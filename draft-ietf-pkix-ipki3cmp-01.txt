Internet Draft                                          S. Farrell (SSE)
PKIX Working Group                                     C. Adams (Nortel)
draft-ietf-pkix-ipki3cmp-01.txt

Expires in 6 months                                        December 1996


Internet Public Key Infrastructure
Part III: Certificate Management Protocols

Status of this Memo 

   This document is an Internet-Draft.  Internet-Drafts are working 
documents of the Internet Engineering Task Force (IETF), its areas, and 
its working groups.  Note that other groups may also distribute working 
documents as Internet-Drafts. 

   Internet-Drafts are draft documents valid for a maximum of 6 months 
and may be updated, replaced, or obsoleted by other documents at any 
time. It is inappropriate to use Internet- Drafts as reference material 
or to cite them other than as "work in progress." 

   To learn the current status of any Internet-Draft, please check the 
"1id-abstracts.txt" listing contained in the Internet-Drafts Shadow 
Directories on ftp.is.co.za(Africa), nic.nordu.net (Europe), 
munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or 
ftp.isi.edu (US West Coast). 

Abstract 

This is the fourth draft of the Internet Public Key Infrastructure X.509 
Certificate Management Protocols. This version builds on draft-ietf-
pkix-ipki3cmp-01.txt and discussions on the PKIX mailing list (ietf-
pkix@tandem.com) and at the Montreal IETF meeting (June 1996).

Summary of changes since the third draft:

- New messages defined to ask for general information from a PKI 
management entity (RA/CA).
- New fields added allowing for:
       proof of possession of a private key; 
       request for publication of a certificate; and 
       request for archival of a private key.
- ASN.1 simplifications.
- First concrete definition of what is mandatory for conformance.
- File- and socket-based protocols defined.

1. Introduction
The layout of this draft is as follows:

- Section 1 contains an overview of PKI management

Farrell, Adams                                               [Page 1]


INTERNET-DRAFT                                         December 1996

- Section 2 contains discussion of assumptions and restrictions
- Section 3 contains data structures used for PKI management messages
- Section 4 defines the functions which are to be carried out in PKI 
management including those which must be supported by conforming 
implementations and those which are optional
- Section 5 describes a simple protocol for transporting PKI messages
1.1 PKI Management Overview 

  The PKI must be structured to be consistent with the types of 
individuals who must administer it.  Providing such administrators with 
unbounded choices not only complicates the software required but also 
increases the chances that a subtle mistake by an administrator or 
software developer will result in broader compromise. Similarly, 
restricting administrators with cumbersome mechanisms will cause them  
not to use the PKI. 

  Management protocols are required to support on-line interactions 
between Public Key Infrastructure (PKI) components.  For example, a 
management protocol might be used between a CA and a client system with 
which a key pair is associated, or between two CAs which cross-certify 
each other. 

2.1 PKI Management Model 

Before specifying particular message formats and procedures we first 
define the entities involved in PKI management and their interactions 
(in terms of the PKI management functions required).  We then group 
these functions in order to accommodate different identifiable types of 
end entities. 

1.2 Definitions of PKI Entities 

  The entities involved in PKI management include the end entity (i.e.  
the entity to be named in the subject field of a certificate) and the 
certification authority (i.e. the entity named in the issuer field of a 
certificate). A registration authority may also be involved in PKI 
management. 

1.2.1 Subjects and End Entities 

The term "subject" is used here to refer to the entity named by the 
subject field of a certificate; when we wish to distinguish the tools 
and/or software used by the subject (e.g. a local certificate management 
module) we will use the term "subject equipment". In general, we prefer 
the term "end entity" rather than subject in order to avoid confusion 
with the field name.

It is important to note that the end entities here will include not only 
human users of applications, but also applications themselves (e.g. for 
IP security). This factor influences the protocols which the PKI 
management operations use; e.g., applications software is far more 
likely to know exactly which certificate extensions are required than 

Farrell, Adams                                              [Page 2]


INTERNET-DRAFT                                         December 1996

are human users. PKI management entities are also end entities in the 
sense that they are sometimes named in the subject field of a 
certificate or cross-certificate. Where appropriate, the term "end- 
entity" will be used to refer to end entities who are not PKI management 
entities. 

All end entities require secure local access to some information -- at a 
minimum, their own name and private key, the name of a CA which is 
directly trusted by this subject and that CA's public key (or a 
fingerprint of the public key where a self-certified version is 
available elsewhere). Implementations may use secure local storage for 
more than this minimum (e.g. the end entity's own certificate or 
application-specific information). The form of storage will also vary -- 
from files to tamper resistant cryptographic tokens.  Such local trusted 
storage is referred to here as the end entity's Personal Security 
Environment (PSE). 

Though PSE formats are out of scope of this document (they are very 
dependent on equipment, et cetera), a generic interchange format for 
PSEs is defined here - a certification response message may be used.

1.2.2 Certification Authority 
The certification authority (CA) may or may not actually be a real 
"third party" from the end entity's point of view. Quite often, the CA 
will actually belong to the same organisation as the end entities it 
supports. 

Again, we use the term CA to refer to the entity named in the issuer 
field of a certificate; when it is necessary to distinguish the software 
or hardware tools used by the CA we use the term "CA equipment". 

The CA equipment will often include both an "off-line" component and an 
"on-line" component, with the CA private key only available to the "off-
line" component. This is, however, a matter for implementers (though it 
is also relevant as a policy issue).

We use the term "root CA" to indicate a CA which is directly trusted 
by an end entity, that is, securely acquiring the value of a root CA 
public key requires some out-of-band step(s). This term does not 
indicate that a root CA is at the top of any hierarchy, simply that the 
CA in question is trusted directly.

A subordinate CA is one which is not a root CA for the end entity in 
question. Often, a subordinate CA will not be a root CA for any entity 
but this is not mandatory.
1.2.3 Registration Authority 
In addition to end entities and CAs, many environments call for the 
existence of a registration authority (RA) separate from the 
certification authority. The functions which the registration authority 
may carry out will vary from case to case but may include personal 
authentication, token distribution, revocation reporting, name 
assignment, key generation, archival of key pairs, et cetera. 


Farrell, Adams                                              [Page 3]

INTERNET-DRAFT                                         December 1996

This document views the RA as an optional component - when it is not 
present the CA is assumed to be able to carry out the RA's functions so 
that the PKI management protocols are the same from the end entity's 
point of view. 

Again, we distinguish, where necessary, between the RA and the tools 
used (the "RA equipment"). 

Note that an RA is itself an end entity. We further assume that all RAs 
are in fact certified end entities and that RA private keys are usable 
for signing. How a particular CA equipment identifies some end entities 
as RAs is an implementation issue (so there is no special RA 
certification operation). We do not mandate that the RA is certified by 
the CA with which it is interacting at the moment (so one RA may work 
with more than one CA whilst only being certified once). 

In some circumstances end entities will communicate directly with a CA 
even where an RA is present. For example, for initial registration 
and/or certification the subject may use its RA, but communicate 
directly with the CA in order to refresh its certificate. 

1.3 PKI Management Requirements 

The protocols given here meet the following requirements on PKI 
management. 

1. PKI management must conform to ISO 9594-8 and the associated 
amendments (certificate extensions) 

2. PKI management must conform to the other parts of this series. 

3. It must be possible to regularly update any key pair without 
affecting any other key pair.

4. The use of confidentiality in PKI management protocols must be kept 
to a minimum in order to ease regulatory problems.

5. PKI management protocols must allow the use of different industry-
standard cryptographic algorithms, (specifically including, RSA, DSA, 
MD5, SHA-1) -- this means that any given CA, RA, or end entity may, in 
principal, use whichever algorithms suit it for its own key pair(s). 

6. PKI management protocols must not preclude the generation of key 
pairs by the end entity concerned, by an RA, or by a CA -- key 
generation may also occur elsewhere, but for the purposes of PKI 
management we can regard key generation as occurring wherever the key is 
first present at an end entity, RA or CA. 

7. PKI management protocols must support the publication of certificates 
by the end entity concerned, by an RA or by a CA.  Different 
implementations and different environments may choose any of the above 

Farrell, Adams                                              [Page 4]


INTERNET-DRAFT                                         December 1996

approaches. 

8. PKI management protocols must support the production of CRLs by 
allowing certified end entities to make requests for the revocation of 
certificates - this must be done in such a way that the denial-of-
service attacks which are possible are not made simpler. 

9. PKI management protocols must be usable over a variety of "transport" 
mechanisms, specifically including mail, http, TCP/IP and ftp. 

10. Final authority for certification creation rests with the CA; no RA 
or end entity equipment should assume that any certificate issued by a 
CA will contain what was requested -- a CA may alter certificate field 
values or may add, delete or alter extensions according to its operating 
policy; the only exception to this is the public key, which the CA may 
not modify (assuming that the CA was presented with the public key 
value). In other words, all PKI entities (end entities, RAs and CAs) 
must be capable of handling responses to requests for certificates in 
which the actual certificate issued is different from that requested -- 
for example, a CA may shorten the validity period requested. 

11. A graceful, scheduled change-over from one non-compromised  CA key 
pair to the next must be supported (CA key update). An end-entity whose 
PSE contains the new CA public key (following a CA key update) must also 
be able to verify certificates verifiable using the old public key. End 
entities who directly trust the old CA key pair must also be able to 
verify certificates signed using the new CA private key.  (Required for 
situations where the old CA public key is "hardwired" into the end 
entity's cryptographic equipment). 

12. The Functions of an RA may, in some implementations or  
environments, be carried out by the CA itself. The protocols must be 
designed so that end entities will use the same protocol regardless of 
whether the communication is with an RA or CA. 

1.4 13. Where an end entity requests a certificate containing a given 
public key value, the end entity must show the ability to use the 
corresponding private key value. This is accomplished in various ways, 
depending on the type of certification request. See the section "Proof 
of Possession of Private Key" for details.

1.5 PKI Management Operations 

  The following diagram shows the relationship between the entities 
defined above in terms of the PKI management operations. The letters in 
the diagram indicate "protocols" in the sense that a defined set of PKI 
management messages can be sent along each of the lettered lines. 

                cert. publish        +------------+ 
      +---+           +------------  | End Entity |   Operations 
      | C |           | g            +------------+ 
      | e |  <--------+                | ^      initial 
      | r |                          a | | b     registration/ 


Farrell, Adams                                              [Page 5]

INTERNET-DRAFT                                         December 1996

      | t |       PKI "users"          | |       certification 
      |   |                            | |      key pair recovery 
      | / |                            | |      key pair update 
      |   |                            | |      certificate update 
      | C |                            V |      revocation request 
      | R |             -------+-+-----+-+------+-+----- 
      | L |   PKI management   | ^              | ^ 
      |   |      entities    a | | b          a | | b 
      |   |                    V |              | | 
      | R |             g   +------+    d       | | 
      | e |   <------------ | RA   | <-----+    | | 
      | p |      cert.      |      | ----+ |    | | 
      | o |       publish   +------+   c | |    | | 
      | s |                              | |    | | 
      | i |                              V |    V | 
      | t |          h                 +------------+   i 
      | o |   <------------------------| CA         |-------> 
      | r |                            +------------+  "out-of-band" 
      | y |      cert. publish              | ^         publication 
      |   |      CRL publish                | | 
      +---+                                 | |    cross-certification 
                                          e | | f  cross-certificate 
                                            | |       update 
                                            | | 
                                            V | 
                                          +------+ 
                                          | CA-2 | 
                                          +------+ 

                           Figure 1 - PKI Entities 

At a high level the set of operations for which management messages are 
defined can be grouped as follows.

1 CA establishment: When establishing a new CA, certain steps are 
required (e.g., production of initial CRLs, export of CA public 
key).
2 End entity initialisation: this includes importing a CA public key 
and requesting information about the options supported by a PKI 
management entity.
3 Certification: various operations result in the creation of new 
certificates:
3.1 initial registration/certification: This is the process whereby a 
subject first makes itself known to a CA or RA, prior to the CA issuing 
a certificate or certificates for that user. The end result of this 
process (when it is successful) is that a CA issues a certificate for an 
end entity's public key, and returns that certificate to the subject 
and/or posts that certificate in a public repository. This process may, 
and typically will, involve multiple "steps", possibly including an 
initialization of the end entity's equipment. For example, the subject 
3.2 
Farrell, Adams                                              [Page 6]


INTERNET-DRAFT                                         December 1996

1.1 equipment must be securely initialized with the public key 
of a CA, to be used in validating certificate paths.  
Furthermore, a subject typically needs to be initialized 
with its own key pair(s). 
1.2 key pair update:  Every key pair needs to be updated 
regularly  (i.e., replaced with a new key pair), and a new 
certificate needs to  be issued. 
1.3 certificate update: As certificates expire they may be 
"refreshed" if nothing relevant in the environment has 
changed. 
1.4 CA key pair update: As with end entities, CA key pairs need 
to be updated regularly; however, different mechanisms are 
required. 
1.5 cross-certification:  Two CAs exchange the information 
necessary to establish cross-certificates between those CAs. 
1.6 cross-certificate update: Similar to a normal certificate 
update  but involving a cross-certificate. 
2 Certificate/CRL discovery operations: some PKI management 
operations result in the publication of certificates or CRLs
2.1 certificate publication: Having gone to the trouble of 
producing  a certificate some means for publishing it is 
needed. 
2.2 CRL publication: As for certificates. 
3 Recovery operations: some PKI management operations are used when 
an end entity has "lost" it's PSE
3.1 key pair recovery:  As an option, user client key materials 
(e.g., a user's private key used for decryption purposes) 
may be backed up by a CA, an RA or a key backup system 
associated with a CA or RA.  If a subject needs to recover 
these backed up key materials (e.g., as a result of a 
forgotten password or a lost key chain file), a  protocol 
exchange may be needed to support such recovery. 
4 Revocation operations: some PKI operations result in the creation 
of new CRL entries and/or new CRLs
4.1 revocation request:  An authorized person advises a CA of an 
abnormal situation requiring certificate revocation. 
5 PSE operations: whilst the definition of PSE operations (e.g. 
moving a PSE, changing a PIN, etc.) are beyond the scope of this 
specification, we do define a PKIMessage which can form the basis 
of such operations.
Note that on-line protocols are not the only way of implementing the 
above operations.  For all operations there are off-line methods of 
achieving the same result, and this specification does not mandate use 
of on-line protocols.  For example, when hardware tokens are used, many 
of the operations may be achieved as part of the physical token 
delivery. 

Later sections define a set of standard protocols supporting the above 
operations.  The protocols for conveying these exchanges in different 
environments (file based, on-line, E-mail, and WWW) may also be 
specified. 


Farrell, Adams                                              [Page 7]


INTERNET-DRAFT                                         December 1996

2. Assumptions and restrictions
2.1 End entity initialisation
The first step for and end entity in dealing with PKI management 
entities is to request information about the PKI functions supported and 
optionally to securely acquire a copy of the relevant root CA public 
key(s).

2.2 Initial registration/certification
There are many schemes which can be used to achieve initial registration 
and certification of end entities. No one method is suitable for all 
situations due to the range of policies which a CA may implement and the 
variation in the types of end entity which can occur.

We can however, classify the initial registration / certification 
schemes which are supported by this specification. Note that the word 
"initial", above, is crucial - we are dealing with the situation where 
the end entity in question has had no previous contact with the PKI. 
Where the end entity already possesses certified keys then some 
simplifications are possible.

Having classified the schemes which are supported by this specification 
we can then specify some as mandatory and some as optional. The goal is 
that the mandatory schemes cover a sufficient number of the cases which 
will arise in real use, whilst the optional schemes are available for 
special cases which arise less frequently. In this way we achieve a 
balance between flexibility and ease of implementation.

We will now describe the classification of initial registration / 
certification schemes.
2.2.1 Criteria used
2.2.1.1 Initiation of registration / certification
In terms of the PKI messages which are produced we can regard the 
initiation of the initial registration / certification exchanges as 
occurring wherever the first PKI message relating to the end entity is 
produced. Note that the real world initiation of the registration / 
certification procedure may occur elsewhere (e.g. a personnel department 
may telephone an RA operator).

The possible locations are: at the end entity, an RA or a CA.
2.2.1.2 End entity message origin authentication
The on-line messages produced by the end entity which requires a 
certificate may be authenticated or not. The requirement here is to 
authenticate the origin of any messages from the end entity to the PKI 
(CA/RA).

In this specification, such authentication is achieved by the PKI 
(CA/RA) issuing the end entity with a secret value (initial 
authentication key) and reference value (used to identify the 
transaction) via some out-of-band means. The initial authentication key 
can then be used to protect relevant PKI messages.

We can thus classify the initial registration/certification scheme 

Farrell, Adams                                              [Page 8]


INTERNET-DRAFT                                         December 1996

according to whether or not the on-line end-entity -> PKI messages are 
authenticated or not.

Note 1: We do not discuss the authentication of the PKI -> end entity 
messages here as this is always required. In any case, it can be 
achieved simply once the root-CA public key has been installed at the 
end entity's equipment or based on the initial authentication key.

Note 2: An initial registration / certification procedure can be secure 
where the messages from the end entity are authenticated via some out-
of-band means (e.g. a subsequent visit).
2.2.1.3 Location of key generation
In this specification, key generation is regarded as occurring wherever 
either the public or private component of a key pair first occurs in a 
PKI message. Note that this does not preclude a centralised key 
generation service - the actual key pair may have been generated 
elsewhere and transported to the end entity, RA or CA.

There are thus three possibilities for the location of key generation: 
the end-entity, an RA or a CA.
2.2.1.4 Confirmation of successful certification
Following the creation of an initial certificate for an end entity, 
additional assurance can be gained by having the end entity explicitly 
confirm successful receipt of the message containing (or indicating the 
creation of) the certificate. Naturally, this confirmation message must 
be protected (based on the initial authentication key or other means).

This gives two further possibilities: confirmed or not.
2.2.2 Mandatory schemes
The criteria above allow for a large number of initial registration / 
certification schemes. This specification mandates that conforming RA/CA 
equipment must support both of the schemes listed below. Conforming end 
entity equipment must support one of the schemes listed below.
2.2.2.1 Centralised scheme
In terms of the classification above, this scheme is where:

- initiation occurs at the certifying CA;
- no on-line message authentication is required;
- key generation occurs at the certifying CA;
- no confirmation message is required.

In terms of message flow, this scheme means that the only message 
required is sent from the CA to the end entity. The message must contain 
the entire PSE for the end entity. Some out-of-band means must be 
provided to allow the end entity to authenticate the message received.
2.2.2.2 Basic authenticated scheme
In terms of the classification above, this scheme is where:

- initiation occurs at the end entity
- message authentication is required
- key generation occurs at the end entity
- a confirmation message is required


Farrell, Adams                                              [Page 9]

INTERNET-DRAFT                                         December 1996

In terms of message flow, the scheme is as follows:

      End entity                                           CA
      ==========                                      =============
                    out-of-band distribution of 
                    initial authentication key and 
                    reference value
      Key generation
      Creation of certification request
      Protect request with IAK
                    -->>--certification request-->>
                                                     verify request
                                                     process request
                                                     create response
                    --<<--certification response--<<--
      handle response
      create confirmation
                    -->>--confirmation message-->>--
                                                     verify confirmation

(Where verification of the confirmation message fails, the CA must 
revoke the newly issued certificate if necessary.)
2.3 Proof of Possession of Private Key
In order to prevent certain attacks, the PKI management operations 
specified here require end-entities to prove that they have possession 
of (i.e., are able to use) the private key corresponding to the public 
key for which a certificate is requested.

This is accomplished in a different ways, depending on the type of key 
for which a certificate is requested. If a key can be used for multiple 
purposes (e.g. an RSA key) then any of the methods may be used.

This specification explicitly allows for cases where an end entity 
supplies the relevant proof to an RA and the RA subsequently attests to 
the CA that the required proof has been received (and validated!). For 
example, an end entity wishing to have a signing key certified could 
send the appropriate signature to the RA which then simply notifies the 
relevant CA that the end entity has supplied the required proof. Of 
course, such a situation may be disallowed by some policies.
2.3.1 Signature Keys
For signature keys, the end-entity can sign a value to prove possession 
of the private key.
2.3.2 Encryption Keys
For encryption keys, the end-entity can be required to decrypt a value 
in order to prove possession of the private key. This can be achieved 
either directly or indirectly. 

The direct method is to issue a random challenge to which an immediate 
response is required.

The indirect method is to issue a certificate which is encrypted for the 

Farrell, Adams                                              [Page 10]


INTERNET-DRAFT                                         December 1996

end entity (and have the end entity demonstrate its ability to decrypt 
this certificate in the confirmation message). This allows a CA to issue 
a certificate in a form which can only be used by the intended end 
entity.

This specification uses the indirect method because this requires no 
extra messages to be sent (i.e., the proof can be demonstrated using the 
{request, response, confirmation} triple of messages).

2.3.3 Key Agreement Keys
For key agreement keys, the end entity and the PKI management entity 
(i.e. CA or RA) must establish a shared secret key in order to prove 
that the end entity has possession of the private key.

Note that this need not impose any restrictions on the keys which can be 
certified by a given CA -- in particular, for Diffie-Hellman keys the 
end entity may freely choose its algorithm parameters -- provided that 
the CA can generate a short-term (or one-time) key pair with the 
appropriate parameters when necessary.

2.4 Root CA key update
This discussion only applies to CAs which are a root CA for some end 
entity.

The basis of the procedure described here is that the CA protects its 
new public key using its previous private key and vice versa. Thus when 
a CA updates its key pair it must generate two new cACertificate 
attribute values if certificates are made available using an X.500 
directory. 

When a CA changes its key pair those entities who have acquired the old 
CA public key via "out-of-band" means are most affected. It is these end 
entities who will need access to the new CA public key protected with 
the old CA private key. However, they will only require this for a 
limited period (until they have acquired the new CA public key via the 
"out-of-band" mechanism). This will typically be easily achieved when 
these end entity's certificates expire. 

The data structure used to protect the new and old CA public keys is a 
standard certificate (which may also contain extensions). There are no 
new data structures required. 

  Notes: 

1.This scheme does not make use of any of the X.509 v3 extensions as it 
should be able to work even for version 1 certificates. The presence of 
the KeyIdentifier extension would make for efficiency improvements. 

2.While the scheme could be generalized to cover cases where the CA 
updates its key pair more than once during the validity period of one of 
its end entity's certificates, this generalization seems of dubious 
value. This means that the validity period of a CA key pair must be 

Farrell, Adams                                              [Page 11]


INTERNET-DRAFT                                         December 1996

greater than the validity period of any certificate issued by that CA 
using that key pair. 

3.This scheme forces end entities to acquire the new CA public key on 
the expiry of the last certificate they owned which was signed with the 
old CA private key (via the "out-of-band" means).  Certificate and/or 
key update operations occurring at other times do not necessarily 
require this (depending on the end entity's equipment). 
2.4.1 CA Operator actions 
  To change the key of the CA, the CA operator does the following: 

  1.Generate a new key pair. 

  2.Create a certificate containing the old CA public key signed with 
the new private key (the "old with new" certificate). 

  3.Create a certificate containing the new CA public key signed with 
the old private key (the "new with old" certificate). 

  4.Create a certificate containing the new CA public key signed with 
the new private key (the "new with new" certificate). 

  5.Publish these new certificates via the directory and/or other means. 
(A CAKeyUpdAnn message.) 

  6.Export the new CA public key so that end entities may acquire it 
using the "out-of-band" mechanism. 

The old CA private key is then no longer required. The old CA public key 
will however remain in use for some time. The time when the old CA 
public key is no longer required (other than for non-repudiation) will 
be when all end entities of this CA have acquired the new CA public key 
via "out-of-band" means. 

The "old with new" certificate should have a validity period starting at 
the generation time of the old key pair and ending at the time at which 
the CA will next update its key pair. 

The "new with old" certificate should have a validity period starting at 
the generation time of the new key pair and ending at the time by which 
all end entities of this CA will securely possess the new CA public key. 

The "new with new" certificate should have a validity period starting at 
the generation time of the new key pair and ending at the time at which 
the CA will next update its key pair. 

2.4.2 Verifying Certificates. 
Normally when verifying a signature the verifier simply(!) verifies the 
certificate containing the public key of the signer. However, once a CA 
is allowed to update its key there are a range of new possibilities. 
These are shown in the table below. 


Farrell, Adams                                              [Page 12]


INTERNET-DRAFT                                         December 1996

            Repository contains NEW     Repository contains only OLD 
              and OLD public keys        public key (due to e.g. 
                                          delay in publication) 

               PSE      PSE Contains  PSE Contains    PSE Contains 
            Contains     OLD public    NEW public      OLD public 
           NEW public       key            key            key 
               key 

Signer's   Case 1:      Case 3:       Case 5:        Case 7: 
certifi-   This is      In this case  Although the   In this case 
cate is    the          the verifier  CA operator    the CA 
protected  standard     must access   has not        operator  has 
using NEW  case where   the           updated the    not updated 
public     the          directory in  directory the  the directory 
key        verifier     order to get  verifier can   and so the 
           can          the value of  verify the     verification 
           directly     the NEW       certificate    will FAIL 
           verify the   public key    directly - 
           certificate                this is thus 
           without                    the same as 
           using the                  case 1. 
           directory 
 
Signer's   Case 2:      Case 4:       Case 6:        Case 8: 
certifi-   In this      In this case  The verifier   Although the 
cate is    case the     the verifier  thinks this    CA operator 
protected  verifier     can directly  is the         has not 
using OLD  must         verify the    situation of   updated the 
public     access the   certificate   case 2 and     directory the 
key        directory    without       will access    verifier can 
           in order     using the     the            verify the 
           to get the   directory     directory,     certificate 
           value of                   however the    directly - 
           the OLD                    verification   this is thus 
           public key                 will FAIL      the same as 
                                                     case 4. 

2.4.2.1 Verification in cases 1, 4, 5 and 8. 
In these cases the verifier has a local copy of the CA public key which 
can be used to verify the certificate directly. This is the same as the 
situation where no key change has ever occurred. 

Note that case 8 may arise between the time when the CA operator has 
generated the new key pair and the time when the CA operator stores the 
updated attributes in the directory. Case 5 can only arise if the CA 
operator has issued both the signer's and verifier's certificates during 
this "gap" (the CA operator should avoid this as it leads to the failure 
cases described below). 
2.4.2.2 Verification in case 2. 
In case 2 the verifier must get access to the old public key of the CA. 
The verifier does the following: 


Farrell, Adams                                              [Page 13]

INTERNET-DRAFT                                         December 1996

1.Lookup the CACertificate attribute in the directory and pick the 
appropriate value (based on validity periods) 
2.Verify that this is correct using the new CA key (which the verifier 
has locally). 
3.If correct then check the signer's certificate using the old CA key. 

Case 2 will arise when the CA operator has issued the signer's 
certificate, then changed key and then issued the verifier's 
certificate, so it is quite a typical case. 

2.4.2.3 Verification in case 3. 
In case 3 the verifier must get access to the new public key of the CA. 
The verifier does the following: 

1.Lookup the CACertificate attribute in the directory and pick the 
appropriate value (based on validity periods).  
2.Verify that this is correct using the old CA key (which the verifier 
has stored locally). 
3.If correct then  check the signer's certificate using the new CA key. 

Case 3 will arise when the CA operator has issued the verifier's 
certificate, then changed key and then issued the signer's certificate, 
so it is also quite a typical case. 

2.4.2.4 Failure of verification in case 6. 
In this case the CA has issued the verifier's PSE containing the new key 
without updating the directory attributes. This means that the verifier 
has no means to get a trustworthy version of the CA's old key and so 
verification fails. 

Note that the failure is the CA operator's fault. 
2.4.2.5 Failure of verification in case 7. 
In this case the CA has issued the signer's certificate protected with 
the new key without updating the directory attributes. This means that 
the verifier has no means to get a trustworthy version of the CA's new 
key and so verification fails. 

Note that the failure is again the CA operator's fault. 
2.4.3 Revocation - Change of CA key 
As we saw above the verification of a certificate becomes more complex 
once the CA is allowed to change its key. This is also true for 
revocation checks as the CA may have signed the CRL using a newer 
private key than the one that is within the user's PSE. 

The analysis of the alternatives is as for certificate verification. 


3. Data Structures 
This section contains descriptions of the data structures required for 
PKI management messages. Section 4 describes constraints on their values 

Farrell, Adams                                              [Page 14]


INTERNET-DRAFT                                         December 1996

and the sequence of events for each of the various PKI management 
operations. Section 5 describes how these may be encapsulated in various 
transport mechanisms. 
3.1 Overall PKI Message 
All of the messages used in PKI management use the following structure:

  PKIMessage ::= SEQUENCE { 
      header           PKIHeader, 
      body             PKIBody, 
      protection   [0] PKIProtection OPTIONAL,
      extraCerts   [1] SEQUENCE OF Certificate OPTIONAL
  }

The PKIHeader contains information which is common to many PKI messages.

The PKIBody contains message-specific information.

The PKIProtection contains bits which protect the PKI message.

The extra certificates field can contain certificates which may be 
useful to the recipient. For example, this can be used by a CA or RA to 
present an end entity with certificates which it needs to verify it's 
own new certificate (if the CA that issued the end entity's certificate 
is not a root CA for the end entity). 

Note also that this field does not necessarily contain a certification 
path - the recipient may have to sort, select from, or otherwise process 
the extra certificates in order to use them.
3.1.1 PKI Message Header 
All PKI messages require some header information for addressing and 
transaction identification. Some of this information will also be 
present in a transport-specific envelope; however, if the PKI message is 
protected then this information is also protected (i.e. we make no 
assumption about secure transport). 

The following data structure is used to contain this information: 

  PKIHeader ::= SEQUENCE { 
      pvno                INTEGER     { ietf-version1 (0) }, 
      sender              GeneralName, 
      -- identifies the sender
      recipient           GeneralName, 
      -- identifies the intended recipient
      messageTime     [0] GeneralizedTime        OPTIONAL, 
      -- time of production of this message (used when sender
      -- believes that the transport will be "suitable"; i.e., 
      -- that the time will still be meaningful upon receipt)
      protectionAlg   [1] AlgorithmIdentifier    OPTIONAL, 
      -- algorithm used for calculation of protection bits
      senderKID       [2] KeyIdentifier          OPTIONAL,
      recipKID        [3] KeyIdentifier          OPTIONAL,


Farrell, Adams                                              [Page 15]


INTERNET-DRAFT                                         December 1996

      -- to identify specific keys used for protection
      transactionID   [4] OCTET STRING           OPTIONAL, 
      -- identifies the transaction, i.e. this will be the same in 
           -- corresponding request, response and confirmation messages
      senderNonce     [5] OCTET STRING           OPTIONAL, 
      recipNonce      [6] OCTET STRING           OPTIONAL, 
      -- nonces used to provide replay protection, senderNonce 
      -- is inserted by the creator of this message; recipNonce 
      -- is a nonce previously inserted in a related message by 
      -- the intended recipient of this message 
      freeText        [7] PKIFreeText            OPTIONAL
      -- this may be used to indicate context-specific 
      -- instructions (this field is intended for human 
      -- consumption) 
  }

  PKIFreeText ::= CHOICE { 
      iA5String  [0] IA5String, 
      bMPString  [1] BMPString
  }

The pvno field is fixed for this version of IPKI.

The sender field contains the name of the sender of the PKIMessage. This 
name (in conjunction with senderKID, if supplied) should be usable to 
verify the protection on the message.  If nothing about the sender is 
known to the sending entity (e.g., in the InitReqContent message, where 
the end entity may not know its own DN, e-mail name, IP address, etc.), 
then the "sender" field must contain a "NULL" value; that is, the 
SEQUENCE OF relative distinguished names is of zero length.  In such a 
case the senderKID field must hold an identifier (i.e., a reference 
number) which indicates to the receiver the appropriate shared secret 
information to use to verify the message.

The recipient field contains the name of the recipient of the 
PKIMessage. This name (in conjunction with recipKID, if supplied) should 
be usable to verify the protection on the message.

The protectionAlg field specifies the algorithm used to protect the 
message. If no protection bits are supplied (PKIProtection is optional) 
then this field must be omitted; if protection bits are supplied then 
this field must be supplied.

senderKID and recipKID are usable to indicate which keys have been used 
to protect the message (recipKID will normally only be required where 
protection of the message uses DH keys).

The transactionID field within the message header is required so that 
the recipient of a response message can correlate this with a previously 
issued request. For example, in the case of an RA there may be many 
requests "outstanding" at a given moment.


Farrell, Adams                                              [Page 16]


INTERNET-DRAFT                                         December 1996

The senderNonce and recipNonce fields protect the PKIMessage against 
replay attacks.

The messageTime field contains the time at which the sender created the 
message. This may be useful to allow end entities to correct their local 
time to be consistent with the time on a central system.

The freeText field may be used to send a human-readable message to the 
recipient.
3.1.2 PKI Message Body 
  PKIBody ::= CHOICE {       -- message-specific body elements 
      ir      [0]  InitReqContent, 
      ip      [1]  InitRepContent, 
      cr      [2]  CertReqContent, 
      cp      [3]  CertRepContent, 
      kur     [4]  KeyUpdReqContent, 
      kup     [5]  KeyUpdRepContent, 
      krr     [6]  KeyRecReqContent, 
      krp     [7]  KeyRecRepContent, 
      rr      [8]  RevReqContent, 
      rp      [9]  RevRepContent, 
      ccr     [10] CrossCertReqContent, 
      ccp     [11] CrossCertRepContent, 
      ckuann  [12] CAKeyUpdAnnContent, 
      cann    [13] CertAnnContent, 
      rann    [14] RevAnnContent, 
      crlann  [15] CRLAnnContent, 
      conf    [16] PKIConfirmContent, 
      nested  [17] NestedMessageContent,
      infor   [18] PKIInfoReqContent,
      infop   [19] PKIInfoRepContent,
      error   [20] ErrorMsgContent
  }

The specific types are described in section 3.3 below.
3.1.3 PKI Message Protection 
Some PKI messages will be protected for integrity. (Note that if an 
asymmetric algorithm is used to protect a message and the relevant 
public component has been certified already, then the origin of message 
can also be authenticated.  On the other hand, if the public component 
is uncertified then the message origin cannot be automatically 
authenticated, but may be authenticated via out-of-band means.) 

When protection is applied the following structure is used: 

  PKIProtection ::= BIT STRING 

The input to the calculation of the protectionBits is the DER encoding 
of the following data structure: 

  ProtectedPart ::= SEQUENCE { 


Farrell, Adams                                              [Page 17]


INTERNET-DRAFT                                         December 1996

      header    PKIHeader, 
      body      PKIBody
  }

Depending on the circumstances the PKIProtection bits may contain a MAC 
or signature. Only the following cases can occur:

- shared secret information

In this case the sender and recipient share secret information 
(established via out-of-band means or from a previous PKI management 
operation). The protection bits will typically contain a MAC value and 
the protectionAlg will be the following:

  PasswordBasedMac ::= OBJECT IDENTIFIER

  PBMParameter ::= SEQUENCE {
      salt                OCTET STRING,
      owf                 AlgorithmIdentifier,
      -- AlgId for a One-Way Function (SHA-1 recommended)
      iterationCount      INTEGER,
      -- number of times the OWF is applied
      mac                 AlgorithmIdentifier
      -- the MAC AlgId (e.g., DES-MAC or Triple-DES-MAC [PKCS #11])
  }

In the above protectionAlg the salt value is appended to the shared 
secret input. The OWF is then applied iterationCount times, where the 
salted secret is the input to the first iteration and, for each 
successive iteration, the input is set to be the output of the previous 
iteration. The output of the final iteration (called "BASEKEY" for 
ease of reference, with a size of "H") is what is used to form the 
symmetric key. If the MAC algorithm requires a K-bit key and K <= H, 
then the most significant K bits of BASEKEY are used. If K > H, then all 
of BASEKEY is used for the most significant H bits of the key, OWF("1" 
|| BASEKEY) is used for the next most significant H bits of the key, 
OWF("2" || BASEKEY) is used for the next most significant H bits of 
the key, and so on, until all K bits have been derived. [Here "N" is 
the ASCII byte encoding the number N and "||" represents 
concatenation.]

- DH key pairs

Where the sender and receiver possess Diffie-Hellman certificates with 
compatible DH parameters, then in order to protect the message the end 
entity must generate a symmetric key based on its private DH key value 
and the DH public key of the recipient of the PKI message. The 
protection bits will typically contain a MAC value keyed with this 
derived symmetric key and the protectionAlg will be the following:.


Farrell, Adams                                              [Page 18]


INTERNET-DRAFT                                         December 1996

  DHBasedMac ::= OBJECT IDENTIFIER

  DHBMParameter ::= SEQUENCE {
      owf                 AlgorithmIdentifier,
      -- AlgId for a One-Way Function (SHA-1 recommended)
      mac                 AlgorithmIdentifier
      -- the MAC AlgId (e.g., DES-MAC or Triple-DES-MAC [PKCS #11])
  }

In the above protectionAlg OWF is applied to the result of the Diffie-
Hellman computation. The OWF output (called "BASEKEY" for ease of 
reference, with a size of "H") is what is used to form the symmetric 
key. If the MAC algorithm requires a K-bit key and K <= H, then the most 
significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is 
used for the most significant H bits of the key, OWF("1" || BASEKEY) 
is used for the next most significant H bits of the key, OWF("2" || 
BASEKEY) is used for the next most significant H bits of the key, and so 
on, until all K bits have been derived. [Here "N" is the ASCII byte 
encoding the number N and "||" represents concatenation.]

- signature

Where the sender possesses a signature key pair it may simply sign the 
PKI message. The protection bits will contain a signature value and the 
protectionAlg will be an AlgorithmIdentifier for a digital signature 
(e.g., md5WithRSAEncryption or dsaWithSha-1). 

- multiple protection

In cases where an end entity sends a protected PKI message to an RA, the 
RA may forward that message to a CA, attaching it's own protection. This 
is accomplished by nesting the entire message sent by the end entity 
within a new PKI message. The structure used is as follows.

  NestedMessageContent ::= ANY 
  -- This will be a PKIMessage

3.2 Common Data Structures 
Before specifying the specific types which may be placed in a PKIBody we 
define some useful data structures which are used in more than one case. 
3.2.1 Requested Certificate Contents 
Various PKI management messages require that the originator of the 
message indicate some of the fields which are required to be present in 
a certificate. The CertTemplate structure allows an end entity or RA to 
specify as much as they wish about the certificate it requires. 
ReqCertContent is basically the same as a Certificate but with all 
fields optional. 

Note that even if the originator completely specifies the contents of a 

Farrell, Adams                                              [Page 19]


INTERNET-DRAFT                                         December 1996

certificate it requires, a CA is free to modify fields within the 
certificate actually issued. 

  CertTemplate ::= SEQUENCE { 
      version    [0] Version               OPTIONAL, 
      -- used to ask for a particular syntax version 
      serial     [1] INTEGER               OPTIONAL, 
      -- used to ask for a particular serial number 
      signingAlg [2] AlgorithmIdentifier   OPTIONAL, 
      -- used to ask the CA to use this alg. for signing the cert 
      subject    [3] Name                  OPTIONAL, 
      validity   [4] OptionalValidity      OPTIONAL, 
      issuer     [5] Name                  OPTIONAL, 
      publicKey  [6] SubjectPublicKeyInfo  OPTIONAL, 
      issuerUID  [7] UniqueIdentifier      OPTIONAL, 
      subjectUID [8] UniqueIdentifier      OPTIONAL, 
      extensions [9] Extensions            OPTIONAL
      -- the extensions which the requester would like in the cert. 
  }

  OptionalValidity ::= SEQUENCE { 
      notBefore  [0] UTCTime OPTIONAL, 
      notAfter   [1] UTCTime OPTIONAL 
  }

3.2.2 Encrypted Values 
Where encrypted values (restricted, in this specification, to be either 
private keys or certificates) are sent in PKI messages the following 
data structure is used. 

  EncryptedValue ::= SEQUENCE { 
      encValue          BIT STRING, 
      -- the encrypted value itself
      intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
      -- the intended algorithm for which the value will be used
      symmAlg       [1] AlgorithmIdentifier  OPTIONAL, 
      -- the symmetric algorithm used to encrypt the value 
      encSymmKey    [2] BIT STRING           OPTIONAL,
      -- the (encrypted) symmetric key used to encrypt the value
      keyAlg        [3] AlgorithmIdentifier  OPTIONAL 
      -- algorithm used to encrypt the symmetric key 
  }

Use of this data structure requires that the creator and intended 
recipient are respectively able to encrypt and decrypt. Typically, this 
will mean that the sender and recipient have, or are able to generate, a 
shared secret key. 

If the recipient of the PKIMessage already possesses a private key 
usable for decryption, then the encSymmKey field may contain a session 

Farrell, Adams                                              [Page 20]


INTERNET-DRAFT                                         December 1996

key encrypted using the recipient's public key. 
3.2.3 Status codes and Failure Information for PKI messages 
All response messages will include some status information. The 
following values are defined. 
   
  PKIStatus ::= INTEGER { 
      granted                (0), 
      -- you got exactly what you asked for 
      grantedWithMods        (1), 
      -- you got something like what you asked for; the 
      -- requester is responsible for ascertaining the differences 
      rejection              (2), 
      -- you don't get it, more information elsewhere in the message
      waiting                (3), 
      -- the request body part has not yet been processed, 
      -- expect to hear more later 
      revocationWarning      (4), 
      -- this message contains a warning that a revocation is 
      -- imminent 
      revocationNotification (5), 
      -- notification that a revocation has occurred 
      keyUpdateWarning       (6)
      -- update already done for the oldCertId specified in 
      -- FullCertTemplate
  }

Responders may use the following syntax to provide more information 
about failure cases. 

  PKIFailureInfo ::= BIT STRING { 
  -- since we can fail in more than one way! 
      badAlg           (0), 
      badMessageCheck  (1) 
      -- more TBS
  }

  PKIStatusInfo ::= SEQUENCE {
      status    PKIStatus, 
      failInfo  PKIFailureInfo  OPTIONAL
  }

3.2.4 Certificate Identification 
In order to identify particular certificates the following data 
structure is used. 

  CertId ::= SEQUENCE { 
      issuer           GeneralName, 
      serialNumber     INTEGER 
  }

3.2.5 "Out-of-band" root CA public key 
Each root CA must be able to publish its current public key via some 

Farrell, Adams                                              [Page 21]


INTERNET-DRAFT                                         December 1996

"out- of-band" means. While such mechanisms are beyond the scope of this 
document, we define data structures which can support such mechanisms. 

There are generally two methods available; either the CA directly 
publishes its public key and associated attributes, or this information 
is available via the Directory (or equivalent) and the CA publishes a 
hash of this value to allow verification of its integrity before use. 

  OOBCert ::= Certificate 

The fields within this certificate are restricted as follows:

- The certificate should be self-signed, i.e. the signature should be 
verifiable using the subjectPublicKey field.
- The subject and issuer fields should be identical.
- If the subject field is NULL then both subjectAltNames and 
issuerAltNames extensions must be present and have exactly the same 
value.
- The values of all other extensions should be suitable for a self-
certificate (e.g. key identifiers for subject and issuer should be 
the same).

  OOBCertHash ::= SEQUENCE { 
      hashAlg     [0] AlgorithmIdentifier     OPTIONAL, 
      certId      [1] CertId                  OPTIONAL, 
      hashVal         BIT STRING
      -- hashVal is calculated over DER encoding of the 
      -- subjectPublicKey field of the corresponding cert. 
  }

The intention of the hash value here is that anyone who has securely 
gotten the hash value (via the out-of-band means) can verify a self-
signed certificate for that CA. The hash value is only calculated over 
the subjectPublicKey field in order to allow the CA to change its self-
signed certificate (e.g. perhaps to modify some policy constraints). 

3.2.6 Archival Options
Requesters may indicate that they wish the PKI to archive a private key 
value using the following structure:

  PKIArchiveOptions ::= CHOICE {
      encryptedPrivKey     [0] EncryptedValue,
      -- the actual value of the private key
      keyGenParameters     [1] KeyGenParameters,
      -- parameters which allow the private key to be re-generated
      archiveRemGenPrivKey [2] BOOLEAN
      -- set to TRUE if sender wishes receiver to archive the private
      -- key of a key pair which the receiver generates in response to
      -- this request; set to FALSE if no archival is desired.
}

  KeyGenParameters ::= OCTET STRING


Farrell, Adams                                              [Page 22]

INTERNET-DRAFT                                         December 1996

      -- actual syntax is <<TBS>>
      -- an alternative to sending the key is to send the information 
      -- about how to re-generate the key (e.g. for many RSA 
      -- implementations one could send the first random number tested 
      -- for primality)

<<Microsoft's PFX stuff could be re-used here?>>
3.2.7 Publication Information
Requesters may indicate that they wish the PKI to publish a certificate 
using the structure below. 

If the dontPublish option is chosen, the requester indicates that the 
PKI should not publish the certificate (this may indicate that the 
requester intends to publish the certificate him/herself).

If the dontCare method is chosen, the requester indicates that the PKI 
may publish the certificate using whatever means it chooses.

The pubLocation field, if supplied, indicates where the requester would 
like the certificate to be found (note that the CHOICE within 
GeneralName includes a URL and an IP address, for example).

  PKIPublicationInfo ::= SEQUENCE {
     action     INTEGER {
                  dontPublish (0),
                  pleasePublish (1)
                },
     pubInfos  SEQUENCE OF SinglePubInfo OPTIONAL
       -- pubInfos should not be present if action is "dontPublish"
       -- (if action is "pleasePublish" and pubInfos is omitted, 
       -- "dontCare" is assumed)
  }

  SinglePubInfo ::= SEQUENCE {
      pubMethod    INTEGER {
          dontCare    (0),
          x500        (1),
          web         (2)
      },
      pubLocation  GeneralName OPTIONAL
  }

3.2.8  "Full" Request Template
The following structure groups together the fields which may be sent as 
part of a certification request:

  FullCertTemplates ::= SEQUENCE OF FullCertTemplate

  FullCertTemplate ::= SEQUENCE {
      certReqId              INTEGER,
      -- to match this request with corresponding response
      -- (note:  must be unique over all FullCertReqs in this message)


Farrell, Adams                                              [Page 23]

INTERNET-DRAFT                                         December 1996

      certTemplate           CertTemplate,
      popoSigningKey     [0] POPOSigningKey      OPTIONAL,
      archiveOptions     [1] PKIArchiveOptions   OPTIONAL,
      publicationInfo    [2] PKIPublicationInfo  OPTIONAL,
      oldCertId          [3] CertId              OPTIONAL
      -- id. of cert. which is being updated by this one
  }

If the certification request is for a signing key pair (i.e., a request 
for a verification certificate), then the proof of possession of the 
private signing key is demonstrated through use of the POPOSigningKey 
structure.

  POPOSigningKey ::= SEQUENCE {
      alg                 AlgorithmIdentifier,
      signature           BIT STRING
      -- the signature (using "alg") on the DER-encoded 
      -- POPOSigningKeyInput structure given below
  }

  POPOSigningKeyInput ::= SEQUENCE {
      authInfo            CHOICE {
          sender              [0] GeneralName,
          -- from PKIHeader (used only if an authenticated identity
          -- has been established for the sender (e.g., a DN from a
          -- previously-issued and currently-valid certificate)
          publicKeyMAC        [1] BIT STRING
          -- used if no authenticated GeneralName currently exists for
          -- the sender; publicKeyMAC contains a password-based MAC
          -- (using the protectionAlg AlgId from PKIHeader) on the
          -- DER-encoded value of publicKey
      }
      publicKey           SubjectPublicKeyInfo    -- from CertTemplate
  }

On the other hand, if the certification request is for an encryption key 
pair (i.e., a request for an encryption certificate), then the proof of 
possession of the private decryption key may be demonstrated by the 
inclusion of the private key (encrypted) in the FullCertTemplate (in the 
PKIArchivalOptions structure). Alternatively (i.e., if the private key 
is not included), the CA may return not the certificate, but an 
encrypted certificate (i.e., the certificate encrypted under a randomly-
generated symmetric key, and the symmetric key encrypted under the 
public key for which the certification request is being made).  The end 
entity proves knowledge of the private decryption key to the CA by 
MACing the PKIConfirm message using a key derived from this symmetric 
key.  [Note that if several FullCertTemplates are included in the 
PKIMessage, then the CA uses a different symmetric key for each 
FullCertTemplate and the MAC uses a key derived from the concatenation 
of all these keys.]  The MACing procedure uses the PasswordBasedMac 
AlgId defined in Section 3.1.


Farrell, Adams                                              [Page 24]


INTERNET-DRAFT                                         December 1996

3.3 Operation-Specific Data Structures 
3.3.1 Initialization Request 
An Initialization request message (InitReq) contains an InitReqContent 
data structure which specifies the requested certificate(s).  Typically, 
SubjectPublicKeyInfo, KeyId, and Validity are the template fields which 
may be supplied for each certificate requested.

  InitReqContent ::= SEQUENCE { 
      protocolEncKey      [0] SubjectPublicKeyInfo  OPTIONAL,
      fullCertTemplates       FullCertTemplates
  }

3.3.2 Initialization Response 
An Initialization response message (InitRep) contains an InitRepContent 
data structure which has for each certificate requested a PKIStatusInfo 
field, a subject certificate, and possibly a private key (normally 
encrypted with a session key, which is itself encrypted with the 
protocolEncKey).  

  InitRepContent ::= CertRepContent

3.3.3 Registration/Certification Request 

A Registration/Certification request message (CertReq) contains a 
CertReqContent data structure which specifies the requested certificate. 

  CertReqContent ::= FullCertTemplates 

3.3.4 Registration/Certification Response 

A registration response message (CertRep) contains a CertRepContent data 
structure which has a CA public key, a status value and optionally 
failure information, a subject certificate, and an encrypted private 
key. 

  CertRepContent ::= SEQUENCE { 
      caPub           [1] Certificate             OPTIONAL, 
      response            SEQUENCE OF CertResponse 
  }

  CertResponse ::= SEQUENCE { 
      certReqId           INTEGER,
      -- to match this response with corresponding request
      status              PKIStatusInfo, 
      certifiedKeyPair    CertifiedKeyPair    OPTIONAL
  }

  CertifiedKeyPair ::= SEQUENCE { 
      certificate     [0] Certificate         OPTIONAL,


Farrell, Adams                                              [Page 25]


INTERNET-DRAFT                                         December 1996

      encryptedCert   [1] EncryptedValue      OPTIONAL,
      privateKey      [2] EncryptedValue      OPTIONAL,
      publicationInfo [3] PKIPublicationInfo  OPTIONAL 
  }

Only one of the failInfo (in PKIStatusInfo) and certificate fields 
should be present in CertRepResponse (depending on the status). For some 
status values (e.g., waiting) neither of the optional fields will be 
present. 

The CertifiedKeyPair structure must contain either a Certificate or an 
EncryptedCert, and an optional EncryptedPrivateKey (i.e. not both a 
Certificate and EncryptedCert).

Given an EncryptedCert and the relevant decryption key the certificate 
may be obtained. The purpose of this is to allow a CA to return the 
value of a certificate, but with the constraint that only the intended 
recipient can obtain the actual certificate. The benefit of this 
approach is that a CA may reply with a certificate even in the absence 
of a proof that the requester is the end entity which can use the 
relevant private key (note that the proof is not obtained until the 
PKIConfirm message is received by the CA). Thus the CA will not have to 
revoke that certificate in the event that something goes wrong.
3.3.5 Key update request content 
For key update requests the following syntax is used.  Typically, 
SubjectPublicKeyInfo, KeyId, and Validity are the template fields which 
may be supplied for each key to be updated. 

  KeyUpdReqContent ::= SEQUENCE { 
      protocolEncKey      [0] SubjectPublicKeyInfo  OPTIONAL, 
      fullCertTemplates   [1] FullCertTemplates     OPTIONAL 
  }

3.3.6 Key Update response content 
For key update responses the syntax used is identical to the 
initialization response.

  KeyUpdRepContent ::= InitRepContent 

3.3.7 Key Recovery Request content 

For key recovery requests the syntax used is identical to the 
initialization request InitReqContent.  Typically, SubjectPublicKeyInfo 
and KeyId are the template fields which may be used to supply a 
signature public key for which a certificate is required.

  KeyRecReqContent ::= InitReqContent 

3.3.8 Key recovery response content 

For key recovery responses the following syntax is used.  For some 

Farrell, Adams                                              [Page 26]


INTERNET-DRAFT                                         December 1996

status values (e.g., waiting) none of the optional fields will be 
present.

  KeyRecRepContent ::= SEQUENCE { 
      status                  PKIStatusInfo,
      newSigCert          [0] Certificate                   OPTIONAL, 
      caCerts             [1] SEQUENCE OF Certificate       OPTIONAL,
      keyPairHist         [2] SEQUENCE OF CertifiedKeyPair  OPTIONAL
  }

3.3.9 Revocation Request Content 
When requesting revocation of a certificate (or several certificates) 
the following data structure is used. The name of the requester is 
present in the PKIHeader structure. 

  RevReqContent ::= SEQUENCE OF RevDetails

  RevDetails ::= SEQUENCE { 
      certDetails         CertTemplate, 
      -- allows requester to specify as much as they can about 
      -- the cert. for which revocation is requested 
      -- (e.g. for cases in which serialNumber is not available)
      revocationReason    ReasonFlags, 
      -- from the DAM, so that CA knows which Dist. point to use
      badSinceDate        GeneralizedTime  OPTIONAL, 
      -- indicates best knowledge of sender 
      crlEntryDetails     Extensions 
      -- requested crlEntryExtensions 
  }

3.3.10 Revocation Response Content 
The response to the above message. If produced, this is sent to the 
requester of the revocation. (A separate revocation announcement message 
may be sent to the subject of the certificate for which revocation was 
requested.) 

  RevRepContent ::= SEQUENCE { 
      status              PKIStatusInfo, 
      revCerts        [0] SEQUENCE OF CertId OPTIONAL, 
      -- identifies the certs for which revocation was requested 
      crls            [1] SEQUENCE OF CertificateList  OPTIONAL 
      -- the resulting CRLs (there may be more than one) 
  }

3.3.11 Cross certification request content 
Cross certification requests use the same syntax as for normal 
certification requests with the restriction that the key should have 
been generated by the requesting CA and should not be sent to the 
responding CA. 

  CrossCertReqContent ::= CertReqContent 


Farrell, Adams                                              [Page 27]


INTERNET-DRAFT                                         December 1996

3.3.12 Cross certification response content 

Cross certification responses use the same syntax as for normal 
certification responses with the restriction that no encrypted private 
key can be sent.

  CrossCertRepContent ::= CertRepContent 

3.3.13 CA Key Update Announcement content 
When a CA updates its own key pair the following data structure may be 
used to announce this event.

  CAKeyUpdAnnContent ::= SEQUENCE { 
      oldWithNew          Certificate, -- old pub signed with new priv 
      newWithOld          Certificate, -- new pub signed with old priv 
      newWithNew          Certificate  -- new pub signed with new priv 
  }

3.3.14 Certificate Announcement 
This data structure may be used to announce the existence of 
certificates. 

Note that this structure (and the CertAnn message itself) is intended to 
be used for those cases (if any) where there is no pre-existing method 
for publication of certificates; it is not intended to be used where, 
for example, X.500 is the method for publication of certificates. 

  CertAnnContent ::= Certificate 

3.3.15 Revocation Announcement 
When a CA has revoked, or is about to revoke, a particular certificate 
it may issue an announcement of this (possibly upcoming) event. 

  RevAnnContent ::= SEQUENCE { 
      status              PKIStatus, 
      certId              CertId, 
      willBeRevokedAt     GeneralizedTime, 
      badSinceDate        GeneralizedTime, 
      crlDetails          Extensions  OPTIONAL 
      -- extra CRL details(e.g., crl number, reason, location, etc.) 
}

A CA may use such an announcement to warn (or notify) a subject that its 
certificate is about to be (or has been) revoked. This would typically 
be used where the request for revocation did not come from the subject 
concerned.

The willBeRevokedAt field contains the time at which a new entry will be 
added to the relevant CRLs.

3.3.16 CRL Announcement 
3.3.17 

Farrell, Adams                                              [Page 28]


INTERNET-DRAFT                                         December 1996

When a CA issues a new CRL (or set of CRLs) the following data structure 
may be used to announce this event. 

  CRLAnnContent ::= SEQUENCE OF CertificateList 

3.3.18 PKI Confirmation content 
This data structure is used in three-way protocols as the final 
PKIMessage. Its content is the same in all cases - actually there is no 
content since the PKIHeader carries all the required information. 

  PKIConfirmContent ::= NULL 

3.3.19 PKI Information Request content

  PKIInfoReqContent ::= BIT STRING {
      caProtEncCert       (0),
      signKeyPairTypes    (1),
      enckeyPairTypes     (2),
      preferredSymmAlg    (3),
      caKeyUpdateInfo     (4),
      currentCRL          (5)
  }

3.3.20 PKI Information Response content
  PKIInfoRepContent ::= SEQUENCE {
      caProtEncCert      [0] Certificate                      OPTIONAL,
      signKeyPairTypes   [1] SEQUENCE OF AlgorithmIdentifier  OPTIONAL,
      encKeypairTypes    [2] SEQUENCE OF AlgorithmIdentifier  OPTIONAL,
      preferredSymmAlg   [3] AlgorithmIdentifier              OPTIONAL,
      caKeyUpdateInfo    [4] CAKeyUpdAnnContent               OPTIONAL,
      currentCRL         [5] CertificateList                  OPTIONAL
  }

3.3.21 Error Message content
  ErrorMsgContent ::= SEQUENCE {
      pKIStatusInfo          PKIStatusInfo,
      errorCode              INTEGER                          OPTIONAL,
      -- implementation-specific error codes
      errorDetails           CHOICE { IA5String, BMPString }  OPTIONAL
      -- implementation-specific error details
  }

4. PKI Management functions
The PKI management functions outlined in section 1 above are described 
in this section.

This section is split into two, the first part dealing with functions 
which are "mandatory" in the sense that all end-entity and CA/RA 
implementations must be able to provide functionality described via one 
of the transport mechanisms defined in section 5. This part is 
effectively the profile of the PKI management functionality which must 
be supported.


Farrell, Adams                                              [Page 29]

INTERNET-DRAFT                                         December 1996

The second part defines "additional" functions.

Note that not all PKI management functions result in the creation of a 
PKI message.
4.1 Mandatory Functions
4.1.1 Root CA initialisation
A newly created root CA must produce a "self-certificate" which is a 
Certificate structure with the profile defined for the "newWithNew" 
certificate issued following a root CA key update.

In  order to make the CA's self certificate useful to end entities which 
do not acquire this information via "out-of-band" means, the CA must 
also produce a fingerprint for its public key. End entities which 
acquire this value securely via some "out-of-band" means can then 
verify the CA's self-certificate and hence the other attributes 
contained therein.

The data structure used to carry the fingerprint is the OOBCertHash.

The root CA must also produce an initial revocation list.

4.1.2 Root CA key update

4.1.3 Subordinate CA initialisation
From the perspective of PKI management protocols the initialisation of a 
subordinate CA is the same as the initialisation of an end-entity. The 
only difference is that the subordinate CA must also produce an initial 
revocation list.
4.1.4 CRL production
Before issuing any certificates a newly established CA (which issues 
CRLs) must produce "empty" versions of each CRL which is to be 
periodically produced.
4.1.5 PKI information request
The above operations produce various data structures which are used in 
PKI management protocols.

When a PKI entity wishes to acquire information about the current status 
of a CA it may send that CA a PKIInfoReq PKIMessage. The response will 
be a PKIInfoRep message.

The CA should respond to the request with a response providing all of 
the information requested by the requester. If some of the information 
cannot be provided then an error message should be returned.

The PKIInfoReq and PKIInfoRep messages are protected using a MAC based 
on shared secret information (i.e., PasswordBasedMAC) or any other 
authenticated means (if the end entity has an existing certificate).
4.1.6 Cross certification
The initiating CA is the CA which will become the subject of the cross-
certificate, the responding CA will become the issuer of the cross-

Farrell, Adams                                              [Page 30]


INTERNET-DRAFT                                         December 1996

certificate. 

The initiating CA must be "up and running" before initiating the cross-
certification operation. 

As with registration/certification there are a few possibilities here. 
4.1.6.1 One-way request-response scheme: 
The cross-certification scheme is essentially a one way operation; that 
is, when successful, this operation results in the creation of one new 
cross-certificate. If the requirement is that cross- certificates be 
created in "both directions" then each CA in turn must initiate a cross-
certification operation (or use another scheme). 

This scheme is suitable where the two CAs in question can already verify 
each other's signatures (they have some common points of trust) or where 
there is an out-of-band verification of the origin of the certification 
request.

The followings steps occur: 

1.The initiating CA gathers the information required for the cross 
certification request; 
2.The initiating CA creates the cross-certification request message 
(CrossCertReq); 
3.The CrossCertReq message is transported to the responding CA; 
4.The responding CA processes the CrossCertReq -- this results in the 
creation of a cross-certification response (CrossCertRep) message; 
5.The CrossCertRep message is transported to the initiating CA; 
6.The initiating CA processes the CrossCertRep (depending on its content 
some looping may be required; that is, the initiating CA may have to 
await further responses or generate a new CrossCertReq for the 
responding CA);
7.The initiating CA creates a PKIConfirm message and transports it to 
the responding CA.

Notes: 

1.The CrossCertReq should contain a "complete" certification request, 
that is, all fields (including e.g. a BasicConstraints extension) should 
be specified by the initiating CA.
2.The CrossCertRep message should contain the verification certificate 
of the responding CA - the initiating CA should then verify this via the 
"out-of-band" mechanism. 
4.1.7 End entity initialisation
As with CAs, end entity's must be initialised. Initialisation of end 
entities requires two steps:

      - acquisition of PKI information
      - out-of-band verification of root-CA public key

4.1.7.1 Acquisition of PKI information
The information required is:


Farrell, Adams                                              [Page 31]

INTERNET-DRAFT                                         December 1996

- the current root-CA public key
- (if the certifying CA is not a root-CA) the certification path from 
the root CA to the certifying CA together with appropriate revocation 
lists
- the algorithms and algorithm parameters which the certifying CA 
supports for each relevant usage

Additional information could be required (e.g. supported extensions
or CA policy information) in order to produce a certification request 
which will be successful. However, for simplicity we do not mandate that 
the end entity acquires this information via the PKI messages. The end 
result is simply that some certification requests may fail (e.g., if the 
end entity wants to generate its own encryption key but the CA doesn't 
allow that).

The required information is acquired as follows:

  - the end entity sends a pKIInfoReq to the certifying CA requesting 
(with the xxxxxx bits set) the information it requires;

  - the certifying CA responds with a pKIInfoRep message which contains 
the requested information.

4.1.8 Certificate Update
When a certificate is due to expire the relevant end entity may request 
that the CA update the certificate - that is, that the CA issue a new 
certificate which differs from the previous one only in terms of PKI 
attributes (serialNumber, validity, some extensions) and is otherwise 
identical.

Two options must be catered for here, where the end entity initiates 
this operation, and where the CA initiates the operation and then 
creates a message informing the end entity of the existence of the new 
certificate.

4.2 Additional Functions

4.2.1 Cross certification
4.2.1.1 Two-way request-response scheme: 
4.2.1.1.1 Overview of Exchange 
This cross certification exchange allows two CAs to simultaneously 
certify each other. This means that each CA will create a certificate 
that contains the CA verification key of the other CA. 

Cross certification is initiated at one CA known as the responder.  The 
CA administrator for the responder identifies the CA it wants to cross 
certify and the responder CA equipment generates an authorization code. 
The responder CA administrator passes this authorization code by out-of-
band means to the requester CA administrator. The requester CA 
administrator enters the authorization code at the requester CA in order 
to initiate the on-line exchange. 


Farrell, Adams                                              [Page 32]


INTERNET-DRAFT                                         December 1996

The authorization code is used for authentication and integrity 
purposes. This is done by generating a symmetric key based on the 
authorization code and using the symmetric key for generating Message 
Authentication Codes (MACs) on all messages exchanged. 

Serial numbers and protocol version are used in the same manner as in 
the above CA-client exchanges. 

4.2.1.1.2 Detailed Description 
The requester CA initiates the exchange by generating a random number 
(requester random number). The requester CA then sends the responder CA 
the message CrossReq. The fields in this message are protected from 
modification with a MAC based on the authorization code. 

Upon receipt of the CrossReq message, the responder CA checks the 
protocol version, saves the requester random number, generates its own 
random number (responder random number) and validates the MAC. It then 
generates and archives a new requester certificate which contains the 
requester CA public key and is signed with the responder CA signature 
private key. The responder CA responds with the message CrossRep. The 
fields in this message are protected from modification with a MAC based 
on the authorization code. 

Upon receipt of the CrossRep message,  the requester CA checks that its 
own system time is close to the responder CA system time, checks the 
received random numbers and validates the MAC. It then generates and 
archives a new responder certificate which contains the responder CA 
public key and is signed by the requester CA signature private key.  The 
requester CA responds with the message PKIConfirm. The fields in this 
message are protected from modification with a MAC based on the 
authorization code. 

Upon receipt of the PKIConfirm message, the responder CA checks the 
random numbers, archives the responder certificate, and validates the 
MAC. It writes both the request and responder certificates to the 
Directory. It then responds with its own PKIConfirm message. The fields 
in this message are protected from modification with a MAC based on the 
authorization code. 

Upon receipt of the PKIConfirm message, the requester CA checks the 
random numbers and validates the MAC. The requester CA writes both the 
requester and responder certificates to the Directory. 
4.2.2 End entity initialisation
As with CAs, end entities must be initialised. Initialisation of end 
entities requires two steps:

      - acquisition of PKI information
      - out-of-band verification of root-CA public key

4.2.2.1 Acquisition of PKI information
See previous section.


Farrell, Adams                                              [Page 33]


INTERNET-DRAFT                                         December 1996

4.2.2.2 Import of CA key fingerprint
An end entity must possess the public key of it's root CA. One method to 
achieve this is to provide the end entity with the CA's public key 
fingerprint via some secure "out-of-band" means. The end entity can 
then securely use the CA's self-certificate.

The data structure used is the OOBcertHash

5. Transports 
The transport protocols specified below allow end entities, RAs and CAs 
to pass PKI messages between them. There should be no requirement for 
specific security mechanisms to be applied at this level as the PKI 
messages should be suitably protected.

Caution should be taken that no "password" encrypted value is sent 
across a network using these protocols. If values are to be encrypted 
based on passwords then they should be transported using off-line means 
(e.g. files).
5.1 File based protocol
A file containing a PKI message should contain only the DER encoding of 
one PKI message, i.e. there should be no extraneous header or trailer 
information in the file.

Such files can be used to transport PKI messages using e.g. FTP. 
5.2 Socket based Management Protocol 
The following simple socket based protocol is to be used for transport 
of PKI messages. This protocol is suitable for cases where an end entity 
(or an RA) initiates a transaction and can poll to pick up the results. 

If a transaction is initiated by a PKI entity (RA or CA) then an end 
entity must either supply a listener process or be supplied with a 
polling reference (see below) in order to allow it to pick up the PKI 
message from the PKI management component.

The protocol basically assumes a listener process (on an RA or CA) which 
can accept PKI messages on a well defined port (port number TBS). 
Typically an initiator binds to this port and submits the initial PKI 
message for a given transaction ID. The responder replies with a PKI 
message and/or with a reference number to be used later when polling for 
the actual PKI message response. 

If a number of PKI response messages are to be produced for a given 
request (say if some part of the request is handled more quickly than 
another) then a new polling reference is also returned.

When the final PKI response message has been picked up by the initiator 
then no new polling reference is supplied.

The initiator of a transaction sends a "socket PKI message" to the 
recipient. The recipient responds with a similar message.



Farrell, Adams                                              [Page 34]


INTERNET-DRAFT                                         December 1996

A "socket PKI message" consists of:

      length (32-bits), flag (8-bits), value (defined below)

The length field contains the number of octets of the remainder of the 
message (i.e. number of octets of "value" plus one).

Message name
flag
value
comment




msgReq        `00'H  DER-encoded PKI message      PKI message from initiator
pollRep       `01'H  polling reference (32-bits)  poll response where no PKI 
                                                  message response ready; use 
                                                  polling reference value for 
                                                  later polling
pollReq       `02'H  polling reference (32 bits)  request for a PKI message 
                                                  response to initial message
negPollRep    `03'H  `00'H                        no further polling responses 
                                                  (i.e., transaction complete)
partialMsgRep `04'H  next polling reference       partial response to initial
                     (32-bits),                   message plus new polling
                     DER encoded PKI message      reference to use to get next
                                                  part of response
finalMsgRep   `05'H  DER encoded PKI message      final (and possibly sole) 
                                                  response to initial message
errorMsgRep   `06'H  human readable error         produced when an error is
                     message                      detected (e.g., a polling
                                                  reference is received which 
                                                  doesn't exist or is finished 
                                                  with)

Where a PKIConfirm message is to be transported (always from the 
initiator to the responder) then a msgReq message is sent and a 
negPollRep is returned.

The sequence of messages which can occur is then:

a) end entity sends msgReq and receives one of pollRep, negPollRep, 
partialMsgRep or finalMsgRep in response.
b) end entity sends pollReq message and receives one of negPollRep, 
partialMsgRep, finalMsgRep or ErrorMsgRep in response.
5.3 Management Protocol via E-mail 

  << To be supplied.  This subsection will specify a means for 
  conveying ASN.1-encoded messages for the protocol exchanges described 
  in Section 4 via Internet mail. >> 


Farrell, Adams                                              [Page 35]

INTERNET-DRAFT                                         December 1996

5.4 Management Protocol via HTTP 

  << To be supplied.  This subsection will specify a means for 
  conveying ASN.1-encoded messages for the protocol exchanges described 
  in Section 4 over WWW browser-server links, employing HTTP or related 
  WWW protocols. >> 

6. SAMPLES 

<<TBS>>

SECURITY CONSIDERATIONS 

   This entire memo is about security mechanisms. 

One cryptographic consideration is worth explicitly spelling out. In the 
protocols specified above, when an end entity is required to prove 
possession of a decryption key, it is effectively challenged 
to decrypt something (its own certificate). This scheme (and many 
others!) could be vulnerable to an attack if the possessor of the 
decryption key in question could be fooled into decrypting an arbitrary 
challenge and returning the cleartext to an attacker. Although in this 
specification a number of other failures in security are required in 
order for this attack to succeed, it is conceivable that some future 
services (e.g., notary, trusted time) could potentially be vulnerable to 
such attacks. For this reason we re-iterate the general rule that 
implementations should be very careful about decrypting arbitrary 
"ciphertext" and revealing recovered "plaintext" since such a 
practice can lead to serious security vulnerabilities.



Authors' Addresses 

   Stephen Farrell 
   Software and Systems Engineering Ltd. 
   Fitzwilliam Court 
   Leeson Close 
   Dublin 2 
   IRELAND 
   stephen.farrell@sse.ie 

   Carlisle Adams 
   Nortel Secure Networks 
   PO Box 3511, Station C 
   Ottawa, Ontario 
   Canada K1Y 4H7 
   cadams@entrust.com 



APPENDIX A: Reasons for the presence of RAs

The reasons which justify the presence of an RA can be split into those 
which are due to technical factors and those which are organizational in 
nature. Technical reasons include the following. 

  -If hardware tokens are in use, then not all end entities will have 
the equipment needed to initialize these; the RA equipment can include 
the necessary functionality (this may also be a matter of policy). 

  -Some end entities may not have the capability to publish 
certificates; again, the RA may be suitably placed for this. 

  -The RA will be able to issue signed revocation requests on behalf of 
end entities associated with it, whereas the end entity may not be able 
to do this (if the key pair is completely lost). 


Farrell, Adams                                              [Page 36]


INTERNET-DRAFT                                         December 1996

  Some of the organisational reasons which argue for the presence of an 
RA are the following. 

  -It may be more cost effective to concentrate functionality in the RA 
equipment than to supply functionality to all end entities  (especially 
if special token initialization equipment is to be used). 

  -Establishing RAs within an organization can reduce the number of CAs 
required, which is sometimes desirable. 

  -RAs may be better placed to identify people with their "electronic" 
names, especially if the CA is physically remote from the end entity. 

  -For many applications there will already be in place some 
administrative structure so that candidates for the role of RA are easy 
to find (which may not be true of the CA). 


Appendix B. PKI management message profiles.

This appendix contains detailed profiles for those PKIMessages which 
must be supported by conforming implementations.

Profiles for the PKIMessages used in the following PKI management 
operations are provided:

- root CA key update
- information  request/reponse
- cross-certification (1-way)
- initial registration and certification
	- centralised scheme
	- basic authenticated scheme

<<Later revisions will extend the above to include profiles for the 
operations listed below>>

- certificate update
	- end entity initiated
	- PKI initiated
- key update
- revocation request
- certificate publcation
- CRL publication
1. General Rules for interpretation of these profiles.

1. Where fields are not mentioned in individual profiles then they 
should be absent (if OPTIONAL or DEFAULT) from the relevant 
message. For example, pvno is never mentioned since it is always 
fixed for this version of the specification.
2. Where structures occur in more than one message, they are 
separately profiled as appropriate.
3. The algorithmIdentifiers from PKIMessage structures are profiled 
separately.
4. A "special" X.500 DN is called the "NULL-DN"; this means a DN 
containing a zero-
5. 
Farrell, Adams                                              [Page 37]


INTERNET-DRAFT                                         December 1996

1. length SEQUENCE OF rdns (it's DER encoding is then `3000'H).
2. Where a GeneralName is required for a field but no suitable 
value is available (e.g. an end-entity produces a request before 
knowing its name) then the GeneralName is to be an X.500 NULL-DN 
(i.e. the Name field of the CHOICE is to contain a NULL-DN). 
This special value can be called a "NULL-GeneralName".
3. Where a profile omits to specify the value for a GeneralName 
then the NULL-GeneralName value is to be present in the relevant 
PKIMessage field. This occurs with the sender field of the 
PKIHeader for some messages.
4. Where any ambiguity arises due to naming of fields, the profile 
names these using a "dot" notation (e.g., 
"certTemplate.subject" means the subject field within a field 
called certTemplate).
5. Where a "SEQUENCE OF types" is part of a message, a zero-based 
array notation is used to describe fields within the SEQUENCE OF 
(e.g., FullCertTemplates[0].certTemplate.subject refers to a 
subfield of the first FullCertTemplate contained in a request 
message).
6. All PKI message exchanges (other than the centralised initial 
registration/certification scheme) require a PKIConfirm message 
to be sent by the initiating entity.  This message is not 
included in many of the profiles given below since its body is 
NULL and its header contents are clear from the context.  Any 
authenticated means can be used for the protectionAlg (e.g., 
password-based MAC, if shared secret information is known, or 
signature).


<<profiles TBS>>


Appendix C: "Compilable" ASN.1 Module


  PKIMessage ::= SEQUENCE { 
      header           PKIHeader, 
      body             PKIBody, 
      protection   [0] PKIProtection OPTIONAL,
      extraCerts   [1] SEQUENCE OF Certificate OPTIONAL


Farrell, Adams                                              [Page 38]


INTERNET-DRAFT                                         December 1996

  }

  PKIHeader ::= SEQUENCE { 
      pvno                INTEGER     { ietf-version1 (0) }, 
      sender              GeneralName, 
      -- identifies the sender
      recipient           GeneralName, 
      -- identifies the intended recipient
      messageTime     [0] GeneralizedTime        OPTIONAL, 
      -- time of production of this message (used when sender
      -- believes that the transport will be "suitable"; i.e., 
      -- that the time will still be meaningful upon receipt)
      protectionAlg   [1] AlgorithmIdentifier    OPTIONAL, 
      -- algorithm used for calculation of protection bits
      senderKID       [2] KeyIdentifier          OPTIONAL,
      recipKID        [3] KeyIdentifier          OPTIONAL,
      -- to identify specific keys used for protection
      transactionID   [4] OCTET STRING           OPTIONAL, 
      -- identifies the transaction, i.e. this will be the same in 
           -- corresponding request, response and confirmation messages
      senderNonce     [5] OCTET STRING           OPTIONAL, 
      recipNonce      [6] OCTET STRING           OPTIONAL, 
      -- nonces used to provide replay protection, senderNonce 
      -- is inserted by the creator of this message; recipNonce 
      -- is a nonce previously inserted in a related message by 
      -- the intended recipient of this message 
      freeText        [7] PKIFreeText            OPTIONAL
      -- this may be used to indicate context-specific 
      -- instructions (this field is intended for human 
      -- consumption) 
  }

  PKIFreeText ::= CHOICE { 
      iA5String  [0] IA5String, 
      bMPString  [1] BMPString
  }

  PKIBody ::= CHOICE {       -- message-specific body elements 
      ir      [0]  InitReqContent, 
      ip      [1]  InitRepContent, 
      cr      [2]  CertReqContent, 
      cp      [3]  CertRepContent, 
      kur     [4]  KeyUpdReqContent, 
      kup     [5]  KeyUpdRepContent, 
      krr     [6]  KeyRecReqContent, 
      krp     [7]  KeyRecRepContent, 
      rr      [8]  RevReqContent, 
      rp      [9]  RevRepContent, 
      ccr     [10] CrossCertReqContent, 
      ccp     [11] CrossCertRepContent, 
      ckuann  [12] CAKeyUpdAnnContent, 
      cann    [13] CertAnnContent, 


Farrell, Adams                                              [Page 39]

INTERNET-DRAFT                                         December 1996

      rann    [14] RevAnnContent, 
      crlann  [15] CRLAnnContent, 
      conf    [16] PKIConfirmContent, 
      nested  [17] NestedMessageContent,
      infor   [18] PKIInfoReqContent,
      infop   [19] PKIInfoRepContent,
      error   [20] ErrorMsgContent
  }

  PKIProtection ::= BIT STRING 

  ProtectedPart ::= SEQUENCE { 
      header    PKIHeader, 
      body      PKIBody
  }

  PasswordBasedMac ::= OBJECT IDENTIFIER

  PBMParameter ::= SEQUENCE {
      salt                OCTET STRING,
      owf                 AlgorithmIdentifier,
      -- AlgId for a One-Way Function (SHA-1 recommended)
      iterationCount      INTEGER,
      -- number of times the OWF is applied
      mac                 AlgorithmIdentifier
      -- the MAC AlgId (e.g., DES-MAC or Triple-DES-MAC [PKCS #11])
  }

  DHBasedMac ::= OBJECT IDENTIFIER

  DHBMParameter ::= SEQUENCE {
      owf                 AlgorithmIdentifier,
      -- AlgId for a One-Way Function (SHA-1 recommended)
      mac                 AlgorithmIdentifier
      -- the MAC AlgId (e.g., DES-MAC or Triple-DES-MAC [PKCS #11])
  }

  NestedMessageContent ::= ANY 
  -- This will be a PKIMessage

  CertTemplate ::= SEQUENCE { 
      version    [0] Version               OPTIONAL, 
      -- used to ask for a particular syntax version 
      serial     [1] INTEGER               OPTIONAL, 
      -- used to ask for a particular serial number 
      signingAlg [2] AlgorithmIdentifier   OPTIONAL, 
      -- used to ask the CA to use this alg. for signing the cert 
      subject    [3] Name                  OPTIONAL, 
      validity   [4] OptionalValidity      OPTIONAL, 
      issuer     [5] Name                  OPTIONAL, 
      publicKey  [6] SubjectPublicKeyInfo  OPTIONAL, 
      issuerUID  [7] UniqueIdentifier      OPTIONAL, 


Farrell, Adams                                              [Page 40]

INTERNET-DRAFT                                         December 1996

      subjectUID [8] UniqueIdentifier      OPTIONAL, 
      extensions [9] Extensions            OPTIONAL
      -- the extensions which the requester would like in the cert. 
  }

  OptionalValidity ::= SEQUENCE { 
      notBefore  [0] UTCTime OPTIONAL, 
      notAfter   [1] UTCTime OPTIONAL 
  }

  EncryptedValue ::= SEQUENCE { 
      encValue          BIT STRING, 
      -- the encrypted value itself
      intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
      -- the intended algorithm for which the value will be used
      symmAlg       [1] AlgorithmIdentifier  OPTIONAL, 
      -- the symmetric algorithm used to encrypt the value 
      encSymmKey    [2] BIT STRING           OPTIONAL,
      -- the (encrypted) symmetric key used to encrypt the value
      keyAlg        [3] AlgorithmIdentifier  OPTIONAL 
      -- algorithm used to encrypt the symmetric key 
  }

  PKIStatus ::= INTEGER { 
      granted                (0), 
      -- you got exactly what you asked for 
      grantedWithMods        (1), 
      -- you got something like what you asked for; the 
      -- requester is responsible for ascertaining the differences 
      rejection              (2), 
      -- you don't get it, more information elsewhere in the message
      waiting                (3), 
      -- the request body part has not yet been processed, 
      -- expect to hear more later 
      revocationWarning      (4), 
      -- this message contains a warning that a revocation is 
      -- imminent 
      revocationNotification (5), 
      -- notification that a revocation has occurred 
      keyUpdateWarning       (6)
      -- update already done for the oldCertId specified in 
      -- FullCertTemplate
  }

  PKIFailureInfo ::= BIT STRING { 
  -- since we can fail in more than one way! 
      badAlg           (0), 
      badMessageCheck  (1) 
      -- more TBS
  }

  PKIStatusInfo ::= SEQUENCE {


Farrell, Adams                                              [Page 41]

INTERNET-DRAFT                                         December 1996

      status    PKIStatus, 
      failInfo  PKIFailureInfo  OPTIONAL
  }

  CertId ::= SEQUENCE { 
      issuer           GeneralName, 
      serialNumber     INTEGER 
  }

  OOBCert ::= Certificate 

  OOBCertHash ::= SEQUENCE { 
      hashAlg     [0] AlgorithmIdentifier     OPTIONAL, 
      certId      [1] CertId                  OPTIONAL, 
      hashVal         BIT STRING
      -- hashVal is calculated over DER encoding of the 
      -- subjectPublicKey field of the corresponding cert. 
  }

  PKIArchiveOptions ::= CHOICE {
      encryptedPrivKey     [0] EncryptedValue,
      -- the actual value of the private key
      keyGenParameters     [1] KeyGenParameters,
      -- parameters which allow the private key to be re-generated
      archiveRemGenPrivKey [2] BOOLEAN
      -- set to TRUE if sender wishes receiver to archive the private
      -- key of a key pair which the receiver generates in response to
      -- this request; set to FALSE if no archival is desired.
}

  KeyGenParameters ::= OCTET STRING
      -- actual syntax is <<TBS>>
      -- an alternative to sending the key is to send the information 
      -- about how to re-generate the key (e.g. for many RSA 
      -- implementations one could send the first random number tested 
      -- for primality)

  PKIPublicationInfo ::= SEQUENCE {
     action     INTEGER {
                  dontPublish (0),
                  pleasePublish (1)
                },
     pubInfos  SEQUENCE OF SinglePubInfo OPTIONAL
       -- pubInfos should not be present if action is "dontPublish"
       -- (if action is "pleasePublish" and pubInfos is omitted, 
       -- "dontCare" is assumed)
  }

  SinglePubInfo ::= SEQUENCE {
      pubMethod    INTEGER {
          dontCare    (0),
          x500        (1),


Farrell, Adams                                              [Page 42]

INTERNET-DRAFT                                         December 1996

          web         (2)
      },
      pubLocation  GeneralName OPTIONAL
  }

  FullCertTemplates ::= SEQUENCE OF FullCertTemplate

  FullCertTemplate ::= SEQUENCE {
      certReqId              INTEGER,
      -- to match this request with corresponding response
      -- (note:  must be unique over all FullCertReqs in this message)
      certTemplate           CertTemplate,
      popoSigningKey     [0] POPOSigningKey      OPTIONAL,
      archiveOptions     [1] PKIArchiveOptions   OPTIONAL,
      publicationInfo    [2] PKIPublicationInfo  OPTIONAL,
      oldCertId          [3] CertId              OPTIONAL
      -- id. of cert. which is being updated by this one
  }

  POPOSigningKey ::= SEQUENCE {
      alg                 AlgorithmIdentifier,
      signature           BIT STRING
      -- the signature (using "alg") on the DER-encoded 
      -- POPOSigningKeyInput structure given below
  }

  POPOSigningKeyInput ::= SEQUENCE {
      authInfo            CHOICE {
          sender              [0] GeneralName,
          -- from PKIHeader (used only if an authenticated identity
          -- has been established for the sender (e.g., a DN from a
          -- previously-issued and currently-valid certificate)
          publicKeyMAC        [1] BIT STRING
          -- used if no authenticated GeneralName currently exists for
          -- the sender; publicKeyMAC contains a password-based MAC
          -- (using the protectionAlg AlgId from PKIHeader) on the
          -- DER-encoded value of publicKey
      },
      publicKey           SubjectPublicKeyInfo    -- from CertTemplate
  }

  InitReqContent ::= SEQUENCE { 
      protocolEncKey      [0] SubjectPublicKeyInfo  OPTIONAL,
      fullCertTemplates       FullCertTemplates
  }

  InitRepContent ::= CertRepContent

  CertReqContent ::= FullCertTemplates 

  CertRepContent ::= SEQUENCE { 
      caPub           [1] Certificate             OPTIONAL, 


Farrell, Adams                                              [Page 43]

INTERNET-DRAFT                                         December 1996

      response            SEQUENCE OF CertResponse 
  }

  CertResponse ::= SEQUENCE { 
      certReqId           INTEGER,
      -- to match this response with corresponding request
      status              PKIStatusInfo, 
      certifiedKeyPair    CertifiedKeyPair    OPTIONAL
  }

  CertifiedKeyPair ::= SEQUENCE { 
      certificate     [0] Certificate         OPTIONAL,
      encryptedCert   [1] EncryptedValue      OPTIONAL,
      privateKey      [2] EncryptedValue      OPTIONAL,
      publicationInfo [3] PKIPublicationInfo  OPTIONAL 
  }

  KeyUpdReqContent ::= SEQUENCE { 
      protocolEncKey      [0] SubjectPublicKeyInfo  OPTIONAL, 
      fullCertTemplates   [1] FullCertTemplates     OPTIONAL 
  }

  KeyUpdRepContent ::= InitRepContent 

  KeyRecReqContent ::= InitReqContent 

  KeyRecRepContent ::= SEQUENCE { 
      status                  PKIStatusInfo,
      newSigCert          [0] Certificate                   OPTIONAL, 
      caCerts             [1] SEQUENCE OF Certificate       OPTIONAL,
      keyPairHist         [2] SEQUENCE OF CertifiedKeyPair  OPTIONAL
  }

  RevReqContent ::= SEQUENCE OF RevDetails

  RevDetails ::= SEQUENCE { 
      certDetails         CertTemplate, 
      -- allows requester to specify as much as they can about 
      -- the cert. for which revocation is requested 
      -- (e.g. for cases in which serialNumber is not available)
      revocationReason    ReasonFlags, 
      -- from the DAM, so that CA knows which Dist. point to use
      badSinceDate        GeneralizedTime  OPTIONAL, 
      -- indicates best knowledge of sender 
      crlEntryDetails     Extensions 
      -- requested crlEntryExtensions 
  }

  RevRepContent ::= SEQUENCE { 
      status              PKIStatusInfo, 
      revCerts        [0] SEQUENCE OF CertId OPTIONAL, 
      -- identifies the certs for which revocation was requested 


Farrell, Adams                                              [Page 44]

INTERNET-DRAFT                                         December 1996

      crls            [1] SEQUENCE OF CertificateList  OPTIONAL 
      -- the resulting CRLs (there may be more than one) 
  }

  CrossCertReqContent ::= CertReqContent 

  CrossCertRepContent ::= CertRepContent 

  CAKeyUpdAnnContent ::= SEQUENCE { 
      oldWithNew          Certificate, -- old pub signed with new priv 
      newWithOld          Certificate, -- new pub signed with old priv 
      newWithNew          Certificate  -- new pub signed with new priv 
  }

  CertAnnContent ::= Certificate 

  RevAnnContent ::= SEQUENCE { 
      status              PKIStatus, 
      certId              CertId, 
      willBeRevokedAt     GeneralizedTime, 
      badSinceDate        GeneralizedTime, 
      crlDetails          Extensions  OPTIONAL 
      -- extra CRL details(e.g., crl number, reason, location, etc.) 
}

  CRLAnnContent ::= SEQUENCE OF CertificateList 

  PKIConfirmContent ::= NULL 

  PKIInfoReqContent ::= BIT STRING {
      caProtEncCert       (0),
      signKeyPairTypes    (1),
      enckeyPairTypes     (2),
      preferredSymmAlg    (3),
      caKeyUpdateInfo     (4),
      currentCRL          (5)
  }

  PKIInfoRepContent ::= SEQUENCE {
      caProtEncCert      [0] Certificate                      OPTIONAL,
      signKeyPairTypes   [1] SEQUENCE OF AlgorithmIdentifier  OPTIONAL,
      encKeypairTypes    [2] SEQUENCE OF AlgorithmIdentifier  OPTIONAL,
      preferredSymmAlg   [3] AlgorithmIdentifier              OPTIONAL,
      caKeyUpdateInfo    [4] CAKeyUpdAnnContent               OPTIONAL,
      currentCRL         [5] CertificateList                  OPTIONAL
  }

  ErrorMsgContent ::= SEQUENCE {
      pKIStatusInfo          PKIStatusInfo,
      errorCode              INTEGER                          OPTIONAL,
      -- implementation-specific error codes
      errorDetails           CHOICE { IA5String, BMPString }  OPTIONAL


Farrell, Adams                                              [Page 45]

INTERNET-DRAFT                                         December 1996

      -- implementation-specific error details
  }


