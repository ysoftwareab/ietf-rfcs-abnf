


Network                                                         B. Welch
Internet-Draft                                                 B. Halevy
Expires: December 11, 2005                                       Panasas
                                                              G. Goodson
                                                                  NetApp
                                                                D. Black
                                                                     EMC
                                                              A. Adamson
                                                                    CITI
                                                            June 9, 2005


                            pNFS Operations
                      draft-welch-pnfs-ops-02.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on December 11, 2005.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   This Internet-Draft provides a description of the pNFS extension for
   NFSv4.



Welch, et al.           Expires December 11, 2005               [Page 1]

Internet-Draft               pNFS Operations                   June 2005


   The key feature of the protocol extension is the ability for clients
   to perform read and write operations that go directly from the client
   to individual storage system elements without funneling all such
   accesses through a single file server.  Of course, the file server
   must coordinate the client I/O so that the file system retains its
   integrity.

   The extension adds operations that query and manage layout
   information that allows parallel I/O between clients and storage
   system elements.  The layouts are managed in a similar way as
   delegations in that they have leases and can be recalled by the
   server, but layout information is independent of delegations.

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

































Welch, et al.           Expires December 11, 2005               [Page 2]

Internet-Draft               pNFS Operations                   June 2005


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5
   2.  General Definitions  . . . . . . . . . . . . . . . . . . . . .  7
     2.1   Metadata Server  . . . . . . . . . . . . . . . . . . . . .  7
     2.2   Client . . . . . . . . . . . . . . . . . . . . . . . . . .  7
     2.3   Storage Device . . . . . . . . . . . . . . . . . . . . . .  7
     2.4   Storage Protocol . . . . . . . . . . . . . . . . . . . . .  8
     2.5   Management Protocol  . . . . . . . . . . . . . . . . . . .  8
     2.6   Metadata . . . . . . . . . . . . . . . . . . . . . . . . .  8
     2.7   Layout . . . . . . . . . . . . . . . . . . . . . . . . . .  9
   3.  Layouts and Aggregation  . . . . . . . . . . . . . . . . . . .  9
     3.1   Layout Structure . . . . . . . . . . . . . . . . . . . . .  9
       3.1.1   Device IDs . . . . . . . . . . . . . . . . . . . . . . 10
       3.1.2   Aggregation Schemes  . . . . . . . . . . . . . . . . . 10
     3.2   Basic Layout Semantics . . . . . . . . . . . . . . . . . . 10
       3.2.1   Layout Iomode  . . . . . . . . . . . . . . . . . . . . 11
       3.2.2   Operation Sequencing . . . . . . . . . . . . . . . . . 11
     3.3   Obtaining a Layout . . . . . . . . . . . . . . . . . . . . 12
       3.3.1   Identifying Layouts  . . . . . . . . . . . . . . . . . 12
       3.3.2   Overlapping Layouts  . . . . . . . . . . . . . . . . . 12
       3.3.3   Copy-on-write  . . . . . . . . . . . . . . . . . . . . 13
     3.4   Recalling a Layout . . . . . . . . . . . . . . . . . . . . 13
     3.5   Committing a Layout  . . . . . . . . . . . . . . . . . . . 13
       3.5.1   LAYOUTCOMMIT and EOF . . . . . . . . . . . . . . . . . 14
     3.6   Lease Renewals . . . . . . . . . . . . . . . . . . . . . . 15
   4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 15
     4.1   File Layout Security . . . . . . . . . . . . . . . . . . . 17
     4.2   Object Layout Security . . . . . . . . . . . . . . . . . . 17
     4.3   Block Layout Security  . . . . . . . . . . . . . . . . . . 18
   5.  NFSv4 File Layout Type . . . . . . . . . . . . . . . . . . . . 18
     5.1   File Striping and Data Access  . . . . . . . . . . . . . . 18
     5.2   Global Stateid Requirements  . . . . . . . . . . . . . . . 22
     5.3   The Layout Iomode  . . . . . . . . . . . . . . . . . . . . 22
     5.4   Storage Device State Propagation . . . . . . . . . . . . . 22
       5.4.1   Lock State Propagation . . . . . . . . . . . . . . . . 23
       5.4.2   Open-mode Validation . . . . . . . . . . . . . . . . . 23
       5.4.3   File Attributes  . . . . . . . . . . . . . . . . . . . 24
       5.4.4   Access State Propagation . . . . . . . . . . . . . . . 24
     5.5   Extending EOF  . . . . . . . . . . . . . . . . . . . . . . 24
       5.5.1   READs and EOF  . . . . . . . . . . . . . . . . . . . . 24
       5.5.2   LAYOUTCOMMIT and EOF . . . . . . . . . . . . . . . . . 25
     5.6   Security Considerations  . . . . . . . . . . . . . . . . . 26
     5.7   Alternate Approaches . . . . . . . . . . . . . . . . . . . 26
   6.  pNFS Typed Data Structures . . . . . . . . . . . . . . . . . . 27
     6.1   pnfs_layouttype4 . . . . . . . . . . . . . . . . . . . . . 27
     6.2   pnfs_deviceid4 . . . . . . . . . . . . . . . . . . . . . . 27
     6.3   pnfs_devaddr4  . . . . . . . . . . . . . . . . . . . . . . 28



Welch, et al.           Expires December 11, 2005               [Page 3]

Internet-Draft               pNFS Operations                   June 2005


     6.4   pnfs_devlist_item4 . . . . . . . . . . . . . . . . . . . . 28
     6.5   pnfs_layout4 . . . . . . . . . . . . . . . . . . . . . . . 29
   7.  pNFS File Attributes . . . . . . . . . . . . . . . . . . . . . 29
     7.1   pnfs_layouttype4<> LAYOUT_TYPES  . . . . . . . . . . . . . 29
     7.2   pnfs_layouttype4 LAYOUT_TYPE . . . . . . . . . . . . . . . 29
     7.3   pnfs_layouttypes4 LAYOUT_HINT  . . . . . . . . . . . . . . 29
   8.  pNFS Error Definitions . . . . . . . . . . . . . . . . . . . . 30
   9.  pNFS Operations  . . . . . . . . . . . . . . . . . . . . . . . 30
     9.1   LAYOUTGET - Get Layout Information . . . . . . . . . . . . 30
     9.2   LAYOUTCOMMIT - Commit writes made using a layout . . . . . 33
     9.3   LAYOUTRETURN - Release Layout Information  . . . . . . . . 35
     9.4   GETDEVICEINFO - Get Device Information . . . . . . . . . . 36
     9.5   GETDEVICELIST - Get List of Devices  . . . . . . . . . . . 37
   10.   Callback Operations  . . . . . . . . . . . . . . . . . . . . 37
     10.1  CB_LAYOUTRECALL  . . . . . . . . . . . . . . . . . . . . . 38
     10.2  CB_EOFCHANGED  . . . . . . . . . . . . . . . . . . . . . . 39
   11.   Usage Scenarios  . . . . . . . . . . . . . . . . . . . . . . 40
     11.1  Basic Read Scenario  . . . . . . . . . . . . . . . . . . . 40
     11.2  Multiple Reads to a File . . . . . . . . . . . . . . . . . 40
     11.3  Multiple Reads to a File with Delegations  . . . . . . . . 40
     11.4  Read with existing writers . . . . . . . . . . . . . . . . 41
     11.5  Read with later conflict . . . . . . . . . . . . . . . . . 41
     11.6  Basic Write Case . . . . . . . . . . . . . . . . . . . . . 41
     11.7  Large Write Case . . . . . . . . . . . . . . . . . . . . . 42
     11.8  Create with special layout . . . . . . . . . . . . . . . . 42
   12.   Layouts and Aggregation  . . . . . . . . . . . . . . . . . . 42
     12.1  Simple Map . . . . . . . . . . . . . . . . . . . . . . . . 42
     12.2  Block Map  . . . . . . . . . . . . . . . . . . . . . . . . 43
     12.3  Striped Map (RAID 0) . . . . . . . . . . . . . . . . . . . 43
     12.4  Replicated Map . . . . . . . . . . . . . . . . . . . . . . 43
     12.5  Concatenated Map . . . . . . . . . . . . . . . . . . . . . 43
     12.6  Nested Map . . . . . . . . . . . . . . . . . . . . . . . . 44
   13.   Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
     13.1  Storage Protocol Negotiation . . . . . . . . . . . . . . . 44
     13.2  Crash recovery . . . . . . . . . . . . . . . . . . . . . . 44
     13.3  Storage Errors . . . . . . . . . . . . . . . . . . . . . . 44
   14.   Normative References . . . . . . . . . . . . . . . . . . . . 44
       Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 45
   A.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 46
       Intellectual Property and Copyright Statements . . . . . . . . 47











Welch, et al.           Expires December 11, 2005               [Page 4]

Internet-Draft               pNFS Operations                   June 2005


1.  Introduction

   The NFSv4 protocol [2] specifies the interaction between a client
   that accesses files and a server that provides access to files and is
   responsible for coordinating access by multiple clients.  As
   described in the pNFS problem statement, this requires that all
   access to a set of files exported by a single NFSv4 server be
   performed by that server; at high data rates the server may become a
   bottleneck.

   The parallel NFS (pNFS) extensions to NFSv4 allow data accesses to
   bypass this bottleneck by permitting direct client access to the
   storage devices containing the file data.  When file data for a
   single NFSv4 server is stored on multiple and/or higher throughput
   storage devices (by comparison to the server's throughput
   capability), the result can be significantly better file access
   performance.  The relationship among multiple clients, a single
   server, and multiple storage devices for pNFS (server and clients
   have access to all storage devices) is shown in this diagram:

       +-----------+
       |+-----------+                                 +-----------+
       ||+-----------+                                |           |
       |||           |        NFSv4 + pNFS            |           |
       +||  Clients  |<------------------------------>|   Server  |
        +|           |                                |           |
         +-----------+                                |           |
              |||                                     +-----------+
              |||                                           |
              |||                                           |
              ||| Storage        +-----------+              |
              ||| Protocol       |+-----------+             |
              ||+----------------||+-----------+  Management|
              |+-----------------|||           |    Protocol|
              +------------------+||  Storage  |------------+
                                  +|  Devices  |
                                   +-----------+

                                 Figure 1

   In this structure, the responsibility for coordination of file access
   by multiple clients is shared among the server, clients, and storage
   devices, in contrast to NFSv4, by itself, where this is primarily the
   server's responsibility, some of which can be delegated to clients
   under strictly specified conditions.

   The pNFS extension to NFSv4 takes the form of new operations that
   manage data location information called a "layout".  The layout is



Welch, et al.           Expires December 11, 2005               [Page 5]

Internet-Draft               pNFS Operations                   June 2005


   managed in a similar fashion as NFSv4 data delegations (e.g., they
   are recallable and revocable).  However, they are distinct
   abstractions and are manipulated with new operations that are
   described in Section 9.  When a client holds a layout, it has rights
   to access the data directly using the location information in the
   layout.

   There are new attributes that describe general layout
   characteristics.  However, attributes do not provide everything
   needed to support layouts, hence the use of operations instead.

   This document specifies both the NFSv4 extensions required to
   distribute file access coordination between the server and its
   clients and a NFSv4 file storage protocol that may be used to access
   data stored on NFSv4 storage devices.

   Storage protocols used to access a variety of other storage devices
   are deliberately not specified, these may include:

   o  Block protocols such as iSCSI, parallel SCSI, and FCP (SCSI over
      Fibre Channel) [refs].  The block protocol support can be
      independent of the addressing structure of the block protocol
      used, allowing more than one protocol to access the same file data
      and enabling extensibility to other block protocols.

   o  Object protocols such as OSD over iSCSI or Fibre Channel [3].

   o  Other storage protocols, including PVFS and other file systems
      that are in use in HPC environments.

   pNFS is designed to accommodate these protocols and be extensible to
   new classes of storage protocols that may be of interest.

   The distribution of file access coordination between the server and
   its clients increases the level of responsibility placed on clients.
   Clients are already responsible for ensuring that suitable access
   checks are made to cached data and that attributes are suitably
   propagated to the server.  Generally, a misbehaving client that hosts
   only a single-user can only impact files accessible to that single
   user.  Misbehavior by a client hosting multiple users may impact
   files accessible to all of its users.  NFSv4 delegations increase the
   level of client responsibility as a client that carries out actions
   requiring a delegation without obtaining that delegation will cause
   its user(s) to see unexpected and/or incorrect behavior.

   Some uses of pNFS extend the responsibility of clients beyond
   delegations.  In some configurations, the storage devices cannot
   perform fine grain access checks to ensure that clients are only



Welch, et al.           Expires December 11, 2005               [Page 6]

Internet-Draft               pNFS Operations                   June 2005


   performing accesses within the bounds permitted to them by the pNFS
   operations with the server (e.g., the checks may only be possible at
   file system granularity rather than file granularity).  In situations
   where this added responsibility placed on clients creates
   unacceptable security risks, pNFS configurations in which storage
   devices cannot perform fine-grained access checks SHOULD NOT be used.
   All pNFS server implementations MUST support NFSv4 access to any file
   accessible via pNFS in order to provide an interoperable means of
   file access in such situations.  See Section 4 on Security for
   further discussion.

   Finally, there are issues about how layouts interact with the
   existing NFSv4 abstractions of data delegations and byte range
   locking.  These issues (and more) are also discussed here.

2.  General Definitions

   This protocol extension partitions the NFSv4 file system protocol
   into two parts, the control path and the data path.  The control path
   is implemented by the extended (p)NFSv4 server.  When the file system
   being exported by (p)NFSv4 uses storage devices that are visible to
   clients over the network, the data path may be implemented by direct
   communication between the extended (p)NFSv4 file system client and
   the storage devices.  This leads to a few new terms used to describe
   the protocol extension and some clarifications of some existing
   terms.

2.1  Metadata Server

   A pNFS "server" or "metadata server" is a server as defined by
   RFC3530 [2], with the addition of supporting the pNFS minor
   extension.  When using the pNFS NFSv4 minor extension, the metadata
   server may hold only the metadata associated with a file, while the
   data is stored on the storage devices.  Note: directory data is
   always accessed through the metadata server.

2.2  Client

   A pNFS "client" is a client as defined by RFC3530 [2], with the
   addition of supporting the pNFS minor extension server protocol and
   with the addition of supporting at least one storage protocol (for
   performing I/O directly to storage devices).

2.3  Storage Device

   This is a device, or server, that controls the file's data, but
   leaves other metadata management up to the metadata server.  A
   storage device could be another NFS server, or an Object Storage



Welch, et al.           Expires December 11, 2005               [Page 7]

Internet-Draft               pNFS Operations                   June 2005


   Device (OSD) or a block device accessed over a SAN (either
   FiberChannel or iSCSI SAN).  The goal of this extension is to allow
   direct communication between clients and storage devices.

2.4  Storage Protocol

   This is the protocol between the pNFS client and the storage device
   used to access the file data.  There are three primary types: file
   protocols (such as NFSv4 or NFSv3), object protocols (OSD), and block
   protocols (SCSI-block commands, or "SBC").  These protocols are in
   turn layered over transport protocols such as RPC/TCP/IP or iSCSI/
   TCP/IP or FC/SCSI.  We anticipate there will be variations on these
   storage protocols, including new protocols that are unknown at this
   time or experimental in nature.  The details of the storage protocols
   will be described in other documents so that pNFS clients can be
   written to use these storage protocols.  A NFSv4 file protocol is
   described in Section 5.

2.5  Management Protocol

   This is the protocol used by the exported file system between the
   server and storage devices.  This protocol is outside the scope of
   this draft, and is used for various management activities including
   the allocation and deallocation of storage and the management of
   state required by the storage devices to perform client access
   control.  The management protocol should not be confused with
   protocols used to manage LUNs in a SAN and other sysadmin kinds of
   tasks.

   While the pNFS protocol allows for any management protocol, in
   practice the mangement protocol is closely related to the storage
   protocol.  For example, if the storage devices are NFS servers, then
   the protocol between the pNFS metadata server and the storage devices
   is likely to involve NFS operations.  Similarly, when object storage
   devices are used, the pNFS metadata server will likely use iSCSI/OSD
   commands to manipulate storage.

   However, this document does not mandate any particular management
   protocol.  Instead, it just describes the requirements on the
   managment protocol for maintaining attributes like modify time, the
   change attribute, and the end-of-file position.

2.6  Metadata

   This is information about a file, like its name, owner, where it
   stored, and so forth.  The information is managed by the exported
   file system server (server).  Metadata also includes lower-level
   information like block addresses and indirect block pointers.



Welch, et al.           Expires December 11, 2005               [Page 8]

Internet-Draft               pNFS Operations                   June 2005


   Depending the storage protocol, block-level metadata may or may not
   be managed by the metadata server, but is instead managed by Object
   Storage Devices or other servers acting as a storage device.

2.7  Layout

   A layout defines how a file's data is organized on one or more
   storage devices.  There are many possible layout types.  They vary in
   the storage protocol used to access the data, and in the aggregation
   scheme that lays out the file data on the underlying storage devices.
   Layouts are described in more detail below.

3.  Layouts and Aggregation

3.1  Layout Structure

   The layout is a typed data structure that has variants to handle
   different storage protocols (block, object, and file).  A layout
   describes a range of a file's contents (e.g., the set of storage
   devices on which a specific byte range of the file's data reside and
   a method for identifying the data on those devices).  A specific
   layout structure belongs to a "layout type" (e.g., blocks, objects,
   files).  A metadata server, along with its management protocol, must
   support at least one layout type.  See Section 6.1 for the RPC
   definition of a layout type.  A private sub-range of the layout type
   name space can be defined through the IANA (e.g., a type with the
   high bit set to one).  This private sub-range can be used for
   internal testing or experimentation.

   For example, a file layout type could be an array of tuples
   (deviceID, file_handle), along with a definition (or aggregation
   scheme) of how the data is stored across the devices (e.g.,
   striping).  A block layout might be an array of tuples that store
   (deviceID, block_number, block count) along with information about
   block size and the file offset of the first block.  An object layout
   is an array of tuples (deviceID, objectID) and an additional
   structure (i.e., the aggregation map) that defines how the logical
   byte sequence of the file data is serialized into the different
   objects.

   This document defines a NFSv4 file layout type using a stripe-based
   aggregation scheme (see Section 5).  Adjunct specifications must
   exist that precisely define other layout formats (e.g., blocks,
   objects, or other file-based layouts) to allow interoperability among
   clients and metadata servers.






Welch, et al.           Expires December 11, 2005               [Page 9]

Internet-Draft               pNFS Operations                   June 2005


3.1.1  Device IDs

   The "deviceID" is a short name for a storage device.  In practice, a
   significant amount of information may be required to fully identify a
   storage device.  Instead of embedding all that information in a
   layout, a level of indirection is used.  Layouts embed device Ids,
   and a new op (GETDEVICEINFO) is used to retrieve the complete
   identity information about the storage device.  For example, the
   identity of a file server or object server could be an IP address and
   port.  The identity of a block device could be a volume label.  Due
   to multipath connectivity in a SAN environment, agreement on a volume
   label is considered the reliable way to locate a particular storage
   device.  Another operation, GETDEVICELIST, has been added to allow
   clients to fetch the mappings of multiple storage devices attached to
   a metadata server.  Clients SHOULD NOT expect the mapping between
   deviceID and storage device address to exist across metadata server
   reboots (i.e., clients should fetch new mappings upon startup or upon
   detection of a metadata server reboot).  If data are reorganized from
   a storage device with a given deviceID to a different storage device,
   the layout describing the data SHOULD be recalled rather than
   assigning the new storage device to the old deviceID.

3.1.2  Aggregation Schemes

   Aggregation schemes can describe layouts like simple one-to-one
   mapping, concatenation, and striping.  A general aggregation scheme
   allows nested maps so that more complex layouts can be compactly
   described.  The canonical aggregation type for this extension is
   striping, which allows a client to access storage devices in
   parallel.  Even a one-to-one mapping is useful for a file server that
   wishes to distribute its load among a set of other file servers.
   There are also experimental aggregation types such as writable
   mirrors and RAID.

3.2  Basic Layout Semantics

   Layouts delegate to the client the ability to access data out of
   band.  The layout guarantees the holder that the layout will be
   recalled when the state encapsulated by the layout becomes invalid
   (e.g., through some operation that directly or indirectly modifies
   the layout) or, possibly, when a conflicting layout is requested, as
   determined by the layout's iomode.

   Holding a layout does not guarantee that a user of the layout has the
   rights to access the data represented by the layout.  All user access
   rights MUST be obtained through the appropriate open and lock
   commands.  However, if a valid layout for a file is not held by the
   client, the storage device may reject all I/Os to that file's byte



Welch, et al.           Expires December 11, 2005              [Page 10]

Internet-Draft               pNFS Operations                   June 2005


   range that originate from that client.  In summary, layouts and
   ordinary file access controls are independent.  The act of modifying
   a file for which a layout is held, does not necessarily conflict with
   the holding of the layout (that describes the file being modified).
   However, with certain layout types (e.g., block layouts), the
   layout's iomode must agree with the type of I/O being performed.

3.2.1  Layout Iomode

   When requesting a layout (through LAYOUTGET), the client MUST request
   a layout pertaining to an "iomode" of either READ or READ/WRITE.  The
   iomode indicates to the metadata server the client's intent to
   perform either READ-ONLY or READ/WRITE I/O to the storage devices
   using the requested layout.  For certain layout types, it is useful
   for a client to specify this intent at LAYOUTGET time.  E.g., for
   block based protocols, block allocation could occur when a READ/WRITE
   iomode is specified.  A storage device may validate I/O with regards
   to the iomode; this is dependent upon storage device implementation.
   Thus, if the client's layout iomode differs from the I/O being
   performed the storage device may reject the client's I/O with an
   error indicating a new layout with the correct I/O mode should be
   fetched.  E.g., if a client gets a layout with a READ iomode and
   performs a WRITE to a storage device, the storage device is allowed
   to reject that WRITE.

   The iomode does not conflict with OPEN share modes or lock requests,
   and these are the preferred method for restricting user access to
   data files.  E.g., an OPEN of read, deny-write does not conflict with
   a LAYOUTGET containing an iomode of READ/WRITE performed by another
   client.  Applications that depend on writing into the same file
   concurrently SHOULD use byte range locking to serialize their
   accesses.

3.2.2  Operation Sequencing

   As with other stateful operations, pNFS requires the correct
   sequencing of layout operations.  This proposal assumes that sessions
   will precede pNFS into NFSv4.x and thus, pNFS will require the use of
   sessions.  If the sessions proposal does not precede pNFS, then this
   proposal must be modified to provide for the correct sequencing of
   pNFS layout operations.

   One main issue with operation sequencing concerns callbacks.  The
   protocol must defend against races between the reply to a LAYOUTGET
   operation and a subsequent CB_LAYOUTRECALL.  It MUST not be possible
   for a client to process the CB_LAYOUTRECALL for a layout that it has
   not received in a reply message to a LAYOUTGET.




Welch, et al.           Expires December 11, 2005              [Page 11]

Internet-Draft               pNFS Operations                   June 2005


3.3  Obtaining a Layout

   The metadata server will give out layouts of a particular type
   (block, object, or file) and aggregation.  A client obtains a layout
   through a new operation (LAYOUTGET).  The layout returned to the
   client may not line up exactly with the requested byte range.
   However, at least a single byte overlap MUST exist between the
   requested layout and the layout returned by the metadata server.

   The storage protocol used by the client to access the data on the
   storage device is determined by the layout's type.  The client needs
   to select a "layout driver" that understands how to interpret and use
   that layout.  The API used by the client to talk to its drivers is
   outside the scope of the pNFS extension.  The storage protocol
   between the client's layout driver and the actual storage is covered
   by other protocols specifications such as SBC (block storage), OSD
   (object storage) or NFS (file storage).

   Although, the metadata server is in control of the layout for a file,
   the pNFS client can provide hints to the server when a file is opened
   or created about preferred layout type.  The pNFS extension
   introduces a LAYOUT_HINT attribute that the client can query at
   anytime, and can set with a compound SETATTR after OPEN to provide a
   hint to the server for new files.

3.3.1  Identifying Layouts

   A layout is identified by the following tuple: (ClientID, FH, offset,
   length); the FH refers to the FH of the file on the metadata server,
   the offset and length specify the byte range of the file the layout
   covers.  Since there is a desire to manage layouts as sub-dividable
   entities, layouts are range-based and are identified in such a
   manner.  Sub-dividable layouts have the benefit of being returnable/
   recallable or committable in smaller chunks without having to return,
   recall, or commit the entire layout.  E.g., this may be useful when
   the layout is very large and a client is only actively using a small
   range of the layout, thus the client may not want to commit the
   entire layout, rather it could commit just the range of the layout it
   is using.

3.3.2  Overlapping Layouts

   A metadata server may hand-out layouts that overlap, as long as the
   overlapping regions specify the same storage device/file mapping;
   i.e., the records within the overlapping layouts should specify the
   same storage device mapping for the same byte ranges they represent.
   If two overlapping layouts differ, the old layout should be recalled.




Welch, et al.           Expires December 11, 2005              [Page 12]

Internet-Draft               pNFS Operations                   June 2005


3.3.3  Copy-on-write

   For block-based protocols it is useful to have the ability to direct
   a client to read data from one group of blocks, but write to a
   different group; e.g., to implement a snapshotting blocks system.
   The client can not make the choice of where to place data, it
   requires help by the metadata server, most probably communicated
   through the layout.  A single layout with the ability to mark (and
   re-mark) portions read-only vs. read/write is sufficient for this to
   work.

3.4  Recalling a Layout

   Since a layout protects a client's access to a file via a direct
   client-data-server path, a layout need only be recalled when it is
   semantically unable to serve this function.  Typically, this occurs
   when the layout no longer encapsulates the true location of the file
   over the byte range it represents.  Any operation that changes the
   layout will result in a recall of the layout.  A REMOVE operation may
   cause the metadata server to recall the layout to prevent the client
   from accessing a non-existent file and to reclaim state stored on the
   client.  Since a REMOVE may be delayed until the last close of the
   file has occurred, the recall may also be delayed until this time.
   As well, once the file has been removed (after the last reference),
   the client SHOULD no longer be able to perform I/O using the layout
   (e.g., with file-based layouts an error such as ESTALE could be
   returned).

   Once a layout has been recalled, the client should no longer issue
   I/Os to the storage devices for the file and byte range represented
   by the recalled layout, even though the client may still have valid
   stateids for that file (except to flush dirty data before returning
   the layout).  If a client does issue an I/O to a storage device for
   which it does not hold a layout, the storage device SHOULD reject the
   I/O. This can be verified by the storage device by mapping the
   stateid used for I/O to the client instance and validating that the
   client instance has a valid layout.

3.5  Committing a Layout

   Due to the nature of the protocol, the file attributes that exist on
   the metadata storage device may become inconsistent in relation to
   the data stored on the storage devices; e.g., when WRITEs occur
   before a layout has been committed (e.g., between a LAYOUTGET and a
   LAYOUTCOMMIT).  Thus, it is necessary to occasionally re-sync this
   state and make it visible to other clients through the metadata
   server.




Welch, et al.           Expires December 11, 2005              [Page 13]

Internet-Draft               pNFS Operations                   June 2005


   The LAYOUTCOMMIT operation is responsible for committing the modified
   layout to the metadata server.  Note: the data should be written (and
   committed) to the appropriate storage devices before the LAYOUTCOMMIT
   occurs.  The scope of this operation depends on the storage protocol
   in use.  For block-based layouts, it may require updating the block
   list that comprises the file and committing this layout to stable
   storage.  While, for file-layouts it requires the synchronization of
   attributes between the metadata and storage devices (mainly the size/
   EOF).  The management protocol is free to sync this state before it
   receives a LAYOUTCOMMIT, however upon successful completion of a
   LAYOUTCOMMIT, state that exists on the metadata server that describes
   the file MUST be in sync with the state existing on the storage
   devices that comprises that file (assuming no intervening
   operations).  Thus, a client that queries the size of a file between
   a WRITE to a storage device and the LAYOUTCOMMIT may not observe a
   size that reflects the actual data written.

   The change attribute and mtime may be updated, by the server, at
   LAYOUTCOMMIT time; since for some layout protocols, the change
   attribute can not be updated by a WRITE operation performed at a
   storage device.  However, for some layout protocols the change
   attribute and mtime may be updated at or after the time of the WRITE
   (e.g., if the storage device is able to communicate these attributes
   to the metadata server).  If, upon receiving a LAYOUTCOMMIT, the
   server implementation is able to determine that the file did not
   change since the last time the change attribute was updated (e.g., no
   WRITEs or over-writes occurred), the implementation need not update
   the change attribute (file-based protocols may have enough state to
   make this determination or may update the change attribute upon each
   file modification).  This also applies for mtime; if the server
   implementation is able to determine that the file has not been
   modified since the last mtime update, the server need not update
   mtime at LAYOUTCOMMIT time.  Once LAYOUTCOMMIT completes, the new
   change attribute and mtime should be visible if that file was
   modified since the latest previous LAYOUTCOMMIT or LAYOUTGET.  If a
   client prefers to set a new mtime, it should do so through the
   SETATTR operation.

3.5.1  LAYOUTCOMMIT and EOF

   As well, the file's EOF may be updated at LAYOUTCOMMIT time.  The
   LAYOUTCOMMIT operation takes an EOF flag and length as arguments.  If
   the EOF flag is set, a new EOF SHOULD be specified by the client.
   The EOF length may be used as a hint to the metadata server.  The
   metadata server may validate the EOF against state that exists on the
   storage devices.  The metadata server may either: update the file's
   EOF based on the client specified length, it may ignore the EOF flag,
   or it may use a value computed by querying the storage devices (e.g.,



Welch, et al.           Expires December 11, 2005              [Page 14]

Internet-Draft               pNFS Operations                   June 2005


   through the management protocol).

   The method chosen to update EOF may depend on the storage device's
   and/or the management protocol's implementation.  For example, if the
   storage devices are block devices with no knowledge of EOF, then the
   metadata server must rely on the client to set the EOF appropriately.
   An EOF flag and length are also returned in the results of a
   LAYOUTCOMMIT.  This union indicates whether a new EOF was set, and to
   what length it was set.  The server may return a new EOF regardless
   of whether the client set the neweof field in the request, however if
   the EOF flag was set in the request, the neweof MUST be returned.
   The EOF flag SHOULD not be used to truncate or grow the file
   sparsely; the SETATTR operation must be used to do so.  The metadata
   server in conjunction with the management protocol SHOULD ensure that
   a new EOF is reflected by the storage device immediately upon return
   of the LAYOUTCOMMIT operation; e.g., a READ up to the new EOF should
   succeed on the storage devices (assuming no intervening truncations).

   Since client layout holders may be unaware of changes made to EOF
   (through LAYOUTCOMMIT or SETATTR) by other clients, an additional
   callback/notification has been added for pNFS.  CB_EOFCHANGED is a
   notification that the metadata server sends to layout holders to
   notify them of an EOF change to the file.  This is preferred over
   issuing CB_LAYOUTRECALL to each of the layout holders.

3.6  Lease Renewals

   The current NFSv4 specification allows for implicit lease renewals to
   occur upon receiving an I/O. However, due to the disjoint pNFS
   architecture, implicit lease renewals are limited to operations
   performed at the metadata server (including I/O performed through the
   metadata server).  So, READ and WRITE I/O to storage devices do not
   implicitly renew lease state.  It is suggested that explicit lease
   renewal is used instead of relying on implicit renewals.

   The impact on lease renewals and storage devices needs to be better
   defined.  For now it is left up to the management protocol to manage
   leases that may exist on storage devices.

4.  Security Considerations

   The pNFS extension partitions the NFSv4 file system protocol into two
   parts, the control path and the data path (storage protocol).  The
   control path contains all the new operations described by this
   extension; all existing NFSv4 security mechanisms and features apply
   to the control path.  The combination of components in a pNFS system
   (see Figure 1) is required to preserve the security properties of
   NFSv4 with respect to an entity accessing data via a client,



Welch, et al.           Expires December 11, 2005              [Page 15]

Internet-Draft               pNFS Operations                   June 2005


   including security countermeasures to defend against threats that
   NFSv4 provides defenses for in environments where these threats are
   considered significant.

   In some cases, the security countermeasures for connections to
   storage devices may take the form of physical isolation or a
   recommendation not to use pNFS in an environment.  For example, it is
   currently infeasible to provide confidentiality protection for some
   storage device access protocols to protect against eavesdropping; in
   environments where eavesdropping on such protocols is of sufficient
   concern to require countermeasures, physical isolation of the
   communication channel (e.g., via direct connection from client(s) to
   storage device(s)) and/or a decision to forego use of pNFS (e.g., and
   fall back to NFSv4) may be appropriate courses of action.

   In full generality where communication with storage devices is
   subject to the same threats as client-server communication, the
   protocols used for that communication need to provide security
   mechanisms comparable to those available via RPSEC_GSS for NFSv4.
   Many situations in which pNFS is likely to be used will not be
   subject to the overall threat profile for which NFSv4 is required to
   provide countermeasures.

   pNFS implementations MUST NOT remove NFSv4's access controls.  The
   combination of clients, storage devices, and the server are
   responsible for ensuring that all client to storage device file data
   access respects NFSv4 ACLs and file open modes.  This entails
   performing both of these checks on every access in the client, the
   storage device, or both.  If a pNFS configuration performs these
   checks only in the client, the risk of a misbehaving client obtaining
   unauthorized access is an important consideration in determining when
   it is appropriate to use such a pNFS configuration.  Such
   configurations SHOULD NOT be used when client- only access checks do
   not provide sufficient assurance that NFSv4 access control is being
   applied correctly.

   The following subsections describe security considerations
   specifically applicable to each of the three major storage device
   protocol types supported for pNFS.

   [Additional security info - the object protocol needs this, but it
   may be out-of-band; the OSD experts will know for sure.  For Block
   and File an approach of the client being expected to know what it
   needs when it sees what it's being asked to access probably suffices,
   although we might be able to help (e.g., pass iSCSI CHAP
   authentication identities, but NOT secrets, via pNFS).  For File in
   particular, defaulting to the NFSv4 principal is probably a good
   idea, although it's not strictly necessary.]



Welch, et al.           Expires December 11, 2005              [Page 16]

Internet-Draft               pNFS Operations                   June 2005


   [Requiring strict equivalence to NFSv4 security mechanisms is the
   wrong approach.  Will need to lay down a set of statements that each
   protocol has to make starting with access check location/properties.]

4.1  File Layout Security

   A NFSv4 file layout type is defined in Section 5; see Section 5.6 for
   additional security considerations and details.  In summary, the
   NFSv4 file layout type requires that all I/O access checks MUST be
   performed by the storage devices, as defined by the NFSv4
   specification.  If another file layout type is being used, additional
   access checks may be required.  But in all cases, the access control
   performed by the storage devices must be at least as strict as that
   specified by the NFSv4 protocol.

4.2  Object Layout Security

   The object storage protocol relies on a cryptographically secure
   capability to control accesses at the object storage devices.
   Capabilities are generated by the metadata server, returned to the
   client, and used by the client as described below to authenticate
   their requests to the Object Storage Device (OSD).  Capabilities
   therefore achieve the required access and open mode checking.  They
   allow the file server to define and check a policy (e.g., open mode)
   and the OSD to check and enforce that policy without knowing the
   details (e.g., user IDs and ACLs).

   Each capability is specific to a particular object, an operation on
   that object, a byte range w/in the object, and has an explicit
   expiration time.  The capabilities are signed with a secret key that
   is shared by the object storage devices (OSD) and the metadata
   managers. clients do not have device keys so they are unable to forge
   capabilities.

   The details of the security and privacy model for Object Storage are
   out of scope of this document and will be specified in the Object
   Storage version of the storage protocol definition.  However, the
   following sketch of the algorithm should help the reader understand
   the basic model.

   LAYOUTGET returns

     {CapKey = MAC<SecretKey>(CapArgs), CapArgs}

   The client uses CapKey to sign all the requests it issues for that
   object using the respective CapArgs.  In other words, the CapArgs
   appears in the request to the storage device, and that request is
   signed with the CapKey as follows:



Welch, et al.           Expires December 11, 2005              [Page 17]

Internet-Draft               pNFS Operations                   June 2005


     ReqMAC = MAC<CapKey>(Req, Nonceln)

   The following is sent to the OSD: {CapArgs, Req, Nonceln, ReqMAC}.
   The OSD uses the SecretKey it shares with the metadata server to
   compare the ReqMAC the client sent with a locally computed

     MAC<MAC<SecretKey>(CapArgs)>(Req, Nonceln)

   and if they match the OSD assumes that the capabilities came from an
   authentic metadata server and allows access to the object, as allowed
   by the CapArgs.  Therefore, if the server LAYOUTGET reply, holding
   CapKey and CapArgs, is snooped by another client, it can be used to
   generate valid OSD requests (within the CapArgs access restriction).

   To provide the required privacy requirements for the capabilities
   returned by LAYOUTGET, the GSS-API can be used, e.g. by using a
   session key known to the file server and to the client to encrypt the
   whole layout or parts of it.  Two general ways to provide privacy in
   the absence of GSS-API that are independent of NFSv4 are either an
   isolated network such as a VLAN or a secure channel provided by
   IPsec.

4.3  Block Layout Security

   Block protocols rely on clients to enforce file access checks, as the
   storage devices are generally unaware of the files they are storing
   (and in particular are unaware of which block belongs to which file).
   In environments where access control is important and client-only
   access checks provide insufficient assurance of access control
   enforcement (e.g., there is concern about a malicious client skipping
   the access check), the storage devices will generally be unable to
   compensate for these client deficiencies.  In such threat
   environments, Block protocols SHOULD NOT be used with pNFS; NFSv4
   without pNFS may be a more suitable means of accessing files in the
   presence of such threats.  Storage-device/protocol-specific methods
   (e.g., LUN masking/mapping) may be available to prevent malicious or
   high-risk clients from directly accessing storage devices.

5.  NFSv4 File Layout Type

   This section describes the semantics and format of NFSv4 file-based
   layouts.

5.1  File Striping and Data Access

   The file layout specifies an ordered array of (deviceID,
   start_offset, filehandle) tuples, as well as the stripe_size, skip
   and the file's current EOF (current as of LAYOUTGET time).  Devices



Welch, et al.           Expires December 11, 2005              [Page 18]

Internet-Draft               pNFS Operations                   June 2005


   and filehandles may be repeated multiple times within the device list
   (dev_list).  Data MUST be distributed in a round-robin fashion across
   the list of devices in increments of stripe_size bytes.  A data file
   stored on a storage device MUST map to a single file as defined by
   the metadata server; i.e., data from two files as viewed by the
   metadata server MUST NOT be stored within the same data file on any
   storage device.

    struct pnfs_nfsv4_file_layout {
           pnfs_deviceid4          dev_id;
           offset4                 start_offset;
           nfs_fh4                 fh;
    };

    struct pnfs_nfsv4_file_layouttype4 {
           uint64_t                skip;
           uint64_t                stripe_size;
           length4                 eof;
           pnfs_nfsv4_file_layout  dev_list<>;
    };

   The "start_offset" field indicates the initial byte offset in the
   file represented by the filehandle "fh" on the device indicated by
   "dev_id".  The "skip" field indicates the number of bytes to skip
   between the stripes on a particular storage device.  This
   representation allows for a variety of storage device file layouts.
   The two data file layouts anticipated to be most common are "sparse
   file-layouts" and "dense file-layouts".

   For example:





















Welch, et al.           Expires December 11, 2005              [Page 19]

Internet-Draft               pNFS Operations                   June 2005


    Sparse file-layout
    ------------------
    The following layout: stripe_size=4KB, skip=8KB and dev_list:
                          [{dev_id: 0, start_offset: 0},
                           {dev_id: 1, start_offset: 4KB},
                           {dev_id: 2, start_offset: 8KB}]

    Is represented by the following file layout on the storage devices:

        Offset  ID:0    ID:1   ID:2
        0       +--+    +--+   +--+                 +--+  indicates a
                |//|    |  |   |  |                 |//|  stripe that
        4KB     +--+    +--+   +--+                 +--+  contains data
                |  |    |//|   |  |
        8KB     +--+    +--+   +--+
                |  |    |  |   |//|
        12KB    +--+    +--+   +--+
                |//|    |  |   |  |
        16KB    +--+    +--+   +--+
                |  |    |//|   |  |
                +--+    +--+   +--+

   The sparse file-layout has holes for the byte ranges not exported by
   that storage device.  This allows clients to access data using the
   real offset into the file, regardless of the storage device's
   position within the stripe.  However, if a client writes to one of
   these holes (e.g., offset 4-12KB on device 1), then an error MUST be
   returned by the storage device.  This requires that the storage
   device have knowledge of the layout for each file.






















Welch, et al.           Expires December 11, 2005              [Page 20]

Internet-Draft               pNFS Operations                   June 2005


    Dense/packed file-layout
    ------------------------
    The following layout: stripe_size=4KB, skip=0 and dev_list:
                          [{dev_id: 0, start_offset: 0},
                           {dev_id: 1, start_offset: 0},
                           {dev_id: 2, start_offset: 0}]

    Is represented by the following file layout on the storage devices:

        Offset  ID:0    ID:1   ID:2
        0       +--+    +--+   +--+
                |//|    |//|   |//|
        4KB     +--+    +--+   +--+
                |//|    |//|   |//|
        8KB     +--+    +--+   +--+
                |//|    |//|   |//|
        12KB    +--+    +--+   +--+
                |//|    |//|   |//|
        16KB    +--+    +--+   +--+
                |//|    |//|   |//|
                +--+    +--+   +--+

   The dense or packed file-layout does not leave holes on the storage
   devices.  Each stripe unit is spread in a round-robin fashion across
   the storage devices.  As such, the storage devices need not know the
   file's layout since the client is allowed to write to any offset.

   Regardless of the layout, the calculation to determine the index into
   the device array is the same:

     dev_idx = floor(file_offset / stripe_size) mod dev_list_num

   The calculation to determine the byte offset within the data file (on
   the storage device referenced by the device index) is:

     dev_offset = (floor(floor(file_offset / stripe_size) /
                   dev_list_num) * (stripe_size + skip)) +
                  (file_offset mod stripe_size) +
                  dev_list[dev_idx].start_offset

   [NOTE: I have no problem simplifying this layout scheme.  It seems
   there is a desire for sparse and dense layouts.  We can always
   simplify this by adding a flag which indicates the type of layout
   (sparse or dense).]

   Clients MUST use the filehandle described within the layout when
   accessing data on the storage devices.  The client MUST only issue
   READ, WRITE, and COMMIT operations to the storage devices.  In



Welch, et al.           Expires December 11, 2005              [Page 21]

Internet-Draft               pNFS Operations                   June 2005


   response to a WRITE or COMMIT, a storage device may return a
   writeverf unique to that storage device.  GETATTR and SETATTR MUST be
   directed to the metadata server.  In the case of a SETATTR of the
   size attribute, the management protocol is responsible for
   propagating size updates/truncations to the storage devices.  In the
   case of extending WRITEs to the storage devices, the new size must be
   visible on the metadata server once a LAYOUTCOMMIT has completed (see
   Section 3.5.1, Section 5.5.2).  All size attribute updates MUST be
   effective on the storage devices immediately (by the time the
   metadata operation returns), so that READs past EOF can be
   recognized.

   As described in Section 3.2, a client MUST NOT issue I/Os to storage
   devices for which it does not hold a valid layout.  The storage
   devices SHOULD reject such requests.

5.2  Global Stateid Requirements

   Note, there are no stateids returned embedded within the layout.  The
   client MUST use the stateid representing open or lock state as
   returned by an earlier metadata operation (e.g., OPEN, LOCK) to
   perform I/O on the data-servers (as would be used in regular NFSv4).
   Special stateids may be used when accessing data files on the storage
   devices.  Special stateid usage for I/O is subject to the NFSv4
   protocol specification.  The stateid used for I/O MUST have the same
   affect and be subject to the same validation on storage device as it
   would if the I/O was being performed on the metadata server itself
   (in the absence of pNFS).  This has the implication that stateids are
   globally valid on both the metadata and storage devices.  This
   requires the metadata server to propagate changes in lock and open
   state to the data-servers, so that the data-servers may validate I/O
   accesses.  This is discussed further in Section 5.4.

5.3  The Layout Iomode

   The layout iomode is not used by the metadata server when servicing
   NFSv4 file-based layouts.  As such, the client SHOULD set the iomode
   to READ/WRITE at LAYOUTGET time.  If an iomode of READ/WRITE is not
   specified, the metadata server may return an error.  The iomode need
   not be checked by the storage devices when clients perform I/O.
   However, the storage devices SHOULD still validate that the client
   holds a valid layout and return an error if the client does not.

5.4  Storage Device State Propagation

   Since the metadata server, which handles lock and open-mode state
   changes, as well as ACLs, may not be collocated with the storage
   devices (where I/O access is validated), the server implementation



Welch, et al.           Expires December 11, 2005              [Page 22]

Internet-Draft               pNFS Operations                   June 2005


   MUST take care of propagating changes of this state to the storage
   devices.  Once the propagation to the storage devices is complete,
   the full effect of those changes must be in effect at the storage
   devices.  However, some state changes need not be propagated
   immediately, although all changes SHOULD be propagated promptly.
   These state propagations have an impact on the design of the
   management protocol, even though the management protocol is outside
   of the scope of this specification.

5.4.1  Lock State Propagation

   Mandatory locks MUST be made effective at the storage devices before
   the request that establishes them returns to the caller.  Thus,
   mandatory lock state MUST be synchronously propagated to the storage
   devices.  On the other hand, since advisory lock state is not used
   for checking I/O accesses at the storage devices, there is no
   semantic reason for propagating advisory lock state to the storage
   devices.  However, since all lock, unlock, open downgrades and
   upgrades affect the sequence ID stored within the stateid, the
   stateid changes which may cause difficulty if this state is not
   propagated.

   Thus, when a client uses a stateid on a storage device for I/O with a
   newer sequence number than the one the storage device has, the
   storage device should query the metadata server and get any pending
   updates to that stateid.  Since updates to advisory locks neither
   confer nor remove privileges, these changes need not be propagated
   immediately, and may not need to be propagated promptly.  The updates
   to advisory locks need only be propagated when the storage device
   needs to resolve a question about a stateid.  In fact, if byte-range
   locking is not mandatory (is advisory) the clients are advised not to
   use the lock-based stateids for I/O at all.  The ones returned by
   open are sufficient and eliminate overhead for this kind of state
   propagation.

5.4.2  Open-mode Validation

   Open-mode validation MUST be performed against the open mode(s) held
   by the storage devices.  However, the server implementation may not
   always require the immediate propagation of changes.  Reduction in
   access because of CLOSEs or DOWNGRADEs do not have to be propagated
   immediately, but SHOULD be propagated promptly (whereas changes due
   to revocation MUST be propagated immediately).  On the other hand,
   changes that expand access (e.g., new OPEN's and upgrades) don't have
   to be propagated immediately but the storage device SHOULD NOT reject
   a request because of mode issues without making sure that the upgrade
   is not in flight.




Welch, et al.           Expires December 11, 2005              [Page 23]

Internet-Draft               pNFS Operations                   June 2005


5.4.3  File Attributes

   Since the SETATTR operation has the ability to modify state that is
   visible on the both the metadata and storage devices (e.g., the
   size), care must be taken to ensure that the resultant state (across
   the set of storage devices) is consistent; especially when truncating
   or growing the file.

   As described earlier, the LAYOUTCOMMIT operation is used to ensure
   that the metadata is synced with changes made to the storage devices.
   For the file-based protocol, it is necessary to re-sync state such as
   the size attribute, and the setting of mtime/atime.  The management
   protocol is free to sync this state before it receives a
   LAYOUTCOMMIT, however upon successful completion of a LAYOUTCOMMIT
   the size attribute MUST be in sync (across the metadata server and
   storage devices, baring any intervening operations).

5.4.4  Access State Propagation

   Any changes to the state of a file that controls access as reflected
   by ACCESS calls or READs and WRITEs on the metadata server, MUST be
   propagated to the storage devices for enforcement on READ and WRITE
   I/O calls.  If the changes made on the metadata server result in more
   restrictive access permissions for any user, those changes MUST be
   propagated to the storage devices synchronously.

   Recall, the NFSv4 protocol [2] specifies that:

      ...since the NFS version 4 protocol does not impose any
      requirement that READs and WRITEs issued for an open file have the
      same credentials as the OPEN itself, the server still must do
      appropriate access checking on the READs and WRITEs themselves.

   This also includes changes to ACLs.  The propagation of ACLs may be
   asynchronous only if the server implementation is able to determine
   that the updated ACL is not more restrictive for any user specified
   in the old ACL.  Due to the relative infrequency of ACL updates, it
   is suggested that they are propagated synchronously.

5.5  Extending EOF

5.5.1  READs and EOF

   A potential problem exists when a data file on a particular storage
   device is grown past EOF; it exists for both dense and sparse
   layouts.  Imagine the following scenario: a client creates a new file
   (EOF == 0) and writes to byte 128KB; the client then seeks to the
   beginning of the file and reads byte 100.  The client should receive



Welch, et al.           Expires December 11, 2005              [Page 24]

Internet-Draft               pNFS Operations                   June 2005


   0s back as a result of the read.  However, if the read falls on a
   different storage device to the client's original write, the storage
   device servicing the READ may still believe that the EOF is at 0 and
   return no data (with the EOF flag set).  The storage device can only
   return 0s if it knows that the EOF has been extended.  This would
   require the immediate propagation of EOF to all storage devices,
   which is potentially very costly, instead another approach is
   outlined below.

   First, the EOF is returned within the layout by LAYOUTGET.  This EOF
   must reflect the latest EOF at the metadata server as set by the most
   recent of either the last LAYOUTCOMMIT or SETATTR; however, it may be
   more recent.  Second, if a client performs a read that is returned
   short (i.e., is fully within EOF, but the storage device indicates
   EOF and returns partial or no data), the client must assume that it
   is a hole and substitute 0s for the data not read (up until its known
   local EOF).  If a client extends the file, it must update its local
   EOF.  Third, if the metadata server receives a SETATTR of the size or
   a LAYOUTCOMMIT that alters the EOF, the metadata server MUST send out
   CB_EOFCHANGED messages with the new EOF to clients holding layouts
   (it need not send a notification to the client that performed the
   operation that resulted in EOF changing).  Upon reception of the
   CB_EOFCHANGED notification, clients must update their local EOF.  As
   well, if a new EOF is returned as a result to LAYOUTCOMMIT, the
   client must update their local EOF.

5.5.2  LAYOUTCOMMIT and EOF

   Another complication can arise due to EOF.  If a file has been grown
   by a set of WRITEs prior to a LAYOUTCOMMIT, the management protocol
   must ensure that the corresponding file on each storage device is
   grown (possibly sparsely) up until the offset represented by the EOF
   length before LAYOUTCOMMIT returns.

   For example: Imagine a file is striped across four storage devices,
   using a sparse file layout, with 64KB on each storage device.  A
   WRITE of 64KB occurs starting at offset 192KB (the first stripe on
   the 4th storage device) followed by a LAYOUTCOMMIT.  The new EOF
   offset is now at 256KB, however the corresponding file size on the
   first three storage devices is 0, since they did not service any
   WRITE operations.  Immediately upon completion of LAYOUTCOMMIT, the
   server implementation MUST ensure that READs to any of the storage
   devices, at an offset below EOF, succeed; indeed, in this example, a
   read to any of the first three storage devices (below EOF) must
   return all 0s.  The easiest way to accomplish this is to set the file
   size on each of the storage devices to EOF.  Note, this only need
   occur at LAYOUTCOMMIT time or upon the reception of a SETATTR that
   modifies the size.



Welch, et al.           Expires December 11, 2005              [Page 25]

Internet-Draft               pNFS Operations                   June 2005


5.6  Security Considerations

   The NFSv4 file layout type MUST adhere to the security considerations
   outlined in Section 4.  More specifically, storage devices must make
   all of the required access checks on each READ or WRITE I/O as
   determined by the NFSv4 protocol [2].  This impacts the management
   protocol and the propagation of state from the metadata server to the
   storage devices; see Section 5.4 for more details.

5.7  Alternate Approaches

   Two alternate approaches exist for file-based layouts and the method
   used by clients to obtain stateids used for I/O. Both approaches
   embed stateids within the layout.

   However, before examining these approaches it is important to
   understand the distinction between clients and owners.  Delegations
   belong to clients, while locks (record and share reservations) are
   held by owners (who belong to a specific client).  As such,
   delegations can only protect against inter-client conflicts, not
   intra-client conflicts.  Layouts are held by clients and SHOULD NOT
   be associated with state held by owners.  Therefore, if stateids used
   for data access are embedded within a layout, these stateids can only
   act as delegation stateids, protecting against inter-client
   conflicts; stateids pertaining to an owner can not be embedded within
   the layout.  This has the implication that the client MUST arbitrate
   among all intra-client conflicts (such as arbitrating among lock
   requests by different processes) before issuing pNFS operations.
   Using the stateids stored within the layout, storage devices can only
   arbitrate between clients (not owners).

   The first alternate approach is to do away with global stateids
   (stateids returned by OPEN/LOCK that are valid on the metadata server
   and storage devices) and use only stateids embedded within the
   layout.  This approach has the drawback that the stateids used for
   I/O access can not be validated against per owner state (rather they
   are validated against per client state), since they are only
   associated with the client holding the layout.  It breaks the
   semantics of tieing a stateid used for I/O to an open instance.  This
   has the implication that clients must delegate per owner lock and
   open requests internally, rather than push the work onto the storage
   devices.  The storage devices can still arbitrate and enforce inter-
   client lock and open state.

   [Comment: What goes wrong when the stateids are not used as expected?
   Is it that byte range locks are not honored?  Does it matter in the
   world of advisory locks?]




Welch, et al.           Expires December 11, 2005              [Page 26]

Internet-Draft               pNFS Operations                   June 2005


   The second approach is a hybrid approach.  This approach allows for
   stateids to be embedded with the layout, but also allows for the
   possibility of global stateids.  If the stateid embedded within the
   layout is a special stateid of all zeros, then the stateid referring
   to the last successful OPEN/LOCK should be used (as a global stateid
   presented earlier in the proposal).  This approach is recommended if
   it is decided that using NFSv4 as a management protocol is required.

   This proposal suggests the global stateid approach due to the cleaner
   semantics it provides regarding the relationship between stateids
   used for I/O and their corresponding open instance (or lock state).
   However, it does have a profound impact on the management protocol's
   implementation and the state propagation that is required (as
   described in Section 5.4).

6.  pNFS Typed Data Structures

6.1  pnfs_layouttype4

     enum pnfs_layouttype4 {
            LAYOUT_NFSV4_FILES = 1
     };

   A layout type specifies the layout being used.  The implication is
   that clients have "layout drivers" that support one or more layout
   types.  The file server advertises the layout types it supports
   through the LAYOUT_TYPES file system attribute.  A client asks for
   layouts of a particular type in LAYOUTGET, and passes those layouts
   to its layout driver.  The set of well known layout types must be
   defined through IANA.  A private range of layout types should exist
   as defined through IANA.  This would allow custom installations to
   introduce new layout types.

   The LAYOUT_NFSV4_FILES enumeration specifies that the NFSv4 file
   layout type is to be used.

6.2  pnfs_deviceid4

     uint32_t pnfs_deviceid4;       /* 32-bit device ID */

   Layout information includes device IDs that specify a storage device
   through a compact handle.  Addressing and type information is
   obtained with the GETDEVICEINFO operation.  Device IDs may not be
   valid across metadata server reboots.  See Section 3.1.1 for more
   details.






Welch, et al.           Expires December 11, 2005              [Page 27]

Internet-Draft               pNFS Operations                   June 2005


6.3  pnfs_devaddr4

     enum pnfs_devaddrtypes4 {
            DEVADDR_SERVER_PORT = 1
     };

     union pnfs_devaddr4 switch (pnfs_devaddrtypes4 type) {
            case DEVADDR_SERVER_PORT:
                   string           r_netid<>;   /* network ID */
                   string           r_addr<>;    /* universal address */
            default:
                   opaque           devaddr<>;   /* For other layouts */
     };

   This structure is used to set up a communication channel with the
   storage device.  Different layout types will require different types
   of structures to define how they communicate with storage devices.
   The pnfs_devaddrtypes4 enumeration should list the types of
   structures required by the different layout types.  The pnfs_devaddr4
   union switches of this enumeration.  Currently, DEVADDR_SERVER_PORT
   has been defined to identify a storage device by network IP address
   and port number.  This is sufficient for the NFSv4 file layout
   storage driver to communicate with the NFSv4 storage devices, and for
   object-based storage drivers to communicate with iSCSI/OSD devices.
   Again, the pnfs_devaddrtypes4 should be defined through IANA.

6.4  pnfs_devlist_item4

     struct pnfs_devlist_item4 {
            pnfs_deviceid4          id;
            pnfs_deviceaddr4        addr;
     };

   An array of these values is returned by the GETDEVICELIST operation.
   They define the set of devices associated with a file system.
















Welch, et al.           Expires December 11, 2005              [Page 28]

Internet-Draft               pNFS Operations                   June 2005


6.5  pnfs_layout4

     union pnfs_layouttypes4 switch (pnfs_layouttype4 layout_type) {
            case LAYOUT_NFSV4_FILES:
                   pnfs_nfsv4_layouttype4 file_layout;
            default:
                   opaque           layout_data<>;
     };

     struct pnfs_layout4 {
            offset4                 offset;
            length4                 length;
            pnfs_layouttypes4       layout;
     };

   The pnfs_layout4 structure defines a layout for a file.  The
   pnfs_layouttypes4 union contains the portion of the layout specific
   to the layout type.  Currently, only the NFSv4 file layout type is
   defined; see Section 5.1 for its definition.  Since layouts are sub-
   dividable, the offset and length (together with the file's filehandle
   and the clientid), identifies the layout.

7.  pNFS File Attributes

7.1  pnfs_layouttype4<> LAYOUT_TYPES

   This attribute applies to a file system and indicates what layout
   types are supported by the file system.  We expect this attribute to
   be queried when a client encounters a new fsid.  This attribute is
   used by the client to determine if it has applicable layout drivers.

7.2  pnfs_layouttype4 LAYOUT_TYPE

   This attribute indicates the particular layout type used for a file.
   This is for informational purposes only.  The client needs to use the
   LAYOUTGET operation in order to get enough information (e.g.,
   specific device information) in order to perform I/O.

7.3  pnfs_layouttypes4 LAYOUT_HINT

   This attribute may be set on newly created files to influence the
   metadata server's choice for the file's layout.  The metadata server
   may ignore this attribute.  This attribute is a sub-set of the layout
   returned by LAYOUTGET.  For example, instead of specifying particular
   devices, this would be used to suggest the stripe width of a file.
   It is up to the server implementation to determine which fields
   within the layout it uses.




Welch, et al.           Expires December 11, 2005              [Page 29]

Internet-Draft               pNFS Operations                   June 2005


8.  pNFS Error Definitions

   NFS4ERR_BADLAYOUT Layout specified is invalid.

   NFS4ERR_LAYOUTUNAVAILABLE Layouts are not available for the file or
      its containing file system.

   NFS4ERR_LAYOUTTRYLATER Layouts are temporarily unavailable for the
      file, client should retry later.


9.  pNFS Operations

9.1  LAYOUTGET - Get Layout Information

   SYNOPSIS

     (cfh), clientid, layout_type, iomode, offset, length -> layout


   ARGUMENT

     enum layoutget_iomode4 {
             LAYOUTGET_READ          = 1,
             LAYOUTGET_RW            = 2
     };

     struct LAYOUTGET4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             pnfs_layouttype4        layout_type;
             layoutget_iomode4       iomode;
             offset4                 offset;
             length4                 length;
     };

   RESULT

     struct LAYOUTGET4resok {
             pnfs_layout4            layout;
     };

     union LAYOUTGET4res switch (nfsstat4 status) {
             case NFS4_OK:
                     LAYOUTGET4resok resok4;
             default:
                     void;
     };



Welch, et al.           Expires December 11, 2005              [Page 30]

Internet-Draft               pNFS Operations                   June 2005


   DESCRIPTION

   Requests a layout for reading or writing the file given by the
   filehandle at the byte range specified by offset and length.  Layouts
   are identified through the clientid, filehandle, and byte range
   (offset, length pair).  The iomode specifies whether the client
   intends to read or read/write the data pertaining to the layout.  The
   metadata server's use of the iomode may depend on the layout type
   being used.  The storage devices may validate I/O accesses against
   the iomode (and reject invalid accesses).

   As well, the metadata server may adjust the range of the returned
   layout based on striping patterns and usage implied by the iomode.
   The client must be prepared to get a layout that does not line up
   exactly with their request; there MUST be at least one byte of
   overlap between the layout returned by the server and the client's
   request, or the server SHOULD reject the request.  See Section 3.3
   for more details.

   The LAYOUTGET operation returns layout information for the specified
   byte range.  To get a layout from a specific offset through the end-
   of-file (no matter how long the file actually is) use a length field
   with all bits set to 1 (one).  If the length is zero, or if a length
   which is not all bits set to one is specified, and length when added
   to the offset exceeds the maximum 64-bit unsigned integer value, the
   error NFS4ERR_INVAL will result.

   The format of the returned layout is specific to the underlying file
   system.  Layout types other than the NFSv4 file layout type should be
   specified outside of this document.

   If layouts are not supported for the requested file or its containing
   file system the server SHOULD return NFS4ERR_LAYOUTUNAVAILABLE.

   If layout for the file is unavailable due to transient conditions,
   e.g. file sharing prohibits layouts, the server SHOULD return
   NFS4ERR_LAYOUTTRYLATER.

   On success, the current filehandle retains its value.

   IMPLEMENTATION

   Typically, LAYOUTGET will be called as part of a compound RPC after
   an OPEN operation and results in the client having location
   information for the file; a client may also hold a layout across
   multiple OPENs.  The client specifies a layout type that limits what
   kind of layout the server will return.  This prevents servers from
   issuing layouts that are unusable by the client.



Welch, et al.           Expires December 11, 2005              [Page 31]

Internet-Draft               pNFS Operations                   June 2005


   [Comment: The notion of the layout class indicating a sub-set of
   possible layout types is gone.  Now that the class is a flat number
   space, there is no official way to reference a "class" of layouts
   (e.g., files, blocks, or objects).  This means that the type in the
   LAYOUTGET may be too restrictive, or that it is up to the server to
   decide if it can give out a "closely associated" layout that the
   client may be able to use.]

   ERRORS

      NFS4ERR_INVAL

      NFS4ERR_NOTSUPP

      NFS4ERR_LAYOUTUNAVAILABLE

      NFS4ERR_LAYOUTTRYLATER


































Welch, et al.           Expires December 11, 2005              [Page 32]

Internet-Draft               pNFS Operations                   June 2005


9.2  LAYOUTCOMMIT - Commit writes made using a layout

   SYNOPSIS

     (cfh), layout_stateid, offset, length, neweof, newlayout -> neweof


   ARGUMENT

     union neweof4 switch (bool eofchanged) {
             case TRUE:
                     length4            eof;
             case FALSE:
                     void;
     };

     union newlayout4 switch (bool layoutchanged) {
             case TRUE:
                     pnfs_layouttypes4  layout;
             case FALSE:
                     void;
     };

     struct LAYOUTCOMMIT4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             neweof4                 neweof;
             offset4                 offset;
             length4                 length;
             newlayout4              newlayout;
     };

   RESULT

     struct LAYOUTCOMMIT4resok {
             neweof4                 neweof;
     };

     union LAYOUTCOMMIT4res switch (nfsstat4 status) {
             case NFS4_OK:
                     LAYOUTCOMMIT4resok  resok4;
             default:
                     void;
     };

   DESCRIPTION

   Commits changes in the layout portion represented by the current



Welch, et al.           Expires December 11, 2005              [Page 33]

Internet-Draft               pNFS Operations                   June 2005


   filehandle, clientid, and byte range.  Since layouts are sub-
   dividable, a smaller portion of a layout, retrieved via LAYOUTGET,
   may be committed.  The region being committed is specified through
   the byte range (length and offset).  Note: the "newlayout" field does
   not include the length and offset, as they are already specified in
   the arguments.

   The LAYOUTCOMMIT operation indicates that the client has completed
   writes using a layout obtained by a previous LAYOUTGET.  The client
   may have only written a subset of the data range it previously
   requested.  LAYOUTCOMMIT allows it to commit or discard provisionally
   allocated space and to update the server with a new end of file.  The
   metadata server may use the included new EOF as a hint.  If the
   metadata server changes the EOF of the file, it MUST return the new
   EOF as part of the results.

   The layout argument to LAYOUTCOMMIT describes what regions have been
   used and what regions can be deallocated.  NFSv4 file layout type
   implementations should ignore this field.  The resulting layout is
   still valid after LAYOUTCOMMIT and can be continued to be referenced
   by the clientid, filehandle, and byte range.

   The layout information is more verbose for block devices than for
   objects and files because the latter hide the details of block
   allocation behind their storage protocols.  At the minimum, the
   client needs to communicate changes to the end of file location back
   to the server, and its view of the file modify and access times
   (unless it wants the server to set those times to the time of
   LAYOUTCOMMIT).  For blocks, it needs to specify precisely which
   blocks have been used.

   The metadata server should use the time of the LAYOUTCOMMIT operation
   as the file modify time, unless it is able to determine that the file
   has not been updated since the last mtime update.  The client may use
   a SETATTR operation in a compound right after LAYOUTCOMMIT in order
   to override the access and modify times of the file.  See Section 3.5
   for more details.

   On success, the current filehandle retains its value.

   ERRORS

      NFS4ERR_INVAL

      NFS4ERR_BADLAYOUT

      TBD




Welch, et al.           Expires December 11, 2005              [Page 34]

Internet-Draft               pNFS Operations                   June 2005


9.3  LAYOUTRETURN - Release Layout Information

   SYNOPSIS

     (cfh), clientid, offset, length -> -

   ARGUMENT

     struct LAYOUTRETURN4args {
             /* CURRENT_FH: file */
             clientid4       clientid;
             offset4         offset;
             length4         length;
     };

   RESULT

     struct LAYOUTRETURN4res {
             nfsstat4        status;
     };

   DESCRIPTION

   Returns the layout represented by the current filehandle, clientid,
   and byte range.  After this call, the client MUST NOT use the layout
   and the associated storage protocol to access the file data.  The
   layout being returned may be a subdivision of a layout previously
   fetched through LAYOUTGET.  If the length is all 1s, the layout
   covers the range from offset to EOF.

   Layouts may be returned when recalled or voluntarily (i.e., before
   the server has recalled them).  In either case the client must
   properly propagate state changed under the context of the layout to
   storage or to the server before returning the layout.

   If a client fails to return a layout in a timely manner, then the
   metadata server should use its management protocol with the storage
   devices to fence the client from accessing the data referenced by the
   layout.  See Section 3.4 for more details.

   On success, the current filehandle retains its value.

   [TODO: We need to work out how clients return error information if
   they encounter problems with storage (if they should).  We could
   return a single OK bit, or we could return more extensive information
   from the layout driver that describes the error condition in more
   detail.  We could use an opaque "layout_error" type that is defined
   by the storage protocol along with its layout types.]



Welch, et al.           Expires December 11, 2005              [Page 35]

Internet-Draft               pNFS Operations                   June 2005


   [There is a proposal for communicating extended error information in
   the "newlayout" argument to LAYOUTCOMMIT.  This could provide an
   additional status code for each device in the layout, for example.]

   ERRORS

      NFS4ERR_INVAL

      NFS4ERR_BADLAYOUT

      TBD


9.4  GETDEVICEINFO - Get Device Information

   SYNOPSIS

     (cfh), device_id -> device_addr

   ARGUMENT

     struct GETDEVICEINFO4args {
             pnfs_deviceid4                  device_id;
     };

   RESULT

     struct GETDEVICEINFO4resok {
             pnfs_devaddr4                   device_addr;
     };

     union GETDEVICEINFO4res switch (nfsstat4 status) {
             case NFS4_OK:
                     GETDEVICEINFO4resok     resok4;
             default:
                     void;
     };

   DESCRIPTION

   Returns device type and device address information for a specified
   device.  The returned device_addr includes a type that indicates how
   to interpret the addressing information for that device.  At this
   time we expect two main kinds of device addresses, either IP address
   and port numbers, or SCSI volume identifiers.  The final protocol
   specification will detail the allowed values for device_type and the
   format of their associated location information.




Welch, et al.           Expires December 11, 2005              [Page 36]

Internet-Draft               pNFS Operations                   June 2005


   See Section 3.1.1 for more details on device ID assignment.

9.5   GETDEVICELIST - Get List of Devices

   SYNOPSIS

     (cfh), max_bytes, cookie, cookie_verf -> device_addr<>

   ARGUMENT

     struct GETDEVICELIST4args {
             /* Current file handle */
             uint32_t                        max_bytes;
             nfs_cookie4                     cookie;
             verifier4                       cookie_verf;
     };

   RESULT

     struct GETDEVICELIST4resok {
             pnfs_devlist_item4              device_addr_list<>;
     };

     union GETDEVICEINFO4res switch (nfsstat4 status) {
             case NFS4_OK:
                     GETDEVICEINFO4resok     resok4;
             default:
                     void;
     };

   DESCRIPTION

   In some applications, especially SAN environments, it is convenient
   to find out about all the devices associated with a file system.
   This lets a client determine if it has access to these devices, e.g.,
   at mount time.

   This operation returns a list of items that establish the association
   between the short pnfs_deviceid4 and the addressing information for
   that device.  This operation may not be able to fetch all device
   information at once, thus it uses a cookie based approach, similar to
   READDIR, to fetch additional device information.

10.  Callback Operations







Welch, et al.           Expires December 11, 2005              [Page 37]

Internet-Draft               pNFS Operations                   June 2005


10.1  CB_LAYOUTRECALL

   SYNOPSIS

     fh, offset, length -> -

   ARGUMENT

     struct CB_LAYOUTRECALLargs {
             nfs_fh4         fh;
             offset4         offset;
             length4         length;
     };

   RESULT

     struct CB_LAYOUTRECALLres {
             nfsstat4        status;
     };

   DESCRIPTION

   The CB_LAYOUTRECALL operation is used to begin the process of
   recalling a layout, or a portion thereof, and returning it to the
   server.  The offset and length fields specify the portion of the
   layout to be returned.  A length of all 1s specifies that the layout
   to EOF MUST be returned.

   If the handle specified is not one for which the client holds a
   layout, an NFS4ERR_BADHANDLE error is returned.

   If the layout byte range specified does not correspond to a valid
   layout for the file specified by the filehandle, an NFS4ERR_BADLAYOUT
   is returned.  If the byte range overlaps with a layout being held,
   the portion of the layout represented by the overlap MUST be
   returned.

   IMPLEMENTATION

   The client should reply to the callback immediately.  Replying does
   not complete the recall except when an error was returned.  The
   recall is not complete until the layout is returned using a
   LAYOUTRETURN.

   The client should complete any in-flight I/O operations using the
   recalled layout before returning it via LAYOUTRETURN.  If the client
   has buffered dirty data, it may chose to write it directly to storage
   before calling LAYOUTRETURN, or to write it later using normal NFSv4



Welch, et al.           Expires December 11, 2005              [Page 38]

Internet-Draft               pNFS Operations                   June 2005


   WRITE operations to the metadata server.

   ERRORS

      NFS4ERR_BADHANDLE

      NFS4ERR_BADLAYOUT


10.2  CB_EOFCHANGED

   SYNOPSIS

     fh, eof -> -

   ARGUMENT

     struct CB_EOFCHANGEDargs {
             nfs_fh4         fh;
             length4         eof;
     };

   RESULT

     struct CB_EOFCHANGEDres {
             nfsstat4        status;
     };

   DESCRIPTION

   The CB_EOFCHANGED operation is used to notify the client that the EOF
   pertaining to the filehandle associated with "fh", has changed.  The
   new EOF is specified in the "eof" field.  Upon reception of this
   notification callback, the client should update its internal EOF for
   the file.  If the layout being held for the file is of the NFSv4 file
   layout type, then the EOF field within that layout should be updated
   (see Section 5.5.1).  For other layout types see Section 3.5.1 for
   more details.

   If the handle specified is not one for which the client holds a
   layout, an NFS4ERR_BADHANDLE error is returned.

   ERRORS

      NFS4ERR_BADHANDLE






Welch, et al.           Expires December 11, 2005              [Page 39]

Internet-Draft               pNFS Operations                   June 2005


11.  Usage Scenarios

   This section has a description of common open, close, read, write
   interactions and how those work with layout delegations.  [TODO: this
   section feels rough and I'm not sure it adds value in its present
   form.]

11.1  Basic Read Scenario

   Client does an OPEN to get a file handle.  Client does a LAYOUTGET
   for a range of the file, gets back a layout.  Client uses the storage
   protocol and the layout to access the file.  Client returns the
   layout with LAYOUTRETURN.  Client closes stateID and open delegation
   with CLOSE.

   This is rather boring as the client is careful to clean up all server
   state after only a single use of the file.

11.2  Multiple Reads to a File

   Client does an OPEN to get a file handle.  Client does a LAYOUTGET
   for a range of the file, gets back a layout.  Client uses the storage
   protocol and the layout to access the file.  Client closes stateID
   and with CLOSE.

   Client does an OPEN to get a file handle.  Client finds cached layout
   associated with file handle.  Client uses the storage protocol and
   the layout to access the file.  Client closes stateID and with CLOSE.

   A bit more interesting as we've saved the LAYOUTGET operation, but we
   are still doing server round-trips.

11.3  Multiple Reads to a File with Delegations

   Client does an OPEN to get a file handle and an open delegation.
   Client does a LAYOUTGET for a range of the file, gets back a layout.
   Client uses the storage protocol and the layout to access the file.
   Application does a close(), but client keeps state under the
   delegation. (time passes) Application does another open(), which
   client handles under the delegation.  Client finds cached layout
   associated with file handle.  Client uses the storage protocol and
   the layout to access the file. (pattern continues until open
   delegation and/or layout is recalled)

   This illustrates the efficiency of combining open delegations and
   layouts to eliminate interactions with the file server altogether.
   Of course, we assume the client's operating system is only allowing
   the local open() to succeed based on the file permissions.  The use



Welch, et al.           Expires December 11, 2005              [Page 40]

Internet-Draft               pNFS Operations                   June 2005


   of layouts does not change anything about the semantics of open
   delegations.

11.4  Read with existing writers

   NOTE: This scenario was under some debate, but we have resolved that
   the server is able to give out overlapping/conflicting layout
   information to different clients.  In these cases we assume that
   clients are using an external mechanism such as MPI-IO to synchronize
   and serialize access to shared data.  One can argue that even
   unsynchronized clients get the same open-to-close consistency
   semantics as NFS already provides, even when going direct to storage.

   Client does an OPEN to get an open stateID and open delegation.  The
   file is open for writing elsewhere by different clients and so no
   open delegation is returned.  Client does a LAYOUT get and gets a
   layout from the server.  Client either synchronizes with the writers,
   or not, and accesses data via the layout and storage protocol.  There
   are no guarantees about when data that is written by the writer is
   visible to the reader.  Once the writer has closed the file and
   flushed updates to storage, then they are visible to the client.

   [We should state explicitly that COMMIT and LAYOUTCOMMIT represent
   explicit points where changes should be visible to other clients.]

11.5  Read with later conflict

   ClientA does an OPEN to get an open stateID and open delegation.
   ClientA does a LAYOUTGET for a range of the file, gets back a map and
   layout stateid.  ClientA uses the storage protocol to access the file
   data.  ClientB opens the file for WRITE.  File server issues
   CB_RECALL to ClientA.  ClientA issues DELEGRETURN.

   ClientA continues to use the storage protocol to access file data.
   If it is accessing data from its cache, it will periodically check
   that its data is still up-to-date because it has no open delegation.
   [This is an odd scenario that mixes in open delegations for no real
   value.  Basically this is a "regular writer" being mixed with a pNFS
   reader.  I guess this example shows that no particular semantics are
   provided during the simultaneous access.  If the server so chose, it
   could also recall the layout with CB_LAYOUTRECALL to force the
   different clients to serialize at the file server.]

11.6  Basic Write Case

   Client does an OPEN to get a file handle.  Client does a LAYOUTGET
   for a range of the file, gets back a layout and layout stateid.
   Client writes to the file using the storage protocol.  Client uses



Welch, et al.           Expires December 11, 2005              [Page 41]

Internet-Draft               pNFS Operations                   June 2005


   LAYOUTCOMMIT to communicate new EOF position.  Client does SETATTR to
   update timestamps.  Client does a LAYOUTRETURN.  Client does a CLOSE.

   Again, the boring case where the client cleans up all of its server
   state by returning the layout.

11.7  Large Write Case

   Client does an OPEN to get a file handle. (loop.)  Client does a
   LAYOUTGET for a range of the file, gets back a layout and layout
   stateid.  Client writes to the file using the storage protocol.
   Client fills up the range covered by the layout.  Client updates the
   server with LAYOUTCOMMIT, communicating about new EOF position.
   Client does SETATTR to update timestamps.  Client releases the layout
   with LAYOUTRELEASE. (end loop.)  Client does a CLOSE.

11.8  Create with special layout

   Client does an OPEN and a SETATTR that specifies a particular layout
   type using the LAYOUT_HINT attribute.  Client gets back an open
   stateID and file handle. (etc)

12.  Layouts and Aggregation

   This section describes several layout formats in a semi-formal way to
   provide context for the layout delegations.  These definitions will
   be formalized in other protocols.  However, the set of understood
   types is part of this protocol in order to provide for basic
   interoperability.

   The layout descriptions include (deviceID, objectID) tuples that
   identify some storage object on some storage device.  The addressing
   formation associated with the deviceID is obtained with
   GETDEVICEINFO.  The interpretation of the objectID depends on the
   storage protocol.  The objectID could be a filehandle for an NFSv4
   storage device.  It could be a OSD object ID for an object server.
   The layout for a block device generally includes additional block map
   information to enumerate blocks or extents that are part of the
   layout.

12.1  Simple Map

   The data is located on a single storage device.  In this case the
   file server can act as the front end for several storage devices and
   distribute files among them.  Each file is limited in its size and
   performance characteristics by a single storage device.  The simple
   map consists of (deviceID, objectID).




Welch, et al.           Expires December 11, 2005              [Page 42]

Internet-Draft               pNFS Operations                   June 2005


12.2  Block Map

   The data is located on a LUN in the SAN.  The layout consists of an
   array of (deviceID, blockID, blocksize) tuples.  Alternatively, the
   blocksize could be specified once to apply to all entries in the
   layout.

12.3  Striped Map (RAID 0)

   The data is striped across storage devices.  The parameters of the
   stripe include the number of storage devices (N) and the size of each
   stripe unit (U).  A full stripe of data is N * U bytes.  The stripe
   map consists of an ordered list of (deviceID, objectID) tuples and
   the parameter value for U. The first stripe unit (the first U bytes)
   are stored on the first (deviceID, objectID), the second stripe unit
   on the second (deviceID, objectID) and so forth until the first
   complete stripe.  The data layout then wraps around so that byte
   (N*U) of the file is stored on the first (deviceID, objectID) in the
   list, but starting at offset U within that object.  The striped
   layout allows a client to read or write to the component objects in
   parallel to achieve high bandwidth.

   The striped map for a block device would be slightly different.  The
   map is an ordered list of (deviceID, blockID, blocksize), where the
   deviceID is rotated among a set of devices to achieve striping.

12.4  Replicated Map

   The file data is replicated on N storage devices.  The map consists
   of N (deviceID, objectID) tuples.  When data is written using this
   map, it should be written to N objects in parallel.  When data is
   read, any component object can be used.

   This map type is controversial because it highlights the issues with
   error recovery.  Those issues get interesting with any scheme that
   employs redundancy.  The handling of errors (e.g., only a subset of
   replicas get updated) is outside the scope of this protocol
   extension.  Instead, it is a function of the storage protocol and the
   metadata management protocol.

12.5  Concatenated Map

   The map consists of an ordered set of N (deviceID, objectID, size)
   tuples.  Each successive tuple describes the next segment of the
   file.






Welch, et al.           Expires December 11, 2005              [Page 43]

Internet-Draft               pNFS Operations                   June 2005


12.6  Nested Map

   The nested map is used to compose more complex maps out of simpler
   ones.  The map format is an ordered set of M sub-maps, each submap
   applies to a byte range within the file and has its own type such as
   the ones introduced above.  Any level of nesting is allowed in order
   to build up complex aggregation schemes.

13.  Issues

13.1  Storage Protocol Negotiation

   Clients may want to negotiate with the metadata server about their
   preferred storage protocol, and to find out what storage protocols
   the server offers.  Client can do this by querying the LAYOUT_TYPES
   file system attribute.  They respond by specifying a particular
   layout type in their LAYOUTGET operation.

13.2  Crash recovery

   We use the existing client crash recovery and server state recovery
   mechanisms in NFSv4.  The main new issue introduced by pNFS is that
   the client may have to do a lot of I/O in response to a layout
   recall.  The client may need to remember to send RENEW ops to the
   server during this period if it were to risk not doing anything
   within the lease time.  Of course, the client should only reply with
   its LAYOUTRETURN after it knows its I/O has completed.

13.3  Storage Errors

   As noted under LAYOUTRETURN, there may be a need for the client to
   communicate about errors it has when accessing storage directly.

14.  Normative References

   [1]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", March 1997.

   [2]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame,
        C., Eisler, M., and D. Noveck, "Network File System (NFS)
        version 4 Protocol", RFC 3530, April 2003.

   [3]  Weber, R., "Object-Based Storage Device Commands (OSD)",
        INCITS 400-2004, July 2004,
        <http://www.t10.org/ftp/t10/drafts/osd/osd-r10.pdf>.

   [4]  Gibson, G., "pNFS Problem Statement", July 2004, <ftp://
        www.ietf.org/internet-drafts/



Welch, et al.           Expires December 11, 2005              [Page 44]

Internet-Draft               pNFS Operations                   June 2005


        draft-gibson-pnfs-problem-statement-01.txt>.


Authors' Addresses

   Brent Welch
   Panasas, Inc.
   6520 Kaiser Drive
   Fremont, CA  95444
   USA

   Phone: +1-650-608-7770
   Email: welch@panasas.com
   URI:   http://www.panasas.com/


   Benny Halevy
   Panasas, Inc.
   1501 Reedsdale St., #400
   Pittsburgh, PA  15233
   USA

   Phone: +1-412-323-3500
   Email: bhalevy@panasas.com
   URI:   http://www.panasas.com/


   Garth Goodson
   Network Appliance
   495 E. Java Dr
   Sunnyvale, CA  94089
   USA

   Phone: +1-408-822-6847
   Email: goodson@netapp.com


   David L. Black
   EMC Corporation
   176 South Street
   Hopkinton, MA  01748
   USA

   Phone: +1-508-293-7953
   Email: black_david@emc.com






Welch, et al.           Expires December 11, 2005              [Page 45]

Internet-Draft               pNFS Operations                   June 2005


   Andy Adamson
   CITI University of Michigan
   519 W. William
   Ann Arbor, MI  48103-4943
   USA

   Phone: +1-734-764-9465
   Email: andros@umich.edu

Appendix A.  Acknowledgments

   Many members of the pNFS informal working group have helped
   considerably.  The authors would like to thank Gary Grider, Peter
   Corbett, Dave Noveck, and Peter Honeyman.  This work is inspired by
   the NASD and OSD work done by Garth Gibson.  Gary Grider of the
   national labs (LANL) has been a champion of high-performance parallel
   I/O.


































Welch, et al.           Expires December 11, 2005              [Page 46]

Internet-Draft               pNFS Operations                   June 2005


Intellectual Property Statement

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Copyright Statement

   Copyright (C) The Internet Society (2005).  This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Acknowledgment

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Welch, et al.           Expires December 11, 2005              [Page 47]

