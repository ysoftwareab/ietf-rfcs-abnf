<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>A Common API for Transparent Hybrid Multicast</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Use Cases for the Common API">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Overview">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Objectives and Reference Scenarios">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Group Communication API &amp; Protocol Stack">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Naming and Addressing">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Mapping">
<link href="#rfc.section.4" rel="Chapter" title="4 Common Multicast API">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Notation">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Abstract Data Types">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Multicast URI">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Interface">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Membership Events">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Group Management Calls">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Create">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Delete">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Join">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 Leave">
<link href="#rfc.section.4.3.5" rel="Chapter" title="4.3.5 Source Register">
<link href="#rfc.section.4.3.6" rel="Chapter" title="4.3.6 Source Deregister">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Send and Receive Calls">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Send">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Receive">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Socket Options">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Get Interfaces">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Add Interface">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Delete Interface">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 Set TTL">
<link href="#rfc.section.4.5.5" rel="Chapter" title="4.5.5 Get TTL">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Service Calls">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Group Set">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 Neighbor Set">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 Children Set">
<link href="#rfc.section.4.6.4" rel="Chapter" title="4.6.4 Parent Set">
<link href="#rfc.section.4.6.5" rel="Chapter" title="4.6.5 Designated Host">
<link href="#rfc.section.4.6.6" rel="Chapter" title="4.6.6 Enable Membership Events">
<link href="#rfc.section.4.6.7" rel="Chapter" title="4.6.7 Disable Membership Events">
<link href="#rfc.section.5" rel="Chapter" title="5 Functional Details">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Namespaces">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A C Signatures">
<link href="#rfc.appendix.Appendix%20B" rel="Chapter" title="Appendix B Practical Example of the API">
<link href="#rfc.appendix.Appendix%20C" rel="Chapter" title="Appendix C Deployment Use Cases for Hybrid Multicast">
<link href="#rfc.appendix.Appendix%20C.1" rel="Chapter" title="Appendix C.1 DVMRP">
<link href="#rfc.appendix.Appendix%20C.2" rel="Chapter" title="Appendix C.2 PIM-SM">
<link href="#rfc.appendix.Appendix%20C.3" rel="Chapter" title="Appendix C.3 PIM-SSM">
<link href="#rfc.appendix.Appendix%20C.4" rel="Chapter" title="Appendix C.4 BIDIR-PIM">
<link href="#rfc.appendix.Appendix%20D" rel="Chapter" title="Appendix D Change Log">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="Group communication services exist in a large variety of flavors, and technical implementations at different protocol layers. Multicast data distribution is most efficiently performed on the lowest available layer, but a heterogeneous deployment status of multicast technologies throughout the Internet requires an adaptive service binding at runtime.  Today, it is difficult to write an application that runs everywhere and at the same time makes use of the most efficient multicast service available in the network. Facing robustness requirements, developers are frequently forced to use a stable, upper layer protocol controlled by the application itself. This document describes a common multicast API that is suitable for transparent communication in underlay and overlay, and grants access to the different multicast flavors. It proposes an abstract naming by multicast URIs and discusses mapping mechanisms between different namespaces and distribution technologies.  Additionally, it describes the application of this API for building gateways that interconnect current multicast domains throughout the Internet." />
  <meta name="description" content="Group communication services exist in a large variety of flavors, and technical implementations at different protocol layers. Multicast data distribution is most efficiently performed on the lowest available layer, but a heterogeneous deployment status of multicast technologies throughout the Internet requires an adaptive service binding at runtime.  Today, it is difficult to write an application that runs everywhere and at the same time makes use of the most efficient multicast service available in the network. Facing robustness requirements, developers are frequently forced to use a stable, upper layer protocol controlled by the application itself. This document describes a common multicast API that is suitable for transparent communication in underlay and overlay, and grants access to the different multicast flavors. It proposes an abstract naming by multicast URIs and discusses mapping mechanisms between different namespaces and distribution technologies.  Additionally, it describes the application of this API for building gateways that interconnect current multicast domains throughout the Internet." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">SAM Research Group</td>
<td class="right">M. Waehlisch</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">link-lab &amp; FU Berlin</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">T C. Schmidt</td>
</tr>
<tr>
<td class="left">Expires: January 13, 2012</td>
<td class="right">HAW Hamburg</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">S. Venaas</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">cisco Systems</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 12, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">A Common API for Transparent Hybrid Multicast<br />
  <span class="filename">draft-irtf-samrg-common-api-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Group communication services exist in a large variety of flavors, and technical implementations at different protocol layers. Multicast data distribution is most efficiently performed on the lowest available layer, but a heterogeneous deployment status of multicast technologies throughout the Internet requires an adaptive service binding at runtime.  Today, it is difficult to write an application that runs everywhere and at the same time makes use of the most efficient multicast service available in the network. Facing robustness requirements, developers are frequently forced to use a stable, upper layer protocol controlled by the application itself. This document describes a common multicast API that is suitable for transparent communication in underlay and overlay, and grants access to the different multicast flavors. It proposes an abstract naming by multicast URIs and discusses mapping mechanisms between different namespaces and distribution technologies.  Additionally, it describes the application of this API for building gateways that interconnect current multicast domains throughout the Internet.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 13, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Use Cases for the Common API</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Overview</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Objectives and Reference Scenarios</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Group Communication API &amp; Protocol Stack</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Naming and Addressing</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Mapping</a>
</li>
<li>4.   <a href="#rfc.section.4">Common Multicast API</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Notation</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Abstract Data Types</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Multicast URI</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Interface</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Membership Events</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Group Management Calls</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Create</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Delete</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Join</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">Leave</a>
</li>
<li>4.3.5.   <a href="#rfc.section.4.3.5">Source Register</a>
</li>
<li>4.3.6.   <a href="#rfc.section.4.3.6">Source Deregister</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Send and Receive Calls</a>
</li>
<li>4.4.1.   <a href="#rfc.section.4.4.1">Send</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Receive</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Socket Options</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">Get Interfaces</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Add Interface</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Delete Interface</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">Set TTL</a>
</li>
<li>4.5.5.   <a href="#rfc.section.4.5.5">Get TTL</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Service Calls</a>
</li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">Group Set</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">Neighbor Set</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">Children Set</a>
</li>
<li>4.6.4.   <a href="#rfc.section.4.6.4">Parent Set</a>
</li>
<li>4.6.5.   <a href="#rfc.section.4.6.5">Designated Host</a>
</li>
<li>4.6.6.   <a href="#rfc.section.4.6.6">Enable Membership Events</a>
</li>
<li>4.6.7.   <a href="#rfc.section.4.6.7">Disable Membership Events</a>
</li>
<li>5.   <a href="#rfc.section.5">Functional Details</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Namespaces</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Acknowledgements</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">C Signatures</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.Appendix%20B">Practical Example of the API</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.Appendix%20C">Deployment Use Cases for Hybrid Multicast</a>
</li>
<li>Appendix C.1.   <a href="#rfc.appendix.Appendix%20C.1">DVMRP</a>
</li>
<li>Appendix C.2.   <a href="#rfc.appendix.Appendix%20C.2">PIM-SM</a>
</li>
<li>Appendix C.3.   <a href="#rfc.appendix.Appendix%20C.3">PIM-SSM</a>
</li>
<li>Appendix C.4.   <a href="#rfc.appendix.Appendix%20C.4">BIDIR-PIM</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.Appendix%20D">Change Log</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Currently, group application programmers need to make the choice of the distribution technology that the application will require at runtime. There is no common communication interface that abstracts multicast transmission and subscriptions from the deployment state at runtime. The standard multicast socket options <a href="#RFC3493">[RFC3493]</a>, <a href="#RFC3678">[RFC3678]</a> are bound to an IP version and do not distinguish between naming and addressing of multicast identifiers. Group communication, however, is commonly implemented in different flavors such as any source (ASM) vs. source specific multicast (SSM), on different layers (e.g., IP vs. application layer multicast), and may be based on different technologies on the same tier as with IPv4 vs. IPv6. It is the objective of this document to provide a universal access to group services.</p>
<p id="rfc.section.1.p.2">Multicast application development should be decoupled of technological deployment throughout the infrastructure. It requires a common multicast API that offers calls to transmit and receive multicast data independent of the supporting layer and the underlying technological details. For inter-technology transmissions, a consistent view on multicast states is needed, as well. This document describes an abstract group communication API and core functions necessary for transparent operations. Specific implementation guidelines with respect to operating systems or programming languages are out-of-scope of this document.</p>
<p id="rfc.section.1.p.3">In contrast to the standard multicast socket interface, the API introduced in this document abstracts naming from addressing. Using a multicast address in the current socket API predefines the corresponding routing layer. In this specification, the multicast name used for joining a group denotes an application layer data stream that is identified by a multicast URI, independent of its binding to a specific distribution technology. Such a group name can be mapped to variable routing identifiers.</p>
<p id="rfc.section.1.p.4">The aim of this common API is twofold: </p>

<ul>
<li>Enable any application programmer to implement group-oriented data communication independent of the underlying delivery mechanisms. In particular, allow for a late binding of group applications to multicast technologies that makes applications efficient, but robust with respect to deployment aspects.</li>
<li>Allow for a flexible namespace support in group addressing, and thereby separate naming and addressing/routing schemes from the application design. This abstraction does not only decouple programs from specific aspects of underlying protocols, but may open application design to extend to specifically flavored group services.</li>
</ul>
<p id="rfc.section.1.p.5">Multicast technologies may be of various P2P kinds, IPv4 or IPv6 network layer multicast, or implemented by some other application service. Corresponding namespaces may be IP addresses or DNS naming, overlay hashes, or other application layer group identifiers like &lt;sip:*@peanuts.org&gt; but also names independently defined by the applications. Common namespaces are introduced later in this document, but follow an open concept suitable for further extensions.</p>
<p id="rfc.section.1.p.6">This document also proposes and discusses mapping mechanisms between different namespaces and forwarding technologies. Additionally, the multicast API provides internal interfaces to access current multicast states at the host. Multiple multicast protocols may run in parallel on a single host. These protocols may interact to provide a gateway function that bridges data between different domains. The application of this API at gateways operating between current multicast instances throughout the Internet is described, as well.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Use Cases for the Common API</h1>
<p id="rfc.section.1.1.p.1">Four generic use cases can be identified that require an abstract common API for multicast services:</p>
<p></p>

<dl>
<dt>Application Programming Independent of Technologies:</dt>
<dd style="margin-left: 8">Application programmers are provided with group primitives that remain independent of multicast technologies and their deployment in target domains. They are thus enabled to develop programs once that run in every deployment scenario. The employment of group names in the form of abstract meta data types allows applications to remain namespace-agnostic in the sense that the resolution of namespaces and name-to-address mappings may be delegated to a system service at runtime. Thereby, the complexity is minimized as developers need not care about how data is distributed in groups, while the system service can take advantage of extended information of the network environment as acquired at startup.</dd>
<dt>Global Identification of Groups:</dt>
<dd style="margin-left: 8">Groups can be identified independent of technological instantiations and beyond deployment domains. Taking advantage of the abstract naming, an application is thus enabled to match data received from different interface technologies (e.g., IPv4, IPv6, or overlays) to belong to the same group. This not only increases flexibility, an application may for instance combine heterogeneous multipath streams, but also simplifies the design and implementation of gateways and translators.</dd>
<dt>Simplified Service Deployment through Generic Gateways:</dt>
<dd style="margin-left: 8">The common multicast API allows for an implementation of abstract gateway functions with mappings to specific technologies residing at a system level. Such generic gateways may provide a simple bridging service and facilitate an inter-domain deployment of multicast.</dd>
<dt>Mobility-agnostic Group Communication:</dt>
<dd style="margin-left: 8">Group naming and management as foreseen in the common multicast API remain independent of locators. Naturally, applications stay unaware of any mobility-related address changes. Handover-initiated re-addressing is delegated to the mapping services at the system level and may be designed to smoothly interact with mobility management solutions provided at the network or transport layer.</dd>
</dl>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology</h1>
<p id="rfc.section.2.p.1">This document uses the terminology as defined for the multicast protocols <a href="#RFC2710">[RFC2710]</a>,<a href="#RFC3376">[RFC3376]</a>,<a href="#RFC3810">[RFC3810]</a>,<a href="#RFC4601">[RFC4601]</a>,<a href="#RFC4604">[RFC4604]</a>. In addition, the following terms will be used.</p>
<p></p>

<dl>
<dt>Group  Address:</dt>
<dd style="margin-left: 8">A Group Address is a routing identifier. It represents a technological specifier and thus reflects the distribution technology in use. Multicast packet forwarding is based on this ID.</dd>
<dt>Group Name:</dt>
<dd style="margin-left: 8">A Group Name is an application identifier that is used by applications to manage communication in a multicast group (e.g., join/leave and send/receive). The Group Name does not predefine any distribution technologies, even if it syntactically corresponds to an address, but represents a logical identifier.</dd>
<dt>Multicast Namespace:</dt>
<dd style="margin-left: 8">A Multicast Namespace is a collection of designators (i.e., names or addresses) for groups that share a common syntax. Typical instances of namespaces are IPv4 or IPv6 multicast addresses, overlay group IDs, group names defined on the application layer (e.g., SIP or Email), or some human readable strings.</dd>
<dt>Interface:</dt>
<dd style="margin-left: 8">An Interface is a forwarding instance of a distribution technology on a given node. For example, the IP interface 192.168.1.1 at an IPv4 host.</dd>
<dt>Multicast Domain:</dt>
<dd style="margin-left: 8">A Multicast Domain hosts nodes and routers of a common, single multicast forwarding technology and is bound to a single namespace.</dd>
<dt>Inter-domain Multicast Gateway (IMG):</dt>
<dd style="margin-left: 8">An Inter-domain Multicast Gateway (IMG) is an entity that interconnects different Multicast Domains. Its objective is to forward data between these domains, e.g., between IP layer and overlay multicast.</dd>
</dl>
<p></p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Overview</h1>
<p></p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Objectives and Reference Scenarios</h1>
<p id="rfc.section.3.1.p.1">The default use case addressed in this document targets at applications that participate in a group by using some common identifier taken from some common namespace. This Group Name is typically learned at runtime from user interaction like the selection of an IPTV channel, from dynamic session negotiations like in the Session Initiation Protocol (SIP), but may as well have been predefined for an application as a common Group Name.  Technology-specific system functions then transparently map the Group Name to Group Addresses such that</p>

<ul>
<li>programmers are enabled to process group names in their programs without the need to consider technological mappings to designated deployments in target domains;</li>
<li>applications are enabled to identify packets that belong to a logically named group, independent of the interface technology used for sending and receiving packets. The latter shall also hold for multicast gateways.</li>
</ul>
<p id="rfc.section.3.1.p.2">This document considers two reference scenarios that cover the following hybrid deployment cases displayed in <a href="#fig:reference">Figure 1</a>:</p>
<p></p>

<ol>
<li>Multicast Domains running the same multicast technology but remaining isolated, possibly only connected by network layer unicast.</li>
<li>Multicast Domains running different multicast technologies but hosting nodes that are members of the same multicast group.</li>
</ol>
<div id="#rfc.figure.1"></div>
<div id="#fig:reference"></div>
<pre> 
                                        +-------+         +-------+
                                        | Member|         | Member|
                                        |  Foo  |         |   G   |
                                        +-------+         +-------+
                                              \            /
                                            ***  ***  ***  ***
                                           *   **   **   **   *
                                          *                    *
                                           *   MCast Tec A    *
                                          *                    *
                                           *   **   **   **   *
                                            ***  ***  ***  ***
   +-------+          +-------+                      |                
   | Member|          | Member|                  +-------+          
   |   G   |          |  Foo  |                  |  IMG  |   
   +-------+          +-------+                  +-------+          
       |                |                            |                
       ***  ***  ***  ***                  ***  ***  ***  ***
      *   **   **   **   *                *   **   **   **   *
     *                    *  +-------+   *                    * 
      *   MCast Tec A    * --|  IMG  |--  *   MCast Tec B    *    +-------+
     *                    *  +-------+   *                    * - | Member|
      *   **   **   **   *                *   **   **   **   *    |   G   |
       ***  ***  ***  ***                  ***  ***  ***  ***     +-------+

</pre>
<p></p>
<p id="rfc.section.3.1.p.5">It is assumed throughout the document that the domain composition, as well as the node attachment to a specific technology, remain unchanged during a multicast session.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Group Communication API &amp; Protocol Stack</h1>
<p id="rfc.section.3.2.p.1">The group communication API consists of four parts. Two parts combine the essential communication functions, while the remaining two offer optional extensions for an enhanced monitoring and management: </p>

<dl>
<dt>Group Management Calls</dt>
<dd style="margin-left: 8">provide the minimal API to instantiate a multicast socket and to manage group membership.</dd>
<dt>Send/Receive Calls</dt>
<dd style="margin-left: 8">provide the minimal API to send and receive multicast data in a technology-transparent fashion.</dd>
<dt>Socket Options</dt>
<dd style="margin-left: 8">provide extension calls for an explicit configuration of the multicast socket such as setting hop limits or associated interfaces.</dd>
<dt>Service Calls</dt>
<dd style="margin-left: 8">provide extension calls that grant access to internal multicast states of an interface such as the multicast groups under subscription or the multicast forwarding information base.</dd>
</dl>
<p id="rfc.section.3.2.p.2">Multicast applications that use the common API require assistance by a group communication stack. This protocol stack serves two needs:</p>
<p></p>

<ul>
<li>It provides system-level support to transfer the abstract functions of the common API, including namespace support, into protocol operations at interfaces.</li>
<li>It bridges data distribution between different multicast technologies at the local host.</li>
</ul>
<p id="rfc.section.3.2.p.4">A general initiation of a multicast communication in this setting proceeds as follows:</p>
<p></p>

<ol>
<li>An application opens an abstract multicast socket.</li>
<li>The application subscribes/leaves/(de)registers to a group using a Group Name.</li>
<li>An intrinsic function of the stack maps the logical group ID (Group Name) to a technical group ID (Group Address). This function may make use of deployment-specific knowledge such as available technologies and group address management in its domain.</li>
<li>Packet distribution proceeds to and from one or several multicast-enabled interfaces.</li>
</ol>
<p id="rfc.section.3.2.p.6">The multicast socket describes a group communication channel composed of one or multiple interfaces. A socket may be created without explicit interface association by the application, which leaves the choice of the underlying forwarding technology to the group communication stack. However, an application may also bind the socket to one or multiple dedicated interfaces, which predefines the forwarding technology and the namespace(s) of the Group Address(es).</p>
<p id="rfc.section.3.2.p.7">Applications are not required to maintain mapping states for Group Addresses. The group communication stack accounts for the mapping of the Group Name to the Group Address(es) and vice versa. Multicast data passed to the application will be augmented by the corresponding Group Name. Multiple multicast subscriptions thus can be conducted on a single multicast socket without the need for Group Name encoding at the application side.</p>
<p id="rfc.section.3.2.p.8">Hosts may support several multicast protocols. The group communication stack discovers available multicast-enabled interfaces.  It provides a minimal hybrid function that bridges data between different interfaces and Multicast Domains. Details of service discovery are out-of-scope of this document.</p>
<p></p>
<p id="rfc.section.3.2.p.10">The extended multicast functions can be implemented by a middleware as conceptually visualized in <a href="#fig:middleware">Figure 2</a>.</p>
<p></p>
<div id="#rfc.figure.2"></div>
<div id="#fig:middleware"></div>
<pre>*-------*     *-------*     
| App 1 |     | App 2 |
*-------*     *-------*
    |             |
*---------------------*         ---|
|   Middleware        |            |
*---------------------*            |
     |          |                  |
*---------*     |                  |   
| Overlay |     |                   \  Group Communication
*---------*     |                   /  Stack
     |          |                  |
     |          |                  |
*---------------------*            |
|   Underlay          |            |
*---------------------*         ---|</pre>
<p></p>
<p></p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Naming and Addressing</h1>
<p id="rfc.section.3.3.p.1">Applications use Group Names to identify groups. Names can uniquely determine a group in a global communication context and hide technological deployment for data distribution from the application.  In contrast, multicast forwarding operates on Group Addresses. Even though both identifiers may be identical in symbols, they carry different meanings. They may also belong to different namespaces. The namespace of a Group Address reflects a routing technology, while the namespace of a Group Name represents the context in which the application operates.</p>
<p id="rfc.section.3.3.p.2">URIs <a href="#RFC3986">[RFC3986]</a> are a common way to represent namespace-specific identifiers in applications in the form of an abstract meta-data type. Throughout this document, any kind of Group Name follows a URI notation with the syntax defined in <a href="#sec:details-uri">Section 4.2.1</a>. Examples are, ip://224.1.2.3:5000 for a canonical IPv4 ASM group, sip://news@cnn.com for an application-specific naming with service instantiator and default port selection.</p>
<p id="rfc.section.3.3.p.3">An implementation of the group communication middleware can provide convenience functions that detect the namespace of a Group Name and use it to optimize service instantiation. In practice, such a library would provide support for high-level data types to the application, similar to the current socket API (e.g., InetAddress in Java). Using this data type could implicitly determine the namespace. Details of automatic namespace identification is out-of-scope of this document.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Mapping</h1>
<p id="rfc.section.3.4.p.1">All group members subscribe to the same Group Name taken from a common namespace and thereby identify the group in a technology-agnostic way.</p>
<p id="rfc.section.3.4.p.2">Group Names require a mapping to addresses prior to service instantiation at an Interface. Similarly, a mapping is needed at gateways to translate between Group Addresses from different namespaces. Some namespaces facilitate a canonical transformation to default address spaces. For example, ip://224.1.2.3:5000 has an obvious correspondence to 224.1.2.3 in the IPv4 multicast address space. Note that in this example the multicast URI can be completely recovered from any data packet received from this group.</p>
<p id="rfc.section.3.4.p.3">However, mapping in general can be more complex and need not be invertible. Mapping functions can be stateless in some contexts, but may require states in others. The application of such functions depends on the cardinality of the namespaces, the structure of address spaces, and possible address collisions. For example, it is not obvious how to map a large identifier space (e.g., IPv6) to a smaller, collision-prone set like IPv4.</p>
<p id="rfc.section.3.4.p.4">Two (or more) Multicast Addresses from different namespaces may belong to</p>
<p></p>

<ol style="list-style-type: lower-alpha">
<li>the same logical group (i.e., same Group Name)</li>
<li>different multicast channels (i.e., different Group Addresses).</li>
</ol>
<p id="rfc.section.3.4.p.6">A mapping can be realized by embedding smaller in larger namespaces or selecting an arbitrary, unused ID in the target space. The relation between logical and technical ID is maintained by mapping functions which can be stateless or stateful. The middleware thus queries the mapping service first, and creates a new technical group ID only if there is no identifier available for the namespace in use. The Group Name is associated with one or more Group Addresses, which belong to different namespaces. Depending on the scope of the mapping service, it ensures a consistent use of the technical ID in a local or global domain.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sec:capi" id="sec:capi">Common Multicast API</a>
</h1>
<p></p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Notation</h1>
<p id="rfc.section.4.1.p.1">The following description of the common multicast API is described in pseudo syntax. Variables that are passed to function calls are declared by "in", return values are declared by "out". A list of elements is denoted by &lt;&gt;. The pseudo syntax assumes that lists include an attribute which represents the number of elements.</p>
<p id="rfc.section.4.1.p.2">The corresponding C signatures are defined in <a href="#sec:c-signatures">Appendix Appendix A</a>.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Abstract Data Types</h1>
<p></p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#sec:details-uri" id="sec:details-uri">Multicast URI</a>
</h1>
<p id="rfc.section.4.2.1.p.1">Multicast Names and Multicast Addresses used in this API follow an URI scheme that defines a subset of the generic URI specified in <a href="#RFC3986">[RFC3986]</a> and is compliant with the guidelines in <a href="#RFC4395">[RFC4395]</a>.</p>
<p id="rfc.section.4.2.1.p.2">The multicast URI is defined as follows:</p>
<p></p>

<ul class="empty"><li>scheme "://" group "@" instantiation ":" port "/" sec-credentials</li></ul>
<p id="rfc.section.4.2.1.p.4">The parts of the URI are defined as follows:</p>
<p></p>

<dl>
<dt>scheme</dt>
<dd style="margin-left: 8">refers to the specification of the assigned identifier <a href="#RFC3986">[RFC3986]</a> which takes the role of the namespace.</dd>
<dt>group</dt>
<dd style="margin-left: 8">identifies the group uniquely within the namespace given in scheme.</dd>
<dt>instantiation</dt>
<dd style="margin-left: 8">identifies the entity that generates the instance of the group (e.g., a SIP domain or a source in SSM) using the namespace given in scheme.</dd>
<dt>port</dt>
<dd style="margin-left: 8">identifies a specific application at an instance of a group.</dd>
<dt>sec-credentials</dt>
<dd style="margin-left: 8">used to implement security credentials (e.g., to authorize a multicast group access).</dd>
</dl>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> Interface</h1>
<p id="rfc.section.4.2.2.p.1">The interface denotes the layer and instance on which the corresponding call will be effective. In agreement with <a href="#RFC3493">[RFC3493]</a> we identify an interface by an identifier, which is a positive integer starting at 1.</p>
<p id="rfc.section.4.2.2.p.2">Properties of an interface are stored in the following struct:</p>
<div id="#rfc.figure.3"></div>
<p></p>
<pre>    struct if_prop {
      unsigned int if_index; /* 1, 2, ... */
      char        *if_name;  /* "eth0", "eth1:1", "lo", ... */
      char        *if_addr;  /* "1.2.3.4", "abc123", ... */
      char        *if_tech;  /* "ip", "overlay", ... */                 
    };</pre>
<p></p>
<p id="rfc.section.4.2.2.p.4">The following function retrieves all available interfaces from the system:</p>
<p></p>
<div id="#rfc.figure.4"></div>
<p></p>
<pre>    getInterfaces(out Interface &lt;ifs&gt;);</pre>
<p id="rfc.section.4.2.2.p.6">It extends the functions for Interface Identification in <a href="#RFC3493">[RFC3493]</a> (cf., Section 4) and can be implemented by:</p>
<div id="#rfc.figure.5"></div>
<p></p>
<pre>    struct if_prop *if_prop(void);</pre>
<p></p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#sec:membership-events" id="sec:membership-events">Membership Events</a>
</h1>
<p id="rfc.section.4.2.3.p.1">A membership event is triggered by a multicast state change, which is observed by the current node. It is related to a specific Group Name and may be receiver or source oriented.</p>
<div id="#rfc.figure.6"></div>
<p></p>
<pre>    event_type {
            join_event;
            leave_event;
            new_source_event;
    };

    event { 
           event_type event;
           Uri group_name;
           Interface if;
    };
</pre>
<p></p>
<p id="rfc.section.4.2.3.p.3">An event will be created by the middleware and passed to applications that are registered for events.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Group Management Calls</h1>
<p></p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> Create</h1>
<p id="rfc.section.4.3.1.p.1">The create call initiates a multicast socket and provides the application programmer with a corresponding handle. If no interfaces will be assigned based on the call, the default interface will be selected and associated with the socket. The call may return an error code in the case of failures, e.g., due to a non-operational middleware.<em></em></p>
<div id="#rfc.figure.7"></div>
<p></p>
<pre>    createMSocket(in Interface &lt;ifs&gt;, 
                  out Socket s);</pre>
<p></p>
<p id="rfc.section.4.3.1.p.2">The if argument denotes a list of interfaces (if_indexes) that will be associated with the multicast socket. This parameter is optional.</p>
<p id="rfc.section.4.3.1.p.3">On success a multicast socket identifier is returned, otherwise NULL.</p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> Delete</h1>
<p id="rfc.section.4.3.2.p.1">The delete call removes the multicast socket.</p>
<div id="#rfc.figure.8"></div>
<p></p>
<pre>    deleteMSocket(in Socket s, out Int error);</pre>
<p></p>
<p id="rfc.section.4.3.2.p.2">The s argument identifies the multicast socket for destruction.</p>
<p id="rfc.section.4.3.2.p.3">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> Join</h1>
<p id="rfc.section.4.3.3.p.1">The join call initiates a subscription for the given group.  Depending on the interfaces that are associated with the socket, this may result in an IGMP/MLD report or overlay subscription, for example.</p>
<div id="#rfc.figure.9"></div>
<p></p>
<pre>    join(in Socket s, in Uri group_name, out Int error);</pre>
<p></p>
<p id="rfc.section.4.3.3.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.3.3.p.3">The group_name argument identifies the group.</p>
<p id="rfc.section.4.3.3.p.4">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> Leave</h1>
<p id="rfc.section.4.3.4.p.1">The leave call results in an unsubscription for the given Group Name.</p>
<div id="#rfc.figure.10"></div>
<p></p>
<pre>    leave(in Socket s, in Uri group_name, out Int error);</pre>
<p></p>
<p id="rfc.section.4.3.4.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.3.4.p.3">The group_name identifies the group.</p>
<p id="rfc.section.4.3.4.p.4">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.3.5">
<a href="#rfc.section.4.3.5">4.3.5.</a> Source Register</h1>
<p id="rfc.section.4.3.5.p.1">The srcRegister call registers a source for a Group on all active interfaces of the socket s. This call may assist group distribution in some technologies, the creation of sub-overlays, for example. Not all multicast technologies require his call.</p>
<div id="#rfc.figure.11"></div>
<p></p>
<pre>    srcRegister(in Socket s, in Uri group_name, 
                in Interface &lt;ifs&gt;, out Int error);</pre>
<p></p>
<p id="rfc.section.4.3.5.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.3.5.p.3">The group_name argument identifies the multicast group to which a source intends to send data.</p>
<p id="rfc.section.4.3.5.p.4">The ifs argument points to the list of interface indexes for which the source registration failed. A NULL pointer is returned, if the list is empty. This parameter is optional.</p>
<p id="rfc.section.4.3.5.p.5">If source registration succeeded for all interfaces associated with the socket, the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.3.6">
<a href="#rfc.section.4.3.6">4.3.6.</a> Source Deregister</h1>
<p id="rfc.section.4.3.6.p.1">The srcDeregister indicates that a source does no longer intend to send data to the multicast group. This call may remain without effect in some multicast technologies.</p>
<div id="#rfc.figure.12"></div>
<p></p>
<pre>    srcDeregister(in Socket s, in Uri group_name,
                  in Interface &lt;ifs&gt;, out Int error);</pre>
<p></p>
<p id="rfc.section.4.3.6.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.3.6.p.3">The group_name argument identifies the multicast group to which a source has stopped to send multicast data.</p>
<p id="rfc.section.4.3.6.p.4">The ifs argument points to the list of interfaces for which the source deregistration failed. A NULL pointer is returned, if the list is empty.</p>
<p id="rfc.section.4.3.6.p.5">If source deregistration succeeded for all interfaces associated with the socket, the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Send and Receive Calls</h1>
<p></p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> Send</h1>
<p id="rfc.section.4.4.1.p.1">The send call passes multicast data for a Multicast Name from the application to the multicast socket.<em></em></p>
<div id="#rfc.figure.13"></div>
<p></p>
<pre>    send(in Socket s, in Uri group_name, 
         in Size msg_len, in Msg msg_buf,
         out Int error);</pre>
<p></p>
<p id="rfc.section.4.4.1.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.4.1.p.3">The group_name argument identifies the group to which data will be sent.</p>
<p id="rfc.section.4.4.1.p.4">The msg_len argument holds the length of the message to be sent.</p>
<p id="rfc.section.4.4.1.p.5">The msg_buf argument passes the multicast data to the multicast socket.</p>
<p id="rfc.section.4.4.1.p.6">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> Receive</h1>
<div id="#rfc.figure.14"></div>
<p id="rfc.section.4.4.2.p.1">The receive call passes multicast data and the corresponding Group Name to the application.<em></em></p>

<p></p>
<pre>    receive(in Socket s, out Uri group_name, 
            out Size msg_len, out Msg msg_buf,
            out Int error);</pre>
<p></p>
<p id="rfc.section.4.4.2.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.4.2.p.3">The group_name argument identifies the multicast group for which data was received.</p>
<p id="rfc.section.4.4.2.p.4">The msg_len argument holds the length of the received message.</p>
<p id="rfc.section.4.4.2.p.5">The msg_buf argument points to the payload of the received multicast data.</p>
<p id="rfc.section.4.4.2.p.6">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> Socket Options</h1>
<p id="rfc.section.4.5.p.1">The following calls configure an existing multicast socket.</p>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> Get Interfaces</h1>
<p id="rfc.section.4.5.1.p.1">The getInterface call returns an array of all available multicast communication interfaces associated with the multicast socket.</p>
<div id="#rfc.figure.15"></div>
<p></p>
<pre>    getInterfaces(in Socket s, 
                  out Interface &lt;ifs&gt;, out Int error);</pre>
<p></p>
<p id="rfc.section.4.5.1.p.2">The s argument identifies the multicast socket.</p>
<p id="rfc.section.4.5.1.p.3">The ifs argument points to an array of interface index identifiers.</p>
<p id="rfc.section.4.5.1.p.4">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> Add Interface</h1>
<p id="rfc.section.4.5.2.p.1">The addInterface call adds a distribution channel to the socket.  This may be an overlay or underlay interface, e.g., IPv6 or DHT.  Multiple interfaces of the same technology may be associated with the socket.</p>
<div id="#rfc.figure.16"></div>
<p></p>
<pre>    addInterface(in Socket s, in Interface if,
                 out Int error);</pre>
<p></p>
<p id="rfc.section.4.5.2.p.2">The s and if arguments identify a multicast socket and interface, respectively.</p>
<p id="rfc.section.4.5.2.p.3">On success the value 0 is returned, otherwise -1.</p>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> Delete Interface</h1>
<p id="rfc.section.4.5.3.p.1">The delInterface call removes the interface if from the multicast socket.</p>
<div id="#rfc.figure.17"></div>
<p></p>
<pre>    delInterface(in Socket s, Interface if,
                 out Int error);</pre>
<p></p>
<p id="rfc.section.4.5.3.p.2">The s and if arguments identify a multicast socket and interface, respectively.</p>
<p id="rfc.section.4.5.3.p.3">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> Set TTL</h1>
<p id="rfc.section.4.5.4.p.1">The setTTL call configures the maximum hop count for the socket a multicast message is allowed to traverse.</p>
<div id="#rfc.figure.18"></div>
<p></p>
<pre>    setTTL(in Socket s, in Int h,
           in Interface &lt;ifs&gt;,
           out Int error);</pre>
<p></p>
<p id="rfc.section.4.5.4.p.2">The s and h arguments identify a multicast socket and the maximum hop count, respectively.</p>
<p id="rfc.section.4.5.4.p.3">The ifs argument points to an array of interface index identifiers. This parameter is optional.</p>
<p id="rfc.section.4.5.4.p.4">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.5.5">
<a href="#rfc.section.4.5.5">4.5.5.</a> Get TTL</h1>
<p id="rfc.section.4.5.5.p.1">The getTTL call returns the maximum hop count a multicast message is allowed to traverse for the socket.</p>
<div id="#rfc.figure.19"></div>
<p></p>
<pre>    getTTL(in Socket s, 
           out Int h, out Int error);</pre>
<p></p>
<p id="rfc.section.4.5.5.p.2">The s argument identifies a multicast socket.</p>
<p id="rfc.section.4.5.5.p.3">The h argument holds the maximum number of hops associated with socket s.</p>
<p id="rfc.section.4.5.5.p.4">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> Service Calls</h1>
<p></p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> Group Set</h1>
<p id="rfc.section.4.6.1.p.1">The groupSet call returns all multicast groups registered at a given interface. This information can be provided by group management states or routing protocols. The return values distinguish between sender and listener states.</p>
<div id="#rfc.figure.20"></div>
<p></p>
<pre>    struct GroupSet {
      uri group_name; /* registered multicast group */
      int type;       /* 0 = listener state, 1 = sender state, 
                         2 = sender &amp; listener state */
    }

    groupSet(in Interface if, out Int num_groups,
             out GroupSet &lt;groupSet&gt;, out Int error);
</pre>
<p></p>
<p id="rfc.section.4.6.1.p.2">The if argument identifies the interface for which states are maintained.</p>
<p id="rfc.section.4.6.1.p.3">The num_groups argument holds the number of groups in the groupSet array.</p>
<p id="rfc.section.4.6.1.p.4">The groupSet argument points to a list of group states.</p>
<p id="rfc.section.4.6.1.p.5">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> Neighbor Set</h1>
<p id="rfc.section.4.6.2.p.1">The neighborSet function returns the set of neighboring nodes for a given interface as seen by the multicast routing protocol.</p>
<div id="#rfc.figure.21"></div>
<p></p>
<pre>    neighborSet(in Interface if, out Int num_neighbors,
                out Uri &lt;neighbor_address&gt;, out Int error);</pre>
<p></p>
<p id="rfc.section.4.6.2.p.2">The if argument identifies the interface for which neighbors are inquired.</p>
<p id="rfc.section.4.6.2.p.3">The num_neighbors argument holds the number of addresses in the neighbor_address array.</p>
<p id="rfc.section.4.6.2.p.4">The neighbor_address argument points to a list of neighboring nodes on a successful return.</p>
<p id="rfc.section.4.6.2.p.5">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> Children Set</h1>
<p id="rfc.section.4.6.3.p.1">The childrenSet function returns the set of child nodes that receive multicast data from a specified interface for a given group.  For a common multicast router, this call retrieves the multicast forwarding information base per interface.</p>
<div id="#rfc.figure.22"></div>
<p></p>
<pre>    childrenSet(in Interface if, in Uri group_name, 
                out Int num_children, out Uri &lt;child_address&gt;,
                out Int error);</pre>
<p></p>
<p id="rfc.section.4.6.3.p.2">The if argument identifies the interface for which children are inquired.</p>
<p id="rfc.section.4.6.3.p.3">The group_name argument defines the multicast group for which distribution is considered.</p>
<p id="rfc.section.4.6.3.p.4">The num_children argument holds the number of addresses in the child_address array.</p>
<p id="rfc.section.4.6.3.p.5">The child_address argument points to a list of neighboring nodes on a successful return.</p>
<p id="rfc.section.4.6.3.p.6">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.6.4">
<a href="#rfc.section.4.6.4">4.6.4.</a> Parent Set</h1>
<p id="rfc.section.4.6.4.p.1">The parentSet function returns the set of neighbors from which the current node receives multicast data at a given interface for the specified group.</p>
<div id="#rfc.figure.23"></div>
<p></p>
<pre>    parentSet(in Interface if, in Uri group_name, 
              out Int num_parents, out Uri parent_address,
              out Int error);</pre>
<p></p>
<p id="rfc.section.4.6.4.p.2">The if argument identifies the interface for which parents are inquired.</p>
<p id="rfc.section.4.6.4.p.3">The group_name argument defines the multicast group for which distribution is considered.</p>
<p id="rfc.section.4.6.4.p.4">The num_parents argument holds the number of addresses in the parent_address array.</p>
<p id="rfc.section.4.6.4.p.5">The parent_address argument points to a list of neighboring nodes on a successful return.</p>
<p id="rfc.section.4.6.4.p.6">On success the out parameter error is 0, otherwise -1.</p>
<h1 id="rfc.section.4.6.5">
<a href="#rfc.section.4.6.5">4.6.5.</a> Designated Host</h1>
<p id="rfc.section.4.6.5.p.1">The designatedHost function inquires whether the host has the role of a designated forwarder resp. querier, or not. Such an information is provided by almost all multicast protocols to prevent packet duplication, if multiple multicast instances serve on the same subnet.</p>
<div id="#rfc.figure.24"></div>
<p></p>
<pre>    designatedHost(in Interface if, in Uri group_name
                   out Int return);</pre>
<p></p>
<p id="rfc.section.4.6.5.p.2">The if argument identifies the interface for which designated forwarding is inquired.</p>
<p id="rfc.section.4.6.5.p.3">The group_name argument specifies the group for which the host may attain the role of designated forwarder.</p>
<p id="rfc.section.4.6.5.p.4">The function returns 1 if the host is a designated forwarder or querier, otherwise 0. The return value -1 indicates an error.</p>
<h1 id="rfc.section.4.6.6">
<a href="#rfc.section.4.6.6">4.6.6.</a> Enable Membership Events</h1>
<p id="rfc.section.4.6.6.p.1">The enableEvents function registers an application at the middleware to inform the application about a group change. This is the result of receiver new subscriptions or leaves as well as the observation of source changes. The group service may call other service calls to get additional information.</p>
<div id="#rfc.figure.25"></div>
<p></p>
<pre>    enableEvents();</pre>
<p></p>
<p id="rfc.section.4.6.6.p.2">Calling this function, the middleware starts to pass membership events to the application. Each event includes an event type identifier and a Group Name (cf., <a href="#sec:membership-events">Section 4.2.3</a>).</p>
<h1 id="rfc.section.4.6.7">
<a href="#rfc.section.4.6.7">4.6.7.</a> Disable Membership Events</h1>
<p id="rfc.section.4.6.7.p.1">The disableEvents function deactivates the information about group state changes.</p>
<div id="#rfc.figure.26"></div>
<p></p>
<pre>    disableEvents();</pre>
<p></p>
<p id="rfc.section.4.6.7.p.2">On success the middleware will not pass membership events to the application.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Functional Details</h1>
<p id="rfc.section.5.p.1">In this section, we describe specific functions of the API and the associated system middleware in detail.</p>
<p></p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec:namespace" id="sec:namespace">Namespaces</a>
</h1>
<p id="rfc.section.5.1.p.1">Namespace identifiers in URIs are placed in the scheme element and characterize syntax and semantic of the group identifier. They enable the use of convenience functions and high-level data types while processing URIs. When used in names, they may facilitate a default mapping and a recovery of names from addresses. They characterize its type, when used in addresses.</p>
<p id="rfc.section.5.1.p.2">Compliant to the URI concept, namespace-schemes can be added.  Examples of schemes and functions currently foreseen include</p>
<p></p>

<dl>
<dt>IP</dt>
<dd style="margin-left: 8">This namespace is comprised of regular IP node naming, i.e., DNS names and addresses taken from any version of the Internet Protocol. A processor dealing with the IP namespace is required to determine the syntax (DNS name, IP address version) of the group expression.</dd>
<dt>OLM</dt>
<dd style="margin-left: 8">This namespace covers address strings immediately valid in an overlay network. A processor handling those strings need not be aware of the address generation mechanism, but may pass these values directly to a corresponding overlay.</dd>
<dt>SIP</dt>
<dd style="margin-left: 8">The SIP namespace is an example of an application-layer scheme that bears inherent group functions (conferencing). SIP conference URIs may be directly exchanged and interpreted at the application, and mapped to group addresses on the system level to generate a corresponding multicast group.</dd>
<dt>Opaque</dt>
<dd style="margin-left: 8">This namespace transparently carries strings without further syntactical information, meanings or associated resolution mechanism.</dd>
</dl>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This document makes no request of IANA.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.7.p.1">This draft does neither introduce additional messages nor novel protocol operations.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.8.p.1">We would like to thank the HAMcast-team, Dominik Charousset, Gabriel Hege, Fabian Holler, Alexander Knauf, Sebastian Meiling, and Sebastian Woelke, at the HAW Hamburg for many fruitful discussions and for their continuous critical feedback while implementing API and a hybrid multicast middleware.</p>
<p id="rfc.section.8.p.2">This work is partially supported by the German Federal Ministry of Education and Research within the HAMcast project, which is part of G-Lab.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3493">[RFC3493]</b></td>
<td class="top">
<a>Gilligan, R.</a>, <a>Thomson, S.</a>, <a>Bound, J.</a>, <a>McCann, J.</a> and <a>W. Stevens</a>, "<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>", RFC 3493, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3678">[RFC3678]</b></td>
<td class="top">
<a>Thaler, D.</a>, <a>Fenner, B.</a> and <a>B. Quinn</a>, "<a href="http://tools.ietf.org/html/rfc3678">Socket Interface Extensions for Multicast Source Filters</a>", RFC 3678, January 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1075">[RFC1075]</b></td>
<td class="top">
<a title="Bolt Baranek and Newman (BBN)/STC">Waitzman, D.</a>, <a title="Bolt Baranek and Newman (BBN)/STC">Partridge, C.</a> and <a title="Stanford University">S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc1075">Distance Vector Multicast Routing Protocol</a>", RFC 1075, November 1988.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5015">[RFC5015]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Kouvelas, I.</a>, <a>Speakman, T.</a> and <a>L. Vicisano</a>, "<a href="http://tools.ietf.org/html/rfc5015">Bidirectional Protocol Independent Multicast (BIDIR-PIM)</a>", RFC 5015, October 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3810">[RFC3810]</b></td>
<td class="top">
<a>Vida, R.</a> and <a>L. Costa</a>, "<a href="http://tools.ietf.org/html/rfc3810">Multicast Listener Discovery Version 2 (MLDv2) for IPv6</a>", RFC 3810, June 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4604">[RFC4604]</b></td>
<td class="top">
<a>Holbrook, H.</a>, <a>Cain, B.</a> and <a>B. Haberman</a>, "<a href="http://tools.ietf.org/html/rfc4604">Using Internet Group Management Protocol Version 3 (IGMPv3) and Multicast Listener Discovery Protocol Version 2 (MLDv2) for Source-Specific Multicast</a>", RFC 4604, August 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2710">[RFC2710]</b></td>
<td class="top">
<a href="mailto:deering@cisco.com" title="Cisco Systems, Inc.">Deering, S.</a>, <a href="mailto:fenner@research.att.com" title="AT &amp; T Research">Fenner, W.</a> and <a href="mailto:haberman@raleigh.ibm.com" title="IBM Corporation">B. Haberman</a>, "<a href="http://tools.ietf.org/html/rfc2710">Multicast Listener Discovery (MLD) for IPv6</a>", RFC 2710, October 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4601">[RFC4601]</b></td>
<td class="top">
<a>Fenner, B.</a>, <a>Handley, M.</a>, <a>Holbrook, H.</a> and <a>I. Kouvelas</a>, "<a href="http://tools.ietf.org/html/rfc4601">Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)</a>", RFC 4601, August 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3376">[RFC3376]</b></td>
<td class="top">
<a>Cain, B.</a>, <a>Deering, S.</a>, <a>Kouvelas, I.</a>, <a>Fenner, B.</a> and <a>A. Thyagarajan</a>, "<a href="http://tools.ietf.org/html/rfc3376">Internet Group Management Protocol, Version 3</a>", RFC 3376, October 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4395">[RFC4395]</b></td>
<td class="top">
<a>Hansen, T.</a>, <a>Hardie, T.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc4395">Guidelines and Registration Procedures for New URI Schemes</a>", BCP 35, RFC 4395, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mboned-auto-multicast">[I-D.ietf-mboned-auto-multicast]</b></td>
<td class="top">
<a>Thaler, D</a>, <a>Talwar, M</a>, <a>Aggarwal, A</a>, <a>Vicisano, L</a>, <a>Pusateri, T</a> and <a>T Morin</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mboned-auto-multicast-11">Automatic IP Multicast Tunneling</a>", Internet-Draft draft-ietf-mboned-auto-multicast-11, July 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#sec:c-signatures" id="sec:c-signatures">C Signatures</a>
</h1>
<p id="rfc.section.Appendix A.p.1">This section describes the C signatures of the common multicast API, which is defined in <a href="#sec:capi">Section 4</a>.</p>
<div id="#rfc.figure.27"></div>
<p></p>
<pre>    int createMSocket(uint32_t *if);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.28"></div>
<p></p>
<pre>    int deleteMSocket(int s);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.29"></div>
<p></p>
<pre>    int join(int s, const uri group_name);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.30"></div>
<p></p>
<pre>    int leave(int s, const uri group_name);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.31"></div>
<p></p>
<pre>    int srcRegister(int s, const uri group_name, 
                    uint_t num_ifs, uint_t *ifs);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.32"></div>
<p></p>
<pre>    int srcDeregister(int s, const uri group_name,
                      uint_t num_ifs, uint_t *ifs);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.33"></div>
<p></p>
<pre>    int send(int s, const uri group_name, 
             size_t msg_len, const void *buf);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.34"></div>
<p></p>
<pre>    int receive(int s, const uri group_name, 
                size_t msg_len, msg *msg_buf);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.35"></div>
<p></p>
<pre>    int getInterfaces(int s, uint_t num_ifs, uint_t *ifs);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.36"></div>
<p></p>
<pre>    int addInterface(int s, uint32_t if);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.37"></div>
<p></p>
<pre>    int delInterface(int s, uint32_t if);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.38"></div>
<p></p>
<pre>    int setTTL(int s, int h, uint_t num_ifs, uint_t *ifs);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.39"></div>
<p></p>
<pre>    int getTTL(int s, int h);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.40"></div>
<p></p>
<pre>    int groupSet(uint32_t if, uint_t *num_groups,
                 struct groupSet *groupSet);

    struct groupSet {
      uri group_name; /* registered multicast group */
      int type;       /* 0 = listener state, 1 = sender state, 
                         2 = sender &amp; listener state */</pre>
<p></p>
<p></p>
<div id="#rfc.figure.41"></div>
<p></p>
<pre>    int neighborSet(uint32_t if, uint_t *num_neighbors,
                    const uri *neighbor_address);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.42"></div>
<p></p>
<pre>    int childrenSet(uint32_t if, const uri group_name, 
                   uint_t *num_children, const uri *child_address);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.43"></div>
<p></p>
<pre>    int parentSet(uint32_t if, const uri group_name, uint_t *num_parents,
                    const uri *parent_address);</pre>
<p></p>
<p></p>
<div id="#rfc.figure.44"></div>
<p></p>
<pre>    int designatedHost(uint32_t if, const uri *group_name);</pre>
<p></p>
<p></p>
<h1 id="rfc.appendix.Appendix B">
<a href="#rfc.appendix.Appendix%20B">Appendix B.</a> Practical Example of the API</h1>
<p></p>
<div id="#rfc.figure.45"></div>
<pre>  -- Application above middleware:

  //Initialize multicast socket; 
  //the middleware selects all available interfaces
  MulticastSocket m = new MulticastSocket();
  
  m.join(URI("ip://224.1.2.3:5000"));
  m.join(URI("ip://[FF02:0:0:0:0:0:0:3]:6000"));
  m.join(URI("sip://news@cnn.com"));

  -- Middleware:

  join(URI mcAddress) {
    //Select interfaces in use 
    for all this.interfaces {
      switch (interface.type) {
        case "ipv6":
          //... map logical ID to routing address
          Inet6Address rtAddressIPv6 = new Inet6Address();
          mapNametoAddress(mcAddress,rtAddressIPv6);
          interface.join(rtAddressIPv6);
        case "ipv4":
          //... map logical ID to routing address
          Inet4Address rtAddressIPv4 = new Inet4Address();
          mapNametoAddress(mcAddress,rtAddressIPv4);
          interface.join(rtAddressIPv4);
        case "sip-session":
          //... map logical ID to routing address
          SIPAddress rtAddressSIP = new SIPAddress();
          mapNametoAddress(mcAddress,rtAddressSIP);
          interface.join(rtAddressSIP);          
        case "dht":
          //... map logical ID to routing address
          DHTAddress rtAddressDHT = new DHTAddress();
          mapNametoAddress(mcAddress,rtAddressDHT);
          interface.join(rtAddressDHT);
         //...
      }
    }
  }

</pre>
<h1 id="rfc.appendix.Appendix C">
<a href="#rfc.appendix.Appendix%20C">Appendix C.</a> Deployment Use Cases for Hybrid Multicast</h1>
<p id="rfc.section.Appendix C.p.1">This section describes the application of the defined API to implement an IMG.</p>
<h1 id="rfc.appendix.Appendix C.1">
<a href="#rfc.appendix.Appendix%20C.1">Appendix C.1.</a> DVMRP</h1>
<p id="rfc.section.Appendix C.1.p.1">The following procedure describes a transparent mapping of a DVMRP-based any source multicast service to another many-to-many multicast technology.</p>
<p id="rfc.section.Appendix C.1.p.2">An arbitrary DVMRP <a href="#RFC1075">[RFC1075]</a> router will not be informed about new receivers, but will learn about new sources immediately. The concept of DVMRP does not provide any central multicast instance. Thus, the IMG can be placed anywhere inside the multicast region, but requires a DVMRP neighbor connectivity. The group communication stack used by the IMG is enhanced by a DVMRP implementation. New sources in the underlay will be advertised based on the DVMRP flooding mechanism and received by the IMG. Based on this the event "new_source_event" is created and passed to the application.  The relay agent initiates a corresponding join in the native network and forwards the received source data towards the overlay routing protocol. Depending on the group states, the data will be distributed to overlay peers.</p>
<p id="rfc.section.Appendix C.1.p.3">DVMRP establishes source specific multicast trees. Therefore, a graft message is only visible for DVMRP routers on the path from the new receiver subnet to the source, but in general not for an IMG. To overcome this problem, data of multicast senders will be flooded in the overlay as well as in the underlay. Hence, an IMG has to initiate an all-group join to the overlay using the namespace extension of the API. Each IMG is initially required to forward the received overlay data to the underlay, independent of native multicast receivers.  Subsequent prunes may limit unwanted data distribution thereafter.</p>
<h1 id="rfc.appendix.Appendix C.2">
<a href="#rfc.appendix.Appendix%20C.2">Appendix C.2.</a> PIM-SM</h1>
<p id="rfc.section.Appendix C.2.p.1">The following procedure describes a transparent mapping of a PIM-SM-based any source multicast service to another many-to-many multicast technology.</p>
<p id="rfc.section.Appendix C.2.p.2">The Protocol Independent Multicast Sparse Mode (PIM-SM) <a href="#RFC4601">[RFC4601]</a> establishes rendezvous points (RP). These entities receive listener and source subscriptions of a domain. To be continuously updated, an IMG has to be co-located with a RP. Whenever PIM register messages are received, the IMG must signal internally a new multicast source using the event "new_source_event". Subsequently, the IMG joins the group and a shared tree between the RP and the sources will be established, which may change to a source specific tree after a sufficient number of data has been delivered. Source traffic will be forwarded to the RP based on the IMG join, even if there are no further receivers in the native multicast domain.  Designated routers of a PIM-domain send receiver subscriptions towards the PIM-SM RP. The reception of such messages initiates the event "join_event" at the IMG, which initiates a join towards the overlay routing protocol. Overlay multicast data arriving at the IMG will then transparently be forwarded in the underlay network and distributed through the RP instance.</p>
<h1 id="rfc.appendix.Appendix C.3">
<a href="#rfc.appendix.Appendix%20C.3">Appendix C.3.</a> PIM-SSM</h1>
<p id="rfc.section.Appendix C.3.p.1">The following procedure describes a transparent mapping of a PIM-SSM-based source specific multicast service to another one-to-many multicast technology.</p>
<p id="rfc.section.Appendix C.3.p.2">PIM Source Specific Multicast (PIM-SSM) is defined as part of PIM-SM and admits source specific joins (S,G) according to the source specific host group model <a href="#RFC4604">[RFC4604]</a>. A multicast distribution tree can be established without the assistance of a rendezvous point.</p>
<p id="rfc.section.Appendix C.3.p.3">Sources are not advertised within a PIM-SSM domain. Consequently, an IMG cannot anticipate the local join inside a sender domain and deliver a priori the multicast data to the overlay instance. If an IMG of a receiver domain initiates a group subscription via the overlay routing protocol, relaying multicast data fails, as data are not available at the overlay instance. The IMG instance of the receiver domain, thus, has to locate the IMG instance of the source domain to trigger the corresponding join. In the sense of PIM-SSM, the signaling should not be flooded in underlay and overlay.</p>
<p id="rfc.section.Appendix C.3.p.4">One solution could be to intercept the subscription at both, source and receiver sites: To monitor multicast receiver subscriptions ("join_event" or "leave_event") in the underlay, the IMG is placed on path towards the source, e.g., at a domain border router. This router intercepts join messages and extracts the unicast source address S, initializing an IMG specific join to S via regular unicast. Multicast data arriving at the IMG of the sender domain can be distributed via the overlay. Discovering the IMG of a multicast sender domain may be implemented analogously to AMT <a href="#I-D.ietf-mboned-auto-multicast">[I-D.ietf-mboned-auto-multicast]</a> by anycast.  Consequently, the source address S of the group (S,G) should be built based on an anycast prefix. The corresponding IMG anycast address for a source domain is then derived from the prefix of S.</p>
<h1 id="rfc.appendix.Appendix C.4">
<a href="#rfc.appendix.Appendix%20C.4">Appendix C.4.</a> BIDIR-PIM</h1>
<p id="rfc.section.Appendix C.4.p.1">The following procedure describes a transparent mapping of a BIDIR-PIM-based any source multicast service to another many-to-many multicast technology.</p>
<p id="rfc.section.Appendix C.4.p.2">Bidirectional PIM <a href="#RFC5015">[RFC5015]</a> is a variant of PIM-SM. In contrast to PIM-SM, the protocol pre-establishes bidirectional shared trees per group, connecting multicast sources and receivers. The rendezvous points are virtualized in BIDIR-PIM as an address to identify on-tree directions (up and down). However, routers with the best link towards the (virtualized) rendezvous point address are selected as designated forwarders for a link-local domain and represent the actual distribution tree. The IMG is to be placed at the RP-link, where the rendezvous point address is located. As source data in either cases will be transmitted to the rendezvous point address, the BIDIR-PIM instance of the IMG receives the data and can internally signal new senders towards the stack via the "new_source_event". The first receiver subscription for a new group within a BIDIR-PIM domain needs to be transmitted to the RP to establish the first branching point. Using the "join_event", an IMG will thereby be informed about group requests from its domain, which are then delegated to the overlay.</p>
<h1 id="rfc.appendix.Appendix D">
<a href="#rfc.appendix.Appendix%20D">Appendix D.</a> Change Log</h1>
<p id="rfc.section.Appendix D.p.1">The following changes have been made from draft-irtf-samrg-common-api-01</p>
<p></p>

<ol>
<li>Pseudo syntax for lists objects changed</li>
<li>Editorial improvements</li>
</ol>

<p>The following changes have been made from draft-irtf-samrg-common-api-00</p>
<p></p>

<ol>
<li>Incorrect pseudo code syntax fixed</li>
<li>Minor editorial improvements</li>
</ol>

<p>The following changes have been made from draft-waehlisch-sam-common-api-06</p>
<p></p>

<ol><li>no changes; draft adopted as WG document (previous draft-waehlisch-sam-common-api-06, now draft-irtf-samrg-common-api-00)</li></ol>

<p>The following changes have been made from draft-waehlisch-sam-common-api-05</p>
<p></p>

<ol>
<li>Description of the Common API using pseudo syntax added</li>
<li>C signatures of the Comon API moved to appendix</li>
<li>updateSender() and updateListener() calls replaced by events</li>
<li>Function destroyMSocket renamed as deleteMSocket.</li>
</ol>

<p>The following changes have been made from draft-waehlisch-sam-common-api-04</p>
<p></p>

<ol><li>updateSender() added.</li></ol>

<p>The following changes have been made from draft-waehlisch-sam-common-api-03</p>

<ol>
<li>Use cases added for illustration.</li>
<li>Service calls added for inquiring on the multicast distribution system.</li>
<li>Namespace examples added.</li>
<li>Clarifications and editorial improvements.</li>
</ol>

<p>The following changes have been made from draft-waehlisch-sam-common-api-02</p>

<ol>
<li>Rename init() in createMSocket().</li>
<li>Added calls srcRegister()/srcDeregister().</li>
<li>Rephrased API calls in C-style.</li>
<li>Cleanup code in "Practical Example of the API".</li>
<li>Partial reorganization of the document.</li>
<li>Many editorial improvements.</li>
</ol>
<p id="rfc.section.Appendix D.p.7">The following changes have been made from draft-waehlisch-sam-common-api-01</p>

<ol>
<li>Document restructured to clarify the realm of document overview and specific contributions s.a. naming and addressing.</li>
<li>A clear separation of naming and addressing was drawn. Multicast URIs have been introduced.</li>
<li>Clarified and adapted the API calls.</li>
<li>Introduced Socket Option calls.</li>
<li>Deployment use cases moved to an appendix.</li>
<li>Simple programming example added.</li>
<li>Many editorial improvements.</li>
</ol>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Matthias Waehlisch</span> 
	  <span class="n hidden">
		<span class="family-name">Waehlisch</span>
	  </span>
	</span>
	<span class="org vcardline">link-lab & FU Berlin</span>
	<span class="adr">
	  <span>Hoenower Str. 35</span>

	  <span class="vcardline">
		<span class="locality">Berlin</span>,  
		<span class="region"></span>
		<span class="code">10318</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mw@link-lab.net">mw@link-lab.net</a></span>

<span class="vcardline">URI: <a href="http://www.inf.fu-berlin.de/~waehl">http://www.inf.fu-berlin.de/~waehl</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Thomas C. Schmidt</span> 
	  <span class="n hidden">
		<span class="family-name">Schmidt</span>
	  </span>
	</span>
	<span class="org vcardline">HAW Hamburg</span>
	<span class="adr">
	  <span>Berliner Tor 7</span>

	  <span class="vcardline">
		<span class="locality">Hamburg</span>,  
		<span class="region"></span>
		<span class="code">20099</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:schmidt@informatik.haw-hamburg.de">schmidt@informatik.haw-hamburg.de</a></span>

<span class="vcardline">URI: <a href="http://inet.cpt.haw-hamburg.de/members/schmidt">http://inet.cpt.haw-hamburg.de/members/schmidt</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stig Venaas</span> 
	  <span class="n hidden">
		<span class="family-name">Venaas</span>
	  </span>
	</span>
	<span class="org vcardline">cisco Systems</span>
	<span class="adr">
	  <span>Tasman Drive</span>

	  <span class="vcardline">
		<span class="locality">San Jose</span>,  
		<span class="region">CA</span> 
		<span class="code">95134</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:stig@cisco.com">stig@cisco.com</a></span>

  </address>
</div>

</body>
</html>