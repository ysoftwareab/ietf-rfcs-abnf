<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>LURK Extension version 1 for (D)TLS 1.3 Authentication</title>
<meta content="Daniel Migault" name="author">
<meta content="
       This document describes the LURK Extension 'tls13' which enables
interactions between a LURK client and a LURK server in a context of
authentication with (D)TLS 1.3. 
    " name="description">
<meta content="xml2rfc 3.9.1" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-mglt-lurk-tls13-05" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.9.1
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.1
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.6.3
    pycountry 20.7.3
    pyflakes 2.3.1
    PyYAML 5.4.1
    requests 2.26.0
    setuptools 57.4.0
    six 1.16.0
-->
<link href="/tmp/draft-mglt-lurk-tls13-uxepb12f.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: avoid-page;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">LURK/TLS 1.3</td>
<td class="right">July 2021</td>
</tr></thead>
<tfoot><tr>
<td class="left">Migault</td>
<td class="center">Expires 27 January 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">LURK</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-mglt-lurk-tls13-05</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2021-07-26" class="published">26 July 2021</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-01-27">27 January 2022</time></dd>
<dt class="label-authors">Author:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">D. Migault</div>
<div class="org">Ericsson</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">LURK Extension version 1 for (D)TLS 1.3 Authentication</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes the LURK Extension 'tls13' which enables
interactions between a LURK client and a LURK server in a context of
authentication with (D)TLS 1.3.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 27 January 2022.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="ulEmpty toc compact ulBare">
<li class="ulEmpty toc compact ulBare" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-todo" class="xref">TODO</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="xref">2</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1" class="keepWithNext"><a href="#section-3" class="xref">3</a>.  <a href="#name-terminology" class="xref">Terminology</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-lurk-header" class="xref">LURK Header</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-structures" class="xref">Structures</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-secret_request" class="xref">secret_request</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-handshake" class="xref">handshake</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-session_id" class="xref">session_id</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.  <a href="#name-freshness" class="xref">freshness</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="xref">5.5</a>.  <a href="#name-ephemeral" class="xref">ephemeral</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.5.2.1">
                    <p id="section-toc.1-1.5.2.5.2.1.1"><a href="#section-5.5.1" class="xref">5.5.1</a>.  <a href="#name-shared_secret_provided" class="xref">shared_secret_provided:</a></p>
</li>
                  <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.5.2.2">
                    <p id="section-toc.1-1.5.2.5.2.2.1"><a href="#section-5.5.2" class="xref">5.5.2</a>.  <a href="#name-secret_generated" class="xref">secret_generated:</a></p>
</li>
                  <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.5.2.3">
                    <p id="section-toc.1-1.5.2.5.2.3.1"><a href="#section-5.5.3" class="xref">5.5.3</a>.  <a href="#name-no_secret" class="xref">no_secret</a></p>
</li>
                </ul>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.6">
                <p id="section-toc.1-1.5.2.6.1"><a href="#section-5.6" class="xref">5.6</a>.  <a href="#name-selected_identity" class="xref">selected_identity</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.7">
                <p id="section-toc.1-1.5.2.7.1"><a href="#section-5.7" class="xref">5.7</a>.  <a href="#name-certificate" class="xref">certificate</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.8">
                <p id="section-toc.1-1.5.2.8.1"><a href="#section-5.8" class="xref">5.8</a>.  <a href="#name-tag" class="xref">tag</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.9">
                <p id="section-toc.1-1.5.2.9.1"><a href="#section-5.9" class="xref">5.9</a>.  <a href="#name-secret" class="xref">secret</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.5.2.10">
                <p id="section-toc.1-1.5.2.10.1"><a href="#section-5.10" class="xref">5.10</a>. <a href="#name-signature" class="xref">signature</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-lurk-exchange-on-the-tls-se" class="xref">LURK exchange on the TLS server</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-s_init_cert_verify" class="xref">s_init_cert_verify</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-s_new_tickets" class="xref">s_new_tickets</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-s_init_early_secret" class="xref">s_init_early_secret</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="xref">6.4</a>.  <a href="#name-s_hand_and_app_secret" class="xref">s_hand_and_app_secret</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-lurk-exchange-on-the-tls-cl" class="xref">LURK exchange on the TLS client</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-c_init_post_hand_auth" class="xref">c_init_post_hand_auth</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-c_post_hand_auth" class="xref">c_post_hand_auth</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-c_init_cert_verify" class="xref">c_init_cert_verify</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="xref">7.4</a>.  <a href="#name-c_init_client_hello" class="xref">c_init_client_hello</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.5">
                <p id="section-toc.1-1.7.2.5.1"><a href="#section-7.5" class="xref">7.5</a>.  <a href="#name-c_client_hello" class="xref">c_client_hello</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.6">
                <p id="section-toc.1-1.7.2.6.1"><a href="#section-7.6" class="xref">7.6</a>.  <a href="#name-c_hand_and_app_secret" class="xref">c_hand_and_app_secret</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.7.2.7">
                <p id="section-toc.1-1.7.2.7.1"><a href="#section-7.7" class="xref">7.7</a>.  <a href="#name-c_register_tickets" class="xref">c_register_tickets</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-acknowledgments" class="xref">Acknowledgments</a></p>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-references" class="xref">References</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="xref">11.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="xref">11.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="xref">Appendix A</a>.  <a href="#name-annex" class="xref">Annex</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#appendix-A.1" class="xref">A.1</a>.  <a href="#name-tls-server-ecdhe-no-session" class="xref">TLS server ECDHE  (no session resumption)</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.1.2.1">
                    <p id="section-toc.1-1.12.2.1.2.1.1"><a href="#appendix-A.1.1" class="xref">A.1.1</a>.  <a href="#name-ecdhe-generated-on-the-cs" class="xref">ecdhe generated on the CS</a></p>
</li>
                  <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.1.2.2">
                    <p id="section-toc.1-1.12.2.1.2.2.1"><a href="#appendix-A.1.2" class="xref">A.1.2</a>.  <a href="#name-ecdhe-generated-by-the-tls-" class="xref">ecdhe generated by the TLS server</a></p>
</li>
                </ul>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#appendix-A.2" class="xref">A.2</a>.  <a href="#name-tls-server-ecdhe-with-sessi" class="xref">TLS server ECDHE ( with session resumption )</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.3">
                <p id="section-toc.1-1.12.2.3.1"><a href="#appendix-A.3" class="xref">A.3</a>.  <a href="#name-tls-server-psk-psk-ecdhe" class="xref">TLS server  PSK / PSK-ECDHE</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.4">
                <p id="section-toc.1-1.12.2.4.1"><a href="#appendix-A.4" class="xref">A.4</a>.  <a href="#name-tls-client-unauthenticated-" class="xref">TLS client unauthenticated ECDHE</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.5">
                <p id="section-toc.1-1.12.2.5.1"><a href="#appendix-A.5" class="xref">A.5</a>.  <a href="#name-tls-client-unauthenticated-p" class="xref">TLS client unauthenticated PSK / PSK-ECDHE</a></p>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.6">
                <p id="section-toc.1-1.12.2.6.1"><a href="#appendix-A.6" class="xref">A.6</a>.  <a href="#name-tls-client-authenticated-ec" class="xref">TLS client authenticated ECDHE</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.6.2.1">
                    <p id="section-toc.1-1.12.2.6.2.1.1"><a href="#appendix-A.6.1" class="xref">A.6.1</a>.  <a href="#name-ecdhe-or-proposed-psk-prote" class="xref">(EC)DHE or Proposed PSK protected by the CS</a></p>
</li>
                  <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.6.2.2">
                    <p id="section-toc.1-1.12.2.6.2.2.1"><a href="#appendix-A.6.2" class="xref">A.6.2</a>.  <a href="#name-ecdhe-provided-by-the-tls-c" class="xref">(EC)DHE provided by the TLS client</a></p>
</li>
                </ul>
</li>
              <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.7">
                <p id="section-toc.1-1.12.2.7.1"><a href="#appendix-A.7" class="xref">A.7</a>.  <a href="#name-tls-client-authenticated-po" class="xref">TLS client authenticated - post handshake authentication</a></p>
<ul class="toc ulEmpty ulBare compact">
<li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.7.2.1">
                    <p id="section-toc.1-1.12.2.7.2.1.1"><a href="#appendix-A.7.1" class="xref">A.7.1</a>.  <a href="#name-initial-post-handshake-auth" class="xref">Initial Post Handshake Authentication</a></p>
</li>
                  <li class="toc ulEmpty ulBare compact" id="section-toc.1-1.12.2.7.2.2">
                    <p id="section-toc.1-1.12.2.7.2.2.1"><a href="#appendix-A.7.2" class="xref">A.7.2</a>.  <a href="#name-post-handshake-authenticati" class="xref">Post Handshake Authentication</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="ulEmpty toc compact ulBare" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-B" class="xref"></a><a href="#name-authors-address" class="xref">Author's Address</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="todo">
<section id="section-1">
      <h2 id="name-todo">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-todo" class="section-name selfRef">TODO</a>
      </h2>
<ol start="1" type="1" class="normal type-1" id="section-1-1">
<li id="section-1-1.1">check the terminology is used. PSK agreed....<a href="#section-1-1.1" class="pilcrow">¶</a>
</li>
        <li id="section-1-1.2">move the handshake description to the s_exchange description description<a href="#section-1-1.2" class="pilcrow">¶</a>
</li>
        <li id="section-1-1.3">state diagram for the server.<a href="#section-1-1.3" class="pilcrow">¶</a>
</li>
      </ol>
</section>
</div>
<div id="sec-intro">
<section id="section-2">
      <h2 id="name-introduction">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-2-1">This document defines a LURK extension for TLS 1.3 <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">This document assumes the reader is familiar with TLS 1.3 the LURK architecture <span>[<a href="#I-D.mglt-lurk-lurk" class="xref">I-D.mglt-lurk-lurk</a>]</span>.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">Interactions with the Cryptographic Service (CS) can be performed by the TLS client as well as by the TLS server.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">LURK defines an interface to a CS that stores the security credentials which include the PSK involved in a PSK or PSK-ECDHE authentication or the key used for signing  in an ECDHE authentication. 
In the case of session resumption the PSK is derived from the resumption_master_secret during the key schedule <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 7.1, this secret MAY require similar protection or MAY be delegated as in the LURK extension of TLS 1.2 <span>[<a href="#I-D.mglt-lurk-tls12" class="xref">I-D.mglt-lurk-tls12</a>]</span>.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">The current document extends the scope of the LURK extension for TLS 1.2 in that it defines the CS on the TLS server as well as on the TLS client and the CS can operate in non delegating scenarios.<a href="#section-2-5" class="pilcrow">¶</a></p>
<p id="section-2-6">This document defines the role to specify whether the CS runs on a TLS client or a TLS service. The CS MUST be associated a single role.<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">From a LURK client perspective, the purpose of the LURK exchange is to request secrets, a signing operations, or ticket (NewSessionTicket) as summed up in Table <a href="#table_x_purpose" class="xref">Figure 1</a>.<a href="#section-2-7" class="pilcrow">¶</a></p>
<span id="name-operation-associated-to-lur"></span><div id="table_x_purpose">
<figure id="figure-1">
        <div class="artwork art-text alignLeft" id="section-2-8.1">
<pre>
+--------+-----------------------+------------------------+
|  Role  | LURK exchange         | secret | sign | ticket |
+--------+-----------------------+--------+------+--------+
| server | s_init_early_secret   | yes    |  -   |  -     |
| server | s_init_cert_verify    | yes    | yes  |  -     |
| server | s_hand_and_app_secret | yes    |  -   |  -     |
| server | s_new_ticket          | yes    |  -   |  yes   |
| client | c_init_post_hand_auth |  -     | yes  |  -     |
| client | c_post_hand_auth      |  -     | yes  |  -     |
| client | c_init_cert_verify    | yes    | yes  |  -     |
| client | c_init_early_secret   | yes    |  -   |  -     |
| client | c_init_hand_secret    | yes    |  -   |  -     |
| client | c_hand_and_app_secret | yes    |  -   |  -     |
| client | c_register_tickets    | yes    |  -   |  yes   |
+--------+-----------------------+--------+------+--------+
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-operation-associated-to-lur" class="selfRef">Operation associated to LURK exchange</a>
        </figcaption></figure>
</div>
<p id="section-2-9">The number of operations are limited, but the generation of secrets, tickets as well as signing heavily rely on the knowledge of the TLS handshake messages and in turn impacts these TLS handshake messages. 
As a result, these operations are highly inter-dependent.
This is one reason multiple sequential exchanges are needed between the LURK client and the CS as opposed to independent requests for secrets, signing or tickets. 
This especially requires the necessity to create a session between the LURK client and the CS. 
In addition, the LURK client and the CS need to synchronize the TLS handshake. 
First it is a necessary component for the CS to generate the secrets, signature and tickets. 
Second, elements are respectively generated by the LURK client and by the CS.<a href="#section-2-9" class="pilcrow">¶</a></p>
<p id="section-2-10">While all these messages do share a lot of structures, they also require different structure that make them unique.<a href="#section-2-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="terminology">
<section id="section-3">
      <h2 id="name-terminology">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-terminology" class="section-name selfRef">Terminology</a>
      </h2>
<p id="section-3-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">This document uses the terms defined <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> and <span>[<a href="#I-D.mglt-lurk-tls12" class="xref">I-D.mglt-lurk-tls12</a>]</span>.<a href="#section-3-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-3-3">
        <dt id="section-3-3.1">ECHDE</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.2">
  designates the ECDHE authentication defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>. 
(EC)DHE<a href="#section-3-3.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.3"></dt>
        <dd style="margin-left: 1.5em" id="section-3-3.4">designates the shared secret agreed by the key_share extension (section 4.2.8 of <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>) during a TLS handshake.<a href="#section-3-3.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.5">PSK Proposed</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.6">
  A TLS handshake between a TLS client and a TLS server is said to be "PSK proposed" when the latest ClientHello contains a psk_key_exchange_modes (section 4.2.9 of <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>) and a pre_shared_key (section 4.2.11 of <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>) extension.
A TLS client is said to "propose PSK" when its TLS handshake is PSK proposed.<a href="#section-3-3.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.7">PSK Agreed</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.8">
  A TLS handshake between a TLS client and a TLS server is said to be "PSK agreed" when the TLS handshake is PSK proposed and the ServerHello contains a psk_key_exchange_modes and a pre_shared_key extension.
A TLS client and a TLS server are said to have "agreed on PSK" when its TLS handshake is PSK agreed.<a href="#section-3-3.8" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.9">ECDHE Agreed</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.10">
  A TLS handshake between a TLS client and a TLS server is said to be "ECDHE agreed" when the ServerHello contains neither a psk_key_exchange_modes or a pre_shared_key extension. 
As currently TLS proposes only ECDHE and PSK based authentication, when PSK agreed is false, ECDHE agreed is true. 
A TLS client and a TLS server are said to have "agreed on ECDHE" when its TLS handshake is PSK agreed.<a href="#section-3-3.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.11">Key Share Proposed</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.12">
  A TLS handshake between a TLS client and a TLS server is said to be "key shared proposed" or "(EC)DHE proposed" when the latest ClientHello contains a key_share extension (section 4.2.8 of <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>).
A TLS client is said to "propose PSK" when its TLS handshake is PSK proposed.<a href="#section-3-3.12" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.13">Key Share Agreed</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.14">
  A TLS handshake between a TLS client and a TLS server is said to be "key shared agreed" or "(EC)DHE agreed" when the TLS handshake is key shared proposed and the ServerHello contains neither a key_share extension. 
A TLS client and a TLS server are said to have "agreed on (EC)DHE" when its TLS handshake is key share agreed.<a href="#section-3-3.14" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.15">Early Data Enabled</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.16">
  A TLS client is said to "support early data" or "enable early data" when its latest ClientHello contains a early_data extension (section 4.2.10 of <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>.<a href="#section-3-3.16" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-3-3.17">Post Handshake Enabled:</dt>
        <dd style="margin-left: 1.5em" id="section-3-3.18">
  A TLS client is said to "support early data" or "enable early data" when its latest ClientHello contains a post_handshake_auth extension.<a href="#section-3-3.18" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-lurk-tls-header">
<section id="section-4">
      <h2 id="name-lurk-header">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-lurk-header" class="section-name selfRef">LURK Header</a>
      </h2>
<p id="section-4-1">LURK / TLS 1.3 is a LURK Extension that introduces a new designation "tls13". 
This document assumes that Extension is defined with designation set to "tls13" and version set to 1. 
The LURK Extension extends the LURKHeader structure defined in <span>[<a href="#I-D.mglt-lurk-lurk" class="xref">I-D.mglt-lurk-lurk</a>]</span> as follows:<a href="#section-4-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4-2">
<pre>
enum {
    tls13 (2), (255)
} Designation;

enum {
   capabilities(0),
   ping(1),
   s_init_cert_verify(2),
   s_new_ticket(3),
   s_init_early_secret(4),
   s_hand_and_app_secret(5),
   c_binder_key(6),
   c_init_early_secret(7),
   c_init_hand_secret(8),
   c_hand_secret(9),
   c_app_secret(10),
   c_cert_verify(11),
   c_register_tickets(12),
   c_post_hand(13), (255)
}TLS13Type;


enum {
    // generic values reserved or aligned with the
    // LURK Protocol
    request (0), success (1), undefined_error (2),
    invalid_payload_format (3),

    invalid_psk
    invalid_freshness

    invalid_request
    invalid_key_id_type
    invalid_key_id
    invalid_signature_scheme
    invalid_certificate_type
    invalid_certificate
    invalid_certificate_verify
    invalid_secret_request
    invalid_handshake
    invalid_extension
    invalid_ephemeral
    invalid_identity
    too_many_identities

}TLS13Status

struct {
     Designation designation = "tls13";
     int8 version = 1;
} Extension;

struct {
    Extension extension;
    select( Extension ){
        case ("tls13", 1):
            TLS13Type;
    } type;
    select( Extension ){
        case ("tls13", 1):
            TLS13Status;
    } status;
    uint64 id;
    unint32 length;
} LURKHeader;
</pre><a href="#section-4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_structures">
<section id="section-5">
      <h2 id="name-structures">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-structures" class="section-name selfRef">Structures</a>
      </h2>
<p id="section-5-1">This section describes structures that are widely re-used across the multiple LURK exchanges.<a href="#section-5-1" class="pilcrow">¶</a></p>
<div id="sec_secret_request">
<section id="section-5.1">
        <h3 id="name-secret_request">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-secret_request" class="section-name selfRef">secret_request</a>
        </h3>
<p id="section-5.1-1">secret_request is a 16 bit structure described in Table <a href="#table_secret_request_struct" class="xref">Figure 2</a> that indicates the requested key or secrets by the LURK client. 
The secret_request structure is present in the request of any exchange except for a c_post_hand exchange. 
The same structure is used across all LURK exchanges, but each LURK exchange only permit a subset of values described in Table <a href="#table_secret_request_value" class="xref">Figure 3</a>.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1-2">A LURK client MUST NOT set secret_request to key or secrets that are not permitted. 
The CS MUST check the secret_request has only permitted values and has all mandatory keys or secrets set. 
If these two criteria are not met the CS MUST NOT perform the LURK exchange and SHOULD return a invalid_secret_request error. 
If the CS is not able to compute an optional key or secret, the CS MUST proceed the LURK exchange and ignore the optional key or secret.<a href="#section-5.1-2" class="pilcrow">¶</a></p>
<span id="name-secret_request-structure"></span><div id="table_secret_request_struct">
<figure id="figure-2">
          <div class="artwork art-text alignLeft" id="section-5.1-3.1">
<pre>
+------+-------------------------------------------+
| Bit  |      key or secret     (designation)      |
+------+-------------------------------------------+
| 0    | binder_key (b)                            |
| 1    | client_early_traffic_secret (e_c)         |
| 2    | early_exporter_master_secret (e_x)        |
| 3    | client_handshake_traffic_secret (h_c)     |
| 4    | server_handshake_traffic_secret (h_s)     |
| 5    | client_application_traffic_secret_0 (a_c) |
| 6    | server_application_traffic_secret_0 (a_s) |
| 7    | exporter_master_secret (x)                |
| 8    | resumption_master_secret (r)              |
| 9-15 | reserved and set to zero                  |
+------+-------------------------------------------+
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-secret_request-structure" class="selfRef">secret_request structure</a>
          </figcaption></figure>
</div>
<span id="name-secret_request-permitted-va"></span><div id="table_secret_request_value">
<figure id="figure-3">
          <div class="artwork art-text alignLeft" id="section-5.1-4.1">
<pre>
+-----------------------+-----------------------------+
| LURK exchange         | Permitted secrets           |
+-----------------------+-----------------------------+
| s_init_cert_verify    | h_c*, h_s*, a_c*, a_s*, x*  |
| s_new_ticket          | r*                          |
| s_init_early_secret   | b,e_c*, e_x*                |
| s_hand_and_app_secret | h_c, h_s, a_c*, a_s*, x*    |
| c_init_post_hand_auth | -                            |
| c_post_hand_auth      | -                            |
| c_init_cert_verify    | a_c*, a_s*, x*              |
| c_init_client_hello   | b*, e_c*, e_x*              |
| c_client_hello        | b*, e_c*, e_x*              |
| c_hand_and_app_secret | h_c, h_s, a_c*, a_s*, x*, r*|
| c_register_tickets    | -                            |
+-----------------------+-----------------------------+
* indicates the secret MAY be requested
- indicates no secrets van be requested
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-secret_request-permitted-va" class="selfRef">secret_request permitted values per LURK exchange</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="sec_handshake">
<section id="section-5.2">
        <h3 id="name-handshake">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-handshake" class="section-name selfRef">handshake</a>
        </h3>
<p id="section-5.2-1">The derivation of the secrets, signing operation and tickets requires the TLS handshake. 
The TLS handshake is described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4 and maintained by the TLS server and the TLS client to derive the same secrets. 
As the CS is in charge is deriving the secrets as well to perform some signature verification, the CS must be be aware of the TLS handshake.
The TLS handshake is not necessarily being provided by the LURK client to the CS, but instead is derived some structures provided by the LURK client as well as other structures generated or modified by the CS.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">When an unexpected handshake context is received, the CS SHOULD return an invalid_handshake error.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2-3">The value of the TLS hanshake is defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4 and remainded in
Table <a href="#table_handshake" class="xref">Figure 4</a> reminds the TLS handshake values after each LURK exchange and describes operations performed by the CS in order to build it.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<p id="section-5.2-4">On the TLS server:<a href="#section-5.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-5.1">(a) ServerHello.random value provided by the LURK client requires specific treatment as described in <a href="#sec_freshness" class="xref">Section 5.4</a> before being inserted in the TLS handshake variable.<a href="#section-5.2-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-5.2">(b) When the shared secret ( and so the private ECDHE ) is generated by the CS, the KeyShareServerHello structure cannot be provided to the CS by the LURK client in a ServerHello and is instead completed by the CS as described in <a href="#sec_ephemeral" class="xref">Section 5.5</a>.<a href="#section-5.2-5.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-5.3">(c) The TLS Certificate structure MUST not be provided by the LURK client as part of the handshake structure. 
Instead, the CS generates the Certificate message from the certificate structure described in <a href="#sec_cert" class="xref">Section 5.7</a>. The handshake MUST NOT contain a TLS Certificate message and CS SHOULD raise an invalid_handshake_error if such message is found in the TLS handshake. 
When a client Certificate is provided, the CS SHOULD raise an invalid_handshake error in the absence of a CertificateRequest message.<a href="#section-5.2-5.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-5.4">(d) The Certificate and Finished messages are not provided in a handshake structure by the LURK client but are instead generated by the CS as described in <a href="#sec_sig" class="xref">Section 5.10</a>.<a href="#section-5.2-5.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-5.5">(e) Some authentication PSK_ECHDE or ECDHE requires the agreement of a shared ECDHE secret. 
This is indicated by the presence of key_share extension in both ClientHello and ServerHello.
When these extensions are not found, the CS SHOULD raise an error. Note that in the case of PSK / PSK-ECDHE, the presence or absence of key_share extension MAY be used to distinguish between the two authentication methods.<a href="#section-5.2-5.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-5.6">(f) ECDHE authentication does not involve the agreement of a PSK. 
This is indicated by the presence of a key_share extension in both ClientHello and ServerHello. 
When these extensions are found, the CS SHOULD raise an error.<a href="#section-5.2-5.6" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-5.7">(g) PSK and PSK_ECDHE requires the agreement of a PSK, so a psk is expected in the ClientHello as well as - when present in the ServerHello. 
When this extension are not found, the CS SHOULD raise an error.<a href="#section-5.2-5.7" class="pilcrow">¶</a>
</li>
        </ul>
<span id="name-handshake-values-per-lurk-e"></span><div id="table_handshake">
<figure id="figure-4">
          <div class="artwork art-text alignLeft" id="section-5.2-6.1">
<pre>
+-----------------------+------------------------------------+---------------+
| LURK exchange         |        TLS handshake               | CS operations |
+-----------------------+------------------------------------+---------------+
| s_init_cert_verify    | ClientHello ... later of           | a,b,c,d,e,f   |
|                       | server EncryptedExtensions /       |               |
|                       | CertificateRequest                 |               |
| s_new_ticket          | earlier of client Certificate /    | c             |
|                       | client CertificateVerify /         |               |
|                       | Finished ... Finished              |               |
| s_init_early_secret   | ClientHello                        | a, g          |
| s_hand_and_app_secret | ServerHello ... later of           | b, g          |
|                       | server EncryptedExtensions /       |               |
|                       | CertificateRequest                 |               |
| c_init_post_hand_auth | ClientHello ... ServerHello        | e             |
|                       | CertificateRequest                 |               |
| c_post_hand_auth      | CertificateRequest                 |               |
| c_init_cert_verify    | ClientHello...server Finished      | e,f           |
| c_init_client_hello   | (Partial) ClientHello  or          |               |
|                       | ClientHello, HelloRetryRequest,    |               |
|                       | (Partial) ClientHello              |               |
| c_client_hello        | HelloRetryRequest, (Partial) ClientHello           |
| c_hand_and_app_secret | ServerHello, {EncryptedExtensions} |               |
|                       | ... later of { server Finished } / |               |
|                       | EndOfEarlyData                     |               |
| c_register_tickets    | -                                  |               |
+-----------------------+------------------------------------+---------------+
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-handshake-values-per-lurk-e" class="selfRef">handshake values per LURK exchange</a>
          </figcaption></figure>
</div>
<div class="artwork art-text alignLeft" id="section-5.2-7">
<pre>
Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4 (clear) clientHello...client finished CertificateRequest
</pre><a href="#section-5.2-7" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_session_id">
<section id="section-5.3">
        <h3 id="name-session_id">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-session_id" class="section-name selfRef">session_id</a>
        </h3>
<p id="section-5.3-1">The session_id is a 32 bit identifier that identifies a LURK session between a LURK client and a CS. 
Unless the exchange is sessionless, the session_id is negotiated at the initiation of the LURK session where the LURK client (resp. the CS) indicates the value to be used for inbound session_id in the following LURK exchanges.     
For other LURK exchanges, the session_id is set by the sender to the inbound value provided by the receiving party. 
When the CS receives an unexpected session_id the CS SHOULD return an invalid_session_id error.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">Table <a href="#table_session_id" class="xref">Figure 5</a> indicates the presence of the session_id.<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<span id="name-session_id-in-lurk-exchange"></span><div id="table_session_id">
<figure id="figure-5">
          <div class="artwork art-text alignLeft" id="section-5.3-3.1">
<pre>
+-----------------------+------------+
| LURK exchange         | session_id |
+-----------------------+------------+
| s_init_cert_verify    |      *     |
| s_new_ticket          |      y     |
| s_init_early_secret   |      y     |
| s_hand_and_app_secret |      y     |
| c_init_post_hand_auth |      *     |
| c_post_hand_auth      |      y     |
| c_init_cert_verify    |      *     |
| c_init_client_hello   |      y     |
| c_client_hello        |      y     |
| c_hand_and_app_secret |      y     |
| c_register_tickets    |      y     |
+-----------------------+------------+

y indicates the session_id is present
- indicates session_id may be absent
* indicates session_id may be present (depending on the tag.last_message)
</pre>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-session_id-in-lurk-exchange" class="selfRef">session_id in LURK exchanges</a>
          </figcaption></figure>
</div>
<p id="section-5.3-4">The session_id structure is defined below:
~~~
uint32 session_id
~~~<a href="#section-5.3-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_freshness">
<section id="section-5.4">
        <h3 id="name-freshness">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-freshness" class="section-name selfRef">freshness</a>
        </h3>
<p id="section-5.4-1">The freshness function implements perfect forward secrecy (PFS) and prevents replay attack. 
On the TLS server, the CS generates the ServerHello.random of the TLS handshake that is used latter to derive the secrets. 
The ServerHello.random value is generated by the CS using the freshness function and the ServerHello.random  provided by the LURK client in the handshake structure. 
The CS operates similarly on the TLS client and generates the ClientHello.random of the TLS handshake using the freshness function as well as the ClientHello.random value provided by the LURK client in the handshake structure.<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<p id="section-5.4-2">If the CS does not support the freshness, the CS SHOULD return an invalid_freshness error. 
In this document the freshness function is implemented by applying sha256.<a href="#section-5.4-2" class="pilcrow">¶</a></p>
<p id="section-5.4-3">Table {table:freshness} details the exchanges that contains the freshness structure.<a href="#section-5.4-3" class="pilcrow">¶</a></p>
<span id="name-freshness-in-lurk-exchange"></span><div id="table_freshness">
<figure id="figure-6">
          <div class="artwork art-text alignLeft" id="section-5.4-4.1">
<pre>
+-----------------------+-----------+
| LURK exchange         | freshness |
+-----------------------+-----------+
| s_init_cert_verify    |     y     |
| s_new_ticket          |     -     |
| s_init_early_secret   |     -     |
| s_hand_and_app_secret |     y     |
| c_init_post_hand_auth |     y     |
| c_post_hand_auth      |     -     |
| c_init_cert_verify    |     y     |
| c_init_client_hello   |     y     |
| c_client_hello        |     -     |
| c_hand_and_app_secret |     -     |
| c_register_tickets    |     -     |
+-----------------------+-----------+

y indicates freshness is present
- indicates freshness is absent
</pre>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-freshness-in-lurk-exchange" class="selfRef">freshness in LURK exchange</a>
          </figcaption></figure>
</div>
<p id="section-5.4-5">The extension data is defined as follows:<a href="#section-5.4-5" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.4-6">
<pre>
enum { sha256(0) ... (255) } Freshness;
</pre><a href="#section-5.4-6" class="pilcrow">¶</a>
</div>
<p id="section-5.4-7">When the CS is running on the TLS server, the  ServerHello.random is generated as follows:<a href="#section-5.4-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.4-8">
<pre>
server_random = ServerHello.random
ServerHello.random = freshness( server_random + "tls13 pfs srv" );
</pre><a href="#section-5.4-8" class="pilcrow">¶</a>
</div>
<p id="section-5.4-9">When the CS is running on the TLS client, the ClientHello.random is generated as follows:<a href="#section-5.4-9" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.4-10">
<pre>
client_random = ClientHello.random
ClientHello.random = freshness( client_random + "tls13 pfs clt" );
</pre><a href="#section-5.4-10" class="pilcrow">¶</a>
</div>
<p id="section-5.4-11">The server_random (resp client_random) MUST be deleted once it has been received by the CS.
In some cases, especially when the TLS client enables post handshake authentication and interacts with the CS via a (c_init_post_hand_auth) exchange, there might be some delay between the ClientHello is sent to the server and the Handshake context is shared with the CS.
The client_random MUST be kept until the post-handshake authentication is performed as the full handshake is provided during this exchange.<a href="#section-5.4-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_ephemeral">
<section id="section-5.5">
        <h3 id="name-ephemeral">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-ephemeral" class="section-name selfRef">ephemeral</a>
        </h3>
<p id="section-5.5-1">The Ephemeral structure carries the necessary information to generate the (EC)DHE shared secret used to derive the secrets. 
This document defines the following ephemeral methods to generate the (EC)DHE shared secret:<a href="#section-5.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.5-2.1">secret_provided: Where (EC)DHE keys and shared secret are generated by the TLS server and provided to the CS<a href="#section-5.5-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.5-2.2">secret_generated: Where the (EC)DH keys and shared secret are generated by the CS.<a href="#section-5.5-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.5-2.3">no_secret: where no (EC)DHE is involved, and PSK authentication is performed.<a href="#section-5.5-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<div id="sharedsecretprovided">
<section id="section-5.5.1">
          <h4 id="name-shared_secret_provided">
<a href="#section-5.5.1" class="section-number selfRef">5.5.1. </a><a href="#name-shared_secret_provided" class="section-name selfRef">shared_secret_provided:</a>
          </h4>
<p id="section-5.5.1-1">When ECDHE shared secret are generated by the TLS server, the LURK client provides the shared secret value to the CS.
The shared secret is transmitted via the SharedSecret structure, which is similar to the key_exchange parameter of the KeyShareEntry described in 
The CS MUST NOT return any data.<span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.2.8.<a href="#section-5.5.1-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.5.1-2">
<pre>
struct {
   NamedGroup group;
   opaque shared_secret[coordinate_length];
} SharedSecret;
</pre><a href="#section-5.5.1-2" class="pilcrow">¶</a>
</div>
<p id="section-5.5.1-3">Where coordinate_length depends on the chosen group. 
For secp256r1, secp384r1, secp521r1, x25519, x448, the coordinate_length is respectively 32 bytes, 48 bytes, 66 bytes, 32 bytes and 56 bytes. 
Upon receiving the shared_secret, the CS MUST check group is proposed in the KeyShareClientHello and agreed in the KeyShareServerHello.<a href="#section-5.5.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="secretgenerated">
<section id="section-5.5.2">
          <h4 id="name-secret_generated">
<a href="#section-5.5.2" class="section-number selfRef">5.5.2. </a><a href="#name-secret_generated" class="section-name selfRef">secret_generated:</a>
          </h4>
<p id="section-5.5.2-1">When the ECDHE public/private keys are generated by the CS, the LURK client requests the CS the associated public value. 
Note that in such cases the CS would receive an incomplete Handshake Context from the LURK client with the public part of the ECDHE missing. 
Typically the ServerHello message would present a KeyShareServerHello that consists of a KeyShareEntry with an empty key_exchange field, but the field group is present.<a href="#section-5.5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.5.2-2">The CS MUST check the group field in the KeyShareServerHello, and get the public value of the TLS client from the KeyShareClientHello. 
The CS performs the same checks as described  in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.2.8. 
The CS generates the private and public (EC)DH keys, computes the shared key and return the KeyShareEntry server_share structure defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section section 4.2.8 to the LURK client.<a href="#section-5.5.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="nosecret">
<section id="section-5.5.3">
          <h4 id="name-no_secret">
<a href="#section-5.5.3" class="section-number selfRef">5.5.3. </a><a href="#name-no_secret" class="section-name selfRef">no_secret</a>
          </h4>
<p id="section-5.5.3-1">With PSK authentication, (EC)DHE keys and shared secrets are not needed. 
The CS SHOULD check the PSK authentication has been agreed, that is pre_shared_key and psk_key_exchamge_modes extensions are noth present in the ClientHello and in the ServerHello<a href="#section-5.5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.5.3-2">When the ephemeral method or the group is not supported, the CS SHOULD return an invalid_ephemeral error.<a href="#section-5.5.3-2" class="pilcrow">¶</a></p>
<span id="name-ephemeral-field-in-lurk-exc"></span><div id="table_ephemeral">
<figure id="figure-7">
            <div class="artwork art-text alignLeft" id="section-5.5.3-3.1">
<pre>
+-----------------------+-----------+---------------------------+
|                       |           |  ephemeral_method= secret |
| LURK exchange         | ephemeral | no | provided | generated |
+-----------------------+-----------+----+----------+-----------+
| s_init_cert_verify    |     y+    | -  |    y     |     y     |
| s_new_ticket          |     -     | -  |    -     |     -     |
| s_init_early_secret   |     -     | -  |    -     |     -     |
| s_hand_and_app_secret |     y     | y  |    y     |     y     |
| c_init_post_hand      |     y     | -  |    y     |     -     |
| c_post_hand           |     y     | -  |    y     |     y     |
| c_init_cert_verify    |     y     | -  |    y     |     y     |
| c_init_client_hello   |     y     | y  |    -     |     y     |
| c_client_hello        |     y     | y  |    -     |     y     |
| c_hand_and_app_secret |     y     | y  |    y     |     -     |
| c_register_tickets    |     -     | -  |    -     |     -     |
+-----------------------+-----------+----+----------+-----------+

y indicates presence of ephemeral or possible value for ephemeral_method
- indicates absent or ephemeral or incompatible value for ephemeral_method
</pre>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-ephemeral-field-in-lurk-exc" class="selfRef">Ephemeral field in LURK exchange</a>
            </figcaption></figure>
</div>
<p id="section-5.5.3-4">The extension data is defined as follows:<a href="#section-5.5.3-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.5.3-5">
<pre>
enum { no_secret (0), secret_provided(1), secret_generated(2) (255)} EphemeralMethod;

EphemeralRequest {
    EphemeralMethod method;
    select(method) {
        case secret_provided:
            SharedSecret shared_secret&lt;0..2^16&gt;;
    }
}

EphemeralResponse {
    select(method) {
        case secret_generated:
            KeyShareEntry server_share
  }
}
</pre><a href="#section-5.5.3-5" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="sec_psk_id">
<section id="section-5.6">
        <h3 id="name-selected_identity">
<a href="#section-5.6" class="section-number selfRef">5.6. </a><a href="#name-selected_identity" class="section-name selfRef">selected_identity</a>
        </h3>
<p id="section-5.6-1">The selected_identity indicates the identity of the PSK used in the key schedule.
The selected_identity is expressed as a (0-based) index into the identities in the client's list. The client's list is provided in the pre_shared_key extension as expressed in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.2.11.<a href="#section-5.6-1" class="pilcrow">¶</a></p>
<p id="section-5.6-2">The LURK client MUST provide the selected_identity only when PSK or PSK-authentication is envisioned and when the PSK has not been provided earlier. 
These exchanges are s_init_early_secret on the TLS server and c_init_early_secret and c_init_hand_secret on the TLS client side.<a href="#section-5.6-2" class="pilcrow">¶</a></p>
<span id="name-psk_id-in-lurk-exchange"></span><div id="table_psk">
<figure id="figure-8">
          <div class="artwork art-text alignLeft" id="section-5.6-3.1">
<pre>
+-----------------------+-----+
| LURK exchange         | req |
+-----------------------+-----+
| s_init_cert_verify    |  -  |
| s_new_ticket          |  -  |
| s_init_early_secret   |  y  |
| s_hand_and_app_secret |  -  |
| c_init_post_hand_auth |  -  |
| c_post_hand_auth      |  -  |
| c_init_cert_verify    |  -  |
| c_init_client_hello   |  -  |
| c_client_hello        |  -  |
| c_hand_and_app_secret |  -  |
| c_register_tickets    |  -  |
+-----------------------+-----+

y indicates the selected_identity is present
- indicates the selected_identity is absent
</pre>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-psk_id-in-lurk-exchange" class="selfRef">psk_id in LURK exchange</a>
          </figcaption></figure>
</div>
<p id="section-5.6-4">The extension data is defined as follows:<a href="#section-5.6-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.6-5">
<pre>
uint16 selected_identity; //RFC8446 section 4.2.11
</pre><a href="#section-5.6-5" class="pilcrow">¶</a>
</div>
<p id="section-5.6-6">The CS retrieve the PSK identity from the ClientHello and SHOULD send an invalid_psk error if an error occurs. 
If the PSK is not provided, a default PSK is generated as described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 7.1. If the default PSK is not allowed then an invalid_psk is returned.<a href="#section-5.6-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_cert">
<section id="section-5.7">
        <h3 id="name-certificate">
<a href="#section-5.7" class="section-number selfRef">5.7. </a><a href="#name-certificate" class="section-name selfRef">certificate</a>
        </h3>
<p id="section-5.7-1">The certificate structure indicates the presence and associated value of the Certificate message in the TLS handshake.<a href="#section-5.7-1" class="pilcrow">¶</a></p>
<p id="section-5.7-2">Upon receiving a certificate field, the CS MUST:
1. ensure coherent with the handshake messages - typically authentication method is ECDHE and not PSK or PSK-ECDHE.
2. ensure the provided value corresponds to an acceptable provisioned value. 
3. generate the appropriated corresponding message.<a href="#section-5.7-2" class="pilcrow">¶</a></p>
<p id="section-5.7-3">If the CS is not able to understand the lurk_tls13_certificate field, it SHOULD return an invalid_certificate error.<a href="#section-5.7-3" class="pilcrow">¶</a></p>
<p id="section-5.7-4">Table <a href="#table_cert" class="xref">Figure 9</a> indicates the presence of that field in the LURK exchanges.<a href="#section-5.7-4" class="pilcrow">¶</a></p>
<span id="name-certificate-per-lurk-exchan"></span><div id="table_cert">
<figure id="figure-9">
          <div class="artwork art-text alignLeft" id="section-5.7-5.1">
<pre>
+-----------------------+-------------+--------------------+
| LURK exchange         | certificate | certificate type   |
+-----------------------+-------------+--------------------+
| s_init_cert_verify    |      y      | server certificate |
| s_new_ticket          |      *      | client certificate |
| s_init_early_secret   |      -      |                    |
| s_hand_and_app_secret |      -      |                    |
| c_init_post_hand_auth |      y      | client_certificate |
| c_post_hand_auth      |      y      | client_certificate |
| c_init_cert_verify    |      y      | client certificate |
| c_init_client_hello   |      -      |                    |
| c_client_hello        |      -      |                    |
| c_hand_and_app_secret |      y      | client_certificate |
| c_register_tickets    |      -      |                    |
+-----------------------+-------------+--------------------+

* indicates certificate type MAY be set to emtpy.
y indicates certificate type MUST NOT be set to empty
- indicates the certificate structure is absent
</pre>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-certificate-per-lurk-exchan" class="selfRef">certificate per LURK exchange</a>
          </figcaption></figure>
</div>
<p id="section-5.7-6">There are different ways the LURK client can provide the certificate message:<a href="#section-5.7-6" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.7-7">
<pre>
enum { empty(0), finger_print(1), uncompressed(2), (255)
}; LURKTLS13CertificateType

struct {
    LURKTLS13CertificateType certificate_type;
    select (certificate_type) {
        case empty:
          // no payload
        case finger_print
            uint32 hash_cert;
        case uncompressed:
            Certificate certificate; // RFC8446 section 4.4.2
    };
} LURKTLS13Certificate;
</pre><a href="#section-5.7-7" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-5.7-8">
          <dt id="section-5.7-8.1">empty</dt>
          <dd style="margin-left: 1.5em" id="section-5.7-8.2">
  indicates there is no certificates provided by this field.<a href="#section-5.7-8.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.7-8.3">fingerprint</dt>
          <dd style="margin-left: 1.5em" id="section-5.7-8.4">
  a 4 bytes finger print length that represents the fingerprinting of the TLS Certificate message. 
Fingerprinting is described in <span>[<a href="#RFC7924" class="xref">RFC7924</a>]</span> and takes as input the full handshake message - that is a message of message type certificate with that contain the Certificate as its message_data. 
In this document only the 4 most left bytes of the output are considered. 
uncompressed<a href="#section-5.7-8.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.7-8.5"></dt>
          <dd style="margin-left: 1.5em" id="section-5.7-8.6">indicates the Certificate message as defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> is provided.<a href="#section-5.7-8.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_tag">
<section id="section-5.8">
        <h3 id="name-tag">
<a href="#section-5.8" class="section-number selfRef">5.8. </a><a href="#name-tag" class="section-name selfRef">tag</a>
        </h3>
<p id="section-5.8-1">This field provides extra information. 
Currently, the tag structure defines tag.last_message and tag.cert_request.<a href="#section-5.8-1" class="pilcrow">¶</a></p>
<p id="section-5.8-2">The LURK client or the CS sets the tag.last_message to terminate the LURK session. 
The tag.cert_request is only used by the CS in a c_hand_and_app_secret exchange. 
The tag.cert_request by the CS when a  CertificateRequest has been found in the handshake and that the CS includes in its response the necessary information to the TLS client to build a CertificateVerify message (see <a href="#sec_c_hand_and_app_secret" class="xref">Section 7.6</a> ).<a href="#section-5.8-2" class="pilcrow">¶</a></p>
<p id="section-5.8-3">In this document, we use setting, setting to True to indicate the bit is set to 1. Respectively, we say unsetting, setting to False to indicate the bit is set to 0.<a href="#section-5.8-3" class="pilcrow">¶</a></p>
<p id="section-5.8-4">Table <a href="#table_tag_values" class="xref">Figure 10</a> indicates the different values carried by the tag as well as the exchange these tags are considered. 
The bits values MUST be ignored outside their exchange context and bits 
Bits that are not specified within a given exchange MUST be set to zero by the sender and MUST be ignored by the receiver.<a href="#section-5.8-4" class="pilcrow">¶</a></p>
<span id="name-tag-description"></span><div id="table_tag_values">
<figure id="figure-10">
          <div class="artwork art-text alignLeft" id="section-5.8-5.1">
<pre>
+------+----------------+
| Bit  | description    |
+------+----------------+
| 0    | last_exchange  |
| 1    | cert_request   |
| 2-7  | RESERVED       |
+------+----------------+
</pre>
</div>
<figcaption><a href="#figure-10" class="selfRef">Figure 10</a>:
<a href="#name-tag-description" class="selfRef">tag description</a>
          </figcaption></figure>
</div>
<span id="name-tag-per-lurk-exchange"></span><div id="table_tag">
<figure id="figure-11">
          <div class="artwork art-text alignLeft" id="section-5.8-6.1">
<pre>
+-----------------------+--------------+--------------+
| LURK exchange         | last_message | cert_request |
+-----------------------+--------------+--------------+
| s_init_cert_verify    |       y      |       -      |
| s_new_ticket          |       y      |       -      |
| s_init_early_secret   |       -      |       -      |
| s_hand_and_app_secret |       y      |       -      |
| c_init_post_hand_auth |       y      |       -      |
| c_post_hand_auth      |       y      |       -      |
| c_init_cert_verify    |       y      |       -      |
| c_init_client_hello   |       -      |       -      |
| c_client_hello        |       -      |       _      |
| c_hand_and_app_secret |       y      | y (response) |
| c_register_tickets    |       y      |       -      |
+-----------------------+--------------+--------------+

y indicates tag is present
- indicates tag is absent
</pre>
</div>
<figcaption><a href="#figure-11" class="selfRef">Figure 11</a>:
<a href="#name-tag-per-lurk-exchange" class="selfRef">tag per LURK exchange</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="sec_secret">
<section id="section-5.9">
        <h3 id="name-secret">
<a href="#section-5.9" class="section-number selfRef">5.9. </a><a href="#name-secret" class="section-name selfRef">secret</a>
        </h3>
<p id="section-5.9-1">The Secret structure is used by the CS to send the various secrets derived by the key schedule described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 7.<a href="#section-5.9-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.9-2">
<pre>
enum {
    binder_key (0),
    client_early_traffic_secret(1),
    early_exporter_master_secret(2),
    client_handshake_traffic_secret(3),
    server_handshake_traffic_secret(4),
    client_application_traffic_secret_0(5),
    server_application_traffic_secret_0(6),
    exporter_master_secret(7),
    esumption_master_secret(8),
    (255)
} SecretType;

struct {
    SecretType secret_type;
    opaque secret_data&lt;0..2^8-1&gt;;
} Secret;
</pre><a href="#section-5.9-2" class="pilcrow">¶</a>
</div>
<p id="section-5.9-3">secret_type:
The type of the secret or key<a href="#section-5.9-3" class="pilcrow">¶</a></p>
<p id="section-5.9-4">secret_data:
The value of the secret.<a href="#section-5.9-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_sig">
<section id="section-5.10">
        <h3 id="name-signature">
<a href="#section-5.10" class="section-number selfRef">5.10. </a><a href="#name-signature" class="section-name selfRef">signature</a>
        </h3>
<p id="section-5.10-1">The signature requires the signature scheme, a private key and the appropriated context. 
The signature scheme is provided using the SignatureScheme structure defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.2.3, the private key is derived from the lurk_tls13_certificate <a href="#sec_cert" class="xref">Section 5.7</a> and the context is derived from the handshake <a href="#sec_handshake" class="xref">Section 5.2</a> and lurk_tls13_certificate <a href="#sec_cert" class="xref">Section 5.7</a>.<a href="#section-5.10-1" class="pilcrow">¶</a></p>
<p id="section-5.10-2">Signing operations are described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.4.3. 
The context string is derived from the role and the type of the LURK exchange as described
below. 
The Handshake Context is taken from the key schedule context.<a href="#section-5.10-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.10-3">
<pre>
+--------------------+-------------------------------------+
| type               | context                             |
+--------------------+-------------------------------------+
| s_init_cert_verify | "TLS 1.3, server CertificateVerify" |
| c_cert_verify      | "TLS 1.3, client CertificateVerify" |
+--------------------+-------------------------------------+
</pre><a href="#section-5.10-3" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-5.10-4">
<pre>
struct {
    opaque signature&lt;0..2^16-1&gt;; //RFC8446 section 4.4.3.
} Signature;
</pre><a href="#section-5.10-4" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="lurk-exchange-on-the-tls-server">
<section id="section-6">
      <h2 id="name-lurk-exchange-on-the-tls-se">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-lurk-exchange-on-the-tls-se" class="section-name selfRef">LURK exchange on the TLS server</a>
      </h2>
<p id="section-6-1">This section describes the LURK exchanges that are performed on the TLS server. 
Unless specified used structures are described in <a href="#sec_structures" class="xref">Section 5</a><a href="#section-6-1" class="pilcrow">¶</a></p>
<div id="sec_s_init_cert_verify">
<section id="section-6.1">
        <h3 id="name-s_init_cert_verify">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-s_init_cert_verify" class="section-name selfRef">s_init_cert_verify</a>
        </h3>
<p id="section-6.1-1">s_init_cert_verify initiates a LURK session when the server is authenticated with ECDHE. 
The ClientHello received by the TLS server, and the ServerHello and optionally the HelloRetryRequest MUST carry a key_share extension.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">If the LURK client is configured to not proceed to further exchange, it sets the last_exchange bit of the tag. When this bit is set, the session_id is ignored.
The CS sets the last_exchange bit if the last_exchange bit has been set by the LURK client or when it has been configured to not accept further LURK exchanges, such as s_new_ticket.<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1-3">
<pre>
struct{
    uint8 tag;
    select (tag.last_exchange){
      case False:
        uint32 session_id;
    }
    FreshnessFunct freshness;
    Ephemeral ephemeral;
    Handshake handshake&lt;0..2^32&gt;; //RFC8446 section 4
    LURKTLS13Certificate certificate;
    uint16 secret_request;
    SignatureScheme sig_algo; //RFC8446 section 4.2.3.
}SInitCertVerifyRequest

struct{
    uint8 tag;
    select (tag.last_exchange){
      case False:
        uint32 session_id;
    }
    Ephemeral ephemeral;
    Secret secret_list&lt;0..2^16-1&gt;;
    Signature signature;
}SInitCertVerifyResponse
</pre><a href="#section-6.1-3" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-6.1-4">
          <dt id="section-6.1-4.1">sig_algo</dt>
          <dd style="margin-left: 1.5em" id="section-6.1-4.2">
  SignatureScheme is defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.2.3.<a href="#section-6.1-4.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="snewtickets">
<section id="section-6.2">
        <h3 id="name-s_new_tickets">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-s_new_tickets" class="section-name selfRef">s_new_tickets</a>
        </h3>
<p id="section-6.2-1">new_session ticket handles session resumption.
It enables to retrieve NewSessionTickets that will be forwarded to the TLS client by the TLS server to be used later when session resumption is used. 
It also provides the ability to delegate the session resumption authentication from the CS to the TLS server. 
In fact, if the LURK client requests and receives the resumption_master_secret it is able to emit on its own NewSessionTicket. 
As a result s_new_ticket LURK exchanges are only initiated if the TLS server expects to perform session resumption and the CS responds only if if session_resumption is enabled.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">The CS MAY responds with a resumption_master_secret based on its policies.<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2-3">The LURK client MAY perform multiple s_new_ticket exchanges. 
The LURK client and CS are expected to advertise by setting the last_exchange bit in the tag field.<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.2-4">
<pre>
struct {
    uint8 tag
    uint32 session_id
    Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4.
    LURKTLS13Certificate certificate;
    uint8 ticket_nbr;
    uint16 secret_request;
} SNewTicketRequest;


struct {
    uint8 tag
    uint32 session_id
    Secret secret_list&lt;0..2^16-1&gt;;
    NewSessionTicket ticket_list&lt;0..2^16-1&gt;; //RFC8446 section 4.6.1.
} SNewTicketResponse;
</pre><a href="#section-6.2-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2-5">ticket_nbr:
designates the requested number of NewSessionTicket. 
In the case of delegation this number MAY be set to zero. 
The CS MAY responds with less tickets when the value is too high.<a href="#section-6.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_s_init_early_secret">
<section id="section-6.3">
        <h3 id="name-s_init_early_secret">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-s_init_early_secret" class="section-name selfRef">s_init_early_secret</a>
        </h3>
<p id="section-6.3-1">s_init_early_secret initiates a LURK session when the server is authenticated by the PSK or PSK-ECDHE methods. 
This means the ClientHello received by the TLS server and ServerHello responded by the TLS server MUST carry the pre_shared_key and psk_key_exchange_modes extensions.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<p id="section-6.3-2">selected_identity indicates the selected PSK<a href="#section-6.3-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.3-3">
<pre>
struct{
    uint32 session_id
    FreshnessFunct freshness
    uint16 selected_identity
    Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4
    uint16 secret_request;
}SInitEarlySecretRequest

struct{
    uint32 session_id
    Secret secret_list&lt;0..2^16-1&gt;;
}SInitEarlySecretResponse
</pre><a href="#section-6.3-3" class="pilcrow">¶</a>
</div>
<p id="section-6.3-4">The binder_key MUST be requested, since it is used to validate the PSK. 
The TLS client MAY indicate support for early application data via the early_data extension. Depending on the TLS server policies, it MAY accept early data and request the client_early_traffic_secret. 
The TLS server MAY have specific policies and request early_exporter_master_secret.<a href="#section-6.3-4" class="pilcrow">¶</a></p>
<p id="section-6.3-5">The CS MUST check pre_shared_key and psk_key_exchange_modes extensions are present in the ClientHello message. 
If these extensions are not present, a invalid_handshake error SHOULD be returned. 
The CS MUST ignore the client_early_traffic_secret if early_data extension is
not found in the ClientHello. 
The Cryptographic Service MAY ignore the request for client_early_traffic_secret or early_exporter_master_secret depending on configuration parameters.<a href="#section-6.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_s_hand_and_app_secret">
<section id="section-6.4">
        <h3 id="name-s_hand_and_app_secret">
<a href="#section-6.4" class="section-number selfRef">6.4. </a><a href="#name-s_hand_and_app_secret" class="section-name selfRef">s_hand_and_app_secret</a>
        </h3>
<p id="section-6.4-1">The s_hand_and_app_secret is necessary to complete the ServerHello and always
follows an s_init_early_secret LURK exchange. Such sequence is guaranteed by the session_id. 
In case of unknown session_id or an invalid_request error SHOULD be returned.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
<p id="section-6.4-2">The LURK client MUST ensure that PSK or PSK-ECDHE authentication has been
selected via the presence of the pre_shared_key extension in the
ServerHello. 
In addition, the selected identity MUST be the one provided in the pre_shared_key extension of the previous s_init_early_secret exchange. 
The CS MUST also check the selected cipher in the ServerHello match the one associated to the PSK. 
The CS generates the Finished message as described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.4.4. Which involves the h_s secret.
The LURK client MAY request the exporter_master_secret depending on its policies. 
The CS MAY ignore the request based on its policies.<a href="#section-6.4-2" class="pilcrow">¶</a></p>
<p id="section-6.4-3">If the LURK client is configured to not proceed to further exchange, it sets the last_exchange bit of the tag.
The CS sets the last_exchange bit if the last_exchange bit has been set by the LURK client or when it has been configured to not accept further LURK exchange.<a href="#section-6.4-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.4-4">
<pre>
struct{
    uint8 tag
    uint32 session_id
    Ephemeral ephemeral
    Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4
    uint16 secret_request;
} SHandAndAppSecretRequest

struct{
    uint8 tag
    uint32 session_id
    Ephemeral ephemeral
    Secret secret_list&lt;0..2^16-1&gt;;
} SHandAndAppSecretResponse
</pre><a href="#section-6.4-4" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="lurk-exchange-on-the-tls-client">
<section id="section-7">
      <h2 id="name-lurk-exchange-on-the-tls-cl">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-lurk-exchange-on-the-tls-cl" class="section-name selfRef">LURK exchange on the TLS client</a>
      </h2>
<p id="section-7-1">The CS described in this document considers the case where PSK and (EC)DHE private part MAY be protected by the CS. 
This document does not consider the case where a TLS client may propose a combination of protected and unprotected PSKs.
Either all proposed PSK are unprotected by the CS or all PSK are protected by the CS. 
Similarly, this document does not consider the case where a TLS client may propose a combination of protected and unprotected (EC)DHE. 
Either all (EC)DHE are generated by the CS or all (EC)DHE are generated by the TLS client.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">Figure <a href="#fig_state_tls_client_clt" class="xref">Figure 12</a> summarizes the different possible LURK session as well as the different messages that are involved in the session.<a href="#section-7-2" class="pilcrow">¶</a></p>
<span id="name-lurk-client-state-diagram"></span><div id="fig_state_tls_client_clt">
<figure id="figure-12">
        <div class="artwork art-text alignLeft" id="section-7-3.1">
<pre>
                    ^           |        no
                    |   (EC)DHE in CS or ------------+
      ClientHello   |   PSK in CS Proposed           |
      Derivation    |       yes |                    |
                    |   c_init_client_hello          |
                    |           |           no       |
                    |   Hello Retry Request --+      |
                    |       yes |             |      |
      ClientHello   |    c_client_hello       |      |
      sent       --&gt;v           |&lt;------------+      |
      ServerHello--&gt;^           |                    |      no
      received      |           |              ECDHE Agreed --+
                    |           |                yes |        |
        ServerHello | c_hand_and_app_secret c_init_cert_verify|
        Treatment   |           |                    |        |
      clientFinished|           +-------+------------+        |     no
      sent       --&gt;v                   |         Post Auth Enabled --+
                    ^                   |                  +          |
                    |                   |         CertificateRequest  |
                    |                   |                 |           |
                    |                   |        c_init_post_hand_auth|
                    |                   |                     |       |
                    |+-----------------&gt;|&lt;--------------------+       |
      Posthandshake ||        +---------+-------+                     |
      Treatment     ||        |                 |                     |
                    ||Post Auth Enabled   (EC)DHE in CS or            |
                    ||         +          Agreed PSK in CS            |
                    ||CertificateRequest        +                     |
                    ||        |          NewSessionTicket             |
                    ||        |                 |                     |
                    ||c_post_hand_auth c_register_tickets             |
                    ||        |                 |                     |
                    ||        +-------+---------+                     |
                    ||                |                               |
                    v+----------------+                         +-----+
                                      |                         |
                                 LURK session         LURK session
                                 closed               not initiated
</pre>
</div>
<figcaption><a href="#figure-12" class="selfRef">Figure 12</a>:
<a href="#name-lurk-client-state-diagram" class="selfRef">LURK client State Diagram</a>
        </figcaption></figure>
</div>
<p id="section-7-4">The TLS client needs to interact with the CS when either the TLS client proposes PKSs and the CS hosts the PSKs or when the TLS client requests the CS to generate the (EC)DHE private key.
The TLS client requests with a c_init_client_hello exchange the CS the binder_keys, the (EC)DHE public part as well as early secrets and is thus able to start the TLS handshake, that is sending a ClientHello with potential early data. 
In case a HeloRetryRequest is received, the TLS client pursue with a c_client_hello exchange to complete the second ClientHello. 
Upon receiving a ServerHello as well as other messages by the TLS server, the TLS client requests via a c_hand_and_App_secret exchange the necessary information (signature, secrets) to complete the TLS handshake.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">When the TLS client does not propose PSKs that are protected by the CS nor does request the CS to generate the private part of the (EC)DHE shared secret, the TLS client does not need to interact wit the CS to send its ClientHello.
However, the TLS client may interact with the CS to authenticate itself to the TLS server via the generation of a signature contained in a CertificateVerify message. 
Such authentication can be performed during the TLS handshake when ECDHE is agreed and when the TLS client enables post handshake authentication, in which case the signature is requested via a c_init_cert_verify exchange.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">Once the TLS handshake is completed, and the TLS client has enabled post handshake authentication, the TLS server may request by sending a CertificateRequest the TLS client to authenticate itself with a signature. 
If the TLS client has already started a LURK session associated to the TLS handshake the signature is requested via a c_post_hand_auth exchange.
Otherwise, the signature is requested via a c_init_post_hand_auth exchange. 
Multiple post hand shake authentication may be performed in both cases and additional signature generation are requested via c_post_hand_auth exchange.<a href="#section-7-6" class="pilcrow">¶</a></p>
<p id="section-7-7">Similarly, once the TLS handshake is completed, the TLS client may receive NewSessionTickets from the TLS server to perform session resumption. 
If the TLS client has its (EC)DHE or the PSK in use protected by the CS - the NewSessionTicket is registered via a c_register_ticket. 
Multiple NewSessionTickets may be registered.
When no protected PSK have been agreed and (EC)DHE are not generated by the CS, the TLS client may generate the PSK session resumption. 
As a result, it cannot be registered in the CS as to prevent providing a false sense of security.<a href="#section-7-7" class="pilcrow">¶</a></p>
<div id="sec_c_init_post_hand_auth">
<section id="section-7.1">
        <h3 id="name-c_init_post_hand_auth">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-c_init_post_hand_auth" class="section-name selfRef">c_init_post_hand_auth</a>
        </h3>
<p id="section-7.1-1">The c_init_post_hand_auth occurs when the TLS client performs post handshake authentication while no previous interactions occurred between the TLS client and the CS.
More specifically, the (EC)DHE shared secrets have been generated by the TLS client, and the proposed keys, if proposed previously by the TLS client, are not protected by the CS.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">The CS completes and returns the signature as described in <a href="#sec_sig" class="xref">Section 5.10</a>.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
<p id="section-7.1-3">Since session resumption secrets are not protected by the CS, the registration of NewSessioinTickets is not expected, and the only exchanges that MAY follow are additional post handshake authentications described in <a href="#sec_c_post_hand_auth" class="xref">Section 7.2</a>.<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.1-4">
<pre>
struct{
  uint8 tag;
  select (tag.last_exchange){
    case False:
      uint32 session_id;
  }
  FreshnessFunct freshness;
  Ephemeral = ephemeral     ## ephemeral_method = secret_provided
  Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4
  LURKTLS13Certificate cert;
  SignatureScheme sig_algo;
}CInitPostHandAuthRequest


struct{
  unit8 tag
  select (tag.last_exchange){
    case False:
      uint32 session_id;
  }
  Signature signature
}CInitPostHandAuth
</pre><a href="#section-7.1-4" class="pilcrow">¶</a>
</div>
<span class="break"></span><dl class="dlParallel" id="section-7.1-5">
          <dt id="section-7.1-5.1">tag</dt>
          <dd style="margin-left: 1.5em" id="section-7.1-5.2">
  is defined in <a href="#sec_tag" class="xref">Section 5.8</a>. 
The TLS client sets tag.last_message if further post handshake authentications are expected.
Similarly the CS sets the tag.last_message if further post handshake authentications are permitted. 
Note that it is out of scope of this specification to specify the reasons, but it is RECOMMENEDED the CS sets life time to LURK session as well as limits the maximum number of post handshake authentications.<a href="#section-7.1-5.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-5.3">ephemeral</dt>
          <dd style="margin-left: 1.5em" id="section-7.1-5.4">
  is defined in <a href="#sec_ephemeral" class="xref">Section 5.5</a> and ephemeral_method MUST be set to 'secret_provided' when the TLS handshake agreed an ECDHE or a PSK-ECDHE authentication. 
The ephemeral_method MUST be set to 'no_secret' when PSK the TLS handshake agreed on PSK authentication.<a href="#section-7.1-5.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-5.5">handshake</dt>
          <dd style="margin-left: 1.5em" id="section-7.1-5.6">
  is defined in <a href="#sec_handshake" class="xref">Section 5.2</a> and post handshake authentication MUST be enabled by the TLS client.<a href="#section-7.1-5.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-5.7">cert</dt>
          <dd style="margin-left: 1.5em" id="section-7.1-5.8">
  is defined in <a href="#sec_cert" class="xref">Section 5.7</a> and is used by the TLS client to indicate the expected certificate to be used to compute the signature as well as the certificate that is expected to be send further to the TLS server.<a href="#section-7.1-5.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-5.9">sig_algo</dt>
          <dd style="margin-left: 1.5em" id="section-7.1-5.10">
  is defined in <a href="#sec_sig" class="xref">Section 5.10</a> and indicates the selected algorithm.<a href="#section-7.1-5.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-5.11">signature</dt>
          <dd style="margin-left: 1.5em" id="section-7.1-5.12">
  is defined in <a href="#sec_sig" class="xref">Section 5.10</a>.<a href="#section-7.1-5.12" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_c_post_hand_auth">
<section id="section-7.2">
        <h3 id="name-c_post_hand_auth">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-c_post_hand_auth" class="section-name selfRef">c_post_hand_auth</a>
        </h3>
<p id="section-7.2-1">The c_post_hand_auth exchange enables a TLS client to perform post handshake authentication.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">This exchange is followed by a c_register_ticket or a c_post_hand_and_app exchange.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.2-3">
<pre>
struct{
  Tag tag
  uint32 session_id
  Ephemeral = ephemeral     ## ephemeral_method = secret_provided
  Handshake handshake&lt;0..2^32&gt; // CertificateRequest
  LURKTLS13Certificate cert;
  SignatureScheme sig_algo;
}CPostHandAuthRequest


struct{
  Tag tag
  uint32 session_id
  Signature signature
}CPostHandAuth
</pre><a href="#section-7.2-3" class="pilcrow">¶</a>
</div>
<p id="section-7.2-4">tag, sig_algo, cert, signature are described in <a href="#sec_c_init_post_hand_auth" class="xref">Section 7.1</a><a href="#section-7.2-4" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.2-5">
          <dt id="section-7.2-5.1">handshake</dt>
          <dd style="margin-left: 1.5em" id="section-7.2-5.2">
  is defined in <a href="#sec_handshake" class="xref">Section 5.2</a> and is only composed of a CertificateRequest. 
However, post handshake authentication MUST be enabled by the TLS client.<a href="#section-7.2-5.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="cinitcertverify">
<section id="section-7.3">
        <h3 id="name-c_init_cert_verify">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-c_init_cert_verify" class="section-name selfRef">c_init_cert_verify</a>
        </h3>
<p id="section-7.3-1">The c_init_cert_verify exchange occurs when the TLS client is being requested to authenticate during the TLS handshake.
According to <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> client authentication during the TLS handshake is not valid with a PSK or PSK based authentication. 
As a result, ECHDE needs to be agreed. 
In addition, as c_init_cert_verify initiates a LURK session, the ECDHE shared secrets have been generated by the TLS client as opposed to the CS.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<p id="section-7.3-2">The CS completes and returns the signature as described in <a href="#sec_sig" class="xref">Section 5.10</a>. 
When further LURK exchanges are expected, the CS generates also the Finished message in order to be able to complete the latter requests for post authentication.<a href="#section-7.3-2" class="pilcrow">¶</a></p>
<p id="section-7.3-3">This exchange is followed by a c_post_hand_auth exchange.<a href="#section-7.3-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.3-4">
<pre>
struct{
    uint8 tag;
    select (tag.last_exchange){
      case False:
        uint32 session_id;
    }
    FreshnessFunct freshness;
    Ephemeral ephemeral;
    Handshake handshake&lt;0..2^32&gt;; //RFC8446 section 4
    LURKTLS13Certificate certificate;
    SignatureScheme sig_algo; //RFC8446 section 4.2.3.
}CInitCertVerifyRequest

struct{
    uint8 tag;
    select (tag.last_exchange){
      case False:
        uint32 session_id;
    }
    Ephemeral ephemeral;
    Signature signature;
}CInitCertVerifyResponse
</pre><a href="#section-7.3-4" class="pilcrow">¶</a>
</div>
<p id="section-7.3-5">freshness, session_id are respectively defined in <a href="#sec_freshness" class="xref">Section 5.4</a> and <a href="#sec_session_id" class="xref">Section 5.3</a>.<a href="#section-7.3-5" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.3-6">
          <dt id="section-7.3-6.1">tag</dt>
          <dd style="margin-left: 1.5em" id="section-7.3-6.2">
            <p id="section-7.3-6.2.1">
  is defined in <a href="#sec_tag" class="xref">Section 5.8</a>. The TLS client that does not expect an additional post handshake authentication MUST set it tag.last_message. 
A consequence is that a TLS client that does not enable post authentication MUST set the tag.last_message.<a href="#section-7.3-6.2.1" class="pilcrow">¶</a></p>
<p id="section-7.3-6.2.2">
The CS MUST set the tag.last_message when the TLS client does not enabled post handshake authentication or when no further post handshake authentication is expected.<a href="#section-7.3-6.2.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-7.3-6.3">ephemeral</dt>
          <dd style="margin-left: 1.5em" id="section-7.3-6.4">
  is defined in <a href="#sec_ephemeral" class="xref">Section 5.5</a>. The TLS client MUST set the ephemeral_method to 'secret_provided'.<a href="#section-7.3-6.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.3-6.5">handshake</dt>
          <dd style="margin-left: 1.5em" id="section-7.3-6.6">
  is defined in <a href="#sec_handshake" class="xref">Section 5.2</a> and must be set to ECDHE agreed. Note that PSK may be proposed if these PSKs are not provisioned in the CS. The handshake messages are also in clear.<a href="#section-7.3-6.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_c_init_client_hello">
<section id="section-7.4">
        <h3 id="name-c_init_client_hello">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-c_init_client_hello" class="section-name selfRef">c_init_client_hello</a>
        </h3>
<p id="section-7.4-1">The c_init_ephemeral_binder exchange occurs when the  TLS client needs to generate the ClientHello as well as the early secrets.
In fact the generation of the ClientHello may require the CS to generates the (EC)DHE  private key and returns the public part as well as the binder_key to generate the binders. 
On the other hand, the generation of the early secrets requires the ClientHello to be completed. 
As a result, the CS will be expected to complete the ClientHello from a potential partial ClientHello. 
More specifically, when binders are needed, the partial Client Hello does not contains the OfferedPsks structure, that is the PreSharedKeyExtension.
The latter structure is simply stripped from the ClientHello, without any further changes, such as changing the lengths for example.
It is entirely built by the CS and append as the last extension as described in section 4.2.11 of 
The reason for having CPskID as opposed to the identity structure is that nothing prevent identities of two different NewSessionTickets to be collide. 
CPskID are managed by the CS of the TLS client to prevent such collisions and are provided during the registration of the NewSessionTickets c_register_tickets (see <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>. 
Note that extension_type as well as the 16 bit length of the OfferedPsks remain present.
The PreSharedKeyExtension structure of the ClientHello is built from a list of CPskIDs where each CPskID designates a PSK with an identifier managed by the CS of the TLS client. 
The PSK can be associated to a NewSessionTicket in which case the CPskID will be used to designate the NewSessionTicket and its associate identity structure.<a href="#sec_c_register_tickets" class="xref">Section 7.7</a>). 
When the PSK is provisioned, the TLS client needs to be configured with it. 
When the CS is not able to generate the PreSharedKeyExtension an invalid_identity error SHOULD be raised.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
<p id="section-7.4-2">Note that when PSK is not proposed or when PSK are not registered in the CS, the ClientHello is fully provided -  without the PreSharedKeyExtension or with a completed PreSharedKeyExtension extension. 
The CS is expected to be able to distinguish between the two by for example, comparing the length of the handshake provided in c_init_client_hello and the length indicated in the ClientHello.<a href="#section-7.4-2" class="pilcrow">¶</a></p>
<p id="section-7.4-3">Note that (EC)DHE may be generated when ECDHE or PSK-ECDHE authentication is proposed by the TLS client, while early secrets and binder_key can only be requested when PSK is proposed. 
When the TLS client requests the generation of a (EC)DHE private key, the KeyShareClietHello MAY contain a list of KeyShareEntry (defined in section 4.2.8 
When an error is found regarding the KeyShareClientHello, the CS SHOULD raise an invalid_ephemeral error.
Note that according to <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> ).
When provided, these structures contains the group but are being stripped the key_exchange_value, while all other fields - including the lengths - are left unchanged.<a href="#sec_ephemeral" class="xref">Section 5.5</a> when the ephemeral_method is set to 'no_secret', the resulting list is empty.<a href="#section-7.4-3" class="pilcrow">¶</a></p>
<p id="section-7.4-4">This exchange is followed by a c_client_hello or a c_hand_and_app_secret.<a href="#section-7.4-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.4-5">
<pre>
struct{
  uint32 c_psk_id
}CPskID

struct{
  uint32 session_id
  Freshness freshness
  Ephemeral ephemeral ephemeral_method=secret_generate or no_secret
  Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4
  CPskID c_psk_id_list&lt;0..2^8-1&gt;
  uint16 secret_request;
}CInitClientHello

struct{
  uint32 session_id
  Ephemeral ephemeral_list&lt;0..2^16-1&gt;
  Secret secret_list&lt;0..2^16-1&gt;;
}CInitClientHello
</pre><a href="#section-7.4-5" class="pilcrow">¶</a>
</div>
<p id="section-7.4-6">session_id, freshness and ephemeral, secret_request and secret_list are respectively defined in <a href="#sec_session_id" class="xref">Section 5.3</a>, <a href="#sec_freshness" class="xref">Section 5.4</a>, <a href="#sec_ephemeral" class="xref">Section 5.5</a>, <a href="#sec_secret_request" class="xref">Section 5.1</a> and <a href="#sec_secret" class="xref">Section 5.9</a>.<a href="#section-7.4-6" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.4-7">
          <dt id="section-7.4-7.1">ephemeral</dt>
          <dd style="margin-left: 1.5em" id="section-7.4-7.2">
            <p id="section-7.4-7.2.1">
  is defined in <a href="#sec_ephemeral" class="xref">Section 5.5</a>. With a single ClientHello or partial ClientHello, ephemeral_method is set to secret_generate when ECDHE and PSK-ECDHE authentication are being proposed or no_secret when only PSK is proposed or when the ECDHE is generated by the TLS client.<a href="#section-7.4-7.2.1" class="pilcrow">¶</a></p>
<p id="section-7.4-7.2.2">
Note that even though the CLientHello requests multiple KeyShareENtries, a single ephemeral method is provided.<a href="#section-7.4-7.2.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-7.4-7.3">handshake</dt>
          <dd style="margin-left: 1.5em" id="section-7.4-7.4">
  is defined in <a href="#sec_handshake" class="xref">Section 5.2</a>. When a partial ClientHello is provided, PSK or PSK-ECDHE MUST be enabled. 
When a ClientHello is provided, PSK or PSK-ECDHE may be proposed but with unprotected keys. 
ClientHello, HelloRetryRequest, ClientHello or ClientHello, HelloRetryRequest, partial ClientHello MAY be provided. 
However, there are cases this is not possible, typically when the HellRequestRetry does not contain a key_share extension, the (EC)DHE shared secret is generated with the (EC)DHE generated associated to the first ClientHello. 
When the (EC)DHE private key has been generated by the CS, the TLS client MUST use a c_early_secret LURK exchange as defined in <a href="#sec_c_client_hello" class="xref">Section 7.5</a> in order to ensure the CS is aware of the (EC)DHE shared secret to generate the further secrets.<a href="#section-7.4-7.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.4-7.5">c_psk_id</dt>
          <dd style="margin-left: 1.5em" id="section-7.4-7.6">
  designate an 32 bit identifier for a PSK. 
This identifier is provided and managed by the CS of the TLS client to avoid collision of different PSK provided by different TLS servers.<a href="#section-7.4-7.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.4-7.7">c_psk_id_list</dt>
          <dd style="margin-left: 1.5em" id="section-7.4-7.8">
  designates the list of CPskIDs. 
The list is used by the CS to build the OfferedPsks structure - including the PSKIdentity structure. 
The list of identities in the OfferedPsks MUST be the same as the one of the c_psk_id_list.<a href="#section-7.4-7.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.4-7.9">ephemeral_list</dt>
          <dd style="margin-left: 1.5em" id="section-7.4-7.10">
  When contains the different values of (EC)DHE public parts - i.e. the KeyShareEntries when the ephemeral_method is set to secret_generated. 
When the ephemeral_method is set to no_secret, the list is an empty list by construction of the ephemeral structure (see <a href="#sec_ephemeral" class="xref">Section 5.5</a>).<a href="#section-7.4-7.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_c_client_hello">
<section id="section-7.5">
        <h3 id="name-c_client_hello">
<a href="#section-7.5" class="section-number selfRef">7.5. </a><a href="#name-c_client_hello" class="section-name selfRef">c_client_hello</a>
        </h3>
<p id="section-7.5-1">The c_client_hello exchange occurs after a TLS server responds to a ClientHello generated using a c_init_client_hello defined in <a href="#sec_c_init_client_hello" class="xref">Section 7.4</a> is being responded a HelloRetryRequest by the TLS server.
While in some cases, re-initiating a LURK exchange with a _init_client_hello MAY be considered, this document RECOMMENDS to proceed as follows when a HelloRetryRequest is received:<a href="#section-7.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.5-2.1">If the first ClientHello has been generated via a c_init_client_hello, use c_client_hello to generate the second ClientHello<a href="#section-7.5-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.5-2.2">If the first ClientHello has not been generated via a c_init_client_hello, consider generating the second ClientHello via c_init_client_hello.<a href="#section-7.5-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.5-3">This exchange is followed by a c_hand_and_app_secret.<a href="#section-7.5-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.5-4">
<pre>
struct{
  uint32 session_id
  Freshness freshness
  Ephemeral ephemeral ephemeral_method=secret_generate or no_secret
  Handshake handshake&lt;0..2^32&gt; //RFC8446 section 4
  uint16 secret_request;
}CClientHello

struct{
  uint32 session_id
  Ephemeral ephemeral
  Secret secret_list&lt;0..2^16-1&gt;;
}CClientHello
</pre><a href="#section-7.5-4" class="pilcrow">¶</a>
</div>
<p id="section-7.5-5">session_id, ephemeral, secret_request and secret_list are respectively defined in <a href="#sec_session_id" class="xref">Section 5.3</a>, <a href="#sec_ephemeral" class="xref">Section 5.5</a>, <a href="#sec_secret_request" class="xref">Section 5.1</a> and <a href="#sec_secret" class="xref">Section 5.9</a>.<a href="#section-7.5-5" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.5-6">
          <dt id="section-7.5-6.1">handshake</dt>
          <dd style="margin-left: 1.5em" id="section-7.5-6.2">
  is defined in <a href="#sec_handshake" class="xref">Section 5.2</a>. 
The handshake MUST contain a HelloRetryRequest and a ClientHello or partial ClientHello. 
The same restrictions as defined in <a href="#sec_c_init_client_hello" class="xref">Section 7.4</a> apply to the ClientHello<a href="#section-7.5-6.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_c_hand_and_app_secret">
<section id="section-7.6">
        <h3 id="name-c_hand_and_app_secret">
<a href="#section-7.6" class="section-number selfRef">7.6. </a><a href="#name-c_hand_and_app_secret" class="section-name selfRef">c_hand_and_app_secret</a>
        </h3>
<p id="section-7.6-1">The c_hand_and_app_secret exchange occurs after a ServerHello is received and the TLS client request handshake secrets to decrypt (resp. encrypt) handshake messages sent by (resp. to) the server.
Similarly the TLS client requests application secrets used to protect the TLS session as well as other secrets such as exporter secrets.<a href="#section-7.6-1" class="pilcrow">¶</a></p>
<p id="section-7.6-2">Upon receiption of the handshake the CS derives the handshake secrets and the server_handshake_traffic_secret as described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 7.3 to decrypt the encrypted messages.
The presence of a CertificateRequest indicates the TLS server expects the TLS client to authenticate via a CertificateVerify message. 
If the CS protects a private key associated to the TLS client, the CS MUST provides the necessary information to the TLS client client. 
Otherwise, the CertificateRequest is ignored by the CS.<a href="#section-7.6-2" class="pilcrow">¶</a></p>
<p id="section-7.6-3">When the CS generates the signature, the presence of the certificate, the signature and sig_algo is indicated by setting tag.cert_request. 
Unlike on the TLS server, where the TLS server indicates the certificate to chose  as well as the signature scheme to select, on the TLS client, such decision is left to the CS. 
The choice of the signature algorithm and certificate is performed by the CS as described in 
When resumption_master_secret is requested by the TLS client, or when further exchanges between teh TLS client and the CS are expected, the CS generates the CertificateVerify and Finished message to synchronize the TLS handshake context. 
The Certificate, respectively CertificateVerify and Finished message are generated as described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.4.2.3.  <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.4.2, section 4.4.3, and section 4.4.4.<a href="#section-7.6-3" class="pilcrow">¶</a></p>
<p id="section-7.6-4">This exchange is followed by a c_post_hand_auth, c_register_ticket exchange.<a href="#section-7.6-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.6-5">
<pre>
struct{
  uint8 tag;
  uint32 session_id;
  Ephemeral ephemeral;
  Handshake handshake&lt;0..2^32&gt;; //RFC8446 section 4
  uint16 secret_request;
}CHandAndAppSecretRequest

struct{
  uint8 tag;
  uint32 session_id;
  Secret secret_list&lt;0..2^16-1&gt;;
  select( tag.cert_request){
    case true:
      LURKTLS13Certificate certificate;
      SignatureScheme sig_algo;
      Signature signature;
  }
}CHandAndAppSecretRequest

</pre><a href="#section-7.6-5" class="pilcrow">¶</a>
</div>
<p id="section-7.6-6">session_id, secret_request certificate signature, and secret_list are respectively described in <a href="#sec_session_id" class="xref">Section 5.3</a>, <a href="#sec_secret_request" class="xref">Section 5.1</a>, <a href="#sec_cert" class="xref">Section 5.7</a>, <a href="#sec_sig" class="xref">Section 5.10</a> and <a href="#sec_secret" class="xref">Section 5.9</a><a href="#section-7.6-6" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.6-7">
          <dt id="section-7.6-7.1">tag</dt>
          <dd style="margin-left: 1.5em" id="section-7.6-7.2">
  is defined in <a href="#sec_tag" class="xref">Section 5.8</a> and indicates whether the further exchanges are expected or not. 
If the TLS client or the TLS server do not expect to perform session resumption or have not enabled post handshake authentication the tag.last_message SHOULD be set.<a href="#section-7.6-7.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.6-7.3">ephemeral</dt>
          <dd style="margin-left: 1.5em" id="section-7.6-7.4">
  is defined in <a href="#sec_ephemeral" class="xref">Section 5.5</a>. Since ClientHello as already been sent, the purpose of the ephemeral is to provid ethe (EC)DHE shared secret to perform the key schedule and ephemeral_method MUST NOT be set to secret_generated.<a href="#section-7.6-7.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.6-7.5">handshake</dt>
          <dd style="margin-left: 1.5em" id="section-7.6-7.6">
  is defined in <a href="#sec_handshake" class="xref">Section 5.2</a> and includes the ServerHello up to the server Finished. These messages are passed to the CS encrypted.<a href="#section-7.6-7.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.6-7.7">sig_algo</dt>
          <dd style="margin-left: 1.5em" id="section-7.6-7.8">
  is defined in <a href="#sec_sig" class="xref">Section 5.10</a> and defines the algorithm chosen by the CS.<a href="#section-7.6-7.8" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec_c_register_tickets">
<section id="section-7.7">
        <h3 id="name-c_register_tickets">
<a href="#section-7.7" class="section-number selfRef">7.7. </a><a href="#name-c_register_tickets" class="section-name selfRef">c_register_tickets</a>
        </h3>
<p id="section-7.7-1">The c_register_ticket is only used when the TLS client intend to
perform session resumption. 
The LURK client MAY
provide one or multiple NewSessionTickets. These tickets will be
helpful for the session resumption to bind the PSK value to some
identities. 
As teh NewSessionTicket's identities may collide when being provided by multiple TLS servers, the CS provides identities it manages to prevent such collisions (CPskID). 
One such CPskID is assigned to each ticket and is later used to designate that ticket (see <a href="#sec_c_init_client_hello" class="xref">Section 7.4</a>). 
When too many tickets are provided, the CS SHOULD raise a too_many_identities error.<a href="#section-7.7-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.7-2">
<pre>
struct {
  uint8 tag
  uint32 session_id
  NewSessionTicket ticket_list&lt;0..2^16-1&gt;; //RFC8446 section 4.6.1.
} RegisterTicketsRequest;

struct {
  uint8 tag
  uint32 session_id
  CPskID c_spk_id_list&lt;0..2^8-1&gt;
} RegisterTicketsResponse;

</pre><a href="#section-7.7-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="security-considerations">
<section id="section-8">
      <h2 id="name-security-considerations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-8-1">Security credentials as per say are the private key used to sign the
CertificateVerify when ECDHE authentication is performed as well as the
PSK when PSK or PSK-ECDHE authentication is used.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">The protection of these credentials means that someone gaining access to
the CS MUST NOT be able to use that access from
anything else than the authentication of an TLS being established. In
other way, it MUST NOT leverage this for:
* any operations outside the scope of TLS session establishment.
* any operations on past established TLS sessions
* any operations on future TLS sessions
* any operations on establishing TLS sessions by another LURK client.<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">The CS outputs are limited to secrets as well as
NewSessionTickets. The design of TLS 1.3 make these output of limited
use outside the scope of TLS 1.3. Signature are signing data specific to
TLS 1.3 that makes the signature facility of limited interest outside
the scope of TLS 1.3. NewSessionTicket are only useful in a context of
TLS 1.3 authentication.<a href="#section-8-3" class="pilcrow">¶</a></p>
<p id="section-8-4">ECDHE and PSK-ECDHE provides perfect forward secrecy which prevents past
session to be decrypted as long as the secret keys that generated teh
ECDHE share secret are deleted after every TLS handshake. PSK
authentication does not provide perfect forward secrecy and
authentication relies on the PSK remaining sercet. The Cryptographic
Service does not reveal the PSK and instead limits its disclosure to
secrets that are generated from the PSK and hard to be reversed.<a href="#section-8-4" class="pilcrow">¶</a></p>
<p id="section-8-5">Future session may be impacted if an attacker is able to authenticate a
future session based on what it learns from a current session. ECDHE
authentication relies on cryptographic signature and an ongoing TLS
handshake. The robustness of the signature depends on the signature
scheme and the unpredictability of the TLS Handshake. PSK authentication
relies on not revealing the PSK. The CS does not
reveal the PSK. TLS 1.3 has been designed so secrets generated do not
disclose the PSK as a result, secrets provided by the Cryptographic do
not reveal the PSK. NewSessionTicket reveals the identity (ticket) of a PSK.
NewSessionTickets.ticket are expected to be public data. It value is
bound to the knowledge of the PSK. The Cryptographic does not output any
material that could help generate a PSK - the PSK itself or the
resumption_master_secret. In addition, the Cryptographic only generates
NewSessionTickets for the LURK client that initiates the key schedule
with CS with a specific way to generate ctx_id. This
prevents the leak of NewSessionTickets to an attacker gaining access to
a given CS.<a href="#section-8-5" class="pilcrow">¶</a></p>
<p id="section-8-6">If an the attacker get the NewSessionTicket, as well as access to the
CS of the TLS client it will be possible to proceed
to the establishment of a TLS session based on the PSK. In this case,
the CS cannot make the distinction between the
legitimate TLS client and teh attacker.  This corresponds to the case
where the TLS client is corrupted.<a href="#section-8-6" class="pilcrow">¶</a></p>
<p id="section-8-7">Note that when access to the CS on the TLS server
side, a similar attack may be performed. However the limitation to a
single re-use of the NewSessionTicket prevents the TLS server to proceed
to the authentication.<a href="#section-8-7" class="pilcrow">¶</a></p>
<p id="section-8-8">Attacks related to other TLS sessions are hard by design of TLS 1.3
that ensure a close binding between the TLS Handshake and the generated
secrets. In addition communications between the LURK client and the
CS cannot be derived from an observed TLS handshake
(freshness function). This makes attacks on other TLS sessions unlikely.<a href="#section-8-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-considerations">
<section id="section-9">
      <h2 id="name-iana-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
    </h2>
</section>
</div>
<div id="acknowledgments">
<section id="section-10">
      <h2 id="name-acknowledgments">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
    </h2>
</section>
</div>
<section id="section-11">
      <h2 id="name-references">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-11.1">
        <h3 id="name-normative-references">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7924">[RFC7924]</dt>
        <dd>
<span class="refAuthor">Santesson, S.</span> and <span class="refAuthor">H. Tschofenig</span>, <span class="refTitle">"Transport Layer Security (TLS) Cached Information Extension"</span>, <span class="seriesInfo">RFC 7924</span>, <span class="seriesInfo">DOI 10.17487/RFC7924</span>, <time datetime="2016-07" class="refDate">July 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7924">https://www.rfc-editor.org/info/rfc7924</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8446">[RFC8446]</dt>
      <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08" class="refDate">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-11.2">
        <h3 id="name-informative-references">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="I-D.mglt-lurk-lurk">[I-D.mglt-lurk-lurk]</dt>
        <dd>
<span class="refAuthor">Migault, D.</span>, <span class="refTitle">"LURK Protocol version 1"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-mglt-lurk-lurk-00</span>, <time datetime="2018-02-09" class="refDate">9 February 2018</time>, <span>&lt;<a href="https://www.ietf.org/archive/id/draft-mglt-lurk-lurk-00.txt">https://www.ietf.org/archive/id/draft-mglt-lurk-lurk-00.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.mglt-lurk-tls12">[I-D.mglt-lurk-tls12]</dt>
      <dd>
<span class="refAuthor">Migault, D.</span> and <span class="refAuthor">I. Boureanu</span>, <span class="refTitle">"LURK Extension version 1 for (D)TLS 1.2 Authentication"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-mglt-lurk-tls12-04</span>, <time datetime="2021-01-25" class="refDate">25 January 2021</time>, <span>&lt;<a href="https://www.ietf.org/internet-drafts/draft-mglt-lurk-tls12-04.txt">https://www.ietf.org/internet-drafts/draft-mglt-lurk-tls12-04.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="annex">
<section id="appendix-A">
      <h2 id="name-annex">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-annex" class="section-name selfRef">Annex</a>
      </h2>
<div id="sec_ex_srv_ecdhe">
<section id="appendix-A.1">
        <h3 id="name-tls-server-ecdhe-no-session">
<a href="#appendix-A.1" class="section-number selfRef">A.1. </a><a href="#name-tls-server-ecdhe-no-session" class="section-name selfRef">TLS server ECDHE  (no session resumption)</a>
        </h3>
<p id="appendix-A.1-1">This section illustrates the most common exchange of a TLS client authenticates a TLS server with it certificate (ECDHE) without session resumption.<a href="#appendix-A.1-1" class="pilcrow">¶</a></p>
<p id="appendix-A.1-2">The TLS handshake is depicted below from {!RFC8446}}. 
For clarity as ECDHE authentication is performed, PSK related extensions ( psk_key_exchange_modes, pre_shared_key ) have been omitted.
In addition, as the TLS client is not authenticated,  CertificateRequest sent by the TLS server as well as Certificate and CertificateVerify sent by the TLS client have been removed.<a href="#appendix-A.1-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.1-3">
<pre>
TLS client                                   TLS Server

  Key  ^ ClientHello
  Exch | + key_share
       v + signature_algorithms ---------&gt;
                                           ServerHello  ^ Key
                                           + key_share  v Exch
                                 {EncryptedExtensions}    Server Params
                                         {Certificate}  ^
                                   {CertificateVerify}  | Auth
                                            {Finished}  v
                        &lt;--------  [Application Data*]
    {Finished}              --------&gt;
    [Application Data]      &lt;-------&gt;  [Application Data]
</pre><a href="#appendix-A.1-3" class="pilcrow">¶</a>
</div>
<p id="appendix-A.1-4">The TLS server interacts with the CS with a s_init_cert_verify exchange in order to respond to the ClientHello.<a href="#appendix-A.1-4" class="pilcrow">¶</a></p>
<p id="appendix-A.1-5">Since there is no session resumption, the request indicates with the tag set to last_exchange that no subsequent messages are expected. 
As a result, no session_id is provided. 
The freshness function is set to sha256, the handshake is constituted with the appropriated messages with a modified server_random to provide PFS. The Certificate message is also omitted from the handshake and is instead provided in the certificate structure using a finger_print. 
The requested secrets are handshake and application secrets, that is h_s, h_c, a_s, and a_c. The signature scheme is ed25519.
With authentication based on certificates, there are two ways to generate the shared secrets that is used as an input to the derive the secrets.
The ECDHE private key and shared secret may be generated by the CS as described in {sec:ex:srv:cs_generated}. 
On the other hand the ECDHE private key and shared secret may be generated by the TLS server as described in {tls_server_generated}<a href="#appendix-A.1-5" class="pilcrow">¶</a></p>
<div id="sec_ex_srv_cs_generated">
<section id="appendix-A.1.1">
          <h4 id="name-ecdhe-generated-on-the-cs">
<a href="#appendix-A.1.1" class="section-number selfRef">A.1.1. </a><a href="#name-ecdhe-generated-on-the-cs" class="section-name selfRef">ecdhe generated on the CS</a>
          </h4>
<p id="appendix-A.1.1-1">When the (EC)DHE private key and shared secrets are generated by the CS, the LURK client set the ephemeral_method to secret_generated.
The (EC)DHE group x25519 is specified in the handshake in the key_share extension. 
In return the CS provides the LURK client the public key so the TLS server can send the ServerHello to the TLS client.<a href="#appendix-A.1.1-1" class="pilcrow">¶</a></p>
<p id="appendix-A.1.1-2">In this scenario, the CS is the only entity that knows the private ECDHE key and the shared secret, and only the CS is able to compute the secrets.
The CS indicates the exchange is final by setting the tag to last_message, returns the x25519 public key that will be included in the ServerHello key_share extension, the signature sig that will be returned in the CertificateVerify message as well as the secrets that will be used to derive the appropriated keys.<a href="#appendix-A.1.1-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.1.1-3">
<pre>
TLS server
LURK client                              Cryptographic Service
  SInitCertVerifyRequest
    tag=last_exchange        --------&gt;
    freshness = sha256
    ephemeral
      ephemeral_method = secret_generated
    handshake = handshake (x25519)
    certificate = finger_print
    secret_request = h_s, h_c, a_s, and a_c
    sig_algo = ed25519
                                   SInitCertVerifyResponse
                                     tag=last_exchange
                                     ephemeral
                                       key
                                         group = x25519,
                                         key_exchange = public_key
                                     secret_list
                                     signature = sig
                             &lt;---------
</pre><a href="#appendix-A.1.1-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_ex_srv_tls_server_generated">
<section id="appendix-A.1.2">
          <h4 id="name-ecdhe-generated-by-the-tls-">
<a href="#appendix-A.1.2" class="section-number selfRef">A.1.2. </a><a href="#name-ecdhe-generated-by-the-tls-" class="section-name selfRef">ecdhe generated by the TLS server</a>
          </h4>
<p id="appendix-A.1.2-1">When the (EC)DHE private keys and the shared secrets are generated by the TLS server, the LURK client provides the shared secret to the CS as only the shared secret is necessary to generated the signature. 
This is indicated by the ephemeral_method set to secret_provided.
No (EC)DHE values are returned by the CS as these have already been generated by the TLS server. 
However, the TLS server has all the necessary material to generate the secrets and the only information that the CS owns and that is not known to et TLS server is the private key (associated to the certificate) used to generate the signature. 
This means that is session resumption were allowed, since it is based on PSK authentication derived from the resumption secret, these sessions could be authenticated by the TLS server without any implication from the CS.<a href="#appendix-A.1.2-1" class="pilcrow">¶</a></p>
<p id="appendix-A.1.2-2">In this scenario, the CS is the only entity that knows the private ECDHE key. 
Only the CS is able to generate the signature. 
Both the CS and the TLS server are able to compute all secrets. 
The CS indicates the exchange is final by setting the tag to last_message, returns the signature sig that will be returned in the CertificateVerify message as well as - when requested - the secrets that will be used to derive the appropriated keys.<a href="#appendix-A.1.2-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.1.2-3">
<pre>
TLS server
LURK client                              Cryptographic Service
  SInitCertVerifyRequest
    tag.last_exchange=True   --------&gt;
    freshness = sha256
    ephemeral
      ephemeral_method = secret_provided
      key
        group = x25519
        shared_secret = shared_secret
    handshake = handshake
    certificate = finger_print
    secret_request = h_s, h_c, a_s, and a_c
    sig_algo = ed25519
                                   SInitCertVerifyResponse
                                     tag.last_exchange=True
                                     secret_list
                                     signature = sig
                                   &lt;---------
</pre><a href="#appendix-A.1.2-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="sec_ex_srv_ecdhe_s">
<section id="appendix-A.2">
        <h3 id="name-tls-server-ecdhe-with-sessi">
<a href="#appendix-A.2" class="section-number selfRef">A.2. </a><a href="#name-tls-server-ecdhe-with-sessi" class="section-name selfRef">TLS server ECDHE ( with session resumption )</a>
        </h3>
<p id="appendix-A.2-1">When the TLS client is enabling session resumption, the TLS server is expected to generate some tickets that will be later used for later sessions. 
The generation of the tickets is based on the resumption_master_secret. 
To ensure protection of the authentication credential used for the session resumption, the CS necessarily must have generated the (EC)DHE keys and must not have provided the resumption_master_secret. 
In either other cases, the TLS client is able to compute the resumption_master_secret and so session resumption is out of control of the CS.
As a result, the CS sort of achieves a delegation to the TLS server.<a href="#appendix-A.2-1" class="pilcrow">¶</a></p>
<p id="appendix-A.2-2">In the remaining of this section, we consider the session resumption is performed by the CS.<a href="#appendix-A.2-2" class="pilcrow">¶</a></p>
<p id="appendix-A.2-3">ECDHE authentication is performed with the CS generating the private part of the (EC)DHE as described in {sec:ex:srv:cs_generated}. 
However, additional s_new_ticket exchanges are needed so the TLS server provides sufficient material to generate the tickets by the CS and retrieves the generated tickets by the CS. 
As result, the main difference with the scenario described in {sec:ex:srv:cs_generated} is that tag carries a session_id to identify the session between the TLS server and the CS.<a href="#appendix-A.2-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.2-4">
<pre>
TLS server
LURK client                              Cryptographic Service
  SInitCertVerifyRequest
    tag.last_exchange=False
    session_id = session_id_tls_server    --------&gt;
    freshness = sha256
    ephemeral
      ephemeral_method = secret_generated
    handshake = handshake (x25519)
    certificate = finger_print
    secret_request = h_s, h_c, a_s, a_c
    sig_algo = ed25519
                                   SInitCertVerifyResponse
                                     tag.last_exchange=False
                                     session_id = session_id_cs
                                     ephemeral
                                       key
                                         group = x25519,
                                         key_exchange = public_key
                                     secret_list
                                     signature = sig
                             &lt;---------
</pre><a href="#appendix-A.2-4" class="pilcrow">¶</a>
</div>
<p id="appendix-A.2-5">To enable session resumption, the TLS server needs to send NewSessionTickets to the TLS client. 
This exchange is taken from <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> and represented below:
~~~
TLS client                                   TLS Server
                          &lt;-----      [NewSessionTicket]
~~~<a href="#appendix-A.2-5" class="pilcrow">¶</a></p>
<p id="appendix-A.2-6">The TLS server requests NewSessionTicket to the CS by sending a SNewTicketRequest. 
The tag.last_exchange set to False indicates to the CS the TLS server is willing to request NewSessionTickets multiple times. 
The session_id is set to the value provided previously by the CS. 
This session_id will be used to associate the SNewTicketRequest to the specific context of teh TLS handshake.
handshake is the remaining handshake necessary to generate the secrets. In some cases, when the TLS client is authenticated, the TLS handshake contains a Certificate message that is carried in the certificate structure as opposed as to the handshake structure.
In our current case, the TLS client is not authenticated, so the certificate_type is set to 'empty'. 
ticket_nbr is an indication of the number of requested NewSessionTicket, and secret_list indicates the requested secrets.
In our case the resumption_master_secret (r) will remain in the CS and will be anyway ignored by the CS, so the secret_request has its r bit unset.<a href="#appendix-A.2-6" class="pilcrow">¶</a></p>
<p id="appendix-A.2-7">As depicted below, the CS provides a list of tickets that could be later used in order to authenticate the TLS server using PSK or PSK-ECDHE authentication as describe din {sec:ex:srv:server-psk}.<a href="#appendix-A.2-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.2-8">
<pre>
TLS server
LURK client                              Cryptographic Service
  SNewTicketRequest
    tag.last_exchange=False
    session_id = session_id_cs
    handshake = client Finished
    certificate
      certificate_type = empty
    ticket_nbr
    secret_request  --------&gt;
                                   SNewTicketResponse
                                     tag.last_exchange=False
                                     session_id = session_id_tls_server
                                     secret_list
                        &lt;---------   ticket_list
</pre><a href="#appendix-A.2-8" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_ex_srv_server-psk">
<section id="appendix-A.3">
        <h3 id="name-tls-server-psk-psk-ecdhe">
<a href="#appendix-A.3" class="section-number selfRef">A.3. </a><a href="#name-tls-server-psk-psk-ecdhe" class="section-name selfRef">TLS server  PSK / PSK-ECDHE</a>
        </h3>
<p id="appendix-A.3-1">PSK/PSK-ECDHE authentication is the method used for session resumption but can also be used outside the scope of session resumption.
In both cases, the PSK is hosted by the CS.<a href="#appendix-A.3-1" class="pilcrow">¶</a></p>
<p id="appendix-A.3-2">The PSK authentication can be illustrated by the exchange below:<a href="#appendix-A.3-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.3-3">
<pre>
TLS client                                   TLS Server
  ClientHello
  + key_share
  + psk_key_exchange_mode
  + pre_shared_key          --------&gt;
                                                  ServerHello
                                             + pre_shared_key
                                                 + key_share
                                        {EncryptedExtensions}
                                                   {Finished}
                            &lt;--------     [Application Data*]
</pre><a href="#appendix-A.3-3" class="pilcrow">¶</a>
</div>
<p id="appendix-A.3-4">The TLS client may propose to the TLS server multiple PSKs.<a href="#appendix-A.3-4" class="pilcrow">¶</a></p>
<p id="appendix-A.3-5">Each of these PSKs is associated a PskBindersEntry defined in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> section 4.2.11.2. 
PskBindersEntry is computed similarly to the Finished message using the binder_key and the partial ClientHello. 
The TLS server is expected to pick a single PSK and validate the binder.
In case the binder does not validate the TLS Handshake is aborted. 
As a result, only one binder_key is expected to be requested by the TLS server as opposed to the TLS client. 
In this example we assume the psk_key_exchange_mode indicated by the TLS client supports PSK-ECDHE as well as PSK authentication. 
The presence of a pre_shared_key and a key_share extension in the ServerHello indicates that PSK-ECDHE has been selected.<a href="#appendix-A.3-5" class="pilcrow">¶</a></p>
<p id="appendix-A.3-6">While the TLS handshake is performed in one round trip, the TLS server and the CS have 2 LURK exchanges.
These exchanges are consecutive and performed in the scope of a LURK session. 
A first exchange (s_init_early_secret) validates the ClientHello receives by the TLS server and existence of the selected PSK (by the TLS server) is actually hosted by the CS.
Once the s_init_early_secret exchange succeeds, the TLS server starts building the ServerHello and requests the necessary parameters derived by the CS to complete the ServerHello with a second exchange (s_init_hand_and_apps).<a href="#appendix-A.3-6" class="pilcrow">¶</a></p>
<p id="appendix-A.3-7">The TLS server is expected to select a PSK, check the associated binder and proceed further. 
If the binder fails, it is not expected to proceed to another PSK, as a result, the TLS server is expected to initiates a single LURK session.<a href="#appendix-A.3-7" class="pilcrow">¶</a></p>
<p id="appendix-A.3-8">The SInitEarlySecretRequest structure provides the session_id that will be used later by the TLS server to identify the session with future inbound responses from the CS (session_id_server). 
The freshness function (sha256) is used to implement PFS together with the ClientHello.random. 
selected_identity indicates the PSK chosen by the TLS server among those proposed by the TLS client in its ClientHello.
The secrets requested by the TLS server are indicated in secret_request.
This example shows only the binder_key, but other early secrets may be requests as well.<a href="#appendix-A.3-8" class="pilcrow">¶</a></p>
<p id="appendix-A.3-9">The CS responds with a SInitEarlySecretResponse that contains the session_id_cs used later to identify the incoming packets associated to the LURK session and the binder_key.<a href="#appendix-A.3-9" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.3-10">
<pre>
TLS server
LURK client                              Cryptographic Service
  SInitEarlySecretRequest ----------&gt;
    session_id = session_id_tls_server
    freshness = sha256
    selected_identity = 0
    handshake = ClientHello
    secret_request = b
                                   SInitEarlySecretResponse
                                     session_id = session_id_cs
                          &lt;--------- secret_list = binder_key
</pre><a href="#appendix-A.3-10" class="pilcrow">¶</a>
</div>
<p id="appendix-A.3-11">To complete to the ServerHello exchange, the TLS server needs the handshake and application secrets. 
These secrets are requested via an s_hand_and_app_secret LURK exchange.<a href="#appendix-A.3-11" class="pilcrow">¶</a></p>
<p id="appendix-A.3-12">The SHandAndAppSecretRequest structure carries a tag with its last_exchange set to False to indicate the willingness of the TLS server to keep the session open and proceed to further LURK exchanges. 
In our case, this could mean the TLS server expects to request additional tickets. 
The session_id is set to session_id_cs, the value provided by the CS. 
ephemeral is in our case set the ephemeral_method to secret_generated as described in  <a href="#sec_ex_srv_ecdhe" class="xref">Appendix A.1</a>.
The method (x25519) to generate the (EC)DHE is indicated in the handshake. 
The necessary handshake to derive the handshake and application secrets, as well the requested secrets are indicated in the secret_request structure.<a href="#appendix-A.3-12" class="pilcrow">¶</a></p>
<p id="appendix-A.3-13">The CS sets its tag.last_exchange to True to indicate the session will be closed after this exchange. 
This also means that no ticket will be provided by the CS. 
The CS returns the (EC)DHE public key as well as requested secrets in a SHandAndAppResponse structure similarly to what is being described in {sec:ex:srv:ecdhe}.<a href="#appendix-A.3-13" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.3-14">
<pre>
TLS server
LURK client                              Cryptographic Service
  SHandshakeAndAppRequest
    tag.last_exchange = False
    session_id = session_id_cs
    ephemeral
      ephemeral_method = secret_generated
    handshake = ServerHello(x25519) ... EncryptedExtensions
    secret_request = h_c, h_s, a_c, a_s -------&gt;
                                   SHandAndAppResponse
                                     tag.last_exchange = True
                                     session_id = session_id_tls_server
                                     ephemeral
                                       key
                                         group = x25519,
                                         key_exchange = public_key
                          &lt;--------- secret_list
</pre><a href="#appendix-A.3-14" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_ex_clt_unauth_ecdhe">
<section id="appendix-A.4">
        <h3 id="name-tls-client-unauthenticated-">
<a href="#appendix-A.4" class="section-number selfRef">A.4. </a><a href="#name-tls-client-unauthenticated-" class="section-name selfRef">TLS client unauthenticated ECDHE</a>
        </h3>
<p id="appendix-A.4-1">This section details the case where a TLS client establishes a TLS session authenticating the TLS server using ECDHE. 
The TLS client interacts with the CS in order to generate the (EC)DHE private part. 
While this section does not illustrates session resumption, the TLS client is configured to proceed to session resumption which will be described with further details in <a href="#sec_ex_clt_unauth_psk" class="xref">Appendix A.5</a>.<a href="#appendix-A.4-1" class="pilcrow">¶</a></p>
<p id="appendix-A.4-2">The TLS handshake described in <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span> is depicted below. 
In this example, the TLS client proposes a key_share extension to agree on a (EC)DHE shared secret, but does not propose any PSK.<a href="#appendix-A.4-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.4-3">
<pre>
TLS client                                   TLS Server

  Key  ^ ClientHello
  Exch | + key_share
       v + signature_algorithms ---------&gt;
                                           ServerHello  ^ Key
                                           + key_share  v Exch
                                 {EncryptedExtensions}    Server Params
                                         {Certificate}  ^
                                   {CertificateVerify}  | Auth
                                            {Finished}  v
                        &lt;--------  [Application Data*]
    {Finished}              --------&gt;
    [Application Data]      &lt;-------&gt;  [Application Data]
</pre><a href="#appendix-A.4-3" class="pilcrow">¶</a>
</div>
<p id="appendix-A.4-4">If the TLS client generates the (EC)DHE private key, no interaction with the CS is needed as it will have the default PSK value as well as the (EC)DHE shared secrets necessary to proceed to the key schedule described in section 7.1 of <span>[<a href="#RFC8446" class="xref">RFC8446</a>]</span>.<a href="#appendix-A.4-4" class="pilcrow">¶</a></p>
<p id="appendix-A.4-5">In this example, the TLS client requests the CS via a c_init_client_hello to generate the (EC)DHE private key and provide back the public part that will be placed into the key_share extension before being sent to the TLS server.<a href="#appendix-A.4-5" class="pilcrow">¶</a></p>
<p id="appendix-A.4-6">Like in any init methods, the TLS client indicates with session_id_tls_client the idnetifier of the session that is being assigned by the TLS client for future inbound LURK message responses sent by the CS. 
Similarly, the CS advertises its session_id_cs. 
freshness is set to sha256, and the ClientHello.random is generated as described in <a href="#sec_freshness" class="xref">Section 5.4</a>. 
handshake contains the ClientHello message to which the key_exchange of the KeyShareentries has been stripped off without changing the other fields. 
As PSK are not involved, no early secrets are involved and c_psk_list and secret_request are empty.<a href="#appendix-A.4-6" class="pilcrow">¶</a></p>
<p id="appendix-A.4-7">The CS provides the KeyShareEntries. 
The TLS client is able to build the ClientHello to the TLS server with ClientHello.random and by placing the KeyShareEntries.<a href="#appendix-A.4-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.4-8">
<pre>
TLS client
LURK client                              Cryptographic Service
  CInitClientHello
    session_id = session_id_tls_client
    freshness = sha256
    ephemeral
      ephemeral_method = secret_generated
    handshake = ClientHello(x25519, x488, ... )
    c_psk_id_list = []
    secret_request = []    ------&gt;
                                   CInitClientHello
                                     session_id=session_id_cs
                                     ephemeral_list
                                       key
                                         group = x25519,
                                         key_exchange = public_key
                                       ephemeral_method = secret_generated
                                       key
                                         group = x488,
                                         key_exchange = public_key
                                     secret_list=[]
</pre><a href="#appendix-A.4-8" class="pilcrow">¶</a>
</div>
<p id="appendix-A.4-9">Upon receiving the response from the TLS server, responds with a ServerHello followed by additional encrypted messages.<a href="#appendix-A.4-9" class="pilcrow">¶</a></p>
<p id="appendix-A.4-10">The TLS client needs the handshake secrets to decrypt these encrypted messages and send back the client Finished message.
In addition, the TLS client requests the application secrets to encrypt and decrypt the TLS session.
The secrets are requested via a c_hand_and_app_secret.<a href="#appendix-A.4-10" class="pilcrow">¶</a></p>
<p id="appendix-A.4-11">We assume the TLS client supports session resumption so, the tag.last_message is unset.
The session_id takes the value advertises by each party during the previous c_init_client_hello exchange. 
Since the CS already has the (EC)DHE private keys, it will be able to derive the (EC)DHE shared secret and no information needs to be provided by the TLS client. 
As a result, ephemeral_method is set to no_secret. 
The handshake is composed of the messages sent by the TLS server.
As the TLS client does not have yet the messages are not decrypted, and are provided encrypted. 
The requested secrets are the handshake and application secrets.<a href="#appendix-A.4-11" class="pilcrow">¶</a></p>
<p id="appendix-A.4-12">The CS generates the handshake secrets and the associated key to decrypt the encrypted messages. 
As no CertificateRequest has been found, the CS does not compute the signature that would authenticate the TLS client. 
In this section, we assume the CS is ready to accept further exchanges, and in our case the c_register_tickets exchange to enable session resumption. 
Since session resumption is enabled, the CS computes the Finished message to generate the resumption_master_secret.<a href="#appendix-A.4-12" class="pilcrow">¶</a></p>
<p id="appendix-A.4-13">The CS returns the response by unsetting the tag.last_message and cert_request. 
The ephemeral is an empty list and secret_request returns the requested secrets.<a href="#appendix-A.4-13" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.4-14">
<pre>
TLS client
LURK client                              Cryptographic Service
  CHandAndAppSecretRequest
    tag.last_message=False
    session_id=session_id_cs
    ephemeral
      ephemeral_method = no_secret
    handshake = ServerHello, {EncryptedExtensions}...,{Finished}.
    secret_request = h_c, h_s, a_c, a_s -------&gt;
                                   CHandAndAppSecretResponse
                                     tag
                                       last_message=False
                                        cert_request=False
                                     session_id=session_id_tls_clt
                                     ephemeral_list = []
                                     secret_request = h_s, h_c, a_s, and a_c
</pre><a href="#appendix-A.4-14" class="pilcrow">¶</a>
</div>
<p id="appendix-A.4-15">Upon reception of the response, the TLS client generates the necessary keys to decrypt and encrypt the handshake message and terminates the TLS handshake. 
The TLS client is also able to decrypt and encrypt application traffic.<a href="#appendix-A.4-15" class="pilcrow">¶</a></p>
<p id="appendix-A.4-16">In this section, we assume that after some time, the TLS client receives a NewSessionTicket from the TLS server. 
The TLS client will then transmit the NewSessionTicket to the CS so that it can generate the associated PSK that will be used for the authentication.<a href="#appendix-A.4-16" class="pilcrow">¶</a></p>
<p id="appendix-A.4-17">As multiple NewSessionTickets may be sent, in this example, both TLS client and CS enable further additional registrations by unsetting tag.last_message.
For each registered NewSessionTicket, the CS returns c_spk_id that will use for further references. 
The c_spk_ids are managed by the CS which can ensure the uniqueness of these references as opposed to using the ticket field that is assigned by the TLS server.<a href="#appendix-A.4-17" class="pilcrow">¶</a></p>
<p id="appendix-A.4-18"><a href="#sec_ex_clt_unauth_psk" class="xref">Appendix A.5</a> illustrates how session resumption is performed using PSK / PSK-ECDHE authentication.<a href="#appendix-A.4-18" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.4-19">
<pre>
TLS client
LURK client                              Cryptographic Service
  RegisterTicketsRequest
    tag.last_message=False
    session_id=session_id_cs
    ticket_list = [NewSessionTicket]
                ----------------&gt;
                                   RegisterTicketsResponse
                                     last_message=False
                                     session_id=session_id_tls_clt
                           &lt;-------- c_spk_id_list = [nst_id]
</pre><a href="#appendix-A.4-19" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_ex_clt_unauth_psk">
<section id="appendix-A.5">
        <h3 id="name-tls-client-unauthenticated-p">
<a href="#appendix-A.5" class="section-number selfRef">A.5. </a><a href="#name-tls-client-unauthenticated-p" class="section-name selfRef">TLS client unauthenticated PSK / PSK-ECDHE</a>
        </h3>
<p id="appendix-A.5-1">This section describes the intercation between a TLS client and a CS for a PSK-ECDHE TLS handshake. 
<a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a> shows how the PSK may be provisioned during a ECDHE TLS handshake. 
The scenario described in this section presents a number of similarities to the one described in <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a>. 
As such, we expect the reader to be familiar with <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a> and will highlight the differences with <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a> to avoid to repeat the description.<a href="#appendix-A.5-1" class="pilcrow">¶</a></p>
<p id="appendix-A.5-2">In this section, the PSK is protected by the CS, but the (EC)DHE private keys are generated by the TLS client and as such are considered as unprotected. 
As the (EC)DHE secret are generated by the TLS client, the ephemeral_method is set to no_secret, and the key_share extension is fully provided in the ClientHello.
However, the ClientHello do not carry the PreSharedKeyExtension. 
Instead, this extension is built from the NewSessionTicket identifier nst_id provided in our case from a previous c_register_ticktes exchange (see <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a> }. 
The TLS client requests the binder_key associated to nst_id in order to be able to complete the binders.<a href="#appendix-A.5-2" class="pilcrow">¶</a></p>
<p id="appendix-A.5-3">Upon receiving the message, the CS, computes the binder_keys, complete the ClientHello in order to synchronize its TLS handshake with the TLS client (and the TLS server). 
As the CS does not generate any (EC)DHE, the ephemeral_list is empty.<a href="#appendix-A.5-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.5-4">
<pre>
TLS client
LURK client                              Cryptographic Service
  CInitClientHello
    session_id = session_id_tls_client
    freshness = sha256
    ephemeral
      ephemeral_method = no_secret
    handshake = ClientHello without PreSharedKeyExtension
    c_psk_id_list = [nst_id]
    secret_request = [b]    ------&gt;
                                   CInitClientHello
                                     session_id=session_id_cs
                                     ephemeral_list = []
                                     secret_list=[binder_key]
</pre><a href="#appendix-A.5-4" class="pilcrow">¶</a>
</div>
<p id="appendix-A.5-5">When the TLS client receives the responses from the TLS server, the handshake and application secrets are requested with a c_hand_and_app similarly to <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a>. 
The only difference here is that (EC)DHE have been generated by the TLS client and the shared secret needs to be provided to the CS as described below:<a href="#appendix-A.5-5" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.5-6">
<pre>
TLS client
LURK client                              Cryptographic Service
  CHandAndAppSecretRequest
    tag.last_message=False
    session_id=session_id_cs
    ephemeral
      ephemeral_method = secret_provided
      shared_secret
    handshake = ServerHello, {EncryptedExtensions}...,{Finished}.
    secret_request = h_c, h_s, a_c, a_s -------&gt;
                                   CHandAndAppSecretResponse
                                     tag
                                       last_message=False
                                        cert_request=False
                                     session_id=session_id_tls_clt
                                     ephemeral_list = []
                                     secret_request = h_s, h_c, a_s, and a_c
</pre><a href="#appendix-A.5-6" class="pilcrow">¶</a>
</div>
<p id="appendix-A.5-7">Upon receiving the response, the TLS client proceeds similarly to the TLS client described in <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a>.<a href="#appendix-A.5-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_ex_clt_auth_ecdhe">
<section id="appendix-A.6">
        <h3 id="name-tls-client-authenticated-ec">
<a href="#appendix-A.6" class="section-number selfRef">A.6. </a><a href="#name-tls-client-authenticated-ec" class="section-name selfRef">TLS client authenticated ECDHE</a>
        </h3>
<p id="appendix-A.6-1">This section provides scenarios when the TLS client is authenticated during the TLS handshake. 
Post handshake authentication is detailed in <a href="#sec_ex_clt_auth_post" class="xref">Appendix A.7</a><a href="#appendix-A.6-1" class="pilcrow">¶</a></p>
<div id="ecdhe-or-proposed-psk-protected-by-the-cs">
<section id="appendix-A.6.1">
          <h4 id="name-ecdhe-or-proposed-psk-prote">
<a href="#appendix-A.6.1" class="section-number selfRef">A.6.1. </a><a href="#name-ecdhe-or-proposed-psk-prote" class="section-name selfRef">(EC)DHE or Proposed PSK protected by the CS</a>
          </h4>
<p id="appendix-A.6.1-1">When the (EC)DHE part have been generated by the CS, or the proposed PSK are protected by the CS, the TLS client sends a ClientHello after a c_client_hello exchange with the CS (see <a href="#sec_ex_clt_unauth_psk" class="xref">Appendix A.5</a> or <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a>). 
The request for TLS client authentication is indicated by a encrypted CertificateRequest sent by the TLS server as indicated below:<a href="#appendix-A.6.1-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.6.1-2">
<pre>
TLS client                                   TLS Server

  Key  ^ ClientHello
  Exch | + key_share
       v + signature_algorithms ---------&gt;
                                           ServerHello  ^ Key
                                           + key_share  v Exch
                                 {EncryptedExtensions}  ^ Server Params
                                 {CertificateRequest}   v
                                         {Certificate}  ^
                                   {CertificateVerify}  | Auth
                                            {Finished}  v
                        &lt;--------  [Application Data*]
       ^ {Certificate}
  Auth | {CertificateVErify}
       v {Finished}              --------&gt;
         [Application Data]      &lt;-------&gt;  [Application Data]
</pre><a href="#appendix-A.6.1-2" class="pilcrow">¶</a>
</div>
<p id="appendix-A.6.1-3">The TLS client is unaware of the presence of the CertifcateRequest until it has decrypted the message with a key derived from the handshake secrets. 
As a result, the TLS client initiates a c_hand_an_app_secret exchange as described in <a href="#sec_ex_clt_unauth_psk" class="xref">Appendix A.5</a> or <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a>.<a href="#appendix-A.6.1-3" class="pilcrow">¶</a></p>
<p id="appendix-A.6.1-4">The CS proceeds as described in <a href="#sec_ex_clt_unauth_psk" class="xref">Appendix A.5</a> or <a href="#sec_ex_clt_unauth_ecdhe" class="xref">Appendix A.4</a>. 
However, after the messages have been decrypted, the CS proceeds to the generation of the signature and returns the necessary information to build the CertificateVerify. 
The CS indicates their presence by setting tag.cert_request and returns the certificate, the sig_algo and sig as described below:<a href="#appendix-A.6.1-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.6.1-5">
<pre>
TLS client
LURK client                              Cryptographic Service
  CHandAndAppSecretRequest
    tag.last_message=False
    session_id=session_id_cs
    ephemeral
      ephemeral_method = secret_provided
      shared_secret
    handshake = ServerHello, {EncryptedExtensions}...,{Finished}.
    secret_request = h_c, h_s, a_c, a_s -------&gt;
                                   CHandAndAppSecretResponse
                                     tag
                                       last_message=False
                                       cert_request=True
                                     session_id=session_id_tls_clt
                                     ephemeral_list = []
                                     secret_request = h_s, h_c, a_s, and a_c
                                     certificate
                                       certificate_type = finger_print
                                     sig_algo = ed25519
                                     sig
</pre><a href="#appendix-A.6.1-5" class="pilcrow">¶</a>
</div>
<p id="appendix-A.6.1-6">Note that in the example above, (EC)DHE have not been generated by the CS, but the c_client_hello was motivated to propose a protected PSK. 
As the PSK has not been agreed for authentication by the TLS server, the TLS session does not provide PFS and the protection is similar as the one described in {sec:ex:clt:auth:ecdhe-certverify}, where the TLS client would have proposed directly ECDHE with (EC)DHE generated by the TLS client.<a href="#appendix-A.6.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec_ex_clt_auth_ecdhe-certverify">
<section id="appendix-A.6.2">
          <h4 id="name-ecdhe-provided-by-the-tls-c">
<a href="#appendix-A.6.2" class="section-number selfRef">A.6.2. </a><a href="#name-ecdhe-provided-by-the-tls-c" class="section-name selfRef">(EC)DHE provided by the TLS client</a>
          </h4>
<p id="appendix-A.6.2-1">This section considers a TLS client that proposes to authenticate the TLS server using ECDHE with (EC)DHE private parts being generated by the TLS client.<a href="#appendix-A.6.2-1" class="pilcrow">¶</a></p>
<p id="appendix-A.6.2-2">The TLS client does not need to interact with CS to build its ClientHello. 
Similarly, as the (EC)DHE private part have been generated by the TLS client, the TLS client is able to perform the key schedule and derive the necessary keys to decrypt the encrypted response from the TLS server. 
Upon receiving a CertificateRequest, the TLS client requests the CS to generate the signature needed to send the CertificateVerify.
The exchange is very similar as the one s_init_cert_verify (see <a href="#sec_ex_srv_tls_server_generated" class="xref">Appendix A.1.2</a>). 
As the (EC)DHE shared secret is generated by the TLS client, the ephemeral_method is necessarily set to secret_provided. 
The handshake is set to the ClientHello ... server Finished, and the certificate carries the reference to the TLS client certificate, so the CS picks the appropriated private key. 
sig_algo designates the signature algorithm.<a href="#appendix-A.6.2-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.6.2-3">
<pre>
TLS server
LURK client                              Cryptographic Service
  CInitCertVerifyRequest
    tag.last_exchange=True   --------&gt;
    freshness = sha256
    ephemeral
      ephemeral_method = secret_provided
      key
        group = x25519
        shared_secret = shared_secret
    handshake = hanshake
    certificate
      certificate_type = finger_print
    sig_algo = ed25519
                                   CInitCertVerifyResponse
                                     tag.last_exchange=True
                                     signature = sig
                                   &lt;---------
</pre><a href="#appendix-A.6.2-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="sec_ex_clt_auth_post">
<section id="appendix-A.7">
        <h3 id="name-tls-client-authenticated-po">
<a href="#appendix-A.7" class="section-number selfRef">A.7. </a><a href="#name-tls-client-authenticated-po" class="section-name selfRef">TLS client authenticated - post handshake authentication</a>
        </h3>
<p id="appendix-A.7-1">Post handshake authentication may be requested at any time after the TLS handshake is completed as long as the TLS client has indicated its support with a post_handshake_authentication extension.<a href="#appendix-A.7-1" class="pilcrow">¶</a></p>
<p id="appendix-A.7-2">If the establishment of the TLS session did not required any interactions with the CS, post handshake authentication is performed with a c_init_post_hand_auth exchange as described in <a href="#sec_ex_clt_auth_init_post" class="xref">Appendix A.7.1</a>. 
When the TLS handshake already required some interactions with the CS the post handshake authentication is performed using a c_post_hand_auth described in {sec:ex:clt:auth:post_continued}.<a href="#appendix-A.7-2" class="pilcrow">¶</a></p>
<p id="appendix-A.7-3">In some cases, both c_init_post_hand_auth and c_post_hand_auth can be used. 
When this is possible, c_post_hand_auth is preferred as the handshake context is already being provisioned in the CS.
On the other hand, when the shared secret is only known to the CS, c_init_post_hand_auth cannot be used instead.<a href="#appendix-A.7-3" class="pilcrow">¶</a></p>
<div id="sec_ex_clt_auth_init_post">
<section id="appendix-A.7.1">
          <h4 id="name-initial-post-handshake-auth">
<a href="#appendix-A.7.1" class="section-number selfRef">A.7.1. </a><a href="#name-initial-post-handshake-auth" class="section-name selfRef">Initial Post Handshake Authentication</a>
          </h4>
<p id="appendix-A.7.1-1">This situation describes the case where the TLS client has performed the TLS handshake without interacting with the CS. 
As a result, if involved PSK, (EC)DHE shared secrets are unprotected and hosted by the TLS client. 
Upon receiving a CertificateRequest, the TLS client sends session_id and freshness to initiate the LURK session. 
tag.last_message is set in order to accept future post handshake authentication request. 
ephemeral_method is set to secret_provide as the CS is unable to generate the (EC)DHE shared secret. 
handshake is set to the full handshake including the just received CertificateRequest message. 
The certificate represents the TLS client certificate to determine the private key involved in computing the signature. 
sig_algo specifies the signature algorithm.<a href="#appendix-A.7.1-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.7.1-2">
<pre>
TLS server
LURK client                              Cryptographic Service
  CInitPostHandAuthRequest
    tag.last_message = False
    session_id = session_id_tls_client
    freshness = sha256
    ephemeral
      ephemeral_method = secret_provided
    handshake = ClientHello ... client Finished CertificateRequest
    certificate
      certificate_type = finger_print
     sig_algo   ----------------&gt;
                                   CInitPostHandAuthResponse
                                     tag.last_message = False
                                     session_id = session_id_cs
                   &lt;--------------   signature = sig

</pre><a href="#appendix-A.7.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec_ex_clt_auth_post_continued">
<section id="appendix-A.7.2">
          <h4 id="name-post-handshake-authenticati">
<a href="#appendix-A.7.2" class="section-number selfRef">A.7.2. </a><a href="#name-post-handshake-authenticati" class="section-name selfRef">Post Handshake Authentication</a>
          </h4>
<p id="appendix-A.7.2-1">In this scenario, the post authentication is performed while a LURK session has already been set. 
Upon receiving the CertificateRequest, the TLS client proceeds similarly to the initial post handshake authentication as described in 
As a result, the exchange is illustrated below:<a href="#sec_ex_clt_auth_init_post" class="xref">Appendix A.7.1</a> except that the LURK session does not need to be initiated, the shared secret is already known to the CS and the handshake is only constituted of the remaining CertificateRequest message.<a href="#appendix-A.7.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="appendix-A.7.2-2">
<pre>
TLS server
LURK client                              Cryptographic Service
  CInitPostHandAuthRequest
    tag.last_message = False
    session_id = session_id_tls_client
    handshake = CertificateRequest
    certificate
      certificate_type = finger_print
     sig_algo   ----------------&gt;
                                   CInitPostHandAuthResponse
                                     tag.last_message = False
                                     session_id = session_id_cs
                   &lt;--------------   signature = sig

</pre><a href="#appendix-A.7.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-B">
      <h2 id="name-authors-address">
<a href="#name-authors-address" class="section-name selfRef">Author's Address</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Daniel Migault</span></div>
<div dir="auto" class="left"><span class="org">Ericsson</span></div>
<div dir="auto" class="left"><span class="street-address">8275 Trans Canada Route</span></div>
<div dir="auto" class="left">
<span class="locality">Saint Laurent, QC</span>  <span class="postal-code">4S 0B6</span>
</div>
<div dir="auto" class="left"><span class="country-name">Canada</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:daniel.migault@ericsson.com" class="email">daniel.migault@ericsson.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
