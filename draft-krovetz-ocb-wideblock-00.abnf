i == 2, then P_i refers to the variable P_2.

L_0 = double(L_$)
L_i = double(L_{i-1}) for every integer i > 0

A == A_1 || A_2 || ... || A_m || A_*, and
Sum_0 = zeros(BLOCKLEN)
Offset_0 = zeros(BLOCKLEN)
Offset_i = Offset_{i-1} xor L_{ntz(i)}
Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i)
Zerofill = zeros(BLOCKLEN-(1+bitlen(A_*)))
CipherInput = (A_* || 1 || Zerofill) xor Offset_*
Sum = Sum_m xor ENCIPHER(K, CipherInput)
Sum = Sum_m
L_0 = double(L_$)
L_i = double(L_{i-1}) for every integer i > 0

P == P_1 || P_2 || ... || P_m || P_*, and
Zerofill = zeros(BLOCKLEN-(TAGREP+1+bitlen(N)))
Nonce = num2str(TAGLEN mod BLOCKLEN, TAGREP) || Zerofill || 1 || N
bottom = str2num(Nonce[BLOCKLEN-MASKLEN+1..BLOCKLEN])
Ktop = ENCIPHER(K, Nonce[1..BLOCKLEN-MASKLEN] || zeros(MASKLEN))
ShiftedKtop = Ktop[1..BLOCKLEN-SHIFT] xor Ktop[1+SHIFT..BLOCKLEN]
Stretch = Ktop || ShiftedKtop
Offset_0 = Stretch[1+bottom..BLOCKLEN+bottom]
Checksum_0 = zeros(BLOCKLEN)
Offset_i = Offset_{i-1} xor L_{ntz(i)}
C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i)
Checksum_i = Checksum_{i-1} xor P_i
Pad = ENCIPHER(K, Offset_*)
PaddedP = P_* || 1 || zeros(BLOCKLEN-(bitlen(P_*)+1))
Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)
Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A)
C = C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN]

L_0 = double(L_$)
L_i = double(L_{i-1}) for every integer i > 0

C == C_1 || C_2 || ... || C_m || C_* || T,
Zerofill = zeros(BLOCKLEN-(TAGREP+1+bitlen(N)))
Nonce = num2str(TAGLEN mod BLOCKLEN, TAGREP) || Zerofill || 1 || N
bottom = str2num(Nonce[BLOCKLEN-MASKLEN+1..BLOCKLEN])
Ktop = ENCIPHER(K, Nonce[1..BLOCKLEN-MASKLEN] || zeros(MASKLEN))
ShiftedKtop = Ktop[1..BLOCKLEN-SHIFT] xor Ktop[1+SHIFT..BLOCKLEN]
Stretch = Ktop || ShiftedKtop
Offset_0 = Stretch[1+bottom..BLOCKLEN+bottom]
Checksum_0 = zeros(BLOCKLEN)

Offset_i = Offset_{i-1} xor L_{ntz(i)}
P_i = Offset_i xor DECIPHER(K, C_i xor Offset_i)
Checksum_i = Checksum_{i-1} xor P_i
Pad = ENCIPHER(K, Offset_*)
PaddedP = P_* || 1 || zeros(BLOCKLEN-bitlen(P_*)-1)
Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)
Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A)
P = P_1 || P_2 || ... || P_m || P_*
P = INVALID
K = 000102030405060708090A0B0C0D0E0F
C = <empty string>
S = (0x00 || 0x01 || 0x02 || ...)[1..8i]
N = num2str(3i+1,16)
C = C || OCB-ENCRYPT(K,N,S,S)
N = num2str(3i+2,16)
C = C || OCB-ENCRYPT(K,N,<empty string>,S)
N = num2str(3i+3,16)
C = C || OCB-ENCRYPT(K,N,S,<empty string>)
N = num2str(385,16)
Y = OCB-ENCRYPT(K,N,C,<empty string>)

domsize = [0]    # domsize[i] will contain domain size of shift i

I_rows = [[j == i for j in range(w)] for i in range(w)]
J_rows = [[j == i or j == i + c for j in range(w)]
                                         for i in range(w)]
IJ = matrix(GF(2), I_rows + J_rows)
A = [IJ[i:i + w, 0:w] for i in range(w)]

i = 0         # increase i until not full-rank
dom = w       # Set dom=i ends loop & sets dom to domain size
j = 0
j = j + 1
i = i + 1
domain_bits = floor(log(max(domsize), 2))
candidates = (k for i in range(8)
                      for j in range(floor(log(w, 2)),2,-1)
                      for k in range(i,w,2**j)
                      if domsize[k] >= 2**domain_bits)

