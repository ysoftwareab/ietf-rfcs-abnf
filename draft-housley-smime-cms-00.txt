





S/MIME Working Group                                         R. Housley
Internet Draft                                                   SPYRUS
expires in six months                                      October 1997


                      Cryptographic Message Syntax

                    <draft-housley-smime-cms-00.txt>


Status of this Memo

   This document is an Internet-Draft.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."

   To learn the current status of any Internet-Draft, please check the
   "1id-abstracts.txt" listing contained in the Internet- Drafts Shadow
   Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),
   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or
   ftp.isi.edu (US West Coast).


Abstract

   This document describes the Cryptographic Message Syntax.  This
   syntax is used to digitally sign or encrypt arbitrary messages.

   The Cryptographic Message Syntax is deriveded from PKCS #7 version
   1.5.  Wherever possible, backward compatibility is preserved;
   however, changes were necessary to accomodate attribute certificate
   transfer and key agreement techniques for key management.

   Please send comments on this document to the ietf-smime@imc.com mail
   list.










Housley                                                         [Page 1]





INTERNET DRAFT                                              October 1997


1  Introduction

   This document describes the Cryptographic Message Syntax.  This
   syntax is used to digitally sign or encrypt arbitrary messages.

   The Cryptographic Message Syntax describes a general encapsulation
   syntax for data protection.  It supports digital signatures and
   encryption. The syntax allows multiple enapsulation, so one
   encapsulation envelope can be nested inside another.  Likewise, one
   party can digitally sign some previously encapsulated data. It also
   allows arbitrary attributes, such as signing time, to be
   authenticated along with the message content, and provides for other
   attributes such as countersignatures to be associated with a
   signature.

   The Cryptographic Message Syntax can support a variety of
   architectures for certificate-based key management, such as the one
   defined by the PKIX working group.

   The Cryptographic Message Syntax values are generated using ASN.1,
   using BER-encoding.  Values are typically represented as octet
   strings. While many systems are capable of transmitting arbitrary
   octet strings reliably, it is well known that many electronic-mail
   systems are not. This document does not address mechanisms for
   encoding octet strings for reliable transmission in such
   environments.

2  General Overview

   The Cryptographic Message Syntax is general enough to support many
   different content types. This document defines three: data, signed
   data, and enveloped data. Other content types may be added in the
   future, and additional content types can be defined outside this
   document.

   The Cryptographic Message Syntax exports one content type,
   ContentInfo, as well as the various object identifiers.

   As a general design philosophy, content types permit single pass
   processing using indefinite-length Basic Encoding Rules (BER)
   encoding. Single-pass operation is especially helpful if content is
   large, stored on tapes, or is "piped" from another process. Single-
   pass operation has one significant drawback; it is difficult to
   perform encode operations using the Distinguished Encoding Rules
   (DER) encoding in a single pass since the lengths of the various
   components may not be known in advance. Since DER encoding is
   required by the signed-data content type, an extra pass may be
   necessary when a content type other than data is encapsulated.



Housley                                                         [Page 2]





INTERNET DRAFT                                              October 1997


3  General Syntax

   The Cryptographic Message Syntax associates a content type with a
   content. The syntax shall have ASN.1 type ContentInfo:

      ContentInfo ::= SEQUENCE {
        contentType ContentType,
        content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }

      ContentType ::= OBJECT IDENTIFIER

   The fields of ContentInfo have the following meanings:

      contentType indicates the type of content. It is an object
      identifier, which means it is a unique string of integers assigned
      by the authority that defines the content type.

      content is the content. The field is optional, althought it is
      generally present. In the rare cases where it is absent, the
      intended value must be supplied by other means.

      in 3 The methods below assume that the type of content can be
      determined uniquely by contentType, so the type defined along with
      the object identifier should not be a CHOICE type.

      When a ContentInfo value is encapsulated within signed-data, a
      message-digest algorithm is applied to the contents octets of the
      DER encoding of the content field. When a ContentInfo value is
      encapsulated within enveloped-data, a content-encryption algorithm
      is applied to the contents octets of a definite-length BER
      encoding of the content field.

      The optional omission of the content field makes it possible to
      construct "external signatures." In the case of external
      signatures, the content being signed would be absent from the
      encapsulated ContentInfo value included in the signed-data content
      type.

4  Data Content Type

   The data content type is identified by the following object
   identifier:

      id-data OBJECT IDENTIFIER ::= { iso(1) member-body(2)
          US(840) rsadsi(113549) pkcs(1) pkcs7(7) 1 }






Housley                                                         [Page 3]





INTERNET DRAFT                                              October 1997


   The data content type is just an octet string. It shall have ASN.1
   type Data:

      Data ::= OCTET STRING

   The data content type is intended to refer to arbitrary octet
   strings, such as ASCII text files; the interpretation is left to the
   application. Such strings need not have any internal structure
   (although they may; they could even be DER encodings).

5  Signed-data Content Type

   The signed-data content type consists of a content of any type and
   zero or more signature values. Any type of content can be signed by
   any number of signers in parallel.

   The typical application of the signed-data content type represents
   one signer's digital signature on content of the data content type.
   Another typical application disseminates certificates and certificate
   revocation lists (CRLs).

   The process by which signed data is constructed involves the
   following steps:

      1.  For each signer, a message digest, or hash value, is computed
      on the content with a signer-specific message-digest algorithm. If
      two signers employ the same message digest algorithm, then the
      message digest need be computed for only one of them. If the
      signer is authenticating any information other than the content
      (see Section 5.2), the message digest of the content and the other
      information are digested with the signer's message digest
      algorithm, and the result becomes the "message digest."

      2.  For each signer, the message digest is digitally signed using
      the signer's private key.

      3.  For each signer, the signature value and other signer-specific
      information are collected into a SignerInfo value, as defined in
      Section 5.2. Certificates and CRLs for each signer, and those not
      corresponding to any signer, are collected in this step.

      4.  The message digest algorithms for all the signers and the
      SignerInfo values for all the signers are collected together with
      the content into a SignedData value, as defined in Section 5.1.

   A recipient independently computes the message digest.  This message
   digest and the signer's public key are used it to validate the
   signature value. The signer's public key is either contained in a



Housley                                                         [Page 4]





INTERNET DRAFT                                              October 1997


   certificate included in the signer information, or is referenced by
   an issuer distinguished name and an issuer-specific serial number
   that uniquely identify the certificate containing the public key.

   This section is divided into four parts. The first part describes the
   top-level type SignedData, the second part describes the per-signer
   information type SignerInfo, and the third and fourth parts describe
   the message digest calculation and signiture generation processes.

5.1  SignedData Type

   The signed-data content type is identified by the following object
   identifier:

      id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
          US(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }

   The signed-data content type shall have ASN.1 type SignedData:

      SignedData ::= SEQUENCE {
        version Version,
        digestAlgorithms DigestAlgorithmIdentifiers,
        contentInfo ContentInfo,
        certificates [0] IMPLICIT CertificateSet OPTIONAL,
        crls [1] IMPLICIT CRLs OPTIONAL,
        signerInfos SignerInfos }

      DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier

      SignerInfos ::= SET OF SignerInfo

   The fields of type SignedData have the following meanings:

      version is the syntax version number. If no attribute certificates
      are present in the certificates field, then the value of version
      shall 1; however, if attribute certificates are present, then the
      value of version shall be 3.

      digestAlgorithms is a collection of message digest algorithm
      identifiers. There may be any number of elements in the
      collection, including zero. Each element identifies the message
      digest algorithm, along with any associatied parameters, used by
      one or more signer. The collection is intended to list the message
      digest algorithms employed by all of the signers, in any order, to
      facilitate one-pass signature verification.  The message digesting
      process is described in Section 5.3.

      contentInfo is the content that is signed. It can have any type.



Housley                                                         [Page 5]





INTERNET DRAFT                                              October 1997


      certificates is a collection of certificates. It is intended that
      the set of certificates be sufficient to contain chains from a
      recognized "root" or "top-level certification authority" to all of
      the signers in the signerInfos field. There may be more
      certificates than necessary, and there may be certificates
      sufficient to contain chains from two or more independent top-
      level certification authorities. There may also be fewer
      certificates than necessary, if it is expected recipients have an
      alternate means of obtaining necessary certificates (e.g., from a
      previous set of certificates). If no attribute certificates are
      present in the collection, then the value of version shall 1;
      however, if attribute certificates are present, then the value of
      version shall be 3.

      crls is a collection of certificate revocation lists (CRLs). It is
      intended that the set contain information sufficient to determine
      whether or not the certificates in the certificates field are
      valid, but such correspondence is not necessary. There may be more
      CRLs than necessary, and there may also be fewer CRLs than
      necessary.

      signerInfos is a collection of per-signer information. There may
      be any number of elements in the collection, including zero.

   In the degenerate case where there are no signers, the ContentInfo
   value being "signed" is irrelevant. In this case, the content type
   within the ContentInfo value being "signed" should be data, and the
   content field of the ContentInfo value should be omitted.

5.2  SignerInfo Type

   Per-signer information is represented in the type SignerInfo:

      SignerInfo ::= SEQUENCE {
        version Version,
        issuerAndSerialNumber IssuerAndSerialNumber,
        digestAlgorithm DigestAlgorithmIdentifier,
        authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
        signatureAlgorithm signatureAlgorithmIdentifier,
        signature SignatureValue,
        unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL }

      SignatureValue ::= OCTET STRING

   The fields of type SignerInfo have the following meanings:

      version is the syntax version number. It shall always be 1.




Housley                                                         [Page 6]





INTERNET DRAFT                                              October 1997


      issuerAndSerialNumber specifies the signer's certificate (and
      thereby the signer's public key) by issuer distinguished name and
      issuer-specific serial number.

      digestAlgorithm identifies the message digest algorithm, and any
      associated parameters, used by the signer. The message digest is
      computed over the  the content and authenticated attributes, if
      present. The message digest algorithm should be among those listed
      in the digestAlgorithms field of the superior SignerInfo value.
      The message digesting process is described in Section 5.3.

      authenticatedAttributes is a collection of attributes that are
      signed. The field is optional, but it must be present if the
      content type of the ContentInfo value being signed is not data. If
      the field is present, it must contain, at a minimum, two
      attributes:

         A PKCS #9 content-type attribute having as its value the
         content type of the ContentInfo value being signed.

         A PKCS #9 message-digest attribute, having as its value the
         message digest of the content.

         Other attribute types that might be useful here, such as
         signing time, are also defined in PKCS #9.

      signatureAlgorithm identifies the signature algorithm, and any
      associated parameters, used by the signer to genrate the digital
      signature.

      signature is the result of digital signature generation, using the
      message digest and the signer's private key.

      unauthenticatedAttributes is a collection of attributes that are
      not signed. The field is optional. Attribute types that might be
      useful here, such as countersignatures, are defined in PKCS #9.

5.3  Message Digest Calculation Process

   The message digest calculation process computes a message digest on
   either the content being signed or the content together with the
   signer's authenticated attributes. In either case, the initial input
   to the message digest calculation process is the "value" of the
   content being signed. Specifically, the initial input is the content
   octets of the DER encoding of the content field of the ContentInfo
   value to which the signing process is applied. Only the contents
   octets of the DER encoding of that field are input to the message
   digest algoritm, not the identifier octets or the length octets.



Housley                                                         [Page 7]





INTERNET DRAFT                                              October 1997


   The result of the message digest calculation process depends on
   whether the authenticatedAttributes field is present. When the field
   is absent, the result is just the message digest of the content as
   described above. When the field is present, however, the result is
   the message digest of the complete DER encoding of the Attributes
   value containted in the authenticatedAttributes field. Since the
   Attributes value, when the field is present, must contain as
   attributes the content type and the message digest of the content,
   those values are indirectly included in the result. A separate
   encoding of the authenticatedAttributes field is performed for
   message digest calculation. The IMPLICIT [0] tag in the
   authenticatedAttributes field is not used for the DER encoding,
   rather an EXPLICIT SET OF tag is used. That is, the DER encoding of
   the SET OF tag, rather than of the IMPLICIT [0] tag, is to be
   included in the message digest calculation along with the length and
   contents octets of the Attributes value.

   When the content being signed has content type data and the
   authenticatedAttributes field is absent, then just the value of the
   data (e.g., the contents of a file) is input to the message digest
   calculation. This has the advantage that the length of the content
   being signed need not be known in advance of the encryption process.

   Although the identifier octets and the length octets are not included
   in the message digest calculation, they are still protected by other
   means. The length octets are protected by the nature of the message
   digest algorithm since it is computationally infeasible to find any
   two distinct messages of any length that have the same message
   digest.

   The fact that the message digest is computed on part of a DER
   encoding does not mean that DER is the required method of
   representing that part for data transfer. Indeed, it is expected that
   some implementations will store objects in forms other than their DER
   encodings, but such practices do not affect message digest
   computation.

5.4  Message Signature Generation Process

   The input to the signature generation process includes the result of
   the message digest calculation process and the signer's private key.
   The details of the signature generation depend on the signature
   algorithm deployed.  The object identifier, along with any
   parameters, that specifies the signature algorithm deployed by the
   signer is carried in the signatureAlgorithm field.  The signature
   value generated by the signer is encoded as an OCTET STRING and
   carried in the signature field.




Housley                                                         [Page 8]





INTERNET DRAFT                                              October 1997


6  Enveloped-data Content Type

   The enveloped-data content type consists of an encrypted content of
   any type and encrypted content-encryption keys for one or more
   recipients. The combination of the encrypted content and one
   encrypted content-encryption key for a recipient is a "digital
   envelope" for that recipient. Any type of content can be enveloped
   for any number of recipients.

   The typical application of the enveloped-data content type will
   represent one or more recipients' digital envelopes on content of the
   data or signed-data content types.

   Enveloped-data is constructed by the following steps:

      1.  A content-encryption key for a particular content-encryption
      algorithm is generated at random.

      2.  The content-encryption key is encrypted for each recipient.
      The details of this encryption depend on the key management
      algorithm used, but three genral techniques are supported:

         key transport:  the content-encryption key is encrypted in the
         recipient's public key;

         key agreement:  the recipient's public key and the sender's
         private key are used to generate a pairwise symmetric key, then
         the content-encryption key is encrypted in the pairwise
         symmetric key; and

         mail list keys:  the content-encryption key is encrypted in a
         previously distributed symmetric key.

      3.  For each recipient, the encrypted content-encryption key and
      other recipient-specific information are collected into a
      RecipientInfo value, defined in Section 6.2.

      4.  The content is encrypted with the content-encryption key.
      Content encryption may require that the content be padded to a
      multiple of some block size; see Section 6.3.

      5.  The RecipientInfo values for all the recipients are collected
      together with the encrypted content into a EnvelopedData value as
      defined in Section 6.1.

   A recipient opens the envelope by decrypting the one of the encrypted
   content-encryption keys and decrypting the encrypted content with the
   recovered content-encryption key.



Housley                                                         [Page 9]





INTERNET DRAFT                                              October 1997


   This section is divided into four parts. The first part describes the
   top-level type EnvelopedData, the second part describes the per-
   recipient information type RecipientInfo, and the third and fourth
   parts describe the content-encryption and key-encryption processes.

6.1  EnvelopedData Type

   The enveloped-data content type is identified by the following object
   identifier:

      id-envelopedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
          US(840) rsadsi(113549) pkcs(1) pkcs7(7) 3 }

   The enveloped-data content type shall have ASN.1 type EnvelopedData:

      EnvelopedData ::= SEQUENCE {
        version Version,
        originatorInfo [0] OriginatorInfo OPTIONAL,
        recipientInfos RecipientInfos,
        encryptedContentInfo EncryptedContentInfo }

      OriginatorInfo ::= SEQUENCE {
        certs [0] IMPLICIT CertificateSet OPTIONAL,
        crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
        ukms [2] UserKeyingMaterials OPTIONAL }

      RecipientInfos ::= SET OF RecipientInfo

      EncryptedContentInfo ::= SEQUENCE {
        contentType ContentType,
        contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
        encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }

      EncryptedContent ::= OCTET STRING

   The fields of type EnvelopedData have the following meanings:

      version is the syntax version number. If originatorInfo is
      present, then version shall be 2.  If any of the RecipientInfo
      structures included have a version of 2, then the version shall be
      2. If originatorInfo is absent and all of the RecipientInfo
      structures are version 0, then version shall be 0.

      recipientInfos is a collection of per-recipient information. There
      must be at least one element in the collection.

      encryptedContentInfo is the encrypted content information.




Housley                                                        [Page 10]





INTERNET DRAFT                                              October 1997


   The fields of type EncryptedContentInfo have the following meanings:

      contentType indicates the type of content.

      contentEncryptionAlgorithm identifies the content-encryption
      algorithm, and any associated parameters, used to encrypt the
      content. The content-encryption process is described in Section
      6.3. The same algorithm is used for all recipients.

      encryptedContent is the result of encrypting the content. The
      field is optional, and if the field is not present, its intended
      value must be supplied by other means.

   The recipientInfos field comes before the encryptedContentInfo field
   so that an EnvelopedData value may be preoceesed in a single pass.

6.2  RecipientInfo Type

   Per-recipient information is represented in the type RecipientInfo:

      RecipientInfo ::= SEQUENCE {
        version Version,
        rid RecipientIdentifier,
        keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
        encryptedKey EncryptedKey }

      RecipientIdentifier ::= CHOICE {
        issuerAndSerialNumber IssuerAndSerialNumber,
        rKeyId [0] RecipientKeyIdentifier,
        mlKeyId [1] MailListKeyIdentifier }

      RecipientKeyIdentifier ::= SEQUENCE {
        subjectKeyIdentifier OCTET STRING,
        date GeneralizedTime OPTIONAL,
        other OtherKeyAttribute OPTIONAL }

      MailListKeyIdentifier ::= SEQUENCE {
        kekIdentifier OCTET STRING,
        date GeneralizedTime OPTIONAL,
        other OtherKeyAttribute OPTIONAL }

      OtherKeyAttribute ::= SEQUENCE {
        keyAttrId OBJECT IDENTIFIER,
        keyAttr ANY DEFINED BY keyAttrId OPTIONAL }

      EncryptedKey ::= OCTET STRING





Housley                                                        [Page 11]





INTERNET DRAFT                                              October 1997


   The fields of type RecipientInfo have the following meanings:

      version is the syntax version number. If the RecipientIdentifier
      is the CHOICE issuerAndSerialNumber, then the version shall be 0.
      If the RecipientIdentifier is either the CHOICE rKeyId or mlKeyId,
      then the version shall be 2.

      rid specifies the recipient's certificate or key that was used by
      the sender to protect the content-encryption key.

      keyEncryptionAlgorithm identifies the key-encryption algorithm,
      and any associated parameters, used to encrypt the content-
      encryption key for the recipient. The key-encryption process is
      described in Section 6.4.

      encryptedKey is the result of encrypting the content-encryption
      key for the recipient.

   The RecipientIdentifier is a CHOICE with three alternatives.  The
   first two alternatives, issuerAndSerialNumber and rKeyId, specifies
   the recipient's certificate, and thereby the recipient's public key.
   The rKeyId alternative may optionally specify other parameters
   needed, such as the date.  If the recipient's certificate contains a
   key transport public key, then the content-encryption key is
   encrypted with the recipient's public key. If the recipient's
   certificate contains a key agreement public key, then a pairwise
   symmetric key is established and used to encrypt the content-
   encryption key.  The third alternative, mlKeyId, specifies a
   symmetric key encryption key that was previously distributed to the
   sender and recipient.

   The fields of type RecipientKeyIdentifier have the following
   meanings:

      subjectKeyIdentifier identifies the recipient's certificate by the
      X.509 subjectKeyIdentifier extension value.

      date is optional.  When present, the date specifies which of the
      recipient's UKMs was used by the sender.

      other is optional.  When present, this field contains additional
      information used by the recipient to locate the keying material
      used by the sender.

   The fields of type MailListKeyIdentifier have the following meanings:

      kekIdentifier identifies the key-encryption key that was
      previously distributed to the sender and the recipient.



Housley                                                        [Page 12]





INTERNET DRAFT                                              October 1997


      date is optional. When present, the date specifies a single key-
      encryption key from a set that was previously distributed to the
      sender and the recipient.

      other is optional.  When present, this field contains additional
      information used by the recipient to locate the keying material
      used by the sender.

6.3  Content-encryption Process

   The input to the content-encryption process is the "value" of the
   content being enveloped. Specifically, the input is the content
   octets of a definite-length BER encoding of the content field of the
   ContentInfo value. Only the content octets of the BER encoding are
   encrypted, not the identifier octets or length octets; those other
   octets are not included.

   When the content being enveloped has content type data, then just the
   value of the data (e.g., the contents of a file) is encrypted. This
   has the advantage that the length of the content being encrypted need
   not be known in advance of the encryption process.

   The identifier octets and the length octets are not encrypted. The
   length octets may be protected implicitly by the encryption process,
   depending on the encryption algorithm. The identifier octets are not
   protected at all, although they can be recovered from the content
   type, assuming that the content type uniquely determines the
   identifier octets. Explicit protection of the identifier and length
   octets requires that the signed-data content type be employed prior
   to enveloping.

   A definite-length BER encoding is used to ensure that the bit
   indicating whether the length is definite or indefinite is not
   recorded in the enveloped-data content type. Definite-length encoding
   is more appropriate for simple types such as octet strings, so
   definite-length encoding is chosen.

   Some content-encryption algorithms assume the input length is a
   multiple of k octets, where k is greater than one. For such
   algorithms, the input shall be padded at the trailing end with
   k-(l mod k) octets all having value k-(l mod k), where l is the
   length of the input. In other words, the input is padded at the
   trailing end with one of the following strings:








Housley                                                        [Page 13]





INTERNET DRAFT                                              October 1997


                     01 -- if l mod k = k-1
                  02 02 -- if l mod k = k-2
                      .
                      .
                      .
            k k ... k k -- if l mod k = 0

   The padding can be removed unambiguously since all input is padded,
   including input values that are already a multiple of the block size,
   and no padding string is a suffix of another. This padding method is
   well-defined if and only if k is less than 256.

6.4  Key-encryption Process

   The input to the key-encryption process -- the value supplied to the
   recipient's key-encryption algorithm --is just the "value" of the
   content-encryption key.

7  Useful Types

   This section defines types that are used other places in the
   document.  The types are not listed in any particular order.

7.1  CertificateRevocationLists

   The CertificateRevocationLists type gives a set of certificate
   revocation lists (CRLs). It is intended that the set contain
   information sufficient to determine whether the certificates with
   which the set is associated are revoked or not.  However, there may
   be more CRLs than necessary, or there may be fewer than necessary.

   The definition of CertificateRevocationList is imported from X.509.

      CertificateRevocationLists ::= SET OF CertificateRevocationList

7.2  ContentEncryptionAlgorithmIdentifier

   The ContentEncryptionAlgorithmIdentifier type identifies a content-
   encryption algorithm such as DES. A content-encryption algorithm
   supports encryption and decryption operations. The encryption
   operation maps an octet string (the message) to another octet string
   (the ciphertext) under control of a content-encryption key. The
   decryption operation is the inverse of the encryption operation.
   Context determines which operation is intended.

   The definition of AlgorithmIdentifier is imported from X.509.

      ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier



Housley                                                        [Page 14]





INTERNET DRAFT                                              October 1997


7.3  DigestAlgorithmIdentifier

   The DigestAlgorithmIdentifier type identifies a message-digest
   algorithm. Examples include SHA-1, MD2, and MD5. A message-digest
   algorithm maps an octet string (the message) to another octet string
   (the message digest).

   The definition of AlgorithmIdentifier is imported from X.509.

      DigestAlgorithmIdentifier ::= AlgorithmIdentifier

7.4  SignatureAlgorithmIdentifier

   The SignatureAlgorithmIdentifier type identifies a signture
   algorithm.  Examples include DSS and RSA. A signature algorithm
   supports signature generation and verification operations. The
   signature generation operation uses the message digest and the
   signer's private key to generate a signutre value. The signature
   verification operation uses the message digest and the signer's
   public key to determine whether or not a signutre value is valid.
   Context determines which operation is intended.

   The definition of AlgorithmIdentifier is imported from X.509.

      SignatureAlgorithmIdentifier ::= AlgorithmIdentifier

7.5  CertificateChoices

   The CertificateChoices type gives either a PKCS #6 extended
   certificate, an X.509 certificate, or an X.509 attrinute certificate.
   The PKCS #6 extended certificate is obsolete.  It is included for
   backwards compatibility, and its use should be avoided.

   The definitions of Certificate and AttributeCertificate are imported
   from X.509.

      CertificateChoices ::= CHOICE {
        certificate Certificate,  -- See X.509
        extendedCertificate [0] IMPLICIT ExtendedCertificate,  -- Obsolete
        attrCert [1] AttributeCertificate }  -- See X.509 and X9.57

7.6  CertificateSet

   The CertificateSet type provides a set of certificates. It is
   intended that the set be sufficient to contain chains from a
   recognized "root" or "top-level certification authority" to all of
   the sender certificates with which the set is associated.  However,
   there may be more certificates than necessary, or there may be fewer



Housley                                                        [Page 15]





INTERNET DRAFT                                              October 1997


   than necessary.

   The precise meaning of a "chain" is outside the scope of this
   document. Some applications may impose upper limits on the length of
   a chain; others may enforce certain relationships between the
   subjects and issuers of certificates within a chain.

      CertificateSet ::= SET OF CertificateChoices

7.7  IssuerAndSerialNumber

   The IssuerAndSerialNumber type identifies a certificate, and thereby
   an entity and a public key, by the distinguished name of the
   certificate issuer and an issuer-specific certificate serial number.

      IssuerAndSerialNumber ::= SEQUENCE {
        issuer Name,
        serialNumber CertificateSerialNumber }

7.8  KeyEncryptionAlgorithmIdentifier

   The KeyEncryptionAlgorithmIdentifier type identifies a key-encryption
   algorithm used to encrypt a content-encryption key. The encryption
   operation maps an octet string (the key) to another octet string (the
   encrypted key) under control of a key-encryption key. The decryption
   operation is the inverse of the encryption operation. Context
   determines which operation is intended.

   The details of encryption and decryption depend on the key management
   algorithm used. Key transport, key agreement, and previously
   distributed symmetric key-encrypting keys are supported.

   The definition of AlgorithmIdentifier is imported from X.509.

      KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier

7.9  Version

   The Version type gives a syntax version number, for compatibility
   with future revisions of this document.

      Version ::= INTEGER

7.10  UserKeyingMaterial

   The UserKeyingMaterial type gives a syntax user keying material
   (UKM). Some key management algorithms require UKMs. The sender
   provides a UKM for the specific key management algorithm.



Housley                                                        [Page 16]





INTERNET DRAFT                                              October 1997


   The definition of AlgorithmIdentifier is imported from X.509.

      UserKeyingMaterial ::= SEQUENCE {
        algorithm AlgorithmIdentifier,
        ukm OCTET STRING }

7.11  UserKeyingMaterials

   The UserKeyingMaterial type provides a set of user keying materials
   (UKMs). This allows the sender to provide a UKM for each key
   management algorithm that requires one.

      UserKeyingMaterials ::= SET OF UserKeyingMaterial

7.12  OtherKeyAttribute

   The OtherKeyAttribute type gives a syntax for the inclusion of other
   key attributes that permit the recipient to select the key used by
   the sender. The attribute object identifier must be registered along
   with the syntax of the attribute itself.  Use of this structure
   should be avoided since it may impede interoperability.

      OtherKeyAttribute ::= SEQUENCE {
        keyAttrId OBJECT IDENTIFIER,
        keyAttr ANY DEFINED BY keyAttrId OPTIONAL }

References

   To be supplied.

Security Considerations

   The Cryptographic Message Syntax provides a method for digitally
   signing data and encrypting data.

   Implementations must protect the signer's private key.  Compromise of
   the signer's private key permits masquerade.

   Implementations must protect the key management private key and the
   content-encryption key.  Compromise of the key management private key
   may result in the disclosure of all messages protected with that key.
   Similarly, compromise of the content-encryption key may result in
   disclosure of the encrypted content.








Housley                                                        [Page 17]





INTERNET DRAFT                                              October 1997


Author Address

   Russell Housley
   SPYRUS
   PO Box 1198
   Herndon, VA 20172
   USA
   housley@spyrus.com











































Housley                                                        [Page 18]


