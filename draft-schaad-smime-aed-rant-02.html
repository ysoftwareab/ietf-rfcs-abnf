<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Commentary on the Design of the Authenticated-Enveloped-Data Content Type</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Historic Arguments">
<link href="#rfc.section.3" rel="Chapter" title="3 Algorithm Taxonomy">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 CCM: Counter with CBC-MAC">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 CS: Cipher-State">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 CWC: Carter Wegman with Counter">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 EAX: A Conventional Authenticated-Encryption Mode">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 GCM: Galois/Counter Mode">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 IACBC: Integrity Aware Cipher Block Chaining">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 IAPM: Integrity Aware Parallelizable Mode">
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 OCB: Offset Codebook">
<link href="#rfc.section.3.9" rel="Chapter" title="3.9 PCFB: Propagating Cipher Feedback">
<link href="#rfc.section.3.10" rel="Chapter" title="3.10 SIV: Synthetic IV">
<link href="#rfc.section.3.11" rel="Chapter" title="3.11 XCBC: eXtended Cipher Block Chaining Encryption">
<link href="#rfc.section.3.12" rel="Chapter" title="3.12 MAC-Authenticated Encryption">
<link href="#rfc.section.4" rel="Chapter" title="4 My Assumptions">
<link href="#rfc.section.5" rel="Chapter" title="5 Conclusions">
<link href="#rfc.section.6" rel="Chapter" title="6 Responses">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="The Authenticated-Enveloped-Data Content Type allows for the use of Authenticated-Enveloped modes with block cipher algorithms.  At the time of the original design there was discussion about the relative location of the authenticated attributes and the encrypted content in the ASN.1 structure.  With the benefits of implementation experience I revisit the discussion made  at the time and re-evaluate the decision made." />
  <meta name="description" content="The Authenticated-Enveloped-Data Content Type allows for the use of Authenticated-Enveloped modes with block cipher algorithms.  At the time of the original design there was discussion about the relative location of the authenticated attributes and the encrypted content in the ASN.1 structure.  With the benefits of implementation experience I revisit the discussion made  at the time and re-evaluate the decision made." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">J. Schaad</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Soaring Hawk Consulting</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">April 06, 2011</td>
</tr>
<tr>
<td class="left">Expires: October 08, 2011</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Commentary on the Design of the Authenticated-Enveloped-Data Content Type<br />
  <span class="filename">draft-schaad-smime-aed-rant-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Authenticated-Enveloped-Data Content Type allows for the use of Authenticated-Enveloped modes with block cipher algorithms.  At the time of the original design there was discussion about the relative location of the authenticated attributes and the encrypted content in the ASN.1 structure.  With the benefits of implementation experience I revisit the discussion made  at the time and re-evaluate the decision made.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 08, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
<li>2.   <a href="#rfc.section.2">Historic Arguments</a>
</li>
<li>3.   <a href="#rfc.section.3">Algorithm Taxonomy</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">CCM: Counter with CBC-MAC</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">CS: Cipher-State</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">CWC: Carter Wegman with Counter</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">EAX: A Conventional Authenticated-Encryption Mode</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">GCM: Galois/Counter Mode</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">IACBC: Integrity Aware Cipher Block Chaining</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">IAPM: Integrity Aware Parallelizable Mode</a>
</li>
<li>3.8.   <a href="#rfc.section.3.8">OCB: Offset Codebook</a>
</li>
<li>3.9.   <a href="#rfc.section.3.9">PCFB: Propagating Cipher Feedback</a>
</li>
<li>3.10.   <a href="#rfc.section.3.10">SIV: Synthetic IV</a>
</li>
<li>3.11.   <a href="#rfc.section.3.11">XCBC: eXtended Cipher Block Chaining Encryption</a>
</li>
<li>3.12.   <a href="#rfc.section.3.12">MAC-Authenticated Encryption</a>
</li>
<li>4.   <a href="#rfc.section.4">My Assumptions</a>
</li>
<li>5.   <a href="#rfc.section.5">Conclusions</a>
</li>
<li>6.   <a href="#rfc.section.6">Responses</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">When the Cryptographic Message Syntax (CMS) <a href="#CMS">[CMS]</a> Authenticated-Enveloped-Data content type (defined in RFC 5083 <a href="#CMS-AED">[CMS-AED]</a>) was being discussed, the S/MIME working group had no actual implementation experience to guide it in some of the decisions that were being made at the time.  In this document I am revisiting one of these decisions based on the implementation experience that I have since garnered.</p>
<p id="rfc.section.1.p.2">Issues that were discussed at the time included: </p>

<ul class="empty">
<li>What should the order be for the authenticated attributes, the encrypted data and the authentication code be in the ASN.1 structure.  There was uniform agreement that the authentication code should be last, however the placement of the other two fields was hotly disputed.  This is the issue that we further address below.</li>
<li>Should we change from using a SET to a SEQUENCE for the attribute list.  Doing so would have simplified the encoding processing for hashing.  There was no support for doing this as a common routine exists that already worked for the signed and authenticated data structures.</li>
<li>What are the security issues that deal with the timing of release of the encrypted content vs. the validation step.  This issue was addressed in section 2 with the statement "The recipient MUST verify the integrity of the received content   before releasing any information, especially the plaintext of the   content."</li>
<li>Step 5 in section 2 says that padding needed to be done to the block length, however there was some concern that the issue of how padding should be done is better left to the algorithm description rather than being specified here.  No changes were made to address the issue.</li>
</ul>

<p> </p>
<p id="rfc.section.1.p.3">The major focus of the discussions centered on the relative placement of the encrypted data blob (contained in  the authEncryptedContentInfo field) and the authenticated attributes (contained in the authAttrs field).  There were three different camps that emerged.  These where:  1) The attributes should be before the encrypted data, 2) The attributes should be after the encrypted data, and 3) There should be the ability to place the attributes both before and after the encrypted data and the encoder would choice which to use.  As can be seen from the ASN.1 in <a href="#ASN">Figure 1</a> the final decision was to place the authenticated attributes after the encrypted content.  This was counter to the arguments that I made at the time to place the authenticated attributes before the encrypted content.</p>
<div id="#rfc.figure.1"></div>
<div id="#ASN"></div>
<pre>
 AuthEnvelopedData ::= SEQUENCE {
   version CMSVersion,
   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
   recipientInfos RecipientInfos,
   authEncryptedContentInfo EncryptedContentInfo,
   authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
   mac MessageAuthenticationCode,
   unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
</pre>
<p id="rfc.section.1.p.4">This document is organized as follows: </p>

<ul>
<li>
<a href="#history">Section 2</a> contains a review of the arguments presented at the time.</li>
<li>
<a href="#algs">Section 3</a> has a taxonomy  of a number of authenticated encryption algorithms.</li>
<li>
<a href="#criteria">Section 4</a> presents a set of criteria to be used.</li>
<li>
<a href="#opinion">Section 5</a> contains my personal conclusions on the issue.</li>
<li>
<a href="#rebuttal">Section 6</a> contains rebuttals (or maybe not).</li>
</ul>

<p> </p>
<p id="rfc.section.1.p.5">The major part of my discussion focuses on the desirability to use a streaming model for processing the ASN.1 structure and the data contained within it.  If one does not want to use streaming in doing the processing, then much of the discussion here is moot.  If one is willing to buffer up all of the input to the encryption algorithm before applying it, the order that the inputs are presented are immaterial. This will be further detailed in <a href="#criteria">Section 4</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Terminology</h1>
<p id="rfc.section.1.1.p.1">The following is a list of standardized terms used in the document: </p>

<dl>
<dt>AE</dt>
<dd style="margin-left: 8">is an abbreviation for Authenticated Encryption.  This is block cipher mode of operation which simultaneously provides confidentiality and integrity assurances on the data.</dd>
<dt>AEAD</dt>
<dd style="margin-left: 8">is an abbreviation for Authenticated Encryption with Auxiliary Data.  This is a block cipher mode of operation which simultaneously provides confidentiality and integrity assurances on the message data as well as integrity assurances on an additional set of data.</dd>
<dt>Message Data</dt>
<dd style="margin-left: 8">is the section of the input data that is to be authenticated and encrypted by the AE or AEAD algorithm mode. For CMS, the encrypted message data is placed in the encryptedContent field of the authEncryptedContentInfo sequence.</dd>
<dt>Authenticated Data</dt>
<dd style="margin-left: 8">is the section of input data that is to be authenticated but not encrypted.  For CMS, the authenticated data is the sequence in the authAttrs field.</dd>
<dt>Authentication Tag</dt>
<dd style="margin-left: 8">is a value that is generated by the mode which is used to validate the integrity of the data.  The Authentication Tag is sometimes implicit and does not exist as an independent value.  For CMS, it is assumed that the use of the algorithm will define an explicit tag and the tag will be placed in the mac field.</dd>
<dt>Streaming Model</dt>
<dd style="margin-left: 8">is a method of doing the processing such that the ASN.1 processing and the cryptographic processing can be interleaved with each other.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#history" id="history">Historic Arguments</a>
</h1>
<p id="rfc.section.2.p.1">I have gone through the archived mailing list from the time to find the arguments that were being advanced.  The arguments are laid out with the pro side being for attribute being placed after the data except for the last item in the list.</p>
<p></p>

<ol>
<li>Consistency with the existing CMS data types: <ul class="empty">
<li>PRO:  We have working implementations of both AuthenticatedData and SignedData which work.  In both of these cases the data structures are ordered such that the message data precedes the authenticated data.  Keeping the order consistent makes coding easier and leads to fewer mistakes.</li>
<li>CON:  Being constant is nice, however if it does not work correctly that does not matter.</li>
</ul>
<p> </p>
</li>
<li>Authenticated attributes may be derived from the message content: <ul class="empty">
<li>PRO: It should be possible to create authenticated attributes based on the content of the encrypted data and have these attributes authenticated.  Placing the attribute before the message content means that one must buffer the message content to do this.  The example of this presented on the mailing list was the ability for a sender to process the body of the message on fly by a virus checker and publish the result of the virus checking as an authenticated attribute.  This is the same thing that currently happens today for both SignedData and AuthenticatedData where the hash of the message data is computed on the fly and then placed in the signed/authenticated attributes which are then processed to compute the signature or mac values.  </li>
<li>CON: Placing this information after the message data means that the recipient cannot know to perform matching processing, if necessary, in order to check the value presented by the sender.  The analogous step for the SignedData structure is the need for the recipient to hash the message data during processing in order to correctly validate the signed attribute fields.</li>
</ul>
<p> </p>
</li>
<li>The decision should be dictated by Algorithm Characteristics: <ul class="empty">
<li>PRO: The order of placing the attributes before the message data was dictated by a specific choice of algorithms (CCM and GCM) and that other authenticated encryption algorithms (specifically CWC) would naturally place the attributes second.</li>
<li>CON: No detailed analysis of algorithms was done.  However, the attribute data should be expected to be much smaller than the message data and thus it makes more sense to cache the attributes for later processing than to cache the message data for later processing.</li>
</ul>
<p> </p>
</li>
<li>Resource requirements for the sender and recipient: <ul class="empty"><li>What happens with resource constrained devices that are acting as senders or recipients?  The initial argument dealt with the question of resource limited senders that would not be able to store intermediate data, but the same question applies to resource limited recipients.  We know that this was intended to be used with firmware upgrades as one option, but it could equally be used by a device sending out reports to a central server.  This is a case where a close analysis would need to be done on the algorithm being used and how it will affect the resources needed.</li></ul>
<p> </p>
</li>
<li>Relative frequency of processing: <ul class="empty"><li>There was a certain amount of discussion of the question of the relative frequency of processing between the sender and the recipient of a message.  This would have bearing on the question of which entity the decisions should be optimized for.  One set of people argued that recipients process messages more frequently than senders.  Another set of people argued that there exist applications where the sender may create messages that are never verified.</li></ul>
<p> </p>
</li>
<li>Attributes should be placed in both locations.  <ul class="empty"><li>There were a couple of people who attempted to argue that the discussions should be made by the sender of the message rather than by the object designers.  In this case we should have two different locations where the authenticated attributes could be place, either before or after the data, but only one of the two could be used.  The message creator would then select one or the other based on characteristics of their choosing.  Recipients would then be required to deal with the attributes occurring in either location.  It was generally felt that the additional complexity on the recipient side was not worth the added flexibility.</li></ul>
<p> </p>
</li>
</ol>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#algs" id="algs">Algorithm Taxonomy</a>
</h1>
<p id="rfc.section.3.p.1">In item 3 in the previous section, one of the issues was what would a rigorous analysis of the AEAD algorithms lead us to believe about how the choice should be laid out.  At the time we were using only hearsay facts about what would make for a good choice.  In this section, I define a set of criteria that I will use to analysis the set of algorithms and then describe how each algorithm fits the criteria.</p>
<p id="rfc.section.3.p.2">NIST has been gathering information on Authenticated Encryption Modes over the last decade.  Information on these modes can be found at <a href="http://crc.nist.gov/groups/ST/toolkit/BCM/modes_development.html">http://crc.nist.gov/groups/ST/toolkit/BCM/modes_development.html</a>.  For simplicity I used this as the set of algorithms to look at in order to characterize the requirements for the purposes of comparison with the characteristics required by the Authenticated Encryption data structure.</p>
<p id="rfc.section.3.p.3">In this section we will look at 11 AE algorithms from the NIST submissions along with an algorithm being developed by Peter Gutmann.  Since we are interested in how to setup a streaming model, the criteria we are looking at are chosen with that in mode.  The major characteristics we are going to be looking at are: </p>

<ol>
<li>What are the parameters used for the algorithm?  This contains a list of the elements that are needed for processing exclusive of the key value.  These are the items that would need to be encoded in the ASN.1 parameters field of an AlgorithmInformation structure.</li>
<li>What information is directly authenticated?  This is a list of the data which is directly authenticated in the order of authentication.  (It is possible that this list may change depending on the parameters.  Thus if HMAC-SHA1 is used, the length of the data is directly authenticated but it would not be if MAC-AES-128-CCBC was used.)</li>
<li>What information is required before the first byte of message data can be processed?  Assuming that the first byte of message data is to be processed upon it being decoded from the ASN.1 (or encoded to ASN.1), what items of information are needed by the encryption/decryption algorithm prior to it being processed.</li>
<li>What information is required before the first byte authenticated data can be processed?  Assuming that the first byte of authenticated data is to be processed upon it being decoded from the ASN.1 (or encoded to ASN.1), what items of information are needed by the encryption/decryption algorithm prior to it being processed.</li>
</ol>

<p> </p>
<p id="rfc.section.3.p.4">NIST is currently in the middle of doing a review and selection process for new modes to adopt as US security standards.  For simplicity the set of algorithms that I will be looking at come from the current set of candidate algorithms that are being reviewed for this purpose.  One additional algorithm added to this is a simple hash and encrypt algorithm that has been proposed by Peter Gutmann.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#CCM" id="CCM">CCM: Counter with CBC-MAC</a>
</h1>
<p id="rfc.section.3.1.p.1">The Counter with CBC-MAC (CCM) mode was designed and documented by Doug Whiting, Russ Housley and Niels Ferguson.  A full description of the mode can be found in RFC 3610 <a href="#RFC3610">[RFC3610]</a> and on the NIST website.  CCM is one of the standardized NIST modes (see <a href="#NIST-800-38C">[NIST-800-38C]</a>) and is one of the two modes that are currently documented for use with the CMS Authenticated-Enveloped structures.</p>
<p id="rfc.section.3.1.p.2">The characteristics of the algorithm are: </p>

<ol>
<li>The parameters of the algorithm are the nonce (IV) and the length of the tag to be generated.</li>
<li>The data authenticated is: <ol style="list-style-type: lower-alpha">
<li>The nonce value,</li>
<li>The length of authentication tag,</li>
<li>The length of message data,</li>
<li>The length of authenticated data,</li>
<li>The authenticated data,</li>
<li>The message data</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of message data can be processed, you must know: <ol style="list-style-type: lower-alpha">
<li>The nonce value</li>
<li>The length of the authentication tag</li>
<li>The length of the message</li>
<li>The length of authenticated data,</li>
<li>The authenticated data</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of the authenticated data can be processed, you must know: <ol style="list-style-type: lower-alpha">
<li>The nonce value,</li>
<li>The length of the authentication tag</li>
<li>The length of the message</li>
<li>The length of authenticated data,</li>
</ol>
<p> </p>
</li>
</ol>

<p> </p>
<p id="rfc.section.3.1.p.3">This algorithm mode provides major problems for a sender to process in a streaming model.  The lengths of the message data and the authenticated data are both required to be known before any bytes of the message data or authenticated data can be processed.  Except in cases where fixed length messages will be generated, it is required that the message data be cached prior to encrypting.</p>
<p id="rfc.section.3.1.p.4">This algorithm provides some problems for recipients in processing, but under the correct circumstances can be processed under a streaming model.  The length of the message data must be presented to the recipient before the message data is given.  The authenticated data must be presented before the message data is presented.  Optimal use of this algorithm would require that 1) the authenticated data be moved before the message data bytes and 2) a requirement be established that either the message data be DER encoded or the message data length be published as part of the authenticated data.  Given that this algorithm uses counter mode for encryption, the length of the message is already known so publishing it as part of the authenticated data would not leak any additional information.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> CS: Cipher-State</h1>
<p id="rfc.section.3.2.p.1">Cipher-State is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interest to this discussion.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> CWC: Carter Wegman with Counter</h1>
<p id="rfc.section.3.3.p.1">The Carter Wegman with Counter Authenticated Encryption mode was designed by Tadayoshi Kohno, John Viega and Doug Whiting.  A full description of the mode can be found in <a href="#CWC">[CWC]</a> and on the NIST website.</p>
<p id="rfc.section.3.3.p.2">The characteristics of the algorithm are: </p>

<ol>
<li>The only parameter of the algorithm is a nonce.</li>
<li>The data actually authenticated is: <ol style="list-style-type: lower-alpha">
<li>The nonce,</li>
<li>The authenticated data,</li>
<li>The encrypted message data</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of data can be processed, you must know: <ol style="list-style-type: lower-alpha">
<li>The nonce value,</li>
<li>The authenticated data</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of authenticated data can be processed, you must know: <ol style="list-style-type: lower-alpha"><li>The nonce value</li></ol>
<p> </p>
</li>
</ol>

<p> </p>
<p id="rfc.section.3.3.p.3">It should be noted that the analysis above is for a simplistic implementation of the algorithm such as would normally be done in software.  The algorithm is designed so that it can be performed in parallel, it would be possible for message data bytes to be fully processed before the authenticated data bytes are processed.  The full details of this approach are not spelled out in the referenced documents.</p>
<p id="rfc.section.3.3.p.4">This algorithm can be easily streamed for the sender provided that the authenticated data are generated  prior to the message data being generated.</p>
<p id="rfc.section.3.3.p.5">This algorithm can be easily streamed for the recipient provided that the authenticated data is presented prior to the message data being presented.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> EAX: A Conventional Authenticated-Encryption Mode</h1>
<p id="rfc.section.3.4.p.1">A Conventional Authenticated-Encryption Mode was designed and documented by M. Bellare, P. Rogaway and D. Wagner.  A full description of the algorithm can be found at <a href="#EAX">[EAX]</a> and on the NIST website.</p>
<p id="rfc.section.3.4.p.2">The characteristics of the algorithm are: </p>

<ol>
<li>The only parameter of the algorithm is a nonce.</li>
<li>The data actually authenticated is: <ol style="list-style-type: lower-alpha">
<li>The nonce,</li>
<li>The authenticated attributes,</li>
<li>The encrypted message.</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of data can be processed, you must know: <ol style="list-style-type: lower-alpha"><li>The nonce value.</li></ol>
<p> </p>
</li>
<li>Before the first byte of the data can be processed, you must know: <ol style="list-style-type: lower-alpha"><li>The nonce value.</li></ol>
<p> </p>
</li>
<li>Before the first byte of authenticated data can be processed, you must know: nothing.</li>
</ol>

<p> </p>
<p id="rfc.section.3.4.p.3">This mode computes the authentication value on the authenticated data and on the encrypted message separately - so they can be computed in any order - and combines the results together after the entire message has been processed.</p>
<p id="rfc.section.3.4.p.4">This algorithm can easily be streamed for the sender.  The order of generating the authenticated data and message data is immaterial.</p>
<p id="rfc.section.3.4.p.5">This algorithm can easily be streamed for the recipient.  The order of presenting the authenticated data and the message data is immaterial.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> GCM: Galois/Counter Mode</h1>
<p id="rfc.section.3.5.p.1">The Galois/Counter Mode of Operation (GCM) was designed and documented by David McGrew and John Viega.  A full description of the algorithm can be found on the NIST website.  GCM is one of the standardized NIST modes (see <a href="#NIST-800-38D">[NIST-800-38D]</a>) and is one of the two modes that are currently documented for use with the CMS Authenticated-Enveloped structures.</p>
<p id="rfc.section.3.5.p.2">The characteristics of the algorithm are: </p>

<ol>
<li>The parameters of the algorithm are a nonce and the length of the tag to be generated.</li>
<li>The data actually authenticated is: <ol style="list-style-type: lower-alpha">
<li>The authenticated data,</li>
<li>The encrypted message data,</li>
<li>The length of the authenticated data,</li>
<li>The length of the message data.</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of message data can be processed, you must know: <ol style="list-style-type: lower-alpha">
<li>The nonce value.</li>
<li>The authenticated data.</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of authenticated data can be processed you must know: nothing.</li>
</ol>

<p> </p>
<p id="rfc.section.3.5.p.3">This mode can easily be used in a stream model for senders provided the authenticated data is generated prior to the message data.</p>
<p id="rfc.section.3.5.p.4">This mode can easily be used in a stream model for recipients provided that the authenticated data is presented prior to the message data.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> IACBC: Integrity Aware Cipher Block Chaining</h1>
<p id="rfc.section.3.6.p.1">Integrity Aware Cipher Block Chaining is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interest to this discussion.</p>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> IAPM: Integrity Aware Parallelizable Mode</h1>
<p id="rfc.section.3.7.p.1">Integrity Aware Parallelizable Mode is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interest to this discussion.</p>
<h1 id="rfc.section.3.8">
<a href="#rfc.section.3.8">3.8.</a> OCB: Offset Codebook</h1>
<p id="rfc.section.3.8.p.1">Offset Codebook mode is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interest to this discussion.</p>
<p id="rfc.section.3.8.p.2">However, an addendum to the original mode submission described a method of adding the AEAD capability to any AE algorithm.  This was described by Phillip Rogaway in <a href="#OCB-AD1">[OCB-AD1]</a> as section 5 and designated as Ciphertext Translation.</p>
<p id="rfc.section.3.8.p.3">The characteristics of this algorithm are: </p>

<ol>
<li>This mode adds no additional parameters to the underlying AE algorithm parameters.</li>
<li>The data actually authenticated is: <ol style="list-style-type: lower-alpha">
<li>The message data</li>
<li>The authenticated data</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of data can be processed, you must know: the same information as for the AE mode by itself.</li>
<li>Before the first byte of authenticated data can be processed you must know: nothing.</li>
</ol>

<p> </p>
<p id="rfc.section.3.8.p.4">It needs to be noted that before one can process the last t bytes of the message (for either encryption or decryption) the authenticated data must be known.  The value t is equal to the length of the output function for the authenticated data processor.  This does mean that an indication that one is in the last t bytes of processing the data is needed for both encryption and decryption modes.</p>
<p id="rfc.section.3.8.p.5">The sender can operate using a streaming model as long as it buffers the last t bytes of message data so that it can be correctly tagged and sent to the cryptographic code as needing special processing.  The authenticated data must be computed prior to the last t bytes of the encryption stream being produced.  One possible way of dealing with this is to make the last t bytes the authentication tag as there is no explicit authentication tag created.</p>
<p id="rfc.section.3.8.p.6">The recipient can operate using a streaming model as long as it buffers the last t bytes of encrypted data so that it can be correctly tagged when sent to the cryptographic code.  As no separate authentication tag is created by the algorithm, the authenticated attributes must be presented prior to the last bytes of the encrypted data stream being decrypted.</p>
<h1 id="rfc.section.3.9">
<a href="#rfc.section.3.9">3.9.</a> PCFB: Propagating Cipher Feedback</h1>
<p id="rfc.section.3.9.p.1">Propagating Cipher Feedback is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interest to this discussion.</p>
<h1 id="rfc.section.3.10">
<a href="#rfc.section.3.10">3.10.</a> SIV: Synthetic IV</h1>
<p id="rfc.section.3.10.p.1">The Synthetic IV (SIV) mode was designed and documented by Phillip Rogaway and Thomas Shrimpton.  A full description of the algorithm can be found on the NIST website at <a href="#SIV">[SIV]</a>.  </p>
<p id="rfc.section.3.10.p.2">The characteristics of the algorithm are: </p>

<ol>
<li>The parameters of the algorithm are: <ol style="list-style-type: lower-alpha">
<li>None for the sender of the message</li>
<li>An IV value for the recipient of the message.  (The IV value acts as the authentication tag.)</li>
</ol>
<p> </p>
</li>
<li>The data actually authenticated is: <ol style="list-style-type: lower-alpha">
<li>The authenticated data</li>
<li>The message data</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of data can be processed, you must know: <ol style="list-style-type: lower-alpha"><li>The authenticated attributes.</li></ol>
<p> </p>
</li>
<li>Before the first byte of authenticated data can be processed, you must know: nothing.</li>
</ol>

<p> </p>
<p id="rfc.section.3.10.p.3">The algorithm does not use a nonce value, instead the IV used for the counter mode is computed from the authenticated data and message data.  The IV is then emitted as the authentication tag.  Note that this also means that the message data must processed twice by the cryptographic code.  Once to do the authentication computation and produce the IV and one to do the counter mode encryption.</p>
<p id="rfc.section.3.10.p.4">This algorithm cannot be streamed by the sender.  Since the IV used for the counter mode encryption of the message data depends on all of the message data, the message data must actually be processed twice by the encryption algorithm.</p>
<p id="rfc.section.3.10.p.5">The algorithm can easily be streamed by the recipient. The requirement is that the authenticated attributes and the IV be presented to the recipient before the message data is presented.  The authentication check is then done by comparing the IV passed in with the IV computed.</p>
<h1 id="rfc.section.3.11">
<a href="#rfc.section.3.11">3.11.</a> XCBC: eXtended Cipher Block Chaining Encryption</h1>
<p id="rfc.section.3.11.p.1">eXtended Cipher Block Chaining Encryption is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interest to this discussion.</p>
<h1 id="rfc.section.3.12">
<a href="#rfc.section.3.12">3.12.</a> MAC-Authenticated Encryption</h1>
<p id="rfc.section.3.12.p.1">The MAC-Authenticated Encryption mode has been documented by Peter Gutmann.  This mode is documented in <a href="#GUTMANN">[GUTMANN]</a>.</p>
<p id="rfc.section.3.12.p.2">The characteristics of the algorithm are: </p>

<ol>
<li>The parameters of the algorithm are: <ol style="list-style-type: lower-alpha">
<li>A key derivation algorithm,</li>
<li>A keyed MAC algorithm,</li>
<li>An encryption algorithm</li>
</ol>
<p> </p>
</li>
<li>The data actually authenticated is: <ol style="list-style-type: lower-alpha">
<li>The encrypted message,</li>
<li>The authenticated attributes.</li>
</ol>
<p> </p>
</li>
<li>Before the first byte of the message data can be processed, you must know: nothing.</li>
<li>Before the first byte of the authenticated data can be processed, you must know: <ol style="list-style-type: lower-alpha"><li>The encrypted message data.</li></ol>
<p> </p>
</li>
</ol>

<p> </p>
<p id="rfc.section.3.12.p.3">This algorithm can easily be used in a streaming model by the sender.</p>
<p id="rfc.section.3.12.p.4">This algorithm can easily be used in a streaming model by the recipient.</p>
<p id="rfc.section.3.12.p.5">Note: In the series of messages that I exchanged with Peter during the design of this algorithm, one of the things he noted was that to make streaming easier he should put the authenticated attributes after the message data.  Thus the algorithm was designed to make sure that streaming worked well with the current encoding.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#criteria" id="criteria">My Assumptions</a>
</h1>
<p id="rfc.section.4.p.1">This section will list the set of criteria that I am using in making my conclusions.  Again, the most important thing in my mind is the ability to implement a streaming model for encode and decode operations.</p>
<p></p>

<ol>
<li>We want to implement using a single pass streaming module to encode and decode the structures.  There are many reasons to do so: <ol>
<li>The amount of resources used is minimized by not buffering the entirety of the message at each level of wrapping.</li>
<li>The fact that not all messages are DER encode means that there is no single buffer in the original message that can be treated as a single input buffer.</li>
<li>The message may be feed to the encoder/decode in chunks due to the way things are read from files, the fact that nodes in trees are emitted serially or the fact that removal of MIME content transfer encoding is normally done on small buffers.</li>
</ol>
<p> </p>
<ul class="empty">
<li>There is one argument that says one should buffer up the entire encrypted buffer, decrypt in one chunk and then pass on the data in one piece.  Since the name of the algorithm class is encrypted and authenticated, one should perhaps actually authenticate that the data is correct prior to releasing the data for additional processing.  </li>
<li>I believe that it is sufficient to check that the encrypted buffer has been authenticated prior to acting on the data contained in the encrypted buffer.  Thus I believe it makes sense to continue doing the decode and either fail on the decode operation and propagate a failure up either when the decode itself fails or when the authentication check is actually made.  In this way it is no different than the processing of a signed message where the signature may be checked long after the message has been fully decoded.  In fact this is the normal case for an S/MIME client where the content is often viewable with some indication that the validation of the signature failed for some reason.</li>
</ul>
<p> </p>
</li>
<li>The relative lengths of the data to be encrypted and the attributes to be protected are such that the encrypted data is generally much larger than the attributes.  Thus if one has to cache one in a streaming mode, it is preferable to cache the attributes.</li>
</ol>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#opinion" id="opinion">Conclusions</a>
</h1>
<p id="rfc.section.5.p.1">I now look again at the arguments presented in <a href="#history">Section 2</a> and review the arguments presented.  All of the opinions in this section are mine and may or may not be represent those of any other people.  <a href="#rebuttal">Section 6</a> contains the opinions of other people.</p>
<div id="#rfc.figure.2"></div>
<pre>
A foolish consistency is the hobgoblin of little minds, 
adored by little statesmen and philosophers and divines.
                          (Ralph Waldo Emerson 1841)</pre>
<p></p>

<ol>
<li>Consistency with the existing CMS data types: <ul class="empty"><li>This criteria should only be used a tie breaker in the event that all other criteria come out equal.  When looking at this argument I am reminded of the following: </li></ul>
<p> </p>
</li>
<li>Authenticated attributes that are derived from the message content: <ul class="empty">
<li>This argument is slightly more believable than it was before I began this document as I now have an attribute which is derived from the message content, however this attribute is the length of the message data and in order to be useful it needs to be placed before the message data is consumed. (See <a href="#CCM">Section 3.1</a>.)</li>
<li>I found this argument to be difficult to believe at the time it was presented, and I have not changed my mind since then.  The argument that this means the authenticated attributes comes second would mean that this is an attribute that is attested to by the sender, but is not verified in any way by the recipient.  If the recipient needed to do any processing then it would be much more desirable to have the attribute occur before the message data so that the recipient can setup to do the necessary processing prior to processing the message data.</li>
<li>In the process of writing <a href="#XOR-HASH">[XOR-HASH]</a> I have become convinced that there is a fundamental problem which is going to be coming in the future with the signed data structure.  Since the recipient does not "know" the correct set of hash algorithms to be used when processing a message the vast majority look at the list presented and then augment it with a number of different algorithms.  This often means that one is computing four or five different hash functions on the content just on the off-chance that they may be needed.  Many systems will not attempt a recovery if they find a signer info structure which uses a hash algorithm they did not realize that they needed even if it is known to the system because of the work involved in doing a restart after having parsed in all of the data.  This means that similar behavior should be expected for any attributes that need to be validated by the recipient after having been generated by the sender.  The problem is worse since there is no similar field to the set of digest algorithms that can filled at the beginning of a signed data object.</li>
<li>I believe that this criteria was mis-applied.  The issues of how a recipient was supposed to deal with these types of attributes was completely ignored in the decision process and it should have had paramount importance.</li>
</ul>
<p> </p>
</li>
<li>The decision should be dictated by Algorithm Characteristics: <ul class="empty">
<li>Looking at the taxonomy of algorithms that is presented in <a href="#algs">Section 3</a> we come up with the following results: <ul class="empty">
<li>The algorithms which cannot be easily streamed are: CCM, SIV (for sender)</li>
<li>The algorithms which need attributes before the message body are: CWC (serialized implementation), GCM, SIV (for recipient), CCM (for recipient in special circumstances)</li>
<li>The algorithms which need the message body before the attributes are: MAC-Authenticated</li>
<li>The algorithms which can have either the body or the attributes first are: CWC (parallelized implementation), EAX, OCB</li>
</ul>
<p> </p>
</li>
<li>We can see that CCM and SIV will never be easily streamed for the sender. It is unfortunate for people wanting to stream the CCM is one of the two algorithms that we have standardized on.  It should be noted that both of these algorithms can be setup to be streamed for the recipient of the message, but CCM requires an additional restriction to be applied.  If either of these algorithms is used then the entire question discussed above about a sender processing the content on sending would be academic as the message data needs to be buffered anyway.</li>
<li>We have only one algorithm were the attributes are logically placed after the message data, that being the MAC-Authenticated, which was explicitly designed to be that way so that it could be streamed using the current data layout.  Additionally there are two algorithms that are agnostic of the order of attributes and data plus one that can be implemented to be agnostic.</li>
<li>For recipients, only the MAC-Authenticated algorithm necessitates that the attributes be cached until the message data has been processed.  All of the other algorithms can be made work with the attributes preceding the message data without any problems.</li>
<li>In current practice, and in part because of NIST standardization, the only two modes that have significant use are the CCM and GCM modes.  It is possible that the MAC-Authenticated mode will also get traction since it is easy for people to understand and implement.  This should also be taken into consideration when looking at the algorithm characteristics.</li>
<li>If we had done this analysis at the time the decision was made then we should have made the decision to place the attributes first.</li>
</ul>
<p> </p>
</li>
<li>Resource requirements for the sender and recipient: <ul class="empty"><li>It is no more likely that the sender of a message is resource constrained than it is for the recipient of the message to be resource constrained.  This means that it is better for a set of algorithms and layout to be chosen that will work well in a streaming model under normal circumstances than to optimize for either the sender or the recipient.</li></ul>
<p> </p>
</li>
<li>Relative frequency of processing: <ul class="empty">
<li>In my opinion, most of the time messages that are created using an authenticated encryption algorithm will be decrypted by at least one recipient.  Messages which are not decrypted will exist, either from being lost in the ether or from being cached until needed, but these will be the smallest part of the set.  Messages which need to be decrypted multiple times by a single recipient will generally be a small number as well, unless it because part of the S/MIME standard.  However I believe that a significant number of messages will be created that will have multiple recipients.  This may be done by creating multiple lock boxes up front, or by creating the lock boxes on demand in cases where it does not matter than a traffic analysis can be done that multiple recipients have gotten the same message.  (An example of this might be sending a firmware upgrade to multiple devices, where the message is transferred on demand and it does not matter that an observer can see that the same set of firmware is being installed on multiple machines.  This would be something that could probably be assumed anyway.)</li>
<li>I therefore think that overall more messages will be decoded and decrypted than encrypted and encoded.  This would mean that a bias should be placed for the recipients of messages not the sender of messages in making decisions.</li>
</ul>
<p> </p>
</li>
</ol>

<p> </p>
<p id="rfc.section.5.p.3">Based on the above, I would say that we should modify the order of these fields in the event that the document is updated.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#rebuttal" id="rebuttal">Responses</a>
</h1>
<p id="rfc.section.6.p.1">An opportunity was provided to the Russ Housley as the author of <a href="#CMS-AED">[CMS-AED]</a> and to others that were involved on the mailing list to provide a formal response.  Nobody took advantage of the offer.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Security Considerations</h1>
<p id="rfc.section.7.p.1">This document discusses a security related document, however it makes no changes to the document.  As such there are no actual security implications for this document.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> IANA Considerations</h1>
<p id="rfc.section.8.p.1">No action by IANA is required for this document.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3610">[RFC3610]</b></td>
<td class="top">
<a>Whiting, D.</a>, <a>Housley, R.</a> and <a>N. Ferguson</a>, "<a href="http://tools.ietf.org/html/rfc3610">Counter with CBC-MAC (CCM)</a>", RFC 3610, September 2003.</td>
</tr>
<tr>
<td class="reference"><b id="CMS">[CMS]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="http://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>", RFC 5652, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="CMS-AED">[CMS-AED]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="http://tools.ietf.org/html/rfc5083">Cryptographic Message Syntax (CMS) Authenticated-Enveloped-Data Content Type</a>", RFC 5083, November 2007.</td>
</tr>
<tr>
<td class="reference"><b id="GUTMANN">[GUTMANN]</b></td>
<td class="top">
<a>Gutmann, P.</a>, "<a>Using MAC-authenticated Encryption in the Cryptographic Message Syntax (CMS)</a>", .</td>
</tr>
<tr>
<td class="reference"><b id="NIST-800-38C">[NIST-800-38C]</b></td>
<td class="top">
<a>Dworkin, M.</a>, "<a>Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality</a>", NIST Special Publication 800-38C, May 2004.</td>
</tr>
<tr>
<td class="reference"><b id="NIST-800-38D">[NIST-800-38D]</b></td>
<td class="top">
<a>Dworkin, M.</a>, "<a>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</a>", NIST Special Publication 800-38D, November 2007.</td>
</tr>
<tr>
<td class="reference"><b id="CWC">[CWC]</b></td>
<td class="top">
<a>Kohno, T.</a>, <a>Viega, J.</a> and <a>D. Whiting</a>, "<a>The CWC authenticated encryption (associated data) mode</a>", May 2003.</td>
</tr>
<tr>
<td class="reference"><b id="EAX">[EAX]</b></td>
<td class="top">
<a>Bellare, M.</a>, <a>Rogaway, P.</a> and <a>D. Wagner</a>, "<a>EAX: A Conventional Authenticated-Encryption Mode</a>", 2003.</td>
</tr>
<tr>
<td class="reference"><b id="OCB-AD1">[OCB-AD1]</b></td>
<td class="top">
<a>Rogaway, P.</a>, "<a>The Associated-Data Problem</a>", November 2001.</td>
</tr>
<tr>
<td class="reference"><b id="SIV">[SIV]</b></td>
<td class="top">
<a>Rogaway, P.</a> and <a>T. Shrimpton</a>, "<a>The SIV Mode of Operation for Deterministic Authenticated-Encryption (Key Wrap) and Misuse-Resistant Nonce-Based Authenticated-Encryption</a>", August 2007.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="XOR-HASH">[XOR-HASH]</b></td>
<td class="top">
<a>Schaad, J</a>, "<a href="http://tools.ietf.org/html/draft-schaad-smime-hash-experiment-06">Experiment: Hash functions with parameters in CMS and S/MIME</a>", Internet-Draft draft-schaad-smime-hash-experiment-06, January 2011.</td>
</tr></tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jim Schaad</span> 
	  <span class="n hidden">
		<span class="family-name">Schaad</span>
	  </span>
	</span>
	<span class="org vcardline">Soaring Hawk Consulting</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jimsch@augustcellars.com">jimsch@augustcellars.com</a></span>

  </address>
</div>

</body>
</html>