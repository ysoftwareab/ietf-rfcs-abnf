 



Network Working Group                                      S.K.Srivastav
Internet-Draft                                            September 2017
Intended status: Standards Track
Expires: March 2018


            YANG extension Statements for formulae modeling
                    draft-srivastav-netmod-formulae-00

Abstract


   Operational data can be divided into multiple categories like i)
   state data, ii) raw performance counter, iii) Derived/calculated
   Counters by arithmetic operation on raw performance counters also
   referred as KPIs. Existing YANG built-in-types only define the way to
   model the state data and raw performance counters but have no
   provision for modelling derived performance counters representing an
   equivalent of a simple mathematical formula.

   This document define extensions for the modeling language YANG as new
   language statements, which introduce a method to model KPIs aka
   mathematical expression in YANG data modeling language and describes
   the syntax and semantics of newly added .

   As KPIs require limited number of mathematical operations viz. +, /,
   -, *,minimum, maximum, summation are needed. Hence, +, /, -,
   *,minimum, maximum, summation are needed. Hence, our proposal is to
   enhance YANG to support formula based nodes for these basic
   arithmetic operations. YANG is enhanced to model KPI formulae with
   basic arithmetic operations.


Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

 


Srivastav, et al.           Standards Track                     [Page 1]

Internet-Draft                                            September 2017


Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 3.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


































 


Srivastav, et al.           Standards Track                     [Page 2]

Internet-Draft                                            September 2017


Table of Contents

   1.  Introduction and overview . . . . . . . . . . . . . . . . . .  5
   2.  NETCONF Enhancement. . . . . . . . . . . . . . . . . . . . . . 5
   3.  MATH types Statements. . . . . . . . . . . . . . . . . . . . . 5
       3.1.  The "mt:math" Statement . . . . . . . .  . . . . . . . . 5
             3.1.1.  The mt:math's Substatements. . . . . . . . . . . 5
       3.2.  The "mt:addition " Statement. . . . . . . . . . . . . . .6
             3.2.1.  The mt:addition 's Substatements. . . . . . . . .6
             3.2.2.  The mt:addend Statements. . . . . . . . . . . . .6
                     3.2.2.1   The mt:addend Substatements. . . .  . .6
       3.3.  The "mt:subtraction" Statement. . . . . . . . . . . . . .6
             3.3.1.  The mt:subtraction's Substatements. .. . . . . . 7
             3.3.2.  The "mt:minuend" Statement. . . . . . . . . . . .7
                     3.3.2.1  The "mt:minuend" Substatements . . . . .7
             3.3.3.  The "mt:subtrahend" Statement. .  . . . . . . . .7
                     3.3.3.1  mt:subtrahend Substatements. . . . . . .7
       3.4.  The "mt:multiplication" Statement. . . . . . . . . . . . 8
             3.4.1.  The mt:multiplication's Substatements . . . . . .8
             3.4.2.  The "mt:multiplier" Statement. . . . . . . . . . 8
                     3.4.2.1. mt:multiplier Substatements. . . . . . .8
       3.5.  The "mt:division" Statement. . . . . . . .  . . . . . . .9
             3.5.1.  The mt:division's Substatements. . . . . . . . . 9
             3.5.2.  The "mt:dividend" Statement. . . . . . . . . . . 9
                     3.5.2.1. mt:dividend Substatements. . . . . . . .9
             3.5.3.  The "mt:divisor" Statement. . . . . . . .  . . . 9
                     3.5.3.1. mt:divisor Substatements. . . . . . . . 9
       3.6.  The "mt:summation" Statement. . . . . . . . . . . . . . .10
             3.6.1.  The mt:summation's Substatements. . . . . . . . .10
             3.6.2.  The "mt:loop" Statement. . . . . . . . . . . . . 10
                     3.6.2.1 mt:loop Substatements.. . . . . . . . . .10
                     3.6.2.2 Example. . . . . . . . . . . . . . . . . 10
       3.7.  The "mt:min" Statement. . . . . . . . . . . . . . . . . .11
             3.7.1.  The mt:min's Substatements. . . . . . . . . . . .11
             3.7.2.  The mt:event Statement. . . . . . . . . . . . . .11
             3.7.3.  The mt:event's Substatements. . . . . . . . . . .11
             3.7.4.  Example. . . . . . . . . . . . . . . . . . . . . 12
             3.7.5.  Example. . . . . . . . . . . . . . . . . . . . . 12
             3.7.6.  Example. . . . . . . . . . . . . . . . . . . . . 13
       3.8.  The "mt:max" Statement. . . . . . . . . . . . . . . . . .14
             3.8.1.  The mt:max's Substatements. . . . . . . . . . . .14
             3.8.2.  Example. . . . . . . . . . . . . . . . . . . . . 14
             3.8.3.  Example. . . . . . . . . . . . . . . . . . . . . 15
             3.8.4.  Example. . . . . . . . . . . . . . . . . . . . . 16
       3.9.  The "mt:const" Statement. . . . . . . . . . . . . . . . .16
             3.9.1.  The mt:const's Substatements. . . . . . . . . . .16
       3.10. Usage example of expression statements. . . . . . . . . .16
             3.10.1. Sample Example. . . . . . . . . . . . . . . . . .16
 


Srivastav, et al.           Standards Track                     [Page 3]

Internet-Draft                                            September 2017


             3.10.2. 3GPP Standard formula(3GPP TS 32.450) . . . . . .19
       3.11. YIN. . . . . . . . . . . . . . . . . . . . . . . . . . . 20
             3.11.1. Example. . . . . . . . . . . . . . . . . . . . . 21
       3.12. YANG ABNF Grammar. . . . . . . . . . . . . . . . . . . . 22
       3.13. XML Mapping Rules. . . . . . . . . . . . . . . . .  . . .25
   4.  Extension Definition Module. . . . . . . . . . . . . . . . . . 25
   5.  IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 27
   6.  Security Considerations . . . . . . . . . . . . . . . . . . . .27
   7.  References. . . . . . . . . . . . . . . . . . . . . . . . . .  28
       7.1.  Normative References . . . . . . . . . . . . . . . . . . 28
   Authors' Addresses. . . . . . . . . . . . . . . . . . . . . . . . .28





































 


Srivastav, et al.           Standards Track                     [Page 4]

Internet-Draft                                            September 2017


1. Introduction and Overview

   YANG is a data modeling language originally designed to model
   configuration and state data manipulated by the Network Configuration
   Protocol (NETCONF), NETCONF Remote Procedure Calls, and NETCONF
   notifications [RFC6241].
   This document define and describes the syntax and semantics of new
   YANG extension statements for expression modelling.
   In future, telco's will be moving towards highly automated
   virtualized network to get lesser vender dependency and to have
   freedom to change and deploy services dynamically in less time. To do
   that they need good statistics and highly adaptable analytics engine
   that can adapt KPIs for new/changed services. They can not wait to
   get analytic engine changed to support new/Change service. To achieve
   that kind of automation and less time to market in service deployment
   in telco network, formula modelling in yang is necessary. In summary
   Formula modelling in standard helps to develop generic/highly
   adaptable Analytics Engine framework for future Telco network which
   learns the formula on fly and apply on received statistics.
   Note that this document does not obsolete RFC 6020 [RFC6020].

2.  NETCONF Enhancement

   To support mathematical exprssion with enhanced YANG DML, NETCONF
   protocol should be enhanced to parse and understand the newly added,
   enhanced extension statements as described in below sections.
   NETCONF protocol should exchange its mathematical expression
   capabilty with client establishing session.

3. MATH types Statements

   This draft proposes definition of math type extension statement using
   YANG extension and method to model mathematical expression using
   those new defined statements.

3.1. The "mt:math" Statement

   This statement allows a module or submodule to define a mathematical
   expression in a schema tree. It takes one argument, which is an
   identifier, followed by a block of substatements that holds detailed
   mathematical expression. This node is always root of mathematical
   expression tree in YANG.

3.1.1 The mt:math's Substatements

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
 


Srivastav, et al.           Standards Track                     [Page 5]

Internet-Draft                                            September 2017


   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   | mt:summation     | 3.6            | 0..1        |
   +------------------+----------------+-------------+

3.2. The "mt:addition" Statement

   This statement allows a module or submodule to define a mt:addition 
   node in a schema tree of mathematical expression. It takes one
   argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

   3.2.1 The mt:addition 's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 0..1        |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:addend     | 3.2.1          | 2..n        |
   +---------------+----------------+-------------+

   3.2.2 The mt:addend Statement

   This substatement specifies name or refernce of node to be added. It
   takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.2.2.1 mt:addend Substatement's

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   +------------------+----------------+-------------+

3.3. The "mt:subtraction" Statement

   This statement allows a module or submodule to define a
 


Srivastav, et al.           Standards Track                     [Page 6]

Internet-Draft                                            September 2017


   mt:subtraction node in a schema tree of mathematical expression.It
   takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.3.1 The mt:subtraction's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 0..1        |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:minuend    | 3.3.2          | 1           |
   | mt:subtrahend | 3.3.3          | 1           |
   +---------------+----------------+-------------+

3.3.2 The "mt:minuend" Statement

   This substatement specifies name or refernce of mt:minuend node. It
   takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.3.2.1 mt:minuend Substatement's

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   +------------------+----------------+-------------+

3.3.3 The "mt:subtrahend" Statement

   This substatement specifies name or refernce of mt:subtrahend node.
   It takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.3.3.1 mt:subtrahend substatement's

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
 


Srivastav, et al.           Standards Track                     [Page 7]

Internet-Draft                                            September 2017


   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   +------------------+----------------+-------------+

3.4. The "mt:multiplication" Statement

   This statement allows a module or submodule to define a
   mt:multiplication node in a schema tree of mathematical expression.
   It takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.4.1 The mt:multiplication's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 0..1        |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:multiplier | 3.4.2          | 2..n        |
   +---------------+----------------+-------------+

3.4.2 The "mt:multiplier" Statement

   This substatement specifies name or refernce of mt:multiplier node.
   It takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.4.2.1 mt:multiplier substatement's

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   +------------------+----------------+-------------+

3.5. The "mt:division" Statement

   This statement allows a module or submodule to define a mt:division
   node in a schema tree of mathematical expression. It takes one
   argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

 


Srivastav, et al.           Standards Track                     [Page 8]

Internet-Draft                                            September 2017


3.5.1 The mt:division's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 0..1        |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:dividend   | 3.5.2          | 1           |
   | mt:divisor    | 3.5.3          | 1           |
   +---------------+----------------+-------------+

3.5.2 The "mt:dividend" Statement

   This substatement specifies name or refernce of mt:dividend node. It
   takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.5.2.1 mt:dividend substatement's

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   +------------------+----------------+-------------+

3.5.3 The "mt:divisor" Statement

   This substatement specifies name or refernce of mt:divisor node. It
   takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.5.3.1 mt:divisor substatement's

   +------------------+----------------+-------------+
   | substatement     | section        | cardinality |
   +------------------+----------------+-------------+
   | leaf             | rfc6020 7.10   | 0..1        |
   | mt:subtraction   | 3.3            | 0..1        |
   | mt:addition      | 3.2            | 0..1        |
   | mt:division      | 3.5            | 0..1        |
   | mt:multiplication| 3.4            | 0..1        |
   | Description      | rfc6020 7.19.3 | 0..1        |
   +------------------+----------------+-------------+
 


Srivastav, et al.           Standards Track                     [Page 9]

Internet-Draft                                            September 2017


3.6. The "mt:summation" Statement

   This statement allows a module or submodule to define a Summation
   node in a schema tree of mathematical expression. It takes one
   argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression.

3.6.1 The mt:summation's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 1           |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:loop       | 3.6.2          | 1..n        |
   +---------------+----------------+-------------+

3.6.2 The "mt:loop" Statement

   This substatement specifies mt:summation index refernce. It takes one
   argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression. leaf
   substatement of this statement can only be of type leafref.Range of
   mt:summation index will be the range of refered leaf.

3.6.2.1 mt:loop substatement's

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 0..1        |
   | Description   | rfc6020 7.19.3 | 0..1        |
   +---------------+----------------+-------------+

3.6.2.2 Example

   sum a, where a goes from 1 to 5.
   container formula {
      list elements{
         leaf a {
            type uint32{
               range "1..5"
            }
         }
      } mt:math suma {
         mt:summation a {
            mt:loop index {
               leaf a {
 


Srivastav, et al.           Standards Track                    [Page 10]

Internet-Draft                                            September 2017


                  type leafref {
                     path "../../../elements/a";
                  }
               }
            }
         }
      }
   }

3.7. The "mt:min" Statement

   This statement allows a module or submodule to define a Minimum node
   in a schema tree of mathematical expression. It takes one argument,
   which is an identifier, followed by a block of substatements that
   holds detailed mathematical expression i.e set of nodes which
   reference to other node.
   Minimum is done on a set of values. There are three categories of
   sets : 1. Set consist different leafs. 2. Set consist different
   values of a leaf defined in a list. 3. Set consist intermediate
   values of a leaf. By modeling this server/application can learn
   that minimum of respective values to be calculated and should be
   marked as minimum when server/application defined event occurs.

3.7.1 The mt:min's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 1           |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:loop       | 3.6.2.1        | 1           |
   | mt:event      | 3.7.2          | 1           |
   +---------------+----------------+-------------+

3.7.2 The mt:event statement

   This substatement specifies calculation of minimum on intermediate
   value of a leaf and to be committed on application defined event.It
   takes one argument, which is an identifier, followed by a block of
   substatements that holds detailed mathematical expression. leaf
   substatement of this statement can only be of type leafref.

3.7.3 The mt:event's Substatements
   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 1           |
   | Description   | rfc6020 7.19.3 | 0..1        |
 


Srivastav, et al.           Standards Track                    [Page 11]

Internet-Draft                                            September 2017


   +---------------+----------------+-------------+

3.7.4 Example

       Minimum to be calculated over a set of different leafs.
       x = min(a,b,c)
       container formula {
          list elements{
             leaf a {
                type uint32{
                   range "1..5"
                }
             }    leaf b {
                type uint32{
                   range "1..5"
                }
             }    leaf c {
                type uint32{
                   range "1..5"
                }
             }
          mt:math formula {
             mt:min x {
                leaf a{
                   type leafref {
                      path "../../../elements/a";
                   }
                }    leaf b{
                   type leafref {
                      path "../../../elements/b";
                   }
                }    leaf c{
                   type leafref {
                      path "../../../elements/c";
                   }
                }
             }
          }
       }

3.7.5  Example

       Minimum to be calculated over a set of differen value of a
   leaf defined in a list.
       x = min(a) where a is a leaf in list.
       container formula {
          list elements{
             leaf a {
 


Srivastav, et al.           Standards Track                    [Page 12]

Internet-Draft                                            September 2017


                type uint32{
                   range "1..5"
                }
             }    leaf b {
                type uint32{
                   range "1..5"
                }
             }    leaf c {
                type uint32{
                   range "1..5"
                }
             }
          }
          mt:math formula {
             mt:min x {
                mt:loop index {
                   leaf a {
                      type leafref {
                         path "../../../../elements/a";
                      }
                   }
                }
             }
          }
       }

3.7.6  Example

       Minimum to be calculated over a intermediate values of a leaf,   
   when a perticuler mt:event occurs.
       x = min(a) where x is mt:min of intermediate values of a.
       container formula {
          list elements{
             leaf a {
                type uint32{
                   range "1..5"
                }
             }    mt:math formula {
                mt:min x {
                   mt:event period{
                      leaf a {
                         type leafref {
                            path "../../../a";
                         }
                      }
                   }
                }
             }
 


Srivastav, et al.           Standards Track                    [Page 13]

Internet-Draft                                            September 2017


          }
       }

3.8. The "mt:max" Statement

   This statement allows a module or submodule to define a Maximum node
   in a schema tree of mathematical expression. It takes one argument,
   which is an identifier, followed by a block of substatements that
   holds detailed mathematical expression i.e set of nodes which
   reference to other node.
   Maximum is normally done a set of values. There are three categories
   of sets : 1. Set consist different leafs. 2. Set consist different
   values of a leaf defined in a list. 3. Set consist intermediate
   values of a leaf. By modeling this server/application can learn
   that maximum of respective values to be calculated and should be
   marked as maximum when server/application defined event occurs.

3.8.1 The mt:max's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | leaf          | rfc6020 7.10   | 1           |
   | Description   | rfc6020 7.19.3 | 0..1        |
   | mt:loop       | 3.6.2.1        | 1           |
   | mt:event      | 3.7.2          | 1           |
   +---------------+----------------+-------------+

3.8.2 Example

       Maximum to be calculated over a set of different leafs.
       x = max(a,b,c)
       container formula {
          list elements{
             leaf a {
                type uint32{
                   range "1..5"
                }
             }    leaf b {
                type uint32{
                   range "1..5"
                }
             }    leaf c {
                type uint32{
                   range "1..5"
                }
             }
          mt:math formula {
 


Srivastav, et al.           Standards Track                    [Page 14]

Internet-Draft                                            September 2017


             mt:max x {
                leaf a{
                   type leafref {
                      path "../../../elements/a";
                   }
                }    leaf b{
                   type leafref {
                      path "../../../elements/b";
                   }
                }    leaf c{
                   type leafref {
                      path "../../../elements/c";
                   }
                }
             }
          }
       }

3.8.3  Example

       Maximum to be calculated over a set of differen value of
       A leaf defined in a list.    x = max(a) where a is a leaf in
   list.
       container formula {
          list elements{
             leaf a {
                type uint32{
                   range "1..5"
                }
             }    leaf b {
                type uint32{
                   range "1..5"
                }
             }    leaf c {
                type uint32{
                   range "1..5"
                }
             }
          }
          mt:math formula {
             mt:min x {
                mt:loop index {
                   leaf a {
                      type leafref {
                         path "../../../../elements/a";
                      }
                   }
                }
 


Srivastav, et al.           Standards Track                    [Page 15]

Internet-Draft                                            September 2017


             }
          }
       }

3.8.4  Example

       Maximum to be calculated over a intermediate values of a leaf,   
   when a perticuler mt:event occurs.
       x = max(a) where x is mt:min of intermediate values of a.
       container formula {
          list elements{
             leaf a {
                type uint32{
                   range "1..5"
                }
             }    mt:math formula {
                mt:max x {
                   mt:event period{
                      leaf a {
                         type leafref {
                            path "../../../a";
                         }
                      }
                   }
                }
             }
          }
       }

3.9.  The "mt:const" Statement

   This statement allows a module or submodule to define a constant leaf
   node in a schema tree of mathematical expression. This statement can
   be used only inside a leaf node.leaf with mt:const statment is non-
   modifiable and should hold the value defined using mt-const
   statement.

3.9.1 The mt:const's Substatements

   +---------------+----------------+-------------+
   | substatement  | section        | cardinality |
   +---------------+----------------+-------------+
   | Description   | rfc6020 7.19.3 | 0..1        |
   +---------------+----------------+-------------+

3.10. Usage example of expression statements

   3.10.1 Sample Example
 


Srivastav, et al.           Standards Track                    [Page 16]

Internet-Draft                                            September 2017


   x=((a+b)-(c-d))/(e*100)
   container formula {
      leaf a {
         type int32;
      }
      leaf b {
         type int32;
      }
      leaf c {
         type int32;
      }
      leaf d {
         type int32;
      }
      leaf e {
             type int32;
      }
      mt:math x {
         leaf x {
            type int32;
            description "x=((a+b) - (c-d)/(e*100))";
         }
         mt:division divNode {
            mt:dividend dividendNode {
               mt:subtraction subNode {
                  mt:minuend minuendNode {
                     leaf minuendNodeVal {
                        type int32;
                        description "Can be used to store
                        intermediate value a+b"
                     }
                     mt:addition additionNode {
                        mt:addend a {
                           leaf a {
                              type leafref {
                                 path "/formula/a";
                              }
                           }
                        }
                        mt:addend b {
                           leaf b {
                              type leafref {
                                 path "/formula/b";
                              }
                           }
                        }
                     }
                  }
 


Srivastav, et al.           Standards Track                    [Page 17]

Internet-Draft                                            September 2017


                  mt:subtrahend subtrahendNode {
                     leaf subtrahendNodeVal {
                        type int32;
                        description "Can be used to
                        store intermediate value c-d";
                     }
                     mt:subtraction subNode {
                        mt:minuend minuendNode{
                           leaf c{
                              type leafref{
                                 path "/formula/c";
                              }
                           }
                        }
                        mt:subtrahend subtrahendNode {
                           leaf d {
                              type leafref{
                                 path "/formula/d";
                              }
                           }
                        }
                     }
                  }
               }
            }
            mt:divisor divisorNode {
               mt:multiplication multiplicationNode {
                  leaf mt:subtrahendNodeVal {
                     type int32;
                     description "Can be used to store intermediate
                     value e * 100"
                  }
                  mt:multiplier multiplierNodeOne {
                     leaf e {
                        type leafref {
                           path "/formula/e";
                        }
                     }
                  }
                  mt:multiplier multiplierNodeTwo {
                     leaf const {
                        mt:const 100;
                        type uint32;
                     }
                  }
               }
            }
         }
 


Srivastav, et al.           Standards Track                    [Page 18]

Internet-Draft                                            September 2017


      }
   }

3.10.2 3GPP Standard formula(3GPP TS 32.450 V14.0.0(2017-04))

   MobilitySuccessRate for QCI x =
               ((HO.ExeSucc for QCI x/HO.ExeAtt for QCI x)
               *(HO.PrepSucc for QCI x /HO.PrepAtt for QCI x) * 100)
      list MobiltySuccess {
         key QCI;
         leaf QCI {
            leaf int32;
         }
         leaf  HOExeSucc {
            type int32;
         }
         leaf HOExeAtt  {
            type int32;
         }
         leaf HOPrepSucc {
            type int32;
         }
         leaf HOPrepAtt {
            type int32;
         }
         mt:mathMobiltySuccessRate {
            leaf MobSuccRate {
               type int32;
               description "MobSuccRate=
               ((HOExeSucc/HOExeAtt)*(HOPrepSucc/HOPrepAtt))*100";
            }
            mt:multiplication multNode {
               mt:mulitiplier multiplerNodeOne {
                  mt:muliplication multNode {
                     mt:mulitiplier multiplerNodeOne {
                        leaf multiplerNodeOneVal {
                           type int32;
                           description "Can be used to
                           store value of HOExeSucc/HOExeAtt";
                        }
                        mt:division divNode {
                           mt:dividend divNode {
                              leaf HOExeSucc{
                                 type leafref {
                                    path  "/MobiltySuccess/HOExeSucc";
                                 }
                              }
                           }
 


Srivastav, et al.           Standards Track                    [Page 19]

Internet-Draft                                            September 2017


                           mt:divisor divsNode {
                              leaf HOExeAtt{
                                 type leafref {
                                    path "/MobiltySuccess/HOExeAtt";
                                 }
                              }
                           }
                        }
                     }
                     mt:mulitiplier multiplerNodeTwo {
                        leaf multiplerNodeTwoval {
                           type int32;
                           description "Can be used to store
                           value of HOPrepSucc/HOPrepAtt";
                        }
                        mt:division divNode {
                           mt:dividend divNode {
                              leaf HOPrepSucc{
                                 type leafref {
                                    path "/MobiltySuccess/HOPrepSucc";
                                 }
                              }
                           }
                           mt:divisor divsNode {
                              leaf HOPrepAtt{
                                 type leafref{
                                    path "/MobiltySuccess/HOPrepAtt";
                                 }
                              }
                           }
                        }
                     }
                  }
               }
               mt:mulitiplier multiplerNodeTwo {
                  leaf const {
                     mt:const 100;
                     type int32;
                  }
               }
            }
         }
      }

3.11. YIN

   A YANG module can be translated into an alternative XML-based syntax
   called YIN.  The translated module is called a YIN module.  This
 


Srivastav, et al.           Standards Track                    [Page 20]

Internet-Draft                                            September 2017


   section describes symmetric mapping rules between the two formats.
   The YANG and YIN formats contain equivalent information using
   different notations.  The YIN notation enables developers to
   represent YANG data models in XML and therefore use the rich set of
   XML-based tools for data filtering and validation, automated
   generation of code and documentation, and other tasks.  Tools like
   XSLT or XML validators can be utilized.
   The mapping between YANG and YIN does not modify the information
   content of the model. Comments and whitespace are not preserved.
      Mapping of arguments of the YANG statements.

      +------------------+---------------+-------------+
      | keyword          | argument name | yin-element |
      +------------------+---------------+-------------+
      | mt:math          | name          | false       |
      | mt:addition      | name          | false       |
      | mt:addend        | name          | false       |
      | mt:minuend       | name          | false       |
      | mt:subtrahend    | name          | false       |
      | mt:multiplication| name          | false       |
      | mt:mulitiplier   | name          | false       |
      | mt:division      | name          | false       |
      | mt:dividend      | name          | false       |
      | mt:divisor       | name          | false       |
      | mt:const         | value         | false       |
      | mt:summation     | name          | false       |
      | mt:loop          | name          | false       |
      | mt:min           | name          | false       |
      | mt:max           | name          | false       |
      | mt:event         | name          | false       |
      +------------------+---------------+-------------+

3.11.1 Example

      mt:division divNode {
         mt:dividend divNode {
            leaf HOPrepSucc{
               type leafref {
                  path "/MobiltySuccess/HOPrepSucc";
               }
            }
         }
         mt:divisor divsNode {
            leaf HOPrepAtt{
               type leafref{
                  path "/MobiltySuccess/HOPrepAtt";
               }
            }
 


Srivastav, et al.           Standards Track                    [Page 21]

Internet-Draft                                            September 2017


         }
      }

      Corresponding YIN
      <mt:division name="divNode">
        <mt:dividend name="divNode">
          <leaf name="HOPrepSucc">
            <type name="leafref">
              <path value="/MobiltySuccess/HOPrepSucc">
            </type>
          </leaf>
        </mt:dividend>
        <mt:divisor name="divsNode">
          <leaf name="HOPrepAtt">
            <type name="leafref">
              <path value="/MobiltySuccess/HOPrepAtt">
            </type>
          </leaf>
        </mt:dividend>
      </mt:division>

3.12. YANG ABNF Grammar

         mt:addition-stmt = mt:addition-keyword sep
                                  identifier-arg-str optsep
                          ("{" stmtsep
                             ;; these stmts can appear in any order
                             [mt:addend-stmt stmtsep]
                             [description-stmt stmtsep]
                             [leaf-stmt]
                          "}")
         mt:addend-stmt   = mt:addend-keyword sep identifier-arg-str
                                      optsep
                          ("{" stmtsep
                            [leaf-stmt]
                            ;; these stmts can appear in any order
                            [mt:addend-stmt stmtsep]
                            [mt:subtraction-stmt stmtsep]
                            [mt:division-stmt stmtsep]
                            [mt:multiplication-stmt stmtsep]
                            [description-stmt stmtsep]
                          "}")

         mt:subtraction-stmt = mt:subtraction-keyword sep
                                  identifier-arg-str optsep
                             ("{" stmtsep
                                [leaf-stmt]
                                [mt:minuend-stmt stmtsep]
 


Srivastav, et al.           Standards Track                    [Page 22]

Internet-Draft                                            September 2017


                                [mt:subtrahend-stmt stmtsep]
                                ;; these stmts can appear in any order
                                [description-stmt stmtsep]
                              "}")

         mt:minuend-stmt = mt:minuend-keyword sep identifier-arg-str
                            optsep
                            ("{" stmtsep
                              [leaf-stmt]
                              ;; these stmts can appear in any order
                              [mt:addition -stmt stmtsep]
                              [mt:subtraction-stmt stmtsep]
                              [mt:division-stmt stmtsep]
                              [mt:multiplication-stmt stmtsep]
                              [description-stmt stmtsep]
                            "}")

         mt:subtrahend-stmt = mt:subtrahend-keyword sep
                                  identifier-arg-str optsep
                            ("{" stmtsep
                              [leaf-stmt]
                              ;; these stmts can appear in any order
                              [mt:addition -stmt stmtsep]
                              [mt:subtraction-stmt stmtsep]
                              [mt:division-stmt stmtsep]
                              [mt:multiplication-stmt stmtsep]
                              [description-stmt stmtsep]
                            "}")

         mt:multiplication-stmt = mt:multiplication-keyword sep
                               identifier-arg-str optsep
                              ("{" stmtsep
                                [leaf-stmt]
                                [mt:multiplier-stmt stmtsep]
                                ;; these stmts can appear in any order
                                [description-stmt stmtsep]
                              "}")
         mt:multiplier-stmt = mt:multiplier-keyword sep
                                  identifier-arg-str optsep
                              ("{" stmtsep
                                [leaf-stmt]
                                ;; these stmts can appear in any order
                                [mt:addition -stmt stmtsep]
                                [mt:subtraction-stmt stmtsep]
                                [mt:division-stmt stmtsep]
                                [mt:multiplication-stmt stmtsep]
                                [description-stmt stmtsep]
                               "}")
 


Srivastav, et al.           Standards Track                    [Page 23]

Internet-Draft                                            September 2017


         mt:division-stmt = mt:division-keyword sep
                               identifier-arg-str optsep
                           ("{" stmtsep
                                [leaf-stmt]
                                [mt:dividend-stmt stmtsep]
                                [mt:divisor-stmt stmtsep]
                                [description-stmt stmtsep]
                            "}")
         mt:dividend-stmt = mt:dividend-keyword sep
                                identifier-arg-str optsep
                           ("{" stmtsep
                                [leaf-stmt]
                                ;; these stmts can appear in any order
                                [mt:addition -stmt stmtsep]
                                [mt:subtraction-stmt stmtsep]
                                [mt:division-stmt stmtsep]
                                [mt:multiplication-stmt stmtsep]
                                [description-stmt stmtsep]
                            "}")


         mt:divisor-stmt  = mt:divisor-keyword sep
                                identifier-arg-str optsep
                           ("{" stmtsep
                                [leaf-stmt]
                                ;; these stmts can appear in any order
                                [mt:addition -stmt stmtsep]
                                [mt:subtraction-stmt stmtsep]
                                [mt:division-stmt stmtsep]
                                [mt:multiplication-stmt stmtsep]
                                [description-stmt stmtsep]
                            "}")

         mt:summation-stmt = mt:summation-keyword sep
                                identifier-arg-str optsep
                           ("{" stmtsep
                                [leaf-stmt]/
                                [mt:loop-stmt]
                                [description-stmt stmtsep]
                            "}")
         mt:loop-stmt    = mt:loop-keyword sep identifier-arg-str
                                optsep
                           ("{" stmtsep
                               [leaf-stmt]
                               [description-stmt stmtsep]
                            "}")


 


Srivastav, et al.           Standards Track                    [Page 24]

Internet-Draft                                            September 2017


         mt:math-stmt      = mt:math-keyword sep identifier-arg-str 
                             optsep
                           ("{" stmtsep
                                [leaf-stmt]
                                [mt:addition -stmt]/
                                [mt:subtraction-stmt]/
                                [mt:division-stmt]/
                                [mt:multiplication-stmt]
                                [description-stmt stmtsep]
                            "}")
         mt:const-stmt = mt:const-keyword sep integer-value stmtend

         mt:event-stmt    = mt:event-keyword sep identifier-arg-str
                               optsep
                           ("{" stmtsep
                               [leaf-stmt]
                               [description-stmt stmtsep]
                            "}")
         mt:min-stmt    = mt:min-keyword sep identifier-arg-str optsep
                           ("{" stmtsep
                               1*(leaf-stmt)/
                               [mt:loop-stmt]/
                               [mt:event-stmt]
                               [description-stmt stmtsep]
                            "}")
         mt:max-stmt    = mt:max-keyword sep identifier-arg-str optsep
                           ("{" stmtsep
                               1*(leaf-stmt)/
                               [mt:loop-stmt]/
                               [mt:event-stmt]
                               [description-stmt stmtsep]
                            "}")

3.13.  XML Mapping Rules

      A NETCONF server that replies to a <get> or <get-config> request
      may choose to not send newly added nodes and its subnodes
      if does not have the leaf nodes which can hold a data.


4.  Extension Definition Module

   <CODE BEGINS>file "ietf-math-types@2017-09-12.yang"

    module ietf-math-types {

       namespace "urn:ietf:params:xml:ns:yang:ietf-math-types";
       prefix "mt";

 


Srivastav, et al.           Standards Track                    [Page 25]

Internet-Draft                                            September 2017


       organization "NETMOD WG";
       contact "Editor: Sudhanshu Kumar Srivastav
                        <sk.srivastav@samsung.com>";
       description
          "YANG extensions for math types.";
       revision 2017-09-12 {
               description "Initial revision.";
               reference "RFC 6080";
           }
       extension math {
           argument name;      
           description "Define a mathematical expression node";
       }
       extension addition {
           argument name;      
           description "Define a addition expression node";
       }
       extension addend {
           argument name;      
           description "Define a addend node";
       }
       extension subtraction {
           argument name;      
           description "Define a subtraction expression node";
       }
       extension minuend {
           argument name;      
           description "Define a minuend node";
       }
       extension subtrahend {
           argument name;      
           description "Define a subtrahend node";
       }
       extension multiplication {
           argument name;
           description "Define a multiplication expression node";
       }
       extension multiplier {
           argument name;      
           description "Define a multiplier node";
       }
       extension division {
           argument name;      
           description "Define a division expression node";
       }
       extension divisor {
           argument name;      
           description "Define a divisor node";
       }
 


Srivastav, et al.           Standards Track                    [Page 26]

Internet-Draft                                            September 2017


       extension dividend {
           argument name;      
           description "Define a dividend node";
       }
       extension event {
           argument name;      
           description "Define a event node";
       }
       extension loop {
           argument name;      
           description "Define a loop node";
       }
       extension min {
           argument name;      
           description "Define a min node";
       }
       extension max {
           argument name;      
           description "Define a max node";
       }
       extension const {
           argument name;      
           description "Define a const node";
       }
   }
    <CODE ENDS>

5. IANA Considerations

   This document registers one  URIs in the IETF XML registry.
   IANA   registered the following URIs, according to [RFC3688]:
   URI: "urn:ietf:params:xml:ns:yang:ietf-math-types"

   This document registers one module name in the
   "YANG Module Names" registry, defined in [RFC6020].
         name: ietf-math-types

         namespace: urn:ietf:params:xml:ns:yang:ietf-math-types

         prefix: mt

6. Security Considerations

   The YANG module "math-types" in this memo defines YANG
   extensions for math types new language statements.

   math types themselves do not have any security impact
   on the Internet.
 


Srivastav, et al.           Standards Track                    [Page 27]

Internet-Draft                                            September 2017


7. References

   7.1. Normative References
   [RFC6020]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
   the Network Configuration Protocol (NETCONF)", RFC 6020,
   DOI 10.17487/RFC6020, October 2010,
   <http://www.rfc-editor.org/info/rfc6020>.

Authors' Addresses

      Sudhanshu Kumar Srivastav
      Samsung R and D Institute
      Bangalore, KA 560037
      India
      Phone: (966) 339-4051
      EMail: sk.srivastav@samsung.com



































Srivastav, et al.           Standards Track                    [Page 28]
