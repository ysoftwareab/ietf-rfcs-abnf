<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Transport Layer Security (TLS) Snap Start</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Transport Layer Security (TLS) Snap Start">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">A. Langley</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Google Inc</td></tr>
<tr><td class="header">Expires: December 20, 2010</td><td class="header">June 18, 2010</td></tr>
</table></td></tr></table>
<h1><br />Transport Layer Security (TLS) Snap Start<br />draft-agl-tls-snapstart-00</h1>

<h3>Abstract</h3>

<p>
        This document describes a Transport Layer Security (TLS) extension for eliminating the latency of handshakes when the client has prior knowledge about the server. Unlike resumption, this prior knowledge is not secret and may be obtained from third parties and stored on disk for significant periods of time.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on December 20, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">2.</a>&nbsp;
Design<br />
<a href="#anchor2">3.</a>&nbsp;
Details<br />
<a href="#anchor3">4.</a>&nbsp;
Requirements Notation<br />
<a href="#anchor4">5.</a>&nbsp;
Snap Start Extension<br />
<a href="#anchor5">6.</a>&nbsp;
Active attack considerations<br />
<a href="#anchor6">7.</a>&nbsp;
Requirements on the application<br />
<a href="#anchor7">8.</a>&nbsp;
Interactions with the Session Tickets extension<br />
<a href="#anchor8">9.</a>&nbsp;
Interactions with OCSP stapling<br />
<a href="#anchor9">10.</a>&nbsp;
Interactions with client certificates<br />
<a href="#anchor10">11.</a>&nbsp;
Examples<br />
<a href="#anchor11">12.</a>&nbsp;
Prior work<br />
<a href="#anchor12">13.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor13">14.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">15.</a>&nbsp;
Normative References<br />
<a href="#anchor15">Appendix&nbsp;A.</a>&nbsp;
Changes<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
        Snap Start aims to remove the latency overhead of TLS handshakes in the case that the application protocol involves the client speaking first.  Currently, TLS handshaking imposes additional latency and is costly for time-sensitive applications.
      
</p>
<p>
        In order to achieve this, the initial flow from the client must contain application data and, therefore, everything needed for the server to complete a handshake and process it. Starting from this premise we can derive the essential features of Snap Start.
      
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Design</h3>

<p>
        At first we are only considering the case of a full handshake. Assume, for the sake of argument, a client that is capable of predicting the contents of a server's first handshake flow (i.e. the <tt>ServerHello</tt> message through to the <tt>ServerHelloDone</tt>). Such a client could send <tt>ClientKeyExchange</tt>, <tt>ChangeCipherSpec</tt> and <tt>Finished</tt> messages immediately following its <tt>ClientHello</tt>. It would then be able to transmit application data records and we have successfully eliminated the TLS handshake latency.
      
</p>
<p>
        However, several elements of the server's first handshake flow are unpredictable. Fundamentally, any ephemeral Diffie-Hellman based cipher suite is incompatible with Snap Start so the following assumes that the server is using non-ephemeral key agreement.
      
</p>
<p>
        The chosen cipher suite, compression method, supported extensions, ordering of those extensions, certificate etc are all somewhat unpredictable for a given server but are highly correlated across time. Given a previous handshake with the same server, assuming that it will make the same choices when presented with a similar <tt>ClientHello</tt> is sufficiently accurate to expect a very high rate of prediction of these elements of the handshake.
      
</p>
<p>
        The server's chosen session id is unpredictable. However, this can be eliminated by using <a class='info' href='#RFC5077'>Session Tickets<span> (</span><span class='info'>Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, &ldquo;Transport Layer Security (TLS) Session Resumption without Server-Side State,&rdquo; January&nbsp;2008.</span><span>)</span></a> [RFC5077]. When Session Tickets are in use the <tt>ServerHello</tt> doesn't include a session id and the <tt>NewSessionTicket</tt> message itself is not part of the first flow.
      
</p>
<p>
        Lastly, the <tt>server_random</tt> is unpredictable. The <tt>server_random</tt> exists to provide uniqueness and freshness. When the server picks a random value it can be assured that no previous TLS connection has ever used the same value. Therefore the connection cannot be a replay of the client's traffic. Additionally, the server knows when its unpredictable random value was created, relative to its local clock, and therefore knows that handshake hasn't been delayed for an arbitrary amount of time.
      
</p>
<p>
        In order for the <tt>server_random</tt> to be predictable by the client, it will have to be chosen by the client and suggested to the server. In order for the server to be assured of uniqueness, it will have to remember every <tt>server_random</tt> value that has been used so that it may reject duplicates. (Several methods of limiting the amount of state required for this are introduced below.)
      
</p>
<p>
        Even without Snap Start, an attacker can delay an application data record in an established connection. However, both parties to the connection are likely to timeout after some period of inactivity, bounding the amount of possible delay introduced. With Snap Start, since we are assuming that the client's initial flow includes a full handshake and application data, an attacker could arbitrarily delay the flow and have the server process the application data at a time of their choosing. As the server lacks an nonce it has no way of detecting this.
      
</p>
<p>
        Without a similar mechanism to bound the delay of a Snap Start handshake, an attacker could perform a pseudo-replay attack: a handshake is delayed until the client retries, but the first handshake can still be used to deliver the same application data a second time. Because of this (and for other reasons other reasons given below) we require some degree of clock synchronisation between the client and server with respect the the timestamp in the <tt>ClientHello</tt>. The level of synchronisation required is left to the application layer to determine although it's recommended that the permitted clock skew be shorter than the application's retry timeout.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Details</h3>

<p>
        The essential features of Snap Start are now established: the client predicts the server's handshake flow using a client suggested <tt>server_random</tt>, SessionTickets and knowledge from a previous connection to the same server.
      
</p>
<p>
        We now note that this functions for both full and abbreviated handshakes. The abbreviated handshake retains its lower computational requirements but both now complete in the same number of round trips.
      
</p>
<p>
        In order to limit the amount of state required for the server to reject repeated <tt>server_random</tt>s, we allow the server to bound this state temporally and spatially. In the temporal dimension, we define that the <tt>gmt_unix_time</tt> of the server random is taken from <tt>gmt_unix_time</tt> of the client's random value. The server may use this timestamp to reject all suggested random values outside some window around the current time.
      
</p>
<p>
        Spatially, we define that the subsequent eight bytes of the server's random value are the server's 'orbit' value. This value must be discovered by the client from a previous (non Snap Start) handshake. In the event that several, geographically separated servers share the same certificates, they may use different orbit values. This allows one to reject <tt>server_random</tt> values for the other without any communication between them. (The term 'orbit' was chosen only to be short and otherwise reasonably meaningless in this context.)
      
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Requirements Notation</h3>

<p>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
      
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Snap Start Extension</h3>

<p>
        A new extension type (<tt>snap_start(TBD)</tt>) is defined and MAY be included by the client in its <tt>ClientHello</tt> message. If, and only if, the server sees this extension in the <tt>ClientHello</tt>, it MAY choose to include the extension in its <tt>ServerHello</tt>.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
enum {
  snap_start(TBD), (65535)
} ExtensionType;
</pre></div>
<p>The <tt>extension_data</tt> field of a <tt>snap_start</tt> extension in a <tt>ClientHello</tt> MAY be empty.
</p>
<p>If the server chooses to echo a <tt>snap_start</tt> extension then it is indicating that it MAY support Snap Start on future connections. The contents of the <tt>extension_data</tt> in this case MUST be:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
struct {
  opaque orbit[8];
  CipherSuite snap_start_cipher_suite;
} ServerSnapStart;
</pre></div>
<p><tt>orbit</tt> is the server's current orbit value and <tt>snap_start_cipher_suite</tt> contains the CipherSuite value that the client should assume that the server will use in a Snap Start handshake.
</p>
<p>If the client wishes to attempt a Snap Start connection then it includes a non-empty <tt>snap_start</tt> extension in its <tt>ClientHello</tt>. If the extension is not empty, then its contents MUST be:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
struct {
  opaque orbit[8];
  opaque random_bytes[20];
  opaque predicted_server_handshake[8];
  // TLSCiphertext structures follow
} ClientSnapStart;
</pre></div>
<p>Following this, without a length prefix, the client may include one or more <tt>TLSCiphertext</tt> structures to be processed by the server in the case that the Snap Start is successful. These records are as described in <a class='info' href='#RFC5246'>RFC 5246<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> [RFC5246] section 6.2
</p>
<p>The <tt>orbit</tt> MUST contain an orbit value obtained from a previous connection to the same server. <tt>random_bytes</tt> MUST contain 20 random bytes from a cryptographic random source equal in strength to the one used for the <tt>client_random</tt>.
</p>
<p><tt>predicted_server_handshake</tt> MUST contain an <a class='info' href='#fnv1a'>FNV1a64<span> (</span><span class='info'>Noll, L., &ldquo;FNV hash,&rdquo; .</span><span>)</span></a> [fnv1a] hash of the server's predicted response flow. This hash is taken over the bytes of the <tt>Handshake</tt> structures, as defined in RFC 5246 section 7.4. If the client is attempting to resume a connection then this is calculated over the server's <tt>ServerHello</tt> message. Otherwise, this is calculated over all handshake messages from the <tt>ServerHello</tt> to the <tt>ServerHelloDone</tt> (inclusive). The client's prediction MUST assume that the server chooses its server random as detailed below. The client's prediction MUST also assume that the server includes a Snap Start extension with the same <tt>ServerSnapStart</tt> contents as previously observed.
</p>
<p>If the client's prediction is correct then the server MAY perform a Snap Start handshake. If the server wishes to perform a Snap Start handshake then it MUST form its <tt>random</tt> value from the <tt>gmt_unix_time</tt> of the client's <tt>random</tt>, followed by the server's orbit value, followed by the contents of <tt>random_bytes</tt> from the client's Snap Start extension.
</p>
<p>The server MUST NOT transmit any predicted handshake messages and MUST start processing records from the client's Snap Start extension. For the purposes of the Finished calculation, the client's <tt>ClientHello</tt> is hashed as if the <tt>snap_start</tt> extension were not included (the <tt>length</tt> field of the <tt>Handshake</tt> structure from RFC 5246 section 7.4, and the prefixed length of the <tt>extensions</tt> member of the <tt>ClientHello</tt> are updated accordingly). When processing records from the extension, they are hashed as usual. Once the set of records embedded in the <tt>ClientHello</tt> has been exhausted, the server resumes reading records from the network. Records must not be partially contained within the <tt>ClientHello</tt> and partially read from the network.
</p>
<p>(Since the <tt>ClientHello</tt> is likely to have a <tt>Finished</tt> message embedded within it, it cannot be hashed into the Finished calculation as normal as its contents would then depend in its own hash. One could consider hashing with the embedded hash zeroed out, however a <tt>Finished</tt> message is encrypted under the negotiated cipher suite and a CBC-based ciphersuite would spread the effects of the embedded hash beyond its apparent boundaries. Likewise, the <tt>Finished</tt> message is compressed using the negotiated compression algorithm thus the length of the record, and thus the extension, depend on the contents of the hash. Given these limitations, removing the extension altogether is the simplest way to break the cycle.)
</p>
<p>If the server chooses not to perform a Snap Start handshake (for any reason, including that the application rejected the suggested random value or that the client mispredicted the handshake) then the handshake MUST continue as normal. The server MUST NOT change the way that it hashes the <tt>ClientHello</tt>. The server MAY echo a <tt>snap_start</tt> extension.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Active attack considerations</h3>

<p>
        Given that this draft makes changes to the Finished hash, it's required to show that no active attack can cause a handshake to complete which differs from that which would have occurred otherwise.
      
</p>
<p>Since the <tt>snap_start</tt> extension is not included in the Finished hash of a Snap Start handshake, we have to consider the results of an attacker manipulating its contents.
</p>
<p>Firstly, since the embedded records are hashed as usual, the same security properties hold: any manipulation will be detected by the Finished hash, or by a MAC verification failure.
</p>
<p>An attacker could manipulate the orbit. This would typically cause the server to reject the suggested random value and a normal handshake would detect the manipulation. In the case that the server still proceeds with a Snap Start handshake, the orbit is copied into the <tt>server_random</tt> in the <tt>ServerHello</tt>, which is then hashed into the Finished calculation (although not transmitted).
</p>
<p>An attacker could manipulate the suggested server random. The same argument as for the orbit holds here.
</p>
<p>An attacker could manipulate the hash of the predicted messages. Assuming that the client correctly predicted the hash, the manipulation would cause the server to not perform a Snap Start handshake and the manipulation would be detected. Assuming that the client mispredicted, and that the manipulation results in a different, but also incorrect, value then the same argument applies. Assuming that the client mispredicted and the manipulation corrects the hash, the server could perform a Snap Start handshake, but the differing contents of the predicted handshake messages will be hashed into the Finished calculation and the manipulation will be detected.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Requirements on the application</h3>

<p>Applications are required to ensure that no suggested random value is accepted twice within the scope of any given certificate. In general, validation of the suggested random value is outside the scope a TLS implementation (although it may handle simple cases and provide utility code for others). Applications may use the orbit value and client timestamp to aid them in this. Applications may always safely reject a suggested random value. Applications SHOULD limit the allowed difference between the timestamp in the suggested random value and the current time in order to prevent arbitrary delays, as detailed in the design section of this document.
</p>
<p>For a single server deployment, the server may generate a new, random orbit value each time that it starts and, thereafter, maintain an in-memory data structure. Each random value seen should be "struck off" by recording it in this data structure (the "strike register"). The strike register's size can be bound by fixed limits and by rejecting all random values where the timestamp is outside a certain window around the current time.
</p>
<p>For a multi-server deployment in a single location, the servers should share an orbit value and a strike register. The strike register is likely to be a held in a single location which the TLS servers access over an internal network.
</p>
<p>For a multi-cluster deployment, where the clusters are geographically separated, each cluster should have its own orbit value and shared strike register. The effectiveness of Snap Start in this setup is limited by the probability of a given client repeatedly being served by the same cluster. With pure round robin scheduling, a Snap Start handshake is unlikely to be successful.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Interactions with the Session Tickets extension</h3>

<p>A successful Snap Start abbreviated handshake can occur without the use of session tickets. A successful Snap Start full handshake, without session tickets, can only occur if the server doesn't generate a random session id. A server MAY choose not to generate a session id if the client presents a Snap Start extension but not a session tickets extension. However, all TLS implementations of Snap Start SHOULD implement session tickets. TLS clients which send a Snap Start extension SHOULD also send a Session Tickets extension.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Interactions with OCSP stapling</h3>

<p>Clients attempting a Snap Start handshake MUST trust the server's cached certificate. This includes validating revocation information (via <a class='info' href='#RFC2560'>OCSP<span> (</span><span class='info'>Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, &ldquo;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP,&rdquo; June&nbsp;1999.</span><span>)</span></a> [RFC2560], <a class='info' href='#RFC5280'>CRLs<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5280] etc) as the local policy dictates.
</p>
<p>TLS clients which send a Snap Start extension SHOULD NOT send a <tt>status_request</tt> extension as defined in <a class='info' href='#RFC4366'>RFC 4366<span> (</span><span class='info'>Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;Transport Layer Security (TLS) Extensions,&rdquo; April&nbsp;2006.</span><span>)</span></a> [RFC4366] section 3.6. A client may be able to predict the contents of a <tt>CertificateStatus</tt> message but, if it can predict it, then it doesn't need it and, if it needs fresh OCSP information, then it shouldn't have attempted a Snap Start handshake using a certificate that it cannot validate.
</p>
<p>This does preclude the case where the client has cached a valid OCSP response that is still timely, but the server has a response valid further into the future. We can only suggest that opportunistic OCSP stapling additionally be included in application level protocols for this situation.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Interactions with client certificates</h3>

<p>A Snap Start handshake can include client-side authentication. In this case the client must predict that the server will send a <tt>CertificateRequest</tt> message, calculate its <tt>predicted_server_handshake</tt> accordingly and embed <tt>Certificate</tt> and <tt>CertificateVerify</tt> messages in the Snap Start extension.
</p>
<p>The <tt>handshake_messages</tt> over which the <tt>CertificateVerify</tt> is calculated MUST omit the Snap Start extension as detailed for the Finished calculation, above.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Examples</h3>

<p>
      Firstly, a client contacting a previously unknown server for the first time may include an empty Snap Start extension in its ClientHello. The server, if so capable, could reply with:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
01 02 03 04 05 06 07 08         (Orbit value)
00 2f                           (Cipher suite)
</pre></div>
<p>
      A future connection may now attempt a Snap Start by including a Snap Start extension in the ClientHello with the following contents:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
01 02 03 04 05 06 07 08         (Orbit value)
88 c0 1e 1c a9 4e ...           (Random bytes)
aa bb cc dd ee ff 00 11         (predicted server handshake)
16 03 03 00 84 10 00 00 80 ...  (ClientKeyExchange)
14 03 03 00 01 01               (ChangeCipherSpec)
16 03 03 00 20 ...              (Finished)
17 03 03 00 50 ...              (Application data)
</pre></div>
<p>
      If the Snap Start is successful, then the message flow looks like this:
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
ClientHello     --------&gt;
                              ChangeCipherSpec
                                      Finished
                &lt;--------     Application data
</pre></div>
<p>
      If the client mispredicts the server's handshake, however, then the flow is unaltered from Figure 1 in RFC 5246 section 7.3.
    
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Prior work</h3>

<p>The idea of cache-side caching of long lived server parameters has been discussed in <a class='info' href='#fasttrack'>Client Side Caching for TLS<span> (</span><span class='info'>Shacham, H., Boneh, D., and E. Rescorla, &ldquo;Client Side Caching for TLS,&rdquo; Nov&nbsp;2004.</span><span>)</span></a> [fasttrack] and specified in <a class='info' href='#cached-info'>draft-ietf-tls-cached-info<span> (</span><span class='info'>Santesson, S., &ldquo;Transport Layer Security (TLS) Cached Information Extension,&rdquo; Internet Draft (work in progress), April&nbsp;2010.</span><span>)</span></a> [cached&#8209;info]. <a class='info' href='#fasttrack'>Client Side Caching for TLS<span> (</span><span class='info'>Shacham, H., Boneh, D., and E. Rescorla, &ldquo;Client Side Caching for TLS,&rdquo; Nov&nbsp;2004.</span><span>)</span></a> [fasttrack] also considered including an opportunistic <tt>ClientKeyExchange</tt> message in the client's initial flow.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
IANA Considerations</h3>

<p>
        This document requires IANA to update its registry of TLS extensions
        to assign an entry, referred herein as <tt>snap_start</tt>.
      
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Acknowledgements</h3>

<p>
        This document benefited specifically from discussions with Wan-Teh
        Chang, Bodo Moeller and Nagendra Modadugu.
      
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2560">[RFC2560]</a></td>
<td class="author-text"><a href="mailto:mmyers@verisign.com">Myers, M.</a>, <a href="mailto:rankney@erols.com">Ankney, R.</a>, <a href="mailto:ambarish@valicert.com">Malpani, A.</a>, <a href="mailto:galperin@mycfo.com">Galperin, S.</a>, and <a href="mailto:cadams@entrust.com">C. Adams</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2560">X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP</a>,&rdquo; RFC&nbsp;2560, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2560.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4366">[RFC4366]</a></td>
<td class="author-text">Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>,&rdquo; RFC&nbsp;4366, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4366.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5077">[RFC5077]</a></td>
<td class="author-text">Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, &ldquo;<a href="http://tools.ietf.org/html/rfc5077">Transport Layer Security (TLS) Session Resumption without Server-Side State</a>,&rdquo; RFC&nbsp;5077, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5077.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5280.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="fnv1a">[fnv1a]</a></td>
<td class="author-text">Noll, L., &ldquo;FNV hash.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="cached-info">[cached-info]</a></td>
<td class="author-text">Santesson, S., &ldquo;Transport Layer Security (TLS) Cached Information Extension,&rdquo; Internet Draft (work in progress), April&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="fasttrack">[fasttrack]</a></td>
<td class="author-text">Shacham, H., Boneh, D., and E. Rescorla, &ldquo;Client Side Caching for TLS,&rdquo; Nov&nbsp;2004.</td></tr>
</table>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Changes</h3>

<p>To be removed by RFC Editor before publication
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adam Langley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google Inc</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:agl@google.com">agl@google.com</a></td></tr>
</table>
</body></html>
