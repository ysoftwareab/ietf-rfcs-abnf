<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>TLS Proxy Server Extension</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.2" rel="Chapter" title="2 Motivation">
<link href="#rfc.section.3" rel="Chapter" title="3 Operation">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 ProxyInfoExtension">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 ProxyInfoExtension">
<link href="#rfc.section.4" rel="Chapter" title="4 Discussion">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="Transport Layer Security (TLS) is commonly used to protect HTTP and other protocols. HTTP is often proxied, for instance, to allow an application-layer firewall to inspect the HTTP traffic between the client and the server. A TLS session cannot protect traffic between the client and server when an HTTP proxy is present. Separate TLS sessions can be run between the client and the proxy, on one side, and the proxy and the server on the other side. This provides the needed security, as long as the client, server, and proxy device use appropriate and consistent security policies. However, this last part is problematic; how can a proxy know if a client trusts a server? At present, TLS provides no mechanism to coordinate policies." />
  <meta name="description" content="Transport Layer Security (TLS) is commonly used to protect HTTP and other protocols. HTTP is often proxied, for instance, to allow an application-layer firewall to inspect the HTTP traffic between the client and the server. A TLS session cannot protect traffic between the client and server when an HTTP proxy is present. Separate TLS sessions can be run between the client and the proxy, on one side, and the proxy and the server on the other side. This provides the needed security, as long as the client, server, and proxy device use appropriate and consistent security policies. However, this last part is problematic; how can a proxy know if a client trusts a server? At present, TLS provides no mechanism to coordinate policies." />
  <meta name="keywords" content="TLS, Proxy" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">D.A.M. McGrew</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">P.J.S.G. Gladstone</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">Cisco Systems</td>
</tr>
<tr>
<td class="left">Expires: January 05, 2012</td>
<td class="right">July 04, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">TLS Proxy Server Extension<br />
  <span class="filename">draft-mcgrew-tls-proxy-server-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Transport Layer Security (TLS) is commonly used to protect HTTP and other protocols. HTTP is often proxied, for instance, to allow an application-layer firewall to inspect the HTTP traffic between the client and the server. A TLS session cannot protect traffic between the client and server when an HTTP proxy is present. Separate TLS sessions can be run between the client and the proxy, on one side, and the proxy and the server on the other side. This provides the needed security, as long as the client, server, and proxy device use appropriate and consistent security policies. However, this last part is problematic; how can a proxy know if a client trusts a server? At present, TLS provides no mechanism to coordinate policies.</p>
<p>This note defines a TLS extension that allows a TLS proxy to provide a TLS client with all of information about the TLS server that the client needs to make a well-informed access control decision.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 05, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>2.   <a href="#rfc.section.2">Motivation</a>
</li>
<li>3.   <a href="#rfc.section.3">Operation</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">ProxyInfoExtension</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">ProxyInfoExtension</a>
</li>
<li>4.   <a href="#rfc.section.4">Discussion</a>
</li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Transport Layer Security (TLS) <a href="#RFC5246">RFC 5246</a> <cite title="NONE">[RFC5246]</cite> is commonly used to protect HTTP <a href="#RFC2616">[RFC2616]</a> as described in <a href="#RFC2818">[RFC2818]</a>. In many scenarios an HTTP proxy is used, for instance, to allow caching, to provide anonymity to a client, or to provide security by using an application-layer firewall to inspect the HTTP traffic on behalf of the client. A TLS session cannot protect traffic between the client and server when a proxy is present.  It is possible to have separate TLS sessions between the client and the proxy, on one side, and the proxy and the server on the other side, as show in <a href="#simple">Figure 1</a> . This technique provides the appropriate cryptographic security (see below for a discussion of why some other alternatives are less attractive). But there is a problem: the presence of the proxy removes the client's knowledge about the server. Without this knowledge, the client has no way to decide what trust, if any, it should have in the server. This is most problematic when the client trusts multiple different servers for different applications, or trusts servers from different domains. </p>
<div id="#rfc.figure.1"></div>
<div id="#simple"></div>
<pre>
                       
         Client                Proxy                 Server
                TLS Session #1        TLS Session #2
                &lt;------------&gt;       &lt;-------------&gt;
                               HTTP
                &lt;-----------------------------------&gt;
            </pre>
<p></p>

<p>A proxied HTTPS session, with two independent TLS sessions. </p>
<p id="rfc.section.1.p.3">A further issue is that the client cannot determine the security level of the TLS session between the proxy and the server. For instance, a client can negotiate a high security ciphersuite between itself and the proxy, but it will have no way of knowing what ciphersuite is in use between the client and the server, which could be using the obsolete 56-bit Data Encryption Standard (DES) cipher.</p>
<p id="rfc.section.1.p.4">Another point of difficulty is the fact that there can be multiple proxies on a particular path. To solve the security issues introduced by TLS proxies in a way that is generally applicable, it is necessary to accommodate scenarios involving multiple proxies. </p>
<p id="rfc.section.1.p.5">We propose a solution in this note, by describing a TLS extension that can be used by a proxy to provide information to a TLS client about the TLS server. When this extension is used, the client is well informed about the proxy as well as the server, and can make a knowledgeable access control decision about the server, using the same processes that it uses when the proxy is not present. The data in the extension are signed by the proxy in order to bind the information about the server to a particular session between the client and the proxy. When there are multiple proxies, the client is informed about all of them. This extension also works for DTLS. </p>
<p id="rfc.section.1.p.6">A separate issue is the provisioning of the proxy with information about what servers (or rather, which certificates) should be trusted. If the laptop has installed certificates that are specific to its organization or to a particular domain, how can the proxy know to trust these certificates on behalf of the laptop? </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Motivation</h1>
<p id="rfc.section.2.p.1">The following motivating example describes a typical situation with a TLS proxy, as in <a href="#simple">Figure 1</a>. A laptop trusts the server A for a particular banking application, and trusts server B for a social media application, and can authenticate both servers by using standard PKIX certificate checking <a href="#RFC5280">[RFC5280]</a> and locally stored root certificates. Or rather, the client trusts a set of root certificates, and uses them to authenticate the TLS servers that it connects with. The laptop also trusts the proxy, and has a certificate by which it can authenticate the proxy. When making a connection directly with B, the laptop can authenticate the server as being trusted (that is, the server's public key appears in a certificate that has been signed by the appropriate trusted certificate authority), and it can also check the authorizations of that server (that is, B is authorized to provide the social media service, but not any other services such as banking). If the web traffic from the laptop goes through an HTTP proxy, then the proxy will need to know that it should trust both A and B to act as TLS servers. Assuming that it does have this knowledge, it will proxy TLS connections from both A and B. However, when the client attempts to establish an HTTPS connection to A through the proxy, it has no way of knowing what security checks the proxy has applied to the connection between the proxy and A. The client cannot tell whether the trusted certificate that it associates with A was used on the connection between the proxy and A. The inability of the client to be confident of the identity of the actual server forces the client to trust all TLS servers indiscriminately.</p>
<p id="rfc.section.2.p.2">This obstacle could be overcome by pushing the client's policy (that is, information about what servers it trusts for what applications) onto the proxy, so that the proxy can make well-informed decisions on behalf of the client. However, this alternative has significant drawbacks: it requires that the proxy obtain and store a significant amount of information about each client, and it requires the construction of a syntax by which the client's policy can be expressed and understood. In contrast, our solution moves the information about the server to the client, which does not require the communication or storage of any security policy between the client and server.</p>
<p></p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#intro" id="intro">Operation</a>
</h1>
<p id="rfc.section.3.p.1">In this note, a TLS proxy is a device that acts as a TLS server in one session and acts as a TLS client in another session, and passes all of the data from one session to the other, possibly modifying it in the process. That is, it is a non-transparent proxy, in the terms of <a href="#RFC2616">[RFC2616]</a>. </p>
<div id="#rfc.figure.2"></div>
<div id="#basic"></div>
<pre>
                 TLS Session #1       TLS Session #2
          Client &lt;------------&gt; Proxy &lt;-------------&gt; Server


        Session #1            Session #2            Session #3           
 Client &lt;---------&gt;  Proxy #1 &lt;--------&gt; Proxy #2  &lt;---------&gt; Server
            </pre>
<p>A TLS session with a single proxy (top) and a TLS session with two proxies (bottom).</p>
<p id="rfc.section.3.p.2">The essential idea is as follows. When a TLS proxy is contacted by a client, it does not respond to the client until it completes a TLS session with the server. It then sends the client an assertion about the server and the session, signed with the same private key that it uses in its role as the TLS proxy server. When the client receives this assertion, it checks the data in the assertion to determine whether or not it trusts the server. The assertion is carried in a ProxyInfoExtension, which is defined below.</p>
<p id="rfc.section.3.p.3">This extension carries all of the information that is available to a TLS client about a TLS server; thus the client can use existing authorization checking processes. The client will need to verify the hostname and/or address, and check to see if the certificate has been revoked. The client authenticates the proxy server as usual during the TLS session. This ensures that the client trusts the proxy, and because of the signature on the assertion, it should trust the server certificate carried in the assertion. The proxy need not perform any checking on the server certificate, because this check is done by the client. Of course, by completing a TLS exchange with the server, the proxy verifies that the server holds the private key associated with that certificate.</p>
<p id="rfc.section.3.p.4">It is required that proxies which implement this extension and support TLS Session Resumption handle TLS Session Resumptions (from the client) by requiring TLS Session Resumption with the server. In particular, a TLS session that is resumed with a client SHOULD correspond to the proxy successfully resuming the TLS session with the same server. When a client resumes a session with a proxy, the proxy SHOULD attempt to resume the corresponding session with the server. </p>
<p id="rfc.section.3.p.5">Because there may be more than one proxy in any path, the TLS extension carries a list of assertions.</p>
<p id="rfc.section.3.p.6">On receiving a ClientHello from the client, the proxy:</p>

<ol>
<li>Checks for a ProxyInfoExtension in the ClientHello; if there is no such extension, then the following steps cannot be performed and are omitted,</li>
<li>Establishes a TLS session with the server (session #2 in <a href="#simple">Figure 1</a>); a ProxyInfoExtension is included in that session,</li>
<li>Constructs a ProxyInfo structure by populating it with information about the server and the current session with that server; if the sever sends back a ProxyInfoExtension, then the ProxyInfo structure is included as the next_proxy_info,</li>
<li>Signs the ProxyInfo structure with the public key corresponding to the server certificate it uses in session #1, </li>
<li>Completes the session with the client (session #1 in <a href="#simple">Figure 1</a>) and provides the ProxyInfoExtension in that session,</li>
</ol>
<p id="rfc.section.3.p.7">The proxy MAY </p>

<ul class="empty"><li>Perform revocation checking on the certificate chain of the server in session #2, and indicate that it has done this in the extension by setting performed_revocation_checking to "true".</li></ul>
<p id="rfc.section.3.p.8">Note that the entity acting in the role of the server in session #2 could be a proxy, but in the above it is referred to as a server because that is the role that it performs in that TLS session. </p>
<p id="rfc.section.3.p.9">When TLS is used in HTTPS, the proxy MUST perform the Server Identity checks described in Section 3.1 of <a href="#RFC2818">[RFC2818]</a>.</p>
<p id="rfc.section.3.p.10">The normal operation of the proxy is to accept the (extended) ClientHello from the client and then send a ClientHello to the server.  It is recommended that the TLS Proxy support commonly deployed TLS extensions (as defined in <a href="#RFC4366">[RFC4366]</a> et al). Any TLS extensions present on the original ClientHello MUST be examined and either ignored, processed or forwarded (possibly after modification) to the TLS server as part of the new ClientHello.</p>
<p id="rfc.section.3.p.11">The client:</p>
<p></p>

<ol>
<li>Includes a ProxyInfoExtension in the ClientHello message, </li>
<li>Checks for ProxyInfoExtension in the ServerHello message; if there is no such extension, then the TLS processing continues as usual; otherwise, </li>
<li>Processes the ProxyInfo extension by checking the validity of the digitally-signed struct, then performing the usual server authentication and authorization checking on the server_certificate_list in the ProxyInfo,</li>
<li>Checks the revocation_checking_performed flag in the ProxyInfo; if it is "false", then the client SHOULD perform revocation checking on the server_certificate_list, </li>
<li>Checks the ProxyInfoFlag in the next_proxy_info field; if it is not_empty, then the client returns to step 3 and performs that processing on the next_proxy_info. </li>
</ol>
<p id="rfc.section.3.p.13">In order to maintain backwards compatibility for existing TLS clients, the TLS proxies MUST (by default) perform certificate validation for the certificates that they receive from the server. The use of the ProxyInfoExtension in the extended ClientHello is an indication by the client to request the alternate processing defined by this note. In particular, if this extension is present in the extended ClientHello, then the TLS proxy should not use its own private key to dynamically generate a certificate.</p>
<p id="rfc.section.3.p.14">The proxy will relay the data between the client and peer data connections. End-to-end flow control is maintained by the relay process: if the relay process is no longer able to write data to the destination of the relayed data, the relay process stops reading data from the source.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> ProxyInfoExtension</h1>
<div id="#rfc.figure.3"></div>
<pre>struct {
     PRFAlgorithm           prf_algorithm;
     BulkCipherAlgorithm    bulk_cipher_algorithm;
     CipherType             cipher_type;
     uint8                  enc_key_length;
     uint8                  block_length;
     uint8                  fixed_iv_length;
     uint8                  record_iv_length;
     MACAlgorithm           mac_algorithm;
     uint8                  mac_length;
     uint8                  mac_key_length;
     CompressionMethod      compression_algorithm;
} ConnectionSecurityParameters;

enum { empty, not_empty } ProxyInfoFlag;

struct {
     select (ProxyInfoFlag) {
        case empty:
          /* zero length body */
        case not_empty:
          digitally-signed struct {
             ConnectionSecurityParameters connection_parameters;
             ASN.1Cert server_certificate_list&lt;0..2^8-1&gt;;
             Boolean revocation_checking_performed;
             ProxyInfo next_proxy_info;   
          } SignedProxyInfo;
     }
} ProxyInfo;

struct {
     ProxyInfo proxy_info;
} ProxyInfoExtension;

</pre>
<p id="rfc.section.3.1.p.1">The syntax of the ProxyInfo extension is as follows</p>

<p>In this extension, .</p>
<p id="rfc.section.3.1.p.2">The ProxyInfo structure is defined recursively, so that the signature of each proxy authenticates the information provided by the proxies that follow it on the path. The ProxyInfo contains the ProxyInfoFlag, which indicates whether or not the ProxyInfo is empty (in which case it contains no other fields) or not (in which case it contains a SignedProxyInfo structure). The SignedProxyInfo structure is signed with the public key that the proxy uses in its role as the TLS server (in session #1). That structure contains the connection_parameters that describe the security of session #2, and the certificate chain of the server from session #2 in the server_certificate_list. If the proxy has performed revocation checking on that certificate chain, it indicates this by setting the Boolean revocation_checking_performed. If the server in session #2 was actually a proxy itself, and it provides a ProxyInfo struct, then that struct is included in the next_proxy_info field. Otherwise, the next_proxy_info field contains an empty ProxyInfo. </p>
<p></p>
<div id="#rfc.figure.4"></div>
<pre>
      enum {
           /* ... */
          proxy_info(TBD1), (65535)
      } ExtensionType;
 </pre>
<p></p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> ProxyInfoExtension</h1>
<p></p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Discussion</h1>
<p id="rfc.section.4.p.1">The ProxyInfo extension could contain information about the checking that the proxy performed on the server and its certificate. For example, if the DNS name of the server matched the subjectAltName, this fact could be indicated. It may be desirable to enumerate the ways in which the server can match its certificate, to allow the proxy to indicate to the client which of those ways was positive for a particular server.</p>
<p id="rfc.section.4.p.2">A potential issue with the ProxyInfo extension is that it can be large, because the certificate chains that it carries can be large.  Roughly speaking, the amount of certificate data presented to the client is proportional to the number of proxies on the path. It is undesirable to require that so much data be sent, but on the other hand, the client does need all of the data in order to make a well-informed access control decision. It appears that the data is the minimum required, in the sense that removing any of the data would make it impossible for the client to assess the security of the entire path. </p>
<p id="rfc.section.4.p.3">The proxy is required to do the authentication checking on the signatures created by the server, but not the authorization checking or revocation checking. The responsibility for authorization checking is not put onto the proxy because it does not know the security policy of the client; in particular, the proxy does not know which servers the client trusts for which applications. The responsibility for revocation checking is not put onto the proxy because that process is better left to the client. The client can perform revocation checking on all of the certificate lists for all of the proxies and the server in parallel, whereas if each proxy performed the revocation checking, those processes would necessarily be serial. Since revocation checking can take a significant amount of time, the serial approach could add a significant amount of latency to the TLS session, and potentially trigger retransmissions. The parallel approach not only reduces the overall latency, but it moves it outside of the client's retransmission timer for the ClientHello message. </p>
<p id="rfc.section.4.p.4">The ProxyInfo extension could convey the IP address of the server, or other network layer information such as the DNS name. However, it is not clear that this information is needed, so it was not included.</p>
<p id="rfc.section.4.p.5">The ProxyInfo extension only provides information about proxies to the client; it does not provide any information to the server about either the client or other proxies on the path. This is acceptable when there are no client certificates in use, which is (regrettably) common in practice. It would be possible to generalize the ideas in this note to also provide information to the server about the client and other proxies on the path. Nonetheless, that goal is out of scope for this note. </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.5.p.1">This document requests IANA to update its registry of TLS extension types to assign an entry, referred herein as proxy_info, with the number TBD1. </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">In a situation with a proxy and a cryptographic protocol, the appropriate security goals are to</p>
<p></p>

<ul class="empty">
<li>preserve the security of the cryptographic protocol, </li>
<li>make the client aware of the proxy, able to authenticate the proxy, and able to check that the device acting as a proxy is authorized to act in that role,</li>
<li>allow the client to make access control decisions that are as well-informed as when the proxy is not present.</li>
</ul>

<p>The idea in this note meets these goals.</p>
<p id="rfc.section.6.p.3">We briefly describe some alternative approaches that do not meet these security goals. First, we consider the proliferation of private keys. In order to allow one device to act as a proxy for a server, the private key of the server could be shared with the proxy. This practice may be workable when there is a one-to-one correspondence between proxies and servers, but it substantially increases the security risk.  If a proxy contains multiple private keys, it becomes an attractive target for an attacker. Second, we consider the session-key proliferation approach in which there is only a single TLS session, negotiated between the client and server, and the proxy participates in the session because either the client or the server has passed the secret session keys to the proxy (using some secure channel). If the proxy is completely passive, and it only decrypts traffic from the TLS session and never modifies the data in that session, then this method can be secure. However, if the proxy rewrites the data inside the session, or originates messages, then the security of the TLS protocol will be undermined. Message authentication can be subverted because an attacker can intercept a message sent by the server, and forward it on to the client, bypassing the proxy. By interleaving messages sent by the proxy with ones sent by the server, an attacker can potentially confuse a client, and can certainly cause a denial of service. Confidentiality may be undermined as well; if RC4 or AES-GCM is in use, information about the plaintext will be leaked due to keystream reuse. Session-key proliferation is not secure when the proxy needs to edit the session.  Most proxies do need to edit the session, and we regard it as potentially hazardous to construct a TLS proxy along these lines.  Suppose that such a proxy were implemented because it was anticipated that the application proxy would be read-only, but then a future revision to the application protocol or the goals of the application proxy made it necessary to have the proxy edit the application session.  If the session-key proliferation approach had been used, the implementer would be in the awkward position of having to choose between implementing a completely new approach that preserved security, and in risking the security of the application. </p>
<p id="rfc.section.6.p.4">With the ProxyInfo extension, there is no protection against the proxy lying about the security characteristics of the onward connection.  However, in any proxying scenario, it is necessary to trust the proxy, just as a client must trust the server. For instance, any proxy (not just one using the ProxyInfo extension) could choose to forward the plaintext from the session to untrusted third parties, and violate the trust of the client. It is the responsibility of the client to decide whether or not a particular device should be trusted to act in the role of proxy. The ProxyInfo proposal has the benefit of making the presence of the proxy obvious, and allows the client to refuse to deal with untrusted proxies.</p>
<p id="rfc.section.6.p.5">Many clients use password-based authentication within a TLS tunnel. When a proxy is present, it can learn plaintext passwords, and it can gain the information needed to perform offline dictionary attacks against authentication systems that use challenge-response methods. This is a highly undesirable aspect of TLS proxying. The ProxyInfo extension does nothing to directly help this issue. However, it does indirectly improve the situation, because it empowers the client with information that enables it to reject proxies and servers that it should not trust. Since the TLS authentication (including both sever and proxy authentication) takes place before the password-based authentication, the client can protect itself by rejecting sessions with inappropriate proxies, or inappropriate servers on the path beyond the proxy. </p>
<p id="rfc.section.6.p.6">In theory, the cryptographic proxying scenario could be considered as multiparty security negotiation and key establishment. It may be interesting to investigate such ideas because they can allow for more equitable negotiation of session parameters, and additional security properties. This note focuses on compatibility with existing specifications and implementations, so these considerations are beyond its scope. </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Acknowledgements</h1>
<p id="rfc.section.7.p.1">Thanks are due to Dan Wing for suggestions and fruitful discussion.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2818">[RFC2818]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4366">[RFC4366]</b></td>
<td class="top">
<a>Blake-Wilson, S.</a>, <a>Nystrom, M.</a>, <a>Hopwood, D.</a>, <a>Mikkelsen, J.</a> and <a>T. Wright</a>, "<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>", RFC 4366, April 2006.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr></tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David A. McGrew</span> 
	  <span class="n hidden">
		<span class="family-name">McGrew</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  <span>510 McCarthy Blvd.</span>

	  <span class="vcardline">
		<span class="locality">Milpitas</span>,  
		<span class="region">CA</span> 
		<span class="code">95035</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">Phone: (408) 525 8651</span>

<span class="vcardline">EMail: <a href="mailto:mcgrew@cisco.com">mcgrew@cisco.com</a></span>

<span class="vcardline">URI: <a href="http://www.mindspring.com/~dmcgrew/dam.htm">http://www.mindspring.com/~dmcgrew/dam.htm</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philip Gladstone</span> 
	  <span class="n hidden">
		<span class="family-name">Gladstone</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  <span>1414 Mass Ave</span>

	  <span class="vcardline">
		<span class="locality">Boxborough</span>,  
		<span class="region">MA</span> 
		<span class="code">01719</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:pgladstone@cisco.com">pgladstone@cisco.com</a></span>

  </address>
</div>

</body>
</html>