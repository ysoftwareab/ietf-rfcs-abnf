<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Analysis of solution proposals for hosts to learn NAT64 prefix</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Assumptions">
<link href="#rfc.section.3" rel="Chapter" title="3 Background">
<link href="#rfc.section.4" rel="Chapter" title="4 Proposed solutions to learn about synthesis and Network-Specific Prefix">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 DNS Query for a Well-Known Name">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Solution description">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Analysis and discussion">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Summary">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 EDNS0 option indicating AAAA Record synthesis and format">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Solution description">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Analysis and discussion">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Summary">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 EDNS0 flags indicating AAAA Record synthesis and format">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Solution description">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Analysis and discussion">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Summary">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 DNS Resource Record for IPv4-Embedded IPv6 address">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Solution description">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Analysis and discussion">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 Summary">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Learning the IPv6 Prefix of a Network's NAT64 using DNS">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Solution description">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Analysis and discussion">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Summary">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Learning the IPv6 Prefix of a Network's NAT64 using DHCPv6">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Solution description">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 Analysis and discussion">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 Summary">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Learning the IPv6 Prefix of a Network's NAT64 using Router Advertisements">
<link href="#rfc.section.4.7.1" rel="Chapter" title="4.7.1 Solution description">
<link href="#rfc.section.4.7.2" rel="Chapter" title="4.7.2 Analysis and discussion">
<link href="#rfc.section.4.7.3" rel="Chapter" title="4.7.3 Summary">
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Using application layer protocols such as STUN">
<link href="#rfc.section.4.8.1" rel="Chapter" title="4.8.1 Solution description">
<link href="#rfc.section.4.8.2" rel="Chapter" title="4.8.2 Analysis and discussion">
<link href="#rfc.section.4.8.3" rel="Chapter" title="4.8.3 Summary">
<link href="#rfc.section.4.9" rel="Chapter" title="4.9 Learning the IPv6 Prefix of a Network's NAT64 using Access Technology Specific Methods">
<link href="#rfc.section.4.9.1" rel="Chapter" title="4.9.1 Solution description">
<link href="#rfc.section.4.9.2" rel="Chapter" title="4.9.2 Analysis and discussion">
<link href="#rfc.section.4.9.3" rel="Chapter" title="4.9.3 Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Conclusion">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Contributors">
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="Hosts and applications may benefit from the knowledge if an IPv6 address is synthesized, which would mean a NAT64 is used to reach the IPv4 network or Internet. This document analyses a number of proposed solutions for communicating whether the synthesis is taking place, used address format, and the IPv6 prefix used by the NAT64 and DNS64. The solutions enable both NAT64 avoidance and intentional utilization by allowing local IPv6 address synthesis. The document concludes by recommending selection of heuristic discovery based solution.  " />
  <meta name="description" content="Hosts and applications may benefit from the knowledge if an IPv6 address is synthesized, which would mean a NAT64 is used to reach the IPv4 network or Internet. This document analyses a number of proposed solutions for communicating whether the synthesis is taking place, used address format, and the IPv6 prefix used by the NAT64 and DNS64. The solutions enable both NAT64 avoidance and intentional utilization by allowing local IPv6 address synthesis. The document concludes by recommending selection of heuristic discovery based solution.  " />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Behavior Engineering for Hindrance Avoidance (BEHAVE)</td>
<td class="right">J. Korhonen, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Nokia Siemens Networks</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">T. Savolainen, Ed.</td>
</tr>
<tr>
<td class="left">Expires: April 08, 2012</td>
<td class="right">Nokia</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 06, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Analysis of solution proposals for hosts to learn NAT64 prefix<br />
  <span class="filename">draft-ietf-behave-nat64-learn-analysis-01.txt</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Hosts and applications may benefit from the knowledge if an IPv6 address is synthesized, which would mean a NAT64 is used to reach the IPv4 network or Internet. This document analyses a number of proposed solutions for communicating whether the synthesis is taking place, used address format, and the IPv6 prefix used by the NAT64 and DNS64. The solutions enable both NAT64 avoidance and intentional utilization by allowing local IPv6 address synthesis. The document concludes by recommending selection of heuristic discovery based solution.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 08, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Assumptions</a>
</li>
<li>3.   <a href="#rfc.section.3">Background</a>
</li>
<li>4.   <a href="#rfc.section.4">Proposed solutions to learn about synthesis and Network-Specific Prefix</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">DNS Query for a Well-Known Name</a>
</li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">Solution description</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Analysis and discussion</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">Summary</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">EDNS0 option indicating AAAA Record synthesis and format</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Solution description</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Analysis and discussion</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Summary</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">EDNS0 flags indicating AAAA Record synthesis and format</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Solution description</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Analysis and discussion</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Summary</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">DNS Resource Record for IPv4-Embedded IPv6 address</a>
</li>
<li>4.4.1.   <a href="#rfc.section.4.4.1">Solution description</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Analysis and discussion</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">Summary</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Learning the IPv6 Prefix of a Network's NAT64 using DNS</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">Solution description</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Analysis and discussion</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Summary</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Learning the IPv6 Prefix of a Network's NAT64 using DHCPv6</a>
</li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">Solution description</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">Analysis and discussion</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">Summary</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Learning the IPv6 Prefix of a Network's NAT64 using Router Advertisements</a>
</li>
<li>4.7.1.   <a href="#rfc.section.4.7.1">Solution description</a>
</li>
<li>4.7.2.   <a href="#rfc.section.4.7.2">Analysis and discussion</a>
</li>
<li>4.7.3.   <a href="#rfc.section.4.7.3">Summary</a>
</li>
<li>4.8.   <a href="#rfc.section.4.8">Using application layer protocols such as STUN</a>
</li>
<li>4.8.1.   <a href="#rfc.section.4.8.1">Solution description</a>
</li>
<li>4.8.2.   <a href="#rfc.section.4.8.2">Analysis and discussion</a>
</li>
<li>4.8.3.   <a href="#rfc.section.4.8.3">Summary</a>
</li>
<li>4.9.   <a href="#rfc.section.4.9">Learning the IPv6 Prefix of a Network's NAT64 using Access Technology Specific Methods</a>
</li>
<li>4.9.1.   <a href="#rfc.section.4.9.1">Solution description</a>
</li>
<li>4.9.2.   <a href="#rfc.section.4.9.2">Analysis and discussion</a>
</li>
<li>4.9.3.   <a href="#rfc.section.4.9.3">Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Conclusion</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Contributors</a>
</li>
<li>9.   <a href="#rfc.section.9">Acknowledgements</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Hosts and applications may benefit from the knowledge of whether an IPv6 address is synthesized, which would mean a NAT64 is used to reach the IPv4 network or Internet. There are two issues that can be addressed with solutions that allow hosts and applications to learn the Network Specific Prefix (NSP)  <a href="#RFC6052">[RFC6052]</a> used by the NAT64 <a href="#RFC6146">[RFC6146]</a> and the DNS64 <a href="#RFC6147">[RFC6147]</a> devices.  </p>
<p id="rfc.section.1.p.2">Firstly, finding out whether a particular address is synthetic and therefore learning the presence of a NAT64. For example, a Dual-Stack (DS) host with IPv4 connectivity could use this information to bypass NAT64 and use native IPv4 transport for destinations that are reachable through IPv4. We will refer this as 'Issue #1' throughout the document.  </p>
<p id="rfc.section.1.p.3">Secondly, finding out how to construct from an IPv4 address an IPv6 address that will be routable to/by the NAT64. This is useful when IPv4 literals can be found in the payload of some protocol or applications do not use DNS to resolve names to addresses but know the IPv4 address of the destination by some other means. We will refer this as 'Issue #2' throughout the document.  </p>
<p id="rfc.section.1.p.4">Additionally three other issues have to be considered by a solution addressing the first two issues: whether DNS is required 'Issue #3', whether a solution supports changing NSP 'Issue #4', and whether multiple NSPs are supported (either of the same or different length) for load-balancing purposes 'Issue #5'.</p>
<p id="rfc.section.1.p.5">This document analyses all known solution proposals known at the time of writing for communicating if the synthesis is taking place, used address format, and the IPv6 prefix used by the NAT64 and DNS64. Based on the analysis we conclude whether the issue of learning the Network-Specific Prefix is worth solving and what would be the recommended solution(s) in that case.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology and Assumptions</h1>
<p></p>

<dl>
<dt>NSP</dt>
<dd style="margin-left: 8">
<br><br> Network-Specific Prefix: A prefix chosen by network administrator for NAT64/DNS64 to present IPv4 addresses in IPv6 namespace.  </dd>
<dt>WKP</dt>
<dd style="margin-left: 8">
<br><br> Well-Known Prefix: A prefix (64:ff9b::/96) chosen by IETF and configured by a network administrator for NAT64/DNS64 to present IPv4 addresses in IPv6 namespace.  </dd>
<dt>NAT64</dt>
<dd style="margin-left: 8">
<br><br> Network Address and protocol Translation mechanism for translating IPv6 packets to IPv4 packets and vice-versa: A network entity that a host or an application may want to either avoid or utilize. IPv6 packets hosts send to addresses in the NSP and/or WKP are routed to NAT64.  </dd>
<dt>DNS64</dt>
<dd style="margin-left: 8">
<br><br> DNS extensions for network address translation from IPv6 clients to IPv4 servers: A network entity that synthesizes IPv6 addresses and AAAA records out of IPv4  addresses and A records, hence making IPv4 namespaces visible into IPv6 namespace. DNS64 uses NSP and/or WKP in the synthesis process.  </dd>
<dt>Address Synthesis</dt>
<dd style="margin-left: 8">
<br><br> A mechanism, in the context of this document, where an IPv4 address is represented as an IPv6 address understood by a NAT64 device. The synthesized IPv6 address is formed by embedding an IPv4 address as-is into an IPv6 address prefixed with a NSP/WKP. It is assumed that the 'unused' suffix bits of the synthesized address are set to zero as described in Section 2.2 of <a href="#RFC6052">[RFC6052]</a>.  </dd>
<dt>Issue #1</dt>
<dd style="margin-left: 8">
<br><br> The problem of distinguishing between a synthesized and a real IPv6 addresses, which allows a host to learn the presence of a NAT64 in the network.  </dd>
<dt>Issue #2</dt>
<dd style="margin-left: 8">
<br><br> The problem of learning the NSP used by the access network and needed for local IPv6 address synthesis.</dd>
<dt>Issue #3</dt>
<dd style="margin-left: 8">
<br><br> The problem of learning the NSP or WKP used by the access network by a host not implementing DNS (hence applications are unable to use DNS to learn prefix).</dd>
<dt>Issue #4</dt>
<dd style="margin-left: 8">
<br><br> The problem of supporting changing NSP. The NSP learned by the host may become stale for multiple reasons. For example, the host might move to a new network that uses different NSP, thus making the previously learned NSP stale. Also, the NSP used in the network may be changed due administrative reasons, thus again making previously learned NSP stale.</dd>
<dt>Issue #5</dt>
<dd style="margin-left: 8">
<br><br> The problem of supporting multiple NSPs. A network may be configured with multiple NSPs for address synthesis. For example, for load-balancing purposes each NAT64 device in the same network could be assigned with their own NSP. It should be noted that learning a single NSP is enough for an end host to successfully perform local IPv6 address synthesis but to avoid NAT64 the end host needs to learn all NSPs used by the access network.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Background</h1>
<p id="rfc.section.3.p.1">Certain applications, operating in protocol translation scenarios, can benefit  from  knowing the IPv6 prefix used by a local NAT64 of the attached access network. This applies to the Framework document <a href="#RFC6144">[RFC6144]</a> Scenario 1 ("IPv6 network to IPv4 Internet"), Scenario 5 ("An IPv6 network to an IPv4 network"), and Scenario 7 ("The IPv6 Internet to the IPv4 Internet"). Scenario 3("The IPv6 Internet to an IPv4 network") is not considered applicable herein as in that case a NAT64 is located at the front of remote IPv4 network and host in IPv6 Internet can benefit very little of learning NSP IPv6 prefix used by the remote NAT64. The NAT64 prefix can be either a Network Specific Prefix (NSP) or the Well-known Prefix (WKP). Below is (an incomplete) list of various use cases where it is beneficial for a host or an application to know the presence of a NAT64 and the NSP/WKP: </p>

<ul>
<li>Host-based DNSSEC validation: as is documented in DNS64 <a href="#RFC6147">[RFC6147]</a> section 5.5. point 3, synthetic AAAA records cannot be successfully validated in a host. In order to utilize NAT64 a security-aware and validating host has to perform DNS64 function locally and hence it has to be able to learn WKP or proper NSP.</li>
<li>Protocols that use IPv4 literals: in IPv6-only access native IPv4 connections cannot be created. If a network has NAT64 it is possible to synthesize IPv6 address by combining the IPv4 literal and the IPv6 prefix used by NAT64. The synthesized IPv6 address can then be used to create an IPv6 connection. </li>
<li>Multicast translations <a href="#I-D.venaas-behave-mcast46">[I-D.venaas-behave-mcast46]</a><a href="#I-D.venaas-behave-v4v6mc-framework">[I-D.venaas-behave-v4v6mc-framework]</a>.</li>
<li>URI schemes with host IPv4 address literals rather than domain names (e.g., http://192.0.2.1, ftp://192.0.2.1, imap://192.0.2.1, ipp://192.0.2.1)): a host can synthesize IPv6 address out of the literal in URI and use IPv6 to create connection through NAT64.</li>
<li>Updating host's <a href="#RFC3484">[RFC3484]</a> preference table to prefer native prefixes over translated prefixes: this is useful as applications are more likely able to traverse through NAT44 than NAT64.</li>
</ul>

<p> </p>
<p id="rfc.section.3.p.2">DNS64 cannot serve applications that are not using DNS or that obtain referral as an IPv4 literal address. One example application is the Session Description Protocol (SDP) <a href="#RFC4566">[RFC4566]</a>, as used by Real Time Streaming Protocol (RTSP) <a href="#RFC2326">[RFC2326]</a> and Session Initiation Protocol (SIP) <a href="#RFC3261">[RFC3261]</a>. Other example applications include web browsers, as IPv4 address literals are still encountered in web pages and URLs. Some of these applications could still work through NAT64, provided they were able to create locally valid IPv6 presentations of peers' IPv4 addresses.  </p>
<p id="rfc.section.3.p.3">It is a known issue that passing IP address referrals, often fails in today's Internet <a href="#I-D.carpenter-referral-ps">[I-D.carpenter-referral-ps]</a>.  Synthesizing IPv6 addresses does not necessarily make the situation any better as the synthesized addresses utilizing NSP are not distinguishable from public IPv6 addresses for the referral receiver.  However, the situation is not really any different from the current Internet as using public addresses does not really guarantee reachability (for example due firewalls). A node 'A' behind NAT64 may detect it is talking to a node 'B' through NAT64, in which case the node 'A' may want to avoid passing its IPv6 address as a referral to the node 'B'. The node 'B' on the IPv4 side of the NAT64 should not see the IPv6 address of a node 'A' from the IPv6 side of NAT64, and hence the node 'B' should not be able to pass IPv6 address referral to a node 'C'. Passing IPv4 presentation of the IPv6 address of the host 'A' to the node 'C' is bound to similar problems as passing a public IPv4 address of a host behind NAT44 as a referral. This analysis focuses on detecting NAT64 presence from the IPv6 side of NAT64.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Proposed solutions to learn about synthesis and Network-Specific Prefix</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> DNS Query for a Well-Known Name</h1>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> Solution description</h1>
<p id="rfc.section.4.1.1.p.1">Section 3 of <a href="#I-D.savolainen-heuristic-nat64-discovery">[I-D.savolainen-heuristic-nat64-discovery]</a> describes a host behavior for discovering the presence of a DNS64 server and a NAT64 device, and heuristics for discovering the used NSP. A host requiring information for local IPv6 address synthesis or for NAT64 avoidance sends a DNS query for an AAAA record of a Well-Known IPv4-only Fully Qualified Domain Name (FQDN). If a host receives a negative reply, it knows there are no DNS64 and NAT64 in the network.  </p>
<p id="rfc.section.4.1.1.p.2">If a host receives AAAA reply, it knows the network must be utilizing IPv6 address synthesis. After receiving a synthesized AAAA Resource Record, the host may examine the received IPv6 address and use heuristics, such as "subtracting" the known IPv4 address out of synthesized IPv6 address, to find out the NSP.</p>
<p id="rfc.section.4.1.1.p.3">The Well-Known Name may be assigned by IANA or provided some third party, including application or operating system vendor. The IPv4 address corresponding to the Well-Known Name may be resolved via A query to Well-Known Name, assigned by IANA, or hard-coded.  </p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.1.2.p.1">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1 and Issue #2.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Solves issue #4 via DNS record lifetime.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can partially solve issue #5 if multiple synthetic AAAA records are included in the response. Can find multiple address formats.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not necessarily require any standards effort.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require host stack or resolver changes. All required logic and heuristics can be implemented in applications that are interested in learning about address synthesis taking place.</dd>
<dt>+</dt>
<dd style="margin-left: 2">The solution is backward compatible from 'legacy' hosts and servers point of view.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Hosts or applications interested in learning about synthesis and the used NSP can do the "discovery" proactively at any time, for example every time the host attaches to a new network.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require explicit support from the network using NAT64</dd>
</dl>

<p> </p>
<p id="rfc.section.4.1.2.p.2">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires hosting of a DNS resource record for the Well-Known Name. </dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not provide solution for issue #3.</dd>
<dt>-</dt>
<dd style="margin-left: 2">This method is only able to find one NSP even if a network is utilizing multiple NSPs (issue #5) (unless DNS64 includes multiple synthetic AAAA records in response).</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> Summary</h1>
<p id="rfc.section.4.1.3.p.1">This is the only approach that can be deployed without explicit support from the network or the host. This approach could also complement explicit methods and be used as a fallback approach when explicit methods are not supported by an access network.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#edns0opt" id="edns0opt">EDNS0 option indicating AAAA Record synthesis and format</a>
</h1>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> Solution description</h1>
<p id="rfc.section.4.2.1.p.1">Section 3 of <a href="#I-D.korhonen-edns0-synthesis-flag">[I-D.korhonen-edns0-synthesis-flag]</a> defines a new EDNS0 option <a href="#RFC2671">[RFC2671]</a>, which contain 3 flag bits (called SY-bits). The EDNS0 option serves as an implicit indication of the presence of DNS64 server and the NAT64 device. The EDNS0 option SY-bit values other than '000' and '111' explicitly tell the NSP prefix length. Only the DNS64 server can insert the EDNS0 option and the required SY-bits combination into the synthesized AAAA Resource Record.  </p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.2.2.p.1">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1 and is designed to explicitly solve Issue #2.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Solves issue #4 via DNS record lifetime.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can partially solve issue #5 if multiple synthetic AAAA records are included in the response and all use same format.</dd>
<dt>+</dt>
<dd style="margin-left: 2">The solution is backward compatible from 'legacy' hosts and servers point of view.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Even if the solution is bundled with DNS queries and responses, a standardization of a new DNS record type is not required, rather just defining a new EDNS0 option.</dd>
<dt>+</dt>
<dd style="margin-left: 2">EDNS0 option implementation requires changes only to DNS64 servers.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require additional provisioning or management as the EDNS0 option is added automatically by the DNS64 server to the responses.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not involve additional queries towards the global DNS infrastructure as EDNS0 logic can be handled within the DNS64 server.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.2.2.p.2">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires end hosts to support <a href="#RFC2671">[RFC2671]</a> EDSN0 extension mechanism.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires host resolver changes and a mechanism/additions to the host resolver API (or flags, hints etc) to deliver a note to the querying application that the address is synthesized and what is the NSP prefix length.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a modification to DNS64 servers to include the EDNS0 option to the synthesized responses.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not provide solution for issue #3.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> Summary</h1>
<p id="rfc.section.4.2.3.p.1">The EDNS0 option based solution works by extending the existing EDNS0 Resource Record. Although the solution has host resolver and DNS64 server impacts, the changes are limited to those entities (end host, applications) that are interested in learning the presence of NAT64 and the used NAT64 prefix. The provisioning and management overhead is minimal if not non-existent as the EDNS0 options are synthesized in a DNS64 server in a same manner as the synthesized AAAA Resource Records. Moreover, EDNS0 does not induce any load to DNS servers because no new RRType query is defined.  </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#edns0flags" id="edns0flags">EDNS0 flags indicating AAAA Record synthesis and format</a>
</h1>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> Solution description</h1>
<p id="rfc.section.4.3.1.p.1">Section 3 of the version -00 of <a href="#I-D.korhonen-edns0-synthesis-flag">[I-D.korhonen-edns0-synthesis-flag]</a> defines 3 new flag bits (called SY-bits) into EDNS0 OPT <a href="#RFC2671">[RFC2671]</a> header, which serve as an implicit indication of the presence of DNS64 server and a NAT64 device. SY-bit values other than '000' or '111' explicitly tell the NSP prefix length. Only the DNS64 server can insert the EDNS0 option and the required SY-bits combination into the synthesized AAAA Resource Record.  </p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.3.2.p.1">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1 and is designed to explicitly solve Issue #2.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Solves issue #4 via DNS record lifetime.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can partially solve issue #5 if multiple synthetic AAAA records are included in the response and all use same format.</dd>
<dt>+</dt>
<dd style="margin-left: 2">The solution is backward compatible from 'legacy' hosts and servers point of view.</dd>
<dt>+</dt>
<dd style="margin-left: 2">EDNS0 option implementation requires changes only to DNS64 servers.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require additional provisioning or management as the EDNS0 option is added automatically by the DNS64 server to the responses.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not involve additional queries towards the global DNS infrastructure as EDNS0 logic can be handled within the DNS64 server.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.3.2.p.2">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires end hosts to support <a href="#RFC2671">[RFC2671]</a> EDSN0 extension mechanism.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Consumes scarce flag bits from EDNS0 OPT header.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a host resolver changes and a mechanism/additions to the host resolver API (or flags, hints etc) to deliver a note to the querying application that the address is synthesized and what is the NSP prefix length.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a modification to DNS64 servers to include the EDNS0 option to the synthesized responses.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not provide solution for issue #3.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> Summary</h1>
<p id="rfc.section.4.3.3.p.1">This option is included here for the sake of completeness. The consumption of three bits of the limited EDNS0 OPT space can be considered unfavorable and hence is unlikely to be accepted.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#a64" id="a64">DNS Resource Record for IPv4-Embedded IPv6 address</a>
</h1>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> Solution description</h1>
<p id="rfc.section.4.4.1.p.1">Section 4 of <a href="#I-D.boucadair-behave-dns-a64">[I-D.boucadair-behave-dns-a64]</a> defines a new DNS Resource Record (A64) that is a record specific to store a single IPv4-Embedded IPv6 address <a href="#RFC6052">[RFC6052]</a>. Using a dedicated Resource Record allows a host to distinguish between real IPv6 addresses and synthesized IPv6 addresses. The solution requires host to send a query for an A64 record. Positive answer with A64 record informs the requesting host that the resolved address is not a native address but an IPv4-Embedded IPv6 address. This would ease the local policies to prefer direct communications (i.e., avoid using IPv4-Embedded IPv6 addresses when a native IPv6 address or a native IPv4 address is available). Applications may be notified via new or modified API.  </p>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> Analysis and discussion</h1>
<p></p>
<p id="rfc.section.4.4.2.p.2">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1 and #5.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Solves issue #4 via DNS record lifetime.</dd>
<dt>+</dt>
<dd style="margin-left: 2">The solution is backward compatible from 'legacy' hosts and servers point of view.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Synthesized addresses can be used in authoritative DNS servers.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Maintains the reliability of the DNS model (i.e., a synthesised IPv6 address is presented as such and not as native IPv6 address).</dd>
<dt>+</dt>
<dd style="margin-left: 2">When both IPv4-Converted and native IPv6 addresses are configured for the same QNAME, native addresses are preferred.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.4.2.p.3">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Does not address Issue #2 or #3 in any way.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a host resolver changes and a mechanism/additions to the host resolver API (or flags, hints etc) to deliver a note to the querying application that the address is synthesized.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a standardization of a new DNS Resource Record type (A64), and the implementation of it in both resolvers and servers.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a coordinated deployment between different flavors of DNS servers within the provider to work deterministically.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Additional load the DNS servers (3 Queries, A64, AAAA and A, may be issued by a dual-stack host).</dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not help to identify synthesized IPv6 addresses if the session does not involve any DNS queries.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> Summary</h1>
<p id="rfc.section.4.4.3.p.1">While the proposed solution delivers explicit information about address synthesis taking place solving the Issue #1, a standardization of a new DNS record type might turn out a too overwhelming task for a solution for a temporary transition phase. Defining a new record type increases load towards DNS server as the host issues parallel A64, AAAA and A queries.  </p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> Learning the IPv6 Prefix of a Network's NAT64 using DNS</h1>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> Solution description</h1>
<p id="rfc.section.4.5.1.p.1">Section 4.1 of the version -04 of <a href="#I-D.wing-behave-learn-prefix">[I-D.wing-behave-learn-prefix]</a> actually proposes two DNS-based method for discovering the presence of a DNS64 server and a NAT64 device, and then a mechanism for discovering the used NSP. First, a host may learn the presence of a DNS64 server and a NAT64 device, by receiving a TXT Resource Record with a well-known (TBD IANA registered?) string followed by the NAT64 unicast IPv6 address and the prefix length. The DNS64 server would add the TXT Resource Record into the  DNS response.  </p>
<p id="rfc.section.4.5.1.p.2">Second, Section 4.1 of the version -04 of <a href="#I-D.wing-behave-learn-prefix">[I-D.wing-behave-learn-prefix]</a> also proposes specifying a new U-NAPTR <a href="#RFC4848">[RFC4848]</a> application to discover the NAT64's IPv6 prefix and length. The input domain name is exactly the same as would be used for a reverse DNS lookup, derived from the host's IPv6 in the ".ip6.arpa." tree. The host doing the U-NAPTR queries may need multiple queries until finds the provisioned domain name with the correct prefix length. The response to a successful U-NATPR query contains the unicast IPv6 address and the prefix length of the NAT64 device.  </p>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.5.2.p.1">[Editor' note: can this be made to solve issue #5 by having multiple NSPs in TXT record?]</p>
<p id="rfc.section.4.5.2.p.2">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1 and Issue #2.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Solves issue #4 via DNS record lifetime.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require host stack or resolver changes if the required logic and heuristics is implemented in applications that are interested in learning about address synthesis taking place.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.5.2.p.3">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires standardization of a well-known names from IANA for TXT Resource Record and/or a standardization of a new U-NAPTR application.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires a host resolver changes and a mechanism/additions to the host resolver API (or flags, hints etc) to deliver a note to the querying application that the address is synthesized and what is the NSP prefix length. However, it is possible that the U-NAPTR application logic is completely implemented by the application itself as noted in PROs list.</dd>
<dt>-</dt>
<dd style="margin-left: 2">U-NAPTR prefix learning method may entail multiple queries.</dd>
<dt>-</dt>
<dd style="margin-left: 2">U-NAPTR prefix learning method requires provisioning of NSPs in ".ip6.arpa." tree.</dd>
<dt>-</dt>
<dd style="margin-left: 2">RFC5507 <a href="#RFC5507">[RFC5507]</a> specifically recommends against reusing TXT Resource Records to expand DNS.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires configuration on the access network's DNS servers.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not provide solution for issue #3.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> Summary</h1>
<p id="rfc.section.4.5.3.p.1">The implementation of this solution requires some changes to the applications and resolvers in a similar fashion as in solutions in <a href="#edns0opt">Section 4.2</a>, <a href="#edns0flags">Section 4.3</a> and <a href="#a64">Section 4.4</a>. Unlike the other DNS-based approaches, the U-NAPTR-based solution also requires provisioning information into the '.ip6.arpa.' tree which is not any more entirely internal to the provider hosting the NAT64/DNS64 service.  </p>
<p id="rfc.section.4.5.3.p.2">The iterative approach of learning the NAT64 prefix in U-NAPTR-based solution may result in multiple DNS queries, which can be considered more complex and inefficient compared to other DNS-based solutions.  </p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#learndhcpv6" id="learndhcpv6">Learning the IPv6 Prefix of a Network's NAT64 using DHCPv6</a>
</h1>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> Solution description</h1>
<p id="rfc.section.4.6.1.p.1">Two individual drafts specify DHCPv6 based approaches.</p>
<p id="rfc.section.4.6.1.p.2">Section 4.2 of the version -04 of <a href="#I-D.wing-behave-learn-prefix">[I-D.wing-behave-learn-prefix]</a> describes a new DHCPv6 <a href="#RFC3315">[RFC3315]</a> option (OPTION_AFT_PREFIX_DHCP) that contains the IPv6 unicast prefix, IPv6 ASM prefix, and IPv6 SSM prefix (and their lengths) for the NAT64.  </p>
<p id="rfc.section.4.6.1.p.3">Section 4 of <a href="#I-D.boucadair-dhcpv6-shared-address-option">[I-D.boucadair-dhcpv6-shared-address-option]</a> defines a DHCPv6 option that can be used to communicate to a requesting host the prefix used for building IPv4-Converted IPv6 addresses together with the format type and therefore also the used address synthesis algorithm.  Provisioning the format type is required so as to be correctly handled by the NAT64-enabled devices deployed in a given domain.  </p>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.6.2.p.1">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1, Issue #2, Issue #3 and Issue #4 via DHCPv6 information lifetime.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not involve DNS system. Therefore, applications that would not normally initiate any DNS queries can still learn the NAT64 prefix.</dd>
<dt>+</dt>
<dd style="margin-left: 2">DHCPv6 is designed to provide various kinds of configuration information in a centrally managed fashion.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.6.2.p.2">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Change of NSP requires change to DHCPv6 configuration.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires at least Stateless DHCPv6 client on hosts.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires support on DHCPv6 clients, which is not trivial in all operating systems.</dd>
<dt>-</dt>
<dd style="margin-left: 2">The DHCPv6-based solution involves changes and management on network side nodes that are not really part of the NAT64/DNS64 deployment (or issues caused by their existence).</dd>
<dt>-</dt>
<dd style="margin-left: 2">A new DHCPv6 option is required and the corresponding changes to both DHCPv6 clients and servers.</dd>
</dl>
<p id="rfc.section.4.6.2.p.3">If DHCPv6 would include multiple NSPs issue #5 could be solved as well, but only if nodes as a group would select different NSPs hence supporting load-balancing. As this is not clear this item is not yet listed under PRO nor CON.</p>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> Summary</h1>
<p id="rfc.section.4.6.3.p.1">The DHCPv6-based solution would be a good solution in a sense it hooks into general IP configuration phase, allows easy updates when configuration information changes and does not involve DNS in general. Use of DHCPv6 requires configuration changes on DHCPv6 clients and servers and in some cases may also require implementation changes. Furthermore, it is not obvious that all devices that need translation services would implement stateless DHCPv6. For example, cellular 3GPP networks do not mandate hosts or network to implement or deploy DHCPv6.  </p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> <a href="#learnra" id="learnra">Learning the IPv6 Prefix of a Network's NAT64 using Router Advertisements</a>
</h1>
<h1 id="rfc.section.4.7.1">
<a href="#rfc.section.4.7.1">4.7.1.</a> Solution description</h1>
<p id="rfc.section.4.7.1.p.1">Section 3.3 of the version -03 of <a href="#I-D.wing-behave-learn-prefix">[I-D.wing-behave-learn-prefix]</a> describes a new Router Advertisement (RA) <a href="#RFC4861">[RFC4861]</a> option (OPTION_AFT_PREFIX_RA) that contains the IPv6 unicast prefix, IPv6 ASM prefix, and IPv6 SSM prefix (and their lengths) for the NAT64. The RA option is essentially the same as for DHCPv6 discussed in <a href="#learndhcpv6">Section 4.6</a>.  </p>
<h1 id="rfc.section.4.7.2">
<a href="#rfc.section.4.7.2">4.7.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.7.2.p.1">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1, Issue #2, and Issue #3.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can solve Issue #4 if lifetime information can be communicated.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.7.2.p.2">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires configuration and managements of all access routers to emit correct information in RA. This could, for example, be accomplished somehow by piggybacking on top of routing protocols (which would then require enhancements to routing protocols)</dd>
<dt>-</dt>
<dd style="margin-left: 2">In some operating systems it may not be trivial to transfer information obtained in RA to upper layers</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires changes to host operating system's IP stack</dd>
<dt>-</dt>
<dd style="margin-left: 2">NSP change requires changes to access router configuration</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires standardization of a new option to Router Advertisement that is generally unfavored approach</dd>
<dt>-</dt>
<dd style="margin-left: 2">The RA-based solution involves changes and management on network side nodes that are not really part of the NAT64/DNS64 deployment (or issues caused by their existence).  </dd>
</dl>
<p id="rfc.section.4.7.2.p.3">If RA would include multiple NSPs issue #5 could be solved as well, but only if nodes as a group would select different NSPs hence supporting load-balancing. As this is not clear this item is not yet listed under PRO nor CON.</p>
<h1 id="rfc.section.4.7.3">
<a href="#rfc.section.4.7.3">4.7.3.</a> Summary</h1>
<p id="rfc.section.4.7.3.p.1">The RA-based solution would be a good solution in a sense it hooks into general IP configuration phase, allows easy updates when configuration information changes and does not involve DNS in general. However, generally introducing any changes to the Neighbor Discovery Protocol that are not absolutely necessary are unfavored due the impact on both network node side and end host IP stack implementations.  </p>
<p id="rfc.section.4.7.3.p.2">Compared to the DHCPv6 equivalent solution in <a href="#learndhcpv6">Section 4.6</a> the management overhead is greater with RA-based solution. In case of DHCPv6-based solution the management can be centralized to few DHCPv6 servers compared to RA-based solution where each access router is supposed to be configured with the same information.  </p>
<h1 id="rfc.section.4.8">
<a href="#rfc.section.4.8">4.8.</a> Using application layer protocols such as STUN</h1>
<h1 id="rfc.section.4.8.1">
<a href="#rfc.section.4.8.1">4.8.1.</a> Solution description</h1>
<p id="rfc.section.4.8.1.p.1">Application layer protocols, such as Session Traversal Utilities for NAT (STUN) <a href="#RFC5389">[RFC5389]</a>, which define methods for endpoints to learn their external IP addresses could be used for NAT64 and NSP discovery.  This document focuses on STUN, but the protocol could be something else as well.  </p>
<p id="rfc.section.4.8.1.p.2">A host must first use DNS to discover IPv6 representation(s) of STUN server(s) IPv4 address(es), because the host has no way to directly use IPv4 addresses to contact to STUN server(s).</p>
<p id="rfc.section.4.8.1.p.3">After learning the IPv6 address of a STUN server the STUN client sends a request to the STUN server containing new 'SENDING-TO' attribute that tells to the server the IPv6 address the client sent the request to.  In a reply the server includes another new attribute called 'RECEIVED-AS', which contains server's IP address the request arrived on. After receiving the reply the client compares 'SENDING-TO' and 'RECEIVED-AS' attributes to find out an NSP candidate.</p>
<h1 id="rfc.section.4.8.2">
<a href="#rfc.section.4.8.2">4.8.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.8.2.p.1">This solution is relatively similar as described in section 4.3, but instead of using DNS uses STUN to get input for heuristic algorithms.</p>
<p id="rfc.section.4.8.2.p.2">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1 and Issue #2.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require host changes or supportive protocols such as DNS or DHCPv6. All required logic and heuristics can be implemented in applications that are interested in learning about address synthesis taking place.</dd>
<dt>+</dt>
<dd style="margin-left: 2">The solution is backward compatible from 'legacy' hosts and servers point of view.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Hosts or applications interested in learning about synthesis and the used NSP can do the "discovery" proactively at any time, for example every time the host attaches to a new network.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Does not require explicit support from the network using NAT64.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can possibly be bundled to existing STUN message exchanges as new attributes and hence client can learn its external IPv4 address and a NSP/WKP with the same exchange</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to confirm the heuristics by synthesizing IPv6 address of another STUN server or by synthesizing IPv6 address of first STUN server after host has heuristically determined NSP using method from section 4.3. I.e. the connectivity test could be done with STUN.</dd>
<dt>+</dt>
<dd style="margin-left: 2">True IPv4 destination address is used in NSP determination instead of IPv4 address received from DNS. This may increase reliability.</dd>
<dt>+</dt>
<dd style="margin-left: 2">The same STUN improvement could also be used to reveal NAT66 on the data path, if the 'RECEIVED-AS' would contain different IPv6 address than 'SENDING-TO'.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.8.2.p.3">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires a server on the network to respond the queries.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires standardization if done as extension to STUN.</dd>
<dt>-</dt>
<dd style="margin-left: 2">The solution involves changes and management on network side nodes that are not really part of the NAT64/DNS64 deployment (or issues caused by their existence).  </dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not solve issue #3 if STUN server's synthetic IPv6 address is provisioned via DNS.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not solve issue #4 as the STUN server would not be aware of learned NSP's validity time.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Does not solve issue #5 as the STUN server would not be aware of multiple NSP prefixes.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Heavyweight solution especially if an application does not otherwise support STUN.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.8.3">
<a href="#rfc.section.4.8.3">4.8.3.</a> Summary</h1>
<p id="rfc.section.4.8.3.p.1">The STUN, or similar, protocol based approach is a second way to solve the problem without explicit access network support.  The heuristics for NSP discovery would still be in the client, however, the result may be more reliable as actual IPv4 destination address is compared to IPv6 address used in sending. The additional benefit of STUN is that the client learns its public IPv4 address with the same message exchange. STUN could also be used as the connectivity test tool if the client would first heuristically determine NSP out of DNS as described in section 4.3, synthesize IPv6 representation of STUN server's IPv4 address, and then tests connectivity to the STUN server.  </p>
<p id="rfc.section.4.8.3.p.2">As an additional benefit the STUN improvement could be used for NAT66 discovery.  </p>
<h1 id="rfc.section.4.9">
<a href="#rfc.section.4.9">4.9.</a> Learning the IPv6 Prefix of a Network's NAT64 using Access Technology Specific Methods</h1>
<h1 id="rfc.section.4.9.1">
<a href="#rfc.section.4.9.1">4.9.1.</a> Solution description</h1>
<p id="rfc.section.4.9.1.p.1">Several link layers on different access systems have an attachment time signaling protocols to negotiate various parameter used later on the established link layer connection. Examples of such include 3GPP Non-Access-Stratum (NAS) signaling protocol <a href="#NAS.24.301">[NAS.24.301]</a> among other link layers and tunneling solutions. There, using NAS signaling it could be possible to list all NSPs with their respective prefix lengths in generic protocol configuration option containers during the network access establishment. The lack of NSPs in protocol configuration option containers would be an implicit indication that there is no NAT64 present in the network.  </p>
<h1 id="rfc.section.4.9.2">
<a href="#rfc.section.4.9.2">4.9.2.</a> Analysis and discussion</h1>
<p id="rfc.section.4.9.2.p.1">The PROs of the proposal are listed below: </p>

<dl>
<dt>+</dt>
<dd style="margin-left: 2">Can be used to solve Issue #1, Issue #2, Issue #3 and Issue #5.</dd>
<dt>+</dt>
<dd style="margin-left: 2">Can solve Issue #4 if lifetime information is also communicated.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.9.2.p.2">The CONs of the proposal are listed below: </p>

<dl>
<dt>-</dt>
<dd style="margin-left: 2">Requires configuration and managements of all access routers/gateway to emit correct information in "link/lower layer" signaling. In a case the NAT64 functionality is implemented into the access router/gateway itself that terminates the generic protocol configuration exchange, then the configuration management can be automated.</dd>
<dt>-</dt>
<dd style="margin-left: 2">In some operating systems it may not be trivial to transfer information obtained in "link/lower layers" to upper layers.</dd>
<dt>-</dt>
<dd style="margin-left: 2">NSP change may require changes to access router/gateway configuration.</dd>
<dt>-</dt>
<dd style="margin-left: 2">Requires standardization of a new configuration parameter exchange/container for each access system of interest. The proposed solution is indeed specific to each access technology.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.9.3">
<a href="#rfc.section.4.9.3">4.9.3.</a> Summary</h1>
<p id="rfc.section.4.9.3.p.1">The Access Technology-based solution would be a good solution in a sense it hooks into general network access establishment phase, allows easy updates when configuration information changes and does not involve DNS in general. However, generally introducing any changes to the link/lower layers is a long and slow router, and yet is access technology/system specific.  </p>
<p id="rfc.section.4.9.3.p.2">Compared to the RA equivalent solution in <a href="#learnra">Section 4.7</a> the management overhead is equivalent or even less than RA-based solution.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Conclusion</h1>
<p id="rfc.section.5.p.1">Our conclusion is to recommend publishing the Well-Known DNS Name heuristic discovery-based method as a standards track IETF document for applications and host implementors to implement as-is.</p>
<p id="rfc.section.5.p.2">As a general principle we prefer to have as minimal solution as possible, avoid impacts to entities not otherwise involved in the protocol translation scheme, minimize host impact, and that requires minimal to no operational effort on the network side.  </p>
<p id="rfc.section.5.p.3">Of the different issues we give most weight for issues #1 and #2. We are not giving much weight for the Issue #3 'DNS should not be required', as cases where hosts need to synthesize IPv6 addresses but do not have DNS available seem rare for us. Even if application does not otherwise utilize DNS, it ought to be able to trigger simple DNS query to find out WKP/NSP. Issue #4 is handled by majority of solutions and Issue #5 is considered to be mostly insignificant as even if individual hosts would use only one NSP at a time, different hosts would be using different NSPs, hence supporting load-balancing targets.  Only one of the discussed solutions, see <a href="#learndhcpv6">Section 4.6</a>, support learning of possible new or indicating support for multiple algorithms for address synthesis other than the one described in <a href="#RFC6052">[RFC6052]</a>.</p>
<p id="rfc.section.5.p.4">The DNS64 entity has to be configured with WKP/NSP in order for it to do synthesis and hence using DNS also for delivering the synthesis information sounds logical. The fact that the synthesis information fate-shares the information received in the DNS response is a valuable attribute and reduces the possible distribution of stale prefix information. However, having all DNS64 servers to support explicit WKP/NSP discovery (ENDS0, A64, and DNS SRV record approaches) is difficult to arrange.  The U-NAPTR-based approach would require provisioning information into the '.ip6.arpa' tree which would not be entirely internal for the provider.  Use of DHCPv6 would require additional trouble configuring DHCPv6 servers and ensuring DHCPv6 clients are in place, and furthermore that the NAT64, DHCPv6 (and possible even some DNS64) servers are all in sync. RA-based mechanisms are operationally expensive as configuration would have to be placed and maintained in the access routers.  Furthermore, both DHCPv6 and RA based mechanisms involve entities that do not otherwise need to be aware of protocol translation (only need to know DNS server addresses).  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Security Considerations</h1>
<p id="rfc.section.6.p.1">The security considerations are essentially similar to what is described in DNS64 <a href="#RFC6147">[RFC6147]</a>.  Forgery of information required for IPv6 address synthesis may allow an attacker to insert itself as middle man or to perform denial-of-service attack. The DHCPv6 and RA based approaches are vulnerable for the forgery as the attacker may send forged RAs or act as a rogue DHCPv6 server (unless DHCPv6 authentication or SEND are used). If the attacker is already able to modify and forge DNS responses (flags, addresses of know IPv4-only servers, records, etc), ability to influence local address synthesis is likely of low additional value.  Also, a DNS-based mechanism is only as secure as the method used to configure the DNS server's IP addresses on the host. Therefore, if the host cannot trust e.g. DHCPv6 it cannot trust the DNS server learned via DHCPv6 either, unless the host has a way to authenticate all DNS responses.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> IANA Considerations</h1>
<p id="rfc.section.7.p.1">This document is informative and has no actions to IANA.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Contributors</h1>
<p id="rfc.section.8.p.1">The following people have contributed text to this document.  </p>

<ul class="empty"><li>Mohamed Boucadair<br> France Telecom<br> Rennes,   35000<br> France<br><br> Email: mohamed.boucadair@orange-ftgroup.com </li></ul>

<p> </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Acknowledgements</h1>
<p id="rfc.section.9.p.1">Authors would like to thank Dan Wing and Christian Huitema especially for  the STUN idea for their valuable comments and discussions.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC6146">[RFC6146]</b></td>
<td class="top">
<a>Bagnulo, M.</a>, <a>Matthews, P.</a> and <a>I. van Beijnum</a>, "<a href="http://tools.ietf.org/html/rfc6146">Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers</a>", RFC 6146, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6147">[RFC6147]</b></td>
<td class="top">
<a>Bagnulo, M.</a>, <a>Sullivan, A.</a>, <a>Matthews, P.</a> and <a>I. van Beijnum</a>, "<a href="http://tools.ietf.org/html/rfc6147">DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers</a>", RFC 6147, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3484">[RFC3484]</b></td>
<td class="top">
<a>Draves, R.</a>, "<a href="http://tools.ietf.org/html/rfc3484">Default Address Selection for Internet Protocol version 6 (IPv6)</a>", RFC 3484, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4848">[RFC4848]</b></td>
<td class="top">
<a>Daigle, L.</a>, "<a href="http://tools.ietf.org/html/rfc4848">Domain-Based Application Service Location Using URIs and the Dynamic Delegation Discovery Service (DDDS)</a>", RFC 4848, April 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3315">[RFC3315]</b></td>
<td class="top">
<a>Droms, R.</a>, <a>Bound, J.</a>, <a>Volz, B.</a>, <a>Lemon, T.</a>, <a>Perkins, C.</a> and <a>M. Carney</a>, "<a href="http://tools.ietf.org/html/rfc3315">Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</a>", RFC 3315, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4861">[RFC4861]</b></td>
<td class="top">
<a>Narten, T.</a>, <a>Nordmark, E.</a>, <a>Simpson, W.</a> and <a>H. Soliman</a>, "<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>", RFC 4861, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6052">[RFC6052]</b></td>
<td class="top">
<a>Bao, C.</a>, <a>Huitema, C.</a>, <a>Bagnulo, M.</a>, <a>Boucadair, M.</a> and <a>X. Li</a>, "<a href="http://tools.ietf.org/html/rfc6052">IPv6 Addressing of IPv4/IPv6 Translators</a>", RFC 6052, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4566">[RFC4566]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2326">[RFC2326]</b></td>
<td class="top">
<a href="mailto:schulzrinne@cs.columbia.edu" title="Columbia University, Dept. of Computer Science">Schulzrinne, H.</a>, <a href="mailto:anup@netscape.com" title="Netscape Communications Corp.">Rao, A.</a> and <a href="mailto:robla@real.com" title="RealNetworks">R. Lanphier</a>, "<a href="http://tools.ietf.org/html/rfc2326">Real Time Streaming Protocol (RTSP)</a>", RFC 2326, April 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3261">[RFC3261]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5389">[RFC5389]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2671">[RFC2671]</b></td>
<td class="top">
<a href="mailto:vixie@isc.org" title="Internet Software Consortium">Vixie, P.</a>, "<a href="http://tools.ietf.org/html/rfc2671">Extension Mechanisms for DNS (EDNS0)</a>", RFC 2671, August 1999.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC6144">[RFC6144]</b></td>
<td class="top">
<a>Baker, F.</a>, <a>Li, X.</a>, <a>Bao, C.</a> and <a>K. Yin</a>, "<a href="http://tools.ietf.org/html/rfc6144">Framework for IPv4/IPv6 Translation</a>", RFC 6144, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5507">[RFC5507]</b></td>
<td class="top">
<a>IAB</a><a>Faltstrom, P.</a>, <a>Austein, R.</a> and <a>P. Koch</a>, "<a href="http://tools.ietf.org/html/rfc5507">Design Choices When Expanding the DNS</a>", RFC 5507, April 2009.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.venaas-behave-mcast46">[I-D.venaas-behave-mcast46]</b></td>
<td class="top">
<a>Venaas, S</a>, <a>Asaeda, H</a>, <a>SUZUKI, S</a> and <a>T Fujisaki</a>, "<a href="http://tools.ietf.org/html/draft-venaas-behave-mcast46-02">An IPv4 - IPv6 multicast translator</a>", Internet-Draft draft-venaas-behave-mcast46-02, December 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.venaas-behave-v4v6mc-framework">[I-D.venaas-behave-v4v6mc-framework]</b></td>
<td class="top">
<a>Venaas, S</a>, <a>Li, X</a> and <a>C Bao</a>, "<a href="http://tools.ietf.org/html/draft-venaas-behave-v4v6mc-framework-03">Framework for IPv4/IPv6 Multicast Translation</a>", Internet-Draft draft-venaas-behave-v4v6mc-framework-03, June 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.korhonen-edns0-synthesis-flag">[I-D.korhonen-edns0-synthesis-flag]</b></td>
<td class="top">
<a>Korhonen, J</a> and <a>T Savolainen</a>, "<a href="http://tools.ietf.org/html/draft-korhonen-edns0-synthesis-flag-02">EDNS0 Option for Indicating AAAA Record Synthesis and Format</a>", Internet-Draft draft-korhonen-edns0-synthesis-flag-02, February 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.savolainen-heuristic-nat64-discovery">[I-D.savolainen-heuristic-nat64-discovery]</b></td>
<td class="top">
<a>Savolainen, T</a> and <a>J Korhonen</a>, "<a href="http://tools.ietf.org/html/draft-savolainen-heuristic-nat64-discovery-01">Discovery of a Network-Specific NAT64 Prefix using a Well-Known Name</a>", Internet-Draft draft-savolainen-heuristic-nat64-discovery-01, February 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.boucadair-behave-dns-a64">[I-D.boucadair-behave-dns-a64]</b></td>
<td class="top">
<a>Boucadair, M</a> and <a>E Burgey</a>, "<a href="http://tools.ietf.org/html/draft-boucadair-behave-dns-a64-02">A64: DNS Resource Record for IPv4-Embedded IPv6 Address</a>", Internet-Draft draft-boucadair-behave-dns-a64-02, September 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.wing-behave-learn-prefix">[I-D.wing-behave-learn-prefix]</b></td>
<td class="top">
<a>Wing, D</a>, "<a href="http://tools.ietf.org/html/draft-wing-behave-learn-prefix-04">Learning the IPv6 Prefix of a Network's IPv6/IPv4 Translator</a>", Internet-Draft draft-wing-behave-learn-prefix-04, October 2009.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.boucadair-dhcpv6-shared-address-option">[I-D.boucadair-dhcpv6-shared-address-option]</b></td>
<td class="top">
<a>Boucadair, M</a>, <a>Levis, P</a>, <a>Grimault, J</a>, <a>Savolainen, T</a> and <a>G Bajko</a>, "<a href="http://tools.ietf.org/html/draft-boucadair-dhcpv6-shared-address-option-01">Dynamic Host Configuration Protocol (DHCPv6) Options for Shared IP Addresses Solutions</a>", Internet-Draft draft-boucadair-dhcpv6-shared-address-option-01, December 2009.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.carpenter-referral-ps">[I-D.carpenter-referral-ps]</b></td>
<td class="top">
<a>Carpenter, B</a>, <a>Jiang, S</a> and <a>Z Cao</a>, "<a href="http://tools.ietf.org/html/draft-carpenter-referral-ps-02">Problem Statement for Referral</a>", Internet-Draft draft-carpenter-referral-ps-02, February 2011.</td>
</tr>
<tr>
<td class="reference"><b id="NAS.24.301">[NAS.24.301]</b></td>
<td class="top">
<a>3GPP</a>, "<a>Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS) </a>", 3GPP TS 24.301 8.8.0, December 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jouni Korhonen</span> editor
	  <span class="n hidden">
		<span class="family-name">Korhonen</span>
	  </span>
	</span>
	<span class="org vcardline">Nokia Siemens Networks</span>
	<span class="adr">
	  <span>Linnoitustie 6</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code">FI-02600 Espoo</span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jouni.nospam@gmail.com">jouni.nospam@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Teemu Savolainen</span> editor
	  <span class="n hidden">
		<span class="family-name">Savolainen</span>
	  </span>
	</span>
	<span class="org vcardline">Nokia</span>
	<span class="adr">
	  <span>Hermiankatu 12 D</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code">FI-33720 Tampere</span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:teemu.savolainen@nokia.com">teemu.savolainen@nokia.com</a></span>

  </address>
</div>

</body>
</html>