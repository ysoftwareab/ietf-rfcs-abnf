<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>NewReno Modification for Smooth Recovery After Fast Retransmission</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="NewReno Modification for Smooth Recovery After Fast Retransmission">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">Y. Nishida</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">WIDE Project</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">March 02, 2010</td></tr>
<tr><td class="header">Expires: September 3, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />NewReno Modification for Smooth Recovery After Fast Retransmission<br />draft-nishida-newreno-modification-02</h1>

<h3>Abstract</h3>

<p>
	    This memo describes a feeble point in Fast Recovery algorithm in NewReno defined
	    in RFC3782 and proposes a simple modification to solve the problem.
         
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 3, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Conventions and Terminology<br />
<a href="#anchor3">3.</a>&nbsp;
Problem Description<br />
<a href="#anchor4">4.</a>&nbsp;
Possible Scenarios<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.1.</a>&nbsp;
Case 1: Small Sending Window Size at Sender<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.2.</a>&nbsp;
Case 2: Zero Window Advertisement from Receiver<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.3.</a>&nbsp;
Case 3: Lost of ACK segments<br />
<a href="#anchor8">5.</a>&nbsp;
Discussion<br />
<a href="#anchor9">6.</a>&nbsp;
Proposed Fix<br />
<a href="#anchor10">7.</a>&nbsp;
Simulation Results<br />
<a href="#anchor11">8.</a>&nbsp;
Security Considerations<br />
<a href="#anchor12">9.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
	  There are some situations that NewReno cannot recover quickly after the success
	  of fast retransmission. This issue is resulted from a feeble point in Fast Recovery
	  algorithm in NewReno defined in RFC3782 <a class='info' href='#RFC3782'>[RFC3782]<span> (</span><span class='info'>Floyd, S., Henderson, T., and A. Gurtov, &ldquo;The NewReno Modification to TCP's Fast Recovery Algorithm,&rdquo; April&nbsp;2004.</span><span>)</span></a>.
	  This document describes the
	  point in Fast Recovery and presents possible scenarios. This memo also propose a
	  simple modification to fix this problem.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conventions and Terminology</h3>

<p>
	  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
	  document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
	  
</p>
<p>
	  Since this document describes a potential risk in NewReno, it uses the same 
      terminology and definitions in RFC3782 <a class='info' href='#RFC3782'>[RFC3782]<span> (</span><span class='info'>Floyd, S., Henderson, T., and A. Gurtov, &ldquo;The NewReno Modification to TCP's Fast Recovery Algorithm,&rdquo; April&nbsp;2004.</span><span>)</span></a>.
	  Which means this documents assumes that the reader is familiar with the 
	  terms SENDER MAXIMUM SEGMENT SIZE (SMSS), CONGESTION WINDOW (cwnd), 
      and FLIGHT SIZE (FlightSize) defined in <a class='info' href='#RFC2581'>[RFC2581]<span> (</span><span class='info'>Allman, M., Paxson, V., and W. Stevens, &ldquo;TCP Congestion Control,&rdquo; April&nbsp;1999.</span><span>)</span></a>. 
	  
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Problem Description</h3>

<p>
	  This section describes a potential risk in Fast Retransmit and Fast Recovery
	  Algorithm in RFC3782. 
</p>
<p>
	    Section 3 in RFC3782 describes the Fast Retransmit and Fast Recovery Algorithm
	    in NewReno. The algorithm consists of 6 steps. The following lines are the description
	    of the fifth steps which describes the behavior for the arrival of the first Full ACK
	    after first retransmission.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  5)  When an ACK arrives that acknowledges new data, this ACK could be
      the acknowledgment elicited by the retransmission from step 2, or
      elicited by a later retransmission.

      Full acknowledgements:

      If this ACK acknowledges all of the data up to and including
      "recover", then the ACK acknowledges all the intermediate
      segments sent between the original transmission of the lost
      segment and the receipt of the third duplicate ACK.  Set cwnd to
      either (1) min (ssthresh, FlightSize + SMSS) or (2) ssthresh
      where ssthresh is the value set in step 1; this is termed
      "deflating" the window.  (We note that "FlightSize" in step 1
      referred to the amount of data outstanding in step 1, when Fast
      Recovery was entered, while "FlightSize" in step 5 refers to the
      amount of data outstanding in step 5, when Fast Recovery is
      exited.)
</pre></div>
<p>
</p>
<p>
    According to this description, the cwnd after the first FULL ACK reception
    will be one of the followings. 
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         (1) min (ssthresh, FlightSize + SMSS)
         (2) ssthresh
</pre></div>
<p>
</p>
<p>
    However, there is a risk in (1) which can cause performance degradation.
    In (1), if FlightSize is zero, the result of (1) will be 1 SMSS. (ssthresh
    should be bigger than 1)  This means TCP can transmit only 1 segment in this case.
    This can cause the delay in ACK transmission at the receiver side if the receiver
    use delayed ACK algorithm. The FlightSize in (1) represents the amount
    of data outstanding in the fifth step: the moment when the new Full ACK arrives.
    The next section describes several scenarios where the FlightSize becomes zero.
	    
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Possible Scenarios</h3>

<p>
   There are several possible situations that FlightSize becomes zero when the first
   new full ACK arrives after fast retransmission. This section describe several
   possible cases.

</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Case 1: Small Sending Window Size at Sender</h3>

<p>
    This is the tcpdump example of the case. This log is recorded at A.
    
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      1  10:41:00.000001 A &gt; B: . 1000:2000(1000) ack 1 win 32768
      2  10:41:00.001001 A &gt; B: . 2000:3000(1000) ack 1 win 32768
      3  10:41:00.002001 A &gt; B: . 3000:4000(1000) ack 1 win 32768
      4  10:41:00.003001 A &gt; B: . 4000:5000(1000) ack 1 win 32768
      5  10:41:00.010001 B &gt; A: . ack 1000 win 16384
      6  10:41:00.011001 B &gt; A: . ack 1000 win 16384
      7  10:41:00.012001 B &gt; A: . ack 1000 win 16384
      8  10:41:00.013001 A &gt; B: . 1000:2000(1000) ack 1 win 32768
      9  10:41:00.014001 A &gt; B: . 5000:6000(1000) ack 1 win 32768
     10  10:41:00.024001 B &gt; A: . ack 6000 win 16384
     11  10:41:00.025001 A &gt; B: . 6000:7000(1000) ack 1 win 32768

</pre></div>
<p>
</p>
<p>
   In this example, A sends data segments to B. At the beginning of the log,
    the cwnd of A is 4 SMSS, hence A sends 4 segments to B (line 1-4).
    Here, if the segment sent in line 1 (segment 1000:2000) is lost, B sends
    3 duplicated ACKs for the lost segment (line 5-7) to ask retransmission.
    At line 8, A receives 3 duplicated ACKs then it transmits the lost segment.
    At line 9, A sets cwnd to ssthresh plus 3*SMSS (as defined in the second steps
    in NewReno algorithm) and cwnd becomes 5 SMSS as the result. This window
    inflation allows A to transmit one new segment.
   
</p>
<p>
   Since the two segments in line 8 and 9 are usually transmitted almost at the same
    time, the receiver may send back only one ACK for these two segments (line 10)
    The ACK received in line 10 is the first Full ACK and there is no out-standing
    data in this moment. Hence, new cwnd is set to 1 SMSS and only one new segment
    is sent (line 11)
    
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Case 2: Zero Window Advertisement from Receiver</h3>

<p>
    This is the tcpdump example of the case. This log is recorded at A.
    
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      1  11:42:00.000001 A &gt; B: . 1000:2000(1000) ack 1 win 32768
      2  11:42:00.001001 A &gt; B: . 2000:3000(1000) ack 1 win 32768
      3  11:42:00.002001 A &gt; B: . 3000:4000(1000) ack 1 win 32768
      4  11:42:00.003001 A &gt; B: . 4000:5000(1000) ack 1 win 32768
      5  11:42:00.004001 A &gt; B: . 5000:6000(1000) ack 1 win 32768
      6  11:42:00.005001 A &gt; B: . 6000:7000(1000) ack 1 win 32768
      7  11:42:00.010001 B &gt; A: . ack 1000 win 0
      8  11:42:00.011001 B &gt; A: . ack 1000 win 0
      9  11:42:00.012001 B &gt; A: . ack 1000 win 0
     10  11:42:00.012201 A &gt; B: . 1000:2000(1000) ack 1 win 32768
     11  11:42:00.013001 B &gt; A: . ack 1000 win 0
     12  11:42:00.014001 B &gt; A: . ack 1000 win 0
     13  11:42:00.022001 B &gt; A: . ack 7000 win 16384
     14  11:42:00.023001 A &gt; B: . 7000:8000(1000) ack 1 win 32768

</pre></div>
<p>
</p>
<p>
    In this example, A sends data segments to B. At the beginning of the log,
    the cwnd of A is 6 SMSS, hence A sends 6 segments to B (line 1-6).
    Here, if the segment sent in line 1 (segment 1000:2000) is lost, B sends
    duplicated ACKs for the lost segment (line 7-9 and 11-12) to ask retransmission.
    However, these duplicated ACKs sent from B have zero advertised window because of
    buffer overflow. In this case, although the cwnd at A is inflated at the reception
    of the duplicated ACKs, it cannot transmit new segments. Hence, only the lost
    segment is retransmitted (line 10). When B receives retransmitted segment, the
    buffer becomes empty, then B sends a Full ACK with non-zero advertised window.
    The ACK received in line 13 is the first Full ACK and there is no out-standing
    data in this moment. Hence, new cwnd is set to 1 SMSS and only one new segment
    is sent (line 14)
    
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Case 3: Lost of ACK segments</h3>

<p>
    This is the tcpdump example of the case. This log is recorded at A.
    
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      1  12:43:00.000001 A &gt; B: . 1000:2000(1000) ack 1 win 32768
      2  12:43:00.001001 A &gt; B: . 2000:3000(1000) ack 1 win 32768
      3  12:43:00.002001 A &gt; B: . 3000:4000(1000) ack 1 win 32768
      4  12:43:00.003001 A &gt; B: . 4000:5000(1000) ack 1 win 32768
      5  12:43:00.004001 A &gt; B: . 5000:6000(1000) ack 1 win 32768
      6  12:43:00.005001 A &gt; B: . 6000:7000(1000) ack 1 win 32768
      7  12:43:00.010001 B &gt; A: . ack 1000 win 16384
      8  12:43:00.011001 B &gt; A: . ack 1000 win 16384
      9  12:43:00.012001 B &gt; A: . ack 1000 win 16384
     10  12:43:00.012201 A &gt; B: . 1000:2000(1000) ack 1 win 32768
     11  12:43:00.022001 B &gt; A: . ack 7000 win 16384
     12  12:43:00.023001 A &gt; B: . 7000:8000(1000) ack 1 win 32768
</pre></div>
<p>
</p>
<p>
    In this example, A sends data segments to B. At the beginning of the log,
    the cwnd of A is 6 SMSS, hence A sends 6 segments to B (line 1-6).
    Here, if the segment sent in line 1 (segment 1000:2000) is lost, B generates
    5 duplicated ACKS, however 2 ACK segments are lost in this case. Then, only
    3 duplicated ACKs arrives at A (line 7-9).
    At line 10, A transmits the lost segment and sets cwnd to ssthresh plus 3*SMSS.
    As the result, the cwnd becomes 6 SMSS. However, this cwnd does not allow A to
    transmit new segments. At line 11, A receives the first Full ACK and
    there is no out-standing data in this moment. Hence, new cwnd is set to 1 SMSS
    and only one new segment is sent (line 12)
    
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Discussion</h3>

<p>
Some TCP implementations such as Linux, NS-2 Network simulator do not have this issue.
This is because these implementations always transmit more than 1 MSS right after fast recovery.
In these implementations, when TCP exits Fast Recovery (when the first FULL ACK is received)
it also calls "open cwnd" function at the same time and performs Slow Start or Congestion 
Avoidance algorithm.
Hence, even though cwnd is set to 1 MSS after Fast Recovery as described in Section 3,
the cwnd will be increased by 1 MSS by Slow Start.  
(Since ssthresh should be bigger than 1 MSS at this moment, Slow Start is always used 
to increase cwnd) 

</p>
<p>
However, this behavior can be controversial because it enters Slow-Start after Fast Recovery
without receiving any packets. Although this point is unclear in RFC3782, we believe that 
this is rather aggressive behavior and TCP should not open cwnd after Fast Recovery 
without receiving another ACKs. In fact, several implementation do not perform Slow Start 
right after Fast Recovery. With these implementations, severe performance degradations 
can be observed over lossy networks.

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Proposed Fix</h3>

<p>
   To solve the problem mentioned above, we propose a simple fix to the fifth step
   in NewReno. 
          
<p>
The proposed solution is modifying the current cwnd adjustment:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           (1) min (ssthresh, FlightSize + SMSS)
   to
           (1) min (ssthresh, max(FlightSize, SMSS) + SMSS)
</pre></div>
<p>
</p>
   This fix ensures that cwnd is always larger than 1 SMSS. Hence, sender TCP
   can always transmit at least two segments right after the first Full ACK reception.
   This can avoid the delay of ACK transmissions caused by delayed ACK algorithm.
   The new algorithm increases 1 SMSS only when FlightSize becomes zero and behaves
   completely the same as the previous algorithm does in other situations.
   The new algorithm might add slight burstness since it requires additional
   increase of cwnd.
   However, we believe this burstness can be almost negligible.


<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Simulation Results</h3>

<p>
   In order to verify the effect of the issue described in this document, 
   we implemented our algorithm in the TCP/Newreno agent in ns-2.34 and conducted several simulations.
   We used a simple network configuration as depicted in the below figure for our
   simulations. There is one 10Mbps link between the sender and the receiver and link delay is 
   set to 2ms. The PLR on the link is set to 0.01 - 0.06 for the traffic towards the receiver. 
   The sender transmits 100000 packets to the receiver with one TCP 
   connection. (FTP application attached to TCP/Newreno agent is used) The receiver uses
   TCPSink/DelAck agent and delayed ack interval is set to 200ms.
   
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

           _________                              __________
          |         |       10Mbps, 2ms          |          |
          | sender  |----------------------------| receiver |
          |_________|      PLR=0.01-0.06         |__________|


</pre></div>
<p>
</p>

With this configuration, we measured the performance of TCP by using the following three 
algorithms. alg1 is the algorithm adopted in the original NS-2 code or linux. 
alg2 is the algorithm that seems to be adopted in some other OSs.
alg3 is the algorithm proposed in this document.  
   
   
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  alg1 ... always do slow start after fast recovery without receiving
           ACKs

  alg2 ... don't do slow start after fast recovery without receiving
           ACKs

  alg3 ... don't do slow start after fast recovery without receiving
           ACKs. but, adjust cwnd to be always bigger than 1.


</pre></div>
<p>
</p>


   At first, we measured the number of events where flightsize becomes zero after fast recovery.
   As showed in the below table, when PLR=0.01, the ratio of the event is around 0.1% 
   while it is around 2.0% when PLR=0.06. This means that the ratio of this event 
   cannot be negligible under congested situations.
   
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>


  number of events where flightsize becomes zero after fast recovery

         PLR=0.01   PLR=0.02   PLR=0.03   PLR=0.04   PLR=0.05   PLR=0.06
 alg1      108        333        687       1140       1537       1916
 alg2      113        365        724       1182       1615       1939
 alg3      107        371        717       1186       1587       1936


</pre></div>
<p>
</p>
Next, we measured the throughput of each algorithm.
As showed in the below table, alg2 exhibits serious performance degradation compared to the other two.
alg1 maintains the best performance in all cases. This is because it has a bit aggressive
natures. Although alg3 is a less aggressive algorithm than alg1, it attains mostly the same performance 
as alg1. 

   
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                           throughput (kbps)

         PLR=0.01   PLR=0.02   PLR=0.03   PLR=0.04   PLR=0.05   PLR=0.06
 alg1    1028.49     697.87     491.29     356.36     257.71     198.65
 alg2     825.57     451.96     284.25     190.13     137.99     107.05
 alg3    1006.64     671.86     470.39     344.28     248.71     193.30


</pre></div>
<p>
</p>
From these results, we recommend not to adopt alg2 and to use alg1 or alg3. We also believe that
alg3 is the best algorithm since it can attain good performance while it keeps conservative nature 
as we discuss in this draft.




<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>
  This document only propose simple modification in RFC3782. There are
   no known additional security concerns for this algorithm.
  
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>
   This document does not create any new registries or modify the rules
   for any existing registries managed by IANA.
	  
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2581">[RFC2581]</a></td>
<td class="author-text"><a href="mailto:mallman@grc.nasa.gov">Allman, M.</a>, <a href="mailto:vern@aciri.org">Paxson, V.</a>, and <a href="mailto:rstevens@kohala.com">W. Stevens</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2581">TCP Congestion Control</a>,&rdquo; RFC&nbsp;2581, April&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2581.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3782">[RFC3782]</a></td>
<td class="author-text">Floyd, S., Henderson, T., and A. Gurtov, &ldquo;<a href="http://tools.ietf.org/html/rfc3782">The NewReno Modification to TCP's Fast Recovery Algorithm</a>,&rdquo; RFC&nbsp;3782, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3782.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yoshifumi Nishida</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">WIDE Project</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Endo 5322</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fujisawa, Kanagawa  252-8520</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Japan</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nishida@wide.ad.jp">nishida@wide.ad.jp</a></td></tr>
</table>
</body></html>
