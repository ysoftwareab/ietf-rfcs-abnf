name="xxxyyy" /> and place it at the top level immediately below the
tag="arabic-indic-digits" />
tag="extended-arabic-indic-digits" />
comment="Cyrillic small letter SSHA" />
comment="reflexive mapping" />
comment="DIGIT ZERO - DIGIT NINE" />
comment="LATIN SMALL LETTER A - LATIN SMALL LETTER Z" />
comment="matches any non-preferred code point">
match="three-or-more-consonants" />
not-match="non-preferred" />
language-tag = xsd:token

scope-value = xsd:token {
minLength = "1"
code-point = xsd:token {
pattern = "[0-9A-F]{4,6}"
code-point-sequence = xsd:token {
pattern = "[0-9A-F]{4,6}( [0-9A-F]{4,6})+"
code-point-literal = code-point | code-point-sequence

code-point-set-shorthand = xsd:token {
pattern = "([0-9A-F]{4,6}|[0-9A-F]{4,6}-[0-9A-F]{4,6})"
                 ~ "( ([0-9A-F]{4,6}|[0-9A-F]{4,6}-[0-9A-F]{4,6}))*"
date = xsd:token {
pattern = "\d{4}-\d\d-\d\d"
rule-ref = xsd:IDREF
tags = xsd:NMTOKENS

tag-ref = xsd:NMTOKEN

identifier = xsd:ID

class-ref = xsd:IDREF

count-pattern = xsd:token {
pattern = "\d+(\+|:\d+)?"
char = element char {
       attribute cp { code-point-literal },
       attribute comment { text }?,
       attribute when { rule-ref }?,
       attribute not-when { rule-ref }?,
       attribute tag { tags }?,
       attribute ref { text }?,
       variant*
range = element range {
       attribute first-cp { code-point },
       attribute last-cp { code-point },
       attribute comment { text }?,
       attribute tag { tags }?,
       attribute ref { text }?
char-simple = element char {
       attribute cp { code-point }
range-simple = element range {
       attribute first-cp { code-point },
       attribute last-cp { code-point }
variant = element var {
       attribute cp { code-point-literal },
       attribute type { text }?,
       attribute when { rule-ref }?,
       attribute not-when { rule-ref }?,
       attribute comment { text }?,
       attribute type { text }?,
       attribute ref { text }?
class-invocation = element class {
       (attribute by-ref { class-ref }
           | attribute from-tag { tag-ref }),
       attribute count { count-pattern }?,
       attribute comment { text }?
class-declaration = element class {
       # "name" attribute MUST be present if this is a "top-level" class
       # declaration, i.e. appearing directly under the "rules" element.
       # Otherwise, it MUST be absent.
       attribute name { identifier }?,
       # If used as a matcher (appearing in a "rule" element), the
       # "count" attribute may be present. Otherwise, it MUST be absent.
       attribute count { count-pattern }?,
       attribute comment { text }?,
       attribute ref { text }?,
       (
         # define the class by property (e.g. property="sc:Latn"), OR
         attribute property { text }
         # define the class by tagged code points, OR
         | attribute from-tag { tag-ref }
         # list of single code points and ranges, OR
         | (char-simple | range-simple)+
         # text node to allow for shorthand notation e.g.
         # "0061 0062-0063"
         | code-point-set-shorthand
       )
     }

class-or-set-operator-nested =
     class-invocation | class-declaration | set-operator

class-or-set-operator-declaration =
     # a "class" element or set operator (effectively defining a class)
     # directly in the "rules" element.
     class-declaration | set-operator


complement-operator = element complement {
       attribute name { identifier }?,
       attribute comment { text }?,
       attribute ref { text }?,
       # "count" attribute MUST only be used when this set-operator is
       # used as a matcher (i.e. nested in a <rule> element)
       attribute count { count-pattern }?,
       class-or-set-operator-nested
union-operator = element union {
       attribute name { identifier }?,
       attribute comment { text }?,
       attribute ref { text }?,
       # "count" attribute MUST only be used when this set-operator is
       # used as a matcher (i.e. nested in a <rule> element)
       attribute count { count-pattern }?,
       class-or-set-operator-nested,
       # needs two or more child elements
       class-or-set-operator-nested+
intersection-operator = element intersection {
       attribute name { identifier }?,
       attribute comment { text }?,
       attribute ref { text }?,
       # "count" attribute MUST only be used when this set-operator is
       # used as a matcher (i.e. nested in a <rule> element)
       attribute count { count-pattern }?,
       class-or-set-operator-nested,
       class-or-set-operator-nested
difference-operator = element difference {
       attribute name { identifier }?,
       attribute comment { text }?,
       attribute ref { text }?,
       # "count" attribute MUST only be used when this set-operator is
       # used as a matcher (i.e. nested in a <rule> element)
       attribute count { count-pattern }?,
       class-or-set-operator-nested,
       class-or-set-operator-nested
symmetric-difference-operator = element symmetric-difference {
       attribute name { identifier }?,
       attribute comment { text }?,
       attribute ref { text }?,
       # "count" attribute MUST only be used when this set-operator is
       # used as a matcher (i.e. nested in a <rule> element)
       attribute count { count-pattern }?,
       class-or-set-operator-nested,
       class-or-set-operator-nested
set-operator = complement-operator
                  | union-operator
                  | intersection-operator
                  | difference-operator
                  | symmetric-difference-operator

any-matcher = element any {
       attribute count { count-pattern }?,
       attribute comment { text }?
choice-matcher = element choice {
       attribute count { count-pattern }?,
       attribute comment { text }?,
       # two or more match operators
       match-operator-choice,
       match-operator-choice+
char-matcher =
     # for use as a matcher - like "char" but without a "tag" attribute
     element char {
       attribute cp { code-point-literal },
       # If used as a matcher (appearing in a "rule" element), the
       # "count" attribute may be present. Otherwise, it MUST be
       # absent.
       attribute count { count-pattern }?,
       attribute comment { text }?,
       attribute ref { text }?
start-matcher = element start {
       attribute comment { text }?
end-matcher = element end {
       attribute comment { text }?
anchor-matcher = element anchor {
       attribute comment { text }?
look-ahead-matcher = element look-ahead {
       attribute comment { text }?,
       match-operators-non-pos
look-behind-matcher = element look-behind {
       attribute comment { text }?,
       match-operators-non-pos
match-operator-choice = (
     any-matcher | choice-matcher | start-matcher | end-matcher
     | char-matcher | class-or-set-operator-nested | rule-matcher
match-operators-non-pos = (
     start-matcher?,
     (any-matcher | choice-matcher | char-matcher
      | class-or-set-operator-nested | rule-matcher)*,
     end-matcher?
match-operators-pos =
     look-behind-matcher?, anchor-matcher, look-ahead-matcher?

match-operators = match-operators-non-pos | match-operators-pos


rule-declaration-top = element rule {
       attribute name { identifier },
       attribute comment { text }?,
       attribute ref { text }?,
       match-operators
rule-matcher =
     element rule {
       attribute count { count-pattern }?,
       attribute comment { text }?,
       attribute ref { text }?,
       (attribute by-ref { rule-ref } | match-operators)
     }


action-declaration = element action {
       attribute comment { text }?,
       attribute ref { text }?,
       attribute disp { text },
       ( attribute match { text } | attribute not-match { text } )?,
       ( attribute any-variant { text }
         | attribute all-variants { text }
         | attribute only-variants { text } )?
start = lgr
lgr = element lgr {
       attribute id { text }?,
       meta-section?,
       data-section,
       rules-section?
meta-section = element meta {
       element version {
           attribute comment { text }?,
           text
       }?
       & element date {
           xsd:token {
pattern = "\d{4}-\d{2}-\d{2}"
pattern = "\d+\.\d+\.\d+"
data-section = element data { (char | range)+ }

rules-section = element rules {
     ( class-or-set-operator-declaration
       | rule-declaration-top
       | action-declaration)*
