header_length = length - payload_length - aead_tag_length

header_length = length - payload_length

ConnectivityServerListening = {
       ? ip_v4: IPAddress
       ? ip_v6: IPAddress
       ? port_v4: uint16
       ? port_v6: uint16

       ; the server will always answer client initials with a retry
       ; (no 1-RTT connection setups by choice)
       ? retry_required: bool
ConnectivityConnectionStarted = {
       ? ip_version: IPVersion
       src_ip: IPAddress
       dst_ip: IPAddress

       ; transport layer protocol
       ? protocol: text .default "QUIC"
       ? src_port: uint16
       ? dst_port: uint16

       ? src_cid: ConnectionID
       ? dst_cid: ConnectionID
ConnectivityConnectionClosed = {
       ; which side closed the connection
       ? owner: Owner

       ? connection_code: TransportError / CryptoError / uint32
       ? application_code: $ApplicationError / uint32
       ? internal_code: uint32

       ? reason: text
       ? trigger:
           "clean" /
           "handshake_timeout" /
           "idle_timeout" /
           ; this is called the "immediate close" in the QUIC RFC
           "error" /
           "stateless_reset" /
           "version_mismatch" /
           ; for example HTTP/3's GOAWAY frame
           "application"
ConnectivityConnectionIDUpdated = {
       owner: Owner

       ? old: ConnectionID
       ? new: ConnectionID
ConnectivitySpinBitUpdated = {
       state: bool
ConnectivityConnectionStateUpdated = {
       ? old: ConnectionState / SimpleConnectionState
       new: ConnectionState / SimpleConnectionState
ConnectionState =
       ; initial sent/received
       "attempted" /
       ; peer address validated by: client sent Handshake packet OR
       ; client used CONNID chosen by the server.
       ; transport-draft-32, section-8.1
       "peer_validated" /
       "handshake_started" /
       ; 1 RTT can be sent, but handshake isn't done yet
       "early_write" /
       ; TLS handshake complete: Finished received and sent
       ; tls-draft-32, section-4.1.1
       "handshake_complete" /
       ; HANDSHAKE_DONE sent/received (connection is now "active", 1RTT
       ; can be sent). tls-draft-32, section-4.1.2
       "handshake_confirmed" /
       "closing" /
       ; connection_close sent/received
       "draining" /
       ; draining period done, connection state discarded
       "closed"

SimpleConnectionState =
       "attempted" /
       "handshake_started" /
       "handshake_confirmed" /
       "closed"

          Figure 6: ConnectivityConnectionStateUpdated definition

SecurityKeyUpdated = {
       key_type: KeyType

       ? old: hexstring
       new: hexstring

       ; needed for 1RTT key updates
       ? generation: uint32

       ? trigger:
           ; (e.g., initial, handshake and 0-RTT keys
           ; are generated by TLS)
           "tls" /
           "remote_update" /
           "local_update"
SecurityKeyRetired = {
       key_type: KeyType
       ? key: hexstring

       ; needed for 1RTT key updates
       ? generation: uint32

       ? trigger:
           ; (e.g., initial, handshake and 0-RTT keys
           ; are generated by TLS)
           "tls" /
           "remote_update" /
           "local_update"
TransportVersionInformation = {
       ? server_versions: [+ QuicVersion]
       ? client_versions: [+ QuicVersion]
       ? chosen_version: QuicVersion
TransportALPNInformation = {
       ? server_alpns: [* text]
       ? client_alpns: [* text]
       ? chosen_alpn: text
TransportParametersSet = {
       ? owner: Owner

       ; true if valid session ticket was received
       ? resumption_allowed: bool
       ; true if early data extension was enabled on the TLS layer
       ? early_data_enabled: bool

       ; e.g., "AES_128_GCM_SHA256"
       ? tls_cipher: text

       ; depends on the TLS cipher, but it's easier to be explicit.
       ; in bytes
       ? aead_tag_length: uint8 .default 16

       ; transport parameters from the TLS layer:
       ? original_destination_connection_id: ConnectionID
       ? initial_source_connection_id: ConnectionID
       ? retry_source_connection_id: ConnectionID
       ? stateless_reset_token: Token
       ? disable_active_migration: bool

       ? max_idle_timeout: uint64
       ? max_udp_payload_size: uint32
       ? ack_delay_exponent: uint16
       ? max_ack_delay: uint16
       ? active_connection_id_limit: uint32

       ? initial_max_data: uint64
       ? initial_max_stream_data_bidi_local: uint64
       ? initial_max_stream_data_bidi_remote: uint64
       ? initial_max_stream_data_uni: uint64
       ? initial_max_streams_bidi: uint64
       ? initial_max_streams_uni: uint64

       ? preferred_address: PreferredAddress
PreferredAddress = {
       ip_v4: IPAddress
       ip_v6: IPAddress

       port_v4: uint16
       port_v6: uint16

       connection_id: ConnectionID
       stateless_reset_token: Token
TransportParametersRestored = {
       ? disable_active_migration: bool

       ? max_idle_timeout: uint64
       ? max_udp_payload_size: uint32
       ? active_connection_id_limit: uint32

       ? initial_max_data: uint64
       ? initial_max_stream_data_bidi_local: uint64
       ? initial_max_stream_data_bidi_remote: uint64,
       ? initial_max_stream_data_uni: uint64
       ? initial_max_streams_bidi: uint64
       ? initial_max_streams_uni: uint64
TransportPacketSent = {
       header: PacketHeader

       ; see appendix for the QuicFrame definitions
       ? frames: [* QuicFrame]

       ? is_coalesced: bool .default false

       ; only if header.packet_type === "retry"
       ? retry_token: Token

       ; only if header.packet_type === "stateless_reset"
       ; is always 128 bits in length.
       ? stateless_reset_token: hexstring .size 16

       ; only if header.packet_type === "version_negotiation"
       ? supported_versions: [+ QuicVersion]

       ? raw: RawInfo
       ? datagram_id: uint32

       ? trigger:
         ; draft-23 5.1.1
         "retransmit_reordered" /
         ; draft-23 5.1.2
         "retransmit_timeout" /
         ; draft-23 5.3.1
         "pto_probe" /
         ; draft-19 6.2
         "retransmit_crypto" /
         ; needed for some CCs to figure out bandwidth allocations
         ; when there are no normal sends
         "cc_bandwidth_probe"
TransportPacketReceived = {
       header: PacketHeader

       ; see appendix for the definitions
       ? frames: [* QuicFrame]

       ? is_coalesced: bool .default false

       ; only if header.packet_type === "retry"
       ? retry_token: Token

       ; only if header.packet_type === "stateless_reset"
       ; Is always 128 bits in length.
       ? stateless_reset_token: hexstring .size 16

       ; only if header.packet_type === "version_negotiation"
       ? supported_versions: [+ QuicVersion]

       ? raw: RawInfo
       ? datagram_id: uint32

       ? trigger:
           ; if packet was buffered because
           ; it couldn't be decrypted before
           "keys_available"
TransportPacketDropped = {
       ; primarily packet_type should be filled here,
       ; as other fields might not be parseable
       ? header: PacketHeader

       ? raw: RawInfo
       ? datagram_id: uint32

       ? trigger:
           "key_unavailable" /
           "unknown_connection_id" /
           "header_parse_error" /
           "payload_decrypt_error" /
           "protocol_violation" /
           "dos_prevention" /
           "unsupported_version" /
           "unexpected_packet" /
           "unexpected_source_connection_id" /
           "unexpected_version" /
           "duplicate" /
           "invalid_initial"
TransportPacketBuffered = {
       ; primarily packet_type and possible packet_number should be
       ; filled here as other elements might not be available yet
       ? header: PacketHeader

       ? raw: RawInfo
       ? datagram_id: uint32

       ? trigger:
           ; indicates the parser cannot keep up, temporarily buffers
           ; packet for later processing
           "backpressure" /
           ; if packet cannot be decrypted because the proper keys were
           ; not yet available
           "keys_unavailable"
TransportPacketsAcked = {
       ? packet_number_space: PacketNumberSpace

       ? packet_numbers: [+ uint64]
TransportDatagramsSent = {
       ; to support passing multiple at once
       ? count: uint16

       ; RawInfo:length field indicates total length of the datagrams
       ; including UDP header length
       ? raw: [+ RawInfo]

       ? datagram_ids: [+ uint32]
TransportDatagramsReceived = {
       ; to support passing multiple at once
       ? count: uint16

       ; RawInfo:length field indicates total length of the datagrams
       ; including UDP header length
       ? raw: [+ RawInfo]

       ? datagram_ids: [+ uint32]
TransportDatagramDropped = {
       ? raw: RawInfo
StreamType = "unidirectional" / "bidirectional"

TransportStreamStateUpdated = {
       stream_id: uint64

       ; mainly useful when opening the stream
       ? stream_type: StreamType

       ? old: StreamState
       new: StreamState

       ? stream_side: "sending" / "receiving"
StreamState =
       ; bidirectional stream states, draft-23 3.4.
       "idle" /
       "open" /
       "half_closed_local" /
       "half_closed_remote" /
       "closed" /

       ; sending-side stream states, draft-23 3.1.
       "ready" /
       "send" /
       "data_sent" /
       "reset_sent" /
       "reset_received" /

       ; receive-side stream states, draft-23 3.2.
       "receive" /
       "size_known" /
       "data_read" /
       "reset_read" /

       ; both-side states
       "data_received" /

       ; qlog-defined:
       ; memory actually freed
       "destroyed"

             Figure 21: TransportStreamStateUpdated definition
TransportFramesProcessed = {
       ; see appendix for the QuicFrame definitions
       frames: [* QuicFrame]

       ? packet_number: uint64
TransportDataMoved = {
       ? stream_id: uint64
       ? offset: uint64

       ; byte length of the moved data
       ? length: uint64

       ? from: "user" / "application" / "transport" / "network" / text
       ? to: "user" / "application" / "transport" / "network" / text

       ; raw bytes that were transferred
       ? data: hexstring
RecoveryParametersSet = {
       ; Loss detection, see recovery draft-23, Appendix A.2
       ; in amount of packets
       ? reordering_threshold: uint16

       ; as RTT multiplier
       ? time_threshold: float32

       ; in ms
       timer_granularity: uint16

       ; in ms
       ? initial_rtt:float32

       ; congestion control, Appendix B.1.
       ; in bytes. Note: this could be updated after pmtud
       ? max_datagram_size: uint32

       ; in bytes
       ? initial_congestion_window: uint64

       ; Note: this could change when max_datagram_size changes
       ; in bytes
       ? minimum_congestion_window: uint32
       ? loss_reduction_factor: float32

       ; as PTO multiplier
       ? persistent_congestion_threshold: uint16
RecoveryMetricsUpdated = {
       ; Loss detection, see recovery draft-23, Appendix A.3
       ; all following rtt fields are expressed in ms
       ? min_rtt: float32
       ? smoothed_rtt: float32
       ? latest_rtt: float32
       ? rtt_variance: float32

       ? pto_count: uint16

       ; Congestion control, Appendix B.2.
       ; in bytes
       ? congestion_window: uint64
       ? bytes_in_flight: uint64

       ; in bytes
       ? ssthresh: uint64

       ; qlog defined
       ; sum of all packet number spaces
       ? packets_in_flight: uint64

       ; in bits per second
       ? pacing_rate: uint64
RecoveryCongestionStateUpdated = {
       ? old: text
       new: text

       ? trigger:
           "persistent_congestion" /
           "ECN"
RecoveryLossTimerUpdated = {
       ; called "mode" in draft-23 A.9.
       ? timer_type: "ack" / "pto"
       ? packet_number_space: PacketNumberSpace

       event_type: "set" / "expired" / "cancelled"

       ; if event_type === "set": delta time is in ms from
       ; this event's timestamp until when the timer will trigger
       ? delta: float32
RecoveryPacketLost = {
       ; should include at least the packet_type and packet_number
       ? header: PacketHeader

       ; not all implementations will keep track of full
       ; packets, so these are optional
       ; see appendix for the QuicFrame definitions
       ? frames: [* QuicFrame]

       ? trigger:
           "reordering_threshold" /
           "time_threshold" /
           ; draft-23 section 5.3.1, MAY
           "pto_expired"
RecoveryMarkedForRetransmit = {
       ; see appendix for the QuicFrame definitions
       frames: [+ QuicFrame]
QuicEvents = ConnectivityServerListening /
                ConnectivityConnectionStarted /
                ConnectivityConnectionClosed /
                ConnectivityConnectionIDUpdated /
                ConnectivitySpinBitUpdated /
                ConnectivityConnectionStateUpdated /
                SecurityKeyUpdated / SecurityKeyRetired /
                TransportVersionInformation / TransportALPNInformation /
                TransportParametersSet / TransportParametersRestored /
                TransportPacketSent / TransportPacketReceived /
                TransportPacketDropped / TransportPacketBuffered /
                TransportPacketsAcked / TransportDatagramsSent /
                TransportDatagramsReceived / TransportDatagramDropped /
                TransportStreamStateUpdated / TransportFramesProcessed /
                TransportDataMoved /
                RecoveryParametersSet / RecoveryMetricsUpdated /
                RecoveryCongestionStateUpdated /
                RecoveryLossTimerUpdated /
                RecoveryPacketLost

QuicVersion = hexstring

                     Figure 30: QuicVersion definition

ConnectionID = hexstring

                     Figure 31: ConnectionID definition

Owner = "local" / "remote"

                        Figure 32: Owner definition

IPAddress = text / hexstring
                      Figure 33: IPAddress definition

IPVersion = "v4" / "v6"

                      Figure 34: IPVersion definition

PacketType = "initial" / "handshake" / "0RTT" / "1RTT" / "retry" /
       "version_negotiation" / "stateless_reset" / "unknown"

                      Figure 35: PacketType definition

PacketNumberSpace = "initial" / "handshake" / "application_data"

                  Figure 36: PacketNumberSpace definition

PacketHeader = {
       packet_type: PacketType
       packet_number: uint64

       ; the bit flags of the packet headers (spin bit, key update bit,
       ; etc. up to and including the packet number length bits
       ; if present
       ? flags: uint8

       ; only if packet_type === "initial"
       ? token: Token

       ; only if packet_type === "initial" || "handshake" || "0RTT"
       ; Signifies length of the packet_number plus the payload
       ? length: uint16

       ; only if present in the header
       ; if correctly using transport:connection_id_updated events,
       ; dcid can be skipped for 1RTT packets
       ? version: QuicVersion
       ? scil: uint8
       ? dcil: uint8
       ? scid: ConnectionID
       ? dcid: ConnectionID
Token = {
       ? type: "retry" / "resumption" / "stateless_reset"

       ; byte length of the token
       ? length: uint32

       ; raw byte value of the token
       ? data: hexstring

       ; decoded fields included in the token
       ; (typically: peer's IP address, creation time)
       ? details: {
         * text => any
       }
KeyType =
       "server_initial_secret" / "client_initial_secret" /
       "server_handshake_secret" / "client_handshake_secret" /
       "server_0rtt_secret" / "client_0rtt_secret" /
       "server_1rtt_secret" / "client_1rtt_secret"

                       Figure 39: KeyType definition

QuicFrame =
     PaddingFrame / PingFrame / AckFrame / ResetStreamFrame /
     StopSendingFrame / CryptoFrame / NewTokenFrame / StreamFrame /
     MaxDataFrame / MaxStreamDataFrame / MaxStreamsFrame /
     DataBlockedFrame / StreamDataBlockedFrame / StreamsBlockedFrame /
     NewConnectionIDFrame / RetireConnectionIDFrame /
     PathChallengeFrame / PathResponseFrame / ConnectionCloseFrame /
     HandshakeDoneFrame / UnknownFrame

                      Figure 40: QuicFrame definition

PaddingFrame = {
       frame_type: "padding"

       ; total frame length, including frame header
       ? length: uint32
       payload_length: uint32
PingFrame = {
       frame_type: "ping"

       ; total frame length, including frame header
       ? length: uint32
       ? payload_length: uint32
AckRange = [1*2 uint64]

AckFrame = {
       frame_type: "ack"

       ; in ms
       ? ack_delay: float32

       ; e.g., looks like [[1,2],[4,5], [7], [10,22]] serialized
       ? acked_ranges: [+ AckRange]

       ; ECN (explicit congestion notification) related fields
       ; (not always present)
       ? ect1: uint64
       ? ect0:uint64
       ? ce: uint64

       ; total frame length, including frame header
       ? length: uint32
       ? payload_length: uint32
ResetStreamFrame = {
       frame_type: "reset_stream"

       stream_id: uint64
       error_code: $ApplicationError / uint32

       ; in bytes
       final_size: uint64

       ; total frame length, including frame header
       ? length: uint32
       ? payload_length: uint32
StopSendingFrame = {
       frame_type: "stop_sending"

       stream_id: uint64
       error_code: $ApplicationError / uint32

       ; total frame length, including frame header
       ? length: uint32
       ? payload_length: uint32
CryptoFrame = {
       frame_type: "crypto"

       offset: uint64
       length: uint64

       ? payload_length: uint32
NewTokenFrame = {
     frame_type: "new_token"

     token: Token
StreamFrame = {
       frame_type: "stream"

       stream_id: uint64

       ; These two MUST always be set
       ; If not present in the Frame type, log their default values
       offset: uint64
       length: uint64

       ; this MAY be set any time,
       ; but MUST only be set if the value is true
       ; if absent, the value MUST be assumed to be false
       ? fin: bool .default false

       ? raw: hexstring
MaxDataFrame = {
     frame_type: "max_data"

     maximum: uint64
MaxStreamDataFrame = {
     frame_type: "max_stream_data"

     stream_id: uint64
     maximum: uint64
MaxStreamsFrame = {
     frame_type: "max_streams"

     stream_type: StreamType
     maximum: uint64
DataBlockedFrame = {
     frame_type: "data_blocked"

     limit: uint64
StreamDataBlockedFrame = {
     frame_type: "stream_data_blocked"

     stream_id: uint64
     limit: uint64
StreamsBlockedFrame = {
     frame_type: "streams_blocked"

     stream_type: StreamType
     limit: uint64
NewConnectionIDFrame = {
     frame_type: "new_connection_id"

     sequence_number: uint32
     retire_prior_to: uint32

     ; mainly used if e.g., for privacy reasons the full
     ; connection_id cannot be logged
     ? connection_id_length: uint8
     connection_id: ConnectionID

     ? stateless_reset_token: Token
RetireConnectionIDFrame = {
     frame_type: "retire_connection_id"

     sequence_number: uint32
PathChallengeFrame = {
     frame_type: "path_challenge"

     ; always 64-bit
     ? data: hexstring
PathResponseFrame = {
     frame_type: "path_response"

     ; always 64-bit
     ? data: hexstring
ErrorSpace = "transport" / "application"

ConnectionCloseFrame = {
       frame_type: "connection_close"

       ? error_space: ErrorSpace
       ? error_code: TransportError / $ApplicationError / uint32
       ? raw_error_code: uint32
       ? reason: text

       ; For known frame types, the appropriate "frame_type" string
       ; For unknown frame types, the hex encoded identifier value
       ? trigger_frame_type: uint64 / text
HandshakeDoneFrame = {
     frame_type: "handshake_done";
UnknownFrame = {
       frame_type: "unknown"
       raw_frame_type: uint64

       ? raw_length: uint32
       ? raw: hexstring
TransportError = "no_error" / "internal_error" /
       "connection_refused" / "flow_control_error" /
       "stream_limit_error" / "stream_state_error" /
       "final_size_error" / "frame_encoding_error" /
       "transport_parameter_error" / "connection_id_limit_error" /
       "protocol_violation" / "invalid_token" / "application_error" /
       "crypto_buffer_exceeded"

                    Figure 62: TransportError definition

CryptoError = text .regexp "crypto_error_0x1[0-9][0-9]"

                     Figure 63: CryptoError definition

