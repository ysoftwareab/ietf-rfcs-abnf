<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A Process for Obscuring Location</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A Process for Obscuring Location">
<meta name="keywords" content="geopriv, geolocation, privacy, obscure, location, fuzz">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">GEOPRIV</td><td class="header">M. Thomson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Andrew Corporation</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">November 11, 2010</td></tr>
<tr><td class="header">Expires: May 15, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />A Process for Obscuring Location<br />draft-thomson-geopriv-location-obscuring-01</h1>

<h3>Abstract</h3>

<p>A method for obscuring location information is described.  Both static and changing location information can be obscured.  A single distance measure is input to the process; this parameter controls the precision of location information that can be extracted by a recipient.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on May 15, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#characteristics">2.</a>&nbsp;
Method Characteristics and Applicability<br />
<a href="#static">3.</a>&nbsp;
Obscuring Static Locations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#point">3.1.</a>&nbsp;
Known Point Locations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">3.2.</a>&nbsp;
Known Locations with Uncertainty<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rvector">3.3.</a>&nbsp;
Selecting a Offset Vector<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multiplestatic">3.4.</a>&nbsp;
Multiple Reported Locations<br />
<a href="#dynamic">4.</a>&nbsp;
Obscuring Changing Locations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trigger">4.1.</a>&nbsp;
Update Conditions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bad-trigger">4.1.1.</a>&nbsp;
Bad Triggers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#hidden-trigger">4.1.2.</a>&nbsp;
Hidden Trigger<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#consecutive">4.2.</a>&nbsp;
Consecutive Reported Locations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#smoothing">4.2.1.</a>&nbsp;
Reducing Variation between Offset Vectors<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#smoothingamt">4.2.2.</a>&nbsp;
Trade-off in Reducing Variation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">4.3.</a>&nbsp;
Returning to the Same Location<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#posstability">4.3.1.</a>&nbsp;
Positional Stability<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">4.3.2.</a>&nbsp;
Triggering with Positional Stability<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#grid">4.3.3.</a>&nbsp;
Selecting a Grid<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#noise2d">4.3.4.</a>&nbsp;
Random Grid<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#interpolation">4.3.5.</a>&nbsp;
Linear Interpolation of Random Offsets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#uderp">4.3.5.1.</a>&nbsp;
Uniformly Distributed Interpolation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.3.5.2.</a>&nbsp;
Applying Uniformly Distributed Interpolation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.3.5.3.</a>&nbsp;
Selecting an Appropriate Grid Size<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#wonky">4.3.6.</a>&nbsp;
The Wonky Grid<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.3.6.1.</a>&nbsp;
Wonky Grid Points at the Poles<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.3.6.2.</a>&nbsp;
Interpolation About the 180th Meridian<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.3.7.</a>&nbsp;
Temporal Interpolation<br />
<a href="#examples">5.</a>&nbsp;
Examples<br />
<a href="#ack">6.</a>&nbsp;
Acknowledgements<br />
<a href="#iana">7.</a>&nbsp;
IANA Considerations<br />
<a href="#security">8.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
Informative References<br />
<a href="#anchor10">Appendix&nbsp;A.</a>&nbsp;
Sample Implementation<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>A method for obscuring location information is described.  This method obscures location information such that it can be provided to recipients without revealing the location of the subject to within the desired distance.
      
</p>
<p>Obscuring location has applications for protecting privacy, as described in <a class='info' href='#I-D.ietf-geopriv-policy'>[I&#8209;D.ietf&#8209;geopriv&#8209;policy]<span> (</span><span class='info'>Schulzrinne, H., Tschofenig, H., Morris, J., Cuellar, J., and J. Polk, &ldquo;Geolocation Policy: A Document Format for Expressing Privacy Preferences for Location Information,&rdquo; October&nbsp;2010.</span><span>)</span></a>.
      
</p>
<p>This method uses a single configuration parameter as input: an <em>obscuring distance</em>.
      
</p>
<p>A location recipient (or recipient) is the entity that is given location about a target entity.  The goal is to ensure that the recipient is unable to recover location information with better accuracy than is desired.  Despite this obscuring the recipient should still be able to use the reported locations.
      
</p>
<p>The obscuring process takes a series of <em>known locations</em>, which might have greater accuracy than the recipient is permitted to receive.  The obscuring process produces a series of <em>reported locations</em>.
      
</p>
<a name="characteristics"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Method Characteristics and Applicability</h3>

<p>The method described here is intended to provide limited protection for location information by constrained degradation.  The method has the following characteristics:

      </p>
<blockquote class="text"><dl>
<dt>Simple Configuration:</dt>
<dd>It might be possible to define a more complete solution for obscuring location information that is more configurable.  However, a more configurable option would also demand greater involvement from users so that they would be able to specify a configuration that meets their goals.  This method is designed to be easy to understand, which increases the chances that a user is able to successfully choose an appropriate configuration.  The method has just one input parameter: the obscuring distance.  A separate parameter for grid size is set by recommendation.
        
</dd>
<dt>Irreversible:</dt>
<dd>Obscuring is intended to be irreversible.  Information is lost by applying the process.  Multiple applications of this process to the same input location is could reduce information more than a single application of the process with the largest obscuring distance.
        
</dd>
<dt>Increases Uncertainty:</dt>
<dd>A recipient does not need to treat obscured location information any differently to location information that contains uncertainty.  The uncertainty of the reported location is increased so that the reported location includes the known location.  Thus, the information that is reported is correct, though the accuracy might be reduced.  This document relies on a definition of uncertainty for location described in more detail in <a class='info' href='#I-D.thomson-geopriv-uncertainty'>[I&#8209;D.thomson&#8209;geopriv&#8209;uncertainty]<span> (</span><span class='info'>Thomson, M. and J. Winterbottom, &ldquo;Representation of Uncertainty and Confidence in PIDF-LO,&rdquo; May&nbsp;2010.</span><span>)</span></a>.
        
</dd>
<dt>Two Dimensions:</dt>
<dd>The method described in this document operates in two dimensions only.  Many of the principles might be applicable in a higher number of dimensions, though no effort has been made to validate their integrity.  A three-dimensional location can be reduced to a two-dimensional form for use in this algorithm.  This is not contrary to the goal of reducing the amount of information provided.
        
</dd>
<dt>Time Invariant:</dt>
<dd>The method described in this document does not use time.  An entity performing obscuring does not need to consider time in applying this method.  Only the location is protected, not the time that the location was determined.  The time from the known location is included in the reported location.
        
</dd>
<dt>Obscuring Distance Not Secret:</dt>
<dd>No attempt is made to protect the obscuring distance as a secret.  It is assumed that a recipient is able to learn this value.
        
</dd>
<dt>Minimal State:</dt>
<dd>An entity that performs obscuring of locations often performs this service for the combination of many targets and recipients.  This process requires only that the obscuring entity hold maintain a trigger location for each recipient.  The additional state that an obscuring entity retains in order to apply this obscuring method is a small increment over what is typically required.  The current known location does not need to be retained; it need only be reacted to when it changes.  [TBD: determine an algorithm that removes the need for retaining the trigger location; this might be possible.]
        
</dd>
</dl></blockquote><p>
      
</p>
<a name="static"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Obscuring Static Locations</h3>

<p>A static location doesn't change.  That is, different locations are not attributed to a single target at different times.
      
</p>
<p>The basic location obscuring case involves a single, isolated instance of location information.
      
</p>
<p>It might be appropriate to apply just this section in protecting the privacy of a single location.   A recipient must be unable to acquire multiple location instances for the same entity if this is the only form of obscuring used.
      
</p>
<a name="point"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Known Point Locations</h3>

<p>A known point location can be obscured by adding a randomized offset vector to the location.  The size of the offset vector is randomly selected so that the reported location could be anywhere within the obscuring distance of the known location, see <a class='info' href='#rvector'>Section&nbsp;3.3<span> (</span><span class='info'>Selecting a Offset Vector</span><span>)</span></a>.
        
</p>
<p>The uncertainty of the reported location is set to the obscuring distance.  This ensures that the reported uncertainty region encloses the known location.
        </p>
<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>It's not sufficient to increase the uncertainty region so that it minimally includes the known location.  Doing this reveals that the known location is at the boundary of the reported uncertainty region.
        
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Known Locations with Uncertainty</h3>

<p>A known location with uncertainty is reduced to a circular uncertainty region (see <a class='info' href='#I-D.thomson-geopriv-uncertainty'>[I&#8209;D.thomson&#8209;geopriv&#8209;uncertainty]<span> (</span><span class='info'>Thomson, M. and J. Winterbottom, &ldquo;Representation of Uncertainty and Confidence in PIDF-LO,&rdquo; May&nbsp;2010.</span><span>)</span></a>, Section 4.2).  An irregularly shaped uncertainty region is difficult to evaluate against the scalar obscuring distance, and it might inadvertently reveal more information than intended.
        
</p>
<p>A known location with uncertainty greater than the obscuring radius does not require additional obscuring.  The radius of the circular uncertainty region is compared to the obscuring distance to determine if further obscuring is necessary.  A location with sufficient uncertainty can be directly reported.
        
</p>
<p>Randomization is needed if the known location contains insufficient uncertainty.  As for a point location, an offset vector is added and the uncertainty increased to the obscuring distance.  A smaller offset vector is necessary where the known location has uncertainty - this vector need only be of a size up to the obscuring distance, less the existing uncertainty.
        
</p>
<p>The reported uncertainty is increased so that the reported location contains an uncertainty radius of at least the obscuring distance.  An uncertainty in a known location cannot be recovered by a recipient of an obscured location unless it is larger than the obscuring distance.
        
</p>
<p></p>
<blockquote class="text">
<p>Paradoxically, more accurate location determination methods are better suited to obscuring.
          
</p>
<p>A location that is reported with uncertainty does not always have a uniform probability distribution.  A non-uniform distribution is not conducive to obscuring, since a location with an unevently distributed probability distribution reveals that the location of the target is more likely to be in specific parts of the uncertainty region.
          
</p>
<p>Information on the likely probability distribution cannot be conveyed in many systems, including presence (see <a class='info' href='#RFC4119'>[RFC4119]<span> (</span><span class='info'>Peterson, J., &ldquo;A Presence-based GEOPRIV Location Object Format,&rdquo; December&nbsp;2005.</span><span>)</span></a>, <a class='info' href='#RFC5491'>[RFC5491]<span> (</span><span class='info'>Winterbottom, J., Thomson, M., and H. Tschofenig, &ldquo;GEOPRIV Presence Information Data Format Location Object (PIDF-LO) Usage Clarification, Considerations, and Recommendations,&rdquo; March&nbsp;2009.</span><span>)</span></a>).  The location determination method can be reported, which can reveal characteristics of the probability distribution.  Specific measures to counteract this effect are therefore not feasible.
          
</p>
<p>Removing or replacing the location determination method parameter denies a recipient any information about probability distribution.
          
</p>
</blockquote>

<a name="rvector"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Selecting a Offset Vector</h3>

<p>To select a random offset vector of up to a given size, select two uniformly distributed random numbers.  The first is used to select a random angle, the second to select a random distance.
        
</p>
<p>Assuming a <tt>random()</tt> function produces a number distributed between 0 (inclusive) and 1 (exclusive) - that is, the range [0, 1) - the angle and distance can be produced by the following:
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      angle =  random() * 2 * pi
      distance =  sqrt(random()) * size
   or
      distance =  (1 - |random() - random()|) * size
</pre></div>
<p>...where <tt>sqrt(x)</tt> takes the square root of <tt>x</tt> and <tt>|</tt> takes the absolute value of the enclosed.   <tt>size</tt> is the desired size of the random vector, which could be the obscuring distance less any existing uncertainty.
        
</p>
<p>A recipient that is able to learn the state of the random number generator could use this to determine the known location from a reported location.  A <a class='info' href='#RFC4086'>secure random number generator<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> [RFC4086] provides an assurance that recovering the state of the random number generator is made more difficult.
        
</p>
<a name="multiplestatic"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Multiple Reported Locations</h3>

<p>Multiple applications of this algorithm produce different results.  The intersection of multiple reported locations can be used to recover a better estimate of the known location.  This recovered estimate has less uncertainty than the obscuring distance, which is not desirable.
        
</p>
<p>Multiple reported locations for the same known location MUST NOT be produced.  An entity that is responsible for obscuring location might achieve this by storing the reported location with the obscured location.
        
</p>
<p>It is possible to implement obscuring for a static location without retaining state.  Seeding a pseudo-random number generator with data that is not available to the recipient can ensure that the same result is produced from the same input.  Taking a hash of the known location combined with a secret key ensures that this seed cannot be easily determined by a recipient.  A hash function that includes the values shown in <a class='info' href='#noise2d'>Section&nbsp;4.3.4<span> (</span><span class='info'>Random Grid</span><span>)</span></a> is sufficient for this task.
        
</p>
<a name="dynamic"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Obscuring Changing Locations</h3>

<p>Applications that use the location of a target over time, such as <a class='info' href='#RFC4079'>presence<span> (</span><span class='info'>Peterson, J., &ldquo;A Presence Architecture for the Distribution of GEOPRIV Location Objects,&rdquo; July&nbsp;2005.</span><span>)</span></a> [RFC4079] require additional steps to ensure that the location a recipient acquires does not reveal more information than desired.
      
</p>
<p>The first consideration is the frequency of updates.  As the target moves, the known location changes.  A continuous stream of reported locations could give a recipient sufficient information to determine the known location with low uncertainty in a fashion close to that described in <a class='info' href='#multiplestatic'>Section&nbsp;3.4<span> (</span><span class='info'>Multiple Reported Locations</span><span>)</span></a>.
      
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>It is not necessary to ensure that a recipient always has accurate location information.  Early proposed algorithms wrongly assumed that the reported location was required to cover the known location at all times.  Even in the absence of obscuring, changes in location result in a recipient having outdated information.  The only necessary constraint is that the location be accurate at the time that it is reported (or the time associated with that report).
      
</dd>
</dl></blockquote>

<a name="trigger"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Update Conditions</h3>

<p>To limit the amount of information provided to a recipient, new reported locations are not generated in response to all changes in the known location.  The trigger for creating a new reported location can be defined.
        
</p>
<p>Any trigger condition needs to be constructed in a way that does not reveal information.  At the point that a new reported location is provided to a recipient, the fact that the trigger conditions are met at that point in time provides the recipient with significant information that could - if the trigger conditions were poorly defined - reveal significant information.
        
</p>
<p>The goal is to provide a new reported location when the known location moves by approximately the obscuring distance.  This limits the information that a recipient has available with similar accuracy to each individual location.
        
</p>
<a name="bad-trigger"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Bad Triggers</h3>

<p>One potential trigger is the movement of the target outside of the reported uncertainty region.  At the point that a new reported location is generated, a recipient knows that the target is a) at the boundary of the last uncertainty region, and b) somewhere in the new uncertainty region.  The intersection of these two regions produces an area that is significantly smaller than desired.
          
</p><br /><hr class="insert" />
<a name="overlap"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                  New Reported
                                    Location
           ..--"""--..   ..--"""--..   /
        .-'           /=\.          `-.
      ,'            ,'   \\            `.
     /             /       \\            \
    /             /         \\            \
   |             |           ||            |
   |             |           ||            |
   |             |           ||            |
    \             \         //            /
     `.            `.     // \          .'
       `._           `._//    \      _.'
      /   `--..___..--' `--..__\..--'
   Last Reported                \
     Location               Recovered Location
                              Along Border
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Trigger on Leaving the Reported Location&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Similarly, information is revealed if the trigger is movement based on the known location.  A new reported location might be produced when the known location moves more than the obscuring distance from the known location from the last report.
          </p>
<blockquote class="text">
<p>That is, when a new location is reported, the corresponding known location is saved.  A new reported location is determined when the current known location is more than the obscuring distance from the saved location.
            
</p>
</blockquote><p>
          If the recipient is able to assume that the target is moving in a straight line, the speed of the target is revealed.
          
</p>
<a name="hidden-trigger"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Hidden Trigger</h3>

<p>To limit the information that is revealed at the point that a new reported location is provided, the trigger conditions can be based on information that is not available to the recipient.
          
</p>
<p>Applying randomization to the trigger reduces the ability of a recipient to make assertions about the significance of a new reported location.
          
</p>
<p>A hidden trigger is established using the following process:
          </p>
<ul class="text">
<li>When a new reported location is generated:
            
<ol class="text">
<li>The centroid of the known location is determined.
</li>
<li>A <a class='info' href='#rvector'>random offset vector<span> (</span><span class='info'>Selecting a Offset Vector</span><span>)</span></a> of a maximum size of half the obscuring distance is determined.
</li>
<li>The offset vector is added to the centroid and this value is saved as a trigger point.
              
</li>
</ol>
            
</li>
<li>When the known location changes:
            
<ol class="text">
<li>The centroid of the (new) known location is determined.
</li>
<li>If this centroid is further than the obscuring distance from the saved trigger point, a new reported location is generated.
              
</li>
</ol>
            
</li>
</ul><p>
          
</p>
<p>Each new reported location is randomized using the process described in <a class='info' href='#static'>Section&nbsp;3<span> (</span><span class='info'>Obscuring Static Locations</span><span>)</span></a>.
          
</p>
<p>This algorithm ensures that the centroid of the known location moves between 0.5 and 1.5 times the obscuring distance before a new reported location is produced.  As a consequence, the uncertainty in the distance moved is equal to the obscuring distance.
          
</p>
<a name="consecutive"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Consecutive Reported Locations</h3>

<p>The obscuring method has a weakness that is as a direct consequence of the triggering conditions.  These conditions grant a recipient this information:
        </p>
<blockquote class="text">
<p>For any two consecutive reported locations there is a pair of points that are less than 1.5 times the obscuring distance apart, with one point in the area described by each reported location.  The first point is the known location at the time of the first reported location; the second point is the known location at the time of the second reported location.
        
</p>
</blockquote><p>
        
</p>
<p>At the time that a location is reported, the recipient can use this knowledge to determine that the current location of the target is at the intersection of the new reported location and a circle with a radius of 2.5 times the obscuring distance, centered on the last reported location, as shown in <a class='info' href='#biggap'>Figure&nbsp;2<span> (</span><span class='info'>Consecutive Reported Locations</span><span>)</span></a>
        
</p><br /><hr class="insert" />
<a name="biggap"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                   Known location .
                   is in overlap   \
      Last                    \     \             New
          ,.--"--..            \     \   ,.--"--..
       ,-'         `-.          \    |,-'         `-.
      /               \          \_  +               \
     |                 |            /|                |
     |        o        |&lt;----------&gt;||       o        |
     |         \       | --&gt; 1.5OD  \|                |
      \         \     /              +               /
       `.        \  ,'               |`.           ,'
         `-..___,.+'                 ;  `-..___,.-'
                   \                /
     |&lt;------&gt;|&lt;----\-&gt;|&lt;------&gt;|&lt;-/----&gt;|&lt;------&gt;|&lt;--...
          OD      OD \     OD     / OD       OD
                      \         ,'
                 2.5OD \       /
                        \   _,'
                        _\/'         OD = obscuring
                     _,,-'                distance
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Consecutive Reported Locations&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Two consecutive reported locations can have their centers up to 3.5 times the obscuring distance apart; making the closest points on each uncertainty region up to 1.5 times the obscuring distance apart.  When consecutive reported locations are maximally distant, a recipient can recover the location of the target almost perfectly.
        
</p>
<p>This relies on the recipient being able to determine the obscuring distance.  As identified, the obscuring distance is not protected.
        
</p>
<a name="smoothing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Reducing Variation between Offset Vectors</h3>

<p>This shortcoming can be addressed by reducing the difference between the random offset vector added to consecutive reported locations.  The extreme case shown in <a class='info' href='#biggap'>Figure&nbsp;2<span> (</span><span class='info'>Consecutive Reported Locations</span><span>)</span></a> only arises because the absolute difference between the randomization vector used for in consecutive reported locations is twice the obscuring distance.  The problem occurs when the difference between consecutive know locations approachs 1.5 times the obscuring distance in combination with this large difference between randomization vectors.
          
</p>
<p>Reducing the amount that a offset vector can change between consecutive reported locations reduces.  If the difference between offset vectors is constrained then the effect of this problem is reduced.
          
</p>
<p>Using the same offset vector for all reported locations removes the problem entirely.  However, using the same offset vector increases the chances of that vector being discovered.  For instance, if the target is following a road, reported locations that have a fixed offset from the known location will reveal the shape of the road.  From this it is trivial to learn the offset vector and hence all presence and past locations can be recovered.
          
</p>
<p>Each time a location is randomized, the offset vector used can be the combination of a new random offset vector and the offset  vector that was last used.  The proportion of old and new vectors determines the trade-off between the probability that a recipient is able to learn a more accurate location with the probability that a recipient is able to learn the offset.
          
</p>
<a name="smoothingamt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Trade-off in Reducing Variation</h3>

<p>A small amount of randomness at each stage makes it difficult to learn the offset vector.  A number reported locations are required to learn the offset vector.  Therefore, as long as the offset vector is able to change significantly over a number of reported locations, the goal is achieved,   Thus, the offset vector need only change a small amount for each consecutive reported location.  This need only make it difficult to learn the vector and to make learning the vector less useful if it is revealed.
          
</p>
<p>In turn a smaller change in the offset vector maximizes the worst case area.  If the absolute difference in offset vectors is half the obscuring distance, then there is no gap between consecutive reported locations and in the worst case the recipient is able to determine the known location to be within 77 percent of the desired area.  This varies based on <tt>r(diff)</tt>, as follows:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   a(diff) = ((1.5 + diff)^2 - 5.25) / (2*(1.5 + diff))
   r(diff) = acos(a(diff)) + 6.25 * acos((1.5 + diff - a(diff)) / 2.5)
             - (1.5 + diff) * sqrt(1 - a(diff)^2)
</pre></div>
<p>...where <tt>acos(x)</tt> returns the inverse cosine of <tt>x</tt>.  This only produces a result where <tt>diff</tt> is less than 2.
          
</p>
<p>It might be useful in this case to create a offset vector that is no more than <tt>diff</tt> times the oscuring distance different to the previous vector.  This might be done by taking a weighted average of the previous vector with a new random offset vector as follows:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   o[new] =  (o[prev] * (2 - diff) + o[random] * diff) / 2
</pre></div>
<p>...where <tt>o[new]</tt> is the new ofset vector, <tt>o[prev]</tt> is the new previous vector, and <tt>o[random]</tt> is a completely random vector of the same magnitude.
          
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Returning to the Same Location</h3>

<p>A moving target might return to the same location several times.  The method described thus far produces a different reported location each time.  With some inferences, a recipient that is able to observe location over time could intersect reported locations to recover
        
</p>
<p>Furthermore, if known locations are not available before and after leaving the location that is frequently visited, only that location is obscured.  The known location could be readily extracted.
        
</p>
<a name="posstability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Positional Stability</h3>

<p>The key to addressing this flaw is to have the randomization of offset vectors based on the known location.  If the same known location produced a reported location that was equal or very close to it each time that the location was obscured, this would address the problem.
          
</p>
<p>It might be possible to take the coordinates of the known location and pass them through a cryptographic hash function along with a secret key. The result bits would be sufficiently random to produce an offset vector.  This would ensure that the exact same location would produce the same random vector.
          
</p>
<p>The drawback of this sort of method is that the location is obscured inconsistently when even the slightest difference occurs in the known location.  Imprecision in the location determination method used frequently produces variations in the known location, making this approach not viable.
          
</p>
<p>The goal is to ensure that two known locations in close proximity produce a constant (or almost constant) random vector.  It is also desirable that the random vector change as the locations change.  This has the consequence of reducing the difference in randomness between consecutive reported locations, provided that the random values do not vary significantly over a distance of 1.5 times the obscuring distance.
          
</p>
<p>It might be desirable if the random vectors changed over a longer distance, as <a class='info' href='#smoothing'>Section&nbsp;4.2.1<span> (</span><span class='info'>Reducing Variation between Offset Vectors</span><span>)</span></a> demonstrates.  If the offset vector changed over a period of approximately 4 times the randomization distance, the vector would change by no more than about 3/4 of the offset distance.
          
</p>
<p>An approach similar to that described in <a class='info' href='#PERLIN'>[PERLIN]<span> (</span><span class='info'>Perlin, K., &ldquo;An Image Synthesizer,&rdquo; July&nbsp;1985.</span><span>)</span></a> is used to achieve a continuously varying random field.  In this, randomness is constrained to a grid of points with interpolation used to determine values for intervening points.
          
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Triggering with Positional Stability</h3>

<p>No specific changes are required for the triggering process, though this does require that some state be maintained by the entity that performs obscuring.  For a SIP entity that is maintaining a subscription, this is not expected to be onerous.
          
</p>
<p>The advantage of having a specific trigger for providing a new reported location is that it reduces the information provided to a recipient.  Providing updates at a higher rate provide a recipient with additional information that could be used to recover the offset.
          
</p>
<a name="grid"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Selecting a Grid</h3>

<p>In selecting an appropriate grid with two dimensions, the curvature of the surface of the Earth presents a challenge.  The simplest approach might be to select an origin at latitude 0, longitude 0.  Grid points could be placed at increments based on a constant ratio between latitude and longitude and distance; for example, 9e-6 degrees per meter assumes a spherical planet of 6366197 meter radius, which is slightly smaller than the semi-major axis of the ellipsoid used in most Earth models.
          
</p>
<p>Grid intervals can be set to a multiple of the obscuring distance that ensures that consecutive reported locations have continuously varying offset vectors.  Assuming that linear interpolation is used in <tt>n</tt> dimensions, a multiple of <tt>m</tt> produces a proportional change in the offset vector of:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   change = (1 - (m - 1.5 * 2^((3 - n)/2)) / m)^n
</pre></div>
<p>For a two-dimensional grid with a multiple of <tt>m</tt>, the following equations identify the latitude and longitude of the four nearest grid points to a given location:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   grid =  m * obscuring distance * 9e-6

   latitude[low] =  floor(latitude / grid) * grid
   latitude[high] =  latitude[low] + grid

   longitude[low] =  floor(longitude / grid) * grid
   longitude[high] =  longitude[low] + grid
</pre></div>
<p>...where <tt>floor(x)</tt> produces the nearest whole integer that is more negative than <tt>x</tt>.
          
</p>
<p>The shortcoming of a grid of this nature is that changes in longitude are more rapid as locations get closer to the poles.  At approximately 60 degrees of latitude (North or South), grid intervals on the East-West direction are twice as frequent as desired.  For this reason, larger intervals between grid points might be chosen for longitudes.
          
</p>
<p>A solution for this problem is described in <a class='info' href='#wonky'>Section&nbsp;4.3.6<span> (</span><span class='info'>The Wonky Grid</span><span>)</span></a>.  An alternative problem might select a local tangent plane removes the effect of the curvature of the Earth, though this introduces the problem of selecting an appropriate tangent plane as locations change.
          
</p>
<p></p>
<blockquote class="text">
<p>In three dimensions, conversion to Earth-centered, Earth-fixed Cartesian coordinates renders this problem moot.
</p>
</blockquote>

<a name="noise2d"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
Random Grid</h3>

<p>At each of the points on the grid, a random offset vector is produced using the method described in <a class='info' href='#rvector'>Section&nbsp;3.3<span> (</span><span class='info'>Selecting a Offset Vector</span><span>)</span></a>.  The resulting offset vectors are interpolated as shown in <a class='info' href='#interp'>Figure&nbsp;3<span> (</span><span class='info'>Grid Interpolation</span><span>)</span></a>.
          
</p>
<p>Rather than use a random number generator, the random number should be produced using a cryptographic hash function.  The input to this hash should include:
          </p>
<ul class="text">
<li>a <a class='info' href='#RFC4086'>random sequence<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> [RFC4086] with the desired entropy that is only known by the entity that performs the obscuring,
            
</li>
<li>the identity of the target,
            
</li>
<li>each individual coordinate of the grid point, and
            
</li>
<li>as necessary, an identifier for the purposes of the random number: angle, distance, and (optionally) a second distance, depending on the method used to generate the random offset vector.
            
</li>
</ul><p>
          The inclusion of a secret ensures that a recipient is unable to construct the offset vector.  This secret is persistent so that later applications of the obscuring formula do not produce a different offset vector for the same location.
          
</p>
<p><a class='info' href='#rvector'>Section&nbsp;3.3<span> (</span><span class='info'>Selecting a Offset Vector</span><span>)</span></a> requires that two or three random numbers are produced.  The additional identifier produces additional randomness where multiple random (or pseudo-random) numbers are required.
          
</p>
<p>Using a hash in this fashion ensures that each target gets a different set of random offset vectors and that the same grid point coordinates produce the same result.
          
</p>
<p>Though ordering need only be consistent between consequent applications of the obscuring algorithm, the following might be used to produce random bits:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   random = H(secret key | target identity | identifier
              | grid coordinate | grid coordinate | ...)
</pre></div>
<p>...where <tt>|</tt> represents concatenation, including a delimiter as necessary (that is, to delineate variable length values).
          
</p>
<p>Alternatively, the same sequence could be used to seed a <a class='info' href='#RFC4086'>secure random number generator<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a> [RFC4086].  Extracting values in the same order makes the <tt>identifier</tt> unnecessary.
          
</p>
<p>One consequence of this approach is that changes to the obscuring distance result in the noise pattern being completely changed.  This can result in the same known location producing a significantly different reported location before and after the change.
          
</p>
<a name="interpolation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5"></a><h3>4.3.5.&nbsp;
Linear Interpolation of Random Offsets</h3>

<p>Once a grid of random offset vectors is established, an offset vector is calculated based on the centroid of the known location.  <a class='info' href='#interp'>Figure&nbsp;3<span> (</span><span class='info'>Grid Interpolation</span><span>)</span></a> shows a point at <tt>(x,y)</tt> and the values that are used in the interpolation process.
          
</p><br /><hr class="insert" />
<a name="interp"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         |                              |
    - ---o------------------------------o---
        /|          ^                  /|
 (x1,y2) |          |           (x2,y2) |
         |          | (y2-y)            |
         |    (x,y) |                   |
         |        \ v                   |
         |&lt;-(x-x1)-&gt;X&lt;------(x2-x)-----&gt;|
         |          ^                   |
         |          | (y-y1)            |
         |          v                   |
    - ---o------------------------------o---
        /|                             /|
 (x1,y1) |                      (x2,y1) |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Grid Interpolation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The offset vector at the identified point is produced by taking the weighted average of the offset vectors.  Two weighted averages are taken between pairs of adjacent grid points along the same axis, then the weighted average of the two resulting vectors is taken along the other axis.
          
</p>
<p>The following equations produce an linearly interpolated offset vector for any point in this grid cell:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   tx = (x - x1) / (x2 - x1)
   ty = (y - y1) / (y2 - y1)
   w1 = o[x1,y1] * (1 - tx) + o[x2,y1] * tx
   w2 = o[x1,y1] * (1 - tx) + o[x2,y1] * tx
   offset = w1 * (1 - ty) + w2 * ty
</pre></div>
<p>...where <tt>o[x1,y1]</tt> is the random offset vector at the grid point <tt>(x1,y1)</tt>.
          
</p>
<a name="uderp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5.1"></a><h3>4.3.5.1.&nbsp;
Uniformly Distributed Interpolation</h3>

<p>A consequence of performing a weighted average is that the resulting value is not uniformly distributed.  Depending on the weighting factor (the value <tt>tx</tt> or <tt>ty</tt> in <a class='info' href='#interpolation'>Section&nbsp;4.3.5<span> (</span><span class='info'>Linear Interpolation of Random Offsets</span><span>)</span></a>), the resulting probability distribution has a higher probability of producing values in the middle of the range of possible values.
            
</p>
<p>For example, the probability distribution for a weighted average of two uniformly distributed random numbers between 0 and 1 is shown in <a class='info' href='#weightedpdf'>Figure&nbsp;4</a>.  The figure shows the case where <tt>t</tt> is less than 0.5, though the same distribution is produced for <tt>t</tt> and <tt>(1-t)</tt>.
            
</p><br /><hr class="insert" />
<a name="weightedpdf"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
             P(x)
              |
              |    ,---------------.
              |   /:               :\
              |  / :               : \
              | /  :               :  \
              |/   :               :   \
              '----+---------------+------ x
              0    t             (1-t)  1
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In order to correct for this skewing of results toward the middle of the range, a smoothed interpolation is used.
</p>
<p>Over the range from 0 to 1, the following produces a uniformly distributed interpolation between <tt>a</tt> and <tt>b</tt>:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   r = a * (1 - t) + b * t
   IF r &lt; t AND r &lt; (1 - t) THEN:
      r = r * r / 2 / t / (1 - t)
   ELSE IF r &gt; t AND r &gt; (1 - t) THEN:
      r = 1 - (1 - r) * (1 - r) / t / (1 - t)
   ELSE IF t &lt; 0.5 THEN:
      r = (2 * r - t) / 2 / (1 - t)
   ELSE:
      r = (2 * r - 1 + t) / 2 / t
</pre></div>
<p>This maps a linearly interpolated value to a smoothed value, using the cumulative distribution function for the weighted sum of <tt>a</tt> and <tt>b</tt>.  This mapping produces a value between 0 and 1 for inputs between 0 and 1.  The mapping is continuous. The mapping is not monotonically increasing for some values of <tt>a</tt> and <tt>b</tt>; the intent is to have a uniform distribution between 0 and 1, not between <tt>a</tt> and <tt>b</tt>.  Toward the middle of the range, a maximum gradient of 2 is possible.
            
</p>
<p>For convenience, this interpolation function is represented in shorthand throughout the remainder of the document: <tt>uniformDistInterp(a, b, t)</tt>.
            
</p>
<p>This has similar characteristics to the smoothing function used in <a class='info' href='#PERLIN'>[PERLIN]<span> (</span><span class='info'>Perlin, K., &ldquo;An Image Synthesizer,&rdquo; July&nbsp;1985.</span><span>)</span></a>, except that the goal is not smoothing, but ensuring a uniform distribution of values in the output.  Values are continuous, but their first derivative is not.
            
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5.2"></a><h3>4.3.5.2.&nbsp;
Applying Uniformly Distributed Interpolation</h3>

<p>The method for producing a random vector in <a class='info' href='#rvector'>Section&nbsp;3.3<span> (</span><span class='info'>Selecting a Offset Vector</span><span>)</span></a> produces a result that is uniformly distributed in a circular area.  As a result, the cartesian coordinates produced are not evenly distributed on each axis.  Similarly, the polar coordinates have a non-uniformly distributed magnitude.  Rather than interpolate on the output of this process, the uniformly distributed interpolation is applied to the random inputs.
            
</p>
<p>Interpolation is performed on a set of random numbers that are produced at each grid vertex.  This is used to produce a single set of random numbers that are used as input to the algorithm that produces a random vector.
            
</p>
<p>One consequence of this process is that the angle of the random vector does not cross 360 degrees (2 times pi) when being interpolated.  In the worst case, interpolation between two points requires rotation through almost 360 degrees.
            
</p>
<p></p>
<blockquote class="text">
<p>The alternative method of interpolating angles - linear interpolation using the shortest path - does produce an uniformly distributed output, but it also produces a discontinuity that could be exploited by a recipient when interpolation is applied in more than one dimension.  It is possible to produce a change in the offset vector of up to twice the obscuring distance in size as the known location moves only a short distance.
</p>
</blockquote>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5.3"></a><h3>4.3.5.3.&nbsp;
Selecting an Appropriate Grid Size</h3>

<p>Assuming the worst case, the maximum rate of change produced by the uniformly distributed interpolation doubles the rate of rotation.  If the magnitude of the offset vector was the maximum value at each end of the interpolation, the maximum absolute change in offset vector as a result of movement is:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   diff(m, d) = 4 * sin(d * pi / m)
</pre></div>
<p>...where <tt>d</tt> is the distance moved as a proportion of the obscuring distance, <tt>m</tt> is the number of multiples of the obscuring distance in each grid interval, and <tt>2 * d &lt; m</tt>.
            
</p>
<p>The maximum distance between consecutive updates based on the triggerring scheme is 1.5 times the obscuring distance.  With <tt>d</tt> set to 1.5, <tt>m</tt> must be set to a value greater than 9 to ensure that the consecutive offset vectors have an absolute difference of less than twice the obscuring distance.  This protects against the problem described in <a class='info' href='#consecutive'>Section&nbsp;4.2<span> (</span><span class='info'>Consecutive Reported Locations</span><span>)</span></a>.
            
</p>
<p>Setting <tt>m</tt> to 20 ensures that this difference is less than one multiple of the obscuring distance (0.93378 times).  This means that a substantial change in offset vector occurs after linear movement of 20 times the obscuring distance in the aggregate.
            
</p>
<a name="wonky"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.6"></a><h3>4.3.6.&nbsp;
The Wonky Grid</h3>

<p>To address the concerns caused by the curvature of the Earth, a modified grid-like structure can be used.  It is not strictly necessary that the grid be absolutely grid-like in structure.  Therefore, it's possible that different grid intervals could be selected.
          
</p>
<p>This structure uses a different interval for points at different latitudes, at the selected low latitude:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   grid[llat] =  grid / cos(latitude[low])
   longitude[low,llat] =  floor(longitude / grid[llat]) * grid[llat]
   longitude[high,llat] =  longitude[low,llat] + grid[llat]
</pre></div>
<p>...and at the high latitude:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   grid[hlat] = grid / cos(latitude[high])
   longitude[low,hlat] = floor(longitude / grid[hlat]) * grid[hlat]
   longitude[high,hlat] = longitude[low,hlat] + grid[hlat]
</pre></div>
<p>...where <tt>cos(x)</tt> produces the cosine of <tt>x</tt>.
          
</p>
<p>This produces fewer grid points for latitudes that are further from the Equator.  At the poles (and above), a single offset vector is sufficient.
          
</p>
<p>Interpolation of these points uses four distinct points, as shown in <a class='info' href='#wonkyinterp'>Figure&nbsp;5<span> (</span><span class='info'>Wonky Grid Interpolation</span><span>)</span></a>.
          
</p><br /><hr class="insert" />
<a name="wonkyinterp"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                           (x-x1_2)        (x2_2-x)
                         |&lt;--------&gt;|&lt;-----------------&gt;|
                         |          |                   |
                    - ---o------------------------------o--- -
                        /|          |         ^         |\
               (x1_2,y2) :          |         |         : (x2_2,y2)
                                    |         | (y2-y)
                             (x,y)  '         |
                                  \           v
                                    X   - ------
                                              ^
            :                       .   :     | (y-y1)
            |                       |   |     v
       - ---o---------------------------o--------------- -
           /|                       |   |\
  (x1_1,y1) |&lt;---------------------&gt;|&lt;-&gt;| (x2_1,y1)
                    (x-x1_1)       (x2_1-x)
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Wonky Grid Interpolation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Linear interpolation uses the amended equations:
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   tx_1 = (x - x1_1) / (x2_1 - x1_1)
   w1 = uniformDistInterp(r[x1_1,y1], r[x2_1,y1], tx_1)
   tx_2 = (x - x1_2) / (x2_2 - x1_2)
   w2 = uniformDistInterp(r[x1_2,y2], r[x2_2,y2], tx_2)
</pre></div>
<p>Note that this uses the uniformly distributed random values selected at each grid point, rather than the offset vectors.  Each random value is a uniformly distributed random value in the range [0, 1).
          
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.6.1"></a><h3>4.3.6.1.&nbsp;
Wonky Grid Points at the Poles</h3>

<p>At 90 degrees North and South, the cosine used to determine the wonky grid produces a zero.  This produces an undefined grid spacing.
</p>
<p>To avoid this problem, produce a single value at each pole: (90, 0) and (-90, 0).  This value replaces <tt>w1</tt> or <tt>w2</tt> in the interpolation equations.  Retaining the same weighting for determining the final offset is desirable, so that the rate of change is not artificially increased.
            
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.6.2"></a><h3>4.3.6.2.&nbsp;
Interpolation About the 180th Meridian</h3>

<p>At 180 degrees East (or West), longitude values cross from positive to negative values.  This produces a discontinuity in the values used.  This could be exploited to learn when the known location cross the 180th meridian.
            
</p><br /><hr class="insert" />
<a name="interp180"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
             180/-180                         180/-180
                |                                |
 +ve: x1a       |    x2a                  x1a    |        x2a
    ---o---o--X--------o---o--- ... ---o---o--X--------o---o---
          x1b   |         x2b         x1b        |    x2b
        .       |       .                .       |       .
        |               |                |               |
        |&lt;-------------&gt;|                |&lt;-------------&gt;|
      overlap = grid interval          overlap = grid interval
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Interpolation About 180 Degrees&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>This problem might only manifest for one of the two interpolations performed across changing longitude values in a wonky grid.  To address this, the values produced by the negative and positive aspects are independently generated, then these values are interpolated over a span of one grid interval.
            
</p>
<p>For any point within half of one grid interval from the 180th meridian, this algorithm is used.  Perform interpolation using the selected grid points, then add or subtract 360 degrees from the original value to get a value that is either more than 180 degrees or less than -180 degrees.  Perform interpolation on this second point.
            
</p>
<p>The two interpolated values are then interpolated using a different proportion.  This interpolation is taken on the overlap interval that crosses the 180th meridian, as shown in the <a class='info' href='#interp180'>Figure&nbsp;6<span> (</span><span class='info'>Interpolation About 180 Degrees</span><span>)</span></a>.  This proportion is produced by taking the positive input value (that is, the longitude value, with 360 degrees added if it is negative) and applying the following:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   grid = m * obscuring distance * 9e-6 / cos(latitude)
   IF longitide + grid / 2 &gt; 180 OR longitude - grid / 2 &lt; -180 THEN:
      t = ((longitude + 360) % 360 - 180 - grid / 2) / grid
      random[o] = uniformDistInterp(random[+ve], random[-ve], t)
   ENDIF
</pre></div>
<p>...where <tt>%</tt> represents the modulo operation.  The final interpolated value is determined using the uniformly distributed weighted average method described in <a class='info' href='#uderp'>Section&nbsp;4.3.5.1<span> (</span><span class='info'>Uniformly Distributed Interpolation</span><span>)</span></a>.
            
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.7"></a><h3>4.3.7.&nbsp;
Temporal Interpolation</h3>

<p>Providing different values over time is difficult to balance against the need to obscure the same location in the same way.  It is possible to add additional dimensions upon which to interpolate the offset vector.  Adding time as one such dimension would allow the offset vector to change gradually over time as well as with respect to space.
          
</p>
<p>Although a form of temporal interpolation might allow the obscuring entity to change the secret key that it maintains, it does not provide positional stability unless the interpolation is performed over a significant period.  Changing the offset vector applied to the same location would negate much of the benefit derived from the algorithm.
          
</p>
<a name="examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Examples</h3>

<p>TBD
</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>Thanks go to Robert Sparks for identifying key shortcomings in the original attempts.   Richard Barnes, Jorge Cuellar, Cullen Jennings, Warren Kumari, and Hannes Tschofenig variously provided input, feedback, criticisms and insightful ideas.
      
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This document has no IANA actions.
</p>
<p>[RFC Editor: please remove this section prior to publication.]
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>This document describes a method for obscuring location.  An effort has been made to ensure that reported locations do not reveal any more information than the input dictates.  However, obscuring location is not a substitute for withholding location information if the goal is to ensure that a recipient remains ignorant of the known location.  Alternatively, a recipient might be provided with completely falsified location information.
</p>
<p>There is little point in obscuring location when other location-related information is included in a composite document, like a <a class='info' href='#RFC3863'>presence document<span> (</span><span class='info'>Sugano, H., Fujimoto, S., Klyne, G., Bateman, A., Carr, W., and J. Peterson, &ldquo;Presence Information Data Format (PIDF),&rdquo; August&nbsp;2004.</span><span>)</span></a> [RFC3863].  Removing other information, such as <a class='info' href='#RFC5965'>dynamic location information<span> (</span><span class='info'>Shafranovich, Y., Levine, J., and M. Kucherawy, &ldquo;An Extensible Format for Email Feedback Reports,&rdquo; August&nbsp;2010.</span><span>)</span></a> [RFC5965] is necessary to ensure that this cannot be used to recover the known location.
      
</p>
<p>A reported location can inadvertently reveal far more information than intended to a recipient in possession of additional information.  A recipient might be able to apply this additional information to determine the location of the target with less uncertainty than desired.  For instance, a recipient with a map might be able to identify areas on that map that a target is more likely to be found.  A recipient can combine any additional information with the knowledge that the reported location is correct at the time it is reported to recover a better estimate of the known location.  Aside from map-based data, other information that could be used to acquire a more accurate estimate of the location of a target might include knowledge of the target's past behavior, personality traits, or aggregated demographic data.  Increasing the obscuring distance might increase the uncertainty in the location the recipient ultimately recovers.  The complexity involved and the large volume of additional data involved makes more specific measures difficult.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-geopriv-arch">[I-D.ietf-geopriv-arch]</a></td>
<td class="author-text">Barnes, R., Lepinski, M., Cooper, A., Morris, J., Tschofenig, H., and H. Schulzrinne, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-geopriv-arch-03.txt">An Architecture for Location and Location Privacy in Internet Applications</a>,&rdquo; draft-ietf-geopriv-arch-03 (work in progress), October&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-geopriv-arch-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-geopriv-policy">[I-D.ietf-geopriv-policy]</a></td>
<td class="author-text">Schulzrinne, H., Tschofenig, H., Morris, J., Cuellar, J., and J. Polk, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-geopriv-policy-22.txt">Geolocation Policy: A Document Format for Expressing Privacy Preferences for Location Information</a>,&rdquo; draft-ietf-geopriv-policy-22 (work in progress), October&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-geopriv-policy-22.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.thomson-geopriv-uncertainty">[I-D.thomson-geopriv-uncertainty]</a></td>
<td class="author-text">Thomson, M. and J. Winterbottom, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-thomson-geopriv-uncertainty-05.txt">Representation of Uncertainty and Confidence in PIDF-LO</a>,&rdquo; draft-thomson-geopriv-uncertainty-05 (work in progress), May&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-thomson-geopriv-uncertainty-05.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="PERLIN">[PERLIN]</a></td>
<td class="author-text">Perlin, K., &ldquo;An Image Synthesizer,&rdquo; ACM SIGGRAPH Computer Graphics&nbsp;v.19 n.3, p.287-296, July&nbsp;1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3863">[RFC3863]</a></td>
<td class="author-text">Sugano, H., Fujimoto, S., Klyne, G., Bateman, A., Carr, W., and J. Peterson, &ldquo;<a href="http://tools.ietf.org/html/rfc3863">Presence Information Data Format (PIDF)</a>,&rdquo; RFC&nbsp;3863, August&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3863.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4079">[RFC4079]</a></td>
<td class="author-text">Peterson, J., &ldquo;<a href="http://tools.ietf.org/html/rfc4079">A Presence Architecture for the Distribution of GEOPRIV Location Objects</a>,&rdquo; RFC&nbsp;4079, July&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4079.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4119">[RFC4119]</a></td>
<td class="author-text">Peterson, J., &ldquo;<a href="http://tools.ietf.org/html/rfc4119">A Presence-based GEOPRIV Location Object Format</a>,&rdquo; RFC&nbsp;4119, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4119.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5491">[RFC5491]</a></td>
<td class="author-text">Winterbottom, J., Thomson, M., and H. Tschofenig, &ldquo;<a href="http://tools.ietf.org/html/rfc5491">GEOPRIV Presence Information Data Format Location Object (PIDF-LO) Usage Clarification, Considerations, and Recommendations</a>,&rdquo; RFC&nbsp;5491, March&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5491.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5965">[RFC5965]</a></td>
<td class="author-text">Shafranovich, Y., Levine, J., and M. Kucherawy, &ldquo;<a href="http://tools.ietf.org/html/rfc5965">An Extensible Format for Email Feedback Reports</a>,&rdquo; RFC&nbsp;5965, August&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5965.txt">TXT</a>).</td></tr>
</table>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Sample Implementation</h3>

<p>This javascript implements the obscuring algorithm.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
/**
 * Location obscurer:
 *   var f = new GeoShape.Fuzzer(100, secret, target);
 *   var reported = f.fuzz(known);
 * This object retains state.
 */
GeoShape.Fuzzer = function(dist, secret, targetIdentity) {
    this.distance = dist;
    var key = UTF8(secret).concat( [ 0xff ], UTF8(targetIdentity));
    this.random = new GeoShape.UIRandom(key, dist);
    this.trigger = null;
    this.used = 0;
    return this;
};
GeoShape.Fuzzer.prototype = {
    /**
     * Main obscuring function.
     * @param {GeoShape} a shape
     * @returns {GeoShape.GeoCircle} a fuzzed circle
     */
    fuzz: function(shape) {
        var cu = shape.calculateCentroid();
        /*
         * cu contains two attributes:
         * centroid: a WGS84 point uncertainty: a distance in metres
         */
        if (!cu.uncertainty) {
            cu.uncertainty = 0;
        }
        if (this.hasMoved(cu.centroid)) {
            var addunc = Math.max(0, this.distance - cu.uncertainty);
            var centre = this.fuzzPoint(cu.centroid, addunc);
            var unc = Math.max(cu.uncertainty, this.distance);
            this.fuzzed = new GeoShape.GeoCircle(centre, unc);
            var td = this.distance / 2;
            this.trigger = this.randomize(cu.centroid, td);
            this.used = 0;
        }
        this.used++;
        return this.fuzzed;
    },
    /**
     * Determine if the location has moved sufficient distance
     * from the trigger to require fuzzing.
     */
    hasMoved: function(centroid) {
        if (!this.trigger) {
            return true;
        }
        return this.trigger.distanceTo(centroid) &gt; this.distance;
    },
    /**
     * Use a continuously varying random grid to move a point.
     */
    fuzzPoint: function(point, dist) {
        this.random.reset();
        var n = this.random.next(point.latitude, point.longitude);
        var d = Math.sqrt(n) * dist;
        var a = this.random.next(point.latitude, point.longitude);
        return point.movePoint(d, a * 2 * Math.PI);
    },
    /**
     * Move a point randomly (not continuous).
     */
    randomize: function(point, dist) {
        var d = Math.sqrt(Math.random()) * dist;
        var a = Math.random() * 2 * Math.PI;
        return point.movePoint(d, a);
    }
};

/**
 * A uniformly distributed pseudorandom number generator that
 * produces the same value for the same key, location and
 * grid size.
 *
 * @param key a unique, secret key sequence
 * @param gridSize the desired size of the grid, in metres
 */
GeoShape.UIRandom = function(key, gridSize) {
    this.prefix = (key instanceof Array) ? key : UTF8(key);
    this.prefix.push(0xff);
    this.grid = 20 * gridSize * 9e-6;
    this.reset();
    return this;
};
GeoShape.UIRandom.prototype = {
    /**
     * Get next pseudorandom value for a latitude and longitude.
     */
    next: function(lat, lng) {
        var lowlat = Math.floor(lat / this.grid) * this.grid;
        var bottom = this.interpLongitude(lowlat, lng);
        var top = this.interpLongitude(lowlat + this.grid, lng);
        var tlat = (lat - lowlat) / this.grid;

        this.rCount++; /* next time produces a different answer */
        return this.uniformDistInterp(bottom, top, tlat);
    },
    reset: function() {
        this.rCount = 0;
    },
    /* Takes a point and produces a "random" value. */
    hashRandom: function(lat, lng) {
        /* need to fix the lat and lng: 7 decimal places */
        var flat = Math.round(lat * 1e7).toString();
        var flng = Math.round(lng * 1e7).toString();

        var input = this.prefix.concat([ this.rCount ], UTF8(flat),
                                       [ 0xff ], UTF8(flng));
        var h = SHA1.hash(input);
        var r = 0;
        for ( var i = 0; i &lt; h.length; ++i) {
            r ^= h[i] &lt;&lt; ((i % 4) * 8);
        }
        /* add 0.5 to deal with sign bit */
        return r / Math.pow(2, 32) + 0.5;
    },
    /* interpolate a and b using t, with a uniform distribution */
    uniformDistInterp: function(a, b, t) {
        var r = a * (1 - t) + b * t;
        if (r &lt; t &amp;&amp; r &lt; (1 - t)) {
            r = r * r / 2 / t / (1 - t);
        } else if (r &gt; t &amp;&amp; r &gt; (1 - t)) {
            r = 1 - (1 - r) * (1 - r) / 2 / t / (1 - t);
        } else {
            r = 0.5 + (r - 0.5) / Math.max(t, 1 - t);
        }
        return r;
    },
    interpLongitude: function(lat, lng) {
        if (Math.abs(lat) &gt;= 90) {
            return this.hashRandom((lat &gt; 0) ? 90 : -90, lng);
        }
        var size = this.grid / Math.cos(lat * Math.PI / 180);
        if ((lng - size / 2) &lt; -180 || (lng + size / 2) &gt; 180) {
            var lngpos = (lng + 360) % 360;
            var rpos = this.interpLongSimple(lat, lngpos, size);
            var lngneg = lngpos - 360;
            var rneg = this.interpLongSimple(lat, lngneg, size);
            var t = ((lng + 360) % 360 - 180 - size / 2) / size;
            return this.uniformDistInterp(rpos, rneg, t);
        }
        return this.interpLongSimple(lat, lng, size);
    },
    interpLongSimple: function(lat, lng, size) {
        var lowlng = Math.floor(lng / size) * size;
        var rlow = this.hashRandom(lat, lowlng);
        var rhigh = this.hashRandom(lat, lowlng + size);
        var t = (lng - lowlng) / size;
        return this.uniformDistInterp(rlow, rhigh, t);
    }
};
</pre></div>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Martin Thomson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Andrew Corporation</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Andrew Building (39)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wollongong University Campus</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Northfields Avenue</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wollongong, NSW  2522</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">AU</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+61 2 4221 2915</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:martin.thomson@andrew.com">martin.thomson@andrew.com</a></td></tr>
</table>
</body></html>
