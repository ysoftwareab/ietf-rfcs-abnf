count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);

bodyLen = 1st_octet;
bodyLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192

bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |
                (4th_octet << 8)  | 5th_octet

partialBodyLen = 1 << (1st_octet & 0x1F);

lengthOfLength = 1
subpacketLen = 1st_octet

lengthOfLength = 2
subpacketLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192

lengthOfLength = 5
chunk_size = ((uint64_t)1 << (c + 6))

vBSFjNSiVHsuAA==
B = 04 || x || y

B = 40 || x

ZB = x;
MB = Hash ( 00 || 00 || 00 || 01 || ZB || Param );
m = symm_alg_ID || session key || checksum || pkcs5_padding;
curve_OID_len = (byte)len(curve_OID);
Param = curve_OID_len || curve_OID || public_key_alg_ID || 03
Z_len = the key size for the KEK_alg_ID used with AESKeyWrap
VB = convert point V to the octet string
S = rV = rvG, where (r,R) is the recipient's key pair.

k = the length in octets of the key modulus

M = message to be encoded, an octet string of length mLen, where mLen
EM = encoded message, an octet string of length k

EM = 0x00 || 0x02 || PS || 0x00 || M.

EM = encoded message, an octet string

M = message, an octet string

EM = 0x00 || 0x02 || PS || 0x00 || M.

M = message to be encoded

emLen = intended length in octets of the encoded message, at least
        tLen + 11, where tLen is the octet length of the DER encoding
        T of a certain value computed during the encoding operation

EM = encoded message, an octet string of length emLen

H = Hash(M).

EM = 0x00 || 0x01 || PS || 0x00 || T.

