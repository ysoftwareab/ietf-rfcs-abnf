<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Basic Socket Interface Extensions for Host Identity Protocol (HIP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Basic Socket Interface Extensions for Host Identity Protocol (HIP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Host Identity Protocol</td><td class="header">M. Komu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Helsinki Institute for Information</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">Technology</td></tr>
<tr><td class="header">Expires: January 14, 2010</td><td class="header"> Henderson</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">The Boeing Company</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 13, 2009</td></tr>
</table></td></tr></table>
<h1><br />Basic Socket Interface Extensions for Host Identity Protocol (HIP)<br />draft-ietf-hip-native-api-07</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may not be modified, and derivative works of it may
not be created, except to format it for publication as an RFC or
to translate it into languages other than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 14, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document defines extensions to the current sockets API for
     the Host Identity Protocol (HIP). The extensions focus on the use of
     public-key based identifiers discovered via DNS resolution, but
     define also interfaces for manual bindings between HITs and
     locators.  With the extensions, the application can also support
     more relaxed security models where the communication can be
     non-HIP based, according to local policies. The extensions in
     document are experimental and provide basic tools for
     further experimentation with policies.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#sec:intro">1.</a>&nbsp;
Introduction<br />
<a href="#sec:terminology">2.</a>&nbsp;
Terminology<br />
<a href="#sec:api_overview">3.</a>&nbsp;
API Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:resolver">3.1.</a>&nbsp;
Interaction with the Resolver<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:no-resolver">3.2.</a>&nbsp;
Interaction without a Resolver<br />
<a href="#sec:syntax">4.</a>&nbsp;
API Syntax and Semantics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:sock">4.1.</a>&nbsp;
Socket Family and Address Structure Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:getaddrinfo">4.2.</a>&nbsp;
Extensions to Resolver Data Structures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:getsock">4.3.</a>&nbsp;
The Use of getsockname and getpeername Functions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:sockopt">4.4.</a>&nbsp;
Selection of Source HIT Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:types">4.5.</a>&nbsp;
Verification of Source HIT Type<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:explicit">4.6.</a>&nbsp;
Explicit Handling of Locators<br />
<a href="#anchor1">5.</a>&nbsp;
Summary of New Definitions<br />
<a href="#sec:iana">6.</a>&nbsp;
IANA Considerations<br />
<a href="#sec:security">7.</a>&nbsp;
Security Considerations<br />
<a href="#anchor2">8.</a>&nbsp;
Contributors<br />
<a href="#sec:acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="sec:intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
This document defines C-based sockets Application Programming
Interface (API) extensions for handling HIP-based identifiers
explicitly in HIP-aware applications. It is up to the applications, or
high-level programming languages or libraries, to manage the
identifiers. The extensions in this document are mainly related to the
use case in which a DNS resolution step has occurred prior to the
creation of a new socket, and assumes that the system has cached
or is otherwise able to resolve identifiers to locators (IP addresses).
The DNS extensions for HIP are described in <a class='info' href='#RFC5205'>[RFC5205]<span> (</span><span class='info'>Nikander, P. and J. Laganier, &ldquo;Host Identity Protocol (HIP) Domain Name System (DNS) Extensions,&rdquo; April&nbsp;2008.</span><span>)</span></a>.
The extensions also cover the case in which an application may want
to explicitly provide suggested locators with the identifiers, including
supporting the opportunistic case in which the system does not know
the peer host identity.

</p>
<p>The Host Identity Protocol (HIP) <a class='info' href='#RFC4423'>[RFC4423]<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a> proposes
a new cryptographic namespace by separating the roles of end-point
identifiers and locators by introducing a new namespace to the
TCP/IP stack. SHIM6 <a class='info' href='#I-D.ietf-shim6-proto'>[I&#8209;D.ietf&#8209;shim6&#8209;proto]<span> (</span><span class='info'>Nordmark, E. and M. Bagnulo, &ldquo;Shim6: Level 3 Multihoming Shim Protocol for IPv6,&rdquo; February&nbsp;2009.</span><span>)</span></a> is another
protocol based on identity-locator split.
The APIs specified in this document are specific to HIP, but
have been designed as much as possible so
as not to preclude its use with other protocols. The use of these APIs with
other protocols is, nevertheless, for further study.

</p>
<p>
The APIs in this document are based on IPv6 addresses with the ORCHID prefix
<a class='info' href='#RFC4843'>[RFC4843]<span> (</span><span class='info'>Nikander, P., Laganier, J., and F. Dupont, &ldquo;An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID),&rdquo; April&nbsp;2007.</span><span>)</span></a>. ORCHIDs are derived from Host Identifiers
using a hash and fitting the result into an IPv6 address. Such addresses are
called Host Identity Tags (HITs) and they can be distinguished from other
IPv6 addresses with the ORCHID prefix.

</p>
<p>
Applications can observe the HIP layer and its identifiers in the
networking stacks with varying degrees of visibility. <a class='info' href='#RFC5338'>[RFC5338]<span> (</span><span class='info'>Henderson, T., Nikander, P., and M. Komu, &ldquo;Using the Host Identity Protocol with Legacy Applications,&rdquo; September&nbsp;2008.</span><span>)</span></a> discusses the lowest levels
of visibility in which applications are completely unaware of
the underlying HIP layer. Such HIP-unaware applications in some circumstances use HIP-based
identifiers, such as LSIs or HITs, instead of IPv4 or IPv6 addresses
and cannot observe the identifier-locator bindings.

</p>
<p>
This document specifies extensions to <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> to
define a new socket address family, AF_HIP. Similarly to other address
families, AF_HIP can used as an alias for PF_HIP. The extensions also
describe a new socket address structure for sockets using
HITs explicitly and describe how the socket calls
in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> are adapted or extended as a result.

</p>
<p>Some applications may accept incoming communications from any
identifier. Other applications may initiate outgoing communications
without the knowledge of the peer identifier in Opportunistic Mode (section 4.1.6 in <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a>) by just relying on a peer locator.  This
document describes how to address both situations using "wildcards"
as described later in this document.

</p>
<p>There are two related API documents. Multihoming and explicit
   locator-handling related APIs are defined in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. IPsec related policy
   attributes and channel bindings APIs are defined in <a class='info' href='#I-D.ietf-btns-c-api'>[I&#8209;D.ietf&#8209;btns&#8209;c&#8209;api]<span> (</span><span class='info'>Richardson, M., Williams, N., Komu, M., and S. Tarkoma, &ldquo;C-Bindings for IPsec Application Programming Interfaces,&rdquo; March&nbsp;2009.</span><span>)</span></a>. Most of the extensions defined in this
   document can be used independently of the two mentioned API
   documents.

</p>
<p>
The identity-locator split introduced by HIP introduces some policy
related challenges with datagram oriented sockets, opportunistic mode,
and manual bindings between HITs and locators.  The extensions in this
document are of an experimental nature and provide basic tools for
experimenting with policies. Policy related issues are left for
further experimentation.

</p>
<p>
To recap, the extensions in this document have three goals. The first goal
is to allow HIP-aware applications to open sockets to other hosts based on
the HITs alone, presuming that the underlying system can resolve the HITs
to addresses used for initial contact.  The second
goal is that applications can explicitly initiate communications
with unknown peer identifiers.  The third goal is to illustrate how
HIP-aware applications can use the SHIM API
<a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> to manually
map locators to HITs.

</p>
<a name="sec:terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The terms used in this document are summarized in <a class='info' href='#tbl:terms'>Table&nbsp;1</a>.
</p><br /><hr class="insert" />
<a name="tbl:terms"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Term</th><th align="left">Explanation</th></tr>
<tr>
<td align="left">HIP</td>
<td align="left">Host Identity Protocol</td>
</tr>
<tr>
<td align="left">HIT</td>
<td align="left">Host Identity Tag, a 100-bit hash of a public key with a 28 bit prefix</td>
</tr>
<tr>
<td align="left">LSI</td>
<td align="left">Local Scope Identifier, a local, 32-bit descriptor for a given 
          public key.</td>
</tr>
<tr>
<td align="left">Locator</td>
<td align="left">Routable IPv4 or IPv6 address used at the lower layers</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:api_overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
API Overview</h3>

<p>This section provides an overview of how the API can be used.  First,
       the case in which a resolver is involved in name resolution is
       described, and then the case in which no resolver is involved
       is described.
    
</p>
<a name="sec:resolver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Interaction with the Resolver</h3>

<p>Before an application can establish network communications with
       the entity named by a given FQDN or relative host name, the
       application must translate the name into the corresponding
       identifier(s). DNS-based hostname-to-identifier translation is
       illustrated in <a class='info' href='#fig:resolver_path'>Figure&nbsp;1</a>. The
       application calls the resolver in step (a) to resolve an FQDN
       to HIT(s). The resolver queries the DNS in step (b) to
       map the FQDN to a host identifier and locator (A and
       AAAA records). It should be noticed that the FQDN may map to
       multiple host identifiers and
       locators, and this step may involve multiple DNS transactions,
       including queries for A, AAAA, HI and possibly other resource records.
       The DNS server responds with a list of HIP resource records
       in step (c). Optionally in step (d), the
       resolver caches the HIT to locator mapping with the HIP
       module. The resolver converts the HIP records to HITs and
       returns the HITs to the application contained in
       HIP socket address structures
       in step (e). Depending on the parameters for the resolver call,
       the resolver may return also other socket address structures
       to the application.
       Finally, the application receives the socket address structure(s)
       from the resolver and uses them in socket calls such as connect()
       in step (f).
    
</p><br /><hr class="insert" />
<a name="fig:resolver_path"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                           +----------+
                                           |          |
                                           |   DNS    |
                                           |          |
                                           +----------+
                                               ^  |
                                b. QNAME=FQDN  |  | c. HIP and
                                               |  |    A/AAAA
                                               |  v    RR(s)
    +-------------+ a. getaddrinfo(&lt;FQDN&gt;)  +----------+
    |             |------------------------&gt;|          |
    | Application |                         | Resolver |
    |             |&lt;------------------------|          |
    +-------------+        e. &lt;HITs&gt;        +----------+
            |                                    |
            |                                    | d. HIP and
            | f. connect(&lt;HIT&gt;)                  |    A/AAAA
            |    or any other socket call        |    RR(s)
            v                                    v
     +----------+                           +----------+
     |          |                           |          |
     |  TCP/IP  |                           |   HIP    |
     |  Stack   |                           |          |
     +----------+                           +----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
In practice, the resolver functionality can be implemented in different
ways. For example, it may be implemented in existing resolver
libraries or as a HIP-aware interposing agent.

</p>
<a name="sec:no-resolver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Interaction without a Resolver</h3>

<p>
The extensions in this document focus on the use of the resolver to
map host names to HITs and locators in HIP-aware applications.
The resolver may implicitly associate a HIT with the corresponding
locator(s) by communicating the HIT-to-IP mapping to the
HIP daemon. However, it is possible that an application operates
directly on a peer HIT without interacting with the resolver. In
such a case, the application may resort to the system to map the peer
HIT to an IP address. Alternatively, the application can explicitly
map the HIT to an IP address using socket options as specified in <a class='info' href='#sec:explicit'>Section&nbsp;4.6<span> (</span><span class='info'>Explicit Handling of Locators</span><span>)</span></a>. Full support for all of
the extensions defined in this draft requires a number of shim socket options
<a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> to be implemented by
the system.

</p>
<a name="sec:syntax"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
API Syntax and Semantics</h3>

<p>In this section, we describe the native HIP APIs using the
       syntax of the C programming language. We limit the description
       to the interfaces and data structures that are either modified
       or completely new, because the native HIP APIs are otherwise
       identical to the sockets API <a class='info' href='#POSIX'>[POSIX]<span> (</span><span class='info'>Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -                Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</span><span>)</span></a>.
       
</p>
<a name="sec:sock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Socket Family and Address Structure Extensions</h3>

<p>The sockets API extensions define a new protocol family, PF_HIP, and
        a new address family, AF_HIP.   The AF_HIP and PF_HIP are aliases to
        each other.  These definition shall be defined as a result of including
        &lt;sys/socket.h&gt;.
</p>
<p>The use of the PF_HIP constant is mandatory with the socket()
        function when an application uses the native HIP APIs.  The
        application gives the PF_HIP constant as the first argument (domain)
        to the socket() function.  The system returns a positive integer
	representing a socket descriptor when the system supports HIP.
	Otherwise, the system returns -1 and sets errno to EAFNOSUPPORT.
</p>
<p><a class='info' href='#fig:sockaddr_hip'>Figure&nbsp;2</a> shows socket address
        structure for HIP.
</p><br /><hr class="insert" />
<a name="fig:sockaddr_hip"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        #include &lt;netinet/in.h&gt;

        typedef struct in6_addr hip_hit_t;

        struct sockaddr_hip {
                  sa_family_t    ship_family;
                  in_port_t      ship_port;
                  uint32_t       ship_pad;
                  uint64_t       ship_flags;
                  hip_hit_t      ship_hit;
                  uint8_t        ship_reserved[16];
        };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p><a class='info' href='#fig:sockaddr_hip'>Figure&nbsp;2</a> is in in 4.3BSD format.  The family of the socket, ship_family, is
       set to AF_HIP.  The port number ship_port is two octets in network byte
       order and the ship_hit is 16 octets in network byte order.
       An implementation may have extra member(s) in this structure.
</p>
<p>
        The application usually sets the ship_hit field using the
        resolver. However, the application can use three special
        constants to set a wildcard value manually into the ship_hit
        field. The constants are HIP_HIT_ANY, HIP_HIT_ANY_PUB,
        HIP_HIT_ANY_TMP and HIP_ENDPOINT_ANY. The first three equal to a
        HIT value associated with a wildcard HIT of any type, public type, or
        anonymous type. The fourth constant, HIP_ENDPOINT_ANY, denotes that
        the application accepts both HIT and any other type of addresses.
        The HIP_HIT_ANY denotes that the application accepts any type of
        HIT. The anonymous identifiers
        refer to the use of anonymous identifiers as specified in <a class='info' href='#RFC4423'>[RFC4423]<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a>. The system may designate anonymous
        identifiers as meta data associated with a HIT depending on
        whether it has been published or not. However,
        there is no difference in the classes of HITs
        from the protocol perspective.
     
</p>
<p>The application can use the HIP_HIT_ANY_* and HIP_ENDPOINT_ANY
        constants to accept incoming communications to all of the HITs of
        the local host. Incoming communications refers here to
        functions such as bind(), recvfrom() and recvmsg(). The
        HIP_HIT_* constants are similar to the sockets API constants
        INADDR_ANY and IN6ADDR_ANY_INIT, but they are applicable to HITs only.
        After initial contact with the peer, the
        application can discover the local and peer HITs
        using getsockname() and getpeername() calls in the context of
        connection oriented sockets. The difference between the use of
        the HIP_HIT_* and HIP_ENDPOINT_ANY constants here is that the former
        allows only HIP-based communications but the latter also
        allows communications without HIP.
        
</p>
<p>The application also uses the HIP_HIT_ANY constant in ship_hit
        field to establish outgoing communications in Opportunistic
        mode <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a>, i.e., when the
        application knows the remote peer locator but not the
        HIT. Outgoing communications refers here to the use of
        functions such as connect(), sendto() and sendmsg(). However,
        the application should first associate the socket with at least
        one IP address of the peer using SHIM_LOCLIST_PEER_PREF socket
        option. The use of the HIP_HIT_ANY constant guarantees that the
        communications will be based on HIP or none at all.
     
</p>
<p>The use of HIP_ENDPOINT_ANY constant in the context of outgoing
         communications is left for further experimentation in the context
         of opportunistic mode. It can result in a data flow with or
         without HIP.
      
</p>
<p>Some applications rely on system level access control, either
        implicit or explicit (such as accept_filter() function found on
        BSD-based systems), but such discussion is out of scope.
        Other applications implement access control
        themselves by using the HITs. In such a case, the application
        can compare two HITs contained in the ship_hit field using
        memcmp() or similar function. It
        should be noted that different connection attempts between
        the same two hosts can result in different HITs because a host
        is allowed to have multiple HITs.
     
</p>
<a name="sec:getaddrinfo"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Extensions to Resolver Data Structures</h3>

<p>The HIP APIs introduce a new address family, AF_HIP, that HIP
         aware applications can use to control the address type returned
         from getaddrinfo() function <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>.
         The getaddrinfo() function uses a data structure called addrinfo
         in its "hints" and "res" argument which are described in more
         detail in the next section. The addrinfo data structure is
         illustrated in <a class='info' href='#fig:addrinfo'>Figure&nbsp;3</a>.
      
</p><br /><hr class="insert" />
<a name="fig:addrinfo"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       #include &lt;netdb.h&gt;

       struct addrinfo {
           int       ai_flags;          /* e.g. AI_EXTFLAGS */
           int       ai_family;         /* e.g. AF_HIP */
           int       ai_socktype;       /* e.g. SOCK_STREAM */
           int       ai_protocol;       /* 0 or IPPROTO_HIP */
           socklen_t ai_addrlen;        /* size of *ai_addr  */
           struct    sockaddr *ai_addr; /* sockaddr_hip */
           char     *ai_canonname;     /* canon. name of the host */
           struct    addrinfo *ai_next; /* next endpoint */
           int       ai_eflags;         /* RFC5014 extension */
       };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
        An application resolving with the ai_family field set to
        AF_UNSPEC in the hints argument may receive any kind of socket
        address structures, including sockaddr_hip.  When the
        application wants to receive only HITs contained in
        sockaddr_hip structures, it should set the ai_family field to
        AF_HIP.
        Otherwise, the resolver does not return any sockaddr_hip structures.
        The resolver returns EAI_FAMILY when AF_HIP is not supported.
     
</p>
<p>The resolver ignores the AI_PASSIVE flag when the application sets the family
        in hints to AF_HIP.
     
</p>
<p>
         The system may have a HIP-aware interposing DNS agent as
         described in section 3.2 in <a class='info' href='#RFC5338'>[RFC5338]<span> (</span><span class='info'>Henderson, T., Nikander, P., and M. Komu, &ldquo;Using the Host Identity Protocol with Legacy Applications,&rdquo; September&nbsp;2008.</span><span>)</span></a>. In
         such a case, the DNS agent may, according to local policy, return
         transparently LSIs or HITs
         in sockaddr_in and sockaddr_in6 structures when available.
         A HIP-aware application can override this local policy in two ways.
         First, the application can set the family to AF_HIP in the hints
         argument of getaddrinfo() when it requests only sockaddr_hip
         structures. Second, the application can set AI_EXTFLAGS and
         AI_NO_HIT flags to prevent the resolver from returning HITs in
         any kind of data structures.
      
</p>
<p>
         When getaddrinfo() returns resolved outputs the results
         to res argument, it sets the family to AF_HIP when the related structure is
         sockaddr_hip.
      
</p>
<a name="sec:resolver_usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Resolver Usage</h3>

<p>A HIP-aware application creates the sockaddr_hip structures
	 manually or obtains them from the resolver. The explicit
	 configuration of locators is described in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. This document
	 defines "automated" resolver extensions for getaddrinfo()
	 resolver <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig:getaddrinfo"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        #include &lt;netdb.h&gt;

        int getaddrinfo(const char *nodename,
                        const char *servname,
                        const struct addrinfo *hints,
                        struct addrinfo **res)
        void free_addrinfo(struct addrinfo *res)
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>As described in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>, the getaddrinfo
           function takes the nodename, servname, and hints as its
           input arguments. It places the result of the query into the
           res output argument. The return value is zero on success, or a
           non-zero error value on error. The nodename argument
           specifies the host name to be resolved; a NULL argument
           denotes the HITs of the local host. The servname parameter
           declares the
           port number to be set in the socket addresses in the res
           output argument. Both the nodename and servname cannot be
           NULL at the same time.
</p>
<p>The input argument "hints" acts like a filter that defines
           the attributes required from the resolved endpoints. A NULL
           hints argument indicates that any kind of endpoints are
           acceptable.
</p>
<p>The output argument "res" is dynamically allocated by the
           resolver.  The application frees the res argument with the
           free_addrinfo function. The res argument contains a linked
           list of the resolved endpoints. The linked list contains
           sockaddr_hip structures only when the input argument has
           the family set to AF_HIP. When the family is zero,
           the list contains
           sockaddr_hip structures before sockaddr_in and sockaddr_in6
           structures.
        
</p>
<p>Resolver can return a HIT which maps to multiple
           locators. The resolver may cache the locator mappings with
           the HIP module. The HIP module manages the multiple
           locators according to system policies of the host.  The
           multihoming document <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> describes how
           an application can override system default policies.
        
</p>
<p>
           It should be noted that the application can
           configure the HIT explicitly without setting the locator or
           the resolver can fail to resolve any locator. In this
           scenario, the application relies on the system to map the
           HIT to an IP address. When the system fails to provide the
           mapping, it returns -1 in the called sockets API
           function to the application and sets errno to EADDRNOTAVAIL.
       
</p>
<a name="sec:getsock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
The Use of getsockname and getpeername Functions</h3>

<p>The application usually discovers the local or peer HITs from
       the sockaddr_hip structures returned by getaddrinfo(). However,
       the sockaddr_hip structure does not contain a HIT when the
       application uses the HIP_HIT_ANY_* constants. In such a case, the
       application discovers the local and peer HITs using the
       getsockname() and getpeername() functions. The functions return
       sockaddr_hip structures when the family of the socket is AF_HIP.
    
</p>
<a name="sec:sockopt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Selection of Source HIT Type</h3>

<p>
      The Socket API for Source Address Selection <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a>
      defines socket options to allow applications to influence source address
      selection mechanisms.  In some cases, HIP-aware applications may
      want to influence source HIT selection; in particular, whether
      an outbound connection should use a published or anonymous HIT.
      Similar to IPV6_ADDR_PREFERENCES defined in RFC 5014, the
      following socket option HIT_PREFERENCES is defined for
      HIP-based sockets.  This socket option can be used with
      setsockopt() and getsockopt() calls to set and get the HIT
      selection preferences affecting a HIP-enabled socket.  The
      socket option value (optval) is a 32-bit unsigned integer
      argument.  The argument consists of a number of flags where each
      flag indicates an address selection preference that modifies one
      of the rules in the default HIT selection; these flags are shown in
      <a class='info' href='#tbl:src_hit'>Table&nbsp;2</a>.
    
</p><br /><hr class="insert" />
<a name="tbl:src_hit"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Socket Option</th><th align="left">Purpose</th></tr>
<tr>
<td align="left">HIP_PREFER_SRC_HIT_TMP</td>
<td align="left">Prefer an anonymous HIT</td>
</tr>
<tr>
<td align="left">HIP_PREFER_SRC_HIT_PUBLIC</td>
<td align="left">Prefer a public HIT</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
     If the system is unable to assign the type of HIT that is
     requested, at HIT selection time, the socket call (connect (),
     sendto(), or sendmsg()) will fail and errno will be set to
     EINVAL.  If the application tries to set both of the above flags
     for the same socket, this also results in the error EINVAL.
   
</p>
<a name="sec:types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Verification of Source HIT Type</h3>

<p>An application that uses the HIP_ENDPOINT_ANY constant may want to
        check whether the actual communications was based on HIP or not.
        Also, the application may want
        to verify whether a local HIT is public or anonymous. The
        application accomplishes these using a new function called
        sockaddr_is_srcaddr() which is illustrated in <a class='info' href='#fig:sockaddr_is_srcaddr'>Figure&nbsp;5</a>.
     
</p><br /><hr class="insert" />
<a name="fig:sockaddr_is_srcaddr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      #include &lt;netinet/in.h&gt;

      short sockaddr_is_srcaddr(struct sockaddr *srcaddr,
                                uint64_t flags);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The sockaddr_is_srcaddr() function operates in the same way as
        inet6_is_srcaddr() function <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> which
        can be used to verify the type of an address belonging to the
        local host. The difference is that the sockaddr_is_srcaddr()
        function handles sockaddr_hip structures in addition to
        sockaddr_in6, and possibly some other socket structures in
        further extensions. The flags argument is also 64 bit instead
        of 32 bits because new function handles the same flags as
        defined in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> in addition to
        two HIP-specific flags,
        HIP_PREFER_SRC_HIT_TMP and HIP_PREFER_SRC_HIT_PUBLIC. With these
        two flags, the application can distinguish
        anonymous HITs from public HITs.
     
</p>
<p>When given an AF_INET6 socket, sockaddr_is_srcaddr() behaves as
        inet6_is_srcaddr() function as described in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a>.
        With AF_HIP socket, the function returns 1 when the HIT contained in the socket
        address structure corresponds to a valid HIT of the local host and
        the HIT satisfies the given flags. The function returns -1 when
        the HIT does not belong to the local host or the flags are not valid.
        The function returns 0 when the preference flags are valid but the
        HIT does not match the given flags.
     
</p>
<a name="sec:explicit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Explicit Handling of Locators</h3>

<p>
         The system resolver, or the HIP module, maps HITs to locators
         implicitly. However, some applications may want to specify
         initial locator mappings explicitly. In such a case, the
         application first creates a socket with AF_HIP as the domain
         argument. Second, the application may get or set locator information
         with one of the following shim socket options
         as defined in the multihoming extensions in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. The related socket
         options are summarized briefly in <a class='info' href='#tbl:shim'>Table&nbsp;3</a>.
         
</p><br /><hr class="insert" />
<a name="tbl:shim"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">optname</th><th align="left">description</th></tr>
<tr>
<td align="left">SHIM_LOC_LOCAL_PREF</td>
<td align="left">Get or set the preferred locator on the local side for the context
     associated with the socket.</td>
</tr>
<tr>
<td align="left">SHIM_LOC_PEER_PREF</td>
<td align="left">Get or set the preferred locator on the remote side for the context
     associated with the socket.</td>
</tr>
<tr>
<td align="left">SHIM_LOCLIST_LOCAL</td>
<td align="left">Get or set a list of locators associated with the local EID.</td>
</tr>
<tr>
<td align="left">SHIM_LOCLIST_PEER</td>
<td align="left">Get or set a list of locators associated with the peer's EID.</td>
</tr>
<tr>
<td align="left">SHIM_LOC_LOCAL_SEND</td>
<td align="left">Set or get the default source locator of outgoing IP packets.</td>
</tr>
<tr>
<td align="left">SHIM_LOC_PEER_SEND</td>
<td align="left">Set or get the default destination locator of  outgoing IP packets.</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>As an example of locator mappings, a connection-oriented
   application creates a HIP-based socket and sets the
   SHIM_LOCLIST_PEER socket option to the socket.  The HIP module uses
   the first address contained in the option if multiple are provided.
   If the application provides one or more addresses in the
   SHIM_LOCLIST_PEER setsockopt call, the system should not connect to
   the host via another destination address, in case the application
   intends to restrict the range of addresses permissible as a policy
   choice.  The application can override the default peer locator by
   setting the SHIM_LOC_PEER_PREF socket option if necessary. Finally,
   the application provides a specific HIT in the ship_hit field of
   the sockaddr_hip in the connect() system call.  If the system
   cannot reach the HIT at one of the addresses provided, the outbound
   socket API functions (connect, sendmsg, etc.)  return -1 and set
   errno to EINVALIDLOCATOR.

</p>
<p>
  Applications may also choose to associate local addresses with
  sockets.  The procedures specified in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> are followed in this
  case.

</p>
<p>
  Another use case is to use the opportunistic mode
  when the destination HIT is specified as a wildcard. The application
  sets one or more destination addresses using the
  SHIM_LOCLIST_PEER socket option as described above and then calls
  connect() with the wildcard HIT. The connect() call returns -1 and
  sets errno to EADDRNOTAVAIL when the application connects to a
  wildcard without specifying any destination address.

</p>
<p>
  Applications using datagram-oriented sockets can use ancillary data
  to control the locators. This described in detail in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Summary of New Definitions</h3>

<p>
<a class='info' href='#tbl:defs'>Table&nbsp;4</a> summarizes the new constants and
structures defined in this document.

</p><br /><hr class="insert" />
<a name="tbl:defs"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Header</th><th align="left">Definition</th></tr>
<tr>
<td align="left">&lt;sys/socket.h&gt;</td>
<td align="left">AF_HIP</td>
</tr>
<tr>
<td align="left">&lt;sys/socket.h&gt;</td>
<td align="left">PF_HIP</td>
</tr>
<tr>
<td align="left">&lt;netinet/in.h&gt;</td>
<td align="left">IPPROTO_HIP</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY_PUB</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY_TMP</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_ENDPOINT_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_PREFERENCES</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">hip_hit_t</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">AI_NO_HIT</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">sockaddr_hip</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">sockaddr_is_srcaddr</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>No IANA considerations.
</p>
<a name="sec:security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>No security considerations currently.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Contributors</h3>

<p>Thanks for Jukka Ylitalo and Pekka Nikander for their original
    contribution, time and effort to the native HIP APIs. Thanks for
    Yoshifuji Hideaki for his contributions to this document.
    
</p>
<a name="sec:acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>
    Kristian Slavov, Julien Laganier, Jaakko Kangasharju, Mika Kousa,
    Jan Melen, Andrew McGregor, Sasu Tarkoma, Lars Eggert, Joe Touch,
    Antti Jarvinen, Anthony Joseph, Teemu Koponen, Jari Arkko, Ari
    Keranen, Juha-Matti Tapio, Shinta Sugimoto, Philip Matthews,
    Joakim Koskela, Jeff Ahrenholz and Gonzalo Camarillo have also provided
    valuable ideas or
    feedback. Thanks also for the APPS area folks, including Stephane
    Bortzmeyer, Chris Newman, Tony Finch, "der Mouse" and Keith Moore.
    
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-c-api">[I-D.ietf-btns-c-api]</a></td>
<td class="author-text">Richardson, M., Williams, N., Komu, M., and S. Tarkoma, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-c-api-04.txt">C-Bindings for IPsec Application Programming Interfaces</a>,&rdquo; draft-ietf-btns-c-api-04 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-c-api-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-multihome-shim-api">[I-D.ietf-shim6-multihome-shim-api]</a></td>
<td class="author-text">Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">Socket Application Program Interface (API) for Multihoming Shim</a>,&rdquo; draft-ietf-shim6-multihome-shim-api-13 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-proto">[I-D.ietf-shim6-proto]</a></td>
<td class="author-text">Nordmark, E. and M. Bagnulo, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-proto-12.txt">Shim6: Level 3 Multihoming Shim Protocol for IPv6</a>,&rdquo; draft-ietf-shim6-proto-12 (work in progress), February&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-proto-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="POSIX">[POSIX]</a></td>
<td class="author-text">Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -
               Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3493">[RFC3493]</a></td>
<td class="author-text">Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>,&rdquo; RFC&nbsp;3493, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3493.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4423">[RFC4423]</a></td>
<td class="author-text">Moskowitz, R. and P. Nikander, &ldquo;<a href="http://tools.ietf.org/html/rfc4423">Host Identity Protocol (HIP) Architecture</a>,&rdquo; RFC&nbsp;4423, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4423.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4843">[RFC4843]</a></td>
<td class="author-text">Nikander, P., Laganier, J., and F. Dupont, &ldquo;<a href="http://tools.ietf.org/html/rfc4843">An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID)</a>,&rdquo; RFC&nbsp;4843, April&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4843.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5014">[RFC5014]</a></td>
<td class="author-text">Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;<a href="http://tools.ietf.org/html/rfc5014">IPv6 Socket API for Source Address Selection</a>,&rdquo; RFC&nbsp;5014, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5014.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5201">[RFC5201]</a></td>
<td class="author-text">Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;<a href="http://tools.ietf.org/html/rfc5201">Host Identity Protocol</a>,&rdquo; RFC&nbsp;5201, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5201.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5205">[RFC5205]</a></td>
<td class="author-text">Nikander, P. and J. Laganier, &ldquo;<a href="http://tools.ietf.org/html/rfc5205">Host Identity Protocol (HIP) Domain Name System (DNS) Extensions</a>,&rdquo; RFC&nbsp;5205, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5205.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5338">[RFC5338]</a></td>
<td class="author-text">Henderson, T., Nikander, P., and M. Komu, &ldquo;<a href="http://tools.ietf.org/html/rfc5338">Using the Host Identity Protocol with Legacy Applications</a>,&rdquo; RFC&nbsp;5338, September&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5338.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Miika Komu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki Institute for Information Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Metsanneidonkuja 4</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358503841531</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+35896949768</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:miika@iki.fi">miika@iki.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.iki.fi/miika/">http://www.iki.fi/miika/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomas Henderson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The Boeing Company</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 3707</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Seattle, WA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:thomas.r.henderson@boeing.com">thomas.r.henderson@boeing.com</a></td></tr>
</table>
</body></html>
