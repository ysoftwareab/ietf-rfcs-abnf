





Internet Draft                                                Fred Baker
Expiration: February 1999                                          Cisco
File: draft-ietf-rsvp-md5-06.txt                             Bob Lindell
                                                                 USC/ISI
                                                            Mohit Talwar
                                                                 USC/ISI


                   RSVP Cryptographic Authentication


Status of this Memo

   This document is an Internet-Draft.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress".  Comments
   should be made on the list rsvp@isi.edu.

   To view the entire list of current Internet-Drafts, please check the
   "1id-abstracts.txt" listing contained in the Internet-Drafts Shadow
   Directories on ftp.is.co.za (Africa), ftp.nordu.net (Northern
   Europe), ftp.nis.garr.it (Southern Europe), munnari.oz.au (Pacific
   Rim), ftp.ietf.org (US East Coast), or ftp.isi.edu (US West Coast).

Abstract

   This document describes the format and use of RSVP's INTEGRITY object
   to provide hop-by-hop integrity and authentication of RSVP messages.

















Baker, et. al.         Expiration: February 1999                [Page 1]




Internet Draft     RSVP Cryptographic Authentication         August 1998


1.  Introduction

   The Resource ReSerVation Protocol RSVP [1] is a protocol for setting
   up distributed state in routers and hosts, and in particular for
   reserving resources to implement integrated service.  RSVP allows
   particular users to obtain preferential access to network resources,
   under the control of an admission control mechanism.  Permission to
   make a reservation will depend both upon the availability of the
   requested resources along the path of the data, and upon satisfaction
   of policy rules.

   To protect the integrity of this admission control mechanism, RSVP
   requires the ability to protect its messages against corruption and
   spoofing.  This document defines a mechanism to protect RSVP message
   integrity hop-by-hop.  The proposed scheme transmits an
   authenticating digest of the message, computed using a secret
   Authentication Key and a keyed-hash algorithm.  This scheme provides
   protection against forgery or message modification.  The INTEGRITY
   object of each RSVP message is tagged with a one time use sequence
   number.  This allows the message receiver to identify playbacks and
   hence to thwart replay attacks.  The proposed mechanism does not
   afford confidentiality, since messages stay in the clear; however,
   the mechanism is also exportable from most countries, which would be
   impossible were a privacy algorithm to be used.  Note: this document
   uses the terms "sender" and "receiver" differently from [1].  They
   are used to refer to systems which face each other across an RSVP
   hop, the "sender" being the system generating RSVP messages.

   The message replay prevention algorithm is quite simple. The sender
   generates packets with increasing sequence numbers. In turn, the
   receiver only accepts packets which have a larger sequence number
   than the previous packet. To get this process started, a receiver
   handshakes with the sender to get a starting sequence number.  This
   memo discusses ways to relax the strictness of the in order delivery
   of messages as well as techniques to generate monotonically
   increasing sequence numbers that are robust across sender failures
   and restarts.

   The proposed mechanism is independent of a specific cryptographic
   algorithm, but the document describes the use of Keyed-Hashing for
   Message Authentication using HMAC-MD5 [8].  As noted in [8], there
   exist stronger hashes, such as HMAC-SHA1; where warranted,
   implementations will do well to make them available.  However, in the
   general case, [8] suggests that HMAC-MD5 is adequate to the purpose
   at hand and has preferable performance characteristics.  [8] also
   offers source code and test vectors for this algorithm, a boon to
   those who would test for interoperability.  HMAC-MD5 is required as a
   baseline to be universally included in RSVP implementations providing



Baker, et. al.         Expiration: February 1999                [Page 2]




Internet Draft     RSVP Cryptographic Authentication         August 1998


   cryptographic authentication, with other proposals optional (see the
   section on Conformance Requirements below).

   The RSVP checksum may be disabled (set to zero) if HMAC-MD5
   authentication is used, as the HMAC-MD5 digest is a much stronger
   integrity check.

   Two uses are envisioned for INTEGRITY objects: authentication of RSVP
   messages (or message fragments, should a fragmentation procedure be
   defined in the future), and authentication of policy data objects
   [10].  The INTEGRITY object used in both is the same, and is defined
   in this document.  The use of the INTEGRITY object for those purposes
   is defined in other documents [1] [7].

1.1.  Conventions used in this document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [9].

1.2.  Why not use the Standard IPSEC Authentication Header?

   One obvious question is why, since there exists a standard mechanism,
   IPSEC, for authentication [5], we would choose not to use it.  This
   was discussed at length in the working group, and the use of IPSEC
   was rejected for the following reasons.

   The security associations in IPSEC are based on destination address.
   It is not clear that RSVP messages are well defined for either source
   or destination based security associations, as a router must forward
   PATH and PATH TEAR messages using the same source address as the
   sender listed in the SENDER TEMPLATE. RSVP traffic may otherwise not
   follow exactly the same path as data traffic.  Using either source or
   destination based associations would require opening a new security
   association among the routers that a flow traverses for each flow
   making reservations.

   In addition, it was noted that neighbor relationships between RSVP
   systems are not limited to those which face one another across a
   communication channel. RSVP relationships across non-RSVP clouds,
   such as those described in section 2.8 of [1], are not necessarily
   visible to the sending system, suggesting that key management based
   on RSVP router to RSVP router associations may allow a simpler key
   management strategy.

2.  Data Structures





Baker, et. al.         Expiration: February 1999                [Page 3]




Internet Draft     RSVP Cryptographic Authentication         August 1998


2.1.  INTEGRITY Object Format

   An RSVP Message consists of a sequence of "objects," which are type-
   length-value encoded fields having specific purposes.  The
   information required for hop-by-hop integrity checking is carried in
   an INTEGRITY object. The same INTEGRITY object type is used for both
   IPv4 and IPv6.

   The contents of an INTEGRITY object are defined as a "Keyed Message
   Digest" structure, with the following format:

             Keyed Message Digest INTEGRITY Object: Class = 4,
                                C-Type = 1

         +-------------+-------------+-------------+-------------+
         |                    Key Identifier                     |
         |                                                       |
         +-------------+-------------+-------------+-------------+
         |                    Sequence Number                    |
         |                                                       |
         +-------------+-------------+-------------+-------------+
         |                                                       |
         +                                                       +
         |                                                       |
         +                  Keyed Message Digest                 |
         |                                                       |
         +                                                       +
         |                                                       |
         +-------------+-------------+-------------+-------------+


   (1)  Key Identifier

           An unsigned 64-bit number that acts as a key selector.  With
           the key, the system stores an algorithm for its application.
           Senders SHOULD pick globally unique key identifiers.  This
           can be accomplished by using an IP address, a hash of an IP
           address, or a globally unique MAC address concatenated with a
           key number.

   (2)  Sequence Number

           An unsigned 64-bit monotonically increasing, unique sequence
           number.

           Any monotonically increasing sequence of numbers, that
           provides the INTEGRITY object of each RSVP message with a
           unique tag, may be used as Sequence Number values.  Details



Baker, et. al.         Expiration: February 1999                [Page 4]




Internet Draft     RSVP Cryptographic Authentication         August 1998


           on sequence number generation are presented in the next
           section.

   (3)  Keyed Message Digest

           The digest must be a multiple of 4 octets long.  For HMAC-
           MD5, it will be 16 bytes long.

3.  Generating Sequence Numbers

   In this section we describe methods which could be chosen to generate
   the sequence numbers used in the INTEGRITY object of an RSVP message.
   As previous stated, there are two important properties that MUST be
   satisfied by the generation procedure.  The first property is that
   the sequence numbers are unique, or one time, for the lifetime of the
   integrity key that is in current use.  A receiver can use this
   property to unambiguously distinguish between a new or a replayed
   message.  The second property is that the sequence numbers are
   generated in monotonically increasing order.  This is required to
   greatly simplify the message processing rules, since a receiver only
   needs to save the value of the highest sequence number seen to avoid
   a replay attack.

   The size of the sequence number field is chosen to be a 64-bit
   unsigned quantity.  This is large enough to avoid exhaustion over the
   key lifetime.  For example, if a key lifetime was conservatively
   defined as one year, there would be enough sequence number values to
   send RSVP messages at an average rate of about 585 gigaMessages per
   second.  A 32-bit sequence number would limit this average rate to
   about 136 messages per second.

   The ability to generate unique monotonically increasing sequence
   numbers across a failure and restart implies some form of stable
   storage, either local to the device or remotely over the network.
   Three state-based sequence number generation procedures are described
   below.

3.1.  Simple Sequence Numbers

   The most straight forward approach would be to generate a unique
   sequence number using a message counter.  Each time a message is
   transmitted for a given key, the sequence number counter is
   incremented.  The current value of this counter is continually or
   periodically saved to stable storage.  Recovery of this counter after
   a restart is accomplished by using this stable storage.  If the
   counter was saved periodically to stable storage, the count should be
   recovered by increasing the saved value to be larger than any
   possible value of the counter at the time of the failure.  This can



Baker, et. al.         Expiration: February 1999                [Page 5]




Internet Draft     RSVP Cryptographic Authentication         August 1998


   be computed knowing the interval at which the counter was saved to
   stable storage and incrementing the stored value by that amount.

3.2.  Sequence Numbers Based on a Real Time Clock

   Most devices will probably not have the capability to save sequence
   number counters to stable storage for each key.  A more universal
   solution is to base sequence numbers on the stable storage of a real
   time clock.  Many computing devices have a real time clock module
   that includes stable storage of the clock.  These modules generally
   include some form of nonvolatile memory to retain clock information
   in the event of a power failure.

   In this approach, we use an NTP based timestamp value as the sequence
   number.  The rollover period of an NTP timestamp is about 136 years,
   much longer than any reasonable lifetime of a key.  In addition, the
   granularity of the NTP timestamp is fine enough to allow the
   generation of an RSVP message every 200 picoseconds for a given key.
   Many real time clock modules do not have the resolution of an NTP
   timestamp.  In these cases, the least significant bits of the
   timestamp can be generated using a message counter, which is reset
   every clock tick.  For example, when the real time clock provides a
   resolution of 1 second, the 32 least significant bits of the sequence
   number can be generated using a message counter.  The remaining 32
   bits are filled with the 32 least significant bits of the timestamp.
   Assuming that the recovery time after failure takes longer than one
   tick of the real time clock, the message counter for the low order
   bits can be reset to zero.

3.3.  Sequence Numbers Based on a Network Recovered Clock

   If the device does not contain any stable storage, it could recover
   the real time clock from the network using NTP.  Once the clock has
   been recovered, following a restart, the sequence number generation
   procedure would be identical to the procedure described in section
   6.2.

3.4.  Sequence Number Wraparound

   Sequence numbers might roll over within some key's lifetime. To
   accomodate this behavior, each receiver MUST accept monotonically
   increasing sequence numbers, modulo 2^64.  In addition, we assume
   that a key's lifetime is short enough for the key to expire within
   half the sequence number space.  With this assumption, receivers MUST
   reject sequence numbers which lie in the wrong half of the sequence
   number space.  This solution draws directly from the TCP sequence
   number algorithm [11].




Baker, et. al.         Expiration: February 1999                [Page 6]




Internet Draft     RSVP Cryptographic Authentication         August 1998


4.  Message Processing Rules

4.1.  Message Generation

   An RSVP message is created as specified in [1], with these
   exceptions:

   (1)  The RSVP checksum field is set to zero.  If required, an RSVP
        checksum can be calculated after step (7), when the processing
        of the INTEGRITY object is complete.

   (2)  The INTEGRITY object is inserted in the appropriate place, and
        its location in the message is remembered for later use.

   (3)  The current sequence number must be updated, if required, to
        ensure a unique, monotonically increasing number.  It is then
        placed in the Sequence Number field of the INTEGRITY object.

   (4)  The Keyed Message Digest field is set to zero.

   (5)  The Key Identifier is placed into the INTEGRITY object.

   (6)  An authenticating digest of the is computed using the
        appropriate Authentication Key in  conjunction with the keyed-
        hash algorithm. When the HMAC-MD5 algorithm is used, the hash
        calculation is described in [8].

   (7)  The digest is written into the Cryptographic Digest field of the
        INTEGRITY object.

   In the sender, Authentication Key selection is based on the interface
   through which the message is sent, there being a key configured per
   interface.  While administrations may configure all the routers and
   hosts on a subnet (or for that matter, in their network) with the
   same key, implementations MUST assume that each sender may send with
   a different key on each interface (be it numbered or unnumbered), and
   that the keys are simplex - the key that a system uses to sign its
   messages need not be same key that its receivers use to sign theirs.
   Implementations SHOULD maintain a separate key per interface they
   send on.  User interfaces SHOULD provide convenient ways to configure
   these keys.

   An RSVP router may have unnumbered interfaces which carry a common IP
   address but distinct Logical Interface Handles (LIHs) for RSVP. In
   these cases, an implementation SHOULD maintain a separate key per
   LIH.  In addition, Key Identifier values should be formed using some
   combination of the common IP address, the LIH, and the key number in
   an attempt to produce a global unique value.



Baker, et. al.         Expiration: February 1999                [Page 7]




Internet Draft     RSVP Cryptographic Authentication         August 1998


4.2.  Message Reception

   When the message is received, the process is reversed:

   (1)  The RSVP checksum field is set to zero.

   (2)  The Cryptographic Digest field of the INTEGRITY object is set
        aside.

   (3)  The Key Identifier field is used to determine the Authentication
        Key and the hash algorithm to be used.  In the rare event that
        the key identifier is not unique, each matching Authentication
        Key and associated hash algorithm is applied in an attempt to
        find a match.

   (4)  The sequence number is validated to prevent replay attacks, and
        messages with invalid sequence numbers are ignored by the
        receiver.

        Every time a message is accepted, the sequence number of that
        message updates the stored value corresponding to the largest
        sequence number received to date.  Each subsequent message must
        have a larger sequence number to be accepted (see section 3.4).
        This simple processing rule prevents message replay attacks, it
        must be modified to be tolerant to limited out of order message
        delivery.

        If several messages were sent simultaneously (for example, in a
        periodic refresh generated by a router, or as a result of a tear
        down function), a reordering problem might arise either due to
        the use of CBQ/WFQ queuing algorithms in the sender, or due to
        reordering in an intervening non-RSVP cloud.  Therefore, the
        sequence number received may not be higher than the number last
        seen.

        An implementation SHOULD allow administrative configuration
        which sets the tolerance to out of order message delivery.  A
        simple approach would allow administrators to specify a message
        window corresponding to the worst case reordering behavior.  For
        example, one might specify that packets reordered within a 32
        message window would be accepted.  If no reordering can occur,
        the window is set to one.  Since sequence numbers might not be
        strictly sequential, it is necessary to store a list of all
        sequence numbers seen during the reordering window.  Acceptance
        of a sequence number implies adding it to the list and removing
        a number from the lower end of the list.

        A received sequence number is valid if (a) it is greater than



Baker, et. al.         Expiration: February 1999                [Page 8]




Internet Draft     RSVP Cryptographic Authentication         August 1998


        the maximum sequence number received as yet or (b) a past
        sequence number lying within the reordering window and not
        recorded in the list.  Messages received with sequence numbers
        lying below the lower end of the window or marked seen in the
        list are silently discarded.

   (5)  The Cryptographic Digest field of the INTEGRITY object is set to
        zero.

   (6)  A new keyed-digest is calculated using the indicated algorithm
        and the Authentication Key.

   (7)  If the calculated digest does not match the received digest, the
        message is discarded without further processing.


4.3.  Handshake at Restart or Initialization of the Receiver

   During initialization or restart, a receiver must obtain a starting
   sequence number for a sender whose messages require an integrity
   check.  The receiver SHOULD initiate a handshake with the sender to
   attain this information.

   An RSVP capable device challenges another device with an RSVP
   handshake message containing a unique sequence number generated by
   the standard methods outlined earlier.  The remote device receives
   the challenge and returns an INTEGRITY-checked RSVP handshake message
   which contains the original sequence number.  The response is
   accepted only if the original sequence number matches the returned
   sequence number in the message.  This prevents replay of old
   handshake responses.  If the sequence number matches, the device
   saves the remote sequence number from the INTEGRITY object, along
   with the key for the remote device.  If a response is not received
   within a given period of time, the challenge is repeated.  When the
   handshake is successfully completed, a device will begin accepting
   normal RSVP signaling messages from that sender and ignore any other
   handshake responses.

   An RSVP handshake message will carry a message type of 11.  The
   message format is as follows:

   <INTEGRITY Handshake message> ::= <Common Header> [ <INTEGRITY> ]
   <CHALLENGE>

   The contents of a CHALLENGE object is defined with the following
   format:





Baker, et. al.         Expiration: February 1999                [Page 9]




Internet Draft     RSVP Cryptographic Authentication         August 1998



                       CHALLENGE Object: Class = 16,
                                C-Type = 1

         +-------------+-------------+-------------+-------------+
         |                    Sequence Number                    |
         |                                                       |
         +-------------+-------------+-------------+-------------+

   The use of a handshake may not be necessary in all environments.  A
   common use of RSVP integrity will be between peering domain routers,
   which are likely to be processing a steady stream of RSVP messages
   due to aggregation effects.  If a router crashes and restarts, there
   will probably be valid RSVP messages from peering senders arriving
   within a short duration of restart.  Assuming that replay messages
   are injected into the stream of valid RSVP messages, there may only
   be a small window of opportunity for a replay attack before a valid
   message is processed.  This valid message will set the largest
   sequence number seen to a value greater than any number that had been
   stored prior to the crash, preventing any further replays.

   On the other hand, not using a handshake could allow exposure to
   replay attacks if there is a long period of silence from a given
   sender following a restart of a receiver.  It SHOULD be an
   administrative decision whether or not a handshake is performed.
   That decision will be based on assumptions related to a particular
   network environment.

5.  Key Management

   It is likely that the IETF will define a standard key management
   protocol.  It is strongly desirable to use that key management
   protocol to distribute RSVP Authentication Keys among communicating
   RSVP implementations.  Such a protocol would provide scalability and
   significantly reduce the human administrative burden.  The Key ID can
   be used as a hook between RSVP and such a future protocol.  Key
   management protocols have a long history of subtle flaws that are
   often discovered long after the protocol was first described in
   public.  To avoid having to change all RSVP implementations should
   such a flaw be discovered, integrated key management protocol
   techniques were deliberately omitted from this specification.

5.1.  Key Management Procedures

   Each key has a lifetime associated with it.  In general, no key is
   ever used outside its lifetime (but see section 5.3).  If more than
   one key is currently alive, then the youngest key (the key whose
   lifetime most recently started) should be sent.



Baker, et. al.         Expiration: February 1999               [Page 10]




Internet Draft     RSVP Cryptographic Authentication         August 1998


   Possible mechanisms for managing key lifetime include: the use of the
   Network Time Protocol, hardware time-of-day clocks, or waiting some
   time before emitting the first message to determine what key other
   systems are signing with.  The matter is left for the implementor.
   Note that the concept of a "key lifetime" does not require a hardware
   time-of-day clock or the use of NTP, although one or the other is
   advised; it merely requires that the earliest and latest times that
   the key is valid must be programmable in a way the system
   understands.

   To maintain security, it is advisable to change the RSVP
   Authentication Key on a regular basis.  It should be possible to
   switch the RSVP Authentication Key without loss of RSVP state or
   denial of reservation service, and without requiring people to change
   all the keys at once.  This requires the RSVP implementation to
   support the storage and use of more than one RSVP Authentication Key
   on a given interface at the same time.

   For each key there will be a locally-stored Key Identifier.  The
   combination of the Key Identifier and the interface associated with
   the message identifies the cryptographic algorithm and Authentication
   Key in use by RSVP.  As noted above, the sender will select a valid
   key from the set of valid keys for that interface.  The receiver will
   use the Key Identifier to determine which key to use for
   authentication of the received message.  More than one key may be
   associated with an interface at the same time.

   To ensure a smooth switch-over, each communicating RSVP system must
   be updated with the new key before the current key will expire and
   before the new key lifetime begins.  The new key should have a
   lifetime that starts several minutes before the old key expires.
   This gives time for each system to learn of the new RSVP
   Authentication Key before that key will be used.  It also ensures
   that at the time that the current key's lifetime has expired, all
   systems have prepared to send and receive data using the new key.
   For the duration of the overlap in key lifetimes, a system may
   receive messages using either key and authenticate the message.

   There are four important times for each key:

     + KeyStartReceive: the time the system starts accepting received
        packets signed with the key.

     + KeyStartSign: the time the system starts signing packets with the
        key.

     + KeyStopSign: the time the system stops signing packets with the
        key, which implies that it starts signing with the next key, if



Baker, et. al.         Expiration: February 1999               [Page 11]




Internet Draft     RSVP Cryptographic Authentication         August 1998


        any.

     + KeyStopReceive: the time the system stops accepting received
        packets signed with the key.

   The times in the order listed SHOULD form a non-decreasing sequence.
   There needs to be some distance between start times and stop times,
   to achieve a seamless transition.

5.2.  Key Management Requirements

   Requirements on an implementation are as follows.

   (1)  It is strongly desirable that a hypothetical security breach in
        one Internet protocol not automatically compromise other
        Internet protocols.  The Authentication Key of this
        specification SHOULD NOT be stored using protocols or algorithms
        that have known flaws.

   (2)  An implementation MUST support the storage of more than one key
        at the same time, although normally only one key will be active
        on an interface.

   (3)  An implementation MUST associate a specific lifetime (i.e.,
        KeyStartSign and KeyStopSign) with each key and corresponding
        Key Identifier.

   (4)  An implementation MUST support manual key distribution (e.g.,
        the privileged user manually typing in the key, key lifetime,
        and key identifier on the console).  The lifetime may be
        infinite.

   (5)  If more than one algorithm is supported, then the implementation
        MUST require that the algorithm be specified for each key at the
        time the other key information is entered.

   (6)  Keys that are out of date MAY be deleted at will by the
        implementation without requiring human intervention.

   (7)  Manual deletion of active keys SHOULD also be supported.

   (8)  Key storage SHOULD persist across a system restart, warm or
        cold, to avoid operational issues.

5.3.  Pathological Cases

   An implementation of this document must handle two pathological
   cases.  Both of these should be exceedingly rare.



Baker, et. al.         Expiration: February 1999               [Page 12]




Internet Draft     RSVP Cryptographic Authentication         August 1998


   (1)  During key switch-over, devices may exist which have not yet
        been successfully configured with the new key.

        If a key is shared with multiple receivers, there is a region of
        uncertainty around the time of key switch-over during which some
        receivers may still be using the old key and others have
        switched to the new key.  The size of this uncertainity region
        is related to clock synchrony of the receivers.  Administrators
        should configure the overlap between the expiration time of the
        old key (KeyStopReceive) and the validity of the new key
        (KeyStartReceive) to be at least twice the size of this
        uncertainity interval. This will allow a sender to make the key
        switch-over at the midpoint of this interval and be confident
        that all receivers are now accepting the new key.

   (2)  It is possible that the last key associated with an interface
        may expire.

        When this happens, it is unacceptable to revert to an
        unauthenticated condition, and not advisable to disrupt current
        reservations.  Therefore, the system should send a "last
        authentication key expiration" notification to the network
        manager and treat the key as having an infinite lifetime until
        the lifetime is extended, the key is deleted by network
        management, or a new key is configured.

6.  Conformance Requirements

   To conform to this specification, an implementation MUST support all
   of its aspects.  The HMAC-MD5 authentication algorithm defined in [8]
   MUST be implemented by all conforming implementations.  A conforming
   implementation MAY also support other authentication algorithms such
   as NIST's Secure Hash Algorithm (SHA).  Manual key distribution as
   described above MUST be supported by all conforming implementations.
   All implementations MUST support the smooth key roll over described
   under "Key Change Procedures."

   The user documentation provided with the implementation MUST contain
   clear instructions on how to ensure that smooth key roll over occurs.

   Implementations SHOULD support a standard key management protocol for
   secure distribution of RSVP Authentication Keys once such a key
   management protocol is standardized by the IETF.

7.  Acknowledgments

   This document is derived directly from similar work done for OSPF and
   RIP Version II, jointly by Ran Atkinson and Fred Baker.  Significant



Baker, et. al.         Expiration: February 1999               [Page 13]




Internet Draft     RSVP Cryptographic Authentication         August 1998


   editing was done by Bob Braden, resulting in increased clarity.  (if
   you think this document was hard to read, think about what Bob read).
   Significant comments were submitted by Steve Bellovin, who actually
   understands this stuff.  Matt Crawford and Dan Harkins helped revise
   the document.

8.  References

   [1]  Braden, R., Ed., Zhang, L., Estrin, D., Herzog, S., and S.
        Jamin, "Resource ReSerVation Protocol (RSVP) -- Version 1
        Functional Specification".  Internet Draft draft-ietf-rsvp-
        spec-14.ps, January 1997.

   [2]  S.  Bellovin, "Security Problems in the TCP/IP Protocol Suite",
        ACM Computer Communications Review, Volume 19, Number 2, pp.32-
        48, April 1989.

   [3]  N.  Haller, R.  Atkinson, "Internet Authentication Guidelines",
        Request for Comments 1704, October 1994.

   [4]  R.  Braden, D.  Clark, S.  Crocker, & C.  Huitema, "Report of
        IAB Workshop on Security in the Internet Architecture", Request
        for Comments 1636, June 1994.

   [5]  R.  Atkinson, "IP Authentication Header", Request for Comments
        1826, August 1995.

   [6]  R.  Atkinson, "IP Encapsulating Security Payload", Request for
        Comments 1827, August 1995.

   [7]  S.  Herzog, "RSVP Extensions for Policy Control", draft-ietf-
        rsvp-policy-ext-02.txt, March 1997.

   [8]  Krawczyk, Bellare, and Canetti, "HMAC: Keyed-Hashing for Message
        Authentication", Request for Comments 2104, March 1996.

   [9]  [RFC-2119], Bradner, S., "Key words for use in RFCs to Indicate
        Requirement Levels", RFC 2119, Harvard University, March 1997.

   [10] R.  Yavatkar, D. Pendarakis, R.  Guerin, "A Framework for
        Policy-based Admission Control", draft-ietf-rap-framework-00.txt
        November 1997.

   [11] Postel, Jon, "Transmission Control Protocol", Request for
        Comments 793, September 1981.






Baker, et. al.         Expiration: February 1999               [Page 14]




Internet Draft     RSVP Cryptographic Authentication         August 1998


9.  Security Considerations

   This entire memo describes and specifies an authentication mechanism
   for RSVP that is believed to be secure against active and passive
   attacks.  Passive attacks are widespread in the Internet at present.
   Protection against active attacks is also needed even though such
   attacks are not as widespread.

   Users need to understand that the quality of the security provided by
   this mechanism depends completely on the strength of the implemented
   authentication algorithms, the strength of the key being used, and
   the correct implementation of the security mechanism in all
   communicating RSVP implementations.  This mechanism also depends on
   the RSVP Authentication Keys being kept confidential by all parties.
   If any of these assumptions are incorrect or procedures are
   insufficiently secure, then no real security will be provided to the
   users of this mechanism.

   While the handshake response is required to be INTEGRITY-checked, the
   handshake challenge is not.  This was done intentionally to eliminate
   a dependency on an integrity key in the opposite direction.

   Hence an intruder could generate fake handshaking challenges with a
   certain sequence number.  It could then save the response and attempt
   to play it against a receiver that is in recovery. If it was lucky
   enough to have guessed the sequence number used by the receiver at
   recovery time it could use the saved response.  This response would
   be accepted, since it is properly signed, and would have a smaller
   sequence number for the sender because it was an old message. This
   opens the receiver up to replays.

   This seems very difficult to exploit.  Not only does it require
   guessing the challenge sequence number in advance, but also being
   able to masquerade as the receiver to generated a handshake request
   with the proper IP address and not being caught.  Moreover, since
   messages flow back and forth there might be keys in both directions.
   In such cases the receiver can also sign its challenge for the sender
   to authenticate and cover this attack.

   Confidentiality is not provided by this mechanism; if this is
   required, IPSEC ESP [6] may be the best approach, although it is
   subject to the same criticisms as IPSEC Authentication, and therefore
   would be applicable only in specific environments.  Protection
   against traffic analysis is also not provided.  Mechanisms such as
   bulk link encryption might be used when protection against traffic
   analysis is required.





Baker, et. al.         Expiration: February 1999               [Page 15]




Internet Draft     RSVP Cryptographic Authentication         August 1998


10.  Authors' Addresses

        Fred Baker
        Cisco Systems
        519 Lado Drive
        Santa Barbara,
        California 93111
        Phone: (408) 526-4257
        Email: fred@cisco.com

        Bob Lindell
        USC Information Sciences Institute
        4676 Admiralty Way
        Marina del Rey, CA 90292
        Phone: (310) 822-1511
        EMail: lindell@ISI.EDU

        Mohit Talwar
        USC Information Sciences Institute
        4676 Admiralty Way
        Marina del Rey, CA 90292
        Phone: (310) 822-1511
        EMail: mtalwar@ISI.EDU




























Baker, et. al.         Expiration: February 1999               [Page 16]

