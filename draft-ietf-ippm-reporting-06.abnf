reordering_max = max;
reordering_m = calloc(reordering_max, sizeof(uint64_t));
reordering_ring = calloc(reordering_max, sizeof(uint64_t));
r = (r + 1) % reordering_max;
bitfield_len = ((npackets % 64)?
                       (npackets / 64 + 1) : npackets / 64);
bitfield = calloc(bitfield_len, sizeof(uint64_t));
bitfield_sec = packet_sqn >> 6;

bitfield_bit = (uint64_t)1 << (packet_sqn & 63);

k = min(k, n-k);

bc = 1;
m = max(k, n-k);

bc = (bc * (m + i)) / i;
qp_out = qp_out->next) {
offset = (weight + 1) / 2;
offset = weight / 2;
offset = (weight + 2)/ 2;
next_pos = offset - 1;

min_dbl = DBL_MAX;
qp = qp->next) {
min_dbl = min(min_dbl, qp->buffer[qp->pos]);
qp = qp->next) {
qp = qp->next) */
min_level = quantile_buffer_head[seq]->level;
min_level = min(min_level, qp->level);
rc = quantile_collapse(seq, min_level);
qp = qp->next) {
rc = quantile_new(seq, qp, input, k, min_level);
qp = qp->next) {
rc = quantile_new(seq, qp, input, k, 0);
rc = quantile_new(seq, qp, input, quantile_k[seq], 0);
rc = quantile_new(seq, qp2, input + quantile_k[seq],
                                 k - quantile_k[seq], 0);
qp = malloc(sizeof(quantile_t));
qp = qp->next;
quantile_max_seq = max_seq;
quantile_k = calloc(max_seq, sizeof(int));
quantile_input = calloc(max_seq, sizeof(double*));
quantile_input_cnt = calloc(max_seq, sizeof(int));
quantile_empty_buffers = calloc(max_seq, sizeof(int));
quantile_b = calloc(max_seq, sizeof(int));
quantile_buf = calloc(max_seq, sizeof(double*));
quantile_alternate = calloc(max_seq, sizeof(int));
quantile_inf_cnt = calloc(max_seq, sizeof(uint64_t));
quantile_buffer_head = calloc(max_seq, sizeof(quantile_t*));

h_max = h;
k = ceil(N / (double)binomial(b+h_max-2, h_max-1));

b_tmp = b;
k_tmp = k;
b_tmp = b;
k_tmp = k;
rc = quantile_init_seq(seq);
rc = quantile_algorithm(seq, quantile_input[seq],
                                       quantile_input_cnt[seq]);
rc = quantile_algorithm(seq, quantile_input[seq],
                                       quantile_input_cnt[seq]);
rc = quantile_algorithm(seq, quantile_input[seq],
                                   quantile_input_cnt[seq]);
qp = quantile_buffer_head[seq];
next = qp->next;

qp = next;
beta = 1 + quantile_inf_cnt[seq] / (double)npackets;
phi2 = (2 * phi + beta - 1) / (2 * beta);

next_pos = ceil(phi2 * quantile_k[seq] * weight);
min_dbl = DBL_MAX;
qp = qp->next) {
min_dbl = min(min_dbl, qp->buffer[qp->pos]);
qp = qp->next) {
rc = duplication_init(max_packets);
rc = quantile_init(1, QUANTILE_EPS, max_packets);
rc = reordering_init(reordering_max);
sf = fopen(argv[1],"r");
rc = quantile_value_checkin(0, packet_delay[i]);
rc = quantile_finish(0);
rc = quantile_output(0, unique_packets, 0.25, &quantile_25);
rc2 = quantile_output(0, unique_packets, 0.50, &quantile_50);
rc3 = quantile_output(0, unique_packets, 0.75, &quantile_75);
packet_loss = packets_sent > unique_packets?
           (100.0*(packets_sent - unique_packets))/packets_sent: 0;
delay = (packet_loss > 50.0)? INFINITY : quantile_50;
jitter = quantile_75 - quantile_25;
jitter = NAN;
jitter = INFINITY;
