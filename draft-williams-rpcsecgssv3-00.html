<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Remote Procedure Call (RPC) Security Version 3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Remote Procedure Call (RPC) Security Version 3">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">NETWORK WORKING GROUP</td><td class="header">N. Williams</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Sun</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">January 13, 2009</td></tr>
<tr><td class="header">Expires: July 17, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Remote Procedure Call (RPC) Security Version 3<br />draft-williams-rpcsecgssv3-00.txt</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on July 17, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document specifies version 3 of the Remote
		Procedure Call (RPC) security protocol (RPCSEC_GSS).
		This protocol provides for: compound authentication of
		client hosts and users to server (constructed by generic
		composition), channel binding, security label assertions
		for multi-level and type enforcement, privilege
		assertions and identity assertions.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">1.1.</a>&nbsp;
Motivation<br />
<a href="#anchor2">1.2.</a>&nbsp;
Applications of RPCSEC_GSSv3<br />
<a href="#anchor3">1.3.</a>&nbsp;
Conventions used in this document<br />
<a href="#v3">2.</a>&nbsp;
The RPCSEC_GSSv3 protocol<br />
<a href="#anchor4">2.1.</a>&nbsp;
Control messages<br />
<a href="#anchor5">2.1.1.</a>&nbsp;
New auth_stat values<br />
<a href="#anchor6">2.1.2.</a>&nbsp;
Create request<br />
<a href="#anchor13">2.1.3.</a>&nbsp;
Context handle destruction<br />
<a href="#anchor14">2.1.4.</a>&nbsp;
List request<br />
<a href="#anchor15">2.1.5.</a>&nbsp;
Extensibility<br />
<a href="#anchor16">3.</a>&nbsp;
Privileges and identity representation for
	    NFSv4<br />
<a href="#anchor17">4.</a>&nbsp;
Security Considerations<br />
<a href="#anchor18">5.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">6.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The original RPCSEC_GSS protocol <a class='info' href='#RFC2203'>[RFC2203]<span> (</span><span class='info'>Eisler, M., Chiu, A., and L. Ling, &ldquo;RPCSEC_GSS Protocol Specification,&rdquo; September&nbsp;1997.</span><span>)</span></a>
		provided for authentication of RPC clients and servers
		to each other using the Generic Security Services
		Application Programming Interface (GSS-API) <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a>.  The second version of
		RPCSEC_GSS [add ref.] added support for channel binding
		<a class='info' href='#RFC5056'>[RFC5056]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; November&nbsp;2007.</span><span>)</span></a>.
</p>
<p>We find that GSS-API mechanisms are insufficient for
		communicating certain aspects of a client's identity and
		authority to a server.  The GSS-API and its mechanisms
		certainly could be extended to address this
		shortcomming, but it seems be far simpler to address it
		at the application layer, namely, in this case,
		RPCSEC_GSS.
</p>
<p>We therefore provide a new version of RPCSEC_GSS that
		allows for the following:

		</p>
<ul class="text">
<li>compound authentication of the client host and
			user to the server (done by binding of two
			RPCSEC_GSS handles)
</li>
<li>channel binding (even though RPCSEC_GSSv2
			provides this also; see below)
</li>
<li>client-side assertions of authority:
			
<ul class="text">
<li>security labels (for multi-level, type
				enforcement, and other labeled security
				models) [add refs. for labeled
				security]
</li>
<li>application-specific privileges
</li>
</ul>
		    
</li>
<li>client-side assertions of identity:
			
<ul class="text">
<li>primary client/user identity
</li>
<li>supplementary group memberships of the
				client/user, including support for
				specifying deltas to the membership list
				as seen on the server
</li>
</ul>
		    
</li>
</ul><p>
	    
</p>
<p>Assertions of labels, privilege and identity are
		evaluated by the server, which may then map the asserted
		values to other values, all according to server-side
		policy.
</p>
<p>We also add an option for enumerating server-side domains
		of interpretation (DOI), though this seems likely to be
		unnecessary.
</p>
<p>RPCSEC_GSSv3 is patterned as follows:

		</p>
<ul class="text">
<li>a client uses an existing RPCSEC_GSS context
			handle (of any RPCSEC_GSS version) to protect
			RPCSEC_GSSv3 exchanges (this will be termed the
		        "parent" or "outer" handle)
</li>
<li>the server issues a "child" RPCSEC_GSSv3 handle,
			but the underlying GSS-API security context for
			the parent handle is used in all subsequent
			exchanges using the child handle (this works
			because the RPCSEC_GSS handle is included in the
			integrity protected RPCSEC_GSS auth/verifier
			header for all versions of RPCSEC_GSS)
</li>
</ul><p>

		<br />
<br />


		This means that RPCSEC_GSSv3 depends on RPCSEC_GSS
		versions 1 and/or 2 for actual GSS-API security context
		establishment.  This keeps the specification of
		RPCSEC_GSSv3 simple by avoiding the need to duplicate
		the core functionality of RPCSEC_GSS version 1.
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Motivation</h3>

<p>The initial motivation for RPCSEC_GSSv3 is to add
		    support for labeled security.  Several alternatives
		    to revising RPCSEC_GSS were considered:

		    </p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>application-level protocol extensions, such
			    as new operations for the Network File
			    System version 4 (NFSv4)
			    protocol <a class='info' href='#RFC3530'>[RFC3530]<span> (</span><span class='info'>Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &ldquo;Network File System (NFS) version 4 Protocol,&rdquo; April&nbsp;2003.</span><span>)</span></a>;
</dd>
<dt>b.</dt>
<dd>a stackable GSS-API pseudo-mechanism that
			    could be composed with concrete GSS-API
			    mechanisms to provide both, authentication
			    and protected security label assertions;
</dd>
<dt>c.</dt>
<dd>per-GSS-API mechanism extensions for
			    transporting security label assertions;
</dd>
</dl></blockquote><p>
		
</p>
<p>Alternative (c) is not sufficiently general.  One
		    possible benefit of (c) might be the ability to have
		    per-{user, label} credentials, though that might be
		    difficult to manage (and, anyways, can be emulated
		    with regular GSS-API mechanisms through principal
		    naming conventions), whereas with the other
		    approaches there is a single credential per-user
		    that can be used to assert multiple security
		    labels.
</p>
<p>Alternative (a) is not general either, though for the
		    purpose of the NFSv4 community it would suffice.
		    However, a solution at the RPCSEC_GSS or GSS-API
		    layers does, or arguably should, fit more naturally
		    into most, if not all, NFSv4 implementations.
</p>
<p>Alternative (b) is certainly general enough.  In
		    fact, it is more general than the RPCSEC_GSSv3
		    solution in that it could be used in non-RPC
		    protocols that support the use of the GSS-API.
		    However, the RPCSEC_GSSv3 approach is attractively
		    simple.  For example, to pursue (b) would likely
		    entail having to specify a framework for mechanism
		    composition, as well as GSS-API interfaces to access
		    assertions that would typically be very
		    platform-specific.  (The KITTEN WG has explored
		    stackable pseudo-mechanisms in the past, but that
		    work is currently stagnant.)  It is possible that
		    stackable pseudo-mechanisms may materialize in the
		    future; such mechanisms would be usable through all
		    versions of RPCSEC_GSS so far.
</p>
<p>As we considered these alternatives we also realized
		    that we needed other features that could all be
		    packed into a single solution.  For example, the
		    assertion of security label is conceptually
		    equivalent, protocol-wise, to assertions of
		    privilege and identity.
</p>
<p>Additionally, assertions need to be verified, and in
		    this case the one party that can verify an assertion
		    is the client host, which can authenticate to the
		    server using its own credentials.  Yet we want to
		    continue authenticating users as well.  This calls
		    for compound authentication.
</p>
<p>Finally, because the design of RPCSEC_GSSv3 relies on
		    RPCSEC_GSSv1 (though v2 can also be used) to do the
		    actual GSS-API security context establishment, we
		    add support for channel binding so that implementors
		    who have implemented RPCSEC_GSSv1 but not version 2
		    can still provide channel binding without having to
		    implement version 2.  Channel binding is
		    accomplished in a more simple manner in v3 also.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Applications of RPCSEC_GSSv3</h3>

<p>The common uses of RPCSEC_GSSv3, particularly for
		    NFSv4, are expected to be:

		    </p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>labeled security: client-side process label
			    assertion [+ privilege assertion] +
			    compound client host &amp; user
			    authentication;
</dd>
<dt>b.</dt>
<dd>compound client host &amp; user
			    authentication [+ privilege assertion];
</dd>
<dt>c.</dt>
<dd>client-side process credentials assertion [+
			    privilege assertion] as a replacement for
			    AUTH_SYS that is more secure than AUTH_SYS
			    while not requiring per-user credentials
</dd>
</dl></blockquote><p>
		
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Conventions used in this document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED",
		    "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
		    "RECOMMENDED", "MAY", and "OPTIONAL" in this
		    document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="v3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
The RPCSEC_GSSv3 protocol</h3>

<p>The following External Data Representation (XDR) <a class='info' href='#RFC4506'>[RFC4506]<span> (</span><span class='info'>Eisler, M., &ldquo;XDR: External Data Representation Standard,&rdquo; May&nbsp;2006.</span><span>)</span></a> definitions are used:
	    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

	#define RPCSEC_GSS_VERS_3 3

	enum rpc_gss3_proc_t {
		RPCSEC_GSS3_DATA = 0,
		RPCSEC_GSS3_LIST = 1,
		RPCSEC_GSS3_CREATE = 2,
		RPCSEC_GSS3_DESTROY = 3
	};

	struct {
		rpc_gss3_proc_t		gss_proc;
		unsigned int		seq_num;
		rpc_gss_service_t	service;
		unsigned int		handle_version;
		opaque			handle&lt;&gt;;
	} rpc_gss_cred_vers_3_t;

	struct {
		int	type;
		bool	critical;
		opaque	data&lt;&gt;;
	} rpc_gss3_extension;

	struct {
		unsigned int	version;
		opaque		handle&lt;&gt;;
		opaque		nonce&lt;&gt;;
		opaque		mic&lt;&gt;;
	} rpc_gss3_gss_binding;

	typedef opaque rpc_gss3_chan_binding&lt;&gt;;

	typedef opaque rpc_gss3_doi&lt;&gt;;
	struct {
		rpc_gss3_doi	doi;
		opaque		label&lt;&gt;;
	} rpc_gss3_label;

	typedef opaque rpc_gss3_privs&lt;&gt;;

	typedef opaque rpc_gss3_name&lt;&gt;;

	struct {
		rpc_gss3_name	*username;
		rpc_gss3_name	*groups&lt;&gt;;
		rpc_gss3_name   *groups_add&lt;&gt;;
		rpc_gss3_name   *groups_remove&lt;&gt;;
	} rpc_gss3_id;

	enum rpc_gss3_assertion_type {
		LABEL = 0,
		PRIVS = 1,
		IDENTITY = 2
	};

	union switch (rpc_gss3_assertion_type atype) {
	case LABEL:
		rpc_gss3_label	label;
	case PRIVILEGES:
		rpc_gss3_privs	privs;
	case IDENTITY:
		rpc_gss3_id	id;
	default:
		opaque		ext&lt;&gt;;
	} rpc_gss3_assertion_u;

	struct rpc_gss3_assertion {
		bool			critical;
		rpc_gss3_assertion_u	assertion;
	};

	struct {
		rpc_gss3_gss_binding	*compound_binding;
		rpc_gss3_chan_binding	*chan_binding_mic;
		rpc_gss3_assertion	assertions&lt;&gt;;
		rpc_gss3_extension	extensions&lt;&gt;;
	} rpc_gss3_create_args;

	struct {
		opaque			handle&lt;&gt;;
		rpc_gss3_chan_binding	*chan_binding_mic;
		rpc_gss3_assertion	granted_assertions&lt;&gt;;
		rpc_gss3_assertion	server_assertions&lt;&gt;;
		rpc_gss3_extension	extensions&lt;&gt;;
	} rpc_gss3_create_res;

	enum rpc_gss3_list_item {
		DOI = 0,
		PRIV = 1,
		PRIV_GROUP = 2
	};

	struct {
		rpc_gss3_list_item	list_what&lt;&gt;;
	} rpc_gss3_list_args;

	union switch (rpc_gss3_list_item itype) {
	case DOI:
		rpc_gss3_doi	dois&lt;&gt;;
	case PRIV:
		string		privs;
	case PRIV_GROUP:
		string		priv_groups;
	default:
		opaque		ext&lt;&gt;;
	} rpc_gss3_list_item_u;

	typedef rpc_gss3_list_item_u rpc_gss3_list_res&lt;&gt;;

</pre></div>
<p>The rpc_gss_cred_vers_3_t type is used in much the same
		way that rpc_gss_cred_vers_1_t is used in
		RPCSEC_GSSv1, that is: as the arm of the rpc_gss_cred_t
		discriminated union corresponding to version 3
		(RPCSEC_GSS_VERS_3).  It differs from
		rpc_gss_cred_vers_1_t in that: a) the values for
		gss_proc corresponding to control messages are
		different, b) the presence of a field indicating the
		version of RPCSEC_GSS used to established the context
		handle used, if any.
</p>
<p>RPC data messages using RPCSEC_GSSv3 context handles
		differ from RPCSEC_GSSv1 only in that the version number
		used MUST be '3' instead of '1' and, as described above,
		in that there is one more field in the RPCSEC_GSS header
		to name the version of RPCSEC_GSS used to establish the
		context handle used to protect this message.  All other
		protocol elements from RPCSEC_GSSv1-protected RPC data
		messages MUST remain the same in v3 as in v1.
</p>
<p>RPCSEC_GSSv3 control messages are the same as
		RPCSEC_GSSv3 data messages, but with a gss_proc value
		that indicates a control message is contained in the
		data payload.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Control messages</h3>

<p>There are two RPCSEC_GSSv3 control messages:
		    RPCSEC_GSS3_CREATE and RPCSEC_GSS3_LIST.
</p>
<p>The client MUST use one of the following security
		    services to protect any RPCSEC_GSSv3 control
		    message:

		    </p>
<ul class="text">
<li>rpc_gss_svc_channel_prot (see RPCSEC_GSSv2)
</li>
<li>rpc_gss_svc_integrity
</li>
<li>rpc_gss_svc_privacy
</li>
</ul><p>

		    <br />
<br />


		    Specifically the client MUST NOT use
		    rpc_gss_svc_none.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.1"></a><h3>2.1.1.&nbsp;
New auth_stat values</h3>

<p>RPCSEC_GSSv3 requires the addition of several
			values to the auth_stat enumerated type
			definition:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

	enum auth_stat {
		...
		/*
		 * RPCSEC_GSS errors
		 */
		RPCSEC_GSS3_COMPOUND_PROBEM = &lt;TBD&gt;,
		RPCSEC_GSS3_LABEL_PROBLEM = &lt;TBD&gt;,
		RPCSEC_GSS3_IDENTITY_PROBLEM = &lt;TBD&gt;
		RPCSEC_GSS3_UNKNOWN_ASSERTION = &lt;TBD&gt;
		RPCSEC_GSS3_UNKNOWN_EXTENSION = &lt;TBD&gt;
		RPCSEC_GSS3_UNKNOWN_MESSAGE = &lt;TBD&gt;
	};

</pre></div>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2"></a><h3>2.1.2.&nbsp;
Create request</h3>

<p>The RPCSEC_GSS3_CREATE call message consists of
			inputs to bind into a new RPCSEC_GSSv3 handle.
			The context handle used to protect the
			RPCSEC_GSS3_CREATE call message is termed the
			"parent" (or "outer") handle.  The reply to this
			message consists of either an error or a new
			RPCSEC_GSSv3 handle, termed the "child"
			handle.
</p>
<p>All uses of a child context handle MUST use the
			GSS-API security context associated with the
			parent context handle of the RPCSEC_GSS3_CREATE
			request that produced the child context handle.
			The child context, however, has its own sequence
			number space and window, distinct from that of
			the parent.
</p>
<p>As described in the introduction, the
			RPCSEC_GSS3_CREATE call message binds one or
			more items of several kinds into a new
			RPCSEC_GSSv3 context handle:

			</p>
<ul class="text">
<li>another RPCSEC_GSS (version 1, 2, or 3)
				context handle
</li>
<li>a channel binding
</li>
<li>authorization assertions (label,
				privileges)
</li>
<li>identity assertions
</li>
</ul><p>
		    
</p>
<p>Servers MUST either ignore, reject or apply
			policy to the authorization and identity
			assertions.  Policies should take into account
			the identity of the client and/or user as
			authenticated via the GSS-API.  Server
			implementation and policy MAY result in labels,
			privileges and identities being mapped to
			concepts and values that are local to the
			server.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2.1"></a><h3>2.1.2.1.&nbsp;
Compound authentication</h3>

<p>RPCSEC_GSSv3 allows for compound
			    authentication of client hosts and users to
			    servers.  This is done by using an integrity
			    protected RPCSEC_GSSv3 message of
			    RPCSEC_GSS3_CREATE type which includes a
			    reference to the context handle to bind, a
			    nonce and a MIC of that nonce using the
			    GSS-API security context associated with the
			    named context handle.  We'll term the two
			    context handles "parent" (or "outer") and
			    "inner," and the resulting context handle
			    the "child" handle, where the outer context
			    handle is the context handle providing
			    integrity protection to the
			    RPCSEC_GSS3_CREATE message, and the inner
			    context handle is the one referenced via the
			    compound_binding field of the
			    RPCSEC_GSS3_CREATE arguments structure
			    (rpc_gss3_create_args).
</p>
<p>All uses of a child context handle that is
			    bound to an inner context MUST be treated as
			    speaking for the initiator principal (as
			    modified by any assertions in the
			    RPCSEC_GSS3_CREATE message) of the inner
			    context handle's GSS-API security
			    context.
</p>
<p>This feature is needed, for example, when a
			    client wishes to use authority assertions
			    that the server may only grant if a user and
			    a client are authenticated together to the
			    server.  Thus a server may refuse to grant
			    requested authority to a user acting alone
			    (e.g., via an unprivileged user-space
			    program), but may grant requested authority
			    to a client acting on behalf of a user if
			    the server trusts the client.
</p>
<p>It is assumed that an unprivileged user-space
			    program would not have access to client host
			    credentials needed to establish a GSS-API
			    security context authenticating the client
			    to the server, therefore an unprivileged
			    user-space program could not create an
			    RPCSEC_GSSv3 RPCSEC_GSS3_CREATE message that
			    successfully binds a client and a user
			    security context.
</p>
<p>Clients using RPCSEC_GSS context binding MUST
			    use, as the outer context handle, an
			    RPCSEC_GSS context handle that corresponds
			    to a GSS-API security context that
			    authenticates the client host, and for the
			    inner context handle it SHOULD use a context
			    handle to authenticates a user.  The reverse
			    (outer handle authenticates user, inner
			    authenticates client) MUST NOT be used.
			    Other compounds might eventually make
			    sense.
</p>
<p>An RPCSEC_GSSv3 context handle that is bound
			    to another RPCSEC_GSS context MUST be
			    treated by servers as authenticating the
			    GSS-API initiator principal authenticated by
			    the inner context handle's GSS-API security
			    context.  This principal may be mapped to a
			    server-side notion of user or principal as
			    modified by any identity assertions by the
			    client in the same RPCSEC_GSS3_CREATE
			    request that the server accepts.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2.2"></a><h3>2.1.2.2.&nbsp;
Channel binding</h3>

<p>RPCSEC_GSSv3 provides a different way to do
			    channel binding that RPCSEC_GSSv2.
			    Specifically: a) RPCSEC_GSSv3 builds on
			    RPCSEC_GSSv1 by reusing existing,
			    established context handles rather than
			    providing a different RPC security flavor
			    for establishing context handles, b) channel
			    bindings data are not hashed because the
			    community now agrees that it is the secure
			    channel's responsibility to produce channel
			    bindings data of manageable size.  (a) is
			    useful in keeping RPCSEC_GSSv3 simple in
			    general, not just for channel binding.  (b)
			    is useful in keeping RPCSEC_GSSv3 simple
			    specifically for channel binding.
</p>
<p>Channel binding is accomplished as follows.
			    The client prefixes the channel bindings
			    data octet string with the channel type as
			    described in <a class='info' href='#RFC5056'>[RFC5056]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; November&nbsp;2007.</span><span>)</span></a>, then
			    the client calls GSS_GetMIC() to get a MIC
			    of resulting octet string, using the outer
			    RPCSEC_GSS context handle's GSS-API security
			    context.  The MIC is then placed in the
			    chan_binding_mic field of RPCSEC_GSS3_CREATE
			    arguments (rpc_gss3_create_args).
</p>
<p>If the chan_binding_mic field of the
			    arguments of a RPCSEC_GSS3_CREATE control
			    message is set, then the server MUST verify
			    the client's channel binding MIC if the
			    server supports this feature.  If channel
			    binding verification succeeds then the
			    server MUST generate a new MIC of the same
			    channel bindings and place it in the
			    chan_binding_mic field of the
			    RPCSEC_GSS3_CREATE results.  If channel
			    binding verification fails or the server
			    doesn't support channel binding then the
			    server MUST indicate this in its reply by
			    not including a chan_binding_mic value
			    (chan_binding_mic is an optional field).
</p>
<p>The client MUST verify the result's
			    chan_binding_mic value, if the server
			    included it, by calling GSS_VerifyMIC() with
			    the given MIC and the channel bindings data
			    (including the channel type prefix).  If
			    client-side channel binding verification
			    fails then the client MUST call
			    RPCSEC_GSS3_DESTROY.  If the client
			    requested channel binding but the server did
			    not include a chan_binding_mic field in the
			    results, then the client MAY continue to use
			    the resulting context handle as though
			    channel binding had never been requested,
			    otherwise (if the client really wanted
			    channel binding) it MUST call
			    RPCSEC_GSS3_DESTROY.
</p>
<p>As per-RPCSEC_GSSv2:
			    </p>
<ul class="text">
<li>"Once a successful [channel binding]
				    procedure has been performed on an
				    [RPCSEC_GSSv3] context handle, the
				    initiator's implementation may map
				    application requests for
				    rpc_gss_svc_none and
				    rpc_gss_svc_integrity to
				    rpc_gss_svc_channel_prot
				    credentials.  And if the secure
				    channel has privacy enabled,
				    requests for rpc_gss_svc_privacy can
				    also be mapped to
				    rpc_gss_svc_channel_prot."
</li>
<li>...
</li>
</ul><p>
			
</p>
<p>Any RPCSEC_GSSv3 context handle that has been
			    bound to a secure channel in this way SHOULD
			    be used only with the
			    rpc_gss_svc_channel_prot, and SHOULD NOT be
			    used with rpc_gss_svc_none nor
			    rpc_gss_svc_integrity -- if the secure
			    channel does not provide privacy protection
			    then the client MAY use rpc_gss_svc_privacy
			    where privacy protection is needed or
			    desired.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2.3"></a><h3>2.1.2.3.&nbsp;
Label assertions</h3>

<p>RPCSEC_GSSv3 clients MAY assert a security
			    label in some DOI by binding this assertion
			    into an RPCSEC_GSSv3 context handle.  This
			    is done by including an assertion of type
			    rpc_gss3_label in the 'assertions' field
			    (discriminant: 'LABEL') of the
			    RPCSEC_GSS3_CREATE arguments to the desired
			    DOI and label.
</p>
<p>Label encoding is specific to each DOI and
			    not described herein.  DOI encoding is
			    &lt;TBD&gt; [fill in...  Solaris uses
			    integers to name DOIs, and there is an IANA
			    registry of DOIs as 32-bit integers, and
			    IPsec (whence the IANA registry) and CALIPSO
			    use 32-bit integers for DOIs as well.  So a
			    32-bit unsinged integer seems to be the way
			    to go.  Add references... -Nico]
</p>
<p>If a label itself requires privacy protection
			    (i.e., that the user can assert that label
			    is a secret) then the client MUST use the
			    rpc_gss_svc_privacy protection service for
			    the RPCSEC_GSS3_CREATE request or, if the
			    parent handle is bound to a secure channel
			    that provides privacy protection,
			    rpc_gss_svc_channel_prot.
</p>
<p>If a client wants to ensure that the server
			    understands the asserted label then it MUST
			    set the 'critical' field of the label
			    assertion to TRUE, otherwise it MUST set it
			    to FALSE.
</p>
<p>Servers that don't support labeling MUST
			    ignore non-critical label assertions.
			    Servers that don't support the requested DOI
			    MUST either ignore non-critical label
			    assertions or map them to a suitable label
			    in a supported DOI.  Servers that don't
			    support labeling or don't support the
			    requested DOI MUST return an error if the
			    label request is critical.  Servers that
			    support labeling in the requested DOI MAY
			    map the requested label to different label
			    as a result of server-side policy
			    evaluation.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2.4"></a><h3>2.1.2.4.&nbsp;
Privilege assertions</h3>

<p>Privilege assertions are similar to label
			    assertions, except that there is no DOI, and
			    the privileges supported are specified by
			    the RPC application.
</p>
<p>Privileges are encoded US-ASCII strings
			    containing comma-separated privilege names,
			    as well as up to one privilege group name
			    and zero or more exclusions, where each
			    exclusion is a privilege name or privilege
			    group name prefixed with an exclamation
			    point.  Two special privilege group names
			    are defined hereing: "all" (which represents
			    all possible privileges) and "basic" (which
			    represents privileges normally granted to
			    all users).
</p>
<p>RPC applications that wish to use this
			    facility must define the set of known
			    privileges, and must specify which
			    privileges are in the "basic" privilege
			    group.  For example, NFSv4 might specify
			    privileges for reading, writing, chowning,
			    linking, etcetera.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2.5"></a><h3>2.1.2.5.&nbsp;
Identity assertions</h3>

<p>Identity assertions can be used either to
			    modify the set of groups assigned on the
			    server-side to a given user (authenticated
			    by the GSS-API) or to implement an
			    AUTH_SYS-like <a class='info' href='#RFC1831'>[RFC1831]<span> (</span><span class='info'>Srinivasan, R., &ldquo;RPC: Remote Procedure Call Protocol Specification Version 2,&rdquo; August&nbsp;1995.</span><span>)</span></a>.  In
			    the latter case the client specifies at
			    least a user-name and possibly groups that
			    it thinks the user belongs to.
</p>
<p>Clients may set a username, a group list,
			    and/or lists of groups to be added or
			    removed from the group list that the server
			    would normally use for the given user.
</p>
<p>The server MUST decide whether to accept
			    identity assertions by applying local
			    policy.  Such policies is not described
			    herein.  Example policies:

			    </p>
<ul class="text">
<li>"always accept identity
				    assertions"
</li>
<li>"always accept identity assertions where
				    the identities are understood"
</li>
<li>"accept identity assertions ... only
				    from trusted clients" (where the
				    identity of the client is taken from
				    the initiator principal of the outer
				    context handle's GSS-API security
				    context, or from the network address
				    of the client...)
</li>
<li>"accept identity assertions ... only
				    from trusted clients where IPsec
				    policy protects this application's
				    packet flows between the clients and
				    this server"
</li>
<li>"accept only removals of groups from a
				    user's group membership list as
				    determined by the server"
</li>
<li>"never accept identity
				    assertions"
</li>
<li>etcetera
</li>
</ul><p>
			
</p>
<p>Clients may mark an identity assertion as
			    being critical, in which case the server
			    MUST respond with an error if the server
			    does not accept the identity assertion
			    as-is.
</p>
<p>The representation of users and groups is not
			    given here, but is left to the application.
			    It is expected that RPCSEC_GSSv3 identity
			    assertions in the context of the NFSv4
			    application would consist of NFSv4 user and
			    group representations as used on the wire in
			    NFSv4 access control lists (ACLs).
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2.6"></a><h3>2.1.2.6.&nbsp;
Server assertions</h3>

<p>Servers MAY inform clients of assertions were
			    granted by setting the 'granted_assertions'
			    field of the RPCSEC_GSS3_CREATE reply.
</p>
<p>The protocol provides a field
			    ('server_assertions') for servers to make
			    assertions about themselves.  At this time
			    there is not much use for this field, though
			    servers MAY assert a single security label,
			    indicating that all contents on the server
			    is at that label.  The client MUST, of
			    course, either evaluate or ignore any
			    server-side assertions.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.3"></a><h3>2.1.3.&nbsp;
Context handle destruction</h3>

<p>The RPCSEC_GSS3_DESTROY procedure is the same as
			for RPCSEC_GSSv1, but with the version 3
			header.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.4"></a><h3>2.1.4.&nbsp;
List request</h3>

<p>The RPCSEC_GSS3_LIST call message consists of a
			single integer indicating what should be listed,
			and the reply consists of an error or the
			requested list.
</p>
<p>The client may list DOIs, privilege names, or
			privilege group names.
</p>
<p>The result is an opaque octet string containing a
			list of DOIs [encoding &lt;TBD&gt;] or a
			US-ASCII string containing a comma-separated
			list of privilege names or privilege group
			names.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.5"></a><h3>2.1.5.&nbsp;
Extensibility</h3>

<p>Assertion types may be added in the future by
			adding arms to the 'rpc_gss3_assertion_u' union.
			Every assertion has a 'critical' flag that can
			be used to indicate criticality.
</p>
<p>New fields may be added through the 'extensions'
			typed hole.  All such extensions have a
			'critical' flag.
</p>
<p>New message types may be added.
</p>
<p>Clients receiving unknown critical server
			assertions MUST destroy the established
			RPCSEC_GSSv3 context handle.  Servers receiving
			unknown critical client assertions or unknown
			RPCSEC_GSS_v3 extensions MUST return an
			error.
</p>
<p>There is no IANA or other registry for
			RPCSEC_GSSv3 extensions.  All extensions MUST be
			done by IETF Protocol Action.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Privileges and identity representation for
	    NFSv4</h3>

<p>The representation of users and groups for use in
		identity assertions in RPCSEC_GSSv3 SHALL be the same as
		the user and group representations used by NFSv4 for
		access control list subjects on the wire, cast as an
		octet string ("opaque").
</p>
<p>The following privileges are defined for use with the
		NFSv4 protocol:

		</p>
<blockquote class="text"><dl>
<dt>file_chown</dt>
<dd>Generally allows the caller
			to change a file's owner regardless of who owns
			the file.
</dd>
<dt>file_chown_self</dt>
<dd>Generally allows the
			caller to change the owner of a file it
			owns.
</dd>
<dt>file_dac_execute</dt>
<dd>Generally allows the
			caller to read any file for execution.
</dd>
<dt>file_dac_read</dt>
<dd>Generally allows the
			caller to read any file or directory.
</dd>
<dt>file_dac_search</dt>
<dd>Generally allows the
			caller to search any directory.
</dd>
<dt>file_dac_write</dt>
<dd>Generally allows the
			caller to write to any file (or
			create/delete/link objects in directories).
</dd>
<dt>file_link_any</dt>
<dd>Generally allows the
			caller to create hardlinks to files not owned by
			the caller.
</dd>
<dt>file_owner</dt>
<dd>Generally allows the caller
			to modify the access, modification and other
			timestamps of a filesystem object, as well as
			its permissions and ACL.
</dd>
<dt>file_setid</dt>
<dd>Generally allows the caller
			to set the set-user-ID and set-group-ID bits of
			a file.
</dd>
<dt>file_downgrade_sl</dt>
<dd>Generally allows the
			caller to downgrade the security label of a
			filesystem object.
</dd>
<dt>file_update_sl</dt>
<dd>Generally allows the
			caller to upgrade the security label of a
			filesystem object.
</dd>
</dl></blockquote><p>
	    
</p>
<p>[What about NFSv3?  The representation of privs would be
		the same for v3 as for v4, though there'd be no privs
		for dealing with labels (file_downgrade_sl and
		file_update_sl).  And the representation of users/groups
		would NFSv3's representation thereof.  But should we
		bother to specify this? -Nico]
</p>
<p>[Also, this is derived from Solaris' notion of
		privileges.  We should look at how well this scheme
		relates to other operating systems as NFSv4 clients and
		servers. -Nico]
</p>
<p>The contents of the 'basic' privilege set is not defined
		herein.  Note that 'file_link_any' and 'file_chown_self'
		may be present in the server's notion of the basic
		privilege set.
</p>
<p>The NFSv4-specific privileges may be limited by the
		server in ways not specified above.  For example, the
		server may deny access for certain operations that would
		normally be granted given the granted assertion of a
		given privilege (e.g., "no one may write to files owned
		by such and such user"), or the server may require that
		all privileges be asserted (and granted, of course) in
		order to allow certain operations (e.g., "all privileges
		are required in order to write to files owned by such
		and such user, not just file_dac_write").
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Security Considerations</h3>

<p>This entire document deals with security issues.
</p>
<p>The RPCSEC_GSSv3 protocol allows for client-side
		assertions of data that is relevant to server-side
		authorization decisions.  These assertions must be
		evaludated by the server in the context of whether the
		client and/or user are authenticated, whether
		compound authentication was used, whether the client is
		trusted, what ranges of assertions are allowed for the
		client and the user (separately or together), and any
		relevant server-side policy.
</p>
<p>The security semantics of assertions carried by
		RPCSEC_GSSv3 are application protocol-specific.
</p>
<p>RPCSEC_GSSv3 supports a notion of critical assertions
		(and extensions), but there's no need for peers to tell
		each other what assertions were granted, or what they
		were mapped to.
</p>
<p>Note that RPSEC_GSSv3 is not a complete solution for
		labeling: it conveys the labels of actors, but not the
		labels of objects.  RPC application protocols may
		require extending in order to carry object label
		information.
</p>
<p>The RPCSEC_GSSv3 protocol also provides for a replacement
		of the old AUTH_SYS RPC authentication flavor.  AUTH_SYS
		relies on "privileged port numbers" for
		"authentication," and was quite limited in what
		assertions it supported and incompatible with NFSv4
		representations of identity.  To replace AUTH_SYS with
		RPCSEC_GSSv3 simply use a GSS-API mechanism to
		authenticate the client (but not the user) and let the
		client assert the user's identity.  This is more secure
		than AUTH_SYS in that at least the client can be
		strongly authenticated using GSS-API mechanisms, and it
		is more functional than AUTH_SYS in that identity
		representations are defined by the application
		layer.
</p>
<p>It is possible that a GSS-API mechanism that does not
		provide any security services could be created so as to
		make it possible to replace AUTH_SYS with RPCSEC_GSSv3
		while retaining the same privileged port semantics.
		Such a mechanism is out of scope for this document and
		would have its own security considerations.
</p>
<p>There may be interactions with NFSv4's callback security
		scheme and NFSv4.1's GSS-API "SSV" mechanisms.
		Specifically, the NFSv4 callback scheme requires that
		the server initiate GSS-API security contexts, which
		does not work well in practice, and in the context of
		client-side processes running as the same user but with
		different privileges and security labels the NFSv4
		callback security scheme seems particularly unlikely to
		work well.  NFSv4.1 has the server use an existing,
		client-initiated RPCSEC_GSS context handle to protect
		server-initiated callback RPCs.  The NFSv4.1 callback
		security scheme lacks all the problems of the NFSv4
		scheme, however, it is important that the server pick an
		appropriate RPCSEC_GSS context handle to protect any
		callbacks.  Specifically, it is important that the
		server use RPCSEC_GSS context handles which authenticate
		the client to protect any callbacks relating to server
		state initiated by RPCs protected by RPCSEC_GSSv3
		contexts.  [Add text about interaction with
		GSS-SSV...]
</p>
<p>[Anything else?]
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
IANA Considerations</h3>

<p>There are no IANA considerations in this document.
</p>
<p>TBDs in this document will be assigned by the ONC RPC
		registrart (which is not IANA, as I recall).
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1831">[RFC1831]</a></td>
<td class="author-text"><a href="mailto:raj@eng.sun.com">Srinivasan, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1831">RPC: Remote Procedure Call Protocol Specification Version 2</a>,&rdquo; RFC&nbsp;1831, August&nbsp;1995 (<a href="http://www.rfc-editor.org/rfc/rfc1831.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2203">[RFC2203]</a></td>
<td class="author-text"><a href="mailto:mre@eng.sun.com">Eisler, M.</a>, <a href="mailto:hacker@eng.sun.com">Chiu, A.</a>, and <a href="mailto:lling@eng.sun.com">L. Ling</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2203">RPCSEC_GSS Protocol Specification</a>,&rdquo; RFC&nbsp;2203, September&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2203.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2203.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2203.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3530">[RFC3530]</a></td>
<td class="author-text">Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &ldquo;<a href="http://tools.ietf.org/html/rfc3530">Network File System (NFS) version 4 Protocol</a>,&rdquo; RFC&nbsp;3530, April&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3530.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4506">[RFC4506]</a></td>
<td class="author-text">Eisler, M., &ldquo;<a href="http://tools.ietf.org/html/rfc4506">XDR: External Data Representation Standard</a>,&rdquo; STD&nbsp;67, RFC&nbsp;4506, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4506.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5056">[RFC5056]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>,&rdquo; RFC&nbsp;5056, November&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5056.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nicolas
	    Williams</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sun Microsystems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5300 Riata Trace Ct</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Austin, TX  78727</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:Nicolas.Williams@sun.com">Nicolas.Williams@sun.com</a></td></tr>
</table>
</body></html>
