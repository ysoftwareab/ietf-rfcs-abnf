URI = scheme ":" path-rootless [ "?" query ] [ "#" fragment ]

path-rootless = segment-nz *( "/" segment )

segment-nz    = 1*pchar
segment       = *pchar
query         = *( pchar / "/" / "?" )
fragment      = *( pchar / "/" / "?" )

pchar = unreserved / pct-encoded / sub-delims / ":" / "@"

scheme     = "urn"

urn-path   = NID ":" NSS

NID = (ALPHA / DIGIT) 0*30(ALPHA / DIGIT / "-") (ALPHA / DIGIT)

NSS   = 1*pchar   ; or equivalent:    NSS   = segment-nz

urn-query = directive *( "&" directive)

directive = keywd "=" value
keywd     = ALPHA *( ["-"] (ALPHA / DIGIT))
value     = *v-pchar

v-pchar   = unreserved / pct-encoded / v-subdels
v-subdels = "!" / "$" / "'" / "(" / ")"
                / "*" / "+" / "," / ";" / "="
                / ":" / "@" / "/" / "?"
gen-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@"

excluded = CTL / SP        ; control characters and space
                       / DQUOTE          ; "
                       / "#"             ; from <gen-delims>
                       / "%"             ; see above
                       / "/"             ; from <gen-delims>
                       / "<" / ">"
                       / "?"             ; from <gen-delims>
                       / "["             ; from <gen-delims>
                       / "\"
                       / "]"             ; from <gen-delims>
                       / "^"
                       / "`"
                       / "{" / "|" / "}"
                       / %x7F            ; DEL (control character)
                       / %x80-FF         ; non-ASCII

I=I    URI equal to URI?              provisional  RFC 2483, sec. 4.9

URI    = scheme ":" path-rootless [ "?" query ] [ "#" fragment ]

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
path-rootless = segment-nz *( "/" segment )
query         = *( pchar / "/" / "?" )
fragment      = *( pchar / "/" / "?" )

segment-nz    = 1*pchar
segment       = *pchar
pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
pct-encoded   = "%" HEXDIG HEXDIG
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
                     / "*" / "+" / "," / ";" / "="
scheme        = "urn"
                         ; specific, fixed (assigned) value

urn-path      = NID ":" NSS
                         ; to be superimposed on <path-rootless>,
                         ; which needs to be <segment-nz> only

NID           = ( ALPHA / DIGIT ) 1*31( ALPHA / DIGIT / "-" )
                         ; RFC 3406[bis] contains more specific rules

NSS           = 1*pchar
                         ; or equivalent:    NSS   = segment-nz

urn-query     = directive *( "&" directive)
                         ; to be superimposed on <query>

directive     = keywd "=" value
keywd         = ALPHA *( ["-"] (ALPHA / DIGIT))
value         = *v-pchar

v-pchar       = unreserved / pct-encoded / v-subdels
v-subdels     = "!" / "$" /       "'" / "(" / ")"
                       / "*" / "+" / "," / ";" / "="
                         ; this is equivalent to <sub-delims> except "&"
                       / ":" / "@" / "/" / "?"
                         ; plus the extra characters allowed in <pchar>
                         ; and for <query>, as per RFC 3986

ALPHA         =  %x41-5A / %x61-7A   ; A-Z / a-z
DIGIT         =  %x30-39             ; 0-9
HEXDIG        =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"

NSS           = 1*pchar   ; or equivalent:   NSS   = segment-nz
NSS         = 1*URN-char

URN-char    = trans / pct-encoded
trans       = ALPHA / DIGIT / u-other
u-other     = ":" / "@"
                       ; those from RFC 3986 <gen-delims>
                       ; specifically allowed in <pchar>.
