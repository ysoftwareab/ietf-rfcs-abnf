R = Maximum Sustained Traffic Rate (bps)

P = Peak Traffic Rate (bps)

B = Maximum Traffic Burst (bytes)

drop_prob_ = 0;
qdelay_old_ = 0;
burst_reset_ = 0;
burst_state_ = NOBURST;
qdelay = queue_.byte_length() / PEAK_RATE;
qdelay = ((queue_.byte_length() - msrtokens()) / MSR \
                     +  msrtokens() / PEAK_RATE);
drop_prob_ = 0;
p = A * (qdelay - LATENCY_TARGET) + \
               B * (qdelay - qdelay_old_);
p = 0.02;
drop_prob_ = max(0, drop_prob_);
drop_prob_ = min(drop_prob_, \
                        PROB_LOW * MEAN_PKTSIZE/MIN_PKTSIZE);
burst_allowance_ = 0;
burst_allowance_ = burst_allowance_ - INTERVAL;

burst_state_ = FIRST_BURST;
burst_reset_ = 0;

burst_reset_ = 0;
burst_state_ = NOBURST;
burst_reset_ = 0;
qdelay_old_ = qdelay;

accu_prob_ = 0;
accu_prob_ = 0;
burst_state_ = FIRST_BURST;             //burst detected
p1 = drop_prob_ * packet.size() / MEAN_PKTSIZE;
p1 = min(p1, PROB_LOW);

drop = TRUE;
drop = FALSE;            // to bad luck of coin tosses...
drop = TRUE;                      // too slowly
drop = FALSE;
accu_prob_ = 0;

burst_state_ = PROTECT_BURST;
burst_allowance_ = MAX_BURST;
