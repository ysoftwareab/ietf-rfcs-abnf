json-path = root-selector *(S (dot-selector        /
                                  dot-wild-selector   /
                                  index-selector      /
                                  index-wild-selector /
                                  list-selector       /
                                  slice-selector      /
                                  descendant-selector /
                                  filter-selector))

root-selector  = "$"

dot-selector    = "." dot-member-name
dot-member-name = name-first *name-char
name-first      =
                         ALPHA /
                         "_"   /           ; _
                         %x80-10FFFF       ; any non-ASCII Unicode character
name-char = DIGIT / name-first

DIGIT           =  %x30-39              ; 0-9
ALPHA           =  %x41-5A / %x61-7A    ; A-Z / a-z
dot-wild-selector    = "." "*"            ;  dot followed by asterisk

index-selector      = "[" S (quoted-member-name / element-index) S "]"

quoted-member-name  = string-literal

string-literal      = %x22 *double-quoted %x22 /       ; "string"
                         %x27 *single-quoted %x27         ; 'string'

double-quoted       = unescaped /
                         %x27      /                       ; '
                         ESC %x22  /                       ; \"
                         ESC escapable

single-quoted       = unescaped /
                         %x22      /                       ; "
                         ESC %x27  /                       ; \'
                         ESC escapable

ESC                 = %x5C                              ; \  backslash

unescaped           = %x20-21 /                         ; s. RFC 8259
                         %x23-26 /                         ; omit "
                         %x28-5B /                         ; omit '
                         %x5D-10FFFF                       ; omit \

escapable           = ( %x62 / %x66 / %x6E / %x72 / %x74 / ; \b \f \n \r \t
                             ; b /         ;  BS backspace U+0008
                             ; t /         ;  HT horizontal tab U+0009
                             ; n /         ;  LF line feed U+000A
                             ; f /         ;  FF form feed U+000C
                             ; r /         ;  CR carriage return U+000D
                             "/" /          ;  /  slash (solidus) U+002F
                             "\" /          ;  \  backslash (reverse solidus) U+005C
                             (%x75 hexchar) ;  uXXXX      U+XXXX
                         )

hexchar = non-surrogate / (high-surrogate "\" %x75 low-surrogate)
non-surrogate = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG) /
                    ("D" %x30-37 2HEXDIG )
high-surrogate = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate = "D" ("C"/"D"/"E"/"F") 2HEXDIG

HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"

element-index   = int                             ; decimal integer

int             = ["-"] ( "0" / (DIGIT1 *DIGIT) ) ; -  optional
DIGIT1          = %x31-39                         ; 1-9 non-zero digit

index-wild-selector    = "[" "*" "]"  ;  asterisk enclosed by brackets

slice-selector = "[" S slice-index S "]"

slice-index    =  [start S] ":" S [end S] [":" [S step ]]

start          = int       ; included in selection
end            = int       ; not included in selection
step           = int       ; default: 1

B              =    %x20 / ; Space
                       %x09 / ; Horizontal tab
                       %x0A / ; Line feed or New line
                       %x0D   ; Carriage return
S              = *B        ; optional blank space
RS             = 1*B       ; required blank space

n_start = Normalize(start, len)
n_end = Normalize(end, len)

lower = MIN(MAX(n_start, 0), len)
upper = MIN(MAX(n_end, 0), len)
upper = MIN(MAX(n_start, -1), len-1)
lower = MIN(MAX(n_end, -1), len-1)
i = lower
i = i + step
i = upper
i = i + step
descendant-selector = ".." ( dot-member-name      /  ; ..<name>
                                index-selector       /  ; ..[<index>]
                                index-wild-selector  /  ; ..[*]
                                "*"                     ; ..*
                              )

list-selector  = "[" S list-entry 1*(S "," S list-entry) S "]"

list-entry     =  ( quoted-member-name /
                       element-index      /
                       slice-index
                     )

filter-selector    = "[" S "?" S boolean-expr S "]"
boolean-expr     = logical-or-expr
logical-or-expr  = logical-and-expr *(S "||" S logical-and-expr)
                                                         ; disjunction
                                                         ; binds less tightly than conjunction
logical-and-expr = basic-expr *(S "&&" S basic-expr)  ; conjunction
                                                         ; binds more tightly than disjunction

basic-expr   = exist-expr /
                  paren-expr /
                  relation-expr
exist-expr   = [neg-op S] path                          ; path existence or non-existence
path         = rel-path / json-path
rel-path     = "@" *(S (dot-selector / index-selector))
paren-expr   = [neg-op S] "(" S boolean-expr S ")"    ; parenthesized expression
neg-op       = "!"                                    ; not operator

relation-expr = comp-expr /                           ; comparison test
                   regex-expr                            ; regular expression test

comp-expr    = comparable S comp-op S comparable
comparable   = number / string-literal /              ; primitive ...
                  true / false / null /                  ; values only
                  path                                   ; path value
comp-op      = "==" / "!=" /                          ; comparison ...
                  "<"  / ">"  /                          ; operators
                  "<=" / ">="
number       = int [ frac ] [ exp ]                   ; decimal number
frac         = "." 1*DIGIT                            ; decimal fraction
exp          = "e" [ "-" / "+" ] 1*DIGIT              ; decimal exponent
true         = %x74.72.75.65                          ; true
false        = %x66.61.6c.73.65                       ; false
null         = %x6e.75.6c.6c                          ; null

regex-expr   = (path / string-literal) S regex-op S regex
regex-op     = "=~"                                   ; regular expression match
regex        = string-literal                         ; I-Regexp

normalized-path           = root-selector *(normal-index-selector)
normal-index-selector     = "[" (normal-quoted-member-name / normal-element-index) "]"
normal-quoted-member-name = %x27 *normal-single-quoted %x27 ; 'string'
normal-single-quoted      = normal-unescaped /
                               ESC normal-escapable
normal-unescaped          = %x20-26 /                       ; omit control codes
                               %x28-5B /                       ; omit '
                               %x5D-10FFFF                     ; omit \
normal-escapable          = ( %x62 / %x66 / %x6E / %x72 / %x74 / ; \b \f \n \r \t
                                   ; b /         ;  BS backspace U+0008
                                   ; t /         ;  HT horizontal tab U+0009
                                   ; n /         ;  LF line feed U+000A
                                   ; f /         ;  FF form feed U+000C
                                   ; r /         ;  CR carriage return U+000D
                                   "'" /         ;  ' apostrophe U+0027
                                   "\" /         ;  \ backslash (reverse solidus) U+005C
                                   (%x75 normal-hexchar) ;  certain values u00XX U+00XX
                               )
normal-hexchar            = "0" "0"
                               (
                                 ("0" %x30-37) / ; "00"-"07"
                                 ("0" %x62) /    ; "0b"      ; omit U+0008-U+000A
                                 ("0" %x65-66) /  ; "0e"-"0f" ; omit U+000C-U+000D
                                 ("1" normal-HEXDIG)
                               )
normal-HEXDIG             = DIGIT / %x61-66   ; "0"-"9", "a"-"f"
normal-element-index      = "0" / (DIGIT1 *DIGIT) ; non-negative decimal integer

