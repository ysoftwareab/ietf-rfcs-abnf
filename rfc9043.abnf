a == b, a != b
a = b, a += b, a -= b, a *= b

left16s = l  >= 32768 ? ( l  - 65536 ) : l
top16s  = t  >= 32768 ? ( t  - 65536 ) : t
diag16s = tl >= 32768 ? ( tl - 65536 ) : tl

context = Q_0[l - tl] +
             Q_1[tl - t] +
             Q_2[t - tr] +
             Q_3[L - l]  +
             Q_4[T - t]

           Figure 5: Description of the computing of the Context.

Cb = b - g
Cr = r - g
Y = g + (Cb + Cr) >> 2

       Figure 6: Description of the transformation of pixels from RGB
             color space to coded, modified YCbCr color space.

g = Y - (Cb + Cr) >> 2
r = Cr + g
b = Cb + g

     Figure 7: Description of the transformation of pixels from coded,
               modified YCbCr color space to RGB color space.

Cb = g - b
Cr = r - b
Y = b + (Cb + Cr) >> 2

       Figure 8: Description of the transformation of pixels from RGB
        color space to coded, modified YCbCr color space (in case of
                                exception).

b = Y - (Cb + Cr) >> 2
r = Cr + b
g = Cb + b

     Figure 9: Description of the transformation of pixels from coded,
         modified YCbCr color space to RGB color space (in case of
                                exception).

coder_input = ((sample_difference + 2 ^ (bits - 1)) &
                 (2 ^ bits - 1)) - 2 ^ (bits - 1)

      Figure 10: Description of the coding of the Sample Difference in
                               the bitstream.

R_0 = 65280

                Figure 11: The initial value for the Range.

L_0 = 2 ^ 8 * B_0 + B_1

        Figure 12: The initial value for Low is set according to the
                     first two bytes of the bytestream.

j_0 = 2

          Figure 13: The initial value for "j", the length of the
                            bytestream encoding.

r_i = floor( ( R_i * S_(i, C_i) ) / 2 ^ 8 )

        Figure 14: This formula shows the positioning of range split
                            based on the state.

b_i =  0                        <==>
l_i =  L_i                      AND
t_i =  R_i - r_i

b_i =  1                        <==>
l_i =  L_i - R_i + r_i          AND
t_i =  r_i

range = 0xFF00;
end   = 0;
low   = get_bits(16);
low = range;
end = 1;
range = range * 256;
low   = low * 256;
end = 1;
rangeoff  = (range * state) / 256;
state = zero_state[state];
state  = one_state[state];
range  = rangeoff;
a = a * 2 + get_rac(c, state + 22 + min(i, 9));  // 22..31
one_state_i =
          default_state_transition_i + state_transition_delta_i

        Figure 22: Description of the coding of the state transition
                 table for a "get_rac" readout value of 1.

zero_state_i = 256 - one_state_(256-i)

        Figure 23: Description of the coding of the state transition
                 table for a "get_rac" readout value of 0.

v = get_ur_golomb(k);
run_count = 1 << log2_run[run_index];
run_count = get_bits(log2_run[run_index]);
run_count = 0;
run_mode = 2;
negative_bias = 1 << (input_bits - 1);
bits_mask = negative_bias - 1;
output_number = input_number & bits_mask; // Remove negative bit
is_negative = input_number & negative_bias; // Test negative bit
i = state->count;
k = 0;
v = get_sr_golomb(k);

v = -1 - v;
ret = sign_extend(v + state->bias, bits);

diff = get_vlc_symbol(context_state);
drift     = 0;
error_sum = 4;
bias      = 0;
count     = 1;

scale = 1                                                 |
v = 0                                                     |
ConfigurationRecordIsPresent == 1".

ConfigurationRecordIsPresent == 0".

                    +=======+=========================+
                    | value | version                 |
                    +=======+=========================+
                    | 0     | FFV1 version 0          |
                    +-------+-------------------------+
                    | 1     | FFV1 version 1          |
                    +-------+-------------------------+
                    | 2     | reserved*               |
                    +-------+-------------------------+
                    | 3     | FFV1 version 3          |
                    +-------+-------------------------+
                    | Other | reserved for future use |
                    +-------+-------------------------+

                        Table 5: The definitions for
                             "version" values.

pred = j ? initial_states[ i ][j - 1][ k ] : 128

                Figure 29: Predictor value for the coding of
                   "initial_state_delta[ i ][ j ][ k ]".

ConfigurationRecordIsPresent = 1                       |
chroma_planes == 1 && (p == 1 || p == 2)
       ? ceil(slice_pixel_height / (1 << log2_v_chroma_subsample))
       : slice_pixel_height

chroma_planes == 1 && (p == 1 || p == 2)
       ? ceil( slice_pixel_width / (1 << log2_h_chroma_subsample) )
       : slice_pixel_width.

