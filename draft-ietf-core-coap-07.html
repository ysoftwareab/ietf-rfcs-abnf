<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Constrained Application Protocol (CoAP)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Features">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Constrained Application Protocol">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Messaging Model">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Request/Response Model">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Intermediaries and Caching">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Resource Discovery">
<link href="#rfc.section.3" rel="Chapter" title="3 Message Syntax">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Message Format">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Message Size Implementation Considerations">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Option Format">
<link href="#rfc.section.4" rel="Chapter" title="4 Message Semantics">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Reliable Messages">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Unreliable Messages">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Message Types">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Confirmable (CON)">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Non-Confirmable (NON)">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Acknowledgement (ACK)">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 Reset (RST)">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Multicast">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Congestion Control">
<link href="#rfc.section.5" rel="Chapter" title="5 Request/Response Semantics">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Requests">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Responses">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Piggy-backed">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Separate">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Non-Confirmable">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Request/Response Matching">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Options">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Critical/Elective">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Length">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 Default Values">
<link href="#rfc.section.5.4.4" rel="Chapter" title="5.4.4 Repeating Options">
<link href="#rfc.section.5.4.5" rel="Chapter" title="5.4.5 Option Numbers">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Payload">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Caching">
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 Freshness Model">
<link href="#rfc.section.5.6.2" rel="Chapter" title="5.6.2 Validation Model">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Proxying">
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Method Definitions">
<link href="#rfc.section.5.8.1" rel="Chapter" title="5.8.1 GET">
<link href="#rfc.section.5.8.2" rel="Chapter" title="5.8.2 POST">
<link href="#rfc.section.5.8.3" rel="Chapter" title="5.8.3 PUT">
<link href="#rfc.section.5.8.4" rel="Chapter" title="5.8.4 DELETE">
<link href="#rfc.section.5.9" rel="Chapter" title="5.9 Response Code Definitions">
<link href="#rfc.section.5.9.1" rel="Chapter" title="5.9.1 Success 2.xx">
<link href="#rfc.section.5.9.1.1" rel="Chapter" title="5.9.1.1 2.01 Created">
<link href="#rfc.section.5.9.1.2" rel="Chapter" title="5.9.1.2 2.02 Deleted">
<link href="#rfc.section.5.9.1.3" rel="Chapter" title="5.9.1.3 2.03 Valid">
<link href="#rfc.section.5.9.1.4" rel="Chapter" title="5.9.1.4 2.04 Changed">
<link href="#rfc.section.5.9.1.5" rel="Chapter" title="5.9.1.5 2.05 Content">
<link href="#rfc.section.5.9.2" rel="Chapter" title="5.9.2 Client Error 4.xx">
<link href="#rfc.section.5.9.2.1" rel="Chapter" title="5.9.2.1 4.00 Bad Request">
<link href="#rfc.section.5.9.2.2" rel="Chapter" title="5.9.2.2 4.01 Unauthorized">
<link href="#rfc.section.5.9.2.3" rel="Chapter" title="5.9.2.3 4.02 Bad Option">
<link href="#rfc.section.5.9.2.4" rel="Chapter" title="5.9.2.4 4.03 Forbidden">
<link href="#rfc.section.5.9.2.5" rel="Chapter" title="5.9.2.5 4.04 Not Found">
<link href="#rfc.section.5.9.2.6" rel="Chapter" title="5.9.2.6 4.05 Method Not Allowed">
<link href="#rfc.section.5.9.2.7" rel="Chapter" title="5.9.2.7 4.12 Precondition Failed">
<link href="#rfc.section.5.9.2.8" rel="Chapter" title="5.9.2.8 4.13 Request Entity Too Large">
<link href="#rfc.section.5.9.2.9" rel="Chapter" title="5.9.2.9 4.15 Unsupported Media Type">
<link href="#rfc.section.5.9.3" rel="Chapter" title="5.9.3 Server Error 5.xx">
<link href="#rfc.section.5.9.3.1" rel="Chapter" title="5.9.3.1 5.00 Internal Server Error">
<link href="#rfc.section.5.9.3.2" rel="Chapter" title="5.9.3.2 5.01 Not Implemented">
<link href="#rfc.section.5.9.3.3" rel="Chapter" title="5.9.3.3 5.02 Bad Gateway">
<link href="#rfc.section.5.9.3.4" rel="Chapter" title="5.9.3.4 5.03 Service Unavailable">
<link href="#rfc.section.5.9.3.5" rel="Chapter" title="5.9.3.5 5.04 Gateway Timeout">
<link href="#rfc.section.5.9.3.6" rel="Chapter" title="5.9.3.6 5.05 Proxying Not Supported">
<link href="#rfc.section.5.10" rel="Chapter" title="5.10 Option Definitions">
<link href="#rfc.section.5.10.1" rel="Chapter" title="5.10.1 Token">
<link href="#rfc.section.5.10.2" rel="Chapter" title="5.10.2 Uri-Host, Uri-Port, Uri-Path and Uri-Query">
<link href="#rfc.section.5.10.3" rel="Chapter" title="5.10.3 Proxy-Uri">
<link href="#rfc.section.5.10.4" rel="Chapter" title="5.10.4 Content-Type">
<link href="#rfc.section.5.10.5" rel="Chapter" title="5.10.5 Accept">
<link href="#rfc.section.5.10.6" rel="Chapter" title="5.10.6 Max-Age">
<link href="#rfc.section.5.10.7" rel="Chapter" title="5.10.7 ETag">
<link href="#rfc.section.5.10.8" rel="Chapter" title="5.10.8 Location-Path and Location-Query">
<link href="#rfc.section.5.10.9" rel="Chapter" title="5.10.9 If-Match">
<link href="#rfc.section.5.10.10" rel="Chapter" title="5.10.10 If-None-Match">
<link href="#rfc.section.6" rel="Chapter" title="6 CoAP URIs">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 coap URI Scheme">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 coaps URI Scheme">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Normalization and Comparison Rules">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Decomposing URIs into Options">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Composing URIs from Options">
<link href="#rfc.section.7" rel="Chapter" title="7 Finding and Addressing CoAP End-Points">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Resource Discovery">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Content-type code 'ct' attribute">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Default Ports">
<link href="#rfc.section.8" rel="Chapter" title="8 HTTP Mapping">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 CoAP-HTTP Mapping">
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 GET">
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 PUT">
<link href="#rfc.section.8.1.3" rel="Chapter" title="8.1.3 DELETE">
<link href="#rfc.section.8.1.4" rel="Chapter" title="8.1.4 POST">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 HTTP-CoAP Mapping">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 OPTIONS and TRACE">
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 GET">
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 HEAD">
<link href="#rfc.section.8.2.4" rel="Chapter" title="8.2.4 POST">
<link href="#rfc.section.8.2.5" rel="Chapter" title="8.2.5 PUT">
<link href="#rfc.section.8.2.6" rel="Chapter" title="8.2.6 DELETE">
<link href="#rfc.section.8.2.7" rel="Chapter" title="8.2.7 CONNECT">
<link href="#rfc.section.9" rel="Chapter" title="9 Protocol Constants">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Securing CoAP with DTLS">
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 SharedKey and MultiKey Modes">
<link href="#rfc.section.10.1.2" rel="Chapter" title="10.1.2 Certificate Mode">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Using CoAP with IPsec">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Threat analysis and protocol limitations">
<link href="#rfc.section.10.3.1" rel="Chapter" title="10.3.1 Protocol Parsing, Processing URIs">
<link href="#rfc.section.10.3.2" rel="Chapter" title="10.3.2 Proxying and Caching">
<link href="#rfc.section.10.3.3" rel="Chapter" title="10.3.3 Risk of amplification">
<link href="#rfc.section.10.3.4" rel="Chapter" title="10.3.4 Cross-Protocol Attacks">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 CoAP Code Registry">
<link href="#rfc.section.11.1.1" rel="Chapter" title="11.1.1 Method Codes">
<link href="#rfc.section.11.1.2" rel="Chapter" title="11.1.2 Response Codes">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Option Number Registry">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Media Type Registry">
<link href="#rfc.section.11.4" rel="Chapter" title="11.4 URI Scheme Registration">
<link href="#rfc.section.11.5" rel="Chapter" title="11.5 Secure URI Scheme Registration">
<link href="#rfc.section.11.6" rel="Chapter" title="11.6 Service Name and Port Number Registration">
<link href="#rfc.section.11.7" rel="Chapter" title="11.7 Secure Service Name and Port Number Registration">
<link href="#rfc.section.12" rel="Chapter" title="12 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Integer Option Value Format">
<link href="#rfc.appendix.Appendix%20B" rel="Chapter" title="Appendix B Examples">
<link href="#rfc.appendix.Appendix%20C" rel="Chapter" title="Appendix C URI Examples">
<link href="#rfc.appendix.Appendix%20D" rel="Chapter" title="Appendix D Changelog">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document specifies the Constrained Application Protocol (CoAP), a specialized web transfer protocol for use with constrained networks and nodes for machine-to-machine applications such as smart energy and building automation. These constrained nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while networks such as 6LoWPAN often have high packet error rates and a typical throughput of 10s of kbit/s. CoAP provides a method/response interaction model between application end-points, supports built-in resource discovery, and includes key web concepts such as URIs and content-types. CoAP easily translates to HTTP for integration with the web while meeting specialized requirements such as multicast support, very low overhead and simplicity for constrained environments." />
  <meta name="description" content="This document specifies the Constrained Application Protocol (CoAP), a specialized web transfer protocol for use with constrained networks and nodes for machine-to-machine applications such as smart energy and building automation. These constrained nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while networks such as 6LoWPAN often have high packet error rates and a typical throughput of 10s of kbit/s. CoAP provides a method/response interaction model between application end-points, supports built-in resource discovery, and includes key web concepts such as URIs and content-types. CoAP easily translates to HTTP for integration with the web while meeting specialized requirements such as multicast support, very low overhead and simplicity for constrained environments." />
  <meta name="keywords" content="CoAP, Constrained Application Protocol, REST" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CoRE Working Group</td>
<td class="right">Z. Shelby</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Sensinode</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">K. Hartke</td>
</tr>
<tr>
<td class="left">Expires: January 09, 2012</td>
<td class="right">C. Bormann</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Universitaet Bremen TZI</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">B. Frank</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">SkyFoundry</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 08, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Constrained Application Protocol (CoAP)<br />
  <span class="filename">draft-ietf-core-coap-07</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document specifies the Constrained Application Protocol (CoAP), a specialized web transfer protocol for use with constrained networks and nodes for machine-to-machine applications such as smart energy and building automation. These constrained nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while networks such as 6LoWPAN often have high packet error rates and a typical throughput of 10s of kbit/s. CoAP provides a method/response interaction model between application end-points, supports built-in resource discovery, and includes key web concepts such as URIs and content-types. CoAP easily translates to HTTP for integration with the web while meeting specialized requirements such as multicast support, very low overhead and simplicity for constrained environments.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 09, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Features</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
<li>2.   <a href="#rfc.section.2">Constrained Application Protocol</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Messaging Model</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Request/Response Model</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Intermediaries and Caching</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Resource Discovery</a>
</li>
<li>3.   <a href="#rfc.section.3">Message Syntax</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Message Format</a>
</li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">Message Size Implementation Considerations</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Option Format</a>
</li>
<li>4.   <a href="#rfc.section.4">Message Semantics</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Reliable Messages</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Unreliable Messages</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Message Types</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Confirmable (CON)</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Non-Confirmable (NON)</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Acknowledgement (ACK)</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">Reset (RST)</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Multicast</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Congestion Control</a>
</li>
<li>5.   <a href="#rfc.section.5">Request/Response Semantics</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Requests</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Responses</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">Piggy-backed</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Separate</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Non-Confirmable</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Request/Response Matching</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Options</a>
</li>
<li>5.4.1.   <a href="#rfc.section.5.4.1">Critical/Elective</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Length</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">Default Values</a>
</li>
<li>5.4.4.   <a href="#rfc.section.5.4.4">Repeating Options</a>
</li>
<li>5.4.5.   <a href="#rfc.section.5.4.5">Option Numbers</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Payload</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Caching</a>
</li>
<li>5.6.1.   <a href="#rfc.section.5.6.1">Freshness Model</a>
</li>
<li>5.6.2.   <a href="#rfc.section.5.6.2">Validation Model</a>
</li>
<li>5.7.   <a href="#rfc.section.5.7">Proxying</a>
</li>
<li>5.8.   <a href="#rfc.section.5.8">Method Definitions</a>
</li>
<li>5.8.1.   <a href="#rfc.section.5.8.1">GET</a>
</li>
<li>5.8.2.   <a href="#rfc.section.5.8.2">POST</a>
</li>
<li>5.8.3.   <a href="#rfc.section.5.8.3">PUT</a>
</li>
<li>5.8.4.   <a href="#rfc.section.5.8.4">DELETE</a>
</li>
<li>5.9.   <a href="#rfc.section.5.9">Response Code Definitions</a>
</li>
<li>5.9.1.   <a href="#rfc.section.5.9.1">Success 2.xx</a>
</li>
<li>5.9.1.1.   <a href="#rfc.section.5.9.1.1">2.01 Created</a>
</li>
<li>5.9.1.2.   <a href="#rfc.section.5.9.1.2">2.02 Deleted</a>
</li>
<li>5.9.1.3.   <a href="#rfc.section.5.9.1.3">2.03 Valid</a>
</li>
<li>5.9.1.4.   <a href="#rfc.section.5.9.1.4">2.04 Changed</a>
</li>
<li>5.9.1.5.   <a href="#rfc.section.5.9.1.5">2.05 Content</a>
</li>
<li>5.9.2.   <a href="#rfc.section.5.9.2">Client Error 4.xx</a>
</li>
<li>5.9.2.1.   <a href="#rfc.section.5.9.2.1">4.00 Bad Request</a>
</li>
<li>5.9.2.2.   <a href="#rfc.section.5.9.2.2">4.01 Unauthorized</a>
</li>
<li>5.9.2.3.   <a href="#rfc.section.5.9.2.3">4.02 Bad Option</a>
</li>
<li>5.9.2.4.   <a href="#rfc.section.5.9.2.4">4.03 Forbidden</a>
</li>
<li>5.9.2.5.   <a href="#rfc.section.5.9.2.5">4.04 Not Found</a>
</li>
<li>5.9.2.6.   <a href="#rfc.section.5.9.2.6">4.05 Method Not Allowed</a>
</li>
<li>5.9.2.7.   <a href="#rfc.section.5.9.2.7">4.12 Precondition Failed</a>
</li>
<li>5.9.2.8.   <a href="#rfc.section.5.9.2.8">4.13 Request Entity Too Large</a>
</li>
<li>5.9.2.9.   <a href="#rfc.section.5.9.2.9">4.15 Unsupported Media Type</a>
</li>
<li>5.9.3.   <a href="#rfc.section.5.9.3">Server Error 5.xx</a>
</li>
<li>5.9.3.1.   <a href="#rfc.section.5.9.3.1">5.00 Internal Server Error</a>
</li>
<li>5.9.3.2.   <a href="#rfc.section.5.9.3.2">5.01 Not Implemented</a>
</li>
<li>5.9.3.3.   <a href="#rfc.section.5.9.3.3">5.02 Bad Gateway</a>
</li>
<li>5.9.3.4.   <a href="#rfc.section.5.9.3.4">5.03 Service Unavailable</a>
</li>
<li>5.9.3.5.   <a href="#rfc.section.5.9.3.5">5.04 Gateway Timeout</a>
</li>
<li>5.9.3.6.   <a href="#rfc.section.5.9.3.6">5.05 Proxying Not Supported</a>
</li>
<li>5.10.   <a href="#rfc.section.5.10">Option Definitions</a>
</li>
<li>5.10.1.   <a href="#rfc.section.5.10.1">Token</a>
</li>
<li>5.10.2.   <a href="#rfc.section.5.10.2">Uri-Host, Uri-Port, Uri-Path and Uri-Query</a>
</li>
<li>5.10.3.   <a href="#rfc.section.5.10.3">Proxy-Uri</a>
</li>
<li>5.10.4.   <a href="#rfc.section.5.10.4">Content-Type</a>
</li>
<li>5.10.5.   <a href="#rfc.section.5.10.5">Accept</a>
</li>
<li>5.10.6.   <a href="#rfc.section.5.10.6">Max-Age</a>
</li>
<li>5.10.7.   <a href="#rfc.section.5.10.7">ETag</a>
</li>
<li>5.10.8.   <a href="#rfc.section.5.10.8">Location-Path and Location-Query</a>
</li>
<li>5.10.9.   <a href="#rfc.section.5.10.9">If-Match</a>
</li>
<li>5.10.10.   <a href="#rfc.section.5.10.10">If-None-Match</a>
</li>
<li>6.   <a href="#rfc.section.6">CoAP URIs</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">coap URI Scheme</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">coaps URI Scheme</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Normalization and Comparison Rules</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Decomposing URIs into Options</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Composing URIs from Options</a>
</li>
<li>7.   <a href="#rfc.section.7">Finding and Addressing CoAP End-Points</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Resource Discovery</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">Content-type code 'ct' attribute</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Default Ports</a>
</li>
<li>8.   <a href="#rfc.section.8">HTTP Mapping</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">CoAP-HTTP Mapping</a>
</li>
<li>8.1.1.   <a href="#rfc.section.8.1.1">GET</a>
</li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">PUT</a>
</li>
<li>8.1.3.   <a href="#rfc.section.8.1.3">DELETE</a>
</li>
<li>8.1.4.   <a href="#rfc.section.8.1.4">POST</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">HTTP-CoAP Mapping</a>
</li>
<li>8.2.1.   <a href="#rfc.section.8.2.1">OPTIONS and TRACE</a>
</li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">GET</a>
</li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">HEAD</a>
</li>
<li>8.2.4.   <a href="#rfc.section.8.2.4">POST</a>
</li>
<li>8.2.5.   <a href="#rfc.section.8.2.5">PUT</a>
</li>
<li>8.2.6.   <a href="#rfc.section.8.2.6">DELETE</a>
</li>
<li>8.2.7.   <a href="#rfc.section.8.2.7">CONNECT</a>
</li>
<li>9.   <a href="#rfc.section.9">Protocol Constants</a>
</li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>10.1.   <a href="#rfc.section.10.1">Securing CoAP with DTLS</a>
</li>
<li>10.1.1.   <a href="#rfc.section.10.1.1">SharedKey and MultiKey Modes</a>
</li>
<li>10.1.2.   <a href="#rfc.section.10.1.2">Certificate Mode</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Using CoAP with IPsec</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Threat analysis and protocol limitations</a>
</li>
<li>10.3.1.   <a href="#rfc.section.10.3.1">Protocol Parsing, Processing URIs</a>
</li>
<li>10.3.2.   <a href="#rfc.section.10.3.2">Proxying and Caching</a>
</li>
<li>10.3.3.   <a href="#rfc.section.10.3.3">Risk of amplification</a>
</li>
<li>10.3.4.   <a href="#rfc.section.10.3.4">Cross-Protocol Attacks</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>11.1.   <a href="#rfc.section.11.1">CoAP Code Registry</a>
</li>
<li>11.1.1.   <a href="#rfc.section.11.1.1">Method Codes</a>
</li>
<li>11.1.2.   <a href="#rfc.section.11.1.2">Response Codes</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">Option Number Registry</a>
</li>
<li>11.3.   <a href="#rfc.section.11.3">Media Type Registry</a>
</li>
<li>11.4.   <a href="#rfc.section.11.4">URI Scheme Registration</a>
</li>
<li>11.5.   <a href="#rfc.section.11.5">Secure URI Scheme Registration</a>
</li>
<li>11.6.   <a href="#rfc.section.11.6">Service Name and Port Number Registration</a>
</li>
<li>11.7.   <a href="#rfc.section.11.7">Secure Service Name and Port Number Registration</a>
</li>
<li>12.   <a href="#rfc.section.12">Acknowledgements</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Integer Option Value Format</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.Appendix%20B">Examples</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.Appendix%20C">URI Examples</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.Appendix%20D">Changelog</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The use of web services on the Internet has become ubiquitous in most applications, and depends on the fundamental Representational State Transfer (REST) architecture of the web.</p>
<p id="rfc.section.1.p.2">The Constrained RESTful Environments (CoRE) working group aims at realizing the REST architecture in a suitable form for the most constrained nodes (e.g. 8-bit microcontrollers with limited RAM and ROM) and networks (e.g. 6LoWPAN). Constrained networks like 6LoWPAN support the expensive fragmentation of IPv6 packets into small link-layer frames. One design goal of CoAP has been to keep message overhead small, thus limiting the use of fragmentation.</p>
<p id="rfc.section.1.p.3">One of the main goals of CoAP is to design a generic web protocol for the special requirements of this constrained environment, especially considering energy, building automation and other M2M applications. The goal of CoAP is not to blindly compress HTTP <a href="#RFC2616">[RFC2616]</a>, but rather to realize a subset of REST common with HTTP but optimized for M2M applications.  Although CoAP could be used for compressing simple HTTP interfaces, it more importantly also offers features for M2M such as built-in discovery, multicast support and asynchronous message exchanges.</p>
<p id="rfc.section.1.p.4">This document specifies the Constrained Application Protocol (CoAP), which easily translates to HTTP for integration with the existing web while meeting specialized requirements such as multicast support, very low overhead and simplicity for constrained environments and M2M applications.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#features" id="features">Features</a>
</h1>
<p id="rfc.section.1.1.p.1">CoAP has the following main features: </p>

<ul>
<li>Constrained web protocol fulfilling M2M requirements.</li>
<li>UDP binding with optional reliability supporting unicast and multicast requests.</li>
<li>Asynchronous message exchanges.</li>
<li>Low header overhead and parsing complexity.</li>
<li>URI and Content-type support.</li>
<li>Simple proxy and caching capabilities.</li>
<li>A stateless HTTP mapping, allowing proxies to be built providing access to CoAP resources via HTTP in a uniform way or for HTTP simple interfaces to be realized alternatively over CoAP.</li>
<li>Security binding to Datagram Transport Layer Security (DTLS).</li>
</ul>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.2.p.2">This specification requires readers to be familiar with all the terms and concepts that are discussed in <a href="#RFC2616">[RFC2616]</a>. In addition, this specification defines the following terminology: </p>

<dl>
<dt>Piggy-backed Response</dt>
<dd style="margin-left: 8">
<br> A Piggy-backed Response is included right in a CoAP Acknowledgement (ACK) message that is sent to acknowledge receipt of the Request for this Response (<a href="#pb">Section 5.2.1</a>).</dd>
<dt>Separate Response</dt>
<dd style="margin-left: 8">
<br> When a Confirmable message carrying a Request is acknowledged with an empty message (e.g., because the server doesn't have the answer right away), a Separate Response is sent in a separate message exchange (<a href="#npb">Section 5.2.2</a>). </dd>
<dt>Critical Option</dt>
<dd style="margin-left: 8">
<br> An option that would need to be understood by the end-point receiving the message in order to properly process the message (<a href="#critical-elective">Section 5.4.1</a>).  Note that the implementation of critical options is, as the name "Option" implies, generally optional: unsupported critical options lead to rejection of the message.  </dd>
<dt>Elective Option</dt>
<dd style="margin-left: 8">
<br> An option that is intended be ignored by an end-point that does not understand it, which nonetheless still can correctly process the message (<a href="#critical-elective">Section 5.4.1</a>).  </dd>
<dt>Resource Discovery</dt>
<dd style="margin-left: 8">
<br> The process where a CoAP client queries a server for its list of hosted resources (i.e., links, <a href="#discovery">Section 7.1</a>).  </dd>
<dt>End-Point</dt>
<dd style="margin-left: 8">
<br>An entity participating in the CoAP protocol.  Colloquially, a synonym is "Node", although "Host" would be more consistent with Internet standards usage.</dd>
<dt>Sender</dt>
<dd style="margin-left: 8">
<br>The originating end-point of a message.</dd>
<dt>Recipient</dt>
<dd style="margin-left: 8">
<br>The destination end-point of a message.</dd>
<dt>Client</dt>
<dd style="margin-left: 8">
<br>The originating end-point of a request; the destination end-point of a response.</dd>
<dt>Server</dt>
<dd style="margin-left: 8">
<br>The destination end-point of a request; the originating end-point of a response.</dd>
<dt>Origin Server</dt>
<dd style="margin-left: 8">
<br> The server on which a given resource resides or is to be created.  </dd>
<dt>Intermediary</dt>
<dd style="margin-left: 8">
<br>A CoAP end-point that acts both as a server and as a client towards (possibly via further intermediaries) an origin server.  There are two common forms of intermediary: proxy and reverse proxy. In some cases, a single end-point might act as an origin server, proxy, or reverse proxy, switching behavior based on the nature of each request.</dd>
<dt>Proxy</dt>
<dd style="margin-left: 8">
<br>A "proxy" is an end-point selected by a client, usually via local configuration rules, to perform requests on behalf of the client, doing any necessary translations. Some translations are minimal, such as for proxy requests for "coap" URIs, whereas other requests might require translation to and from entirely different application-layer protocols.</dd>
<dt>Reverse Proxy</dt>
<dd style="margin-left: 8">
<br>A "reverse proxy" is an end-point that acts as a layer above some other server(s) and satisfies requests on behalf of these, doing any necessary translations. Unlike a proxy, a reverse proxy receives requests as if it was the origin server for the target resource; the requesting client will not be aware that it is communicating with a reverse proxy.</dd>
</dl>

<p> </p>
<p id="rfc.section.1.2.p.3">In this specification, the term "byte" is used in its now customary sense as a synonym for "octet".</p>
<p id="rfc.section.1.2.p.4">In this specification, the operator "^" stands for exponentiation.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#protocol" id="protocol">Constrained Application Protocol</a>
</h1>
<p id="rfc.section.2.p.1">The interaction model of CoAP is similar to the client/server model of HTTP. However, machine-to-machine interactions typically result in a CoAP implementation acting in both client and server roles (called an end-point). A CoAP request is equivalent to that of HTTP, and is sent by a client to request an action (using a method code) on a resource (identified by a URI) on a server. The server then sends a response with a response code; this response may include a resource representation.</p>
<p id="rfc.section.2.p.2">Unlike HTTP, CoAP deals with these interchanges asynchronously over a datagram-oriented transport such as UDP. This is done logically using a layer of messages that supports optional reliability (with exponential back-off). CoAP defines four types of messages: Confirmable, Non-Confirmable, Acknowledgement, Reset; method codes and response codes included in some of these messages make them carry requests or responses.  The basic exchanges of the four types of messages are transparent to the request/response interactions.</p>
<p id="rfc.section.2.p.3">One could think of CoAP logically as using a two-layer approach, a CoAP messaging layer used to deal with UDP and the asynchronous nature of the interactions, and the request/response interactions using Method and Response codes (see <a href="#fig-layers">Figure 1</a>). CoAP is however a single protocol, with messaging and request/response just features of the CoAP header.</p>
<div id="#rfc.figure.1"></div>
<div id="#fig-layers"></div>
<pre>
      +----------------------+
      |      Application     |
      +----------------------+
      +----------------------+
      |  Requests/Responses  |
      |----------------------|  CoAP
      |       Messages       |
      +----------------------+
      +----------------------+
      |          UDP         |
      +----------------------+
</pre>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Messaging Model</h1>
<p id="rfc.section.2.1.p.1">The CoAP messaging model is based on the exchange of messages over UDP between end-points.</p>
<p id="rfc.section.2.1.p.2">CoAP uses a short fixed-length binary header (4 bytes) that may be followed by compact binary options and a payload. This message format is shared by requests and responses.  The CoAP message format is specified in <a href="#syntax">Section 3</a>.  Each message contains a Message ID used to detect duplicates and for optional reliability.</p>
<p id="rfc.section.2.1.p.3">Reliability is provided by marking a message as Confirmable (CON). A Confirmable message is retransmitted using a default timeout and exponential back-off between retransmissions, until the recipient sends an Acknowledgement message (ACK) with the same Message ID (for example, 0x7d34) from the corresponding end-point; see <a href="#fig-reliable">Figure 2</a>.  When a recipient is not able to process a Confirmable message, it replies with a Reset message (RST) instead of an Acknowledgement (ACK). </p>
<div id="#rfc.figure.2"></div>
<div id="#fig-reliable"></div>
<pre>
Client              Server
   |                  |
   |   CON [0x7d34]   |
   +-----------------&gt;|
   |                  |
   |   ACK [0x7d34]   |
   |&lt;-----------------+
   |                  |
</pre>
<p id="rfc.section.2.1.p.4">A message that does not require reliable delivery, for example each single measurement out of a stream of sensor data, can be sent as a Non-confirmable message (NON).  These are not acknowledged, but still have a Message ID for duplicate detection; see <a href="#fig-unreliable">Figure 3</a>.</p>
<div id="#rfc.figure.3"></div>
<div id="#fig-unreliable"></div>
<pre>
Client              Server
   |                  |
   |   NON [0x01a0]   |
   +-----------------&gt;|
   |                  |
</pre>
<p id="rfc.section.2.1.p.5">See <a href="#messages">Section 4</a> for details of CoAP messages.</p>
<p id="rfc.section.2.1.p.6">As CoAP is based on UDP, it also supports the use of multicast IP destination addresses, enabling multicast CoAP requests. <a href="#multicast">Section 4.4</a> discusses the proper use of CoAP messages with multicast addresses and precautions for avoiding response congestion.</p>
<p id="rfc.section.2.1.p.7">Several security modes are defined for CoAP in <a href="#security">Section 10</a> ranging from no security to certificate-based security. The use of IPsec along with a binding to DTLS are specified for securing the protocol.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Request/Response Model</h1>
<p id="rfc.section.2.2.p.1">CoAP request and response semantics are carried in CoAP messages, which include either a method code or response code, respectively. Optional (or default) request and response information, such as the URI and payload content-type are carried as CoAP options. A Token Option is used to match responses to requests independently from the underlying messages (<a href="#response-matching">Section 5.3</a>).</p>
<p id="rfc.section.2.2.p.2">A request is carried in a Confirmable (CON) or Non-confirmable (NON) message, and if immediately available, the response to a request carried in a Confirmable message is carried in the resulting Acknowledgement (ACK) message. This is called a piggy-backed response, detailed in <a href="#pb">Section 5.2.1</a>. Two examples for a basic GET request with piggy-backed response are shown in <a href="#example-pb">Figure 4</a>.</p>
<div id="#rfc.figure.4"></div>
<div id="#example-pb"></div>
<pre>
Client              Server       Client              Server
   |                  |             |                  |
   |   CON [0xbc90]   |             |   CON [0xbc91]   |
   | GET /temperature |             | GET /temperature |
   |   (Token 0x71)   |             |   (Token 0x72)   |
   +-----------------&gt;|             +-----------------&gt;|
   |                  |             |                  |
   |   ACK [0xbc90]   |             |   ACK [0xbc91]   |
   |   2.05 Content   |             |  4.04 Not Found  |
   |   (Token 0x71)   |             |   (Token 0x72)   |
   |     "22.5 C"     |             |   "Not found"    |
   |&lt;-----------------+             |&lt;-----------------+
   |                  |             |                  |
</pre>
<p id="rfc.section.2.2.p.3">If the server is not able to respond immediately to a request carried in a Confirmable message, it simply responds with an empty Acknowledgement message so that the client can stop retransmitting the request.  When the response is ready, the server sends it in a new Confirmable message (which then in turn needs to be acknowledged by the client).  This is called a separate response, as illustrated in <a href="#example-npb">Figure 5</a> and described in more detail in <a href="#npb">Section 5.2.2</a>.</p>
<div id="#rfc.figure.5"></div>
<div id="#example-npb"></div>
<pre>
Client              Server
   |                  |
   |   CON [0x7a10]   |
   | GET /temperature |
   |   (Token 0x73)   |
   +-----------------&gt;|
   |                  |
   |   ACK [0x7a10]   |
   |&lt;-----------------+
   |                  |
   ... Time Passes  ...
   |                  |
   |   CON [0x23bb]   |
   |   2.05 Content   |
   |   (Token 0x73)   |
   |     "22.5 C"     |
   |&lt;-----------------+
   |                  |
   |   ACK [0x23bb]   |
   +-----------------&gt;|
   |                  |
</pre>
<p id="rfc.section.2.2.p.4">Likewise, if a request is sent in a Non-Confirmable message, then the response is usually sent using a new Non-Confirmable message, although the server may send a Confirmable message.  This type of exchange is illustrated in <a href="#example-non">Figure 6</a>.  </p>
<div id="#rfc.figure.6"></div>
<div id="#example-non"></div>
<pre>
Client              Server
   |                  |
   |   NON [0x7a11]   |
   | GET /temperature |
   |   (Token 0x74)   |
   +-----------------&gt;|
   |                  |
   |   NON [0x23bc]   |
   |   2.05 Content   |
   |   (Token 0x74)   |
   |     "22.5 C"     |
   |&lt;-----------------+
   |                  |
</pre>
<p id="rfc.section.2.2.p.5">CoAP makes use of GET, PUT, POST and DELETE methods in a similar manner to HTTP, with the semantics specified in <a href="#methods">Section 5.8</a>.  (Note that the detailed semantics of CoAP methods are "almost, but not entirely unlike" those of HTTP methods: Intuition taken from HTTP experience generally does apply well, but there are enough differences that make it worthwhile to actually read the present specification.)</p>
<p id="rfc.section.2.2.p.6">URI support in a server is simplified as the client already parses the URI and splits it into host, port, path and query components, making use of default values for efficiency. Response codes correspond to a small subset of HTTP response codes with a few CoAP specific codes added, as defined in <a href="#response-codes">Section 5.9</a>.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Intermediaries and Caching</h1>
<p id="rfc.section.2.3.p.1">The protocol supports the caching of responses in order to efficiently fulfill requests. Simple caching is enabled using freshness and validity information carried with CoAP responses. A cache could be located in an end-point or an intermediary. Caching functionality is specified in <a href="#caching">Section 5.6</a>.</p>
<p id="rfc.section.2.3.p.2">Proxying is useful in constrained networks for several reasons, including network traffic limiting, to improve performance, to access resources of sleeping devices or for security reasons. The proxying of requests on behalf of another CoAP end-point is supported in the protocol. The URI of the resource to request is included in the request, while the destination IP address is set to the proxy. See <a href="#proxying">Section 5.7</a> for more information on proxy functionality. </p>
<p id="rfc.section.2.3.p.3">As CoAP was designed according to the REST architecture and thus exhibits functionality similar to that of the HTTP protocol, it is quite straightforward to map between HTTP-CoAP or CoAP-HTTP. Such a mapping may be used to realize an HTTP REST interface using CoAP, or for converting between HTTP and CoAP. This conversion can be carried out by a proxy, which converts the method or response code, content-type and options to the corresponding HTTP feature. <a href="#http">Section 8</a> provides more detail about HTTP mapping. </p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> Resource Discovery</h1>
<p id="rfc.section.2.4.p.1">Resource discovery is important for machine-to-machine interactions, and is supported using the CoRE Link Format <a href="#I-D.ietf-core-link-format">[I-D.ietf-core-link-format]</a> as discussed in <a href="#discovery">Section 7.1</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#syntax" id="syntax">Message Syntax</a>
</h1>
<p id="rfc.section.3.p.1">CoAP is based on the exchange of short messages which, by default, are transported over UDP (i.e. each CoAP message occupies the data section of one UDP datagram). CoAP may be used with Datagram Transport Layer Security (DTLS) (see <a href="#dtls">Section 10.1</a>). It could also be used over other transports such as TCP or SCTP, the specification of which is out of this document's scope.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#message-format" id="message-format">Message Format</a>
</h1>
<p id="rfc.section.3.1.p.1">CoAP messages are encoded in a simple binary format. A message consists of a fixed-sized CoAP Header followed by options in Type-Length-Value (TLV) format and a payload. The number of options is determined by the header. The payload is made up of the bytes after the options, if any; its length is calculated from the datagram length.</p>
<div id="#rfc.figure.7"></div>
<div id="#fig-message-format"></div>
<pre>
  0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver| T |  OC   |      Code     |          Message ID           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Options (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Payload (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.3.1.p.2">The fields in the header are defined as follows: </p>

<dl>
<dt>Version (Ver):</dt>
<dd style="margin-left: 8">2-bit unsigned integer. Indicates the CoAP version number. Implementations of this specification MUST set this field to 1. Other values are reserved for future versions.</dd>
<dt>Type (T):</dt>
<dd style="margin-left: 8">2-bit unsigned integer. Indicates if this message is of type Confirmable (0), Non-Confirmable (1), Acknowledgement (2) or Reset (3). See <a href="#messages">Section 4</a> for the semantics of these message types.</dd>
<dt>Option Count (OC):</dt>
<dd style="margin-left: 8">4-bit unsigned integer. Indicates the number of options after the header. If set to 0, there are no options and the payload (if any) immediately follows the header.  The format of options is defined below.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">8-bit unsigned integer. Indicates if the message carries a request (1-31) or a response (64-191), or is empty (0).  (All other code values are reserved.) In case of a request, the Code field indicates the Request Method; in case of a response a Response Code. Possible values are maintained in the <a href="#coap-code-registry">CoAP Code Registry</a> <cite title="NONE">[coap-code-registry]</cite>.  See <a href="#requests-responses">Section 5</a> for the semantics of requests and responses.</dd>
<dt>Message ID:</dt>
<dd style="margin-left: 8">16-bit unsigned integer. Used for the detection of message duplication, and to match messages of type Acknowledgement/Reset and messages of type Confirmable. See <a href="#messages">Section 4</a> for Message ID generation rules and how messages are matched.</dd>
</dl>

<p> </p>
<p id="rfc.section.3.1.p.3">While specific link layers make it beneficial to keep CoAP messages small enough to fit into their link layer packets (see <a href="#introduction">Section 1</a>), this is a matter of implementation quality. The CoAP specification itself provides only an upper bound to the message size. Messages larger than an IP fragment result in undesired packet fragmentation.  A CoAP message, appropriately encapsulated, SHOULD fit within a single IP packet (i.e., avoid IP fragmentation) and MUST fit within a single IP datagram. If the Path MTU is not known for a destination, an IP MTU of 1280 bytes SHOULD be assumed; if nothing is known about the size of the headers, good upper bounds are 1152 bytes for the message size and 1024 bytes for the payload size. </p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#message-size-considerations" id="message-size-considerations">Message Size Implementation Considerations</a>
</h1>
<p id="rfc.section.3.1.1.p.1">Note that CoAP's choice of message size parameters works well with IPv6 and with most of today's IPv4 paths.  (However, with IPv4, it is harder to absolutely ensure that there is no IP fragmentation. If IPv4 support on unusual networks is a consideration, implementations may want to limit themselves to more conservative IPv4 datagram sizes such as 576 bytes; worse, the absolute minimum value of the IP MTU for IPv4 is as low as 68 bytes, which would leave only 40 bytes minus security overhead for a UDP payload.  Implementations extremely focused on this problem set might also set the IPv4 DF bit and perform some form of path MTU discovery; this should generally be unnecessary in most realistic use cases for CoAP, however.)  A more important kind of fragmentation in many constrained networks is that on the adaptation layer (e.g., 6LoWPAN L2 packets are limited to 127 bytes including various overheads); this may motivate implementations to be frugal in their packet sizes and to move to block-wise transfers <a href="#I-D.ietf-core-block">[I-D.ietf-core-block]</a> when approaching three-digit message sizes.  </p>
<p id="rfc.section.3.1.1.p.2">Note that message sizes are also of considerable importance to implementations on constrained nodes.  Many implementations will need to allocate a buffer for incoming messages.  If an implementation is too constrained to allow for allocating the above-mentioned upper bound, it could apply the following implementation strategy: Implementations receiving a datagram into a buffer that is too small are usually able to determine if the trailing portion of a datagram was discarded and to retrieve the initial portion. So, if not all of the payload, at least the CoAP header and options are likely to fit within the buffer.  A server can thus fully interpret a request and return a 4.13 (Request Entity Too Large) response code if the payload was truncated. A client sending an idempotent request and receiving a response larger than would fit in the buffer can repeat the request with a suitable value for the Block Option <a href="#I-D.ietf-core-block">[I-D.ietf-core-block]</a>.  </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#option-format" id="option-format">Option Format</a>
</h1>
<p id="rfc.section.3.2.p.1">Options MUST appear in order of their Option Number (see <a href="#option-numbers">Section 5.4.5</a>). A delta encoding is used between options, with the Option Number for each Option calculated as the sum of its Option Delta field and the Option Number of the preceding Option in the message, if any, or zero otherwise.  Multiple options with the same Option Number can be included by using an Option Delta of zero.  Following the Option Delta, each option has a Length field which specifies the length of the Option Value, in bytes. The Length field can be extended by one byte for options with values longer than 14 bytes.  The Option Value immediately follows the Length field.</p>
<div id="#rfc.figure.8"></div>
<div id="#fig-option-format"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| Option Delta  |    Length     | for 0..14
+---+---+---+---+---+---+---+---+
|   Option Value ...
+---+---+---+---+---+---+---+---+
                                            for 15..270:
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| Option Delta  | 1   1   1   1 |          Length - 15          |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|   Option Value ...
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>
<p id="rfc.section.3.2.p.2">The fields in an option are defined as follows: </p>

<dl>
<dt>Option Delta:</dt>
<dd style="margin-left: 8">4-bit unsigned integer.  Indicates the difference between the Option Number of this option and the previous option (or zero for the first option). In other words, the Option Number is calculated by simply summing the Option Delta fields of this and previous options before it. The Option Numbers 14, 28, 42, ... are reserved for no-op options when they are sent with an empty value (they are ignored) and can be used as "fenceposts" if deltas larger than 15 would otherwise be required.</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">Indicates the length of the Option Value, in bytes.  Normally Length is a 4-bit unsigned integer allowing value lengths of 0-14 bytes. When the Length field is set to 15, another byte is added as an 8-bit unsigned integer whose value is added to the 15, allowing option value lengths of 15-270 bytes.</dd>
</dl>

<p> </p>
<p id="rfc.section.3.2.p.3">The length and format of the Option Value depends on the respective option, which MAY define variable length values. Options defined in this document make use of the following formats for option values: </p>

<dl>
<dt>uint:</dt>
<dd style="margin-left: 7">A non-negative integer which is represented in network byte order using a variable number of bytes (see <a href="#integer">Appendix Appendix A</a>).</dd>
<dt>string:</dt>
<dd style="margin-left: 7">A Unicode string which is encoded using <a href="#RFC3629">UTF-8</a> <cite title="NONE">[RFC3629]</cite> in <a href="#RFC5198">Net-Unicode form</a> <cite title="NONE">[RFC5198]</cite>.  Note that here and in all other places where UTF-8 encoding is used in the CoAP protocol, the intention is that the encoded strings can be directly used and compared as opaque byte strings by CoAP protocol implementations.  There is no expectation and no need to perform normalization within a CoAP implementation unless Unicode strings that are not known to be normalized are imported from sources outside the CoAP protocol.  Note also that ASCII strings (that do not make use of special control characters) are always valid UTF-8 Net-Unicode strings.  </dd>
<dt>opaque:</dt>
<dd style="margin-left: 7">An opaque sequence of bytes.</dd>
</dl>

<p> </p>
<p id="rfc.section.3.2.p.4">Option Numbers are maintained in the <a href="#option-number-registry">CoAP Option Number Registry</a> <cite title="NONE">[option-number-registry]</cite>.  See <a href="#options">Section 5.10</a> for the semantics of the options defined in this document.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#messages" id="messages">Message Semantics</a>
</h1>
<p id="rfc.section.4.p.1">CoAP messages are exchanged asynchronously between CoAP end-points.  They are used to transport CoAP requests and responses, the semantics of which are defined in <a href="#requests-responses">Section 5</a>.</p>
<p id="rfc.section.4.p.2">As CoAP is bound to non-reliable transports such as UDP, CoAP messages may arrive out of order, appear duplicated, or go missing without notice. For this reason, CoAP implements a lightweight reliability mechanism, without trying to re-create the full feature set of a transport like TCP.  It has the following features: </p>

<ul>
<li>Simple stop-and-wait retransmission reliability with exponential back-off for "confirmable" messages.</li>
<li>Duplicate detection for both "confirmable" and "non-confirmable" messages.</li>
<li>Multicast support.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#reliable" id="reliable">Reliable Messages</a>
</h1>
<p id="rfc.section.4.1.p.1">The reliable transmission of a message is initiated by marking the message as "confirmable" in the CoAP header. A recipient MUST acknowledge such a message with an acknowledgement message (or, if it lacks context to process the message properly, MUST reject it with a reset message). The sender retransmits the confirmable message at exponentially increasing intervals, until it receives an acknowledgement (or reset message), or runs out of attempts.</p>
<p id="rfc.section.4.1.p.2">Retransmission is controlled by two things that a CoAP end-point MUST keep track of for each confirmable message it sends while waiting for an acknowledgement (or reset): a timeout and a retransmission counter. For a new confirmable message, the initial timeout is set to a random number between RESPONSE_TIMEOUT and (RESPONSE_TIMEOUT * RESPONSE_RANDOM_FACTOR), and the retransmission counter is set to 0. When the timeout is triggered and the retransmission counter is less than MAX_RETRANSMIT, the message is retransmitted, the retransmission counter is incremented, and the timeout is doubled. If the retransmission counter reaches MAX_RETRANSMIT on a timeout, or if the end-point receives a reset message, then the attempt to transmit the message is canceled and the application process informed of failure. On the other hand, if the end-point receives an acknowledgement message in time, transmission is considered successful.</p>
<p id="rfc.section.4.1.p.3">An acknowledgement or reset message is related to a confirmable message by means of a Message ID along with additional address information of the corresponding end-point. The Message ID is a 16-bit unsigned integer that is generated by the sender of a confirmable message and included in the CoAP header. The Message ID MUST be echoed in the acknowledgement or reset message by the recipient.</p>
<p id="rfc.section.4.1.p.4">Several implementation strategies can be employed for generating Message IDs. In the simplest case a CoAP end-point generates Message IDs by keeping a single Message ID variable, which is changed each time a new confirmable message is sent regardless of the destination address or port. End-points dealing with large numbers of transactions could keep multiple Message ID variables, for example per prefix or destination address. The initial variable value SHOULD be randomized. The same Message ID MUST NOT be re-used within the potential retransmission window, calculated as RESPONSE_TIMEOUT * RESPONSE_RANDOM_FACTOR * (2 ^ MAX_RETRANSMIT - 1) plus the expected maximum round trip time.</p>
<p id="rfc.section.4.1.p.5">A recipient MUST be prepared to receive the same confirmable message (as indicated by the Message ID) multiple times, for example, when its acknowledgement went missing or didn't reach the original sender before the first timeout. The recipient SHOULD acknowledge each duplicate copy of a confirmable message using the same acknowledgement or reset message, but SHOULD process any request or response in the message only once.  This rule MAY be relaxed in case the confirmable message transports a request that is idempotent (see <a href="#request-semantics">Section 5.1</a>).  Examples for relaxed message deduplication: </p>

<ul>
<li>A server MAY relax the requirement to answer all retransmissions of an idempotent request with the same response (<a href="#reliable">Section 4.1</a>), so that it does not have to maintain state for Message IDs.  For example, an implementation might want to process duplicate transmissions of a GET, PUT or DELETE request as separate requests if the effort incurred by duplicate processing is less expensive than keeping track of previous responses would be.</li>
<li>(As an implementation consideration, a constrained server MAY even want to relax this requirement for certain non-idempotent requests if the application semantics make this trade-off favorable.  For example, if the result of a POST request is just the creation of some short-lived state at the server, it may be less expensive to incur this effort multiple times for a request than keeping track of whether a previous transmission of the same request already was processed.)</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.p.6">Implementation notes: Note that a CoAP end-point that sent a confirmable message MAY give up in attempting to obtain an ACK even before the MAX_RETRANSMIT counter value is reached:  E.g., the application has canceled the request as it no longer needs a response, or there is some other indication that the CON message did arrive.  In particular, a CoAP request message may have elicited a separate response, in which case it is clear to the requester that only the ACK was lost and a retransmission of the request would serve no purpose.  However, a responder MUST NOT in turn rely on this cross-layer behavior from a requester, i.e. it SHOULD retain the state to create the ACK for the request, if needed, even if a confirmable response was already acknowledged by the requester.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#unreliable" id="unreliable">Unreliable Messages</a>
</h1>
<p id="rfc.section.4.2.p.1">As a more lightweight alternative, a message can be transmitted less reliably by marking the message as "non-confirmable". A non-confirmable message MUST NOT be acknowledged by the recipient.  If a recipient lacks context to process the message properly, it MAY reject the message with a reset message or otherwise MUST silently ignore it.</p>
<p id="rfc.section.4.2.p.2">There is no way to detect if a non-confirmable message was received or not at the CoAP-level. A sender MAY choose to transmit a non-confirmable message multiple times which, for this purpose, specifies a Message ID as well. The same rules for generating the Message ID apply.</p>
<p id="rfc.section.4.2.p.3">A recipient MUST be prepared to receive the same non-confirmable message (as indicated by the Message ID) multiple times. As a general rule that may be relaxed based on the specific semantics of a message, the recipient SHOULD silently ignore any duplicated non-confirmable message, and SHOULD process any request or response in the message only once.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#message-types" id="message-types">Message Types</a>
</h1>
<p id="rfc.section.4.3.p.1">The different types of messages are summarized below. The type of a message is specified by the T field of the CoAP header.</p>
<p id="rfc.section.4.3.p.2">Separate from the message type, a message may carry a request, a response, or be empty. This is signaled by the Code field in the CoAP header and is relevant to the request/response model.  Possible values for the Code field are maintained by the <a href="#coap-code-registry">CoAP Code Registry</a> <cite title="NONE">[coap-code-registry]</cite>.</p>
<p id="rfc.section.4.3.p.3">An empty message has the Code field set to 0. The OC field SHOULD be set to 0 and no bytes SHOULD be present after the Message ID field.  The OC field and any bytes trailing the header MUST be ignored by any recipient.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#confirmable" id="confirmable">Confirmable (CON)</a>
</h1>
<p id="rfc.section.4.3.1.p.1">Some messages require an acknowledgement. These messages are called "Confirmable". When no packets are lost, each confirmable message elicits exactly one return message of type Acknowledgement or type Reset.</p>
<p id="rfc.section.4.3.1.p.2">A confirmable message always carries either a request or response and MUST NOT be empty.</p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#non-confirmable" id="non-confirmable">Non-Confirmable (NON)</a>
</h1>
<p id="rfc.section.4.3.2.p.1">Some other messages do not require an acknowledgement. This is particularly true for messages that are repeated regularly for application requirements, such as repeated readings from a sensor where eventual arrival is sufficient.</p>
<p id="rfc.section.4.3.2.p.2">A non-confirmable message always carries either a request or response, as well, and MUST NOT be empty.</p>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#acknowledgement" id="acknowledgement">Acknowledgement (ACK)</a>
</h1>
<p id="rfc.section.4.3.3.p.1">An Acknowledgement message acknowledges that a specific confirmable message (identified by its Message ID) arrived. It does not indicate success or failure of any encapsulated request.</p>
<p id="rfc.section.4.3.3.p.2">The acknowledgement message MUST echo the Message ID of the confirmable message, and MUST carry a response or be empty (see <a href="#pb">Section 5.2.1</a> and <a href="#npb">Section 5.2.2</a>).</p>
<h1 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> <a href="#reset" id="reset">Reset (RST)</a>
</h1>
<p id="rfc.section.4.3.4.p.1">A Reset message indicates that a specific confirmable message was received, but some context is missing to properly process it. This condition is usually caused when the receiving node has rebooted and has forgotten some state that would be required to interpret the message.</p>
<p id="rfc.section.4.3.4.p.2">A reset message MUST echo the Message ID of the confirmable message, and MUST be empty.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#multicast" id="multicast">Multicast</a>
</h1>
<p id="rfc.section.4.4.p.1">CoAP supports sending messages to multicast destination addresses.  Such multicast messages MUST be Non-Confirmable. Some mechanisms for avoiding congestion from multicast requests have been considered in <a href="#I-D.eggert-core-congestion-control">[I-D.eggert-core-congestion-control]</a>.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#congestion" id="congestion">Congestion Control</a>
</h1>
<p id="rfc.section.4.5.p.1">Basic congestion control for CoAP is provided by the exponential back-off mechanism in <a href="#reliable">Section 4.1</a>. </p>
<p id="rfc.section.4.5.p.2">In order not to cause congestion, Clients (including proxies) SHOULD strictly limit the number of simultaneous outstanding interactions that they maintain to a given server (including proxies). An outstanding interaction is either a CON for which an ACK has not yet been received but is still expected (message layer) or a request for which a response has not yet been received but is still expected (which may both occur at the same time, counting as one outstanding interaction). A good value for this limit is the number 1. (Note that <a href="#RFC2616">[RFC2616]</a>, in trying to achieve a similar objective, did specify a specific number of simultaneous connections as a ceiling. While revising <a href="#RFC2616">[RFC2616]</a>, this was found to be impractical for many applications <a href="#I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</a>. For the same considerations, this specification does not mandate a particular maximum number of outstanding interactions, but instead encourages clients to be conservative when initiating interactions.) </p>
<p id="rfc.section.4.5.p.3">Further congestion control optimizations and considerations are expected in the future, which may for example provide automatic initialization of the CoAP constants defined in <a href="#constants">Section 9</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#requests-responses" id="requests-responses">Request/Response Semantics</a>
</h1>
<p id="rfc.section.5.p.1">CoAP operates under a similar request/response model as HTTP: a CoAP end-point in the role of a "client" sends one or more CoAP requests to a "server", which services the requests by sending CoAP responses.  Unlike HTTP, requests and responses are not sent over a previously established connection, but exchanged asynchronously over CoAP messages.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#request-semantics" id="request-semantics">Requests</a>
</h1>
<p id="rfc.section.5.1.p.1">A CoAP request consists of the method to be applied to the resource, the identifier of the resource, a payload and Internet media type (if any), and optional meta-data about the request.</p>
<p id="rfc.section.5.1.p.2">CoAP supports the basic methods of GET, POST, PUT, DELETE, which are easily mapped to HTTP. They have the same properties of safe (only retrieval) and idempotent (you can invoke it multiple times with the same effects) as HTTP (see Section 9.1 of <a href="#RFC2616">[RFC2616]</a>).  The GET method is safe, therefore it MUST NOT take any other action on a resource other than retrieval. The GET, PUT and DELETE methods MUST be performed in such a way that they are idempotent. POST is not idempotent, because its effect is determined by the origin server and dependent on the target resource; it usually results in a new resource being created or the target resource being updated.</p>
<p id="rfc.section.5.1.p.3">A request is initiated by setting the Code field in the CoAP header of a confirmable or a non-confirmable message to a Method Code and including request information.</p>
<p id="rfc.section.5.1.p.4">The methods used in requests are described in detail in <a href="#methods">Section 5.8</a>.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#response-semantics" id="response-semantics">Responses</a>
</h1>
<p id="rfc.section.5.2.p.1">After receiving and interpreting a request, a server responds with a CoAP response, which is matched to the request by means of a client-generated token.</p>
<p id="rfc.section.5.2.p.2">A response is identified by the Code field in the CoAP header being set to a Response Code. Similar to the HTTP Status Code, the CoAP Response Code indicates the result of the attempt to understand and satisfy the request. These codes are fully defined in <a href="#response-codes">Section 5.9</a>. The Response Code numbers to be set in the Code field of the CoAP header are maintained in the <a href="#coap-code-registry-responses">CoAP Response Code Registry</a> <cite title="NONE">[coap-code-registry-responses]</cite>.</p>
<div id="#rfc.figure.9"></div>
<div id="#response-code"></div>
<pre>
  0
  0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|class|  detail |
+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.5.2.p.3">The upper three bits of the 8-bit Response Code number define the class of response. The lower five bits do not have any categorization role; they give additional detail to the overall class (<a href="#response-code">Figure 9</a>). There are 3 classes: </p>

<dl>
<dt>2 - Success:</dt>
<dd style="margin-left: 8">The request was successfully received, understood, and accepted.</dd>
<dt>4 - Client Error:</dt>
<dd style="margin-left: 8">The request contains bad syntax or cannot be fulfilled.</dd>
<dt>5 - Server Error:</dt>
<dd style="margin-left: 8">The server failed to fulfill an apparently valid request.</dd>
</dl>

<p> The response codes are designed to be extensible: Response Codes in the Client Error and Server Error class that are unrecognized by an end-point MUST be treated as being equivalent to the generic Response Code of that class. However, there is no generic Response Code indicating success, so a Response Code in the Success class that is unrecognized by an end-point can only be used to determine that the request was successful without any further details.</p>
<p id="rfc.section.5.2.p.4">As a human readable notation for specifications and protocol diagnostics, the numeric value of a response code is indicated by giving the upper three bits in decimal, followed by a dot and then the lower five bits in a two-digit decimal.  E.g., "Not Found" is written as 4.04 -- indicating a value of hexadecimal 0x84 or decimal 132.  In other words, the dot "." functions as a short-cut for "*32+".</p>
<p id="rfc.section.5.2.p.5">The possible response codes are described in detail in <a href="#response-codes">Section 5.9</a>.</p>
<p id="rfc.section.5.2.p.6">Responses can be sent in multiple ways, which are defined below.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#pb" id="pb">Piggy-backed</a>
</h1>
<p id="rfc.section.5.2.1.p.1">In the most basic case, the response is carried directly in the acknowledgement message that acknowledges the request (which requires that the request was carried in a confirmable message). This is called a "Piggy-backed" Response.</p>
<p id="rfc.section.5.2.1.p.2">The response is returned in the acknowledgement message independent of whether the response indicates success or failure.  In effect, the response is piggy-backed on the acknowledgement message, so no separate message is required to both acknowledge that the request was received and return the response.</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#npb" id="npb">Separate</a>
</h1>
<p id="rfc.section.5.2.2.p.1">It may not be possible to return a piggy-backed response in all cases. For example, a server might need longer to obtain the representation of the resource requested than it can wait sending back the acknowledgement message, without risking the client to repeatedly retransmit the request message. Responses to requests carried in a Non-Confirmable message are always sent separately (as there is no acknowledgement message).</p>
<p id="rfc.section.5.2.2.p.2">The server maybe initiates the attempt to obtain the resource representation and times out an acknowledgement timer, or it immediately sends an acknowledgement knowing in advance that there will be no piggy-backed response. The acknowledgement effectively is a promise that the request will be acted upon.</p>
<p id="rfc.section.5.2.2.p.3">When the server finally has obtained the resource representation, it sends the response. To ensure that this message is not lost, it is again sent as a confirmable message and answered by the client with an acknowledgement, echoing the new Message ID chosen by the server.</p>
<p id="rfc.section.5.2.2.p.4">(Implementation notes: Note that, as the underlying datagram transport may not be sequence-preserving, the confirmable message carrying the response may actually arrive before or after the acknowledgement message for the request.  Note also that, while the CoAP protocol itself does not make any specific demands here, there is an expectation that the response will come within a time frame that is reasonable from an application point of view; as there is no underlying transport protocol that could be instructed to run a keep-alive mechanism, the requester MAY want to set up a timeout that is unrelated to CoAP's retransmission timers in case the server is destroyed or otherwise unable to send the response.)</p>
<p id="rfc.section.5.2.2.p.5">For a separate exchange, both the acknowledgement to the confirmable request and the acknowledgement to the confirmable response MUST be an empty message, i.e. one that carries neither a request nor a response.</p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#non-confirmable-responses" id="non-confirmable-responses">Non-Confirmable</a>
</h1>
<p id="rfc.section.5.2.3.p.1">If the request message is non-confirmable, then the response SHOULD be returned in a non-confirmable message as well. However, an end-point MUST be prepared to receive a non-confirmable response (preceded or followed an empty acknowledgement message) in reply to a confirmable request, or a confirmable response in reply to a non-confirmable request.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#response-matching" id="response-matching">Request/Response Matching</a>
</h1>
<p id="rfc.section.5.3.p.1">Regardless of how a response is sent, it is matched to the request by means of a token that is included by the client in the request as one of the options along with additional address information of the corresponding end-point. The token MUST be echoed by the server in any resulting response without modification.</p>
<p id="rfc.section.5.3.p.2">The exact rules for matching a response to a request are as follows: </p>

<ol>
<li>For requests sent in a unicast message, the source of the response MUST match the destination of the original request. How this is determined depends on the security mode used (see <a href="#security">Section 10</a>): With NoSec, the IP address and port number of the request destination and response source must match.  With other security modes, in addition to the IP address and UDP port matching, the request and response MUST have the same security context.</li>
<li>In a piggy-backed response, both the Message ID of the confirmable request and the acknowledgement, and the token of the response and original request MUST match. In a separate response, just the token of the response and original request MUST match.</li>
</ol>

<p> </p>
<p id="rfc.section.5.3.p.3">The client SHOULD generate tokens in a way that tokens currently in use for a given source/destination pair are unique. (Note that a client can use the same token for any request if it uses a different source port number each time.)</p>
<p id="rfc.section.5.3.p.4">An end-point receiving a token MUST treat it as opaque and make no assumptions about its format. (Note that there is a default value for the Token Option, so every message carries a token, even if it is not explicitly expressed in a CoAP option.)</p>
<p id="rfc.section.5.3.p.5">In case a confirmable message carrying a response is unexpected (i.e. the client is not waiting for a response with the specified address and/or token), the confirmable response SHOULD be rejected with a reset message and MUST NOT be acknowledged.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#option-semantics" id="option-semantics">Options</a>
</h1>
<p id="rfc.section.5.4.p.1">Both requests and responses may include a list of one or more options. For example, the URI in a request is transported in several options, and meta-data that would be carried in an HTTP header in HTTP is supplied as options as well.</p>
<p id="rfc.section.5.4.p.2">CoAP defines a single set of options that are used in both requests and responses: <a href="#options">Section 5.10</a>.</p>

<ul>
<li>Content-Type</li>
<li>ETag</li>
<li>Location-Path</li>
<li>Location-Query</li>
<li>Max-Age</li>
<li>Proxy-Uri</li>
<li>Token</li>
<li>Uri-Host</li>
<li>Uri-Path</li>
<li>Uri-Port</li>
<li>Uri-Query</li>
<li>Accept</li>
<li>If-Match</li>
<li>If-None-Match</li>
</ul>

<p> The semantics of these options along with their properties are defined in detail in </p>
<p id="rfc.section.5.4.p.3">Not all options have meaning with all methods and response codes.  The possible options for methods and response codes are defined in <a href="#methods">Section 5.8</a> and <a href="#response-codes">Section 5.9</a> respectively. In case an option has no meaning, it SHOULD NOT be included by the sender and MUST be ignored by the recipient.</p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#critical-elective" id="critical-elective">Critical/Elective</a>
</h1>
<p id="rfc.section.5.4.1.p.1">Options fall into one of two classes: "critical" or "elective".  The difference between these is how an option unrecognized by an end-point is handled: </p>

<ul>
<li>Upon reception, unrecognized options of class "elective" MUST be silently ignored.</li>
<li>Unrecognized options of class "critical" that occur in a confirmable request MUST cause the return of a 4.02 (Bad Option) response. This response SHOULD include a human-readable error message describing the unrecognized option(s) (see <a href="#payload-semantics">Section 5.5</a>).</li>
<li>Unrecognized options of class "critical" that occur in a confirmable response SHOULD cause the response to be rejected with a reset message.</li>
<li>Unrecognized options of class "critical" that occur in a non-confirmable message MUST cause the message to be silently ignored.</li>
</ul>

<p> </p>
<p id="rfc.section.5.4.1.p.2">Note that, whether critical or elective, an option is never "mandatory" (it is always optional): These rules are defined in order to enable implementations to reject options they do not understand or implement.</p>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#option-length" id="option-length">Length</a>
</h1>
<p id="rfc.section.5.4.2.p.1">Option values are defined to have a specific length, often in the form of an upper and lower bound. If the length of an option value in a request is outside the defined range, that option MUST be treated like an unrecognized option (see <a href="#critical-elective">Section 5.4.1</a>).</p>
<h1 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> <a href="#option-defaults" id="option-defaults">Default Values</a>
</h1>
<p id="rfc.section.5.4.3.p.1">Options may be defined to have a default value. If the value of option is intended to be this default value, the option SHOULD NOT be included in the message.  If the option is not present, the default value MUST be assumed.</p>
<h1 id="rfc.section.5.4.4">
<a href="#rfc.section.5.4.4">5.4.4.</a> <a href="#repeated-options" id="repeated-options">Repeating Options</a>
</h1>
<p id="rfc.section.5.4.4.p.1">Each definition of an option specifies whether it is defined to occur only at most once or whether it can occur multiple times.  If a message includes an option with more instances than the option is defined for, the additional option instances MUST be treated like an unrecognized option (see <a href="#critical-elective">Section 5.4.1</a>).</p>
<h1 id="rfc.section.5.4.5">
<a href="#rfc.section.5.4.5">5.4.5.</a> <a href="#option-numbers" id="option-numbers">Option Numbers</a>
</h1>
<p id="rfc.section.5.4.5.p.1">Options are identified by an option number. Odd numbers indicate a critical option, while even numbers indicate an elective option.  (Note that this is not just a convention, it is a feature of the protocol: Whether an option is elective or critical is entirely determined by whether its option number is even or odd.) </p>
<p id="rfc.section.5.4.5.p.2">The numbers 14, 28, 42, ... are reserved for "fenceposting", as described in <a href="#option-format">Section 3.2</a>.  As these option numbers are even, they stand for elective options, and unless assigned a meaning, these MUST be silently ignored.</p>
<p id="rfc.section.5.4.5.p.3">The option numbers for the options defined in this document are listed in the <a href="#option-number-registry">CoAP Option Number Registry</a> <cite title="NONE">[option-number-registry]</cite>.</p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#payload-semantics" id="payload-semantics">Payload</a>
</h1>
<p id="rfc.section.5.5.p.1">Both requests and responses may include payload, depending on the method or response code respectively. Methods with payload are PUT and POST, and the response codes with payload are 2.05 (Content) and the error codes.</p>
<p id="rfc.section.5.5.p.2">The payload of PUT, POST and 2.05 (Content) is typically a resource representation. Its format is specified by the Internet media type given by the Content-Type Option. No default value is assumed in the absence of this option.</p>
<p id="rfc.section.5.5.p.3">2.01 (Created), 2.02 (Deleted), 2.04 (Changed) MAY include payload that is describing the result of the action. Again, the format of this payload is specified by the Internet media type given by the Content-Type Option; no default value is assumed in the absence of this option.  </p>
<p id="rfc.section.5.5.p.4">A response with a code indicating a Client or Server Error SHOULD include a brief human-readable diagnostic message as payload, explaining the error situation. This diagnostic message MUST be encoded using <a href="#RFC3629">UTF-8</a> <cite title="NONE">[RFC3629]</cite>, more specifically using <a href="#RFC5198">Net-Unicode form</a> <cite title="NONE">[RFC5198]</cite>. The Content-Type Option has no meaning and SHOULD NOT be included.  (Similar to what one would find as a Reason-Phrase on an HTTP status line, the message is not intended for end-users but for software engineers that during debugging need to interpret it in the context of the present, English-language specification; therefore no language tagging is foreseen.)</p>
<p id="rfc.section.5.5.p.5">If a method or response code is not defined to have a payload, then the sender SHOULD NOT include one, and the recipient MUST ignore it.</p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#caching" id="caching">Caching</a>
</h1>
<p id="rfc.section.5.6.p.1">CoAP end-points MAY cache responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests.</p>
<p id="rfc.section.5.6.p.2">The goal of caching in CoAP is to reuse a prior response message to satisfy a current request. In some cases, a stored response can be reused without the need for a network request, reducing latency and network round-trips; a "freshness" mechanism is used for this purpose (see <a href="#freshness-model">Section 5.6.1</a>).  Even when a new request is required, it is often possible to reuse the payload of a prior response to satisfy the request, thereby reducing network bandwidth usage; a "validation" mechanism is used for this purpose (see <a href="#validation-model">Section 5.6.2</a>).</p>
<p id="rfc.section.5.6.p.3">Unlike HTTP, the cacheability of CoAP responses does not depend on the request method, but the Response Code. The cacheability of each Response Code is defined along the Response Code definitions in <a href="#response-codes">Section 5.9</a>. Response Codes that indicate success and are unrecognized by an end-point MUST NOT be cached.</p>
<p id="rfc.section.5.6.p.4">For a presented request, a CoAP end-point MUST NOT use a stored response, unless: </p>

<ul>
<li>the presented request method and that used to obtain the stored response match,</li>
<li>all options match between those in the presented request and those of the request used to obtain the stored response (which includes the request URI), except that there is no need for a match of the Token, Max-Age, or ETag request option(s), and</li>
<li>the stored response is either fresh or successfully validated as defined below.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.6.1">
<a href="#rfc.section.5.6.1">5.6.1.</a> <a href="#freshness-model" id="freshness-model">Freshness Model</a>
</h1>
<p id="rfc.section.5.6.1.p.1">When a response is "fresh" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.</p>
<p id="rfc.section.5.6.1.p.2">The mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using the Max-Age Option (see <a href="#max-age">Section 5.10.6</a>). The Max-Age Option indicates that the response is to be considered not fresh after its age is greater than the specified number of seconds.</p>
<p id="rfc.section.5.6.1.p.3">As the Max-Age Option defaults to a value of 60, if it is not present in a cacheable response, then the response is considered not fresh after its age is greater than 60 seconds. If an origin server wishes to prevent caching, it MUST explicitly include a Max-Age Option with a value of zero seconds.</p>
<h1 id="rfc.section.5.6.2">
<a href="#rfc.section.5.6.2">5.6.2.</a> <a href="#validation-model" id="validation-model">Validation Model</a>
</h1>
<p id="rfc.section.5.6.2.p.1">When an end-point has one or more stored responses for a GET request, but cannot use any of them (e.g., because they are not fresh), it can use the ETag Option in the GET request to give the origin server an opportunity to both select a stored response to be used, and to update its freshness. This process is known as "validating" or "revalidating" the stored response.</p>
<p id="rfc.section.5.6.2.p.2">When sending such a request, the end-point SHOULD add an ETag Option specifying the entity-tag of each stored response that is applicable.</p>
<p id="rfc.section.5.6.2.p.3">A 2.03 (Valid) response indicates the stored response identified by the entity-tag given in the response's ETag Option can be reused, after updating its freshness with the value of the Max-Age Option that is included with the response (see <a href="#valid">Section 5.9.1.3</a>).</p>
<p id="rfc.section.5.6.2.p.4">Any other response code indicates that none of the stored responses nominated in the request is suitable. Instead, the response SHOULD be used to satisfy the request and MAY replace the stored response.</p>
<h1 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> <a href="#proxying" id="proxying">Proxying</a>
</h1>
<p id="rfc.section.5.7.p.1">CoAP distinguishes between requests to an origin server and a request made through a proxy. A proxy is a CoAP end-point that can be tasked by CoAP clients to perform requests on their behalf.  This may be useful, for example, when the request could otherwise not be made, or to service the response from a cache in order to reduce response time and network bandwidth or energy consumption.</p>
<p id="rfc.section.5.7.p.2">CoAP requests to a proxy are made as normal confirmable or non-confirmable requests to the proxy end-point, but specify the request URI in a different way: The request URI in a proxy request is specified as a string in the Proxy-Uri Option (see <a href="#proxy-uri">Section 5.10.3</a>), while the request URI in a request to an origin server is split into the Uri-Host, Uri-Port, Uri-Path and Uri-Query Options (see <a href="#uri-options">Section 5.10.2</a>).</p>
<p id="rfc.section.5.7.p.3">When a proxy request is made to an end-point and the end-point is unwilling or unable to act as proxy for the request URI, it MUST return a 5.05 (Proxying Not Supported) response. If the authority (host and port) is recognized as identifying the proxy end-point, then the request MUST be treated as a local request.</p>
<p id="rfc.section.5.7.p.4">Unless a proxy is configured to forward the proxy request to another proxy, it MUST translate the request as follows: The origin server's IP address and port are determined by the authority component of the request URI, and the request URI is decoded and split into the Uri-Host, Uri-Port, Uri-Path and Uri-Query Options.</p>
<p id="rfc.section.5.7.p.5">All options present in a proxy request MUST be processed at the proxy.  Critical options in a request that are not recognized by the proxy MUST lead to a 4.02 (Bad Option) response being returned by the proxy.  Elective options not recognized by the proxy MUST NOT be forwarded to the origin server.  Similarly, critical options in a response that are not recognized by the proxy server MUST lead to a 5.02 (Bad Gateway) response.  Again, elective options that are not recognized MUST NOT be forwarded.</p>
<p id="rfc.section.5.7.p.6">If the proxy does not employ a cache, then it simply forwards the translated request to the determined destination. Otherwise, if it does employ a cache but does not have a stored response that matches the translated request and is considered fresh, then it needs to refresh its cache according to <a href="#caching">Section 5.6</a>.</p>
<p id="rfc.section.5.7.p.7">If the request to the destination times out, then a 5.04 (Gateway Timeout) response MUST be returned. If the request to the destination returns an response that cannot be processed by the proxy, then a 5.02 (Bad Gateway) response MUST be returned. Otherwise, the proxy returns the response to the client.</p>
<p id="rfc.section.5.7.p.8">If a response is generated out of a cache, it MUST be generated with a Max-Age Option that does not extend the max-age originally set by the server, considering the time the resource representation spent in the cache.  E.g., the Max-Age Option could be adjusted by the proxy for each response using the formula: proxy-max-age = original-max-age - cache-age. For example if a request is made to a proxied resource that was refreshed 20 seconds ago and had an original Max-Age of 60 seconds, then that resource's proxied max-age is now 40 seconds.</p>
<h1 id="rfc.section.5.8">
<a href="#rfc.section.5.8">5.8.</a> <a href="#methods" id="methods">Method Definitions</a>
</h1>
<p id="rfc.section.5.8.p.1">In this section each method is defined along with its behavior.  A request with an unrecognized or unsupported Method Code MUST generate a 4.05 (Method Not Allowed) response.</p>
<h1 id="rfc.section.5.8.1">
<a href="#rfc.section.5.8.1">5.8.1.</a> <a href="#get" id="get">GET</a>
</h1>
<p id="rfc.section.5.8.1.p.1">The GET method retrieves a representation for the information that currently corresponds to the resource identified by the request URI. If the request inlcudes one or more Accept Options, they indicate the preferred content-type of a response. If the request includes an ETag Option, the GET method requests that ETag be validated and that the representation be transferred only if validation failed. Upon success a 2.05 (Content) or 2.03 (Valid) response SHOULD be sent.</p>
<p id="rfc.section.5.8.1.p.2">The GET method is safe and idempotent.</p>
<h1 id="rfc.section.5.8.2">
<a href="#rfc.section.5.8.2">5.8.2.</a> <a href="#post" id="post">POST</a>
</h1>
<p id="rfc.section.5.8.2.p.1">The POST method requests that the representation enclosed in the request be processed. The actual function performed by the POST method is determined by the origin server and dependent on the target resource. It usually results in a new resource being created or the target resource being updated.</p>
<p id="rfc.section.5.8.2.p.2">If a resource has been created on the server, a 2.01 (Created) response that includes the URI of the new resource in a sequence of one or more Location-Path Options and/or a Location-Query Option SHOULD be returned. If the POST succeeds but does not result in a new resource being created on the server, a 2.04 (Changed) response SHOULD be returned. If the POST succeeds and results in the target resource being deleted, a 2.02 (Deleted) response SHOULD be returned.</p>
<p id="rfc.section.5.8.2.p.3">POST is neither safe nor idempotent.</p>
<h1 id="rfc.section.5.8.3">
<a href="#rfc.section.5.8.3">5.8.3.</a> <a href="#put" id="put">PUT</a>
</h1>
<p id="rfc.section.5.8.3.p.1">The PUT method requests that the resource identified by the request URI be updated or created with the enclosed representation.  The representation format is specified by the media type given in the Content-Type Option.</p>
<p id="rfc.section.5.8.3.p.2">If a resource exists at the request URI the enclosed representation SHOULD be considered a modified version of that resource, and a 2.04 (Changed) response SHOULD be returned.  If no resource exists then the server MAY create a new resource with that URI, resulting in a 2.01 (Created) response.  If the resource could not be created or modified, then an appropriate error response code SHOULD be sent.</p>
<p id="rfc.section.5.8.3.p.3">Further restrictions to a PUT can be made by including the If-Match (see <a href="#if-match">Section 5.10.9</a>) or If-None-Match (see <a href="#if-none-match">Section 5.10.10</a>) options in the request.</p>
<p id="rfc.section.5.8.3.p.4">PUT is not safe, but idempotent.</p>
<h1 id="rfc.section.5.8.4">
<a href="#rfc.section.5.8.4">5.8.4.</a> <a href="#delete" id="delete">DELETE</a>
</h1>
<p id="rfc.section.5.8.4.p.1">The DELETE method requests that the resource identified by the request URI be deleted. A 2.02 (Deleted) response SHOULD be sent on success or in case the resource did not exist before the request.</p>
<p id="rfc.section.5.8.4.p.2">DELETE is not safe, but idempotent.</p>
<h1 id="rfc.section.5.9">
<a href="#rfc.section.5.9">5.9.</a> <a href="#response-codes" id="response-codes">Response Code Definitions</a>
</h1>
<p id="rfc.section.5.9.p.1">Each response code is described below, including any options required in the response.  Where appropriate, some of the codes will be specified in regards to related response codes in HTTP <a href="#RFC2616">[RFC2616]</a>; this does not mean that any such relationship modifies the HTTP mapping specified in <a href="#http">Section 8</a>.</p>
<h1 id="rfc.section.5.9.1">
<a href="#rfc.section.5.9.1">5.9.1.</a> <a href="#success" id="success">Success 2.xx</a>
</h1>
<p id="rfc.section.5.9.1.p.1">This class of status code indicates that the clients request was successfully received, understood, and accepted.</p>
<h1 id="rfc.section.5.9.1.1">
<a href="#rfc.section.5.9.1.1">5.9.1.1.</a> <a href="#created" id="created">2.01 Created</a>
</h1>
<p id="rfc.section.5.9.1.1.p.1">Like HTTP 201 "Created", but only used in response to POST and PUT requests. The payload returned with the response, if any, is a representation of the action result. The representation format is specified by the media type given in the Content-Type Option.</p>
<p id="rfc.section.5.9.1.1.p.2">If the response includes one or more Location-Path Options and/or a Location-Query Option, the values of these options specify the location at which the resource was created. Otherwise, the resource was created at the request URI. A cache SHOULD mark any stored response for the created resource as not fresh.</p>
<p id="rfc.section.5.9.1.1.p.3">This response is not cacheable.</p>
<h1 id="rfc.section.5.9.1.2">
<a href="#rfc.section.5.9.1.2">5.9.1.2.</a> <a href="#deleted" id="deleted">2.02 Deleted</a>
</h1>
<p id="rfc.section.5.9.1.2.p.1">Like HTTP 204 "No Content", but only used in response to DELETE requests. The payload returned with the response, if any, is a representation of the action result. The representation format is specified by the media type given in the Content-Type Option.</p>
<p id="rfc.section.5.9.1.2.p.2">This response is not cacheable. However, a cache SHOULD mark any stored response for the deleted resource as not fresh.</p>
<h1 id="rfc.section.5.9.1.3">
<a href="#rfc.section.5.9.1.3">5.9.1.3.</a> <a href="#valid" id="valid">2.03 Valid</a>
</h1>
<p id="rfc.section.5.9.1.3.p.1">Related to HTTP 304 "Not Modified", but only used to indicate that the response identified by the entity-tag identified by the included ETag Option is valid. Accordingly, the response MUST include an ETag Option.</p>
<p id="rfc.section.5.9.1.3.p.2">When a cache receives a 2.03 (Valid) response, it needs to update the stored response with the value of the Max-Age Option included in the response (see <a href="#validation-model">Section 5.6.2</a>).</p>
<h1 id="rfc.section.5.9.1.4">
<a href="#rfc.section.5.9.1.4">5.9.1.4.</a> <a href="#changed" id="changed">2.04 Changed</a>
</h1>
<p id="rfc.section.5.9.1.4.p.1">Like HTTP 204 "No Content", but only used in response to POST and PUT requests. The payload returned with the response, if any, is a representation of the action result. The representation format is specified by the media type given in the Content-Type Option.</p>
<p id="rfc.section.5.9.1.4.p.2">This response is not cacheable. However, a cache SHOULD mark any stored response for the changed resource as not fresh.</p>
<h1 id="rfc.section.5.9.1.5">
<a href="#rfc.section.5.9.1.5">5.9.1.5.</a> <a href="#content" id="content">2.05 Content</a>
</h1>
<p id="rfc.section.5.9.1.5.p.1">Like HTTP 200 "OK", but only used in response to GET requests.</p>
<p id="rfc.section.5.9.1.5.p.2">The payload returned with the response is a representation of the target resource. The representation format is specified by the media type given in the Content-Type Option.</p>
<p id="rfc.section.5.9.1.5.p.3">This response is cacheable: Caches can use the Max-Age Option to determine freshness (see <a href="#freshness-model">Section 5.6.1</a>) and (if present) the ETag Option for validation (see <a href="#validation-model">Section 5.6.2</a>).</p>
<h1 id="rfc.section.5.9.2">
<a href="#rfc.section.5.9.2">5.9.2.</a> <a href="#client-error" id="client-error">Client Error 4.xx</a>
</h1>
<p id="rfc.section.5.9.2.p.1">This class of response code is intended for cases in which the client seems to have erred. These response codes are applicable to any request method.</p>
<p id="rfc.section.5.9.2.p.2">The server SHOULD include a brief human-readable message as payload, as detailed in <a href="#payload-semantics">Section 5.5</a>.</p>
<p id="rfc.section.5.9.2.p.3">Responses of this class are cacheable: Caches can use the Max-Age Option to determine freshness (see <a href="#freshness-model">Section 5.6.1</a>). They cannot be validated.</p>
<h1 id="rfc.section.5.9.2.1">
<a href="#rfc.section.5.9.2.1">5.9.2.1.</a> <a href="#bad-request" id="bad-request">4.00 Bad Request</a>
</h1>
<p id="rfc.section.5.9.2.1.p.1">Like HTTP 400 "Bad Request".</p>
<h1 id="rfc.section.5.9.2.2">
<a href="#rfc.section.5.9.2.2">5.9.2.2.</a> <a href="#unauthorized" id="unauthorized">4.01 Unauthorized</a>
</h1>
<p id="rfc.section.5.9.2.2.p.1">The client is not authorized to perform the requested action.  The client SHOULD NOT repeat the request without previously improving its authentication status to the server.  Which specific mechanism can be used for this is outside this document's scope; see also <a href="#security">Section 10</a>.</p>
<h1 id="rfc.section.5.9.2.3">
<a href="#rfc.section.5.9.2.3">5.9.2.3.</a> <a href="#bad-option" id="bad-option">4.02 Bad Option</a>
</h1>
<p id="rfc.section.5.9.2.3.p.1">The request could not be understood by the server due to one or more unrecognized or malformed critical options. The client SHOULD NOT repeat the request without modification.</p>
<h1 id="rfc.section.5.9.2.4">
<a href="#rfc.section.5.9.2.4">5.9.2.4.</a> <a href="#forbidden" id="forbidden">4.03 Forbidden</a>
</h1>
<p id="rfc.section.5.9.2.4.p.1">Like HTTP 403 "Forbidden".</p>
<h1 id="rfc.section.5.9.2.5">
<a href="#rfc.section.5.9.2.5">5.9.2.5.</a> <a href="#not-found" id="not-found">4.04 Not Found</a>
</h1>
<p id="rfc.section.5.9.2.5.p.1">Like HTTP 404 "Not Found".</p>
<h1 id="rfc.section.5.9.2.6">
<a href="#rfc.section.5.9.2.6">5.9.2.6.</a> <a href="#method-not-allowed" id="method-not-allowed">4.05 Method Not Allowed</a>
</h1>
<p id="rfc.section.5.9.2.6.p.1">Like HTTP 405 "Method Not Allowed", but with no parallel to the "Allow" header field.</p>
<h1 id="rfc.section.5.9.2.7">
<a href="#rfc.section.5.9.2.7">5.9.2.7.</a> <a href="#precondition-failed" id="precondition-failed">4.12 Precondition Failed</a>
</h1>
<p id="rfc.section.5.9.2.7.p.1">Like HTTP 412 "Precondition Failed".</p>
<h1 id="rfc.section.5.9.2.8">
<a href="#rfc.section.5.9.2.8">5.9.2.8.</a> <a href="#request-entity-too-large" id="request-entity-too-large">4.13 Request Entity Too Large</a>
</h1>
<p id="rfc.section.5.9.2.8.p.1">Like HTTP 413 "Request Entity Too Large".</p>
<h1 id="rfc.section.5.9.2.9">
<a href="#rfc.section.5.9.2.9">5.9.2.9.</a> <a href="#unsupported-media-type" id="unsupported-media-type">4.15 Unsupported Media Type</a>
</h1>
<p id="rfc.section.5.9.2.9.p.1">Like HTTP 415 "Unsupported Media Type".</p>
<h1 id="rfc.section.5.9.3">
<a href="#rfc.section.5.9.3">5.9.3.</a> <a href="#server-error" id="server-error">Server Error 5.xx</a>
</h1>
<p id="rfc.section.5.9.3.p.1">This class of response code indicates cases in which the server is aware that it has erred or is incapable of performing the request. These response codes are applicable to any request method.</p>
<p id="rfc.section.5.9.3.p.2">The server SHOULD include a human-readable message as payload, as detailed in <a href="#payload-semantics">Section 5.5</a>.</p>
<p id="rfc.section.5.9.3.p.3">Responses of this class are cacheable: Caches can use the Max-Age Option to determine freshness (see <a href="#freshness-model">Section 5.6.1</a>). They cannot be validated.</p>
<h1 id="rfc.section.5.9.3.1">
<a href="#rfc.section.5.9.3.1">5.9.3.1.</a> <a href="#internal-server-error" id="internal-server-error">5.00 Internal Server Error</a>
</h1>
<p id="rfc.section.5.9.3.1.p.1">Like HTTP 500 "Internal Server Error".</p>
<h1 id="rfc.section.5.9.3.2">
<a href="#rfc.section.5.9.3.2">5.9.3.2.</a> <a href="#not-implemented" id="not-implemented">5.01 Not Implemented</a>
</h1>
<p id="rfc.section.5.9.3.2.p.1">Like HTTP 501 "Not Implemented".</p>
<h1 id="rfc.section.5.9.3.3">
<a href="#rfc.section.5.9.3.3">5.9.3.3.</a> <a href="#bad-gateway" id="bad-gateway">5.02 Bad Gateway</a>
</h1>
<p id="rfc.section.5.9.3.3.p.1">Like HTTP 502 "Bad Gateway".</p>
<h1 id="rfc.section.5.9.3.4">
<a href="#rfc.section.5.9.3.4">5.9.3.4.</a> <a href="#service-unavailable" id="service-unavailable">5.03 Service Unavailable</a>
</h1>
<p id="rfc.section.5.9.3.4.p.1">Like HTTP 503 "Service Unavailable", but using the Max-Age Option in place of the "Retry-After" header field.</p>
<h1 id="rfc.section.5.9.3.5">
<a href="#rfc.section.5.9.3.5">5.9.3.5.</a> <a href="#gateway-timeout" id="gateway-timeout">5.04 Gateway Timeout</a>
</h1>
<p id="rfc.section.5.9.3.5.p.1">Like HTTP 504 "Gateway Timeout".</p>
<h1 id="rfc.section.5.9.3.6">
<a href="#rfc.section.5.9.3.6">5.9.3.6.</a> <a href="#proxying-not-supported" id="proxying-not-supported">5.05 Proxying Not Supported</a>
</h1>
<p id="rfc.section.5.9.3.6.p.1">The server is unable or unwilling to act as a proxy for the URI specified in the Proxy-Uri Option (see <a href="#proxy-uri">Section 5.10.3</a>).</p>
<h1 id="rfc.section.5.10">
<a href="#rfc.section.5.10">5.10.</a> <a href="#options" id="options">Option Definitions</a>
</h1>
<p id="rfc.section.5.10.p.1">The individual CoAP options are summarized in <a href="#tab-options">Table 1</a> and explained below.</p>
<div id="#rfc.table.1"></div>
<div id="#tab-options"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Options</caption>
<thead><tr>
<th class="right">No.</th>
<th class="left">C/E</th>
<th class="left">Name</th>
<th class="left">Format</th>
<th class="left">Length</th>
<th class="left">Default</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">Critical</td>
<td class="left">Content-Type  </td>
<td class="left">uint  </td>
<td class="left">0-2 B  </td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">Elective</td>
<td class="left">Max-Age       </td>
<td class="left">uint  </td>
<td class="left">0-4 B  </td>
<td class="left">60         </td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">Critical</td>
<td class="left">Proxy-Uri     </td>
<td class="left">string</td>
<td class="left">1-270 B</td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">Elective</td>
<td class="left">ETag          </td>
<td class="left">opaque</td>
<td class="left">1-8 B  </td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">Critical</td>
<td class="left">Uri-Host      </td>
<td class="left">string</td>
<td class="left">1-270 B</td>
<td class="left">(see below)</td>
</tr>
<tr>
<td class="right">6</td>
<td class="left">Elective</td>
<td class="left">Location-Path </td>
<td class="left">string</td>
<td class="left">1-270 B</td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">7</td>
<td class="left">Critical</td>
<td class="left">Uri-Port      </td>
<td class="left">uint  </td>
<td class="left">0-2 B  </td>
<td class="left">(see below)</td>
</tr>
<tr>
<td class="right">8</td>
<td class="left">Elective</td>
<td class="left">Location-Query</td>
<td class="left">string</td>
<td class="left">1-270 B</td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">9</td>
<td class="left">Critical</td>
<td class="left">Uri-Path      </td>
<td class="left">string</td>
<td class="left">1-270 B</td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">11</td>
<td class="left">Critical</td>
<td class="left">Token         </td>
<td class="left">opaque</td>
<td class="left">1-8 B  </td>
<td class="left">(empty)    </td>
</tr>
<tr>
<td class="right">12</td>
<td class="left">Elective</td>
<td class="left">Accept        </td>
<td class="left">uint      </td>
<td class="left">0-2 B  </td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">13</td>
<td class="left">Critical</td>
<td class="left">If-Match      </td>
<td class="left">opaque</td>
<td class="left">0-8 B  </td>
<td class="left">(none)    </td>
</tr>
<tr>
<td class="right">15</td>
<td class="left">Critical</td>
<td class="left">Uri-Query     </td>
<td class="left">string</td>
<td class="left">1-270 B</td>
<td class="left">(none)     </td>
</tr>
<tr>
<td class="right">21</td>
<td class="left">Critical</td>
<td class="left">If-None-Match </td>
<td class="left">(none)</td>
<td class="left">0 B  </td>
<td class="left">(none)    </td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.5.10.1">
<a href="#rfc.section.5.10.1">5.10.1.</a> <a href="#token" id="token">Token</a>
</h1>
<p id="rfc.section.5.10.1.p.1">The Token Option is used to match a response with a request.  Every request has a client-generated token which the server MUST echo in any response. A default value of a zero-length token is assumed in the absence of the option. Thus when the token value is empty, the Token Option SHOULD be elided for efficiency. </p>
<p id="rfc.section.5.10.1.p.2">A token is intended for use as a client-local identifier for differentiating between concurrent requests (see <a href="#response-matching">Section 5.3</a>). A client SHOULD generate tokens in a way that tokens currently in use for a given source/destination pair are unique. An empty token value is appropriate e.g. when no other tokens are in use to a destination, or when requests are made serially per destination. There are however multiple possible implementation strategies to fulfill this. An end-point receiving a token MUST treat it as opaque and make no assumptions about its format.</p>
<p id="rfc.section.5.10.1.p.3">This option is "critical". It MUST NOT occur more than once.</p>
<h1 id="rfc.section.5.10.2">
<a href="#rfc.section.5.10.2">5.10.2.</a> <a href="#uri-options" id="uri-options">Uri-Host, Uri-Port, Uri-Path and Uri-Query</a>
</h1>
<p id="rfc.section.5.10.2.p.1">The Uri-Host, Uri-Port, Uri-Path and Uri-Query Options are used to specify the target resource of a request to a CoAP origin server. The options encode the different components of the request URI in a way that no percent-encoding is visible in the option values and that the full URI can be reconstructed at any involved end-point. The syntax of CoAP URIs is defined in <a href="#uri">Section 6</a>.</p>
<p id="rfc.section.5.10.2.p.2">The steps for parsing URIs into options is defined in <a href="#uri-parsing">Section 6.4</a>. These steps result in zero or more Uri-Host, Uri-Port, Uri-Path and Uri-Query Options being included in a request, where each option holds the following values: <a href="#RFC3986">[RFC3986]</a>, Section 3.5) are not part of the request URI and thus will not be transmitted in a CoAP request.</p>

<ul>
<li>the Uri-Host Option specifies the Internet host of the resource being requested,</li>
<li>the Uri-Port Option specifies the port number of the resource,</li>
<li>each Uri-Path Option specifies one segment of the absolute path to the resource, and</li>
<li>each Uri-Query Option specifies one argument parameterizing the resource.</li>
</ul>

<p> Note: Fragments (</p>
<p id="rfc.section.5.10.2.p.3">The default value of the Uri-Host Option is the IP literal representing the destination IP address of the request message.  Likewise, the default value of the Uri-Port Option is the destination UDP port. The default Uri-Host and Uri-Port options are sufficient for requests to most servers, and are typically used when an end-point hosts multiple virtual servers. </p>
<p id="rfc.section.5.10.2.p.4">The Uri-Path and Uri-Query Option can contain any character sequence. No percent-encoding is performed. The value of a Uri-Path Option MUST NOT be "." or ".." (as the request URI must be resolved before parsing it into options).</p>
<p id="rfc.section.5.10.2.p.5">The steps for constructing the request URI from the options are defined in <a href="#uri-constructing">Section 6.5</a>. Note that an implementation does not necessarily have to construct the URI; it can simply look up the target resource by looking at the individual options.</p>
<p id="rfc.section.5.10.2.p.6">Examples can be found in <a href="#uri-examples">Appendix Appendix C</a>.</p>
<p id="rfc.section.5.10.2.p.7">All of the options are "critical". Uri-Host and Uri-Port MUST NOT occur more than once; Uri-Path and Uri-Query MAY occur one or more times.</p>
<h1 id="rfc.section.5.10.3">
<a href="#rfc.section.5.10.3">5.10.3.</a> <a href="#proxy-uri" id="proxy-uri">Proxy-Uri</a>
</h1>
<p id="rfc.section.5.10.3.p.1">The Proxy-Uri Option is used to make a request to a proxy (see <a href="#proxying">Section 5.7</a>). The proxy is requested to forward the request or service it from a valid cache, and return the response.</p>
<p id="rfc.section.5.10.3.p.2">The option value is an absolute-URI (<a href="#RFC3986">[RFC3986]</a>, Section 4.3). In case the absolute-URI doesn't fit within a single option, the Proxy-Uri Option MAY be included multiple times in a request such that the concatenation of the values results in the single absolute-URI.</p>
<p id="rfc.section.5.10.3.p.3">All but the last instance of the Proxy-Uri Option MUST have a value with a length of 270 bytes, and the last instance MUST NOT be empty.</p>
<p id="rfc.section.5.10.3.p.4">Note that the proxy MAY forward the request on to another proxy or directly to the server specified by the absolute-URI.  In order to avoid request loops, a proxy MUST be able to recognize all of its server names, including any aliases, local variations, and the numeric IP addresses.</p>
<p id="rfc.section.5.10.3.p.5">An end-point receiving a request with a Proxy-Uri Option that is unable or unwilling to act as a proxy for the request MUST cause the return of a 5.05 (Proxying Not Supported) response.</p>
<p id="rfc.section.5.10.3.p.6">This option is "critical". It MAY occur one or more times and MUST take precedence over any of the Uri-Host, Uri-Port, Uri-Path or Uri-Query options (which MUST NOT be included at the same time).</p>
<h1 id="rfc.section.5.10.4">
<a href="#rfc.section.5.10.4">5.10.4.</a> <a href="#content-type" id="content-type">Content-Type</a>
</h1>
<p id="rfc.section.5.10.4.p.1">The Content-Type Option indicates the representation format of the message payload. The representation format is given as a numeric media type identifier that is defined in the <a href="#media-type-registry">CoAP Media Type registry</a> <cite title="NONE">[media-type-registry]</cite>.  No default value is assumed in the absence of the option.</p>
<p id="rfc.section.5.10.4.p.2">This option is "critical". It MUST NOT occur more than once.</p>
<h1 id="rfc.section.5.10.5">
<a href="#rfc.section.5.10.5">5.10.5.</a> <a href="#accept" id="accept">Accept</a>
</h1>
<p id="rfc.section.5.10.5.p.1">The CoAP Accept option indicates when included one or more times in a request, one or more media types, each of which is an acceptable media type for the client, in the order of preference. The representation format is given as a numeric media type identifier that is defined in the <a href="#media-type-registry">CoAP Media Type registry</a> <cite title="NONE">[media-type-registry]</cite>. If no Accept options are given, the client does not express a preference (thus no default value is assumed). The client prefers the representation returned by the server to be in one of the media types indicated. The server SHOULD return one of the preferred media types if available. As a server might not support the Accept option (and thus would ignore it as it is elective), or a server might not have a preferred media type available, the client needs to be prepared to receive a representation in a different media type. The client can simply discard a representation it can not make use of.  </p>
<p id="rfc.section.5.10.5.p.2">This option is "elective". It MAY occur more than once.</p>
<h1 id="rfc.section.5.10.6">
<a href="#rfc.section.5.10.6">5.10.6.</a> <a href="#max-age" id="max-age">Max-Age</a>
</h1>
<p id="rfc.section.5.10.6.p.1">The Max-Age Option indicates the maximum time a response may be cached before it MUST be considered not fresh (see <a href="#freshness-model">Section 5.6.1</a>).</p>
<p id="rfc.section.5.10.6.p.2">The option value is an integer number of seconds between 0 and 2^32-1 inclusive (about 136.1 years). A default value of 60 seconds is assumed in the absence of the option in a response.</p>
<p id="rfc.section.5.10.6.p.3">This option is "elective". It MUST NOT occur more than once.</p>
<h1 id="rfc.section.5.10.7">
<a href="#rfc.section.5.10.7">5.10.7.</a> <a href="#etag" id="etag">ETag</a>
</h1>
<p id="rfc.section.5.10.7.p.1">The ETag Option in a response provides the current value of the entity-tag for the enclosed representation of the target resource.</p>
<p id="rfc.section.5.10.7.p.2">An entity-tag is intended for use as a resource-local identifier for differentiating between representations of the same resource that vary over time. It may be generated in any number of ways including a version, checksum, hash or time. An end-point receiving an entity-tag MUST treat it as opaque and make no assumptions about its format.  (End-points generating an entity-tag are encouraged to use the most compact representation possible, in particular in regards to clients and intermediaries that may want to store multiple ETag values.)</p>
<p id="rfc.section.5.10.7.p.3">An end-point that has one or more representations previously obtained from the resource can specify the ETag Option in a request for each stored response to determine if any of those representations is current (see <a href="#validation-model">Section 5.6.2</a>).</p>
<p id="rfc.section.5.10.7.p.4">This option is "elective". It MUST NOT occur more than once in a response, and MAY occur one or more times in a request.</p>
<h1 id="rfc.section.5.10.8">
<a href="#rfc.section.5.10.8">5.10.8.</a> <a href="#location-options" id="location-options">Location-Path and Location-Query</a>
</h1>
<p id="rfc.section.5.10.8.p.1">The Location-Path and Location-Query Options indicates the location of a resource as an absolute path URI. The Location-Path Option is similar to the Uri-Path Option, and the Location-Query Option similar to the Uri-Query Option.</p>
<p id="rfc.section.5.10.8.p.2">The two options MAY be included in a response to indicate the location of a new resource created with POST.</p>
<p id="rfc.section.5.10.8.p.3">If a response with a Location-Path and/or Location-Query Option passes through a cache and the implied URI identifies one or more currently stored responses, those entries SHOULD be marked as not fresh.  </p>
<p id="rfc.section.5.10.8.p.4">Both options are "elective" and MAY occur one or more times.</p>
<h1 id="rfc.section.5.10.9">
<a href="#rfc.section.5.10.9">5.10.9.</a> <a href="#if-match" id="if-match">If-Match</a>
</h1>
<p id="rfc.section.5.10.9.p.1">The If-Match Option MAY be used to make a request conditional on the current existence or value of an ETag for one or more representations of the target resource.  If-Match is generally useful for resource update requests, such as PUT requests, as a means for protecting against accidental overwrites when multiple clients are acting in parallel on the same resource (i.e., the "lost update" problem).</p>
<p id="rfc.section.5.10.9.p.2">The value of an If-Match option is either an ETag or the empty string.  An empty string places the precondition on the existence of any current representation for the target resource.</p>
<p id="rfc.section.5.10.9.p.3">The If-Match Option can occur multiple times.  If any of the ETags given as an option value match the ETag of the selected representation for the target resource, or if an If-Match Option with an empty string as option value is given and any current representation exists for the target resource, then the server MAY perform the request method as if the If-Match Option was not present.</p>
<p id="rfc.section.5.10.9.p.4">If none of the ETags match and, if an empty string is given, no current representation exists at all, the server MUST NOT perform the requested method.  Instead, the server MUST respond with the 4.12 (Precondition Failed) response code.</p>
<p id="rfc.section.5.10.9.p.5">If the request would, without the If-Match Options, result in anything other than a 2.xx or 4.12 response code, then any If-Match Options MUST be ignored.</p>
<p id="rfc.section.5.10.9.p.6">This option is "critical". It MAY occur more than once.</p>
<h1 id="rfc.section.5.10.10">
<a href="#rfc.section.5.10.10">5.10.10.</a> <a href="#if-none-match" id="if-none-match">If-None-Match</a>
</h1>
<p id="rfc.section.5.10.10.p.1">The If-None-Match Option MAY be used to make a request conditional on the non-existance of the target resource.  If-None-Match is useful for resource creation requests, such as PUT requests, as a means for protecting against accidental overwrites when multiple clients are acting in parallel on the same resource. The If-None-Match Option carries no value.</p>
<p id="rfc.section.5.10.10.p.2">If the target resource does exist, then the server MUST NOT perform the requested method.  Instead, the server MUST respond with the 4.12 (Precondition Failed) response code.</p>
<p id="rfc.section.5.10.10.p.3">This option is "critical". It MAY NOT occur more than once.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#uri" id="uri">CoAP URIs</a>
</h1>
<p id="rfc.section.6.p.1">CoAP uses the "coap" and "coaps" URI schemes for identifying CoAP resources and providing a means of locating the resource. Resources are organized hierarchically and governed by a potential CoAP origin server listening for CoAP requests ("coap") or DTLS-secured CoAP requests ("coaps") on a given UDP port. The CoAP server is identified via the generic syntax's authority component, which includes a host identifier and optional UDP port number. The remainder of the URI is considered to be identifying a resource which can be operated on by the methods defined by the CoAP protocol. The "coap" and "coaps" URI schemes can thus be compared to the "http" and "https" URI schemes respectively.</p>
<p id="rfc.section.6.p.2">The syntax of the "coap" and "coaps" URI schemes is specified below in Augmented Backus-Naur Form (ABNF) <a href="#RFC5234">[RFC5234]</a>.  The definitions of "host", "port", "path-abempty", "query", "segment", "IP-literal", "IPv4address" and "reg-name" are adopted from <a href="#RFC3986">[RFC3986]</a>.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#uri-coap" id="uri-coap">coap URI Scheme</a>
</h1>
<div id="#rfc.figure.10"></div>
<pre>
coap-URI = "coap:" "//" host [ ":" port ] path-abempty [ "?" query ]
</pre>
<p id="rfc.section.6.1.p.1">If host is provided as an IP-literal or IPv4address, then the CoAP server is located at that IP address.  If host is a registered name, then that name is considered an indirect identifier and the end-point might use a name resolution service, such as DNS, to find the address of that host. The host MUST NOT be empty.  The port subcomponent indicates the UDP port at which the CoAP server is located. If it is empty or not given, then the default port 5683 is assumed.</p>
<p id="rfc.section.6.1.p.2">The path identifies a resource within the scope of the host and port. It consists of a sequence of path segments separated by a slash character (U+002F SOLIDUS "/").</p>
<p id="rfc.section.6.1.p.3">The query serves to further parameterize the resource. It consists of a sequence of arguments separated by an ampersand character (U+0026 AMPERSAND "&amp;"). An argument is often in the form of a "key=value" pair.</p>
<p id="rfc.section.6.1.p.4">The "coap" URI scheme supports the path prefix "/.well-known/" defined by <a href="#RFC5785">[RFC5785]</a> for "well-known locations" in the name-space of a host. This enables discovery of policy or other information about a host ("site-wide metadata"), such as hosted resources (see <a href="#discovery">Section 7.1</a>).</p>
<p id="rfc.section.6.1.p.5">Application designers are encouraged to make use of short, but descriptive URIs.  As the environments that CoAP is used in are usually constrained for bandwidth and energy, the trade-off between these two qualities should lean towards the shortness, without ignoring descriptiveness.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#uri-coaps" id="uri-coaps">coaps URI Scheme</a>
</h1>
<div id="#rfc.figure.11"></div>
<pre>
coaps-URI = "coaps:" "//" host [ ":" port ] path-abempty 
            [ "?" query ]
</pre>
<p id="rfc.section.6.2.p.1">All of the requirements listed above for the "coap" scheme are also requirements for the "coaps" scheme, except that a default UDP port of [IANA_TBD_PORT] is assumed if the port subcomponent is empty or not given, and the UDP datagrams MUST be secured for privacy through the use of DTLS as described in <a href="#dtls">Section 10.1</a>.</p>
<p id="rfc.section.6.2.p.2">Unlike the "coap" scheme, responses to "coaps" identified requests are never "public" and thus MUST NOT be reused for shared caching. They can, however, be reused in a private cache if the message is cacheable by default in CoAP.</p>
<p id="rfc.section.6.2.p.3">Resources made available via the "coaps" scheme have no shared identity with the "coap" scheme even if their resource identifiers indicate the same authority (the same host listening to the same UDP port). They are distinct name spaces and are considered to be distinct origin servers.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#uri-normalization" id="uri-normalization">Normalization and Comparison Rules</a>
</h1>
<p id="rfc.section.6.3.p.1">Since the "coap" and "coaps" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in <a href="#RFC3986">[RFC3986]</a>, Section 6, using the defaults described above for each scheme.</p>
<p id="rfc.section.6.3.p.2">If the port is equal to the default port for a scheme, the normal form is to elide the port subcomponent. Likewise, an empty path component is equivalent to an absolute path of "/", so the normal form is to provide a path of "/" instead. The scheme and host are case-insensitive and normally provided in lowercase; IP-literals are in recommended form <a href="#RFC5952">[RFC5952]</a>; all other components are compared in a case-sensitive manner. Characters other than those in the "reserved" set are equivalent to their percent-encoded octets (see <a href="#RFC3986">[RFC3986]</a>, Section 2.1): the normal form is to not encode them.</p>
<p id="rfc.section.6.3.p.3">For example, the following three URIs are equivalent, and cause the same options and option values to appear in the CoAP messages:</p>
<div id="#rfc.figure.12"></div>
<pre>
coap://example.com:5683/~sensors/temp.xml
coap://EXAMPLE.com/%7Esensors/temp.xml
coap://EXAMPLE.com:/%7esensors/temp.xml
</pre>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#uri-parsing" id="uri-parsing">Decomposing URIs into Options</a>
</h1>
<p id="rfc.section.6.4.p.1">The steps to parse a request's options from a string /url/ are as follows. These steps either result in zero or more of the Uri-Host, Uri-Port, Uri-Path and Uri-Query Options being included in the request, or they fail.  </p>

<ol>
<li>If the /url/ string is not an absolute URI (<a href="#RFC3986">[RFC3986]</a>), then fail this algorithm.</li>
<li>Resolve the /url/ string using the process of reference resolution defined by <a href="#RFC3986">[RFC3986]</a>, with the URL character encoding set to <a href="#RFC3629">UTF-8</a> <cite title="NONE">[RFC3629]</cite>.  <br><br> NOTE: It doesn't matter what it is resolved relative to, since we already know it is an absolute URL at this point.</li>
<li>If /url/ does not have a &lt;scheme&gt; component whose value, when converted to ASCII lowercase, is "coap" or "coaps", then fail this algorithm.</li>
<li>If /url/ has a &lt;fragment&gt; component, then fail this algorithm.</li>
<li>If the &lt;host&gt; component of /url/ does not represent the request's destination IP address as an IP-literal or IPv4address, include a Uri-Host Option and let that option's value be the value of the &lt;host&gt; component of /url/, converted to ASCII lowercase, and then converting all percent-encodings ("%" followed by two hexadecimal digits) to the corresponding characters.  <br><br> NOTE: In the usual case where the request's destination IP address is derived from the host part, this ensures that Uri-Host Options are only used for host parts of the form reg-name.</li>
<li>If /url/ has a &lt;port&gt; component, then let /port/ be that component's value interpreted as a decimal integer; otherwise, let /port/ be the default port for the scheme.</li>
<li>If /port/ does not equal the request's destination UDP port, include a Uri-Port Option and let that option's value be /port/.</li>
<li>If the value of the &lt;path&gt; component of /url/ is empty or consists of a single slash character (U+002F SOLIDUS "/"), then move to the next step.<br><br> Otherwise, for each segment in the &lt;path&gt; component, include a Uri-Path Option and let that option's value be the segment (not including the delimiting slash characters) after converting all percent-encodings ("%" followed by two hexadecimal digits) to the corresponding characters.</li>
<li>If /url/ has a &lt;query&gt; component, then, for each argument in the &lt;query&gt; component, include a Uri-Query Option and let that option's value be the argument (not including the question mark and the delimiting ampersand characters) after converting all percent-encodings to the corresponding characters.</li>
</ol>
<p id="rfc.section.6.4.p.2">Note that these rules completely resolve any percent-encoding.  </p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#uri-constructing" id="uri-constructing">Composing URIs from Options</a>
</h1>
<p id="rfc.section.6.5.p.1">The steps to construct a URI from a request's options are as follows.  These steps either result in a URI, or they fail.  In these steps, percent-encoding a character means replacing each of its (UTF-8 encoded) bytes by a "%" character followed by two hexadecimal digits representing the byte, where the digits A-F are in upper case (as defined in <a href="#RFC3986">[RFC3986]</a> Section 2.1; to reduce variability, the hexadecimal notation in CoAP URIs MUST use uppercase letters).  </p>

<ol>
<li>If the request is secured using DTLS, let /url/ be the string "coaps://". Otherwise, let /url/ be the string "coap://".</li>
<li>If the request includes a Uri-Host Option, let /host/ be that option's value, where any non-ASCII characters are replaced by their corresponding percent-encoding.  If /host/ is not a valid reg-name or IP-literal or IPv4address, fail the algorithm.  Otherwise, let /host/ be the IP-literal (making use of the conventions of <a href="#RFC5952">[RFC5952]</a>) or IPv4address representing the request's destination IP address.</li>
<li>Append /host/ to /url/.</li>
<li>If the request includes a Uri-Port Option, let /port/ be that option's value. Otherwise, let /port/ be the request's destination UDP port.</li>
<li>If /port/ is not the default port for the scheme, then append a single U+003A COLON character (:) followed by the decimal representation of /port/ to /url/.</li>
<li>Let /resource name/ be the empty string. For each Uri-Path Option in the request, append a single character U+002F SOLIDUS (/) followed by the option's value to /resource name/, after converting any character that is not either in the "unreserved" set, "sub-delims" set, a U+003A COLON (:) or U+0040 COMMERCIAL AT (@) character, to its percent-encoded form.</li>
<li>If /resource name/ is the empty string, set it to a single character U+002F SOLIDUS (/).</li>
<li>For each Uri-Query Option in the request, append a single character U+003F QUESTION MARK (?) (first option) or U+0026 AMPERSAND (&amp;) (subsequent options) followed by the option's value to /resource name/, after converting any character that is not either in the "unreserved" set, "sub-delims" set (except U+0026 AMPERSAND (&amp;)), a U+003A COLON (:), U+0040 COMMERCIAL AT (@), U+002F SOLIDUS (/) or U+003F QUESTION MARK (?) character, to its percent-encoded form.</li>
<li>Append /resource name/ to /url/.</li>
<li>Return /url/.</li>
</ol>
<p id="rfc.section.6.5.p.2">Note that these steps have been designed to lead to a URI in normal form (see <a href="#uri-normalization">Section 6.3</a>).  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#addressing" id="addressing">Finding and Addressing CoAP End-Points</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#discovery" id="discovery">Resource Discovery</a>
</h1>
<p id="rfc.section.7.1.p.1">The discovery of resources offered by a CoAP end-point is extremely important in machine-to-machine applications where there are no humans in the loop and static interfaces result in fragility. A CoAP end-point SHOULD support the CoRE Link Format of discoverable resources as described in <a href="#I-D.ietf-core-link-format">[I-D.ietf-core-link-format]</a>. It is up to the server which resources are made discoverable (if any). </p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> Content-type code 'ct' attribute</h1>
<p id="rfc.section.7.1.1.p.1">This section defines a new Web Linking <a href="#RFC5988">[RFC5988]</a> attribute for use with <a href="#I-D.ietf-core-link-format">[I-D.ietf-core-link-format]</a>.  The Content-type code "ct" attribute provides a hint about the Internet media type(s) this resource returns. Note that this is only a hint, and does not override the Content-type Option of a CoAP response obtained by actually following the link. The value is in the CoAP identifier code format as a decimal ASCII integer and MUST be in the range of 0-65535 (16-bit unsigned integer). For example application/xml would be indicated as "ct=41". If no Content-type code attribute is present then nothing about the type can be assumed. The Content-type code attribute MAY appear more than once in a link, indicating that multiple content-types are available.  </p>
<div id="#rfc.figure.13"></div>
<pre>
   link-extension    = &lt;Defined in RFC5988&gt;
   link-extension    = ( "ct" "=" cardinal ) ; Range of 0-65535
   cardinal          = "0" / %x31-39 *DIGIT 

         </pre>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#default-port" id="default-port">Default Ports</a>
</h1>
<p id="rfc.section.7.2.p.1">The CoAP default port number 5683 MUST be supported by a server for resource discovery and SHOULD be supported for providing access to other resources. The DTLS-secured CoAP default port number [IANA_TBD_PORT] MAY be supported by a server for resource discovery and for providing access to other resources. In addition other end-points may be hosted in the dynamic port space.</p>
<p id="rfc.section.7.2.p.2">When a CoAP server is hosted by a 6LoWPAN node, it SHOULD also support a port in the 61616-61631 compressed UDP port space defined in <a href="#RFC4944">[RFC4944]</a>.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#http" id="http">HTTP Mapping</a>
</h1>
<p id="rfc.section.8.p.1">CoAP supports a limited subset of HTTP functionality, and thus a mapping to HTTP is straightforward. There might be several reasons for mapping between CoAP and HTTP, for example when designing a web interface for use over either protocol or when realizing a CoAP-HTTP proxy. Likewise, CoAP could equally be mapped to other protocols such as XMPP <a href="#RFC6120">[RFC6120]</a> or SIP <a href="#RFC3264">[RFC3264]</a>; the definition of these mappings is out of scope of this specification.</p>
<p id="rfc.section.8.p.2">There are two possible mappings via a forward proxy: </p>

<dl>
<dt>CoAP-HTTP Mapping:</dt>
<dd style="margin-left: 8">Enables CoAP clients to access resources on HTTP servers through an intermediary.  This is initiated by including the Proxy-Uri Option with an "http" or "https" URI in a CoAP request to a CoAP-HTTP proxy.</dd>
<dt>HTTP-CoAP Mapping:</dt>
<dd style="margin-left: 8">Enables HTTP clients to access resources on CoAP servers through an intermediary.  This is initiated by specifying a "coap" or "coaps" URI in the Request-Line of an HTTP request to an HTTP-CoAP proxy.</dd>
</dl>

<p> </p>
<p id="rfc.section.8.p.3">Either way, only the Request/Response model of CoAP is mapped to HTTP. The underlying model of confirmable or non-confirmable messages, etc., is invisible and MUST have no effect on a proxy function. The following sections describe the handling of requests to a forward proxy. Reverse proxies are not specified as the proxy function is transparent to the client with the proxy acting as if it was the origin server.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#coap-http" id="coap-http">CoAP-HTTP Mapping</a>
</h1>
<p id="rfc.section.8.1.p.1">If a request contains a Proxy-URI Option with an 'http' or 'https' URI <a href="#RFC2616">[RFC2616]</a>, then the receiving CoAP end-point (called "the proxy" henceforth) is requested to perform the operation specified by the request method on the indicated HTTP resource and return the result to the client.</p>
<p id="rfc.section.8.1.p.2">This section specifies for any CoAP request the CoAP response that the proxy should return to the client. How the proxy actually satisfies the request is an implementation detail, although the typical case is expected to be the proxy translating and forwarding the request to an HTTP origin server.</p>
<p id="rfc.section.8.1.p.3">Since HTTP and CoAP share the basic set of request methods, performing a CoAP request on an HTTP resource is not so different from performing it on a CoAP resource. The meanings of the individual CoAP methods when performed on HTTP resources are explained below.</p>
<p id="rfc.section.8.1.p.4">If the proxy is unable or unwilling to service a request with an HTTP URI, a 5.05 (Proxying Not Supported) response SHOULD be returned to the client. If the proxy services the request by interacting with a third party (such as the HTTP origin server) and is unable to obtain a result within a reasonable time frame, a 5.04 (Gateway Timeout) response SHOULD be returned; if a result can be obtained but is not understood, a 5.02 (Bad Gateway) response SHOULD be returned.</p>
<h1 id="rfc.section.8.1.1">
<a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#coap-http-get" id="coap-http-get">GET</a>
</h1>
<p id="rfc.section.8.1.1.p.1">The GET method requests the proxy to return a representation of the HTTP resource identified by the request URI.</p>
<p id="rfc.section.8.1.1.p.2">Upon success, a 2.05 (Content) response SHOULD be returned. The payload of the response MUST be a representation of the target HTTP resource, and the Content-Type Option be set accordingly. The response MUST indicate a Max-Age value that is no greater than the remaining time the representation can be considered fresh. If the HTTP entity has an entity tag, the proxy SHOULD include an ETag Option in the response and process ETag Options in requests as described below.</p>
<p id="rfc.section.8.1.1.p.3">A client can influence the processing of a GET request by including the following option: </p>

<dl>
<dt>Accept:</dt>
<dd style="margin-left: 8">The request MAY include one or more Accept Options, identifying the preferred response content-type.  </dd>
<dt>ETag:</dt>
<dd style="margin-left: 8">The request MAY include one or more ETag Options, identifying responses that the client has stored. This requests the proxy to send a 2.03 (Valid) response whenever it would send a 2.05 (Content) response with an entity tag in the requested set otherwise.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.8.1.2">
<a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#coap-http-put" id="coap-http-put">PUT</a>
</h1>
<p id="rfc.section.8.1.2.p.1">The PUT method requests the proxy to update or create the HTTP resource identified by the request URI with the enclosed representation.</p>
<p id="rfc.section.8.1.2.p.2">If a new resource is created at the request URI, a 2.01 (Created) response MUST be returned to the client. If an existing resource is modified, a 2.04 (Changed) response MUST be returned to indicate successful completion of the request.</p>
<h1 id="rfc.section.8.1.3">
<a href="#rfc.section.8.1.3">8.1.3.</a> <a href="#coap-http-delete" id="coap-http-delete">DELETE</a>
</h1>
<p id="rfc.section.8.1.3.p.1">The DELETE method requests the proxy to delete the HTTP resource identified by the request URI at the HTTP origin server.</p>
<p id="rfc.section.8.1.3.p.2">A 2.02 (Deleted) response MUST be returned to client upon success or if the resource does not exist at the time of the request.</p>
<h1 id="rfc.section.8.1.4">
<a href="#rfc.section.8.1.4">8.1.4.</a> <a href="#coap-http-post" id="coap-http-post">POST</a>
</h1>
<p id="rfc.section.8.1.4.p.1">The POST method requests the proxy to have the representation enclosed in the request be processed by the HTTP origin server. The actual function performed by the POST method is determined by the origin server and dependent on the resource identified by the request URI.</p>
<p id="rfc.section.8.1.4.p.2">If the action performed by the POST method does not result in a resource that can be identified by a URI, a 2.04 (Changed) response MUST be returned to the client. If a resource has been created on the origin server, a 2.01 (Created) response MUST be returned.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#http-coap" id="http-coap">HTTP-CoAP Mapping</a>
</h1>
<p id="rfc.section.8.2.p.1">If an HTTP request contains a Request-URI with a 'coap' or 'coaps' URI, then the receiving HTTP end-point (called "the proxy" henceforth) is requested to perform the operation specified by the request method on the indicated CoAP resource and return the result to the client.</p>
<p id="rfc.section.8.2.p.2">This section specifies for any HTTP request the HTTP response that the proxy should return to the client. How the proxy actually satisfies the request is an implementation detail, although the typical case is expected to be the proxy translating and forwarding the request to a CoAP origin server. The meanings of the individual HTTP methods when performed on CoAP resources are explained below.</p>
<p id="rfc.section.8.2.p.3">If the proxy is unable or unwilling to service a request with a CoAP URI, a 501 (Not Implemented) response SHOULD be returned to the client. If the proxy services the request by interacting with a third party (such as the CoAP origin server) and is unable to obtain a result within a reasonable time frame, a 504 (Gateway Timeout) response SHOULD be returned; if a result can be obtained but is not understood, a 502 (Bad Gateway) response SHOULD be returned.</p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> <a href="#http-coap-options-trace" id="http-coap-options-trace">OPTIONS and TRACE</a>
</h1>
<p id="rfc.section.8.2.1.p.1">As the OPTIONS and TRACE methods are not supported in CoAP a 501 (Not Implemented) error MUST be returned to the client.  </p>
<h1 id="rfc.section.8.2.2">
<a href="#rfc.section.8.2.2">8.2.2.</a> <a href="#http-coap-get" id="http-coap-get">GET</a>
</h1>
<p id="rfc.section.8.2.2.p.1">The GET method requests the proxy to return a representation of the CoAP resource identified by the Request-URI.</p>
<p id="rfc.section.8.2.2.p.2">Upon success, a 200 (OK) response SHOULD be returned. The payload of the response MUST be a representation of the target CoAP resource, and the Content-Type Option be set accordingly. The response MUST indicate a Max-Age value that is no greater than the remaining time the representation can be considered fresh. If the CoAP entity has an entity tag, the proxy SHOULD include an ETag Option in the response and process ETag Options in requests as described below.</p>
<p id="rfc.section.8.2.2.p.3">A client can influence the processing of a GET request by including the following option: </p>

<dl>
<dt>Accept:</dt>
<dd style="margin-left: 8">Each individual Media-type of the HTTP Accept header in a request is mapped to a CoAP Accept option. HTTP Accept Media-type ranges, parameters and extensions are not supported by the CoAP Accept option. If the proxy cannot send a response which is acceptable according to the combined Accept field value, then the proxy SHOULD send a 406 (not acceptable) response.  </dd>
<dt>Conditional GETs:</dt>
<dd style="margin-left: 8">Conditional HTTP GET requests that include an "If-Match" or "If-None-Match" request-header field can be mapped to a corresponding CoAP request. The "If-Modified-Since" and "If-Unmodified-Since" request-header fields are not directly supported by CoAP, but SHOULD be implemented locally by a caching proxy.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.8.2.3">
<a href="#rfc.section.8.2.3">8.2.3.</a> <a href="#http-coap-head" id="http-coap-head">HEAD</a>
</h1>
<p id="rfc.section.8.2.3.p.1">The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.  </p>
<p id="rfc.section.8.2.3.p.2">Although there is no direct equivalent of HTTP's HEAD method in CoAP, an HTTP-CoAP proxy responds to HEAD requests for CoAP resources, and the HTTP headers are returned without a message-body.  </p>
<h1 id="rfc.section.8.2.4">
<a href="#rfc.section.8.2.4">8.2.4.</a> <a href="#http-coap-post" id="http-coap-post">POST</a>
</h1>
<p id="rfc.section.8.2.4.p.1">The POST method requests the proxy to have the representation enclosed in the request be processed by the CoAP origin server. The actual function performed by the POST method is determined by the origin server and dependent on the resource identified by the request URI.</p>
<p id="rfc.section.8.2.4.p.2">If the action performed by the POST method does not result in a resource that can be identified by a URI, a 200 (OK) or 204 (No Content) response MUST be returned to the client. If a resource has been created on the origin server, a 201 (Created) response MUST be returned.</p>
<h1 id="rfc.section.8.2.5">
<a href="#rfc.section.8.2.5">8.2.5.</a> <a href="#http-coap-put" id="http-coap-put">PUT</a>
</h1>
<p id="rfc.section.8.2.5.p.1">The PUT method requests the proxy to update or create the CoAP resource identified by the Request-URI with the enclosed representation.</p>
<p id="rfc.section.8.2.5.p.2">If a new resource is created at the Request-URI, a 201 (Created) response MUST be returned to the client. If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request.</p>
<h1 id="rfc.section.8.2.6">
<a href="#rfc.section.8.2.6">8.2.6.</a> <a href="#http-coap-delete" id="http-coap-delete">DELETE</a>
</h1>
<p id="rfc.section.8.2.6.p.1">The DELETE method requests the proxy to delete the CoAP resource identified by the Request-URI at the CoAP origin server.</p>
<p id="rfc.section.8.2.6.p.2">A successful response SHOULD be 200 (OK) if the response includes an entity describing the status or 204 (No Content) if the action has been enacted but the response does not include an entity.  </p>
<h1 id="rfc.section.8.2.7">
<a href="#rfc.section.8.2.7">8.2.7.</a> <a href="#http-coap-connect" id="http-coap-connect">CONNECT</a>
</h1>
<p id="rfc.section.8.2.7.p.1">This method can not currently be satisfied by an HTTP-CoAP proxy function as TLS to DTLS tunneling has not been specified. It is however expected that such a tunneling mapping will be defined in the future. A 501 (Not Implemented) error SHOULD be returned to the client.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#constants" id="constants">Protocol Constants</a>
</h1>
<p id="rfc.section.9.p.1">This section defines the relevant protocol constants defined in this document: </p>

<dl>
<dt>RESPONSE_TIMEOUT</dt>
<dd style="margin-left: 8">2 seconds</dd>
<dt>RESPONSE_RANDOM_FACTOR</dt>
<dd style="margin-left: 8">1.5</dd>
<dt>MAX_RETRANSMIT</dt>
<dd style="margin-left: 8">4</dd>
</dl>
<p id="rfc.section.9.p.2">Future specifications are expected that will allow implementations to use other sources for initializing RESPONSE_TIMEOUT. The RESPONSE_TIMEOUT variable MAY be configured with a different value for special environments that exhibit very short or very long RTTs.  </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">This section defines the DTLS binding for CoAP, the alternative use of IPsec, and analyzes the possible threats to the protocol and its limitations.  </p>
<p id="rfc.section.10.p.2">During the bootstrap and enrollment phases, a CoAP device is provided with the security information that it needs, including keying materials. How this is done is out of scope for this specification but a couple of ways of doing this are described in <a href="#I-D.oflynn-core-bootstrapping">[I-D.oflynn-core-bootstrapping]</a>. At the end of the enrollment and bootstrap phase, the device will be in one of four security modes with the following information for the given mode. The NoSec, SharedKey and MultiKey modes are mandatory to implement for this specification. </p>
<p><a href="#EUI64">[EUI64]</a>. The discovery process used in the system would build up the mapping between IP addresses of the given devices and the Authority Name for each device. Some devices could have more than one Authority and would need more than a single certificate.</p>

<dl>
<dt>NoSec:</dt>
<dd style="margin-left: 8">There is no protocol level security (DTLS is disabled). Alternative techniques to provide lower layer security SHOULD be used when appropriate. The use of IPsec is discussed in <a href="#ipsec">Section 10.2</a>.</dd>
<dt>SharedKey:</dt>
<dd style="margin-left: 8">DTLS is enabled and there is one shared key between all the nodes that this CoAP node needs to communicate with.</dd>
<dt>MultiKey:</dt>
<dd style="margin-left: 8">DTLS is enabled and there is a list of shared keys and each key includes a list of which nodes it can be used to communicate with. At the extreme there may be one key for each node this CoAP node needs to communicate with.</dd>
<dt>Certificate:</dt>
<dd style="margin-left: 8">DTLS is enabled and the device has an asymmetric key pair with a X.509 <a href="#RFC5280">[RFC5280]</a> certificate that binds it to its Authority Name and is signed by a some common trust root. The device also has a list of root trust anchors that can be used for validating a certificate. There may be an optional shared key that all the nodes that communicate have access to.</dd>
</dl>

<p> The Authority Name in the certificate is the name that would be used in the Authority part of a CoAP URI. It is worth noting that this would typically not be either an IP address or DNS name but would instead be a long term unique identifier for the device such as the EUI-64 </p>
<p id="rfc.section.10.p.4">In the "NoSec" mode, the system simply sends the packets over normal UDP over IP and is indicated by the "coap" scheme and CoAP default port. The system is secured only by keeping attackers from being able to send or receive packets from the network with the CoAP nodes; see <a href="#cross-protocol-attacks">Section 10.3.4</a> for an additional complication with this approach.</p>
<p id="rfc.section.10.p.5">The other three security modes are achieved using DTLS and are indicated by the "coaps" scheme and DTLS-secured CoAP default port. The result is a security association that can be used to authenticate (within the limits of the security model) and, based on this authentication, authorize the communication partner.  CoAP itself does not provide protocol primitives for authentication or authorization; where this is required, it can either be provided by communication security (i.e., IPsec or DTLS) or by object security (within the payload).  Devices that require authorization for certain operations are expected to require one of these two forms of security.  Necessarily, where an intermediary is involved, communication security only works when that intermediary is part of the trust relationships; CoAP does not provide a way to forward different levels of authorization that clients may have with an intermediary to further intermediaries or origin servers -- it therefore may be required to perform all authorization at the first intermediary.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#dtls" id="dtls">Securing CoAP with DTLS</a>
</h1>
<p id="rfc.section.10.1.p.1">Just as HTTP is secured using Transport Layer Security (TLS) over TCP, CoAP is secured using Datagram TLS (DTLS) <a href="#RFC4347">[RFC4347]</a> over UDP. This section defines the CoAP binding to DTLS, along with the minimal MUST implement configurations appropriate for constrained environments. DTLS is in practice TLS with added features to deal with the unreliable nature of the UDP transport.</p>
<p id="rfc.section.10.1.p.2">In some constrained nodes (limited flash and/or RAM) and networks (limited bandwidth or high scalability requirements), and depending on the specific cipher suites in use, DTLS may not be applicable. Some of DTLS' cipher suites can add significant implementation complexity as well as some initial handshake overhead needed when setting up the security association.  Once the initial handshake is completed, DTLS adds a limited per-datagram overhead of approximately 13 bytes, not including any initialization vectors (which are generally implicitly derived with DTLS), integrity check values (e.g., 8 bytes with TLS_PSK_WITH_AES_128_CCM_8 <a href="#I-D.mcgrew-tls-aes-ccm">[I-D.mcgrew-tls-aes-ccm]</a>) and padding required by the cipher suite.  Whether and which mode of using DTLS is applicable for a CoAP-based application should be carefully weighed considering the specific cipher suites that may be applicable, and whether the session maintenance makes it compatible with application flows and sufficient resources are available on the constrained nodes and for the added network overhead.  DTLS is not applicable to group keying (multicast communication); however, it may be a component in a future group key management protocol.</p>
<p id="rfc.section.10.1.p.3">Devices SHOULD support the Server Name Indication (SNI) to indicate their Authority Name in the SNI HostName field as defined in Section 3 of <a href="#RFC6066">[RFC6066]</a>. This is needed so that when a host that acts as a virtual server for multiple Authorities receives a new DTLS connection, it knows which keys to use for the DTLS session.</p>
<p id="rfc.section.10.1.p.4">DTLS connections with certificates are set up using mutual authentication so they can remain up and be reused for future message exchanges in either direction. Devices can close a DTLS connection when they need to recover resources but in general they should keep the connection up for as long as possible. Closing the DTLS connection after every CoAP message exchange is very inefficient.</p>
<h1 id="rfc.section.10.1.1">
<a href="#rfc.section.10.1.1">10.1.1.</a> SharedKey and MultiKey Modes</h1>
<p id="rfc.section.10.1.1.p.1">When forming a connection to a new node, the system selects an appropriate key based on which nodes it is trying to reach then forms a DTLS session using a PSK (Pre-Shared Key) mode of DTLS.  Implementations in these modes MUST support the mandatory to implement cipher suite TLS_PSK_WITH_AES_128_CCM_8 as specified in <a href="#I-D.mcgrew-tls-aes-ccm">[I-D.mcgrew-tls-aes-ccm]</a>.  </p>
<p id="rfc.section.10.1.1.p.2">The security considerations of <a href="#RFC4279">[RFC4279]</a> (Section 7) apply.  In particular, applications should carefully weigh whether they need Perfect Forward Secrecy (PFS) or not and select an appropriate cipher suite (7.1).  The entropy of the PSK must be sufficient to mitigate against brute-force and (where the PSK is not chosen randomly but by a human) dictionary attacks (7.2).  The cleartext communication of client identities may leak data or compromise privacy (7.3).  </p>
<h1 id="rfc.section.10.1.2">
<a href="#rfc.section.10.1.2">10.1.2.</a> Certificate Mode</h1>
<p id="rfc.section.10.1.2.p.1">Implementations in Certificate Mode MUST support the mandatory to implement cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as specified in <a href="#RFC5246">[RFC5246]</a>.</p>
<p id="rfc.section.10.1.2.p.2">When a new connection is formed, the certificate from the remote device needs to be verified. If the CoAP node has a source of absolute time, then the node SHOULD check the validity dates are of the certificate are within range. The certificate MUST also be signed by an appropriate chain of trust. If the certificate contains a SubjectAltName, then the Authority Name MUST match at least one of the authority names of any CoAP URI found in a URI type fields in the SubjectAltName set. If there is no SubjectAltName in the certificate, then the Authoritative Name must match the CN found in the certificate using the matching rules defined in <a href="#RFC2818">[RFC2818]</a> with the exception that certificates with wildcards are not allowed.</p>
<p id="rfc.section.10.1.2.p.3">If the system has a shared key in addition to the certificate, then a cipher suite that includes the shared key such as TLS_RSA_PSK_WITH_AES_128_CBC_SHA SHOULD be used. </p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#ipsec" id="ipsec">Using CoAP with IPsec</a>
</h1>
<p id="rfc.section.10.2.p.1">One mechanism to secure CoAP in constrained environments is the IPsec Encapsulating Security Payload (ESP) <a href="#RFC4303">[RFC4303]</a> when CoAP is used without DTLS in NoSec Mode. Using IPsec ESP with the appropriate configuration, it is possible for many constrained devices to support encryption with built-in link-layer encryption hardware. For example, some IEEE 802.15.4 radio chips are compatible with AES-CBC (with 128-bit keys) <a href="#RFC3602">[RFC3602]</a> as defined for use with IPsec in <a href="#RFC4835">[RFC4835]</a>.  Alternatively, particularly on more common IEEE 802.15.4 hardware that supports AES encryption but not decryption, and to avoid the need for padding, nodes could directly use the more widely supported AES-CCM as defined for use with IPsec in <a href="#RFC4309">[RFC4309]</a>, if the security considerations in Section 9 of that specification can be fulfilled.</p>
<p id="rfc.section.10.2.p.2">Necessarily for AES-CCM, but much preferably also for AES-CBC, static keying should be avoided and the initial keying material be derived into transient session keys, e.g. using a low-overhead mode of IKEv2 <a href="#RFC5996">[RFC5996]</a> as described in <a href="#I-D.kivinen-ipsecme-ikev2-minimal">[I-D.kivinen-ipsecme-ikev2-minimal]</a>; such a protocol for managing keys and sequence numbers is also the only way to achieve anti-replay capabilities.  However, no recommendation can be made at this point on how to manage group keys (i.e., for multicast) in a constrained environment.  Once any initial setup is completed, IPsec ESP adds a limited overhead of approximately 10 bytes per packet, not including initialization vectors, integrity check values and padding required by the cipher suite.  </p>
<p id="rfc.section.10.2.p.3">When using IPsec to secure CoAP, both authentication and confidentiality SHOULD be applied as recommended in <a href="#RFC4303">[RFC4303]</a>. The use of IPsec between CoAP end-points is transparent to the application layer and does not require special consideration for a CoAP implementation. </p>
<p id="rfc.section.10.2.p.4">IPsec may not be appropriate for all environments. For example, IPsec support is not available for many embedded IP stacks and even in full PC operating systems or on back-end web servers, application developers may not have sufficient access to configure or enable IPsec or to add a security gateway to the infrastructure. Problems with firewalls and NATs may furthermore limit the use of IPsec.</p>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> Threat analysis and protocol limitations</h1>
<p id="rfc.section.10.3.p.1">This section is meant to inform protocol and application developers about the security limitations of CoAP as described in this document.  As CoAP realizes a subset of the features in HTTP/1.1, the security considerations in Section 15 of <a href="#RFC2616">[RFC2616]</a> are also pertinent to CoAP. This section concentrates on describing limitations specific to CoAP.</p>
<h1 id="rfc.section.10.3.1">
<a href="#rfc.section.10.3.1">10.3.1.</a> <a href="#protocol-parsing-processing-uris" id="protocol-parsing-processing-uris">Protocol Parsing, Processing URIs</a>
</h1>
<p id="rfc.section.10.3.1.p.1">A network-facing application can exhibit vulnerabilities in its processing logic for incoming packets.  Complex parsers are well-known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it.  CoAP attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible, and by aggressively reducing complexity that is often caused by unnecessary choice between multiple representations that mean the same thing.  Much of the URI processing has been moved to the clients, further reducing the opportunities for introducing vulnerabilities into the servers.  Even so, the URI processing code in CoAP implementations is likely to be a large source of remaining vulnerabilities and should be implemented with special care.  The most complex parser remaining could be the one for the link-format, although this also has been designed with a goal of reduced implementation complexity <a href="#I-D.ietf-core-link-format">[I-D.ietf-core-link-format]</a>.  (See also section 15.2 of <a href="#RFC2616">[RFC2616]</a>.)</p>
<h1 id="rfc.section.10.3.2">
<a href="#rfc.section.10.3.2">10.3.2.</a> Proxying and Caching</h1>
<p id="rfc.section.10.3.2.p.1">As mentioned in 15.7 of <a href="#RFC2616">[RFC2616]</a>, which see, proxies are by their very nature men-in-the-middle, breaking any IPsec or DTLS protection that a direct CoAP message exchange might have.  They are therefore interesting targets for breaking confidentiality or integrity of CoAP message exchanges.  As noted in <a href="#RFC2616">[RFC2616]</a>, they are also interesting targets for breaking availability.  </p>
<p id="rfc.section.10.3.2.p.2">The threat to confidentiality and integrity of request/response data is amplified where proxies also cache.  Note that CoAP does not define any of the cache-suppressing Cache-Control options that HTTP/1.1 provides to better protect sensitive data.  </p>
<p id="rfc.section.10.3.2.p.3">Finally, a proxy that fans out Separate Responses (as opposed to Piggy-backed Responses) to multiple original requesters may provide additional amplification (see below).  </p>
<h1 id="rfc.section.10.3.3">
<a href="#rfc.section.10.3.3">10.3.3.</a> <a href="#amplification" id="amplification">Risk of amplification</a>
</h1>
<p id="rfc.section.10.3.3.p.1">CoAP servers generally reply to a request packet with a response packet.  This response packet may be significantly larger than the request packet.  An attacker might use CoAP nodes to turn a small attack packet into a larger attack packet, an approach known as amplification.  There is therefore a danger that CoAP nodes could become implicated in denial of service (DoS) attacks by using the amplifying properties of the protocol:  An attacker that is attempting to overload a victim but is limited in the amount of traffic it can generate, can use amplification to generate a larger amount of traffic.  </p>
<p id="rfc.section.10.3.3.p.2">This is particularly a problem in nodes that enable NoSec access, that are accessible from an attacker and can access potential victims (e.g. on the general Internet), as the UDP protocol provides no way to verify the source address given in the request packet.  An attacker need only place the IP address of the victim in the source address of a suitable request packet to generate a larger packet directed at the victim.  </p>
<p id="rfc.section.10.3.3.p.3">As a mitigating factor, many constrained networks will only be able to generate a small amount of traffic, which may make CoAP nodes less attractive for this attack.  However, the limited capacity of the constrained network makes the network itself a likely victim of an amplification attack.  </p>
<p id="rfc.section.10.3.3.p.4">A CoAP server can reduce the amount of amplification it provides to an attacker by using slicing/blocking modes of CoAP <a href="#I-D.ietf-core-block">[I-D.ietf-core-block]</a> and offering large resource representations only in relatively small slices.  E.g., for a 1000 byte resource, a 10-byte request might result in an 80-byte response (with a 64-byte block) instead of a 1016-byte response, considerably reducing the amplification provided.  </p>
<p id="rfc.section.10.3.3.p.5">CoAP also supports the use of multicast IP addresses in requests, an important requirement for M2M. Multicast CoAP requests may be the source of accidental or deliberate denial of service attacks, especially over constrained networks. This specification attempts to reduce the amplification effects of multicast requests by limiting when a response is returned. To limit the possibility of malicious use, CoAP servers SHOULD NOT accept multicast requests that can not be authenticated.  If possible a CoAP server SHOULD limit the support for multicast requests to specific resources where the feature is required.  </p>
<p id="rfc.section.10.3.3.p.6">On some general purpose operating systems providing a Posix-style API, it is not straightforward to find out whether a packet received was addressed to a multicast address.  While many implementations will know whether they have joined a multicast group, this creates a problem for packets addressed to multicast addresses of the form FF0x::1, which are received by every IPv6 node.  Implementations SHOULD make use of modern APIs such as IPV6_RECVPKTINFO <a href="#RFC3542">[RFC3542]</a>, if available, to make this determination.  </p>
<h1 id="rfc.section.10.3.4">
<a href="#rfc.section.10.3.4">10.3.4.</a> <a href="#cross-protocol-attacks" id="cross-protocol-attacks">Cross-Protocol Attacks</a>
</h1>
<p id="rfc.section.10.3.4.p.1">The ability to incite a CoAP end-point to send packets to a fake source address can be used not only for amplification, but also for cross-protocol attacks:</p>
<p></p>

<ul>
<li>the attacker sends a message to a CoAP end-point with a fake source address,</li>
<li>the CoAP end-point replies with a message to the given source address,</li>
<li>the victim at the given source address receives a UDP packet that it interprets according to the rules of a different protocol.</li>
</ul>
<p id="rfc.section.10.3.4.p.3">This may be used to circumvent firewall rules that prevent direct communication from the attacker to the victim, but happen to allow communication from the CoAP end-point (which may also host a valid role in the other protocol) to the victim.</p>
<p id="rfc.section.10.3.4.p.4">Also, CoAP end-points may be the victim of a cross-protocol attack generated through an end-point of another UDP-based protocol such as DNS.  In both cases, attacks are possible if the security properties of the end-points rely on checking IP addresses (and firewalling off direct attacks sent from outside using fake IP addresses).  In general, because of their lack of context, UDP-based protocols are relatively easy targets for cross-protocol attacks.</p>
<p id="rfc.section.10.3.4.p.5">Finally, CoAP URIs transported by other means could be used to incite clients to send messages to end-points of other protocols.</p>
<p id="rfc.section.10.3.4.p.6">One mitigation against cross-protocol attacks is strict checking of the syntax of packets received, combined with sufficient difference in syntax.  As an example, it might help if it were difficult to incite a DNS server to send a DNS response that would pass the checks of a CoAP end-point.  Unfortunately, the first two bytes of a DNS reply are an ID that can be chosen by the attacker, which map into the interesting part of the CoAP header, and the next two bytes are then interpreted as CoAP's Message ID (i.e., any value is acceptable).  The DNS count words may be interpreted as multiple instances of a (non-existent, but elective) CoAP option 0.  The echoed query finally may be manufactured by the attacker to achieve a desired effect on the CoAP end-point; the response added by the server (if any) might then just be interpreted as added payload.</p>
<div id="#rfc.figure.14"></div>
<div id="#dns-header"></div>
<pre>
                                1  1  1  1  1  1
  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       | T, OC, code
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | message id
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QDCOUNT                    | (options 0)
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ANCOUNT                    | (options 0)
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    NSCOUNT                    | (options 0)
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ARCOUNT                    | (options 0)
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>
<p id="rfc.section.10.3.4.p.7">In general, for any pair of protocols, one of the protocols can very well have been designed in a way that enables an attacker to cause the generation of replies that look like messages of the other protocol.  It is often much harder to ensure or prove the absence of viable attacks than to generate examples that may not yet completely enable an attack but might be further developed by more creative minds.  Cross-protocol attacks can therefore only be completely mitigated if end-points don't authorize actions desired by an attacker just based on trusting the source IP address of a packet.  Conversely, a NoSec environment that completely relies on a firewall for CoAP security not only needs to firewall off the CoAP end-points but also all other end-points that might be incited to send UDP messages to CoAP end-points using some other UDP-based protocol.</p>
<p id="rfc.section.10.3.4.p.8">In addition to the considerations above, the security considerations for DTLS with respect to cross-protocol attacks apply.  E.g., if the same DTLS security association ("connection") is used to carry data of multiple protocols, DTLS no longer provides protection against cross-protocol attacks between these protocols.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#coap-code-registry" id="coap-code-registry">CoAP Code Registry</a>
</h1>
<p id="rfc.section.11.1.p.1">This document defines a registry for the values of the Code field in the CoAP header. The name of the registry is "CoAP Codes".</p>
<p id="rfc.section.11.1.p.2">All values are assigned by sub-registries according to the following ranges: </p>

<dl>
<dt>0</dt>
<dd style="margin-left: 10">Indicates an empty message (see <a href="#message-types">Section 4.3</a>).</dd>
<dt>1-31</dt>
<dd style="margin-left: 10">Indicates a request. Values in this range are assigned by the "CoAP Method Codes" sub-registry (see <a href="#coap-code-registry-methods">Section 11.1.1</a>).</dd>
<dt>32-63</dt>
<dd style="margin-left: 10">Reserved</dd>
<dt>64-191</dt>
<dd style="margin-left: 10">Indicates a response. Values in this range are assigned by the "CoAP Response Codes" sub-registry (see <a href="#coap-code-registry-responses">Section 11.1.2</a>).</dd>
<dt>192-255</dt>
<dd style="margin-left: 10">Reserved</dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.1.1">
<a href="#rfc.section.11.1.1">11.1.1.</a> <a href="#coap-code-registry-methods" id="coap-code-registry-methods">Method Codes</a>
</h1>
<p id="rfc.section.11.1.1.p.1">The name of the sub-registry is "CoAP Method Codes".</p>
<p id="rfc.section.11.1.1.p.2">Each entry in the sub-registry must include the Method Code in the range 1-31, the name of the method, and a reference to the method's documentation.</p>
<p id="rfc.section.11.1.1.p.3">Initial entries in this sub-registry are as follows:</p>
<div id="#rfc.table.2"></div>
<div id="#tab-method-code-registry"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CoAP Method Codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Reference</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">GET   </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">POST  </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">PUT   </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">DELETE</td>
<td class="left">[RFCXXXX]</td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.1.1.p.4">All other Method Codes are Unassigned.</p>
<p id="rfc.section.11.1.1.p.5">The IANA policy for future additions to this registry is "IETF Review" as described in <a href="#RFC5226">[RFC5226]</a>.</p>
<p id="rfc.section.11.1.1.p.6">The documentation of a method code should specify the semantics of a request with that code, including the following properties: </p>

<ul>
<li>The response codes the method returns in the success case.</li>
<li>Whether the method is idempotent, safe, or both.</li>
<li>Whether the request causes a cache to mark responses stored for the request URI as not fresh.</li>
</ul>

<p> </p>
<h1 id="rfc.section.11.1.2">
<a href="#rfc.section.11.1.2">11.1.2.</a> <a href="#coap-code-registry-responses" id="coap-code-registry-responses">Response Codes</a>
</h1>
<p id="rfc.section.11.1.2.p.1">The name of the sub-registry is "CoAP Response Codes".</p>
<p id="rfc.section.11.1.2.p.2">Each entry in the sub-registry must include the Response Code in the range 64-191, a description of the Response Code, and a reference to the Response Code's documentation.</p>
<p id="rfc.section.11.1.2.p.3">Initial entries in this sub-registry are as follows:</p>
<div id="#rfc.table.3"></div>
<div id="#tab-response-code-registry"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CoAP Response Codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Description</th>
<th class="left">Reference</th>
</tr></thead>
<tbody>
<tr>
<td class="right">65</td>
<td class="left">2.01 Created                 </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">66</td>
<td class="left">2.02 Deleted                 </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">67</td>
<td class="left">2.03 Valid                   </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">68</td>
<td class="left">2.04 Changed                 </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">69</td>
<td class="left">2.05 Content                 </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">128</td>
<td class="left">4.00 Bad Request             </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">129</td>
<td class="left">4.01 Unauthorized            </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">130</td>
<td class="left">4.02 Bad Option              </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">131</td>
<td class="left">4.03 Forbidden               </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">132</td>
<td class="left">4.04 Not Found               </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">133</td>
<td class="left">4.05 Method Not Allowed      </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">140</td>
<td class="left">4.12 Precondition Failed     </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">141</td>
<td class="left">4.13 Request Entity Too Large</td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">143</td>
<td class="left">4.15 Unsupported Media Type  </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">160</td>
<td class="left">5.00 Internal Server Error   </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">161</td>
<td class="left">5.01 Not Implemented         </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">162</td>
<td class="left">5.02 Bad Gateway             </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">163</td>
<td class="left">5.03 Service Unavailable     </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">164</td>
<td class="left">5.04 Gateway Timeout         </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">165</td>
<td class="left">5.05 Proxying Not Supported  </td>
<td class="left">[RFCXXXX]</td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.1.2.p.4">The Response Codes 96-127 are Reserved for future use. All other Response Codes are Unassigned.</p>
<p id="rfc.section.11.1.2.p.5">The IANA policy for future additions to this registry is "IETF Review" as described in <a href="#RFC5226">[RFC5226]</a>.</p>
<p id="rfc.section.11.1.2.p.6">The documentation of a response code should specify the semantics of a response with that code, including the following properties: </p>

<ul>
<li>The methods the response code applies to.</li>
<li>Whether payload is required, optional or not allowed.</li>
<li>The semantics of the payload. For example, the payload of a 2.05 (Content) response is a representation of the target resource; the payload in an error response is a human-readable diagnostic message.</li>
<li>The format of the payload. For example, the format in a 2.05 (Content) response is indicated by the Content-Type Option; the format of the payload in an error response is always Net-Unicode text.</li>
<li>Whether the response is cacheable according to the freshness model.</li>
<li>Whether the response is validatable according to the validation model.</li>
<li>Whether the response causes a cache to mark responses stored for the request URI as not fresh.</li>
</ul>

<p> </p>
<h1 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> <a href="#option-number-registry" id="option-number-registry">Option Number Registry</a>
</h1>
<p id="rfc.section.11.2.p.1">This document defines a registry for the Option Numbers used in CoAP options. The name of the registry is "CoAP Option Numbers".</p>
<p id="rfc.section.11.2.p.2">Each entry in the registry must include the Option Number, the name of the option and a reference to the option's documentation.</p>
<p id="rfc.section.11.2.p.3">Initial entries in this registry are as follows:</p>
<div id="#rfc.table.4"></div>
<div id="#tab-option-registry"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CoAP Option Numbers</caption>
<thead><tr>
<th class="right">Number</th>
<th class="left">Name</th>
<th class="left">Reference</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">Content-Type  </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">Max-Age       </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">Proxy-Uri     </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">ETag          </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">Uri-Host      </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">6</td>
<td class="left">Location-Path </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">7</td>
<td class="left">Uri-Port      </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">8</td>
<td class="left">Location-Query</td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">9</td>
<td class="left">Uri-Path      </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">11</td>
<td class="left">Token         </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">12</td>
<td class="left">Accept        </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">13</td>
<td class="left">If-Match      </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">15</td>
<td class="left">Uri-Query     </td>
<td class="left">[RFCXXXX]</td>
</tr>
<tr>
<td class="right">21</td>
<td class="left">If-None-Match </td>
<td class="left">[RFCXXXX]</td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.2.p.4">The Option Number 0 is Reserved for future use. The Option Numbers 14, 28, 42, ... are Reserved for "fenceposting" (see <a href="#option-format">Section 3.2</a>). All other Option Numbers are Unassigned.</p>
<p id="rfc.section.11.2.p.5">The IANA policy for future additions to this registry is "IETF Review" as described in <a href="#RFC5226">[RFC5226]</a>.</p>
<p id="rfc.section.11.2.p.6">The documentation of an Option Number should specify the semantics of an option with that number, including the following properties: </p>

<ul>
<li>The meaning of the option in a request.</li>
<li>The meaning of the option in a response.</li>
<li>Whether the option is critical of elective, as determined by the Option Number.</li>
<li>The format and length of the option's value.</li>
<li>Whether the option must occur at most once or whether it can occur multiple times.</li>
<li>The default value, if any.</li>
</ul>

<p> </p>
<h1 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> <a href="#media-type-registry" id="media-type-registry">Media Type Registry</a>
</h1>
<p id="rfc.section.11.3.p.1">Media types are identified by a string, such as "application/xml" <a href="#RFC2046">[RFC2046]</a>. In order to minimize the overhead of using these media types to indicate the format of payloads, this document defines a registry for a subset of Internet media types to be used in CoAP and assigns each a numeric identifier. The name of the registry is "CoAP Media Types".</p>
<p id="rfc.section.11.3.p.2">Each entry in the registry must include the media type registered with IANA, the numeric identifier in the range 0-65535 to be used for that media type in CoAP, and a reference to a document describing what payload with that media type means semantically.</p>
<p id="rfc.section.11.3.p.3">Initial entries in this registry are as follows:</p>
<div id="#rfc.table.5"></div>
<div id="#tab-mediatype"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CoAP Media Types</caption>
<thead><tr>
<th class="left">Media type</th>
<th class="right">Id.</th>
<th class="left">Reference</th>
</tr></thead>
<tbody>
<tr>
<td class="left">text/plain; charset=utf-8</td>
<td class="right">0</td>
<td class="left">
<a href="#RFC2046">[RFC2046]</a><a href="#RFC3676">[RFC3676]</a><a href="#RFC5147">[RFC5147]</a>
</td>
</tr>
<tr>
<td class="left">application/link-format</td>
<td class="right">40</td>
<td class="left"><a href="#I-D.ietf-core-link-format">[I-D.ietf-core-link-format]</a></td>
</tr>
<tr>
<td class="left">application/xml</td>
<td class="right">41</td>
<td class="left"><a href="#RFC3023">[RFC3023]</a></td>
</tr>
<tr>
<td class="left">application/octet-stream</td>
<td class="right">42</td>
<td class="left">
<a href="#RFC2045">[RFC2045]</a><a href="#RFC2046">[RFC2046]</a>
</td>
</tr>
<tr>
<td class="left">application/exi</td>
<td class="right">47</td>
<td class="left"><a href="#EXIMIME">[EXIMIME]</a></td>
</tr>
<tr>
<td class="left">application/json</td>
<td class="right">50</td>
<td class="left"><a href="#RFC4627">[RFC4627]</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.11.3.p.4">The identifiers between 201 and 255 inclusive are reserved for Private Use.  All other identifiers are Unassigned.</p>
<p id="rfc.section.11.3.p.5">Because the name space of single-byte identifiers is so small, the IANA policy for future additions in the range 0-200 inclusive to the registry is "Expert Review" as described in <a href="#RFC5226">[RFC5226]</a>.  The IANA policy for additions in the range 256-65535 inclusive is "First Come First Served" as described in <a href="#RFC5226">[RFC5226]</a>.</p>
<p id="rfc.section.11.3.p.6">In machine to machine applications, it is not expected that generic Internet media types such as text/plain, application/xml or application/octet-stream are useful for real applications in the long term. It is recommended that M2M applications making use of CoAP will request new Internet media types from IANA indicating semantic information about how to create or parse a payload. For example, a Smart Energy application payload carried as XML might request a more specific type like application/se+xml or application/se+exi.  </p>
<h1 id="rfc.section.11.4">
<a href="#rfc.section.11.4">11.4.</a> <a href="#uri-scheme-registration" id="uri-scheme-registration">URI Scheme Registration</a>
</h1>
<p id="rfc.section.11.4.p.1">This document requests the registration of the Uniform Resource Identifier (URI) scheme "coap". The registration request complies with <a href="#RFC4395">[RFC4395]</a>.  </p>

<dl>
<dt>URI scheme name.</dt>
<dd style="margin-left: 8">
<br> coap</dd>
<dt>Status.</dt>
<dd style="margin-left: 8">
<br> Permanent.</dd>
<dt>URI scheme syntax.</dt>
<dd style="margin-left: 8">
<br> Defined in <a href="#uri-coap">Section 6.1</a> of [RFCXXXX].</dd>
<dt>URI scheme semantics.</dt>
<dd style="margin-left: 8">
<br> The "coap" URI scheme provides a way to identify resources that are potentially accessible over the Constrained Application Protocol (CoAP). The resources can be located by contacting the governing CoAP server and operated on by sending CoAP requests to the server.  This scheme can thus be compared to the "http" URI scheme <a href="#RFC2616">[RFC2616]</a>. See <a href="#uri">Section 6</a> of [RFCXXXX] for the details of operation.</dd>
<dt>Encoding considerations.</dt>
<dd style="margin-left: 8">
<br> The scheme encoding conforms to the encoding rules established for URIs in <a href="#RFC3986">[RFC3986]</a>, i.e. internationalized and reserved characters are expressed using UTF-8-based percent-encoding.</dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd style="margin-left: 8">
<br> The scheme is used by CoAP end-points to access CoAP resources.</dd>
<dt>Interoperability considerations.</dt>
<dd style="margin-left: 8">
<br> None.</dd>
<dt>Security considerations.</dt>
<dd style="margin-left: 8">
<br> See <a href="#protocol-parsing-processing-uris">Section 10.3.1</a> of [RFCXXXX].</dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br> IETF Chair &lt;chair@ietf.org&gt;</dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br> IESG &lt;iesg@ietf.org&gt;</dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br> [RFCXXXX]</dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.5">
<a href="#rfc.section.11.5">11.5.</a> <a href="#coaps-uri-scheme-registration" id="coaps-uri-scheme-registration">Secure URI Scheme Registration</a>
</h1>
<p id="rfc.section.11.5.p.1">This document requests the registration of the Uniform Resource Identifier (URI) scheme "coaps". The registration request complies with <a href="#RFC4395">[RFC4395]</a>.  </p>

<dl>
<dt>URI scheme name.</dt>
<dd style="margin-left: 8">
<br> coaps</dd>
<dt>Status.</dt>
<dd style="margin-left: 8">
<br> Permanent.</dd>
<dt>URI scheme syntax.</dt>
<dd style="margin-left: 8">
<br> Defined in <a href="#uri-coaps">Section 6.2</a> of [RFCXXXX].</dd>
<dt>URI scheme semantics.</dt>
<dd style="margin-left: 8">
<br> The "coaps" URI scheme provides a way to identify resources that are potentially accessible over the Constrained Application Protocol (CoAP) using DTLS for session security. The resources can be located by contacting the governing CoAP server and operated on by sending CoAP requests to the server.  This scheme can thus be compared to the "https" URI scheme <a href="#RFC2616">[RFC2616]</a>. See <a href="#uri">Section 6</a> of [RFCXXXX] for the details of operation.</dd>
<dt>Encoding considerations.</dt>
<dd style="margin-left: 8">
<br> The scheme encoding conforms to the encoding rules established for URIs in <a href="#RFC3986">[RFC3986]</a>, i.e. internationalized and reserved characters are expressed using UTF-8-based percent-encoding.</dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd style="margin-left: 8">
<br> The scheme is used by CoAP end-points to access CoAP resources using DTLS.</dd>
<dt>Interoperability considerations.</dt>
<dd style="margin-left: 8">
<br> None.</dd>
<dt>Security considerations.</dt>
<dd style="margin-left: 8">
<br> See <a href="#protocol-parsing-processing-uris">Section 10.3.1</a> of [RFCXXXX].</dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br> IETF Chair &lt;chair@ietf.org&gt;</dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br> IESG &lt;iesg@ietf.org&gt;</dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br> [RFCXXXX]</dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.6">
<a href="#rfc.section.11.6">11.6.</a> <a href="#port-registration" id="port-registration">Service Name and Port Number Registration</a>
</h1>
<p id="rfc.section.11.6.p.1">One of the functions of CoAP is resource discovery: a CoAP client can ask a CoAP server about the resources offered by it (see <a href="#discovery">Section 7.1</a>). To enable resource discovery just based on the knowledge of an IP address, the CoAP port for resource discovery needs to be standardized.</p>
<p id="rfc.section.11.6.p.2">IANA has assigned the port number 5683 and the service name "coap", in accordance with <a href="#I-D.ietf-tsvwg-iana-ports">[I-D.ietf-tsvwg-iana-ports]</a>.</p>
<p id="rfc.section.11.6.p.3">Besides unicast, CoAP can be used with both multicast and anycast.  </p>

<dl>
<dt>Service Name.</dt>
<dd style="margin-left: 8">
<br> coap</dd>
<dt>Transport Protocol.</dt>
<dd style="margin-left: 8">
<br> UDP</dd>
<dt>Assignee.</dt>
<dd style="margin-left: 8">
<br> IESG &lt;iesg@ietf.org&gt;</dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br> IETF Chair &lt;chair@ietf.org&gt;</dd>
<dt>Description.</dt>
<dd style="margin-left: 8">
<br> Constrained Application Protocol (CoAP)</dd>
<dt>Reference.</dt>
<dd style="margin-left: 8">
<br> [RFCXXXX]</dd>
<dt>Port Number.</dt>
<dd style="margin-left: 8">
<br> 5683</dd>
</dl>

<p> </p>
<h1 id="rfc.section.11.7">
<a href="#rfc.section.11.7">11.7.</a> <a href="#secure-port-registration" id="secure-port-registration">Secure Service Name and Port Number Registration</a>
</h1>
<p id="rfc.section.11.7.p.1">CoAP resource discovery may also be provided using the DTLS-secured CoAP "coaps" scheme. Thus the CoAP port for secure resource discovery needs to be standardized.</p>
<p id="rfc.section.11.7.p.2">This document requests the assignment of the port number [IANA_TBD_PORT] and the service name "coaps", in accordance with <a href="#I-D.ietf-tsvwg-iana-ports">[I-D.ietf-tsvwg-iana-ports]</a>.</p>
<p id="rfc.section.11.7.p.3">Besides unicast, Secure CoAP can be used with anycast.  </p>

<dl>
<dt>Service Name.</dt>
<dd style="margin-left: 8">
<br> coaps</dd>
<dt>Transport Protocol.</dt>
<dd style="margin-left: 8">
<br> UDP</dd>
<dt>Assignee.</dt>
<dd style="margin-left: 8">
<br> IESG &lt;iesg@ietf.org&gt;</dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br> IETF Chair &lt;chair@ietf.org&gt;</dd>
<dt>Description.</dt>
<dd style="margin-left: 8">
<br> DTLS-secured CoAP</dd>
<dt>Reference.</dt>
<dd style="margin-left: 8">
<br> [RFCXXXX]</dd>
<dt>Port Number.</dt>
<dd style="margin-left: 8">
<br> [IANA_TBD_PORT]</dd>
</dl>

<p> </p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> Acknowledgements</h1>
<p id="rfc.section.12.p.1">Special thanks to Peter Bigot and Cullen Jennings for substantial contributions to the ideas and text in the document, along with countless detailed reviews and discussions.</p>
<p id="rfc.section.12.p.2">Thanks to Michael Stuber, Richard Kelsey, Guido Moritz, Peter Van Der Stok, Adriano Pezzuto, Lisa Dussealt, Alexey Melnikov, Gilbert Clark, Salvatore Loreto, Petri Mutka, Szymon Sasin, Robert Quattlebaum, Robert Cragie, Angelo Castellani, Tom Herbst, Ed Beroset, Gilman Tolle, Robby Simpson, Colin O'Flynn, Eric Rescorla, Matthieu Vial, Linyi Tian, Kerry Lynn, Dale Seed, Akbar Rahman, Charles Palmer and David Ryan for helpful comments and discussions that have shaped the document.</p>
<p id="rfc.section.12.p.3">Some of the text has been lifted from the working documents of the IETF httpbis working group.</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2045">[RFC2045]</b></td>
<td class="top">
<a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N.S. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>", RFC 2045, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2046">[RFC2046]</b></td>
<td class="top">
<a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>", RFC 2046, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4279">[RFC4279]</b></td>
<td class="top">
<a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc4279">Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</a>", RFC 4279, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4303">[RFC4303]</b></td>
<td class="top">
<a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5996">[RFC5996]</b></td>
<td class="top">
<a>Kaufman, C.</a>, <a>Hoffman, P.</a>, <a>Nir, Y.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5996">Internet Key Exchange Protocol Version 2 (IKEv2)</a>", RFC 5996, September 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4309">[RFC4309]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="http://tools.ietf.org/html/rfc4309">Using Advanced Encryption Standard (AES) CCM Mode with IPsec Encapsulating Security Payload (ESP)</a>", RFC 4309, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2818">[RFC2818]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3023">[RFC3023]</b></td>
<td class="top">
<a>Murata, M.</a>, <a>St. Laurent, S.</a> and <a>D. Kohn</a>, "<a href="http://tools.ietf.org/html/rfc3023">XML Media Types</a>", RFC 3023, January 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3676">[RFC3676]</b></td>
<td class="top">
<a>Gellens, R.</a>, "<a href="http://tools.ietf.org/html/rfc3676">The Text/Plain Format and DelSp Parameters</a>", RFC 3676, February 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3602">[RFC3602]</b></td>
<td class="top">
<a>Frankel, S.</a>, <a>Glenn, R.</a> and <a>S. Kelly</a>, "<a href="http://tools.ietf.org/html/rfc3602">The AES-CBC Cipher Algorithm and Its Use with IPsec</a>", RFC 3602, September 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4347">[RFC4347]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc4347">Datagram Transport Layer Security</a>", RFC 4347, April 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4395">[RFC4395]</b></td>
<td class="top">
<a>Hansen, T.</a>, <a>Hardie, T.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc4395">Guidelines and Registration Procedures for New URI Schemes</a>", BCP 35, RFC 4395, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4627">[RFC4627]</b></td>
<td class="top">
<a>Crockford, D.</a>, "<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>", RFC 4627, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4835">[RFC4835]</b></td>
<td class="top">
<a>Manral, V.</a>, "<a href="http://tools.ietf.org/html/rfc4835">Cryptographic Algorithm Implementation Requirements for Encapsulating Security Payload (ESP) and Authentication Header (AH)</a>", RFC 4835, April 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5147">[RFC5147]</b></td>
<td class="top">
<a>Wilde, E.</a> and <a>M. Duerst</a>, "<a href="http://tools.ietf.org/html/rfc5147">URI Fragment Identifiers for the text/plain Media Type</a>", RFC 5147, April 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5198">[RFC5198]</b></td>
<td class="top">
<a>Klensin, J.</a> and <a>M. Padlipsky</a>, "<a href="http://tools.ietf.org/html/rfc5198">Unicode Format for Network Interchange</a>", RFC 5198, March 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5785">[RFC5785]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>E. Hammer-Lahav</a>, "<a href="http://tools.ietf.org/html/rfc5785">Defining Well-Known Uniform Resource Identifiers (URIs)</a>", RFC 5785, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5952">[RFC5952]</b></td>
<td class="top">
<a>Kawamura, S.</a> and <a>M. Kawashima</a>, "<a href="http://tools.ietf.org/html/rfc5952">A Recommendation for IPv6 Address Text Representation</a>", RFC 5952, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5988">[RFC5988]</b></td>
<td class="top">
<a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/rfc5988">Web Linking</a>", RFC 5988, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-link-format">[I-D.ietf-core-link-format]</b></td>
<td class="top">
<a>Shelby, Z</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-link-format-09">CoRE Link Format</a>", Internet-Draft draft-ietf-core-link-format-09, November 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3264">[RFC3264]</b></td>
<td class="top">
<a>Rosenberg, J.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>", RFC 3264, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3542">[RFC3542]</b></td>
<td class="top">
<a>Stevens, W.</a>, <a>Thomas, M.</a>, <a>Nordmark, E.</a> and <a>T. Jinmei</a>, "<a href="http://tools.ietf.org/html/rfc3542">Advanced Sockets Application Program Interface (API) for IPv6</a>", RFC 3542, May 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6120">[RFC6120]</b></td>
<td class="top">
<a>Saint-Andre, P.</a>, "<a href="http://tools.ietf.org/html/rfc6120">Extensible Messaging and Presence Protocol (XMPP): Core</a>", RFC 6120, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4944">[RFC4944]</b></td>
<td class="top">
<a>Montenegro, G.</a>, <a>Kushalnagar, N.</a>, <a>Hui, J.</a> and <a>D. Culler</a>, "<a href="http://tools.ietf.org/html/rfc4944">Transmission of IPv6 Packets over IEEE 802.15.4 Networks</a>", RFC 4944, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.kivinen-ipsecme-ikev2-minimal">[I-D.kivinen-ipsecme-ikev2-minimal]</b></td>
<td class="top">
<a>Kivinen, T</a>, "<a href="http://tools.ietf.org/html/draft-kivinen-ipsecme-ikev2-minimal-00">Minimal IKEv2</a>", Internet-Draft draft-kivinen-ipsecme-ikev2-minimal-00, February 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.eggert-core-congestion-control">[I-D.eggert-core-congestion-control]</b></td>
<td class="top">
<a>Eggert, L</a>, "<a href="http://tools.ietf.org/html/draft-eggert-core-congestion-control-01">Congestion Control for the Constrained Application Protocol (CoAP)</a>", Internet-Draft draft-eggert-core-congestion-control-01, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-block">[I-D.ietf-core-block]</b></td>
<td class="top">
<a>Bormann, C</a> and <a>Z Shelby</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-block-04">Blockwise transfers in CoAP</a>", Internet-Draft draft-ietf-core-block-04, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.oflynn-core-bootstrapping">[I-D.oflynn-core-bootstrapping]</b></td>
<td class="top">
<a>Sarikaya, B</a>, <a>Ohba, Y</a>, <a>Cao, Z</a> and <a>R Cragie</a>, "<a href="http://tools.ietf.org/html/draft-oflynn-core-bootstrapping-03">Security Bootstrapping of Resource-Constrained Devices</a>", Internet-Draft draft-oflynn-core-bootstrapping-03, November 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</b></td>
<td class="top">
<a>Fielding, R</a>, <a>Gettys, J</a>, <a>Mogul, J</a>, <a>Nielsen, H</a>, <a>Masinter, L</a>, <a>Leach, P</a>, <a>Berners-Lee, T</a>, <a>Lafon, Y</a> and <a>J Reschke</a>, "<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-17">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</a>", Internet-Draft draft-ietf-httpbis-p1-messaging-17, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="EUI64">[EUI64]</b></td>
<td class="top">
<a>GUIDELINES FOR 64-BIT GLOBAL IDENTIFIER (EUI-64) REGISTRATION AUTHORITY</a>", April 2010.</td>, "</tr>
<tr>
<td class="reference"><b id="EXIMIME">[EXIMIME]</b></td>
<td class="top">
<a>Efficient XML Interchange (EXI) Format 1.0</a>", December 2009.</td>, "</tr>
<tr>
<td class="reference"><b id="I-D.mcgrew-tls-aes-ccm">[I-D.mcgrew-tls-aes-ccm]</b></td>
<td class="top">
<a>McGrew, D</a> and <a>D Bailey</a>, "<a href="http://tools.ietf.org/html/draft-mcgrew-tls-aes-ccm-02">AES-CCM Cipher Suites for TLS</a>", Internet-Draft draft-mcgrew-tls-aes-ccm-02, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-iana-ports">[I-D.ietf-tsvwg-iana-ports]</b></td>
<td class="top">
<a>Cotton, M</a>, <a>Eggert, L</a>, <a>Touch, J</a>, <a>Westerlund, M</a> and <a>S Cheshire</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tsvwg-iana-ports-10">Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry</a>", Internet-Draft draft-ietf-tsvwg-iana-ports-10, February 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#integer" id="integer">Integer Option Value Format</a>
</h1>
<p id="rfc.section.Appendix A.p.1">Options of type uint contain a non-negative integer that is represented in network byte order using a variable number of bytes, as shown below.</p>
<div id="#rfc.figure.15"></div>
<pre>
Length = 0     (implies value of 0)

                0
                0 1 2 3 4 5 6 7
               +-+-+-+-+-+-+-+-+
Length = 1     |     0-255     |
               +-+-+-+-+-+-+-+-+

                0                   1
                0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Length = 2     |            0-65535            |
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Length = 3 is 24 bits, Length = 4 is 32 bits etc.
</pre>
<h1 id="rfc.appendix.Appendix B">
<a href="#rfc.appendix.Appendix%20B">Appendix B.</a> <a href="#examples" id="examples">Examples</a>
</h1>
<p id="rfc.section.Appendix B.p.1">This section gives a number of short examples with message flows for GET requests. These examples demonstrate the basic operation, the operation in the presence of retransmissions, and multicast.</p>
<p><a href="#fig-example-1">Figure 16</a> shows a basic GET request causing a piggy-backed response: The client sends a Confirmable GET request for the resource coap://server/temperature to the server with a Message ID of 0x7d34. The request includes one Uri-Path Option (Delta 0 + 9 = 9, Length 11, Value "temperature"); the Token is left at its default value (empty). This request is a total of 16 bytes long. A 2.05 (Content) response is returned in the Acknowledgement message that acknowledges the Confirmable request, echoing both the Message ID 0x7d34 and the (implicitly empty) Token value. The response includes a Payload of "22.3 C" and is 10 bytes long.</p>
<div id="#rfc.figure.16"></div>
<div id="#fig-example-1"></div>
<pre>
Client  Server
   |      |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d34)
   | GET  |   Uri-Path: "temperature"
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=ACK, Code=69, MID=0x7d34)
   | 2.05 |    Payload: "22.3 C"
   |      |


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1 | 0 |   1   |     GET=1     |          MID=0x7d34           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   9   |  11   |      "temperature" (11 B) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1 | 2 |   0   |    2.05=69    |          MID=0x7d34           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      "22.3 C" (6 B) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p><a href="#fig-example-1a">Figure 17</a> shows a similar example, but with the inclusion of an explicit Token Option (Delta 9 + 2 = 11, Length 1, Value 0x20) in the request and (Delta 11 + 0 = 11) in the response, increasing the sizes to 18 and 12 bytes, respectively.  </p>
<div id="#rfc.figure.17"></div>
<div id="#fig-example-1a"></div>
<pre>
Client  Server
   |      |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d35)
   | GET  |      Token: 0x20
   |      |   Uri-Path: "temperature"
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=ACK, Code=69, MID=0x7d35)
   | 2.05 |      Token: 0x20
   |      |    Payload: "22.3 C"
   |      |


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1 | 0 |   2   |     GET=1     |          MID=0x7d35           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   9   |  11   |      "temperature" (11 B) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   2   |   1   |     0x20      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1 | 2 |   1   |    2.05=69    |          MID=0x7d35           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  11   |   1   |     0x20      |      "22.3 C" (6 B) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.Appendix B.p.4">In <a href="#fig-example-2">Figure 18</a>, the Confirmable GET request is lost. After RESPONSE_TIMEOUT seconds, the client retransmits the request, resulting in a piggy-backed response as in the previous example.</p>
<div id="#rfc.figure.18"></div>
<div id="#fig-example-2"></div>
<pre>
Client  Server
   |      |
   |      |
   +----X |     Header: GET (T=CON, Code=1, MID=0x7d36)
   | GET  |      Token: 0x31
   |      |   Uri-Path: "temperature"
TIMEOUT   |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d36)
   | GET  |      Token: 0x31
   |      |   Uri-Path: "temperature"
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=ACK, Code=69, MID=0x7d36)
   | 2.05 |      Token: 0x31
   |      |    Payload: "22.3 C"
   |      |
</pre>
<p id="rfc.section.Appendix B.p.5">In <a href="#fig-example-3">Figure 19</a>, the first Acknowledgement message from the server to the client is lost. After RESPONSE_TIMEOUT seconds, the client retransmits the request.</p>
<div id="#rfc.figure.19"></div>
<div id="#fig-example-3"></div>
<pre>
Client  Server
   |      |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d37)
   | GET  |      Token: 0x42
   |      |   Uri-Path: "temperature"
   |      |
   |      |
   | X----+     Header: 2.05 Content (T=ACK, Code=69, MID=0x7d37)
   | 2.05 |      Token: 0x42
   |      |    Payload: "22.3 C"
TIMEOUT   |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d37)
   | GET  |      Token: 0x42
   |      |   Uri-Path: "temperature"
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=ACK, Code=69, MID=0x7d37)
   | 2.05 |      Token: 0x42
   |      |    Payload: "22.3 C"
   |      |
</pre>
<p id="rfc.section.Appendix B.p.6">In <a href="#fig-example-4">Figure 20</a>, the server acknowledges the Confirmable request and sends a 2.05 (Content) response separately in a Confirmable message. Note that the Acknowledgement message and the Confirmable response do not necessarily arrive in the same order as they were sent. The client acknowledges the Confirmable response.</p>
<div id="#rfc.figure.20"></div>
<div id="#fig-example-4"></div>
<pre>
Client  Server
   |      |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d38)
   | GET  |      Token: 0x53
   |      |   Uri-Path: "temperature"
   |      |
   |      |
   |&lt;- - -+     Header: (T=ACK, Code=0, MID=0x7d38)
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=CON, Code=69, MID=0xad7b)
   | 2.05 |      Token: 0x53
   |      |    Payload: "22.3 C"
   |      |
   |      |
   +- - -&gt;|     Header: (T=ACK, Code=0, MID=0xad7b)
   |      |
</pre>
<p><a href="#fig-example-5">Figure 21</a> shows an example where the client loses its state (e.g., crashes and is rebooted) right after sending a Confirmable request, so the separate response arriving some time later comes unexpected. In this case, the client rejects the Confirmable response with a Reset message.  Note that the unexpected ACK is silently ignored.</p>
<div id="#rfc.figure.21"></div>
<div id="#fig-example-5"></div>
<pre>
Client  Server
   |      |
   |      |
   +-----&gt;|     Header: GET (T=CON, Code=1, MID=0x7d39)
   | GET  |      Token: 0x64
   |      |   Uri-Path: "temperature"
 CRASH    |
   |      |
   |&lt;- - -+     Header: (T=ACK, Code=0, MID=0x7d39)
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=CON, Code=69, MID=0xad7c)
   | 2.05 |      Token: 0x64
   |      |    Payload: "22.3 C"
   |      |
   |      |
   +- - -&gt;|     Header: (T=RST, Code=0, MID=0xad7c)
   |      |
</pre>
<p><a href="#fig-example-6">Figure 22</a> shows a basic GET request where the request and the response are non-confirmable, so both may be lost without notice.</p>
<div id="#rfc.figure.22"></div>
<div id="#fig-example-6"></div>
<pre>
Client  Server
   |      |
   |      |
   +-----&gt;|     Header: GET (T=NON, Code=1, MID=0x7d40)
   | GET  |      Token: 0x75
   |      |   Uri-Path: "temperature"
   |      |
   |      |
   |&lt;-----+     Header: 2.05 Content (T=NON, Code=69, MID=0xad7d)
   | 2.05 |      Token: 0x75
   |      |    Payload: "22.3 C"
   |      |
</pre>
<p id="rfc.section.Appendix B.p.9">In <a href="#fig-example-7">Figure 23</a>, the client sends a Non-confirmable GET request to a multicast address: all nodes in link-local scope. There are 3 servers on the link: A, B and C.  Servers A and B have a matching resource, therefore they send back a Non-confirmable 2.05 (Content) response. The response sent by B is lost.  C does not have matching response, therefore it sends a Non-confirmable 4.04 (Not Found) response.</p>
<div id="#rfc.figure.23"></div>
<div id="#fig-example-7"></div>
<pre>
Client  ff02::1  A  B  C
   |       |     |  |  |
   |       |     |  |  |
   +------&gt;|     |  |  |   Header: GET (T=NON, Code=1, MID=0x7d41)
   |  GET  |     |  |  |    Token: 0x86
   |             |  |  |    Uri-Path: "temperature"
   |             |  |  |
   |             |  |  |
   |&lt;------------+  |  |   Header: 2.05 (T=NON, Code=69, MID=0x60b1)
   |      2.05   |  |  |    Token: 0x86
   |             |  |  |    Payload: "22.3 C"
   |             |  |  |
   |             |  |  |
   |   X------------+  |   Header: 2.05 (T=NON, Code=69, MID=0x01a0)
   |      2.05   |  |  |    Token: 0x86
   |             |  |  |    Payload: "20.9 C"
   |             |  |  |
   |             |  |  |
   |&lt;------------------+   Header: 4.04 (T=NON, Code=132, MID=0x952a)
   |      4.04   |  |  |    Token: 0x86
   |             |  |  |
</pre>
<h1 id="rfc.appendix.Appendix C">
<a href="#rfc.appendix.Appendix%20C">Appendix C.</a> <a href="#uri-examples" id="uri-examples">URI Examples</a>
</h1>
<p id="rfc.section.Appendix C.p.1">The following examples demonstrate different sets of Uri options, and the result after constructing an URI from them.  </p>

<ul>
<li>coap://[2001:db8::2:1]/ <ul class="empty">
<li>Destination IP Address = [2001:db8::2:1]</li>
<li>Destination UDP Port = 5683</li>
</ul>
<p> </p>
</li>
<li>coap://example.net/ <ul class="empty">
<li>Destination IP Address = [2001:db8::2:1]</li>
<li>Destination UDP Port = 5683</li>
<li>Uri-Host = "example.net"</li>
</ul>
<p> </p>
</li>
<li>coap://example.net/.well-known/core <ul class="empty">
<li>Destination IP Address = [2001:db8::2:1]</li>
<li>Destination UDP Port = 5683</li>
<li>Uri-Host = "example.net"</li>
<li>Uri-Path = ".well-known"</li>
<li>Uri-Path = "core"</li>
</ul>
<p> </p>
</li>
<li>coap://xn--18j4d.example/%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF <ul class="empty">
<li>Destination IP Address = [2001:db8::2:1]</li>
<li>Destination UDP Port = 5683</li>
<li>Uri-Host = "xn--18j4d.example"</li>
<li>Uri-Path = the string composed of the Unicode characters U+3053 U+3093 U+306b U+3061 U+306f, usually represented in UTF-8 as E38193E38293E381ABE381A1E381AF hexadecimal</li>
</ul>
<p> </p>
</li>
<li>coap://198.51.100.1:61616//%2F//?%2F%2F&amp;?%26 <ul class="empty">
<li>Destination IP Address = 198.51.100.1</li>
<li>Destination UDP Port = 61616</li>
<li>Uri-Path = ""</li>
<li>Uri-Path = "/"</li>
<li>Uri-Path = ""</li>
<li>Uri-Path = ""</li>
<li>Uri-Query = "//"</li>
<li>Uri-Query = "?&amp;"</li>
</ul>
<p> </p>
</li>
</ul>

<p> </p>
<h1 id="rfc.appendix.Appendix D">
<a href="#rfc.appendix.Appendix%20D">Appendix D.</a> Changelog</h1>
<p id="rfc.section.Appendix D.p.1">Changed from ietf-06 to ietf-07: </p>

<ul>
<li>application/link-format added to Media types registration (#160)</li>
<li>Moved content-type attribute to the document from link-format.</li>
<li>Added coaps scheme and DTLS-secured CoAP default port (#154)</li>
<li>Allowed 0-length Content-type options (#150)</li>
<li>Added congestion control recommendations (#153)</li>
<li>Improved text on PUT/POST response payloads (#149)</li>
<li>Added an Accept option for content-negotiation (#163)</li>
<li>Added If-Match and If-None-Match options (#155)</li>
<li>Improved Token Option explanation (#147)</li>
<li>Clarified mandatory to implement security (#156)</li>
<li>Added first come first server policy for 2-byte Media type codes (#161)</li>
<li>Clarify matching rules for messages and tokens (#151)</li>
<li>Changed OPTIONS and TRACE to always return 501 in HTTP-CoAP mapping (#164)</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.2">Changed from ietf-05 to ietf-06: </p>

<ul>
<li>HTTP mapping section improved with the minimal protocol standard text for CoAP-HTTP and HTTP-CoAP forward proxying (#137).</li>
<li>Eradicated percent-encoding by including one Uri-Query Option per &amp;-delimited argument in a query.</li>
<li>Allowed RST message in reply to a NON message with unexpected token (#134).</li>
<li>Cache Invalidation only happens upon successful responses (#135).</li>
<li>50% jitter added to the initial retransmit timer (#142).</li>
<li>DTLS cipher suites aligned with ZigBee IP, DTLS clarified as default CoAP security mechanism (#138, #139)</li>
<li>Added a minimal reference to draft-kivinen-ipsecme-ikev2-minimal (#140).</li>
<li>Clarified the comparison of UTF-8s (#136).</li>
<li>Minimized the initial media type registry (#101).</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.3">Changed from ietf-04 to ietf-05: </p>

<ul>
<li>Renamed Immediate into Piggy-backed and Deferred into Separate -- should finally end the confusion on what this is about.</li>
<li>GET requests now return a 2.05 (Content) response instead of 2.00 (OK) response (#104).</li>
<li>Added text to allow 2.02 (Deleted) responses in reply to POST requests (#105).</li>
<li>Improved message deduplication rules (#106).</li>
<li>Section added on message size implementation considerations (#103).</li>
<li>Clarification made on human readable error payloads (#109).</li>
<li>Definition of CoAP methods improved (#108).</li>
<li>Max-Age removed from requests (#107).</li>
<li>Clarified uniqueness of tokens (#112).</li>
<li>Location-Query Option added (#113).</li>
<li>ETag length set to 1-8 bytes (#123).</li>
<li>Clarified relation between elective/critical and option numbers (#110).</li>
<li>Defined when to update Version header field (#111).</li>
<li>URI scheme registration improved (#102).</li>
<li>Added review guidelines for new CoAP codes and numbers.</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.4">Changes from ietf-03 to ietf-04: </p>

<ul>
<li>Major document reorganization (#51, #63, #71, #81).</li>
<li>Max-age length set to 0-4 bytes (#30).</li>
<li>Added variable unsigned integer definition (#31).</li>
<li>Clarification made on human readable error payloads (#50).</li>
<li>Definition of POST improved (#52).</li>
<li>Token length changed to 0-8 bytes (#53).</li>
<li>Section added on multiplexing CoAP, DTLS and STUN (#56).</li>
<li>Added cross-protocol attack considerations (#61).</li>
<li>Used new Immediate/Deferred response definitions (#73).</li>
<li>Improved request/response matching rules (#74).</li>
<li>Removed unnecessary media types and added recommendations for their use in M2M (#76).</li>
<li>Response codes changed to base 32 coding, new Y.XX naming (#77).</li>
<li>References updated as per AD review (#79).</li>
<li>IANA section completed (#80).</li>
<li>Proxy-Uri Option added to disambiguate between proxy and non-proxy requests (#82).</li>
<li>Added text on critical options in cached states (#83).</li>
<li>HTTP mapping sections improved (#88).</li>
<li>Added text on reverse proxies (#72).</li>
<li>Some security text on multicast added (#54).</li>
<li>Trust model text added to introduction (#58, #60).</li>
<li>AES-CCM vs. AES-CCB text added (#55).</li>
<li>Text added about device capabilities (#59).</li>
<li>DTLS section improvements (#87).</li>
<li>Caching semantics aligned with RFC2616 (#78).</li>
<li>Uri-Path Option split into multiple path segments.</li>
<li>MAX_RETRANSMIT changed to 4 to adjust for RESPONSE_TIME = 2.</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.5">Changes from ietf-02 to ietf-03: </p>

<ul>
<li>Token Option and related use in asynchronous requests added (#25).</li>
<li>CoAP specific error codes added (#26).</li>
<li>Erroring out on unknown critical options changed to a MUST (#27).</li>
<li>Uri-Query Option added.</li>
<li>Terminology and definitions of URIs improved. </li>
<li>Security section completed (#22).</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.6">Changes from ietf-01 to ietf-02: </p>

<ul>
<li>Sending an error on a critical option clarified (#18).</li>
<li>Clarification on behavior of PUT and idempotent operations (#19).</li>
<li>Use of Uri-Authority clarified along with server processing rules; Uri-Scheme Option removed (#20, #23).</li>
<li>Resource discovery section removed to a separate CoRE Link Format draft (#21).</li>
<li>Initial security section outline added.</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.7">Changes from ietf-00 to ietf-01: </p>

<ul>
<li>New cleaner transaction message model and header (#5).</li>
<li>Removed subscription while being designed (#1).</li>
<li>Section 2 re-written (#3).</li>
<li>Text added about use of short URIs (#4).</li>
<li>Improved header option scheme (#5, #14).</li>
<li>Date option removed whiled being designed (#6).</li>
<li>New text for CoAP default port (#7).</li>
<li>Completed proxying section (#8).</li>
<li>Completed resource discovery section (#9).</li>
<li>Completed HTTP mapping section (#10).</li>
<li>Several new examples added (#11).</li>
<li>URI split into 3 options (#12).</li>
<li>MIME type defined for link-format (#13, #16).</li>
<li>New text on maximum message size (#15).</li>
<li>Location Option added.</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.8">Changes from shelby-01 to ietf-00: </p>

<ul>
<li>Removed the TCP binding section, left open for the future.</li>
<li>Fixed a bug in the example.</li>
<li>Marked current Sub/Notify as (Experimental) while under WG discussion.</li>
<li>Fixed maximum datagram size to 1280 for both IPv4 and IPv6 (for CoAP-CoAP proxying to work).</li>
<li>Temporarily removed the Magic Byte header as TCP is no longer included as a binding.</li>
<li>Removed the Uri-code Option as different URI encoding schemes are being discussed.</li>
<li>Changed the rel= field to desc= for resource discovery.</li>
<li>Changed the maximum message size to 1024 bytes to allow for IP/UDP headers.</li>
<li>Made the URI slash optimization and method impotence MUSTs</li>
<li>Minor editing and bug fixing.</li>
</ul>

<p> </p>
<p id="rfc.section.Appendix D.p.9">Changes from shelby-00 to shelby-01: </p>

<ul>
<li>Unified the message header and added a notify message type.</li>
<li>Renamed methods with HTTP names and removed the NOTIFY method.</li>
<li>Added a number of options field to the header.</li>
<li>Combines the Option Type and Length into an 8-bit field.</li>
<li>Added the magic byte header.</li>
<li>Added new ETag Option.</li>
<li>Added new Date Option.</li>
<li>Added new Subscription Option.</li>
<li>Completed the HTTP Code - CoAP Code mapping table appendix.</li>
<li>Completed the Content-type Identifier appendix and tables.</li>
<li>Added more simplifications for URI support.</li>
<li>Initial subscription and discovery sections.</li>
<li>A Flag requirements simplified.</li>
</ul>

<p> </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Zach Shelby</span> 
	  <span class="n hidden">
		<span class="family-name">Shelby</span>
	  </span>
	</span>
	<span class="org vcardline">Sensinode</span>
	<span class="adr">
	  <span>Kidekuja 2</span>

	  <span class="vcardline">
		<span class="locality">Vuokatti</span>,  
		<span class="region"></span>
		<span class="code">88600</span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">Phone: +358407796297</span>

<span class="vcardline">EMail: <a href="mailto:zach@sensinode.com">zach@sensinode.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Klaus Hartke</span> 
	  <span class="n hidden">
		<span class="family-name">Hartke</span>
	  </span>
	</span>
	<span class="org vcardline">Universitaet Bremen TZI</span>
	<span class="adr">
	  <span>Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">Bremen</span>,  
		<span class="region"></span>
		<span class="code">D-28359</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63905</span>

<span class="vcardline">EMail: <a href="mailto:hartke@tzi.org">hartke@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carsten Bormann</span> 
	  <span class="n hidden">
		<span class="family-name">Bormann</span>
	  </span>
	</span>
	<span class="org vcardline">Universitaet Bremen TZI</span>
	<span class="adr">
	  <span>Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">Bremen</span>,  
		<span class="region"></span>
		<span class="code">D-28359</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63921</span>

<span class="vcardline">EMail: <a href="mailto:cabo@tzi.org">cabo@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Frank</span> 
	  <span class="n hidden">
		<span class="family-name">Frank</span>
	  </span>
	</span>
	<span class="org vcardline">SkyFoundry</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Richmond, VA</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:brian@skyfoundry.com">brian@skyfoundry.com</a></span>

  </address>
</div>

</body>
</html>