




MPLS & RSVP Working Groups                                Daniel Awduche
Internet Draft                                  UUNET Technologies, Inc.
Expiration Date: February 1999
                                                             Der-Hwa Gan
                                                  Juniper Networks, Inc.

                                                                 Tony Li
                                                  Juniper Networks, Inc.

                                                          George Swallow
                                                     Cisco Systems, Inc.

                                                        Vijay Srinivasan
                                                  Torrent Networks, Inc.

                                                             August 1998


               Extensions to RSVP for Traffic Engineering


                 draft-swallow-mpls-rsvp-trafeng-00.txt

Status of this Memo

   This document is an Internet-Draft.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   To view the entire list of current Internet-Drafts, please check the
   "1id-abstracts.txt" listing contained in the Internet-Drafts Shadow
   Directories on ftp.is.co.za (Africa), ftp.nordu.net (Northern
   Europe), ftp.nis.garr.it (Southern Europe), munnari.oz.au (Pacific
   Rim), ftp.ietf.org (US East Coast), or ftp.isi.edu (US West Coast).


Abstract

   This document describes the use of RSVP, including all the necessary
   extensions, to support traffic engineering with MPLS as specified in
   [6].




Swallow, editor                                                 [Page 1]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   We propose several additional objects that extend RSVP, allowing the
   establishment of explicitly routed label switched paths (LSPs), using
   RSVP as a signaling protocol.  The result is the instantiation of
   label-switched sessions which can be automatically routed  away from
   network failures, congestion, and bottlenecks.














































Swallow, editor                                                 [Page 2]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998




Contents

    1      Introduction  ...........................................   4
    2      Overview of operation  ..................................   5
    2.1    Service Classes  ........................................   6
    2.2    Reservation styles  .....................................   6
    2.2.1  Fixed Filter (FF) style  ................................   7
    2.2.2  Wildcard Filter (WF) style  .............................   7
    2.2.3  Shared Explicit (SE) style  .............................   8
    2.3    LSP Tunnels  ............................................   8
    2.4    Rerouting LSP Tunnels  ..................................   9
    3      RSVP Message Formats  ...................................  10
    3.1    Path message  ...........................................  10
    3.2    Resv message  ...........................................  11
    4      Objects  ................................................  11
    4.1    Label Object  ...........................................  11
    4.1.1  Handling Label Objects in Resv messages  ................  12
    4.1.2  Non-support of the Label Object  ........................  13
    4.2    Label Request Object  ...................................  13
    4.2.1  Handling of LABEL_REQUEST  ..............................  14
    4.2.2  Non-support of the Label Request Object  ................  14
    4.3    Explicit Route Object  ..................................  15
    4.3.1  Subobjects  .............................................  15
    4.3.2  Applicability  ..........................................  16
    4.3.3  Semantics of the Explicit Route Object  .................  16
    4.3.4  Strict and Loose subobjects  ............................  17
    4.3.5  Loops  ..................................................  18
    4.3.6  Subobject semantics  ....................................  18
    4.3.7  Processing of the Explicit Route Object  ................  20
    4.3.8  Non-support of the Explicit Route Object  ...............  21
    4.4    Record Route Object  ....................................  22
    4.4.1  Subobjects  .............................................  22
    4.4.2  Applicability  ..........................................  24
    4.4.3  Handling RRO  ...........................................  25
    4.4.4  Loop Detection  .........................................  26
    4.4.5  Non-support of RRO  .....................................  26
    4.5    Error subcodes for ERO and RRO  .........................  27
    4.6    Session, Sender Template, and Filter Spec Objects  ......  27
    4.6.1  Session Object  .........................................  27
    4.6.2  Sender Template Object  .................................  28
    4.6.3  Filter Specification Object  ............................  29
    4.6.4  Reroute procedure  ......................................  29
    4.7    Session Attribute Object  ...............................  30
    5      RSVP Aggregate Message  .................................  33
    5.1    Aggregate Header  .......................................  33
    5.2    Message Formats  ........................................  35



Swallow, editor                                                 [Page 3]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


    5.3    Sending RSVP Aggregate Messages  ........................  35
    5.4    Receiving RSVP Aggregate Messages  ......................  36
    5.5    Forwarding RSVP Aggregate Messages  .....................  37
    5.6    Aggregate-capable bit  ..................................  37
    6      Tear Confirm  ...........................................  37
    7      Security Considerations  ................................  39
    8      Acknowledgments  ........................................  39
    9      References  .............................................  39





1. Introduction

   For hosts and routers that support both RSVP [1] and Multi-Protocol
   Label Switching [2], it is possible to associate labels with RSVP
   flows [4].  The result is that a router can identify the appropriate
   reservation state for a packet based on its label value, thus greatly
   simplifying packet classification.  This design also improves network
   performance because the same label lookup identifies forwarding
   information of the packet.

   Using RSVP to establish label switched paths (LSPs) clearly enables
   the allocation of resources to an LSP. For example, you can allocate
   bandwidth to an LSP using standard RSVP reservations and Integrated
   Services service classes [7].  While this is useful, reservations are
   not required. An LSP can also be established to carry best-effort
   traffic without a resource reservation.

   It is possible to add explicit routing capability on top of label-
   switched RSVP flows [3] [5] by adding a simple EXPLICIT_ROUTE object
   to RSVP.  By using this object, the paths taken by label-switched
   RSVP flows can be predetermined, independent of conventional IP
   routing.  The hops in the path can be manually configured, or
   computed automatically based on the QoS requirements of the flow and
   the current network load.

   The purpose of this document is to organize all the objects from [3],
   [4], and [5] into a single document that fully describes all the
   procedures and packet formats so that interoperable implementations
   are possible.  A few new objects are also suggested for enhancing
   management and diagnostics of LSPs.  All objects described are
   optional, and this document describes what happens when an object is
   not supported by a node.

   Finally, an RSVP aggregate message is proposed to help alleviate one
   of the RSVP scaling issues: how to efficiently handle large number of



Swallow, editor                                                 [Page 4]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   RSVP messages that are periodically transmitted between neighbors.

   The document concentrates on unicast LSPs. Explicitly routed
   multicast LSPs are left for further study.



2. Overview of operation

   When an RSVP flow originates in or crosses an MPLS domain, the flow
   may be label switched.  To initiate label switching, the first MPLS
   node inserts a LABEL_REQUEST object into the Path message.  The
   LABEL_REQUEST object indicates that a label binding for this path is
   requested, and also provides an indication of the network layer
   protocol that is to be carried over this path. The reason for this is
   that the network layer protocol sent down an LSP cannot be assumed to
   be IPv4, and cannot be deduced from the L2 header, which simply
   identifies the higher layer protocol as being MPLS.

   If the sender node has prior knowledge of an alternative route that
   has better likelihood of meeting the flow's QoS requirement or that
   makes more efficient use of network resources, the node can decide to
   reroute some of its sessions.  To do this, the node adds an
   EXPLICIT_ROUTE object to the Path message.

   If, during a session, the sender node finds a better route, the
   session can be rerouted on the fly by simply changing the
   EXPLICIT_ROUTE object.  If there are problems with an EXPLICIT_ROUTE
   object, either because it causes a routing loop or some intermediate
   routers do not support it, the sender node is notified.

   If the RECORD_ROUTE object is added to Path messages, the sender node
   can receive information about the exact routing path and can prompt
   for notifications from the network if the routing path changes for
   any reason.

   Finally, a SESSION_ATTRIBUTE object can be added to Path messages for
   aiding in session identification and diagnostics.  Additional control
   information, such as preemption, priority, and fast-reroute, is also
   included in this object.

   When the EXPLICIT_ROUTE object (ERO) is present, the Path message is
   forwarded towards its destination along a path specified by the ERO.
   Each node along the path records the ERO in its path state block.
   Nodes may also modify the ERO before forwarding the Path message, in
   which case the modified ERO should be stored in the path state block.

   The LABEL_REQUEST object requests intermediate routers and receiving



Swallow, editor                                                 [Page 5]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   nodes to provide a label binding for the session.  If a node is
   incapable of providing a label binding it sends a PathErr message
   with an "unknown object class" error.  If the LABEL_REQUEST object is
   not supported end to end, the sender node will be notified by the
   first node which lacks the support.

   The destination node includes a LABEL object in its response Resv
   message.  The LABEL object is inserted in the filter spec list
   immediately following the filter spec to which it pertains.  When the
   LABEL object propagates upstream to the sender node, a label-switched
   path is already set up for use.

   The Resv message is sent back towards the sender. A node that
   receives a Resv message containing a label uses that label for
   outgoing traffic on this path.  It also allocates a new label and
   places that label in the corresponding LABEL object of the Resv
   message before sending it upstream. This is the label that this node
   will use for incoming traffic on this path.  This label now serves as
   shorthand for the Filter Spec.


2.1. Service Classes

   This document does not restrict the type of Integrated Service
   requested on a reservations.  However, an implementation should
   always be ready to accept the Controlled-Load service [7].

   An LSP may not need a bandwidth reservation or a QoS guarantee.  Such
   LSPs can be used to deliver best-effort traffic, even if RSVP is used
   for setting up LSPs.  When no resources need to be allocated to the
   LSP, the Sender_TSpec in the Path message can specify a token bucket
   rate of zero and a token bucket size of zero.  The corresponding
   FLOWSPEC (in the Resv message) should carry a zero rate and size as
   well.  LSPs with no bandwidth reservation are not subject to
   Admission Control and do not require traffic policing.



2.2. Reservation styles

   The receiver node can select from among a set of possible reservation
   styles for each session, and each RSVP session must have a particular
   style.  Senders have no influence on the choice of reservation style.
   The receiver can choose different reservation styles for different
   LSPs.  An RSVP session is identified by a unique (destination
   address, protocol, destination port) tuple.

   An RSVP session can create one or more LSPs, depending on the



Swallow, editor                                                 [Page 6]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   reservation style chosen.

   Some reservation styles, such as FF, dedicate a particular
   reservation to an individual sender node.  Other reservation styles,
   such as WF and SE, can share a reservation among several sender
   nodes.  The following sections discuss the different reservation
   styles and their advantages and disadvantages.


2.2.1. Fixed Filter (FF) style

   The Fixed Filter (FF) reservation style creates a distinct
   reservation for traffic from each sender that is not shared by other
   senders.  This style is common for applications in which traffic from
   each sender is likely to be concurrent and independent.  The total
   amount of reserved bandwidth on a link for sessions using FF is the
   sum of the reservations for the individual senders.

   Because each sender has its own reservation, a unique label and a
   separate label-switched-path is assigned to each sender.  This
   results in a point-to-point LSP between every sender/receiver pair.

   Because the network state overhead is proportional to the number of
   LSPs, having more LSPs means that more network resources are
   consumed.


2.2.2. Wildcard Filter (WF) style

   With the Wildcard Filter (WF) reservation style, a single shared
   reservation is used for all senders.  The total reservation on a link
   remains the same regardless of the number of senders.  This style is
   useful in applications in which not all senders send traffic at the
   same time.  A phone conference, for example, is an application where
   not all speakers talk at the same time.

   A single label-switched-path is created for all senders, because all
   senders to the session are covered by the reservation.  On links that
   senders share, a single label is allocated.  If there is only one
   sender, the LSP looks like normal point-to-point connection.  When
   multiple senders are present, a multipoint-to-point LSP (a reversed
   tree) is created.  This has the advantage of minimizing the number of
   LSPs (and the memory and CPU resources used for each LSP), allowing
   the network to scale better.

   Because of the merging rules, EXPLICIT_ROUTE objects cannot be used
   with WF reservations.  Hence, the use of the WF style should be
   discouraged in the presence of ERO.



Swallow, editor                                                 [Page 7]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


2.2.3. Shared Explicit (SE) style

   Unlike the WF style, where any sender is allowed to share the
   reservation, the Shared Explicit (SE) style allows a receiver to
   explicitly specify the senders to be included.  There is a single
   reservation on a link for all the senders listed.

   Only listed senders can join the reservation.

   Because each sender is explicitly listed in the Resv message, you can
   assign separate labels to each sender, therefore creating separate
   LSPs for each sender.  [4] describes the reason why separate LSPs are
   needed.

   Having separate LSPs for each sender also eliminates the
   incompatibility with the EXPLICIT_ROUTE object.  Path messages from
   different senders can carry their own ERO, and the paths taken by the
   senders can converge and diverge at any point.

   Unlike the FF style, all SE LSPs share the single reservation.
   Unlike the WF style, a separate LSP is created for each sender.


2.3. LSP Tunnels

   When LSPs are used to carry flows, it becomes possible to be more
   flexible in the definition of a flow.  The first node in an LSP can
   use any of a variety of means to determine which packets will be
   assigned a particular label.  Once that label is assigned, the label
   becomes the definition of the flow.  We refer to such an LSP as an
   LSP Tunnel due to the opaque nature of the flow.

   In support of this, a new SESSION object, LSP_TUNNEL_IPv4 is defined.
   The semantics of this object are that the flow is defined solely on
   the basis of packets arriving from the PHOP with the particular label
   value(s) assigned by this node to senders to the session.  In fact,
   the IPv4 appearing in the object name only denotes that the
   destination address is an IPv4 address.

   An application of particular interest is traffic engineering.  By
   establishing ER-LSPs a node at the edge of an MPLS domain can control
   the path which traffic from this node will take through that domain.
   These capabilities can be used to optimize the utilization of network
   resources and enhance traffic oriented performance characteristics.







Swallow, editor                                                 [Page 8]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


2.4. Rerouting LSP Tunnels

   One of the requirements for Traffic Engineering is the ability to
   have an LSP tunnel re-routed upon a failure of a resource along its
   current path.  A further requirement is the ability to have the LSP
   tunnel return to its original path when the failed resource is
   restored.

   It is also desirable not to disrupt traffic while rerouting is in
   progress.  The adaptive rerouting requirement calls for establishing
   a new LSP while keeping the old LSP intact.

   On links that old and new LSPs share, one wishes to (1) not release
   resources from the old LSP that one wants to use for the new LSP, and
   (2) not double-count reservations, because this might cause Admission
   Control to deny the new LSP.

   The combination of the LSP_TUNNEL_IPv4 SESSION object and the SE
   reservation style naturally achieves smooth transitions.  The
   LSP_TUNNEL_IPv4 SESSION object is used to narrow the scope of the
   RSVP session to the particular tunnel in question.  To uniquely
   identify a tunnel we use the combination of the destination IP
   address, a Tunnel ID, and the sender's IP address which is placed in
   the Extended Tunnel ID field.

   During the reroute operation, the source needs to be able to appear
   as two different sources to RSVP.  This is achieved by the use of a
   "LSP ID", which is carried in the SENDER_TEMPLATE and FILTER_SPEC
   objects.  Since the semantics of these objects is changed, a new C-
   Type is assigned.

   To effect a reroute, the source node picks a new LSP ID and forms a
   new SENDER_TEMPLATE.  It creates a new ERO to define the new path.
   The node sends a new Path Message using the original SESSION object
   and the new SENDER_TEMPLATE and ERO.  It continues to use the old LSP
   and refresh the old Path message.  On links which are not in common,
   the new Path message is treated as any new LSP tunnel setup.  On
   links held in common, the shared SESSION object and SE style allow
   the LSP to be established sharing the same resources.  Once the
   sender receives a Resv message for the new LSP, it is free to begin
   using it and to tear down the old LSP.


   Also new C-Types are assigned for the SESSION, SENDER_TEMPLATE, and
   FILTER_SPEC objects.

   Detailed descriptions of the new objects are given in later sections.
   All new objects are optional with respect to RSVP.  An implementation



Swallow, editor                                                 [Page 9]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998



3. RSVP Message Formats

   Five new objects are defined in this document:

      Object name          Applicable RSVP messages
      ---------------      ------------------------
      LABEL_REQUEST          Path
      LABEL                  Resv
      EXPLICIT_ROUTE         Path
      RECORD_ROUTE           Path, Resv
      SESSION_ATTRIBUTE      Path
   can choose to support some but not other objects.  However, the
   LABEL_REQUEST and LABEL objects are mandatory with respect to this
   document.

   The LABEL and RECORD_ROUTE objects, are sender specific.  They must
   immediately follow either the SENDER_TEMPLATE in Path messages, or
   the FILTER_SPEC in Resv messages.

   The placement of EXPLICIT_ROUTE, LABEL_REQUEST, and SESSION_ATTRIBUTE
   objects is simply a suggestion.  While it is recommended that an
   implementation follow this format, the ordering of these objects is
   not important, so an implementation must be prepared to accept
   objects in any order.


3.1. Path message

   The format of the Path message is as follows:

      <Path Message> ::=       <Common Header> [ <INTEGRITY> ]
                               <SESSION> <RSVP_HOP>
                               <TIME_VALUES>
                               [ <EXPLICIT_ROUTE> ]
                               <LABEL_REQUEST>
                               [ <SESSION_ATTRIBUTE> ]
                               [ <POLICY_DATA> ... ]
                               [ <sender descriptor> ]

      <sender descriptor> ::=  <SENDER_TEMPLATE> [ <SENDER_TSPEC> ]
                               [ <ADSPEC> ]
                               [ <RECORD_ROUTE> ]








Swallow, editor                                                [Page 10]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


3.2. Resv message

   The format of the Resv message is as follows:

      <Resv Message> ::=       <Common Header> [ <INTEGRITY> ]
                               <SESSION>  <RSVP_HOP>
                               <TIME_VALUES>
                               [ <RESV_CONFIRM> ]  [ <SCOPE> ]
                               [ <POLICY_DATA> ... ]
                               <STYLE> <flow descriptor list>

      <WF flow descriptor> ::= <FLOWSPEC> <LABEL>
                               [ <RECORD_ROUTE> ]

      <FF flow descriptor list> ::= <FLOWSPEC> <FILTER_SPEC> <LABEL>
                               [ <RECORD_ROUTE> ]
                               | <FF flow descriptor list> <FF flow descriptor>

      <FF flow descriptor> ::= [ <FLOWSPEC> ] <FILTER_SPEC> <LABEL>
                               [ <RECORD_ROUTE> ]

      <SE flow descriptor> ::= <FLOWSPEC> <SE filter spec list>

      <SE filter spec list> ::= <SE filter spec>
                               | <SE filter spec list> <SE filter spec>

      <SE filter spec> ::=     <FILTER_SPEC> <LABEL> [ <RECORD_ROUTE> ]

      Note:  LABEL and RECORD_ROUTE (if present), are bound to the
             preceding FILTER_SPEC.  No more than one LABEL and/or
             RECORD_ROUTE may follow each FILTER_SPEC.


4. Objects

4.1. Label Object

   Labels may be carried in Resv messages. When a label is to be
   associated with a single sender, it must immediately follow the
   FILTER_SPEC for that sender in the Resv message.

   The LABEL object was first documented in [4].  The LABEL object has
   the following format:


   The contents of a LABEL object are a stack of labels, where each
   label is encoded right aligned in 4 octets. The top of the stack is
   in the right 4 octets of the object contents.  A LABEL object that



Swallow, editor                                                [Page 11]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


     LABEL class = 16, C_Type = 1

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                      (Object contents)                       //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       (top label)                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   contains no labels is illegal.

   Each label is an unsigned integer in the range 0 through 1048575.

   The decision of whether to create a label stack with more than one
   label, when to push a new label, and when to pop the label stack are
   to be specified in a separate document.  For implementations that do
   not support a label stack, only the top label is examined.  The rest
   of the label stack should be passed through unchanged.  Such
   implementations are required to generate a label stack of depth 1
   when initiating the first LABEL.


4.1.1. Handling Label Objects in Resv messages

   For unicast sessions, only Resv messages contain the LABEL object.
   If a router does not wish to support MPLS for the session, the router
   can ignore the received LABEL objects and continue processing the
   rest of Resv message.

   The router uses the top label carried in the LABEL object as the
   outgoing label associated with the session (if WF) or sender (if FF
   or SE).  The router allocates a new label and binds it to the
   incoming interface of this session/sender.  This is the same
   interface that the router uses to forward Resv messages to the
   previous hops.

   To construct a new LABEL object, the router replaces the top label
   (from the received Resv message) with the locally allocated new
   label.  The router then sends the new LABEL object as part of the
   Resv message to the previous hop.  The LABEL object should be kept in
   the Reservation State Block.  It is then used in the next Resv
   refresh event for formatting the Resv message.

   A router can decide to send a Resv message before its refresh timers



Swallow, editor                                                [Page 12]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   expire if the contents of the LABEL object have changed.  A received
   Resv message without a LABEL object indicates that the next-hop
   router does not wish to support MPLS for this session/sender.  A
   label can be withdrawn without removing the reservation by sending a
   Resv with no LABEL object.  The receiving router should stop sending
   label switched packets toward the next-hop router.  The RSVP session
   itself is not affected.

   If, however, the session is of type LSP_TUNNEL_IPv4, then the label
   withdrawal procedure must not be used and a ResvTear sent instead.


4.1.2. Non-support of the Label Object

   An RSVP router that does not recognize the LABEL object sends a
   ResvErr with the error code "Unknown object class" toward the
   receiver.  This causes the reservation to fail.  The receiver should
   notify management that a LSP cannot be established, and possibly take
   action to continue the reservation without the LABEL object.

   RSVP is designed to cope gracefully with non-RSVP routers anywhere
   between senders and receivers. However, non-RSVP routers cannot
   receive label-switched packets conveyed in PATH or RESV messages.
   This means that if a router has a neighbor who is not RSVP capable,
   the router must not advertise the LABEL object when sending messages
   that pass through the non-RSVP router.  [1] describes how routers can
   determine the presence of non-RSVP routers.



4.2. Label Request Object

   The LABEL_REQUEST object was first documented in [3].  A
   LABEL_REQUEST object has the following format:

        class = 19, C_Type = 1  (need to get an official class num from
                                 the IANA)

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved            |             L3PID             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The L3PID is an identifier of the layer 3 protocol using this path.
   Standard Ethertype values are used.



Swallow, editor                                                [Page 13]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


4.2.1. Handling of LABEL_REQUEST

   The sender creates a Path message with a LABEL_REQUEST object.  The
   LABEL_REQUEST object indicates that a label binding for this path is
   requested and provides an indication of the network layer protocol
   that is to be carried over this path. This permits non-IP network
   layer protocols to be sent down an LSP.  The information can also be
   useful in assigning the actual label on a link, because some reserved
   labels are protocol specific. See [8].

   The LABEL_REQUEST should be stored in the Path State Block, so that
   refreshes of the Path messages will also contain the LABEL_REQUEST
   object.  When the Path message reaches its receiver, the presence of
   the LABEL_REQUEST object triggers the receiver to allocate a label
   and to place the label in the LABEL object for the corresponding Resv
   message.  A receiver that accepts a LABEL_REQUEST object, must
   include a LABEL object in Resv messages.

   A node that accepts a LABEL_REQUEST object must be ready to accept
   and correctly process a LABEL object in the corresponding Resv
   messages.

   A node that recognizes a LABEL_REQUEST object, but that is unable to
   support it (possibly because of a failure to allocate labels), should
   send a PathErr with the error code "Routing problem" and the subcode
   "MPLS label allocation failure."  If a node cannot support the
   protocol L3PID, it should send a PathErr with the error code "Routing
   problem" and the subcode "Unsupported L3PID."  This causes the RSVP
   session to fail.


4.2.2. Non-support of the Label Request Object

   An RSVP router that does not recognize the LABEL_REQUEST object sends
   a PathErr with the error code "Unknown object class" toward the
   sender.  This causes the path setup to fail.  The sender should
   notify management that a LSP cannot be established and possibly take
   action to continue the reservation without the LABEL_REQUEST.

   RSVP is designed to cope gracefully with non-RSVP routers anywhere
   between the sender and the receiver. However, non-RSVP routers cannot
   receive label-switched packets. This means that if a router has a
   neighbor that is not RSVP capable, the router must not advertise
   LABEL_REQUEST objects when sending messages that pass through the
   non-RSVP routers.  The router should send a PathErr back to the
   sender, with the error code "Routing problem" and the subcode "MPLS
   being negotiated, but a non-RSVP capable router stands in the path."
   [1] describes how routers can determine the presence of non-RSVP



Swallow, editor                                                [Page 14]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   routers.


4.3. Explicit Route Object

   As stated earlier, explicit routes are to be specified through a new
   EXPLICIT_ROUTE object in RSVP. RSVP Path messages carry this object.
   The EXPLICIT_ROUTE object has the following format:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                      (Object contents)                       //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Class-Num

         The Class-Num for an EXPLICIT_ROUTE object is 193 (need to get
         an official one from the IANA with the high order two bits set
         to 11)

      C-Type

         The C-Type for an EXPLICIT_ROUTE object is 1 (need to get an
         official one from the IANA)

   If a Path message contains multiple EXPLICIT_ROUTE objects, only the
   first object is meaningful.  Subsequent EXPLICIT_ROUTE objects may be
   ignored and should not be propagated.



4.3.1. Subobjects

   The contents of an EXPLICIT_ROUTE object are a series of variable-
   length data items called subobjects.  Each subobject has the form:



       0                   1
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-------------//----------------+
      |L|    Type     |     Length    | (Subobject contents)          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-------------//----------------+



Swallow, editor                                                [Page 15]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


      L

         The L bit is an attribute of the subobject.  The L bit is set
         if the subobject represents a loose hop in the explicit route.
         If the bit is not set, the subobject represents a strict hop in
         the explicit route.

      Type

         The Type indicates the type of contents of the subobject.
         Currently defined values are:

         0 Reserved
         1 IPv4 prefix
         2 IPv6 prefix
         32 Autonomous system number
         64 MPLS label switched path termination

      Length

         The Length contains the total length of the subobject in bytes,
         including the L, Type and Length fields.  The Length must
         always be a multiple of 4, and at least 4.


4.3.2. Applicability

   The EXPLICIT_ROUTE object is intended to be used only for unicast
   situations.  Applications of explicit routing to multicast are a
   topic for further research.

   The EXPLICIT_ROUTE object is to be used only when all routers along
   the explicit route support RSVP and the EXPLICIT_ROUTE object.  The
   mechanisms for determining, a priori, that such support is present
   are beyond the scope of this document.


4.3.3. Semantics of the Explicit Route Object

   An explicit route is a particular path in the network topology.
   Typically, the explicit route is computed by a node, with the intent
   of directing traffic down that path.

   An explicit route is described as a list of groups of nodes along the
   explicit route.  Certain operations to be performed along the path
   can also be encoded in the EXPLICIT_ROUTE object.

   In addition to the ability to identify specific nodes along the path,



Swallow, editor                                                [Page 16]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   an explicit route can identify a group of nodes that must be
   traversed along the path.  This capability allows the routing system
   a significant amount of local flexibility in fulfilling a request for
   an explicit route.  In turn, this allows the generator of the
   explicit route to have imperfect information about the details of the
   path.

   The explicit route is encoded as a series of subobjects contained in
   an EXPLICIT_ROUTE object.  Each subobject may identify a group of
   nodes in the explicit route or may be an operation to be performed
   along the path.  An explicit route is then a path including all of
   the identified groups of nodes, with the specified operations
   occurring along the path.

   To simplify the discussion, we call each group of nodes an abstract
   node.  Thus, we can also say that an explicit route is a path
   including all of the abstract nodes, with the specified operations
   occurring along that path.

   As an example, consider an explicit route that consists solely of
   autonomous system number subobjects.  Each subobject corresponds to
   an autonomous system in the network topology.  Each autonomous system
   is an abstract node.  In this case, the explicit route is a path
   including each of the specified autonomous systems.  There may be
   multiple hops within each autonomous system.


4.3.4. Strict and Loose subobjects

   The L bit in the subobject is a one-bit attribute.  If the L bit is
   set, then the value of the attribute is `loose.'  Otherwise, the
   value of the attribute is `strict.'  For brevity, we say that if the
   value of the subobject attribute is `loose' then it is a `loose
   subobject.' Otherwise, it's a `strict subobject.'  Further, we say
   that the abstract node of a strict or loose subobject is a strict or
   a loose node, respectively.  Loose and strict nodes are always
   interpreted relative to their prior abstract nodes.

   The path between a strict node and its prior node MUST include only
   network nodes from the strict node and its prior abstract node.

   The path between a loose node and its prior node MAY include other
   network nodes that are not part of the strict node or its prior
   abstract node.

   The L bit has no meaning in operation subobjects.





Swallow, editor                                                [Page 17]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


4.3.5. Loops

   While the EXPLICIT_ROUTE object is of finite length, the existence of
   loose nodes implies that it is possible to construct forwarding loops
   during transients in the underlying routing protocol.  This can be
   detected by the originator of the explicit route through the use of
   another opaque route object called the RECORD_ROUTE object.  The
   RECORD_ROUTE object is used to collect detailed path information and
   is useful for loop detection as well as diagnostic purposes.


4.3.6. Subobject semantics

4.3.6.1. Subobject 1:  The IPv4 prefix

   The contents of an IPv4 prefix subobject are a 4-octet IPv4 address,
   a 1-octet prefix length, and a 1-octet pad.  The abstract node
   represented by this subobject is the set of nodes that have an IP
   address which lies within this prefix.  Note that a prefix length of
   32 indicates a single IPv4 node.

   The length of the IPv4 prefix subobject is 8 octets.  The contents of
   the 1 octet of padding must be zero on transmission and must not be
   checked on receipt.


4.3.6.2. Subobject 2:  The IPv6 address

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Type     |     Length    | IPV6 address (16 bytes)       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)                                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)                                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)                                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)      |   Mask        |  Padding      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


     Type

       0x82  IPv6 address

     Length



Swallow, editor                                                [Page 18]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


       The Length contains the total length of the subobject in
       bytes, including the Type and Length fields.  The Length
       is always 20.

     IPv6 address

       A 128-bit unicast host address.

     Mask

       128

     Padding

       Zero on transmission.  Ignored on receipt.



4.3.6.3. Subobject 32:  The autonomous system number

   The contents of an autonomous system (AS) number subobject are a 2-
   octet autonomous system number.  The abstract node represented by
   this subobject is the set of nodes belonging to the autonomous
   system.

   The length of the AS number subobject is 4 octets.


4.3.6.4. Subobject 64:  MPLS label switched path termination

   The contents of an MPLS label switched path termination subobject are
   2 octets of padding.  The subobject is an operation subobject.  This
   object is only meaningful if there is a LABEL_REQUEST object in the
   Path message.

   If a LABEL_REQUEST object is present in the Path message, this Path
   message is being used to establish a Label Switched Path.  In this
   case, this subobject indicates that the prior abstract node should
   remove one level of label from all packets following this Label
   Switched Path.

   The length of the MPLS label termination subobject is 4 octets.









Swallow, editor                                                [Page 19]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


4.3.7. Processing of the Explicit Route Object

4.3.7.1. Selection of the next hop

   A Path message containing an EXPLICIT_ROUTE object must determine the
   next hop for this path.  Selection of this next hop may involve a
   selection from a set of possible alternatives.  The mechanism for
   making a selection from this set is implementation dependent and is
   outside of the scope of this specification.  Selection of particular
   paths is also outside of the scope of this specification, but it is
   assumed that each node will make a best effort attempt to determine a
   loop-free path.  Note that such best efforts may be overridden by
   local policy.

   To determine the next hop for the path, a node performs the following
   steps:

   1) The node receiving the RSVP message must first evaluate the first
   subobject.  If the node is not part of the abstract node described by
   the first subobject, it has received the message in error and should
   return a "Bad initial subobject" error.  If the first subobject is an
   operation subobject, the message is in error and the system should
   return a "Bad EXPLICIT_ROUTE object" error.  If there is no first
   subobject, the message is also in error and the system should return
   a "Bad EXPLICIT_ROUTE object" error.

   2) If there is no second subobject, this indicates the end of the
   explicit route.  The EXPLICIT_ROUTE object should be removed from the
   Path message.  This node may or may not be the end of the path.
   Processing continues with section 4.3.2, where a new EXPLICIT_ROUTE
   object may be added to the Path message.

   3) Next, the node evaluates the second subobject.  If the subobject
   is an operation subobject, the node records the subobject, deletes it
   from the EXPLICIT_ROUTE object and continues processing with step 2,
   above.  Note that this changes the third subobject into the second
   subobject in subsequent processing.  The precise operations to be
   performed by this node must be defined by the operation subobject.

   4) If the node is also a part of the abstract node described by the
   second subobject, then the node deletes the first subobject and
   continues processing with step 2, above.  Note that this makes the
   second subobject into the first subobject of the next iteration.

   5) The node determines whether it is topologically adjacent to the
   abstract node described by the second subobject.  If so, the node
   selects a particular next hop which is a member of the abstract node.
   The node then deletes the first subobject and continues processing



Swallow, editor                                                [Page 20]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   with section 4.3.2.

   6) Otherwise, the node selects a next hop within the abstract node of
   the first subobject that is along the path to the abstract node of
   the second subobject.  If no such path exists then there are two
   cases:

   6a) If the second subobject is a strict subobject, there is an error
   and the node should return a "Bad strict node" error.

   6b) Otherwise, if the second subobject is a loose subobject, the node
   selects any next hop that is along the path to the next abstract
   node.  If no path exists, there is an error, and the node should
   return a "Bad loose node" error.

   7) Finally, the node replaces the first subobject with any subobject
   that denotes an abstract node containing the next hop.  This is
   necessary so that when the explicit route is received by the next
   hop, it will be accepted.


4.3.7.2. Adding subobjects to the Explicit Route Object

   After selecting a next hop, the node may alter the explicit route in
   the following ways.

   If, as part of executing the algorithm in section 4.3.1, the
   EXPLICIT_ROUTE object is removed, the node may add a new
   EXPLICIT_ROUTE object.

   Otherwise, if the node is a member of the abstract node for the first
   subobject, a series of subobjects may be inserted before the first
   subobject or may replace the first subobject.  Each subobject in this
   series must denote an abstract node that is a subset of the current
   abstract node.

   Alternately, if the first subobject is a loose subobject, an
   arbitrary series of subobjects may be inserted prior to the first
   subobject.


4.3.8. Non-support of the Explicit Route Object

   An RSVP router that does not recognize the EXPLICIT_ROUTE object
   sends a PathErr with the error code "Unknown object class" toward the
   sender.  This causes the path setup to fail.  The sender should
   notify management that a LSP cannot be established and possibly take
   action to continue the reservation without the EXPLICIT_ROUTE or via



Swallow, editor                                                [Page 21]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   a different explicit route.


4.4. Record Route Object

   The format of the RECORD_ROUTE object (RRO) is described below.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                       (Subobjects)                           //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Class-Num

         The Class-Num for a RECORD_ROUTE object is 194 (need to get an
         official one from the IANA with the high order two bits set to
         11)

      C-Type

         The C-Type for a RECORD_ROUTE object is 1 (need to get an
         official one from the IANA)


         The RRO can show up in both RSVP Path and Resv messages.  The
         presence of the RRO in Path messages is semantically unrelated
         to the presence of RRO in Resv message. The presence of RRO in
         one message type does not necessarily require RRO in other
         message types.

         If a message contains multiple RROs, only the first RRO is
         meaningful. Subsequent RROs can be ignored and should not be
         propagated.


4.4.1. Subobjects

   The contents of a RECORD_ROUTE object are a series of variable-length
   data items called subobjects.  Each subobject has its own Length
   field, the Length contains the total length of the subobject in
   bytes, including the Type and Length fields.  The length must always
   be a multiple of 4, and at least 4.




Swallow, editor                                                [Page 22]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   Subobjects are organized as a last-in-first-out stack.  The first
   subobject relative to the beginning of RRO is considered the top.
   The last subobject is considered bottom.  When a new subobject is
   added, it is always added to the top.

   An empty RRO with no subobjects is considered illegal.

   Two kinds of subobjects are currently defined.


4.4.1.1. Subobject 1: The IPv4 address

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Type     |     Length    | IPV4 address (4 bytes)        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV4 address (continued)      |     Mask      |    Padding    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Type

          0x81  IPv4 address

      IPv4 address

          A 32-bit unicast, host address.  Any network-reachable
          interface address is allowed here.  Illegal addresses,
          such as loopback addresses, should not be used.

      Length

          The Length contains the total length of the subobject in
          bytes, including the Type and Length fields.  The Length
          is always 8.

      Mask

          32

      Padding

          Zero on transmission.  Ignored on receipt.








Swallow, editor                                                [Page 23]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


4.4.1.2. Subobject 2: The IPv6 address

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Type     |     Length    | IPV6 address (16 bytes)       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)                                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)                                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)                                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | IPV6 address (continued)      |   Mask        |  Padding      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Type

         0x82  IPv6 address

      Length

         The Length contains the total length of the subobject in
         bytes, including the Type and Length fields.  The Length
         is always 20.

      IPv6 address

         A 128-bit unicast host address.

      Mask

         128

      Padding

         Zero on transmission.  Ignored on receipt.


4.4.2. Applicability

   In Path messages, the RRO can be used for both unicast and multicast
   RSVP sessions.  In Resv messages, only the procedure for use in
   unicast sessions is defined here.

   There are three possible uses of RRO in RSVP.  First, it can function
   as a loop detection mechanism to discover L3 routing loops. The exact
   procedure for doing so is described in later sections of this



Swallow, editor                                                [Page 24]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   document.

   Second, RRO collects up-to-date detailed path information hop-by-hop
   about RSVP sessions, providing valuable information to the sender or
   receiver.  Any path change (due to network topology changes) is
   quickly reported.

   Third, RRO syntax is designed so that, with minor changes, the whole
   object can be used as input to the EXPLICIT_ROUTE object.  This is
   useful if the sender receives RRO from the receiver in a Resv
   message, applies it to EXPLICIT_ROUTE object in the next Path message
   in order to "pin down session path".


4.4.3. Handling RRO

   Typically, a node initiates an RSVP session by adding the RRO to the
   Path message.  The initial RRO contains only one subobject - the
   sender's IP addresses.

   When a Path message containing a RRO is received by an intermediate
   router, the router stores a copy of it in the Path State Block.  The
   RRO is then used in the next Path refresh event for formating Path
   messages.  When a new Path message is to be sent, the router adds a
   new subobject to the RRO and appends the resulting RRO to the Path
   message before transmission.

   The newly added subobject must be this router's IP address.  The
   address to be added should be the interface address of the outgoing
   Path messages.  If there are multiple addresses to choose from, the
   decision is local matter.  However, it is recommended that the same
   address be chosen consistently.  If the newly added subobject causes
   the RRO to be too big to fit in a Path message, the Path message
   shall be dropped and a PathErr message should be sent back to the
   sender.

   An RSVP router can decide to send Path messages before its refresh
   time if the RRO in the next Path message is different from the
   previous one.  This can happen if the contents of the RRO received
   from the previous hop router changes or if this RRO is newly added to
   (or deleted from) the Path message.

   A received Path message without an RRO indicates that the sender node
   no longer needs route recording.  Subsequent Path messages shall not
   contain an RRO.

   Likewise, RSVP session receiver nodes initiate the RRO process by
   adding an RRO to Resv messages.  The processing mirrors that of the



Swallow, editor                                                [Page 25]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   Path messages.  The only difference is that the RRO in a Resv message
   records the path information in the reverse direction.


4.4.4. Loop Detection

   As part of processing an incoming RRO, the intermediate router looks
   into all subobjects contained within the RRO.  If the router
   determines that it is already in the list, a forwarding loop exists.

   An RSVP session is loop-free if receiver nodes receive Path messages
   with no routing loops detected in the contained RRO or sender nodes
   receive Resv messages with no looping detected.

   There are two broad classifications of forwarding loops.  The first
   class is the transient loop, that occurs as a normal part of
   operations as L3 routing tries to converge on a consistent forwarding
   path for all destinations.  The second class of forwarding loop is
   the permanent loop, that normally results from network mis-
   configuration.

   The action performed on receipt depends on the message type in which
   the RRO is received.

   For Path messages containing a forwarding loop, the router builds and
   send a "Routing problem" PathErr message, with the subcode "loop
   detected," and drops the Path message.  Until the loop is eliminated,
   this session is not suitable for forwarding user data packets.
   Eliminating the loop is beyond the scope of this document.

   For Resv messages containing a forwarding loop, the router simply
   drops the message.  Resv messages should not loop if Path messages do
   not loop.


4.4.5. Non-support of RRO

   An RSVP router that does not recognize RRO forwards it unchanged.
   This has no impact on the reservation.  The presence of non-RSVP
   routers anywhere between senders and receivers has no impact on the
   object either.  The worst result is that RRO does not reflect the
   full path information.









Swallow, editor                                                [Page 26]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


4.5. Error subcodes for ERO and RRO

   In the processing described above, certain errors must be reported as
   part of a "Routing Problem" PathErr message. The value of the
   "Routing Problem" error code is 24 (TBD).

   The following defines the subcodes for the routing problem PathErr
   message:

         Value Error:

         1     Bad EXPLICIT_ROUTE object

         2     Bad strict node

         3     Bad loose node

         4     Bad initial subobject

         5     No route available toward destination

         6     RRO syntax error detected

         7     RRO indicated routing loops

         8     MPLS being negotiated, but a non-RSVP-capable router
               stands in the path

         9     MPLS label allocation failure

         10    Unsupported L3PID


4.6. Session, Sender Template, and Filter Spec Objects

   New C-Types are defined for the SESSION, SENDER_TEMPLATE and
   FILTER_SPEC objects.  The LSP_TUNNEL_IPv4 objects have the following
   format:


4.6.1. Session Object


      IPv4 tunnel end point address

         IPv4 address of the destination node for the tunnel.

      Tunnel ID



Swallow, editor                                                [Page 27]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


      Class = SESSION, C-Type = LSP_TUNNEL_IPv4 (7)

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                   IPv4 tunnel end point address               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Must be zero                 |      Tunnel ID                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Extended Tunnel ID                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         A 16-bit identifier used in the SESSION that remains constant
         over the life of the tunnel.

      Extended Tunnel ID

         A 32-bit identifier used in the SESSION that remains constant
         over the life of the tunnel.  Normally set to all zeros.
         Source nodes which wish to narrow the scope of a SESSION to the
         source destination pair may place their IPv4 address here as a
         globally unique identifier.


4.6.2. Sender Template Object

      Class = SENDER_TEMPLATE, C-Type = LSP_TUNNEL_IPv4 (7)

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                   IPv4 tunnel sender address                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Must be zero                 |            LSP ID             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      IPv4 tunnel sender address

         IPv4 address for a sender node

      LSP ID

         a 16-bit identifier used in the SENDER_TEMPLATE and the
         FILTER_SPEC that can be changed to allow a sender to share
         resources with itself.



Swallow, editor                                                [Page 28]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


4.6.3. Filter Specification Object

      Class = FILTER SPECIFICATION, C-Type = LSP_TUNNEL_IPv4 (7)

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                   IPv4 tunnel sender address                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Must be zero                 |            LSP ID             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      IPv4 tunnel sender address

         IPv4 address for a sender node

      LSP ID

         a 16-bit identifier used in the SENDER_TEMPLATE and the
         FILTER_SPEC that can be changed to allow a sender to share
         resources with itself.



4.6.4. Reroute procedure

   A tunnel which is capable of maintaining resource (without double
   counting) while it is being rerouted or attempting to increase its
   bandwidth is setup as follows.  In the initial Path message, the
   source node forms a SESSION object, picking a Tunnel_ID and placing
   its IPv4 address in the Extended_Tunnel_ID.  It forms a
   SENDER_TEMPLATE picking a Tunnel_Path_ID.  Tunnel setup continues
   with normal processing.

   The destination node sends a Resv message with the STYLE to Shared
   Explicit.

   [Note I think we should add a flag to the SESSION_ATTRIBUTE for the
   source to indicate that it wishes the SE style.]

   When a source node with an established path that wants to change the
   path it forms a new Path message as follows.  The existing SESSION
   object is used, in particular the Tunnel_ID and Extended_Tunnel_ID
   are unchanged.  It picks a new Tunnel_Path_ID to form a new
   SENDER_TEMPLATE.  It creates an EXPLICIT_ROUTE object with the new
   route.  The new Path message is sent.  The source node refreshes both



Swallow, editor                                                [Page 29]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   the old and new path messages

   The destination node responds with a Resv message with an SE flow
   descriptor formated as:

           <FLOW_SPEC><old_FILTER_SPEC><old_LABEL_OBJECT><new_FILTER_SPEC>
           <new_LABEL_OBJECT>

   (Note that if the PHOPs are different, then two messages are sent
   each with the appropriate FILTER_SPEC and LABEL_OBJECT.)

   When the Source node receives the Resv Message(s) it may begin using
   the new route.  It should send a PathTear message for the old route.


4.7. Session Attribute Object

   The format of the SESSION_ATTRIBUTE object is described below.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Length (bytes)        |   Class-Num   |    C-Type     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Setup Prio  | Reserv. Prio  |     Flags     |  Name Length  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //          Session Name      (NULL padded display string)      //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Class-Num

         The Class-Num indicates that the object is 207. (TBD)

      C-Type

         The C-Type is 7.

      Flags

         0x01 = Fast-reroute
           This flag permits transit routers to precompute and
           pre-establish detour paths for this session.  Upon
           fault detection on a immediate downstream link or node,
           transit routers reroute traffic onto the
           detour path for fast fail-over.




Swallow, editor                                                [Page 30]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


         0x02 = Merging permitted
           This flag permits transit routers to merge this session
           with other RSVP sessions for the purpose of reducing
           resource overhead on downstream transit routers, thereby
           providing better network scalability.

      Setup Priority

         the range of 0 to 7.  0 is the highest priority.  The Setup Priority
         is used in deciding whether this session should displace another
         session.

      Reservation Priority

         in the range of 0 to 7.  0 is the highest priority.  Reservation
         Priority is used in deciding whether this session should be displaced
         by another session.

      Name Length

         The length of the display string before padding, in bytes.

      Session Name

         A null padded string of characters.

   The support of setup and reservation priorities is optional.  A node
   can recognize this information but be unable to perform the requested
   operation.  The node should pass the information downstream unchanged.

   Preemption is implemented by two priorities.  The Setup Priority is
   the priority for taking resources.  The Reservation Priority is the
   priority for holding a resource.  The Setup Priority should never be
   higher than the Reservation Priority.  The Reservation Priority is the
   priority at which resources assigned to this request will be reserved.

   When a new reservation is considered for admission, the bandwidth
   requested is compared with the bandwidth available at the priority
   specified in the Setup Priority.  The bandwidth available at a
   particular priority is the unused bandwidth plus the bandwidth
   reserved at all priorities lower than the Setup Priority.

   If the bandwidth is not available a PathErr message is
   returned with a Error Code of 01, Admission Control failure, and an
   Error Value of 0x0002.  The first 0 means globally defined subcode and
   not informational.  The 002 means "requested bandwidth unavailable".

   If the requested bandwidth is less than the unused bandwidth,



Swallow, editor                                                [Page 31]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   processing is complete.  If the requested bandwidth is available, but
   is in use by lower priority sessions, then lower priority sessions
   (beginning with the lowest priority) are pre-empted to free the
   necessary bandwidth.

   When pre-emption is supported, each pre-empted reservation triggers a
   TC_Preempt() upcall to local clients, passing a subcode indicating the
   reason.  A ResvErr and/or PathErr with the code "Policy Control failure"
   should be sent toward the downstream receivers and upstream senders.

   [Editor: we need to define a subcode; if we stay with
   SESSION_ATTRIBUTE (not POLICY) we should also define an error code]

   The support of fast-reroute is optional.  A node can recognize
   this information but be unable to perform the requested operation.  The
   node should pass the information downstream unchanged.

   The support of merging is optional.  A node can recognize this
   information but be unable to perform the requested operation.  The
   node should pass the information downstream unchanged.

   If a Path message contains multiple SESSION_ATTRIBUTE objects, only
   the first SESSION_ATTRIBUTE object is meaningful.  Subsequent
   SESSION_ATTRIBUTE objects can be ignored and not forwarded.

   The contents of the Session Name field are a string, typically
   displayable characters.  The Length must always be a multiple of 4 and
   must be at least 8.  For an object length that is not multiple of 4,
   the object is padded with trailing NULL characters.  The Name Length
   field contains the actual string length.

   All RSVP routers, whether they support this object or not, shall forward
   the object unmodified.  The presence of non-RSVP routers anywhere
   between senders and receivers has no impact on the object.

   Note that the granting of one reservation may result in the preemption
   of other reservations.  We will also need an error code to indicate
   that a reservation has been preempted.  I suggest we do that with both
   a PathTear and a ResvTear with a Error Code of 02, Policy Control
   failure, and a Error Value of 0x8002, where the subcode 002 means
   "Reservation Preempted".










Swallow, editor                                                [Page 32]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


5. RSVP Aggregate Message

   The resource requirement (processing and memory) for running RSVP on
   a router increases proportionally with the number of sessions.
   Supporting a large number of sessions on may present scaling
   problems.

   This section describes an approach to help alleviate one of the
   scaling issues.  Path and Resv messages must be periodically
   refreshed. The approach here simply reduces the volume of messages
   which must be periodically sent and received.

   Another way of addressing the refresh volume problem is to increase
   the refresh timer R.  Increasing the value of R provides linear
   improvement on transmission overhead, but at the cost of increasing
   refresh timeout.  With the proposed aggregate message (see below),
   network administrators can reduce R for faster detection of
   connectivity problems while enjoying an order of magnitude less
   overhead.

   If topology failures occur, every node adjacent to the failure might
   wish to notify all affected sender and receiver nodes.  These
   notification messages are either tear or error messages.  Depending
   on how many sessions are affected and how fast every node is willing
   to react, these messages represent a flood that ripples out from the
   original failure point.  Aggregate messages provide the mechanism to
   reduce message flooding and network overload.  They also enhance the
   efficiency and reliability in delivering of RSVP tear or error
   messages.

   An RSVP aggregate message consists of an aggregate header followed by
   a body consisting of a variable number of standard RSVP messages.
   The following subsections define the formats of the aggregate header
   and the rules for including standard RSVP messages as part of
   message.


5.1. Aggregate Header

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |   Msg type    |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The format of the aggregate header is identical to the format of the



Swallow, editor                                                [Page 33]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   RSVP common header [1].  The fields in the header are as follows:

      Vers: 4 bits

         Protocol version number.  This is version 1.

      Flags: 4 bits

         0x01: Aggregate capable

           If set, indicates to RSVP neighbors that this node is willing
           and capable of receiving aggregate messages.  This bit is
           meaningful only between adjacent RSVP neighbors.

         0x02-0x08: Reserved

      Msg type: 8 bits

         12 = Aggregate

      RSVP checksum: 16 bits

         The one's complement of the one's complement sum of the entire
         message, with the checksum field replaced by zero for the
         purpose of computing the checksum.  An all-zero value means
         that no checksum was transmitted.  Because individual
         submessages carry their own checksum as well as INTEGRITY
         object for authentication, this field is recommended to be left
         as zero.

      Send_TTL: 8 bits

         The IP TTL value with which the message was sent.  This is used
         by RSVP to detect a non-RSVP hop by comparing the IP TTL that
         an Aggregate message sent to the TTL in the received message.

      RSVP length: 16 bits

         The total length of this RSVP aggregate message in bytes,
         including the aggregate header and the submessages that follow.











Swallow, editor                                                [Page 34]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


5.2. Message Formats

   An RSVP aggregate message must contain at least one submessage.  A
   submessage is one of the RSVP Path, PathTear, PathErr, Resv,
   ResvTear, ResvErr, or ResvConf messages.

   Empty RSVP aggregate message should not be sent.  It is illegal to
   include another RSVP aggregate message a as submessage.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |    12         |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   First submessage                           //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   More submessage...                         //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


5.3. Sending RSVP Aggregate Messages

   RSVP Aggregate messages are sent hop by hop between RSVP-capable
   neighbors as "raw" IP datagrams with protocol number 46.  Raw IP
   datagrams are also intended to be used between an end system and the
   first/last hop router, although it is also possible to encapsulate
   RSVP messages as UDP datagrams for end-system communication that
   cannot perform raw network I/O.

   RSVP Aggregate messages should not be used if the next-hop RSVP
   neighbor does not support RSVP Aggregate messages.  Methods for
   discovering such information include 1) Manual configuration. 2)
   Observing the Aggregate-capable bit (see below) in the received RSVP
   messages.

   Support for RSVP Aggregate message is optional.  While it might help
   in scaling RSVP and in reducing processing overhead and bandwidth
   consumption, a node is not required to transmit every standard RSVP
   message in an Aggregate message.  A node must always be ready to
   receive standard RSVP messages.

   The IP source address is local system that originated the Aggregate



Swallow, editor                                                [Page 35]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   message.  The IP destination address is the next-hop node for which
   the submessages are intended.  These addresses need not be identical
   if submessages are sent as standard RSVP messages.

   For example, the IP source address of Path and PathTear messages is
   the address of the sender it describes, while the IP destination
   address is the DestAddress for the session.  These end-to-end
   addresses are overridden by hop-by-hop addresses while encapsulated
   in an Aggregate message.  These addresses can easily be restored from
   the SENDER_TEMPLATE and SESSION objects within Path and PathTear
   messages.  For Path and PathTear messages, the next-hop node can be
   learned by looking up DestAddress in forwarding table.

   RSVP Aggregate messages do not require the Router Alert IP option
   [RFC 2113] in their IP headers.  This is because Aggregate messages
   are addressed directly to RSVP neighbors.

   Each RSVP Aggregate message must occupy exactly one IP datagram.  If
   it exceeds the MTU, the datagram is fragmented by IP and reassembled
   at the recipient node.  A single RSVP Aggregate message cannot exceed
   the maximum IP datagram size, approximately 64K bytes.


5.4. Receiving RSVP Aggregate Messages

   If the local system does not recognize or does not wish to accept an
   Aggregate message, the received messages shall be discarded without
   further analysis.

   The receiver next compares the IP TTL with which an Aggregate message
   is sent to the TTL with which it is received.  If a non-RSVP hop is
   detected, the number of non-RSVP hops is recorded. It is used later
   in processing of sub-messages.

   Next, the receiver verifies the version number and checksum of the
   RSVP aggregate message.  Discard message if any mismatch is found.

   Start decapsulating individual sub-messages.  Each sub-message has
   its own complete message length and authentication information.
   Process each sub-message according to procedures in RFC 2209.











Swallow, editor                                                [Page 36]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


5.5. Forwarding RSVP Aggregate Messages

   RSVP Aggregate messages could be forwarded by routers in non-RSVP
   cloud.  Aggregate messages shall not be forwarded RSVP routers.

   When individual submessages are being forwarded, they can be
   encapsulated in another aggregate message before sending to the
   next-hop neighbor.  The Send_TTL field in the submessages should be
   decremented properly before transmission.


5.6. Aggregate-capable bit

   An additional bit is added to RSVP common header, which is defined in
   RFC2205 [1].

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Vers | Flags |   Msg Type    |         RSVP Checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP Length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Flags: 4 bits

         0x01: Aggregate capable

           If set, indicates to RSVP neighbors that this node is willing
           and  capable  of  receiving  aggregate messages.  This bit is
           meaningful only between adjacent RSVP neighbors.


6. Tear Confirm

   The failure of an LSP Tunnel may result in loss of data.  Locally
   decapsulating the packet and routing is not recommended as this has
   the potential of inducing routing loops and may also violate policy.
   It is thus desirable to make the teardown function reliable.

   Due to the overhead involved in refreshes, administrators may desire
   to set the refreseh timers longer.  The Tear Confirm mechanism
   provides a means of ensuring timely teardown without the necessity of
   setting short refresh timers.

   This has the effect of both rapidly notifying the source that the
   tunnel is inoperative and of freeing the LSP's resources so they may
   be reallocated.



Swallow, editor                                                [Page 37]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


   The reliable teardown is accomplished via a combination of (a)
   including the CONFIRM object in the Resv Tear message, and (b) new
   ResvTear Confirm message.  The confirmations occur hop by hop.

   When the CONFIRM object is included in the ResvTear message, the code
   should:

      (a) set a boolean in the upstream RDB indicating that it is
      present only for retransmission purposes, and set a relatively
      short retransmission interval.  The RDB remains subject to normal
      timeout mechanisms.  If the node is a host, then the RDB should be
      timed out in a period based on its previous retransmission timer,
      i.e. (K + 0.5)*1.5*R, where R is the retransmission timer and K is
      a small integer with the default value of 3.

      (b) whenever the retransmission timer fires, if the boolean is
      FALSE, do as now: send a refreshing Resv message upstream and set
      a longish timer. If it is TRUE, however, set a relatively short
      timer and send an Resv Tear message with the CONFIRM object

      (c) when such an ResvTear message is received, similarly set the
      CONFIRM object and the boolean in the RDB if it exists, and send
      an Resv Tear message. If the RDB does not exist, reply ResvTear
      Confirm.

      (d) in the sender system, when the ResvTear with CONFIRM object is
      received, tear down the RDB and reply ResvTear Confirm to the
      NHOP. Do so whether the RDB exists on receipt or not.

      (e) in the non-sender systems, when the Resv Tear Confirm is
      received, tear down the RDB and forward Resv Tear Confirm to the
      next NHOP.


   Resv Tear Confirm is identical in content to the Resv Confirm, except
   that it results in the RDB being torn down, not established.

   The value of the MessageType for the Resv Tear Confirm message is 10
   (need to get an official one from the IANA).

   (We may also want to define a new CONFIRM object with a C-Type >= 192
   so that nodes which do not recognize the confirm object in the
   ResvTear message will not drop the message and will pass the object
   on.)







Swallow, editor                                                [Page 38]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


7. Security Considerations

   We assume that the security procedures defined for RSVP will handle
   any security issues that arise from coupling label switching with
   RSVP. For example, mechanisms that are used to authenticate RSVP
   resource reservation requests may also be used to authenticate
   requests to establish explicitly routed label switched paths.

   It may be desirable to enable the setup of ER-LSPs without enabling
   general purpose resource reservations. This would be done using the
   policy mechanisms defined for RSVP. It is likely that explicitly
   routed paths would often be setup only within a single administrative
   domain, and thus RSVP requests from outside the domain would be
   ignored.


8. Acknowledgments

   This document contains ideas as well as text which which have
   appeared in previous Internet Drafts.  The editors/authors of the
   current draft wish to thank the authors of those drafts.  They are
   Steven Blake, Bruce Davie, Roch Guerin, Sanjay Kamat, Yakov Rekhter,
   Eric Rosen, and Arun Viswanathan.


9. References

[1] Braden, R. et al. Resource ReSerVation Protocol (RSVP) --
    Version 1, Functional Specification, RFC 2205, September 1997.

[2] Rosen, E. et al. A Proposed Architecture for MPLS,  Internet
    Draft, draft-ietf-mpls-arch-00.txt, August 1997.

[3] Davie, B. et al. Explicit Route Support in MPLS, Internet
    Draft, draft-davie-mpls-explicit-routes-00.txt, November 1997

[4] Davie, B. et al. Use of Label Switching With RSVP, Internet
    Draft, draft-ietf-mpls-rsvp-00.txt, March 1998.

[5] Guerin, R. et al. Setting up Reservations on Explicit Paths using
    RSVP, Internet Draft, draft-guerin-expl-path-rsvp-01.txt,
    November 1997.

[6] Awduche, D. et al. Requirements for Traffic Engineering over MPLS,
    Internet Draft, draft-awduche-mpls-traffic-eng-00.txt, April 1998.

[7] Wroclawski, J. Specification of the Controlled-Load Network
    Element Service, RFC 2211, September 1997.



Swallow, editor                                                [Page 39]

Internet Draft   draft-swallow-mpls-rsvp-trafeng-00.txt      August 1998


[8] Rosen, E. MPLS Label Stack Encoding.  Internet Draft,
    draft-ietf-mpls-label-encaps-01.txt, February 1998.

















































Swallow, editor                                                [Page 40]



