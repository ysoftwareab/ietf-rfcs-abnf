

 Network Working Group                                      J. Strassner
 Internet-draft                                            Cisco Systems
 Category: Standards Track                                   E. Ellesson
                                                                     IBM
                                                           February 1999



                  Policy Framework Core Information Model
                   draft-ietf-policy-core-schema-01.txt
                          February 11, 1999 21:40

 Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   To learn the current status of any Internet-Draft, please check the
   "1id-abstracts.txt" listing contained in the Internet-Drafts Shadow
   Directories on ds.internic.net (US East Coast), nic.nordu.net
   (Europe), ftp.isi.edu (US West Coast), or munnari.oz.au (Pacific
   Rim).

 Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

 Abstract

   This document defines an object-oriented information model for
   representing policy information. This model defines structural
   information of objects that comprise and control policy (the
   "schema", or class inheritance hierarchy) as well as information that
   describes how different objects are related to other objects (the
   relationship hierarchy). In general, both of these class hierarchies
   will need to be mapped to a particular data store.

   This draft targets a directory that uses LDAP as its access protocol.
   As such, the class inheritance hierarchy can be directly mapped, but
   the relationship hierarchy will in general need to be mapped to a
   form suitable for directory implementation. This is because it
   contains concepts that are usually not directly translatable to the
   underlying data store. This document defines a schema and one such
   mapping of relationships for implementation in directories using
   LDAPv3 as their access protocol.

 Strassner, et. al.      Expires: August 8, 1999                [Page 1]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   The information model described in this document consists of five
   very general classes: policyGroup, policyRule, policyCondition,
   policyValidityPeriodCondition, and policyAction. While structural
   information is represented very well in LDAP schemas, relationships
   between objects are not. This document also defines how to map more
   abstract concepts, such as relationships, into LDAP schemas. One
   mechanism to do this mapping is to use auxiliary classes. This
   document defines one such class, the policyRuleContainmentAuxClass.

   While these classes are general, they are not abstract: they can all
   be directly instantiated.  Policy solutions for specific areas, such
   as DiffServ and IPSec, may use the policyGroup, policyRule,
   policyValidityPeriodCondition, and policyRuleContainmentAuxClass
   classes directly, while creating their own subclasses derived from
   policyCondition and policyAction in order to represent their own
   application-specific needs.






































 Strassner, et. al.      Expires: August 8, 1999                [Page 2]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 Table of Contents


   1. Introduction....................................................4

   2. Modeling Policies...............................................5
   2.1. Policy Scope..................................................8

   3. Overview of the Schema..........................................8
   3.1. Relationships.................................................9
   3.2. Associations.................................................10
   3.3. Aggregations.................................................10
   3.4. Key Relationships of the Policy Framework Core Information Model
   ...................................................................10

   4. Inheritance Hierarchy for the LDAP Schema......................11

   5. Class Definitions for the LDAP Schema..........................12
   5.1. Naming Attributes in the Core Schema.........................12
   5.2. The Class policyGroup........................................12
   5.2.1. The attribute cn...........................................14
   5.2.2. The Attribute policyGroupName..............................14
   5.2.3. The Attribute containedPolicyGroups........................14
   5.2.4. The Attribute policyGroupType..............................15
   5.3. The Class policyRuleContainmentAuxClass......................15
   5.3.1. The Attribute policyRulesAuxContainedSet...................16
   5.4. The Class policyRule.........................................16
   5.4.1. The Attribute cn...........................................18
   5.4.2. The Attribute policyRuleName...............................18
   5.4.3. The Attribute policyRuleEnabled............................18
   5.4.4. The Attribute policyRuleConditionListType..................18
   5.4.5. The Attribute policyRuleConditionList......................19
   5.4.6. The Attribute policyRuleActionList.........................20
   5.4.7. The Attribute policyRuleKeywords...........................21
   5.4.8. The Attribute policyRuleType...............................21
   5.4.9. The Attribute policyRuleUsage..............................22
   5.4.10. The Attribute policyRulePriority..........................22
   5.4.11. The Attribute policyRuleMandatory.........................23
   5.4.12. The Attribute policyRuleDebugMode.........................23
   5.4.13. The Attribute policyRuleSequencedActions..................24
   5.5. The Class policyValidityPeriodCondition......................24
   5.5.1. The Attribute pvpConditionTime.............................25
   5.5.2. The Attribute pvpConditionMonthOfYearMask..................26
   5.5.3. The Attribute pvpConditionDayOfMonthMask...................26
   5.5.4. The Attribute pvpConditionDayOfWeekMask....................27
   5.5.5. The Attribute pvpConditionTimeOfDayMask....................28
   5.5.6. The Attribute pvpConditionTimeZone.........................29
   5.6. The Class policyCondition....................................29
   5.6.1. The Attribute cn...........................................31
   5.6.2. The Attribute policyConditionName..........................31
   5.7. The Class vendorPolicyCondition..............................31
   5.7.1. The Attribute vendorPolicyConditionConstraint..............32


 Strassner, et. al.      Expires: August 8, 1999                [Page 3]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   5.7.2. The Attribute vendorPolicyConditionEncoding................32
   5.8. The Class policyAction.......................................33
   5.8.1. The Attribute cn...........................................33
   5.8.2. The Attribute policyActionName.............................33
   5.9. The Class vendorPolicyAction.................................34
   5.9.1. The Attribute vendorPolicyActionData.......................34
   5.9.2. The Attribute vendorPolicyActionEncoding...................35

   6. Extending the Core Schema......................................35
   6.1. Subclassing policyCondition and policyAction.................35
   6.2. Subclassing policyRule.......................................36
   6.2.1. Refining the semantics of policyRule.......................36
   6.2.2. Optimizing the computation of a policyRule.................36
   6.3. Using the Vendor Policy Encoding Attributes..................36
   6.4. Using Time Validity Periods..................................37

   7. Security Considerations........................................37

   8. Intellectual Property..........................................37

   9. Acknowledgments................................................38

   10. References....................................................38

   11. Authors' Addresses............................................39

   12. Full Copyright Statement......................................39

   13. Appendix A - Guidelines for Construction of DNs...............39



 1. Introduction

   This document defines an information model, containing a schema
   (represented as a class inheritance hierarchy) and a relationship
   model. The schema contains five core classes for representing
   policies: policyGroup, policyRule, policyCondtion, policyAction, and
   policyValidityPeriodCondition.

   This schema can be mapped to many different data store
   implementations. This document concentrates on a mapping of the data
   store to a directory that uses LDAP as its access protocol. However,
   the relationship class hierarchy needs to be mapped to a specific
   data store implementation. This document defines a mapping for the
   relationships of this information model to a directory that uses
   LDAPv3 as its access protocol. A sixth core class,
   policyRuleContainmentAuxClass, is used as part of this mapping.  The
   use of an information model enables the schema and the relationship
   class hierarchy to be extensible, such that other types of policy
   repositories, such as relational databases, can use this information.



 Strassner, et. al.      Expires: August 8, 1999                [Page 4]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   These six classes and their relationships are sufficiently generic to
   allow them to represent policies related to anything. However, their
   initial application will be for representing policies related to QoS
   (DiffServ and IntServ) and to IPSec.  Policy models for application-
   specific areas such as these may extend the core schema in several
   ways. The preferred way is to use the policyGroup, policyRule,
   policyValidityPeriodCondition, and policyRuleContainmentAuxClass
   classes directly, as a foundation for representing and communicating
   policy information. Then, specific subclasses derived from
   policyCondition and policyAction can capture application-specific
   definitions of conditions and actions of policies. These subclasses
   will then fit naturally within the policy framework of the above four
   classes. This will be explored more thoroughly in Section 6.0,
   "Extending the Core Schema".

   Two subclasses, vendorPolicyCondition and vendorPolicyAction are also
   included in this document, to provide a standard escape mechanism for
   vendor-specific extensions to the core policy schema.

   This document fits into the overall framework for representing,
   deploying, and managing policies being developed by the Policy
   Framework Working Group.  The initial work to define this framework
   is in reference [1].  More specifically, this document builds on the
   core policy classes first introduced in references [2] and [3].  It
   also draws on the work done for the Directory-enabled Networks (DEN)
   specification, reference [4].  Work on the DEN specification by the
   DEN Ad-Hoc Working Group itself has been completed.  Further work to
   standardize the models contained in it will be the responsibility of
   selected working groups of the CIM (Common Information Model) effort
   in the Desktop Management Task Force (DMTF).  Standardization of the
   core policy model is the responsibility of the SLA Policy working
   group.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119, reference
   [5].


 2. Modeling Policies

   The classes comprising the Policy Framework Core Information Model
   Class Hierarchy are intended to serve as an extensible class
   hierarchy (through specialization) for defining policy objects that
   enable application developers, network administrators, and policy
   administrators to represent policies of different types.

   The simplest way to think of a policy-controlled network is to first
   model the network as a state machine and then use policy to control
   which state a policy-controlled device should be in or is allowed to
   be in at any given time. Given this approach, policy is applied using
   a set of policy rules. Each policy rule consists of a set of


 Strassner, et. al.      Expires: August 8, 1999                [Page 5]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   conditions and a set of actions. Policy rules may be aggregated into
   policy groups.  These groups may be nested, to represent a hierarchy
   of policies.

   The set of conditions associated with a policy rule specifies when
   the policy rule is applicable. The set of conditions can be expressed
   as either an ORed set of ANDed sets of condition statements or an
   ANDed set of ORed sets of statements. These combinations are termed,
   respectively, Disjunctive Normal Form (DNF) and Conjunctive Normal
   Form (CNF) for the conditions. Please note that it is explicitly NOT
   a goal of this specification to represent more complicated conditions
   (such as those that may be found in a procedural language) at this
   time.

   If the set of conditions associated with a policy rule evaluates to
   TRUE, then a set of actions that either maintain the current state of
   the object or transition the object to a new state may be executed.
   For the set of actions associated with a policy rule, it is possible
   to specify an order of execution, as well as an indication of whether
   the order is required or merely recommended.  It is also possible to
   indicate that the order in which the actions are executed does not
   matter.

   Actions can be prioritized so as to avoid conflicts. However, this
   release of the core schema draft does not specify conditional
   handling of the actions to be executed, nor does it specify the
   handling of generalized error conditions. This is because if this
   feature is implemented, then policies immediately become much more
   complex. It is considered better to gain implementation experience
   with simpler policies and use this experience to then build more
   complex policies.

   Policy rules themselves can be prioritized.  One common reason for
   doing this is to express an overall policy that has a general case
   with a few specific exceptions.

   For example, a general QoS policy rule might specify that traffic
   originating from members of the engineering group is to get Bronze
   Service.  A second policy rule might express an exception: traffic
   originating from John, a specific member of the engineering group, is
   to get Gold Service.  Since traffic originating from John satisfies
   the conditions of both policy rules, and the actions associated with
   the two rules are incompatible, a priority needs to be established.
   By giving the second rule (the exception) a higher priority than the
   first rule (the general case), a policy administrator can get the
   desired effect: traffic originating from John gets Gold Service, and
   traffic originating from all the other members of the engineering
   group gets Bronze Service.

   Policies can either be used in a stand-alone fashion or aggregated
   into policy groups to perform more elaborate functions. Stand-alone
   policies are called policy rules. Policy groups are aggregations of


 Strassner, et. al.      Expires: August 8, 1999                [Page 6]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   policy rules, or aggregations of policy groups, but not both. Policy
   groups can model intricate interactions between objects that have
   complex interdependencies. Examples of this include a sophisticated
   user logon policy that sets up application access, security, and
   reconfigures network connections based on a combination of user
   identity, network location, logon method and time of day. A policy
   group represents a unit of reusability and manageability in that its
   management is handled by an identifiable group of administrators and
   its policyRules apply equally to the scope of the policyGroup.

   Stand-alone policies are those that can be expressed in a simple
   statement. They can be represented effectively in schemas or MIBs.
   Examples of this are VLAN assignments, simple YES/NO QoS requests,
   and IP address allocations. A specific design goal of this schema is
   to support both stand-alone and aggregated policies.

   Policy groups and rules can be classified by their purpose and
   intent.  This classification is useful in querying or grouping policy
   rules.  It indicates whether the policy is used to motivate when or
   how an action occurs, or to characterize services (that can then be
   used, for example, to bind clients to network services).  Describing
   each of these concepts in more detail,

   o Motivational Policies are solely targeted at whether or how a
      policy's goal is accomplished.  Configuration and Usage Policies
      are specific kinds of Motivational Policies.  Another example is
      the scheduling of file backup based on disk write activity from
      8am to 3pm, M-F.

   o Configuration Policies define the default (or generic) setup of a
      managed entity (for example, a network service).  Examples of
      Configuration Policies are the setup of a network forwarding
      service or a network-hosted print queue.

   o Installation Policies define what can and can't be put on a system
      or component, as well as the configuration of the mechanisms that
      perform the install. Installation policies typically represent
      specific administrative permissions, and can also represent
      dependencies between different components (e.g., to complete the
      installation of component A, components B and C must be previously
      successfully installed or uninstalled).

   o Error and Event Policies. For example, if a device fails between
      8am and 9pm, call the system administrator, else call the Help
      Desk.

   o Usage Policies control the selection and configuration of entities
      based on specific "usage" data.  Configuration Policies can be
      modified or simply re-applied by Usage Policies.  Examples of
      Usage Policies include upgrading network forwarding services after
      a user is verified to be a member of a "gold" service group, or



 Strassner, et. al.      Expires: August 8, 1999                [Page 7]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


      reconfiguring a printer to be able to handle the next job in its
      queue.

   o Security Policies deal with verifying that the client is actually
      who the client purports to be, permitting or denying access to
      resources, selecting and applying appropriate authentication
      mechanisms, and performing accounting and auditing of resources.

   o Service Policies characterize network and other services (not use
      them). For example, all wide-area backbone interfaces shall use a
      specific type of queuing.

      Service policies describe services available in the network. Usage
      policies describe the particular binding of a client of the
      network to services available in the network.

 2.1. Policy Scope

   Policies represent business goals and objectives. A translation must
   be made between these goals and objectives and their realization in
   the network. An example of this could be a Service Level Agreement
   (SLA), and its objectives and metrics (Service Level Objectives, or
   SLOs), that are used to specify services that the network will
   provide for a given client [8]. The SLA will usually be written in
   high-level business terminology. SLOs address more specific metrics
   in support of the SLA. These high-level descriptions of network
   services and metrics must be translated into lower-level, but also
   vendor- and device-independent specifications. The core policy schema
   classes are intended to be used as part of the definition of this
   specification.

   This translation is domain-independent. That is, it applies equally
   to Quality of Service (QoS) as defined in the Differentiated Services
   working group of the IETF) as it does to signaled QoS, as specified
   in the Integrated Services working group of the IETF.

   Furthermore, it is envisioned that the definition of policy in this
   draft is generic in nature and is suitable for non-QoS networking
   applications (e.g., DHCP and IPSEC) as well as non-networking
   applications (e.g., backup policies, auditing access, etc.).


 3. Overview of the Schema

   The following diagram provides an overview of the five classes that
   comprise the CIM core schema, and their relationships to each other.
   Note that the two extension classes vendorPolicyCondition and
   vendorPolicyAction are not shown.






 Strassner, et. al.      Expires: August 8, 1999                [Page 8]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


                 **************
                 *            *
            0..n *            * ContainedPolicyGroups
          +------v------+     *
          | policyGroup <******
          |             | 0..n
          +------^------+
            0..n *
                 * ContainedPolicyRules
            0..n *
           +-----v-------+
           |             |
           | policyRule  |
           |             |   ContainedPolicyConditions (ORed set of
   ANDed
           |             <*************************     conditions, or
           |             | 0..n                   *     vice-versa)
           |             |                        * 0..n
           |             |              +---------v------------+
           |             |              | policyCondition      |
           |             |              +----------------------+
           |             |                        ^
           |             |                        I
           |             |                        I
           |             |                        ^
           |             |        +------------------------------ +
           |             |        | policyValidityPeriodCondition |
           |             |        +------------------------------ +
           |             |
           |             |        ContainedPolicyActions
           |             <*************************
           |             | 0..n                   *
           |             |                        * 0..n
           |             |              +---------v------------+
           |             |              | policyAction         |
           +-------------+              +----------------------+

   Figure 1.     An Overview of the CIM Policy Classes and Their
     Relationships

 3.1. Relationships

   Relationships are a central feature of information models. A
   relationship represents a physical or conceptual connection between
   objects. CIM and DEN define the general concept of an association
   between two (or more) objects. Two types of associations are
   aggregations (which express whole-part relationships) and other
   relationships, such as those that express dependency. Both are used
   in this model.





 Strassner, et. al.      Expires: August 8, 1999                [Page 9]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 3.2. Associations

   An association is a class that contains two or more references, where
   each reference identifies another object. An association is defined
   using a class. Associations can be defined between classes without
   affecting any of the related classes.  That is, addition of an
   association does not affect the interface of the related classes.

 3.3. Aggregations

   An aggregation is a strong form of an association. An aggregation is
   usually used to represent a "whole-part" relationship. This type of
   relationship defines the containment relationship between a system
   and the components that make up the system. Aggregation often
   implies, but does not require, that the aggregated objects have
   mutual dependencies.

 3.4. Key Relationships of the Policy Framework Core Information Model

   The following relationships are shown in the preceding figure:

   o The ContainedPolicyGroups relationship enables policyGroups to be
      nested. This is critical for scalability and manageability, as it
      enables complex policies to be constructed from multiple simpler
      policies for administrative convenience. For example, a
      policyGroup representing policies for the US might have nested
      within it policy groups for the Eastern and Western US.

      For LDAP schemata, the ContainedPolicyGroups relation is mapped to
      the containedPolicyGroups attribute (note that other data stores
      may define a different mapping). This attribute enables a
      policyGroup to identify another policyGroup as its offspring.

   o A policy group may also aggregate one or more policy rules.
      Grouping of policy rules into a policy group is again for
      administrative convenience; a policy rule may also be used by
      itself, without belonging to a policy group.

   o A policyRule may also be aggregated by an instance of any class to
      which the policyRuleContainmentAuxClass class has been attached.
      Once again, this is for administrative convenience.  If the
      directory entry to which the policyRuleContainmentAuxClass has
      been attached is a policy group, then the pointer in the
      policyRuleContainmentAuxClass realizes the relationship discussed
      above between the group and a policyRule; a separate attribute is
      not needed in the policyGroup class.

   o A condition of a policyRule may specify one or more time validity
      periods. This can be used for several purposes. Two important uses
      include representing time as an additional condition (e.g., use
      one policy in the morning and use a different policy in the
      afternoon) and to enable scheduled activation and deactivation of


 Strassner, et. al.      Expires: August 8, 1999               [Page 10]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


      the policyRule. A policy validity period may be aggregated by
      multiple policyRules. A rule that does not point to a policy
      validity period is, from the point of view of scheduling, always
      active.  It may, however, be inactive for other reasons.

      Time validity periods are a general concept that can be used in
      other applications. However, they are mentioned explicitly here in
      this specification since they are frequently used in policy
      applications.

   o A policyRule aggregates zero or more instances of the
      policyCondition class. For all policy rules, at least one
      condition MUST be specified, either via the
      containedPolicyConditions aggregation, or defined explicitly
      within a subclass of policyRule. These conditions are grouped into
      two levels of lists: either an ORed set of ANDed sets of
      conditions (DNF, the default) or an ANDed set of ORed sets of
      conditions (CNF).  The attribute policyRuleConditionListType
      specifies which of these two grouping schemes applies to a
      particular policyRule.

      Since conditions may be defined explicitly in a subclass of
      policyRule, the AND/OR mechanism to combine these conditions with
      other (associated) policyConditions MUST be specified by the
      policyRule's subclass.

      In either case, the conditions are used to determine whether to
      perform the actions associated with the policyRule. For LDAP
      schemata, pointers to PolicyCondition objects (or subclasses of
      this class) are used.

   o A policyRule may aggregate zero or more policy actions. For all
      policy rules, at least one action MUST be specified, either via
      the containedPolicyActions aggregation, or defined explicitly
      within a subclass of policyRule. The actions associated with a
      policyRule may be given a required order, a recommended order, or
      no order at all. For actions represented as separate objects, the
      containedPolicyActions aggregation can be used to express an
      order. For actions defined explicitly in a subclass of policyRule,
      the ordering mechanism must be specified in the subclass
      definition.


 4. Inheritance Hierarchy for the LDAP Schema

   The following diagram illustrates the class hierarchy for the LDAP
   policy schema classes:







 Strassner, et. al.      Expires: August 8, 1999               [Page 11]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


         top
          |
          +---policyGroup
          |
          +---policyRuleContainmentAuxClass
          |
          +---policyRule
          |
          +---policyCondition
          |          |
          |          +---policyValidityPeriodCondition
          |          |
          |          +---vendorPolicyCondition
          |
          +---policyAction
                     |
                     +---vendorPolicyAction


 5. Class Definitions for the LDAP Schema

   The classes described below contain certain optimizations for a
   directory that uses LDAP as its access protocol. One example of this
   is the use of an auxiliary class to represent CIM relationships.
   Other data stores might need to implement these relationships
   differently.

 5.1. Naming Attributes in the Core Schema

   Instances in a directory are identified by distinguished names (DNs),
   which provide the same type of hierarchical organization that a file
   system provides in a computer system.  A distinguished name is a
   sequence of relative distinguished names (RDNs), where an RDN
   provides a unique identifier for an instance within the context of
   its immediate superior in the same way that a filename provides a
   unique identifier for a file within the context of the folder in
   which it resides.

   To preserve maximum naming flexibility for policy administrators,
   each of the classes defined in this schema has its own naming
   attribute. Since the naming attributes are different, the policy
   administrator is guaranteed that there will be no name collisions
   between instances of different classes, even if the same VALUE is
   assigned to the instances' respective naming attributes.  To fit in
   with existing directory practice, each of the classes uses the
   commonName (cn) attribute as its naming attribute.

 5.2. The Class policyGroup

   This class is a generalized aggregation container. It enables either
   policyRules or policyGroups, but not both, to be aggregated in a
   single container. Loops, including the degenerate case of a


 Strassner, et. al.      Expires: August 8, 1999               [Page 12]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   policyGroup that contains itself, are not allowed when policyGroups
   contain other policyGroups.

   PolicyGroups and their nesting capabilities are shown in Figure 2
   below. Note that a policyGroup can nest other policyGroups, and there
   is no restriction on the depth of the nesting in sibling
   policyGroups.

     +---------------------------------------------------+
     |                    policyGroup                    |
     |                                                   |
     | +--------------------+       +-----------------+  |
     | |    policyGroup A   |       |  policyGroup X  |  |
     | |                    |       |                 |  |
     | | +----------------+ |  ooo  |                 |  |
     | | | policyGroup A1 | |       |                 |  |
     | | +----------------+ |       |                 |  |
     | +--------------------+       +-----------------+  |
     +---------------------------------------------------+

   Figure 2.    Overview of the policyGroup class

   As a simple example, think of the highest level policyGroup shown in
   Figure 2 above as a logon policy for US employees of a company. This
   policyGroup may be called USEmployeeLogonPolicy, and may aggregate
   several policyGroups that provide specialized rules per location.
   Hence, policyGroupA in Figure 2 above may define logon rules for
   employees on the West Coast, while another policyGroup might define
   logon rules for the Midwest (e.g., policyGroupX), and so forth.

   Note also that the depth of each policyGroup does not need to be the
   same. Thus, the WestCoast policyGroup might have several additional
   layers of policyGroups defined for any of several reasons (different
   locales, number of subnets, etc.). The policyRules are therefore
   contained at n levels from the USEmployeeLogonPolicyGroup. Compare
   this to the Midwest policyGroup (policyGroupX), which might directly
   contain policyRules.

   The class definition for policyGroup is as follows.  Note that this
   class definition does not include an attribute to realize the
   ContainedPolicyRules association from the object model, since a
   policyGroup object points to instances of policyRule via the pointer
   in policyRuleContainmentAuxClass.

     NAME             policyGroup
     DESCRIPTION     A container for either a set of related
                      policyRules or a set of related policyGroups
     DERIVED FROM    top
     TYPE             structural
     AUXILIARY CLASSES   policyRuleContainmentAuxClass
     POSSIBLE SUPERIORS  container, organization, organizationalUnit,
                      policyGroup


 Strassner, et. al.      Expires: August 8, 1999               [Page 13]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


     OID              <to be assigned>
     MUST             cn, policyGroupName
     MAY              containedPolicyGroups, policyGroupType

 5.2.1. The attribute cn

   The cn, or commonName, attribute is an X.500 attribute. It stands for
   commonName. It specifies a user-friendly name by which the object is
   commonly known. This name may be ambiguous by itself. This name is
   used in a limited scope (such as an organization). It conforms to the
   naming conventions of the country or culture with which it is
   associated. CN is used universally in DEN as the naming attribute for
   a class.

     NAME             cn
     DESCRIPTION     Naming attribute of this class
     SYNTAX           DirectoryString
     OID              2.4.5.3
     EQUALITY        caseExactMatch
     SINGLE-VALUED

 5.2.2. The Attribute policyGroupName

   This attribute provides a user-friendly name for a policy group, and
   is normally what will be displayed to the end-user as the name of
   this class. It is defined as follows:

     NAME             policyGroupName
     DESCRIPTION     The user-friendly name of this policy group.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY        caseExactIA5Match
     SINGLE-VALUED

 5.2.3. The Attribute containedPolicyGroups

   This attribute provides an unordered set of DN pointers to zero or
   more other policyGroup objects, representing nested policyGroups
   contained by this policyGroup.  The attribute definition is as
   follows:

     NAME             containedPolicyGroups
     DESCRIPTION     Distinguished names of other policyGroup objects
                      aggregated by this policy group.  There is no
                      order implied among the members of the set.
     SYNTAX           DN
     OID              <to be assigned>
     EQUALITY        distinguishedNameMatch
     MULTI-VALUED





 Strassner, et. al.      Expires: August 8, 1999               [Page 14]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 5.2.4. The Attribute policyGroupType

   This attribute is used to specify the type of policy that this
   policyGroup represents. This can be used for classification (for
   example, service policy or usage policy) or categorization (the type
   of service or usage policy that this policy is). The attribute
   definition is as follows:

     NAME             policyGroupType
     DESCRIPTION     Defines a policyGroup classification and
                      categorization. When multiple classifications are
                      possible, the one that "best" describes the
                      policyGroup's type should be used.
     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY        integerMatch
     SINGLE-VALUED
     DEFAULT VALUE   0

   The defined values for this attribute are: Unknown (0), Configuration
   (1), Usage (2), Security (3), Service (4), Motivational (5),
   Installation (6), and Event (7).  These concepts were defined in
   Section 2.0.

 5.3. The Class policyRuleContainmentAuxClass

   This auxiliary class provides a single, multi-valued attribute that
   points to a set of policyRules.  By attaching this attribute to
   instances of various other classes, a policy administrator has a
   flexible way of providing an entry point into the directory that
   allows a client to locate and retrieve the policyRules relevant to
   it.

   A policy administrator might have several different pointers to a
   policyRule in the overall directory structure.  For example, there
   might be pointers to all policyRules for traffic originating in a
   particular subnet from a directory entry that represents that subnet.
   At the same time, there might be pointers to all policyRules related
   to a particular DiffServ setting from an instance of a policyGroup
   explicitly introduced as a container for DiffServ-related
   policyRules.  The policyRuleContainmentAuxClass is the mechanism that
   makes it possible for the policy administrator to define all these
   pointers.

   Note that the cn attribute does NOT need to be defined for this
   class. This is because an auxiliary class is used as a means to
   collect common attributes and treat them as properties of an object.
   A good analogy is a #include file, except that since an auxiliary
   class is a class, all the benefits of a class (e.g., inheritance) can
   be applied to an auxiliary class.

   The class definition is as follows:


 Strassner, et. al.      Expires: August 8, 1999               [Page 15]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


     NAME             policyRuleContainmentAuxClass
     DESCRIPTION     An auxiliary class used to bind policyRules to an
                      appropriate container object.
     DERIVED FROM    top
     TYPE             auxiliary
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  container, organization, organizationalUnit,
                      policyGroup
     OID              <to be assigned>
     MUST             policyRulesAuxContainedSet

 5.3.1. The Attribute policyRulesAuxContainedSet

   This attribute provides an unordered set of DN pointers to one or
   more policyRules associated with the instance of a structural class
   to which this attribute has been appended.  The attribute definition
   is:

     NAME             policyRulesAuxContainedSet
     DESCRIPTION     Distinguished names of policyRules associated in
                      some way with the instance to which this attribute
                      has been appended.  No order is implied.
     SYNTAX           DN
     OID              <to be assigned>
     EQUALITY        distinguishedNameMatch
     MULTI-VALUED

 5.4. The Class policyRule

   This class represents the "If Condition then Action" semantics
   associated with a policy.  A policyRule condition, in the most
   general sense, is represented as either an ORed set of ANDed
   conditions (Disjunctive Normal Form, or DNF) or an ANDed set of ORed
   conditions (Conjunctive Normal Form, or CNF). The actions specified
   by a policyRule are to be performed if and only if the policyRule
   condition (whether it is represented in DNF or CNF) evaluates to
   TRUE. Both the conditions and the actions are identified by DN
   pointers and/or by specific attributes introduced in subclasses of
   policyRule.

   This is illustrated conceptually in Figure 3 below.

     +------------------------------------------------+
     |                    PolicyRule                  |
     |                                                |
     | +--------------------+     +-----------------+ |
     | |  PolicyCondition(s)|     | PolicyAction(s) | |
     | +--------------------+     +-----------------+ |
     |                                                |
     +------------------------------------------------+

   Figure 3.    Overview of the PolicyRule Class


 Strassner, et. al.      Expires: August 8, 1999               [Page 16]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   The policyRule class uses the attribute policyRuleConditionListType,
   to indicate whether the conditions for the rule are in DNF or CNF.
   The DN pointers from a policyRule to its associated policyConditions
   also contain an integer to partition the referenced conditions into
   one or more sets.  An example shows how the attribute and the
   grouping integer provide a unique representation of a set of
   conditions in either DNF or CNF.

   Suppose we have pointers to five policyConditions from an instance of
   policyRule, grouped as follows:

   (C1: groupNumber = 1,
    C2: groupNumber = 1,
    C3: groupNumber = 1,
    C4: groupNumber = 2,
    C5: groupNumber = 2)

   If policyRuleConditionListType = DNF, then the overall condition = for
   the policyRule is:

        (C1 AND C2 AND C3) OR (C4 AND C5)

   On the other hand, if policyRuleConditionListType = CNF, then the
   overall condition for the policyRule is:

        (C1 OR C2 OR C3) AND (C4 OR C5)

   In both cases there is an unambiguous specification of the overall
   condition that is tested to determine whether to perform the actions
   associated with the policyRule.

   This class also contains several attributes designed to help
   directory clients locate the policy rules applicable to them. The
   class definition is as follows:

     NAME             policyRule
     DESCRIPTION     The central class for representing the "If
                      Condition then Action" semantics associated with a
                      policy rule.
     DERIVED FROM    top
     TYPE             structural
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  policyGroup
     OID              <to be assigned>
     MUST             cn policyRuleName
     MAY              policyRuleEnabled policyRuleConditionListType
                      policyRuleConditionList policyRuleActionList
                      policyRuleKeywords policyRuleType policyRuleUsage
                      policyRulePriority policyRuleMandatory
                      policyRuleDebugMode policyRuleSequencedActions




 Strassner, et. al.      Expires: August 8, 1999               [Page 17]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 5.4.1. The Attribute cn

   This is the exact same definition as in Section 5.2.1. It is included
   in this class for the reasons enumerated there.

 5.4.2. The Attribute policyRuleName

   This attribute provides a user-friendly name for a policy rule. The
   attribute definition is as follows:

     NAME             policyRuleName
     DESCRIPTION     The user-friendly name of this policy rule.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY        caseExactIA5Match
     SINGLE-VALUED

 5.4.3. The Attribute policyRuleEnabled

   This flag indicates whether a policy rule is currently enabled, from
   an ADMINISTRATIVE point of view.  Its purpose is to allow a policy
   administrator to enable or disable a policy rule without having to
   add it to, or remove it from, the directory. The attribute definition
   is as follows:

     NAME             policyRuleEnabled
     DESCRIPTION     A flag indicating whether this policy rule is
                      enabled from an administrative point of view.
     SYNTAX           Boolean
     OID              <to be assigned>
     EQUALITY        booleanMatch
     SINGLE-VALUED
     DEFAULT VALUE   TRUE

 5.4.4. The Attribute policyRuleConditionListType

   This attribute is used to specify whether the list of policy
   conditions associated with this policy rule is in disjunctive normal
   form (DNF) or conjunctive normal form (CNF).  If this attribute is
   not present, the list type defaults to DNF.  The attribute definition
   is as follows:

     NAME             policyRuleConditionListType
     DESCRIPTION     Indicates whether the list of policy conditions
                      associated with this policy rule is in disjunctive
                      normal form (DNF) or conjunctive normal form
                      (CNF).  Defined values are 'DNF (1)' and 'CNF
                      (2)'.
     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY        integerMatch
     SINGLE-VALUED


 Strassner, et. al.      Expires: August 8, 1999               [Page 18]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


     DEFAULT VALUE   1 (DNF)

 5.4.5. The Attribute policyRuleConditionList

   This attribute provides an unordered list of DN pointers that
   identify a set of policy conditions associated with this policy rule.
   There is an integer associated with each pointer, to provide the
   grouping of the conditions into first-level groups for the DNF or CNF
   representation of the overall policyRule condition.  To accommodate
   this grouping, the syntax of this attribute is a string of the form
   'groupNumber:DN'.

   Existing matching rules are built to operate on a single data type.
   This attribute is conceptually comprised of two data types, an
   Integer (groupNumber) and DistinguishedName (DN). There are three
   ways to address this.

   1. Collapse the two attribute types into a single structured IA5
     string with the format 'groupNumber:DN'.  This approach has the
     advantage of not requiring any new support in the directory server
     implementations, since these servers already support an IA5 string
     matching rule.  Its disadvantage is that an IA5 string match works
     somewhat differently from a DN match with respect to subtleties
     such as preserving versus ignoring versus removing repeated
     whitespace characters.  Thus DNs that would match with the
     distinguishedNameMatch matching rule might fail to be found as
     substrings of 'groupNumber:DN' strings by the IA% matching rules,
     or vice versa.

   2. Define a new syntax '<integer>:<DN>', with its own matching rules.
     With this approach the matching problems introduced by the IA5
     string could be avoided, since the new type would have its own
     matching rules.  The disadvantage of defining a new type in this
     way is that a directory server must add new code that recognizes
     the type and implements its matching rules.  A directory server
     would thus be unable to support the Core Policy Schema until it had
     added this new code.

   3. Use two objects in the directory to represent the two data types,
     and relate the objects with the Families of Entries model currently
     being discussed in the LDAP Extensions working group.  This
     approach has the same problem as the previous one: without the
     addition of new code to support Families of Entries, a directory
     server would be unable to support the Core Policy Schema at all.
     There is also the additional complication here, that the Families
     of Entries model itself may take some time to reach approved status
     in the LDAP Extensions (LDAPEXT) working group.

   For now, this document will move forward with the 'groupNumber:DN'
   structured IA5 string approach for containedPolicyConditions, as well
   as with an analogous 'n:DN' approach for containedPolicyActions.  To
   minimize problems arising from differences in matching rules, this


 Strassner, et. al.      Expires: August 8, 1999               [Page 19]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   document will provide a series of guidelines for constructing DNs
   that behave identically with respect to the IA5 matching rules and
   the distinguishedNameMatch. These guidelines are in Appendix A.

   The attribute definition is as follows:

     NAME             policyRuleConditionList
     DESCRIPTION     An unordered list of strings of the form
                      'groupNumber:DN', indicating a set of policy
                      conditions that determine when the policyRule is
                      applicable.
     SYNTAX           OctetString
     OID              <to be assigned>
     EQUALITY        TBD
     MULTI-VALUED
     FORMAT           groupNumber:DN

 5.4.6. The Attribute policyRuleActionList

   This attribute provides an unordered list of strings of the form
   'n:DN' that identify a set of policy actions associated with this
   policy rule.  (See section 5.4.5 for a discussion of the issues
   surrounding the use of a syntax of this type.)  When 'n' is a
   positive integer, it indicates a place in the sequence of actions to
   be performed, with smaller integers indicating earlier positions in
   the sequence.  The special value '0' indicates "don't care," with one
   exception: all actions with positive sequence numbers are to be
   performed before any actions with sequence number '0'.  Finally, if
   two or more actions have the same non-zero sequence number, they may
   be performed in any order, but they must all be performed at the
   appropriate place in the overall action sequence.

   A series of examples will make ordering of actions clearer:

   o If all actions have the same sequence number, regardless of
      whether it is '0' or non-zero, any order is acceptable.

   o The values

      1:DN-A
      2:DN-B
      1:DN-C
      3:DN-D

      indicate two acceptable orders:  A,C,B,D or C,A,B.D, since A and C
      can be performed in either order, but only at the '1' position.

   o The values

      0:DN-A
      2:DN-B
      0:DN-C


 Strassner, et. al.      Expires: August 8, 1999               [Page 20]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


      3:DN-D

      indicate either B,D,A,C or B,D,C,A, since the '0' actions A and C
      must be performed after the non-zero ones.  Note that the non-zero
      sequence numbers need not start with '1', and they need not be
      consecutive.  All that matters is their relative magnitude.

   This attribute indicates the actions of a policyRule and their order
   (or absence of order).  However, another attribute,
   policyRuleSequencedActions, indicates whether the indicated order is
   required, recommended, or not to be used at all.

   All actions specified in the policyRuleActionList will be executed as
   long as the overall policy condition as defined by the
   policyRuleConditionListType and policyRuleConditionList attributes
   evaluates to TRUE.

   The attribute definition is as follows:

     NAME             policyRuleActionList
     DESCRIPTION     An unordered list of strings of the form 'n:DN',
                      indicating an ordered set of policy actions to be
                      performed if the associated condition(s) of the
                      policyRule evaluates to true.
     SYNTAX           Octet String
     OID              <to be assigned>
     EQUALITY        TBD
     MULTI-VALUED
     FORMAT           n:DN

 5.4.7. The Attribute policyRuleKeywords

   This attribute provides a set of one or more ad hoc keywords that a
   policy administrator may define to assist directory clients in
   locating the policy rules applicable to them.  Values for this
   attribute are installation dependent, and thus are not specified in
   any schema document. The attribute definition is as follows:

     NAME             policyRuleKeywords
     DESCRIPTION     A set of ad hoc keywords to assist directory
                      clients in locating the policy rules applicable to
                      them.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY        caseExactIA5Match
     MULTI-VALUED

 5.4.8. The Attribute policyRuleType

   This attribute is used to specify the type of policy that this policy
   rule represents. This can be used for classification (for example,
   service policy or usage policy) or categorization (the type of


 Strassner, et. al.      Expires: August 8, 1999               [Page 21]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   service or usage policy that this policy is). The attribute
   definition is as follows:

     NAME             policyRuleType
     DESCRIPTION     Defines a policy classification and
                      categorization. When multiple classifications are
                      possible, the one that "best" describes the
                      policy's type should be used.
     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY        integerMatch
     SINGLE-VALUED
     DEFAULT VALUE   0

   The defined values for this attribute are: Unknown (0), Configuration
   (1), Usage (2), Security (3), Service (4), Motivational (5),
   Installation (6), and Event (7).  These concepts were defined in
   Section 2.0.

 5.4.9. The Attribute policyRuleUsage

   This attribute is a free-form string that recommends how this policy
   should be used. The attribute definition is as follows:

     NAME             policyRuleUsage
     DESCRIPTION     This attribute is used to provide guidelines on
                      how this policy should be used.
     SYNTAX           DirectoryString
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED

 5.4.10. The Attribute policyRulePriority

   This attribute provides a positive integer for prioritizing policy
   rules relative to each other.  For policy rules that have this
   attribute, smaller integer values indicate higher priority.  Since
   one purpose of this attribute is to allow specific, ad hoc policy
   rules to temporarily override established policy rules, an instance
   that has this attribute set has a higher priority than all instances
   that lack it.

   Prioritization among policy rules provides a simple and efficient
   mechanism for resolving policy conflicts.

   The attribute definition is as follows:

     NAME             policyRulePriority
     DESCRIPTION     A positive integer for prioritizing this
                      policyRule relative to other policyRules.  A
                      smaller value indicates a higher priority.
     SYNTAX           INTEGER


 Strassner, et. al.      Expires: August 8, 1999               [Page 22]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


     OID              <to be assigned>
     EQUALITY        integerMatch
     SINGLE-VALUED
     DEFAULT VALUE   0

 5.4.11. The Attribute policyRuleMandatory

   This attribute indicates whether evaluation (and possibly action
   execution) of a policyRule is mandatory or not.  Its concept is
   similar to the ability to mark packets for delivery or possible
   discard, based on network traffic and device load.

   The evaulation of a policyRule MUST be attempted if the
   policyRuleMandatory attribute value is True.  If the
   policyRuleMandatory attribute value of a policyRule is False, then
   the evaluation of the rule is "best effort" and MAY be ignored.

   The attribute definition is as follows:

     NAME             policyRuleMandatory
     DESCRIPTION     A flag indicating that the evaluation of the
                      policyConditions and execution of policyActions
                      (if the condition list evaluates to True) is
                      required.
     SYNTAX           Boolean
     OID              <to be assigned>
     EQUALITY        booleanMatch
     SINGLE-VALUED
     DEFAULT VALUE   TRUE

 5.4.12. The Attribute policyRuleDebugMode

   This attribute indicates that the policyRule should be evaluated, but
   no actions taken.  It serves as a debug vehicle when attempting to
   determine what policies would execute in a particular scenario, but
   not to take any actions to change state due to that scenario.

   The attribute definition is as follows:

     NAME             policyRuleDebugMode
     DESCRIPTION     A flag indicating that the evaluation of the
                      policyRule's policyConditions should occur, but
                      the set of actions specified for the rule should
                      not be executed.
     SYNTAX           Boolean
     OID              <to be assigned>
     EQUALITY        booleanMatch
     SINGLE-VALUED
     DEFAULT VALUE   FALSE





 Strassner, et. al.      Expires: August 8, 1999               [Page 23]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 5.4.13. The Attribute policyRuleSequencedActions

   This attrribute gives a policy administrator a way of specifying how
   the ordering of the policy actions associated with this policyRule is
   to be interpreted.  Three values are supported:

   o mandatory (1):   Do the actions in the indicated order, or don't
      do them at all.

   o recommended (2): Do the actions in the indicated order if you can,
      but if you can't do them in this order, do them in another order
      if you can.

   o dontCare (3):    Do them -- I don't care about the order.

   When error / event reporting is addressed for the Policy Framework,
   suitable codes will be defined for reporting that a set of actions
   could not be performed in an order specified as mandatory (and thus
   were not performed at all), that a set of actions could not be
   performed in a recommended order (and moreover could not be performed
   in any order), or that a set of actions could not be performed in a
   recommended order (but were performed in a different order). The
   attribute definition is as follows:

     NAME             policyRuleSequencedActions
     DESCRIPTION     An enumeration indicating how to interpret the
                      action ordering indicated via the
                      policyRuleActionList attribute.
     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY        integerMatch
     SINGLE-VALUED
     DEFAULT VALUE   3

   The defined values for this attribute are mandatory(1),
   recommended(2), and dontCare(3).

 5.5. The Class policyValidityPeriodCondition

   This class provides a means of representing the time periods during
   which a policy rule is valid, i.e., active.  At all times that fall
   outside these time periods, the policy rule has no effect.  A policy
   rule is treated as valid at all times if it does not specify a
   policyValidityPeriodCondition.

   PolicyValidityPeriodCondition is defined as a subclass of
   policyCondition.  This is to allow the inclusion of time-based
   criteria in the AND/OR condition definitions for a policyRule.

   Instances of this class may have up to five attributes identifying
   time periods at different levels.  The values of all the attributes
   present in an instance are ANDed together to determine the validity


 Strassner, et. al.      Expires: August 8, 1999               [Page 24]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   period(s) for the instance.  For example, an instance with an overall
   validity range of January 1, 1999 through December 31, 1999; a month
   mask of "001100000000" (March and April); a day-of-the-week mask of
   "0000100" (Fridays); and a time of day range of 8 AM through 4 PM
   would represent the following validity periods:

       Friday, March  5, 1999, from 8 AM through 4 PM;
       Friday, March 12, 1999, from 8 AM through 4 PM;
       Friday, March 19, 1999, from 8 AM through 4 PM;
       Friday, March 26, 1999, from 8 AM through 4 PM;
       Friday, April  2, 1999, from 8 AM through 4 PM;
       Friday, April  9, 1999, from 8 AM through 4 PM;
       Friday, April 16, 1999, from 8 AM through 4 PM;
       Friday, April 23, 1999, from 8 AM through 4 PM;
       Friday, April 30, 1999, from 8 AM through 4 PM.

   Attributes not present in an instance of
   policyValidityPeriodCondition are implicitly treated as having their
   value "always enabled". Thus, in the example above, the day-of-the-
   month mask is not present, and so the validity period for the
   instance implicitly includes a day-of-the-month mask containing 31
   1's.  If we apply this "missing attribute" rule to its fullest, we
   see that there is a second way to indicate that a policy rule is
   always enabled: have it point to an instance of
   policyValidityPeriodCondition whose only attributes are its naming
   attributes.

   The class definition is as follows.  Note that instances of this
   class are named with the attributes cn and policyConditionName that
   they inherit from policyCondition.

     NAME             policyValidityPeriodCondition
     DESCRIPTION     A class that provides the capability of enabling /
                      disabling a policy rule according to a pre-
                      determined schedule.
     DERIVED FROM    policyCondition
     TYPE             structural
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  policyRule
     OID              <to be assigned>
     MUST
     MAY              pvpConditionTime pvpConditionMonthOfYearMask
                      pvpConditionDayOfMonthMask
                      pvpConditionDayOfWeekMask
                      pvpConditionTimeOfDayMask pvpConditionTimeZone

 5.5.1. The Attribute pvpConditionTime

   This attribute identifies an overall range of calendar dates and
   times over which a policy rule is valid.  It is formatted as a string
   consisting of a start date and time, then a colon (':'), and followed
   by an end date and time.  The first date indicates the beginning of


 Strassner, et. al.      Expires: August 8, 1999               [Page 25]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   the range, while the second date indicates the end.  Thus the second
   date and time must be later than the first.  Dates are expressed as
   substrings of the form "yyyymmddhhmmss". For example:

     19990101080000:19990131120000

         January 1, 1999, 8 AM through January 31, 1999, noon

   The attribute definition is as follows:

     NAME             pvpConditionTime
     DESCRIPTION     The range of calendar dates on which a policy rule
                      is valid.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           yyyymmddhhmmss:yyyymmddhhmmss

 5.5.2. The Attribute pvpConditionMonthOfYearMask

   The purpose of this attribute is to refine the definition of the
   valid time period that is defined by the pvpConditionTime attribute
   by explicitly specifying which months the policy is valid for. These
   attributes work together, with the pvpConditionTime used to specify
   the overall time period that the policy is valid for, and the
   pvpConditionMonthOfYearMask used to pick out which months of that
   time period the policy is valid for.

   This attribute is formatted as a string containing 12 ASCII '0's and
   '1's, where the '1's identify the months (beginning with January) in
   which the policy rule is valid.  The value "000010010000", for
   example, indicates that a policy rule is valid only in the months May
   and August.

   If this attribute is omitted, then the policy assumes that it is
   valid for all twelve months. The attribute definition is as follows:

     NAME             pvpConditionMonthOfYearMask
     DESCRIPTION     A mask identifying the months of the year in which
                      a policy rule is valid.
     SYNTAX           Printable String
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           A string of 12 ASCII '0's and '1's.

 5.5.3. The Attribute pvpConditionDayOfMonthMask

   The purpose of this attribute is to refine the definition of the
   valid time period that is defined by the pvpConditionTime attribute
   by explicitly specifying which days of the month the policy is valid


 Strassner, et. al.      Expires: August 8, 1999               [Page 26]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   for. These attributes work together, with the pvpConditionTime used
   to specify the overall time period that the policy is valid for, and
   the pvpConditionDayOfMonthMask used to pick out which days of the
   month that time period the policy is valid for.

   This attribute is formatted as a string containing 31 ASCII '0's and
   '1's, where the '1's identify the days of the month (beginning with
   day 1 and going up through day 31) on which the policy rule is valid.
   The value "1110000000000000000000000000000", for example, indicates
   that a policy rule is valid only on the first three days of each
   month.  For months with fewer than 31 days, the digits corresponding
   to days that the months do not have are ignored. The attribute
   definition is as follows:

     NAME             pvpConditionDayOfMonthMask
     DESCRIPTION     A mask identifying the days of the month on which
                      a policy rule is valid.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           A string of 31 ASCII '0's and '1's.

 5.5.4. The Attribute pvpConditionDayOfWeekMask

   The purpose of this attribute is to refine the definition of the
   valid time period that is defined by the pvpConditionTime attribute
   by explicitly specifying which days of the week the policy is valid
   for. These attributes work together, with the pvpConditionTime used
   to specify the overall time period that the policy is valid for, and
   the pvpConditionDayOfWeekMask used to pick out which days of the week
   of that time period the policy is valid for.

   This attribute is formatted as a string containing 7 ASCII '0's and
   '1's, where the '1's identify the days of the week (beginning with
   Monday and going up through Sunday) on which the policy rule is
   valid. The value "1111100", for example, indicates that a policy rule
   is valid Monday through Friday.

   The attribute definition is as follows:

     NAME             pvpConditionDayOfWeekMask
     DESCRIPTION     A mask identifying the days of the week on which a
                      policy rule is valid.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           A string of 7 ASCII '0's and '1's.





 Strassner, et. al.      Expires: August 8, 1999               [Page 27]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 5.5.5. The Attribute pvpConditionTimeOfDayMask

   The purpose of this attribute is to refine the definition of the
   valid time period that is defined by the pvpConditionTime attribute
   by explicitly specifying a range of times in a day the policy is
   valid for. These attributes work together, with the pvpConditionTime
   used to specify the overall time period that the policy is valid for,
   and the pvpConditionTimeOfDayMask used to pick out which range of
   time periods in a given day of the week of that time period the
   policy is valid for.

   This attribute is formatted as a string containing two times,
   separated by a colon (':').  The first time indicates the beginning
   of the range, while the second time indicates the end.  Times are
   expressed as substrings of the form "hhmmss".

   The second substring always identifies a later time than the first
   substring.  To allow for ranges that span midnight, however, the
   value of the second string may be smaller than the value of the first
   substring.  Thus "080000:210000" identifies the range from 8 AM until
   9 PM, while "210000:080000" identifies the range from 9 PM until 8 AM
   of the following day.

   When a range spans midnight, it by definition includes parts of two
   successive days.  When one of these days is also selected by either
   the policyValidityMonthMask, policyValidityDayOfMonthMask, and/or
   policyValidityDayOfWeekMask, but the other day is not, then the
   policy is active only during the portion of the range that falls on
   the selected day.  For example, if the range extends from 9 PM until
   8 AM, and the day of week mask selects Monday and Tuesday, then the
   policy is active during the following three intervals:

       From midnight Sunday until 8 AM Monday; From 9 PM Monday until 8
   AM
       Tuesday; From 9 PM Tuesday until 11:59:59 Tuesday.

   The attribute definition is as follows:

     NAME             pvpConditionTimeOfDayMask
     DESCRIPTION     The range of times at which a policy rule is
                      valid. If the second time is earlier than the
                      first, then the interval spans midnight.
     SYNTAX           Printable String
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           hhmmss:hhmmss[:<UTC offset>]







 Strassner, et. al.      Expires: August 8, 1999               [Page 28]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 5.5.6. The Attribute pvpConditionTimeZone

   This attribute is used to explicitly define a time zone for use by
   the pvpConditionTime and the various Mask attributes. If this
   attribute is NULL, then local time is assumed.

   This attribute specifies time in UTC, using an offset indicator. The
   UTC offset indicator is either a 'Z', indicating UTC, or a substring
   of the following form:

     '+' or '-'     direction from UTC:  '+' = east, '-' = west = plus:
     hh             hours from UTC (00..13)
     mm             minutes from UTC (00..59)

   The attribute definition is as follows:

     NAME             pvpConditionTimeZone
     DESCRIPTION     The definition of the time zone for use by the
                      PolicyValidityCOndition.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY        caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           either 'Z' (UTC) or {'+' | '-'}'hhmm'

 5.6. The Class policyCondition

   The purpose of a policy condition is to determine whether or not the
   set of actions (contained in the policyRule that the condition
   applies to) should be executed or not. For the purposes of the Core
   Policy Framework, all that matters about an individual
   policyCondition is that it evaluate to TRUE or FALSE.  (The
   individual policyConditions associated with a policyRule are combined
   to form a compound expression in either DNF or CNF, but this is
   accomplished via the groupNumber component of the
   policyRuleConditionList string and by the policyRuleConditionListType
   attribute, both of which are discussed above.)  A logical structure
   WITHIN an individual policyCondition may also be introduced, but this
   would have to be done in a suclass of policyCondition.















 Strassner, et. al.      Expires: August 8, 1999               [Page 29]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   +---------------------------------------------------------------+
   |                    Policy Conditions in DNF                   |
   | +-------------------------+         +-----------------------+ |
   | |       AND list          |         |      AND list         | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  policyCondition  |  |         |  | policyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  policyCondition  |  |   ...   |  | policyCondition |  | |
   | |  +-------------------+  |   ORed  |  +-----------------+  | |
   | |          ...            |         |         ...           | |
   | |         ANDed           |         |        ANDed          | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  policyCondition  |  |         |  | policyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | +-------------------------+         +-----------------------+ |
   +---------------------------------------------------------------+

   Figure 4.    Overview of Policy Conditions in DNF

   This figure illustrates that when policy conditions are in DNF, there
   are one or more sets of conditions that are ANDed together to form
   AND lists.  An AND list evaluates to TRUE if and only if all of its
   constituent conditions evaluate to TRUE.  The overall condition then
   evaluates to TRUE if and only if at least one of its constituent AND
   lists evaluates to TRUE.

   +---------------------------------------------------------------+
   |                    Policy Conditions in CNF                   |
   | +-------------------------+         +-----------------------+ |
   | |        OR list          |         |       OR list         | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  policyCondition  |  |         |  | policyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  policyCondition  |  |   ...   |  | policyCondition |  | |
   | |  +-------------------+  |  ANDed  |  +-----------------+  | |
   | |          ...            |         |         ...           | |
   | |         ORed            |         |         ORed          | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | |  |  policyCondition  |  |         |  | policyCondition |  | |
   | |  +-------------------+  |         |  +-----------------+  | |
   | +-------------------------+         +-----------------------+ |
   +---------------------------------------------------------------+

   Figure 5.    Overview of Policy Conditions in CNF

   In this figure the policy conditions are in CNF.  Consequently, there
   are one or more OR lists, each of which evaluates to TRUE if and only
   if at least one of its constituent conditions evaluates to TRUE.  The
   overall condition then evaluates to TRUE if and only if ALL of its



 Strassner, et. al.      Expires: August 8, 1999               [Page 30]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   constituent OR lists evaluate to TRUE.  The class definition is as
   follows:

     NAME             policyCondition
     DESCRIPTION     A class representing a condition to be evaluated
                      in conjunction with a policy rule.
     DERIVED FROM    top
     TYPE             structural
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  policyRule
     OID              <to be assigned>
     MUST             cn PolicyConditionName
     MAY

 5.6.1. The Attribute cn

   This is the exact same definition as in Section 5.2.1. It is included
   in this class for the reasons enumerated there.

 5.6.2. The Attribute policyConditionName

   This attribute provides a user-friendly name for a policy condition.
   The attribute definition is as follows:

     NAME             policyConditionName
     DESCRIPTION     The user-friendly name of this policy condition.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY        caseExactIA5Match
     SINGLE-VALUED

 5.7. The Class vendorPolicyCondition

   The purpose of this class is to provide a general escape mechanism
   for representing policy conditions that have not been modeled with
   specific attributes. Instead, the two attributes policyConstraintData
   and policyConstraintEncoding are used to define the content and
   format of the condition, as explained below.

   As its name suggests, this class is intended for vendor-specific
   extensions to the Core Policy Schema.  Standardized extensions are
   not expected to use this class.

   The class definition is as follows:

     NAME             vendorPolicyCondition
     DESCRIPTION     A class that defines a registered means to
                      describe a policy condition.
     DERIVED FROM    policyCondition
     TYPE             structural
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  policyRule


 Strassner, et. al.      Expires: August 8, 1999               [Page 31]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


     OID              <to be assigned>
     MUST             vendorPolicyConditionConstraint
                      vendorPolicyConditionEncoding
     MAY

 5.7.1. The Attribute vendorPolicyConditionConstraint

   This attribute provides a general escape mechanism for representing
   policy conditions that have not been modeled with specific
   attributes.  The format of the OctetString is left unspecified in
   this definition.  It is determined by the OID value stored in the
   attribute vendorPolicyConditionEncoding.  Since
   vendorPolicyConditionEncoding is single-valued, all the values of
   vendorPolicyConditionData share the same format and semantics.

   A policy decision point can readily determine whether it supports the
   values stored in an instance of vendorPolicyConditionData by checking
   the OID value from vendorPolicyConditionEncoding against the set of
   OIDs it recognizes.  The action for the policy decision point to take
   in case it does not recognize the format of this data could itself be
   modeled as a policy rule, governing the behavior of the policy
   decision point.

   The attribute definition is as follows:

     NAME             vendorPolicyConditionConstraint
     DESCRIPTION     Escape mechanism for representing constraints that
                      have not been modeled as specific attributes. The
                      format of the values is identified by the OID
                      stored in the attribute
                      vendorPolicyConditionEncoding.
     SYNTAX           OctetString
     OID              <to be assigned>
     EQUALITY        octetStringMatch
     MULTI-VALUED

 5.7.2. The Attribute vendorPolicyConditionEncoding

   This attribute identifies the encoding and semantics of the values of
   vendorPolicyConditionConstraint in this instance.  The value of this
   attribute is a single OID.

   The attribute definition is as follows:

     NAME             vendorPolicyConditionEncoding
     DESCRIPTION     An OID identifying the format and semantics for
                      this instance's vendorPolicyConditionConstraint
                      attribute.
     SYNTAX           OID
     OID              <to be assigned>
     EQUALITY        objectIdentifierMatch
     SINGLE-VALUED


 Strassner, et. al.      Expires: August 8, 1999               [Page 32]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999



 5.8. The Class policyAction

   The purpose of a policy action is to execute one or more operations
   that will affect network traffic and/or systems, devices, etc. in
   order to achieve a desired policy state. This (new) policy state
   provides one or more (new) behaviors. A policy action ordinarily
   changes the configuration of one or more elements.

   A policyRule contains one or more policy actions. Unlike a condition,
   however, only one list of policy actions is contained in a
   PolicyRule. A policy administrator can assign an order to the actions
   associated with a policyRule, complete with an indication of whether
   the indicated order is mandatory, recommended, or of no significance.

   The actions associated with a PolicyRule are executed if and only if
   the overall condition(s) of the PolicyRule evaluates to TRUE.

   The class definition is as follows:

     NAME             policyAction
     DESCRIPTION     A class representing an action to be performed as
                      a result of a policy rule.
     DERIVED FROM    top
     TYPE             structural
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  policyRule
     OID              <to be assigned>
     MUST             cn PolicyActionName
     MAY

 5.8.1. The Attribute cn

   This is the exact same definition as in Section 5.2.1. It is included
   in this class for the reasons enumerated there.

 5.8.2. The Attribute policyActionName

   This attribute provides a user-friendly name for a policy action.

   The attribute definition is as follows:

     NAME             policyActionName
     DESCRIPTION     The user-friendly name of this policy action.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY        caseExactIA5Match
     SINGLE-VALUED






 Strassner, et. al.      Expires: August 8, 1999               [Page 33]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 5.9. The Class vendorPolicyAction

   The purpose of this class is to provide a general escape mechanism
   for representing policy actions that have not been modeled with
   specific attributes. Instead, the two attributes
   vendorPolicyActionData and vendorPolicyActionEncoding are used to
   define the content and format of the condition, as explained below.

   As its name suggests, this class is intended for vendor-specific
   extensions to the Core Policy Schema.  Standardized extensions are
   not expected to use this class.

   The class definition is as follows:

     NAME             vendorPolicyAction
     DESCRIPTION     A class that defines a registered means to
                      describe a policy action.
     DERIVED FROM    policyAction
     TYPE             structural
     AUXILIARY CLASSES   none
     POSSIBLE SUPERIORS  policyRule
     OID              <to be assigned>
     MUST             vendorPolicyActionData vendorPolicyActionEncoding
     MAY

 5.9.1. The Attribute vendorPolicyActionData

   This attribute provides a general escape mechanism for representing
   policy actions that have not been modeled with specific attributes.
   The format of the OctetString is left unspecified in this definition.
   It is determined by the OID value stored in the attribute
   vendorPolicyActionEncoding.  Since vendorPolicyActionEncoding is
   single-valued, all the values of vendorPolicyActionData share the
   same format and semantics.

   A policy decision point can readily determine whether it supports the
   values stored in an instance of vendorPolicyActionData, by checking
   the OID value from vendorPolicyActionEncoding against the set of OIDs
   it recognizes. The action for the policy decision point to take in
   case it does not recognize the format of this data could itself be
   modeled as a policy rule, governing the behavior of the policy
   decision point.

   The attribute definition is as follows:

     NAME             vendorPolicyActionData
     DESCRIPTION     Escape mechanism for representing actions that
                      have not been modeled as specific attributes. The
     FORMAT            of the values is identified by the OID stored in
                      the attribute vendorPolicyActionEncoding.
     SYNTAX           OctetString
     OID              <to be assigned>


 Strassner, et. al.      Expires: August 8, 1999               [Page 34]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


     EQUALITY        octetStringMatch
     MULTI-VALUED

 5.9.2. The Attribute vendorPolicyActionEncoding

   This attribute identifies the encoding and semantics of the values of
   vendorPolicyActionData in this instance.  The value of this attribute
   is a single OID.

   The attribute definition is as follows:

     NAME             vendorPolicyActionEncoding
     DESCRIPTION     An OID identifying the format and semantics for
                      this instance's vendorPolicyActionData attribute.
     SYNTAX           OID
     OID              <to be assigned>
     EQUALITY        objectIdentifierMatch
     SINGLE-VALUED


 6. Extending the Core Schema

   There are three fundamental ways to extend the core schema. These are
   detailed in sections 6.1 through 6.3 below. A guideline for using the
   policyValidityPeriod class is discussed in Section 6.4.  Each of
   these methods may be used separately or in conjunction with other
   methods.

 6.1. Subclassing policyCondition and policyAction

   The simplest way of extending the core schema is to use the first
   four classes as they are, and simply subclass policyCondition and
   policyAction.  An instance of policyRule ties everything together,
   with its very simple, invariant semantics:

       If the policyRule is active, then evaluate, possibly in a
       specified order, all conditions pointed to by
       policyConditionList.  If all conditions evaluate to TRUE, then
       perform, possibly in a specified order, all actions pointed to by
       policyActionList.

   With this approach a new schema specifies the conditions it needs in
   subclasses of policyCondition (or, better still, reuses conditions
   that have already been specified in subclasses of policyCondition),
   and it specifies (or reuses) the actions it needs in subclasses of
   policyAction.

   PolicyRules are used to aggregate policy conditions and actions, and
   policyGroups are used to aggregate policyRules. Of course, the
   policyRuleContainmentAuxClass and policyValidityPeriodCondition
   classes can still be used as previously described. Note that the
   subclassing of policyCondition and policyAction can also be used in


 Strassner, et. al.      Expires: August 8, 1999               [Page 35]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   combination with the other methods (discussed below) to extend the
   schema.

 6.2. Subclassing policyRule

   There are two possible ways to subclass policyRule, as described
   below.

 6.2.1. Refining the semantics of policyRule

   This approach refines the structural and possibly behavioral
   semantics of what it means to be a policy rule. For example,
   additional attributes and relationships could be defined in a
   subclass of policyRule. These attributes and relationships could
   provide extra meaning for how to interpret the set of conditions and
   actions that a policyRule aggregates.

   This method can be used in a stand-alone fashion by keeping the
   semantics of policyCondition and policyAction as specified and adding
   semantics to policyRule. These policyRule semantics can explicitly
   specify policyConditions and/or policyActions, or dictate how
   policyConditions and policyActions are used and interpreted.
   Finally, these methods can be used with the other methods discussed
   in this subsection to extend the schema.

 6.2.2. Optimizing the computation of a policyRule

   All preceding mechanisms for extending the core schema will work in
   all cases, but they come at a price: in order to fully understand a
   policy rule, a client must retrieve at least three objects: a policy
   rule, at least one policy condition, and at least one policy action.
   A future version of this specification may define how to optimize the
   evaluation of a policy rule so as to reduce the number of classes
   that must be instantiated to define a policy.

 6.3. Using the Vendor Policy Encoding Attributes

   As discussed in 5.7, "The Class vendorPolicyCondition", the
   attributes vendorPolicyConditionConstraint and
   vendorPolicyConditionEncoding are included in the
   vendorPolicyCondition to provide an escape mechanism for representing
   "exceptional" policy conditions.  The attributes
   vendorPolicyActionData and vendorPolicyActionEncoding of the
   vendorPolicyAction class play the same role with respect to actions.
   This enables interoperability between different vendors.

   For example, imagine a network comprised of access devices from
   vendor A, edge and core devices from vendor B, and a policy server
   from vendor C. It is desirable for the policy server to be able to
   configure and manage all of the devices from vendors A and B.
   Unfortunately, these devices will in general have little in common
   (e.g., different mechanisms, different ways for controlling those


 Strassner, et. al.      Expires: August 8, 1999               [Page 36]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   mechanisms, different operating systems, different commands, and so
   forth). The escape conditions provide a way for vendor-specific
   commands to be encoded as OctetStrings so that devices from different
   vendors can be commonly managed by a single policy server.

 6.4. Using Time Validity Periods

   Time validity periods are defined as a subclass of policyCondition,
   called policyValidityPeriodCondition.  This is to allow their
   inclusion in the AND/OR condition definitions for a policyRule.  Care
   should be taken to not subclass policyValidityPeriodCondition to add
   domain-specific condition properties.  For example, it would be
   incorrect to add IPSec- or QoS-specific condition properties to the
   policyValidityPeriodCondition class, just because IPSec or QoS
   includes time in its condition definition. The correct subclassing
   would be to create IPSec or QoS-specific subclasses of
   policyCondition and then combine instances of these domain-specific
   condition classes with the validity period criteria. This is
   accomplished using the AND/OR aggregation capabilities for
   policyConditions in policyRules.


 7. Security Considerations

   Security and denial of service considerations are not explicitly
   considered in this memo, as they are appropriate for the underlying
   policy architecture. However, the policy architecture must be secure
   as far as the following aspects are concerned. First, the mechanisms
   proposed under the framework must minimize theft and denial of
   service threats. Second, it must be ensured that the entities (such
   as PEPs and PDPs) involved in policy control can verify each other's
   identity and establish necessary trust before communicating. The
   schema defined in this document MUST not compromise either of these
   goals.


 8. Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   intellectual property or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; neither does it represent that it
   has made any effort to identify any such rights.  Information on the
   IETF's procedures with respect to rights in standards-track and
   standards-related documentation can be found in BCP-11.

   Copies of claims of rights made available for publication and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF Secretariat.


 Strassner, et. al.      Expires: August 8, 1999               [Page 37]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights which may cover technology that may be required to practice
   this standard.  Please address the information to the IETF Executive
   Director.


 9. Acknowledgments

   This document is closely aligned with the work being done in the
   Desktop Management Task Force (DMTF) Service Level Agreements and
   Networks working groups.  As noted, the core schema described here
   was initially defined in references [2] and [3]. We would especially
   like to thank Bob Moore, Raju Rajan, Sanjay Kamat, Andrea Westerinen,
   Lee Rafalow, Raj Yavatkar, Glenn Waters, David Black, Michael
   Richardson, Mark Stevens, and David Jones for their helpful comments.


 10. References

 [1]  J. Strassner and E. Ellesson, "Terminology for describing network
      policy and services", draft-strassner-policy-terms-00.txt, August
      1998.

 [2]  Bhattacharya, P., and R. Adams, W. Dixon, R. Pereira, R. Rajan,
      "An LDAP Schema for Configuration and Administration of IPSec
      based Virtual Private Networks (VPNs)", Internet-Draft work in
      progress, October 1998

 [3]  Rajan, R., and J. C. Martin, S. Kamat, M. See, R. Chaudhury, D.
      Verma, G. Powers, R. Yavatkar, "Schema for Differentiated Services
      and Integrated Services in Networks", Internet-Draft work in
      progress, October 1998

 [4]  J. Strassner and S. Judd, "Directory-Enabled Networks", version
      3.0c5 (August 1998).

 [5]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
      Levels", BCP 14, RFC 2119, March 1997.

 [6]  Hovey, R., and S. Bradner, "The Organizations Involved in the IETF
      Standards Process", BCP 11, RFC 2028, October 1996.

 [7]  Wahl, M., and S. Kille, T. Howes, "Lightweight Directory Access
      Protocol (v3):  UTF-8 String Representation of Distinguished
      Names", RFC 2253, December 1997.

 [8]  J. Strassner, policy architecture BOF presentation, 42nd IETF
      Meeting, Chicago, Illinois, October, 1998





 Strassner, et. al.      Expires: August 8, 1999               [Page 38]

 Internet Draft    draft-ietf-policy-core-schema-01.txt    February 1999


 11. Authors' Addresses

   John Strassner
       Cisco Systems, Bldg 1
       170 West Tasman Drive
       San Jose, CA 95134
       Phone:   +1 408-527-1069
       Fax:     +1 408-527-1722
       E-mail:  johns@cisco.com

   Ed Ellesson
      IBM Corporation, JDGA/501
      4205 S. Miami Blvd.
      Research Triangle Park, NC 27709
      Phone:   +1 919-254-4115
      Fax:     +1 919-254-6243
      E-mail:  ellesson@raleigh.ibm.com

 12. Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


 13. Appendix A - Guidelines for Construction of DNs

   To Be Provided




 Strassner, et. al.      Expires: August 8, 1999               [Page 39]
