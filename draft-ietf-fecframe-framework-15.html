<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Forward Error Correction (FEC) Framework</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Definitions and Abbreviations">
<link href="#rfc.section.3" rel="Chapter" title="3 Architecture Overview">
<link href="#rfc.section.4" rel="Chapter" title="4 Procedural Overview">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 General">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Sender Operation">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Receiver Operation">
<link href="#rfc.section.5" rel="Chapter" title="5 Protocol Specification">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 General">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Structure of the Source Block">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Packet Format for FEC Source Packets">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Generic Explicit Source FEC Payload ID">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Packet Format for FEC Repair Packets">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Packet Format for FEC Repair Packets over RTP">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 FEC Framework Configuration Information">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 FEC Scheme Requirements">
<link href="#rfc.section.6" rel="Chapter" title="6 Feedback">
<link href="#rfc.section.7" rel="Chapter" title="7 Transport Protocols">
<link href="#rfc.section.8" rel="Chapter" title="8 Congestion Control">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Motivation">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Normative Requirements">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Problem Statement">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Attacks Against the Data Flows">
<link href="#rfc.section.9.2.1" rel="Chapter" title="9.2.1 Access to Confidential Content">
<link href="#rfc.section.9.2.2" rel="Chapter" title="9.2.2 Content Corruption">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Attacks Against the FEC Parameters">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 When Several Source Flows are to be Protected Together">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Baseline Secure FEC Framework Operation">
<link href="#rfc.section.10" rel="Chapter" title="10 Operations and Management Considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 What are the Key Aspects to Consider?">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Operational and Management Recommendations">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative references">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative references">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document describes a framework for using Forward Error Correction (FEC) codes with applications in public and private IP networks to provide protection against packet loss. The framework supports applying FEC to arbitrary packet flows over unreliable transport and is primarily intended for real-time, or streaming, media.  This framework can be used to define Content Delivery Protocols that provide FEC for streaming media delivery or other packet flows. Content Delivery Protocols defined using this framework can support any FEC scheme (and associated FEC codes) which is compliant with various requirements defined in this document. Thus, Content Delivery Protocols can be defined which are not specific to a particular FEC scheme, and FEC schemes can be defined which are not specific to a particular Content Delivery Protocol." />
  <meta name="description" content="This document describes a framework for using Forward Error Correction (FEC) codes with applications in public and private IP networks to provide protection against packet loss. The framework supports applying FEC to arbitrary packet flows over unreliable transport and is primarily intended for real-time, or streaming, media.  This framework can be used to define Content Delivery Protocols that provide FEC for streaming media delivery or other packet flows. Content Delivery Protocols defined using this framework can support any FEC scheme (and associated FEC codes) which is compliant with various requirements defined in this document. Thus, Content Delivery Protocols can be defined which are not specific to a particular FEC scheme, and FEC schemes can be defined which are not specific to a particular Content Delivery Protocol." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">FEC Framework</td>
<td class="right">M. Watson</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Netflix, Inc.</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">A. Begen</td>
</tr>
<tr>
<td class="left">Expires: December 11, 2011</td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">V. Roca</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">INRIA</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 09, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Forward Error Correction (FEC) Framework<br />
  <span class="filename">draft-ietf-fecframe-framework-15</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes a framework for using Forward Error Correction (FEC) codes with applications in public and private IP networks to provide protection against packet loss. The framework supports applying FEC to arbitrary packet flows over unreliable transport and is primarily intended for real-time, or streaming, media.  This framework can be used to define Content Delivery Protocols that provide FEC for streaming media delivery or other packet flows. Content Delivery Protocols defined using this framework can support any FEC scheme (and associated FEC codes) which is compliant with various requirements defined in this document. Thus, Content Delivery Protocols can be defined which are not specific to a particular FEC scheme, and FEC schemes can be defined which are not specific to a particular Content Delivery Protocol.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 11, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Definitions and Abbreviations</a>
</li>
<li>3.   <a href="#rfc.section.3">Architecture Overview</a>
</li>
<li>4.   <a href="#rfc.section.4">Procedural Overview</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">General</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Sender Operation</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Receiver Operation</a>
</li>
<li>5.   <a href="#rfc.section.5">Protocol Specification</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">General</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Structure of the Source Block</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Packet Format for FEC Source Packets</a>
</li>
<li>5.3.1.   <a href="#rfc.section.5.3.1">Generic Explicit Source FEC Payload ID</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Packet Format for FEC Repair Packets</a>
</li>
<li>5.4.1.   <a href="#rfc.section.5.4.1">Packet Format for FEC Repair Packets over RTP</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">FEC Framework Configuration Information</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">FEC Scheme Requirements</a>
</li>
<li>6.   <a href="#rfc.section.6">Feedback</a>
</li>
<li>7.   <a href="#rfc.section.7">Transport Protocols</a>
</li>
<li>8.   <a href="#rfc.section.8">Congestion Control</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Motivation</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Normative Requirements</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">Problem Statement</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Attacks Against the Data Flows</a>
</li>
<li>9.2.1.   <a href="#rfc.section.9.2.1">Access to Confidential Content</a>
</li>
<li>9.2.2.   <a href="#rfc.section.9.2.2">Content Corruption</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Attacks Against the FEC Parameters</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">When Several Source Flows are to be Protected Together</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Baseline Secure FEC Framework Operation</a>
</li>
<li>10.   <a href="#rfc.section.10">Operations and Management Considerations</a>
</li>
<li>10.1.   <a href="#rfc.section.10.1">What are the Key Aspects to Consider?</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Operational and Management Recommendations</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Acknowledgments</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<li>13.1.   <a href="#rfc.references.1">Normative references</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative references</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">Many applications have a requirement to transport a continuous stream of packetized data from a source (sender) to one or more destinations (receivers) over networks which do not provide guaranteed packet delivery. Primary examples are real-time, or streaming, media applications such as broadcast, multicast or on-demand audio, video or multimedia.</p>
<p id="rfc.section.1.p.2">Forward Error Correction (FEC) is a well-known technique for improving reliability of packet transmission over networks which do not provide guaranteed packet delivery, especially in multicast and broadcast applications. The FEC Building Block defined in <a href="#RFC5052">[RFC5052]</a> provides a framework for definition of Content Delivery Protocols (CDPs) for object delivery (including, primarily, file delivery) which make use of separately defined FEC schemes. Any CDP defined according to the requirements of the FEC Building Block can then easily be used with any FEC scheme which is also defined according to the requirements of the FEC Building Block.</p>
<p id="rfc.section.1.p.3">Note that the term "Forward Erasure Correction" is sometimes used, erasures being a type of error in which data is lost and this loss can be detected, rather than being received in corrupted form. The focus of this document is strictly on erasures and, the term "Forward Error Correction" is more widely used.</p>
<p id="rfc.section.1.p.4">This document defines a framework for the definition of CDPs which provide for FEC protection for arbitrary packet flows over unreliable transports such as UDP. As such, this document complements the FEC Building Block of <a href="#RFC5052">[RFC5052]</a>, by providing for the case of arbitrary packet flows over unreliable transport, the same kind of framework as that document provides for object delivery. This document does not define a complete CDP, but rather defines only those aspects that are expected to be common to all CDPs based on this framework.</p>
<p id="rfc.section.1.p.5">This framework does not define how the flows to be protected are determined, nor how the details of the protected flows and the FEC streams which protect them are communicated from sender to receiver. It is expected that any complete CDP specification which makes use of this framework will address these signaling requirements. However, this document does specify the information which is required by the FEC Framework at the sender and receiver, e.g., details of the flows to be FEC protected, the flow(s) that will carry the FEC protection data and an opaque container for FEC-Scheme-Specific Information.</p>
<p id="rfc.section.1.p.6">FEC schemes designed for use with this framework must fulfill a number of requirements defined in this document. These requirements are different from those defined in <a href="#RFC5052">[RFC5052]</a> for FEC schemes for object delivery. However, there is a great deal of commonality and FEC schemes defined for object delivery may be easily adapted for use with the framework defined in this document.</p>
<p id="rfc.section.1.p.7">Since the RTP protocol is (often) used over UDP, this framework can be applied to RTP flows as well. FEC repair packets may be sent directly over UDP or RTP. The latter approach has the advantage that RTP instrumentation, based on RTP Control Protocol (RTCP), can be used for the repair flow. Additionally, the post-repair RTCP extended reports <a href="#RFC5725">[RFC5725]</a> may be used to obtain information about the loss rate after FEC recovery.</p>
<p id="rfc.section.1.p.8">The use of RTP for repair flows is defined for each FEC scheme by defining an RTP payload format for that particular FEC scheme (possibly in the same document).</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Definitions and Abbreviations</h1>
<p id="rfc.section.2.p.1">Application Data Unit (ADU): The unit of source data provided as payload to the transport layer.</p>
<p id="rfc.section.2.p.2">ADU Flow: A sequence of ADUs associated with a transport-layer flow identifier (such as the standard 5-tuple {Source IP address, source port, destination IP address, destination port, transport protocol}).</p>
<p id="rfc.section.2.p.3">AL-FEC: Application-layer Forward Error Correction.</p>
<p id="rfc.section.2.p.4">Application Protocol: Control protocol used to establish and control the source flow being protected, e.g., RTSP.</p>
<p id="rfc.section.2.p.5">Content Delivery Protocol (CDP): A complete application protocol specification which, through the use of the framework defined in this document, is able to make use of FEC schemes to provide FEC capabilities.</p>
<p id="rfc.section.2.p.6">FEC Code: An algorithm for encoding data such that the encoded data flow is resilient to data loss. Note that in general FEC codes may also be used to make a data flow resilient to corruption, but that is not considered in this document.</p>
<p id="rfc.section.2.p.7">FEC Framework: A protocol framework for definition of Content Delivery Protocols using FEC, such as the framework defined in this document.</p>
<p id="rfc.section.2.p.8">FEC Framework Configuration Information: Information which controls the operation of the FEC Framework.</p>
<p id="rfc.section.2.p.9">FEC Payload ID: Information which identifies the contents of a packet with respect to the FEC scheme.</p>
<p id="rfc.section.2.p.10">FEC Repair Packet: At a sender (respectively, at a receiver) a payload submitted to (respectively, received from) the transport protocol containing one or more repair symbols along with a Repair FEC Payload ID and possibly an RTP header.</p>
<p id="rfc.section.2.p.11">FEC Scheme: A specification which defines the additional protocol aspects required to use a particular FEC code with the FEC Framework.</p>
<p id="rfc.section.2.p.12">FEC Source Packet: At a sender (respectively, at a receiver) a payload submitted to (respectively, received from) the transport protocol containing an ADU along with an optional Explicit Source FEC Payload ID.</p>
<p id="rfc.section.2.p.13">Protection Amount: The relative increase in data sent due to the use of FEC.</p>
<p id="rfc.section.2.p.14">Repair Flow: The packet flow carrying FEC data.</p>
<p id="rfc.section.2.p.15">Repair FEC Payload ID: An FEC Payload ID specifically for use with repair packets.</p>
<p id="rfc.section.2.p.16">Source Flow: The packet flow to which FEC protection is to be applied. A source flow consists of ADUs.</p>
<p id="rfc.section.2.p.17">Source FEC Payload ID: An FEC Payload ID specifically for use with source packets.</p>
<p id="rfc.section.2.p.18">Source Protocol: A protocol used for the source flow being protected, e.g., RTP.</p>
<p id="rfc.section.2.p.19">Transport Protocol: The protocol used for transport of the source and repair flows, e.g., UDP and DCCP.</p>
<p id="rfc.section.2.p.20">The following definitions are aligned with <a href="#RFC5052">[RFC5052]</a>:</p>
<p id="rfc.section.2.p.21">Code Rate: The ratio between the number of source symbols and the number of encoding symbols. By definition, the code rate is such that 0 &lt; code rate &lt;= 1. A code rate close to 1 indicates that a small number of repair symbols have been produced during the encoding process.</p>
<p id="rfc.section.2.p.22">Encoding Symbol: Unit of data generated by the encoding process. With systematic codes, source symbols are part of the encoding symbols.</p>
<p id="rfc.section.2.p.23">Packet Erasure Channel: A communication path where packets are either dropped (e.g., by a congested router, or because the number of transmission errors exceeds the correction capabilities of the physical-layer codes) or received. When a packet is received, it is assumed that this packet is not corrupted.</p>
<p id="rfc.section.2.p.24">Repair Symbol: Encoding symbol that is not a source symbol.</p>
<p id="rfc.section.2.p.25">Source Block: Group of ADUs which are to be FEC protected as a single block.</p>
<p id="rfc.section.2.p.26">Source Symbol: Unit of data used during the encoding process.</p>
<p id="rfc.section.2.p.27">Systematic Code: FEC code in which the source symbols are part of the encoding symbols.</p>
<p id="rfc.section.2.p.28">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Architecture Overview</h1>
<p id="rfc.section.3.p.1">The FEC Framework is described in terms of an additional layer between the transport layer (e.g., UDP or DCCP) and protocols running over this transport layer. As such, the data path interface between the FEC Framework and both underlying and overlying layers can be thought of as being the same as the standard interface to the transport layer, i.e., the data exchanged consists of datagram payloads each associated with a single ADU flow identified by the standard 5-tuple {Source IP address, source port, destination IP address, destination port, transport protocol}. In the case that RTP is used for the repair flows, the source and repair data can be multiplexed using RTP onto a single UDP flow and needs to be consequently demultiplexed at the receiver.  There are various ways in which this multiplexing can be done, for example as described in <a href="#RFC4588">[RFC4588]</a>.</p>
<p id="rfc.section.3.p.2">It is important to understand that the main purpose of the FEC Framework architecture is to allocate functional responsibilities to separately documented components in such a way that specific instances of the components can be combined in different ways to describe different protocols.</p>
<p id="rfc.section.3.p.3">The FEC Framework makes use of an FEC scheme, in a similar sense to that defined in <a href="#RFC5052">[RFC5052]</a> and uses the terminology of that document. The FEC scheme defines the FEC encoding and decoding, and defines the protocol fields and procedures used to identify packet payload data in the context of the FEC scheme. The interface between the FEC Framework and an FEC scheme, which is described in this document, is a logical one, which exists for specification purposes only. At an encoder, the FEC Framework passes ADUs to the FEC scheme for FEC encoding. The FEC scheme returns repair symbols with their associated Repair FEC Payload IDs, and in some cases Source FEC Payload IDs, depending on the FEC scheme. At a decoder, the FEC Framework passes transport packet payloads (source and repair) to the FEC scheme and the FEC scheme returns additional recovered source packet payloads.</p>
<p id="rfc.section.3.p.4">This document defines certain FEC Framework Configuration Information which MUST be available to both sender and receiver(s). For example, this information includes the specification of the ADU flows which are to be FEC protected, specification of the ADU flow(s) which will carry the FEC protection (repair) data and the relationship(s) between these source and repair flows (i.e., which source flow(s) are protected by each repair flow(s)). The FEC Framework Configuration Information also includes information fields which are specific to the FEC scheme. This information is analogous to the FEC Object Transmission Information defined in <a href="#RFC5052">[RFC5052]</a>.</p>
<p id="rfc.section.3.p.5">The FEC Framework does not define how the FEC Framework Configuration Information for the stream is communicated from sender to receiver. This has to be defined by any CDP specification as described in the following sections.</p>
<p id="rfc.section.3.p.6">In this architecture we assume that the interface to the transport layer supports the concepts of data units (referred to here as Application Data Units (ADUs)) to be transported and identification of ADU flows on which those data units are transported. Since this is an interface internal to the architecture, we do not specify this interface explicitly. We do require that ADU flows which are distinct from the transport layer point of view (for example, distinct UDP flows as identified by the UDP source/destination addresses/ports) are also distinct on the interface between the transport layer and the FEC Framework.</p>
<p id="rfc.section.3.p.7">As noted above, RTP flows are a specific example of ADU flows which might be protected by the FEC Framework. From the FEC Framework point of view, RTP source flows are ADU flows like any other, with the RTP header included within the ADU.</p>
<p id="rfc.section.3.p.8">Depending on the FEC scheme, RTP can also be used as a transport for repair packet flows. In this case an FEC scheme has to define an RTP payload format for the repair data.</p>
<p id="rfc.section.3.p.9">The architecture outlined above is illustrated in the <a href="#architecturefigure">Figure 1</a>. In this architecture, two (optional) RTP instances are shown, for the source and repair data respectively. This is because the use of RTP for the source data is separate from and independent of the use of RTP for the repair data. The appearance of two RTP instances is more natural when one considers that in many FEC codes, the repair payload contains repair data calculated across the RTP headers of the source packets. Thus, a repair packet carried over RTP starts with an RTP header of its own which is followed (after the Repair Payload ID) by repair data containing bytes which protect the source RTP headers (as well as repair data for the source RTP payloads).</p>
<div id="#rfc.figure.1"></div>
<div id="#architecturefigure"></div>
<pre>
  +--------------------------------------------+
  |                 Application                |
  +--------------------------------------------+
                         |
                         |
                         |
+ - - - - - - - - - - - - - - - - - - - - - - - -+   
| +--------------------------------------------+ |
  |            Application Layer               |
| +--------------------------------------------+ |
                         |                |
| + -- -- -- -- -- -- -- -- -- -- --+     |      |
  |            RTP (Optional)       |     |       
| |                                 |     |- Configuration/
  +- -- -- -- -- -- -- -- -- -- -- -+     |  Coordination
|                    |                    |      | 
                     | ADU flows          |
|                    |                    v      |
  +--------------------------------------------+     +------------+
| |      FEC Framework (This document)         |&lt;---&gt;| FEC Scheme |
  +--------------------------------------------+     +------------+
|                |               |               |
          Source |        Repair |
|                |               |               |
  +-- -- -- -- --|-- --+ -- -- -- -- -- + -- --+ 
| | RTP Layer    |     | RTP Processing |      | |
  | (Optional)   |     +-- -- -- |- -- -+      |     
| |        +-- -- -- -- -- -- -- |--+          | |   
  |        |  RTP (De)multiplexing  |          |
| +-- -- -- --- -- -- -- -- -- -- -- -- -- -- -+ | 
                         |
| +--------------------------------------------+ |
  |          Transport Layer (e.g., UDP)       |
| +--------------------------------------------+ |
                         |  
| +--------------------------------------------+ | 
  |                     IP                     |  
| +--------------------------------------------+ |

| Content Delivery Protocol                      |
+ - - - - - - - - - - - - - - -  - - - - - - - - +</pre>
<p></p>
<p id="rfc.section.3.p.11">The content of the transport payload for repair packets is fully defined by the FEC scheme. For a specific FEC scheme, a means MAY be defined for repair data to be carried over RTP, in which case the repair packet payload format starts with the RTP header. This corresponds to defining an RTP payload format for the specific FEC scheme.</p>
<p id="rfc.section.3.p.12">The use of RTP for repair packets is independent of the protocols used for source packets: if RTP is used for source packets, repair packets may or may not use RTP and vice versa (although it is unlikely that there are useful scenarios where non-RTP source flows are protected by RTP repair flows). FEC schemes are expected to recover entire transport payloads for recovered source packets in all cases. For example, if RTP is used for source flows, the FEC scheme is expected to recover the entire UDP payload, including the RTP header.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Procedural Overview</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> General</h1>
<p id="rfc.section.4.1.p.1">The mechanism defined in this document does not place any restrictions on the ADUs which can be protected together, except that the ADU is carried over a supported transport protocol (See <a href="#TransportProtocols">Section 7</a>). The data can be from multiple source flows that are protected jointly. The FEC Framework handles the source flows as a sequence of source blocks each consisting of a set of ADUs, possibly from multiple source flows which are to be protected together. For example, each source block can be constructed from those ADUs related to a particular segment in time of the flow.</p>
<p id="rfc.section.4.1.p.2">At the sender, the FEC Framework passes the payloads for a given block to the FEC scheme for FEC encoding. The FEC scheme performs the FEC encoding operation and returns the following information: </p>

<ul>
<li>Optionally, FEC Payload IDs for each of the source payloads (encoded according to an FEC-Scheme-Specific format).</li>
<li>One or more FEC repair packet payloads.</li>
<li>FEC Payload IDs for each of the repair packet payloads (encoded according to an FEC-Scheme-Specific format).</li>
</ul>
<p id="rfc.section.4.1.p.3">The FEC Framework then performs two operations. First, it appends the Source FEC Payload IDs, if provided, to each of the ADUs, and sends the resulting packets, known as FEC source packets, to the receiver, and second it places the provided FEC repair packet payloads and corresponding Repair FEC Payload IDs appropriately to construct FEC repair packets and send them to the receiver.</p>
<p id="rfc.section.4.1.p.4">This document does not define how the sender determines which ADUs are included in which source blocks or the sending order and timing of FEC source and repair packets. A specific CDP MAY define this mapping or it MAY be left as implementation dependent at the sender. However, a CDP specification MUST define how a receiver determines a minimum length of time that it needs to wait to receive FEC repair packets for any given source block. FEC schemes MAY define limitations on this mapping, such as maximum size of source blocks, but SHOULD NOT attempt to define specific mappings. The sequence of operations at the sender is described in more detail in <a href="#senderoperation">Section 4.2</a>.</p>
<p id="rfc.section.4.1.p.5">At the receiver, original ADUs are recovered by the FEC Framework directly from any FEC source packets received simply by removing the Source FEC Payload ID, if present. The receiver also passes the contents of the received ADUs, plus their FEC Payload IDs to the FEC scheme for possible decoding.</p>
<p id="rfc.section.4.1.p.6">If any ADUs related to a given source block have been lost, then the FEC scheme can perform FEC decoding to recover the missing ADUs (assuming sufficient FEC source and repair packets related to that source block have been received).</p>
<p id="rfc.section.4.1.p.7">Note that the receiver might need to buffer received source packets to allow time for the FEC repair packets to arrive and FEC decoding to be performed before some or all of the received or recovered packets are passed to the application. If such a buffer is not provided, then the application has to be able to deal with the severe re-ordering of packets that can occur. However, such buffering is CDP and/or implementation-specific and is not specified here. The receiver operation is described in more detail in <a href="#receiveroperation">Section 4.3</a>.</p>
<p id="rfc.section.4.1.p.8">The FEC source packets MUST contain information which identifies the source block and the position within the source block (in terms specific to the FEC scheme) occupied by the ADU. This information is known as the Source FEC Payload ID. The FEC scheme is responsible for defining and interpreting this information. This information MAY be encoded into a specific field within the FEC source packet format defined in this specification, called the Explicit Source FEC Payload ID field. The exact contents and format of the Explicit Source FEC Payload ID field are defined by the FEC schemes. Alternatively, the FEC scheme MAY define how the Source FEC Payload ID is derived from other fields within the source packets. This document defines the way that the Explicit Source FEC Payload ID field is appended to source packets to form FEC source packets.</p>
<p id="rfc.section.4.1.p.9">The FEC repair packets MUST contain information which identifies the source block and the relationship between the contained repair payloads and the original source block. This is known as the Repair FEC Payload ID. This information MUST be encoded into a specific field, the Repair FEC Payload ID field, the contents and format of which are defined by the FEC schemes.</p>
<p id="rfc.section.4.1.p.10">The FEC scheme MAY use different FEC Payload ID field formats for source and repair packets.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#senderoperation" id="senderoperation">Sender Operation</a>
</h1>
<p id="rfc.section.4.2.p.1">It is assumed that the sender has constructed or received original data packets for the session. These could be carrying any type of data. The following operations, illustrated in <a href="#senderfigure">Figure 2</a>, for the case of UDP repair flows and <a href="#senderfigurertp">Figure 3</a> for the case of RTP repair flows, describe a possible way to generate compliant source and repair flows: </p>

<ol>
<li>ADUs are provided by the application.</li>
<li>A source block is constructed as specified in <a href="#sourceblock">Section 5.2</a>.</li>
<li>The source block is passed to the FEC scheme for FEC encoding.  The Source FEC Payload ID information of each source packet is determined by the FEC scheme. If required by the FEC scheme the Source FEC Payload ID is encoded into the Explicit Source FEC Payload ID field.</li>
<li>The FEC scheme performs FEC encoding, generating repair packet payloads from a source block and a Repair FEC Payload ID field for each repair payload.</li>
<li>The Explicit Source FEC Payload IDs (if used), Repair FEC Payload IDs and repair packet payloads are provided back from the FEC scheme to the FEC Framework.</li>
<li>The FEC Framework constructs FEC source packets according to <a href="#sourcepackets">Section 5.3</a> and FEC repair packets according to <a href="#repairpackets">Section 5.4</a> using the FEC Payload IDs and repair packet payloads provided by the FEC scheme.</li>
<li>The FEC source and repair packets are sent using normal transport-layer procedures. The port(s) and multicast group(s) to be used for FEC repair packets are defined in the FEC Framework Configuration Information. The FEC source packets are sent using the same ADU flow identification information as would have been used for the original source packets if the FEC Framework were not present (for example, in the UDP case, the UDP source and destination addresses and ports on the IP datagram carrying the source packet will be the same whether or not the FEC Framework is applied).</li>
</ol>
<div id="#rfc.figure.2"></div>
<div id="#senderfigure"></div>
<pre>
+----------------------+
|     Application      |
+----------------------+
           |
           |(1) ADUs
           |
           v 
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |--------------------------&gt;|   FEC Scheme   |
|(2) Construct source  |(3) Source Block           |                |
|    blocks            |                           |(4) FEC Encoding|
|(6) Construct FEC     |&lt;--------------------------|                |
|    source and repair |                           |                |
|    packets           |(5) Explicit Source FEC    |                |
+----------------------+    Payload IDs            +----------------+
           |                Repair FEC Payload IDs
           |                Repair symbols 
           |
           |(7) FEC source and repair packets
           v          
+----------------------+ 
|   Transport Layer    | 
|     (e.g., UDP)      |
+----------------------+  
</pre>
<p></p>
<div id="#rfc.figure.3"></div>
<div id="#senderfigurertp"></div>
<pre>
+----------------------+
|     Application      |
+----------------------+
           |
           |(1) ADUs
           |
           v 
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |--------------------------&gt;|   FEC Scheme   |
|(2) Construct source  |(3) Source Block           |                |
|    blocks            |                           |(4) FEC Encoding|
|(6) Construct FEC     |&lt;--------------------------|                |
|    source packets and|                           |                |
|    repair payloads   |(5) Explicit Source FEC    |                |
+----------------------+    Payload IDs            +----------------+
    |             |         Repair FEC Payload IDs
    |             |         Repair symbols 
    |             |
    |(7) Source   |(7') Repair payloads
    |    packets  |
    |             |
    |      + -- -- -- -- -+
    |      |     RTP      |
    |      +-- -- -- -- --+
    v             v                 
+----------------------+ 
|   Transport Layer    | 
|     (e.g., UDP)      |
+----------------------+  
</pre>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#receiveroperation" id="receiveroperation">Receiver Operation</a>
</h1>
<p id="rfc.section.4.3.p.1">The following describes a possible receiver algorithm, illustrated in <a href="#receiverfigure">Figure 4</a> and <a href="#receiverfigurertp">Figure 5</a> for the case of RTP repair flows, when receiving an FEC source or repair packet: </p>

<ol>
<li>FEC source packets and FEC repair packets are received and passed to the FEC Framework. The type of packet (source or repair) and the source flow to which it belongs (in the case of source packets) is indicated by the ADU flow information which identifies the flow at the transport layer.<br><br>In the special case that RTP is used for repair packets, and source and repair packets are multiplexed onto the same UDP flow, then RTP demultiplexing is required to demultiplex source and repair flows.  However, RTP processing is applied only to the repair packets at this stage; source packets continue to be handled as UDP payloads (i.e., including their RTP headers).</li>
<li>The FEC Framework extracts the Explicit Source FEC Payload ID field (if present) from the source packets and the Repair FEC Payload ID from the repair packets.</li>
<li>The Explicit Source FEC Payload IDs (if present), Repair FEC Payload IDs, FEC source and repair payloads are passed to the FEC scheme.</li>
<li>The FEC scheme uses the received FEC Payload IDs (and derived FEC Source Payload IDs in the case that the Explicit Source FEC Payload ID field is not used) to group source and repair packets into source blocks. If at least one source packet is missing from a source block, and at least one repair packet has been received for the same source block then FEC decoding can be performed in order to recover missing source payloads. The FEC scheme determines whether source packets have been lost and whether enough data for decoding of any or all of the missing source payloads in the source block has been received.</li>
<li>The FEC scheme returns the ADUs to the FEC Framework in the form of source blocks containing received and decoded ADUs and indications of any ADUs which were missing and could not be decoded.</li>
<li>The FEC Framework passes the received and recovered ADUs to the application.</li>
</ol>
<p id="rfc.section.4.3.p.2">The description above defines functionality responsibilities but does not imply a specific set of timing relationships. Source packets which are correctly received and those which are reconstructed MAY be delivered to the application out of order and in a different order from the order of arrival at the receiver. Alternatively, buffering and packet re-ordering MAY be applied to re-order received and reconstructed source packets into the order they were placed into the source block, if that is necessary according to the application.</p>
<div id="#rfc.figure.4"></div>
<div id="#receiverfigure"></div>
<p></p>
<pre>
+----------------------+
|     Application      |
+----------------------+
           ^
           |
           |(6) ADUs
           |
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |&lt;--------------------------|   FEC Scheme   |
|(2)Extract FEC Payload|(5) ADUs                   |                |
|   IDs and pass IDs &amp; |                           |(4) FEC Decoding|
|   payloads to FEC    |--------------------------&gt;|                |
|   scheme             |(3) Explicit Source FEC    |                |
+----------------------+    Payload IDs            +----------------+
           ^                Repair FEC Payload IDs
           |                Source payloads
           |                Repair payloads
           |
           |(1) FEC source and repair packets
           |         
+----------------------+ 
|   Transport Layer    | 
|     (e.g., UDP)      |
+----------------------+
</pre>
<p></p>
<div id="#rfc.figure.5"></div>
<div id="#receiverfigurertp"></div>
<p></p>
<pre>
+----------------------+
|     Application      |
+----------------------+
           ^
           |
           |(6) ADUs
           |
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |&lt;--------------------------|   FEC Scheme   |
|(2)Extract FEC Payload|(5) ADUs                   |                |
|   IDs and pass IDs &amp; |                           |(4) FEC Decoding|
|   payloads to FEC    |--------------------------&gt;|                |
|   scheme             |(3) Explicit Source FEC    |                |
+----------------------+    Payload IDs            +----------------+
    ^             ^         Repair FEC Payload IDs
    |             |         Source payloads
    |             |         Repair payloads
    |             |
    |Source       |Repair payloads
    |packets      |
    |             |
+-- |- -- -- -- -- -- -+
|RTP| | RTP Processing | 
|   | +-- -- -- --|-- -+
| +-- -- -- -- -- |--+ |
| | RTP Demux        | |
+-- -- -- -- -- -- -- -+ 
           ^
           |(1) FEC source and repair packets
           |         
+----------------------+ 
|   Transport Layer    | 
|     (e.g., UDP)      |
+----------------------+
</pre>
<p></p>
<p id="rfc.section.4.3.p.5">Note that the above procedure might result in a situation in which not all ADUs are recovered.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Protocol Specification</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> General</h1>
<p id="rfc.section.5.1.p.1">This section specifies the protocol elements for the FEC Framework.  Three components of the protocol are defined in this document and are described in the following sections: </p>

<ol>
<li>Construction of a source block from ADUs. The FEC code will be applied to this source block to produce the repair payloads.</li>
<li>A format for packets containing source data.</li>
<li>A format for packets containing repair data.</li>
</ol>

<p>The operation of the FEC Framework is governed by certain FEC Framework Configuration Information, which is defined in this section.  A complete protocol specification that uses this framework MUST specify the means to determine and communicate this information between sender and receiver.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#sourceblock" id="sourceblock">Structure of the Source Block</a>
</h1>
<p id="rfc.section.5.2.p.1">The FEC Framework and FEC scheme exchange ADUs in the form of source blocks. A source block is generated by the FEC Framework from an ordered sequence of ADUs. The allocation of ADUs to blocks is dependent on the application. Note that some ADUs may not be included in any block. Each source block provided to the FEC scheme consists of an ordered sequence of ADUs where the following information is provided for each ADU: </p>

<ul>
<li>A description of the source flow with which the ADU is associated with.</li>
<li>The ADU itself.</li>
<li>The length of the ADU.</li>
</ul>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#sourcepackets" id="sourcepackets">Packet Format for FEC Source Packets</a>
</h1>
<p id="rfc.section.5.3.p.1">The packet format for FEC source packets MUST be used to transport the payload of an original source packet. As depicted in <a href="#sourcepacketfigure">Figure 6</a>, it consists of the original packet, optionally followed by the Explicit Source FEC Payload ID field. The FEC scheme determines whether the Explicit Source FEC Payload ID field is required. This determination is specific to each ADU flow.</p>
<div id="#rfc.figure.6"></div>
<div id="#sourcepacketfigure"></div>
<pre>
+------------------------------------+
|             IP Header              |
+------------------------------------+
|          Transport Header          |
+------------------------------------+
|        Application Data Unit       |
+------------------------------------+
|   Explicit Source FEC Payload ID   |
+------------------------------------+
</pre>
<p></p>
<p id="rfc.section.5.3.p.3">The FEC source packets MUST be sent using the same ADU flow as would have been used for the original source packets if the FEC Framework were not present. The transport payload of the FEC source packet MUST consist of the ADU followed by the Explicit Source FEC Payload ID field, if required.</p>
<p id="rfc.section.5.3.p.4">The Explicit Source FEC Payload ID field contains information required to associate the source packet with a source block and for the operation of the FEC algorithm, and is defined by the FEC scheme.  The format of the Source FEC Payload ID field is defined by the FEC scheme. In the case that the FEC scheme or CDP defines a means to derive the Source FEC Payload ID from other information in the packet (for example a sequence number used by the application protocol), then the Source FEC Payload ID field is not included in the packet. In this case, the original source packet and FEC source packet are identical.</p>
<p id="rfc.section.5.3.p.5">In applications where avoidance of IP packet fragmentation is a goal, CDPs SHOULD consider the Explicit Source FEC Payload ID size when determining the size of ADUs that will be delivered using the FEC Framework. This is because the addition of the Explicit Source FEC Payload ID increases the packet length.</p>
<p id="rfc.section.5.3.p.6">The Explicit Source FEC Payload ID is placed at the end of the packet so that in the case that Robust Header Compression (ROHC) <a href="#RFC3095">[RFC3095]</a> or other header compression mechanisms are used and in the case that a ROHC profile is defined for the protocol carried within the transport payload (for example RTP), then ROHC will still be applied for the FEC source packets. Applications that are used with this framework need to consider that FEC schemes can add this Explicit Source FEC Payload ID and thereby increase the packet size.</p>
<p id="rfc.section.5.3.p.7">In many applications, support for FEC is added to a pre-existing protocol and in this case use of the Explicit Source FEC Payload ID can break backwards compatibility, since source packets are modified.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> Generic Explicit Source FEC Payload ID</h1>
<p id="rfc.section.5.3.1.p.1">In order to apply FEC protection using multiple FEC schemes to a single source flow, all schemes have to use the same Explicit Source FEC Payload ID format. In order to enable this, it is RECOMMENDED that FEC schemes support the Generic Explicit Source FEC Payload ID format described below.</p>
<p id="rfc.section.5.3.1.p.2">The Generic Explicit Source FEC Payload ID has a length of two octets and consists of an unsigned packet sequence number in network-byte order. The allocation of sequence numbers to packets is independent of any FEC scheme and of the source block construction, except that the use of this sequence number places a constraint on source block construction. Source packets within a given source block MUST have consecutive sequence numbers (where consecutive includes wrap-around from the maximum value which can be represented in two octets (65535) to 0). Sequence numbers SHOULD NOT be reused until all values in the sequence number space have been used.</p>
<p id="rfc.section.5.3.1.p.3">Note that if the original packets of the source flow are already carrying a packet sequence number that is at least two bytes long, there is no need to add the generic Explicit Source FEC Payload ID and modify the packets.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#repairpackets" id="repairpackets">Packet Format for FEC Repair Packets</a>
</h1>
<div id="#rfc.figure.7"></div>
<div id="#repairpacketfigure"></div>
<pre>
+------------------------------------+
|             IP Header              |
+------------------------------------+
|          Transport Header          |
+------------------------------------+
|        Repair FEC Payload ID       |
+------------------------------------+
|           Repair Symbols           |
+------------------------------------+
</pre>
<p id="rfc.section.5.4.p.1">The packet format for FEC repair packets is shown in <a href="#repairpacketfigure">Figure 7</a>. The transport payload consists of a Repair FEC Payload ID field followed by repair data generated in the FEC encoding process. </p>
<p id="rfc.section.5.4.p.2">The Repair FEC Payload ID field contains information required for the operation of the FEC algorithm at the receiver. This information is defined by the FEC scheme. The format of the Repair FEC Payload ID field is defined by the FEC scheme.</p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> Packet Format for FEC Repair Packets over RTP</h1>
<p id="rfc.section.5.4.1.p.1">For FEC schemes which specify the use of RTP for repair packets, the packet format for repair packets includes an RTP header as shown in <a href="#repairpacketfigureRTP">Figure 8</a>.</p>
<div id="#rfc.figure.8"></div>
<div id="#repairpacketfigureRTP"></div>
<pre>
+------------------------------------+
|             IP header              |
+------------------------------------+
|      Transport Header (UDP)        |
+------------------------------------+
|             RTP Header             |
+------------------------------------+
|       Repair FEC Payload ID        |
+------------------------------------+
|          Repair Symbols            |
+------------------------------------+
</pre>
<p></p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#config" id="config">FEC Framework Configuration Information</a>
</h1>
<p id="rfc.section.5.5.p.1">The FEC Framework Configuration Information is information that the FEC Framework needs in order to apply FEC protection to the ADU flows.  A complete CDP specification that uses the framework specified here MUST include details of how this information is derived and communicated between sender and receiver.</p>
<p id="rfc.section.5.5.p.2">The FEC Framework Configuration Information includes identification of the set of source flows. For example, in the case of UDP, each source flow is uniquely identified by a tuple {Source IP address, source UDP port, destination IP address, destination UDP port}. In some applications some of these fields can contain wildcards, so that the flow is identified by a subset of the fields. In particular, in many applications the limited tuple {Destination IP address, destination UDP port} is sufficient.</p>
<p id="rfc.section.5.5.p.3">A single instance of the FEC Framework provides FEC protection for packets of the specified set of source flows, by means of one or more packet flows consisting of repair packets. The FEC Framework Configuration Information includes, for each instance of the FEC Framework: </p>

<ol>
<li>Identification of the repair flows.</li>
<li>For each source flow protected by the repair flow(s): <ol style="list-style-type: lower-alpha">
<li>Definition of the source flow.</li>
<li>An integer identifier for this flow definition (i.e., tuple). This identifier MUST be unique amongst all source flows that are protected by the same FEC repair flow. Integer identifiers can be allocated starting from zero and increasing by one for each flow. However, any random (but still unique) allocation is also possible. A source flow identifier need not be carried in source packets since source packets are directly associated with a flow by virtue of their packet headers.</li>
</ol>
</li>
<li>The FEC Encoding ID, identifying the FEC scheme.</li>
<li>The length of the Explicit Source FEC Payload ID (in octets).</li>
<li>Zero or more FEC-Scheme-Specific Information (FSSI) elements, each consisting of a name and a value where the valid element names and value ranges are defined by the FEC scheme.</li>
</ol>
<p id="rfc.section.5.5.p.4">Multiple instances of the FEC Framework, with separate and independent FEC Framework Configuration Information, can be present at a sender or receiver. A single instance of the FEC Framework protects packets of the source flows identified in (2) above, i.e., all packets sent on those flows MUST be FEC source packets as defined in <a href="#sourcepackets">Section 5.3</a>. A single source flow can be protected by multiple instances of the FEC Framework.</p>
<p id="rfc.section.5.5.p.5">The integer flow identifier identified in (2b) above is a shorthand to identify source flows between the FEC Framework and the FEC scheme.  The reason for defining this as an integer, and including it in the FEC Framework Configuration Information is so that the FEC scheme at the sender and receiver can use it to identify the source flow with which a recovered packet is associated. The integer flow identifier can therefore take the place of the complete flow description (e.g., UDP 4-tuple).</p>
<p id="rfc.section.5.5.p.6">Whether and how this flow identifier is used is defined by the FEC scheme. Since repair packets can provide protection for multiple source flows, repair packets would either not carry the identifier at all or can carry multiple identifiers. However, in any case, the flow identifier associated with a particular source packet can be recovered from the repair packets as part of an FEC decoding operation.</p>
<p id="rfc.section.5.5.p.7">A single FEC repair flow provides repair packets for a single instance of the FEC Framework. Other packets MUST NOT be sent within this flow, i.e., all packets in the FEC repair flow MUST be FEC repair packets as defined in <a href="#repairpackets">Section 5.4</a> and MUST relate to the same FEC Framework instance.</p>
<p id="rfc.section.5.5.p.8">In the case that RTP is used for repair packets, the identification of the repair packet flow can also include the RTP payload type to be used for repair packets.</p>
<p id="rfc.section.5.5.p.9">FSSI includes the information that is specific to the FEC scheme used by the CDP. FSSI is used to communicate the information that cannot be adequately represented otherwise and is essential for proper FEC encoding and decoding operations. The motivation behind separating the FSSI required only by the sender (which is carried in Sender-Side FEC-Scheme-Specific Information (SS-FSSI) container) from the rest of the FSSI is to provide the receiver or the third party entities a means of controlling the FEC operations at the sender. Any FSSI other than the one solely required by the sender MUST be communicated via the FSSI container.</p>
<p id="rfc.section.5.5.p.10">The variable-length SS-FSSI and FSSI containers transmit the information in textual representation and contain zero or more distinct elements, whose descriptions are provided by the fully-specified FEC schemes.</p>
<p id="rfc.section.5.5.p.11">For the CDPs that choose the Session Description Protocol (SDP) <a href="#RFC4566">[RFC4566]</a> as their session description protocol, the ABNF <a href="#RFC5234">[RFC5234]</a> syntax for the SS-FSSI and FSSI containers is provided in Section 4.5 of <a href="#I-D.ietf-fecframe-sdp-elements">[I-D.ietf-fecframe-sdp-elements]</a>.</p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#fecscheme" id="fecscheme">FEC Scheme Requirements</a>
</h1>
<p id="rfc.section.5.6.p.1">In order to be used with this framework, an FEC scheme MUST be capable of processing data arranged into blocks of ADUs (source blocks).</p>
<p id="rfc.section.5.6.p.2">A specification for a new FEC scheme MUST include the following: </p>

<ol>
<li>The FEC Encoding ID value that uniquely identifies the FEC scheme. This value MUST be registered with IANA as described in <a href="#iana">Section 11</a>.</li>
<li>The type, semantics and encoding format of the Repair FEC Payload ID.</li>
<li>The name, type, semantics and text value encoding rules for zero or more FEC-Scheme-Specific Information elements.</li>
<li>A full specification of the FEC code. <br><br>This specification MUST precisely define the valid FEC-Scheme-Specific Information values, the valid FEC Payload ID values and the valid packet payload sizes (where packet payload refers to the space within a packet dedicated to carrying encoding symbols). <br><br>Furthermore, given a source block as defined in <a href="#sourceblock">Section 5.2</a>, valid values of the FEC-Scheme-Specific Information, a valid Repair FEC Payload ID value and a valid packet payload size, the specification MUST uniquely define the values of the encoding symbols to be included in the repair packet payload of a packet with the given Repair FEC Payload ID value.<br><br>A common and simple way to specify the FEC code to the required level of detail is to provide a precise specification of an encoding algorithm which, given a source block, valid values of the FEC-Scheme-Specific Information, a valid Repair FEC Payload ID value and a valid packet payload size as input produces the exact value of the encoding symbols as output.</li>
<li>A description of practical encoding and decoding algorithms.<br><br>This description need not be to the same level of detail as for the encoding above, however it has to be sufficient to demonstrate that encoding and decoding of the code is both possible and practical.</li>
</ol>
<p id="rfc.section.5.6.p.3">FEC scheme specifications MAY additionally define the following: </p>

<ol><li>Type, semantics and encoding format of an Explicit Source FEC Payload ID.</li></ol>
<p id="rfc.section.5.6.p.4">Whenever an FEC scheme specification defines an 'encoding format' for an element, this has to be defined in terms of a sequence of bytes which can be embedded within a protocol. The length of the encoding format MUST either be fixed or it MUST be possible to derive the length from examining the encoded bytes themselves. For example, the initial bytes can include some kind of length indication.</p>
<p id="rfc.section.5.6.p.5">FEC scheme specifications SHOULD use the terminology defined in this document and SHOULD follow the following format: </p>

<dl>
<dt>1. Introduction</dt>
<dd style="margin-left: 8">&lt;Describe the use-cases addressed by this FEC scheme&gt;<br><br>
</dd>
<dt>2. Formats and Codes</dt>
<dd style="margin-left: 8"><dl>
<dt>2.1 Source FEC Payload ID(s)</dt>
<dd style="margin-left: 8">&lt;Either, define the type and format of the Explicit Source FEC Payload ID, or define how Source FEC Payload ID information is derived from source packets&gt;<br><br>
</dd>
<dt>2.2 Repair FEC Payload ID</dt>
<dd style="margin-left: 8">&lt;Define the type and format of the Repair FEC Payload ID&gt;</dd>
<dt>2.3 FEC Framework Configuration Information</dt>
<dd style="margin-left: 8">&lt;Define the names, types and text value encoding formats of the FEC-Scheme-Specific Information elements&gt;</dd>
</dl></dd>
<dt>3. Procedures</dt>
<dd style="margin-left: 8">&lt;Describe any procedures which are specific to this FEC scheme, in particular derivation and interpretation of the fields in the FEC Payload IDs and FEC-Scheme-Specific Information&gt;</dd>
<dt>4. FEC Code Specification</dt>
<dd style="margin-left: 8">&lt;Provide a complete specification of the FEC Code&gt;</dd>
</dl>
<p id="rfc.section.5.6.p.6">Specifications can include additional sections including examples.</p>
<p id="rfc.section.5.6.p.7">Each FEC scheme MUST be specified independently of all other FEC schemes; for example, in a separate specification or a completely independent section of larger specification (except, of course, a specification of one FEC scheme can include portions of another by reference). Where an RTP Payload Format is defined for repair data for a specific FEC scheme, the RTP Payload Format and the FEC scheme can be specified within the same document.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Feedback</h1>
<p id="rfc.section.6.p.1">Many applications require some kind of feedback on transport performance. E.g., how much data arrived at the receiver, at what rate and when? When FEC is added to such applications, feedback mechanisms can also need to be enhanced to report on the performance of the FEC.  E.g., how much lost data was recovered by the FEC?</p>
<p id="rfc.section.6.p.2">When used to provide instrumentation for engineering purposes, it is important to remember that FEC is generally applied to relatively small blocks of data (in the sense that each block is transmitted over a relatively small period of time). Thus, feedback information that is averaged over longer periods of time will likely not provide sufficient information for engineering purposes. More detailed feedback over shorter time scales might be preferred. For example, for applications using RTP transport, see <a href="#RFC5725">[RFC5725]</a>.</p>
<p id="rfc.section.6.p.3">Applications which used feedback for congestion control purposes MUST calculate such feedback on the basis of packets received before FEC recovery is applied. If this requirement conflicts with other uses of the feedback information then the application MUST be enhanced to support both information calculated pre- and post- FEC recovery. This is to ensure that congestion control mechanisms operate correctly based on congestion indications received from the network, rather than on post-FEC recovery information which would give an inaccurate picture of congestion conditions.</p>
<p id="rfc.section.6.p.4">New applications which require such feedback SHOULD use RTP/RTCP <a href="#RFC3550">[RFC3550]</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#TransportProtocols" id="TransportProtocols">Transport Protocols</a>
</h1>
<p id="rfc.section.7.p.1">This framework is intended to be used to define CDPs that operate over transport protocols providing an unreliable datagram service, including in particular the User Datagram Protocol (UDP) and the Datagram Congestion Control Protocol (DCCP).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#sec_congestion" id="sec_congestion">Congestion Control</a>
</h1>
<p id="rfc.section.8.p.1">This section starts with some informative background on the motivation of the normative requirements for congestion control, which are spelled out in <a href="#normativecongestion">Section 8.2</a>.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Motivation</h1>
<p></p>

<ul>
<li>The enforcement of congestion control principles has gained a lot of momentum in the IETF over the recent years. While the need for congestion control over the open Internet is unquestioned, and the goal of TCP friendliness is generally agreed for most (but not all) applications, the subject of congestion detection and measurement in heterogeneous networks can hardly be considered as solved. Most congestion control algorithms detect and measure congestion by taking (primarily or exclusively) the packet loss rate into account. This appears to be inappropriate in environments where a large percentage of the packet losses are the result of link-layer errors and independent of the network load.</li>
<li>The authors of this document are primarily interested in applications where the application reliability requirements and end-to-end reliability of the network differ, such that it warrants higher-layer protection of the packet stream, e.g., due to the presence of unreliable links in the end-to-end path and where real-time, scalability or other constraints prohibit the use of higher-layer (transport or application) feedback. A typical example for such applications is multicast and broadcast streaming or multimedia transmission over heterogeneous networks. In other cases, application reliability requirements can be so high that the required end-to-end reliability will be difficult to achieve.  Furthermore, the end-to-end network reliability is not necessarily known in advance.</li>
<li>This FEC Framework is not defined, nor intended, as a QoS enhancement tool to combat losses resulting from highly congested networks. It should not be used for such purposes.</li>
<li>In order to prevent such mis-use, one approach is to leave standardization to bodies most concerned with the problem described above. However, the IETF defines base standards used by several bodies, including DVB, 3GPP, 3GPP2, all of which appear to share the environment and the problem described.</li>
<li>Another approach is to write a clear applicability statement.  For example, one could restrict the use of this framework to networks with certain loss characteristics (e.g., wireless links).  However, there can be applications where the use of FEC is justified to combat congestion-induced packet losses - particularly in lightly loaded networks, where congestion is the result of relatively rare random peaks in instantaneous traffic load - thereby intentionally violating congestion control principles. One possible example for such an application could be a no-matter-what, brute-force FEC protection of a traffic generated as an emergency signal.</li>
<li>A third approach is to require at a minimum that the use of this framework with any given application, in any given environment, does not cause congestion issues which the application alone would not itself cause, i.e., the use of this framework must not make things worse.</li>
<li>Taking above considerations into account, <a href="#normativecongestion">Section 8.2</a> specifies a small set of constraints for the FEC, which are mandatory for all senders compliant with this FEC Framework. Further restrictions can be imposed by certain CDPs.</li>
</ul>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#normativecongestion" id="normativecongestion">Normative Requirements</a>
</h1>
<p></p>

<ul>
<li>The bandwidth of FEC repair data MUST NOT exceed the bandwidth of the original source data being protected (without the possible addition of an Explicit Source FEC Payload ID). This disallows the (static or dynamic) use of excessively strong FEC to combat high packet loss rates, which can otherwise be chosen by naively implemented dynamic FEC-strength selection mechanisms. We acknowledge that there are a few exotic applications, e.g., IP traffic from space-based senders, or senders in certain hardened military devices, which could warrant a higher FEC strength.  However, in this specification we give preference to the overall stability and network friendliness of average applications.</li>
<li>Whenever the source data rate is adapted due to the operation of congestion control mechanisms, the FEC repair data rate MUST be similarly adapted.</li>
</ul>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Security Considerations</h1>
<p id="rfc.section.9.p.1">First of all, it must be clear that the application of FEC protection to a stream does not provide any kind of security. On the opposite, the FEC Framework itself could be subject to attacks, or could pose new security risks. The goals of this section are to state the problem, discuss the risks and identify solutions when feasible. It also defines a mandatory to implement (but not mandatory to use) security scheme.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> Problem Statement</h1>
<p id="rfc.section.9.1.p.1">A content delivery system is potentially subject to many attacks.  Attacks can target the content, or the CDP, or the network itself, with completely different consequences, in particular in terms of the number of impacted nodes.</p>
<p id="rfc.section.9.1.p.2">Attacks can have several goals: </p>

<ul>
<li>They can try to give access to a confidential content (e.g., in case of a non-free content).</li>
<li>They can try to corrupt the source flows (e.g., to prevent a receiver from using them), which is a form of DoS attack.</li>
<li>They can try to compromise the receiver's behavior (e.g., by making the decoding of an object computationally expensive), which is another form of DoS attack.</li>
<li>They can try to compromise the network's behavior (e.g., by causing congestion within the network), which potentially impacts a large number of nodes.</li>
</ul>

<p>These attacks can be launched either against the source and/or repair flows (e.g., by sending fake FEC source and/or repair packets) or against the FEC parameters that are sent either in-band (e.g., in the Repair FEC Payload ID or in the Explicit Source FEC Payload ID) or out-of-band (e.g., in the FEC Framework Configuration Information).</p>
<p id="rfc.section.9.1.p.3">Several dimensions to the problem need to be considered. The first one is the way the FEC Framework is used. The FEC Framework can be used end-to-end, i.e., it can be included in the final end-device where the upper application runs; or the FEC Framework can be used in middleboxes, for instance, to globally protect several source flows exchanged between two or more distant sites.</p>
<p id="rfc.section.9.1.p.4">A second dimension is the threat model. When the FEC Framework operates in the end-device, this device (e.g., a personal computer) might be subject to attacks. Here, the attacker is either the end-user (who might want to access confidential content) or somebody else. In all cases the attacker has access to the end-device, but not necessarily to the full control of the end-device (a secure domain can exist). Similarly, when the FEC Framework operates in a middlebox, this middlebox can be subject to attacks or the attacker can gain access to it. The threats can also concern the end-to-end transport (e.g., through Internet). Here, examples of threats include the transmission of fake FEC source or repair packets, the replay of valid packets, the drop, delay or misordering of packets, and of course traffic eavesdropping.</p>
<p id="rfc.section.9.1.p.5">The third dimension consists in the desired security services.  Among them, the content integrity and sender authentication services are probably the most important features. We can also mention DoS mitigation, anti-replay protection or content confidentiality.</p>
<p id="rfc.section.9.1.p.6">Finally, the fourth dimension consists in the security tools available. This is the case of the various Digital Rights Management (DRM) systems, defined out of the context of the IETF and that can be proprietary solutions. Otherwise SRTP and IPsec/ESP are two tools that can turn out to be useful in the context of the FEC Framework. Note that using SRTP requires that the application generates RTP source flows and, when applied below the FEC Framework, that both the FEC source and repair packets to be regular RTP packets. Therefore SRTP is not considered as a universal solution applicable in all use cases.</p>
<p id="rfc.section.9.1.p.7">In the following sections, we further discuss security aspects related to the use of the FEC Framework.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> Attacks Against the Data Flows</h1>
<p></p>
<h1 id="rfc.section.9.2.1">
<a href="#rfc.section.9.2.1">9.2.1.</a> Access to Confidential Content</h1>
<p id="rfc.section.9.2.1.p.1">Access control to the source flow being transmitted is typically provided by means of encryption. This encryption can be done by the content provider itself, or within the application (for instance by using the Secure Real-time Transport Protocol (SRTP) <a href="#RFC3711">[RFC3711]</a>), or at the network layer, on a per-packet basis when IPsec/ESP is used <a href="#RFC4303">[RFC4303]</a>. If confidentiality is a concern, it is RECOMMENDED that one of these solutions is used. Even if we mention these attacks here, they are neither related to nor facilitated by the use of FEC.</p>
<p id="rfc.section.9.2.1.p.2">Note that when encryption is applied, this encryption MUST either be applied on the source data before the FEC protection, or if done after the FEC protection, then both the FEC source packets and repair packets MUST be encrypted (and an encryption at least as cryptographically secure as the encryption applied on the FEC source packets MUST be used for the FEC repair packets). Otherwise, if encryption were to be performed only on the FEC source packets after FEC encoding, a non-authorized receiver could be able to recover the source data after decoding the FEC repair packets provided that a sufficient number of such packets were available.</p>
<p id="rfc.section.9.2.1.p.3">The following considerations apply when choosing where to apply encryption (and more generally where to apply security services beyond encryption). Once decryption has taken place, the source data is in plaintext. The full path between the output of the deciphering module and the final destination (e.g., the TV display in case of a video) MUST be secured, in order to prevent any unauthorized access to the source data.</p>
<p id="rfc.section.9.2.1.p.4">When the FEC Framework endpoint is the end system (i.e., where the upper application runs) and if the threat model includes the possibility that an attacker has access to this end system, then the end system architecture is very important. More precisely, in order to prevent an attacker to get hold of the plaintext, all processings, once deciphering has taken place, MUST occur in a protected environment. If encryption is applied after FEC protection at the sending side (i.e., below FEC Framework), it means that FEC decoding MUST take place in the protected environment. With certain use cases, this MAY be complicated or even impossible. In that case applying encryption before FEC protection is preferred.</p>
<p id="rfc.section.9.2.1.p.5">When the FEC Framework endpoint is a middlebox, the recovered source flow, after FEC decoding, SHOULD NOT be sent in plaintext to the final destination(s) if the threat model includes the possibility that an attacker eavesdrops the traffic. In that case also it is preferred to apply encryption before FEC protection.</p>
<p id="rfc.section.9.2.1.p.6">In some cases, encryption could be applied both before and after the FEC protection. The considerations described above still apply in such cases.</p>
<h1 id="rfc.section.9.2.2">
<a href="#rfc.section.9.2.2">9.2.2.</a> <a href="#sec_content_corruption" id="sec_content_corruption">Content Corruption</a>
</h1>
<p id="rfc.section.9.2.2.p.1">Protection against corruptions (e.g., against forged FEC source/repair packets) is achieved by means of a content integrity verification/source authentication scheme. This service is usually provided at the packet level. In this case, after removing all the forged packets, the source flow might sometimes be recovered.  Several techniques can provide this content integrity/source authentication service: </p>

<ul>
<li>At the application layer, SRTP <a href="#RFC3711">[RFC3711]</a> provides several solutions to check the integrity and authenticate the source of RTP and RTCP messages, among other services. For instance, associated to the Timed Efficient Stream Loss-Tolerant Authentication (TESLA) <a href="#RFC4383">[RFC4383]</a>, SRTP is an attractive solution that is robust to losses, provides a true authentication/integrity service, and does not create any prohibitive processing load or transmission overhead. Yet, checking a packet requires a small delay (a second or more) after its reception with TESLA. Whether this extra delay, both in terms of startup delay at the client and end-to-end delay, is appropriate or not depends on the target use case. In some situations, this might degrade the user experience. In other situations, this will not be an issue.  Other building blocks can be used within SRTP to provide content integrity/authentication services.</li>
<li>At the network layer, IPsec/ESP <a href="#RFC4303">[RFC4303]</a> offers (among other services) an integrity verification mechanism that can be used to provide authentication/content integrity services.</li>
</ul>
<p id="rfc.section.9.2.2.p.2">It is up to the developer and the person in charge of deployment, who know the security requirements and features of the target application area, to define which solution is the most appropriate.  Nonetheless it is RECOMMENDED that at least one of these techniques is used.</p>
<p id="rfc.section.9.2.2.p.3">Note that when integrity protection is applied, it is RECOMMENDED that it takes place on both FEC source and repair packets. The motivation is to avoid corrupted packets to be considered during decoding, which would often lead to a decoding failure or result in a corrupted decoded source flow.</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> Attacks Against the FEC Parameters</h1>
<p id="rfc.section.9.3.p.1">Attacks on these FEC parameters can prevent the decoding of the associated object. For instance, modifying the finite field size of a Reed-Solomon FEC scheme (when applicable) will lead a receiver to consider a different FEC code.</p>
<p id="rfc.section.9.3.p.2">It is therefore RECOMMENDED that security measures are taken to guarantee the FEC Framework Configuration Information integrity. Since the FEC Framework does not define how the FEC Framework Configuration Information is communicated from sender to receiver, we cannot provide further recommendations on how to guarantee its integrity. However, any complete CDP specification MUST give recommendations on how to achieve it. When the FEC Framework Configuration Information is sent out-of-band, e.g., in a session description, it SHOULD be protected, for instance, by digitally signing it.</p>
<p id="rfc.section.9.3.p.3">Attacks are also possible against some FEC parameters included in the Explicit Source FEC Payload ID and Repair FEC Payload ID. For instance, modifying the Source Block Number of an FEC source or repair packet will lead a receiver to assign this packet to a wrong block.</p>
<p id="rfc.section.9.3.p.4">It is therefore RECOMMENDED that security measures are taken to guarantee the Explicit Source FEC Payload ID and Repair FEC Payload ID integrity. To that purpose, one of the packet-level source authentication/content integrity techniques of <a href="#sec_content_corruption">Section 9.2.2</a> can be used.</p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#sec_pro_tog" id="sec_pro_tog">When Several Source Flows are to be Protected Together</a>
</h1>
<p id="rfc.section.9.4.p.1">When several source flows, with different security requirements, need to be FEC protected jointly, within a single FEC Framework instance, then each flow MAY be processed appropriately, before the protection. For instance, source Flows that require access control MAY be encrypted before they are FEC protected.</p>
<p id="rfc.section.9.4.p.2">There are also situations where the only insecure domain is the one over which the FEC Framework operates. In that case, this situation MAY be addressed at the network layer, using IPsec/ESP (see <a href="#sec_mandatory_solution">Section 9.5</a>), even if only a subset of the source flows have strict security requirements.</p>
<p id="rfc.section.9.4.p.3">Since the use of FEC Framework should not add any additional threat, it is RECOMMENDED that the FEC Framework aggregate flow be in line with the maximum security requirements of the individual source flows. For instance, if denial-of-service (DoS) protection is required, an integrity protection SHOULD be provided below the FEC Framework, using for instance IPsec/ESP.</p>
<p id="rfc.section.9.4.p.4">Generally speaking, whenever feasible, it is RECOMMENDED to avoid FEC protecting flows with totally different security requirements.  Otherwise, an important processing would be added to protect the source flows that do not need it.</p>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#sec_mandatory_solution" id="sec_mandatory_solution">Baseline Secure FEC Framework Operation</a>
</h1>
<p id="rfc.section.9.5.p.1">This section describes a baseline mode of secure FEC Framework operation based on the application of the IPsec security protocol, which is one possible solution to solve or mitigate the security threats introduced by the use of the FEC Framework.</p>
<p id="rfc.section.9.5.p.2">Two related documents are of interest. First, Section 5.1 of <a href="#RFC5775">[RFC5775]</a> defines a baseline secure ALC operation for sender-to-group transmissions, assuming the presence of a single sender and a source-specific multicast (SSM) or SSM-like operation.  The proposed solution, based on IPsec/ESP, can be used to provide a baseline FEC Framework secure operation, for the downstream source flow.</p>
<p id="rfc.section.9.5.p.3">Second, Section 7.1 of <a href="#RFC5740">[RFC5740]</a> defines a baseline secure NORM operation, for sender-to-group transmissions as well as unicast feedbacks from receivers. Here, it is also assumed there is a single sender. The proposed solution is also based on IPsec/ESP. However, the difference with respect to the first document relies on the management of IPsec Security Associations (SA) and corresponding Security Policy Database (SPD) entries, since NORM requires a second set of SA and SPD to be defined to protect unicast feedbacks from receivers.</p>
<p id="rfc.section.9.5.p.4">The FEC Framework has been defined in such a way to be independent from the application that generates source flows. Some applications might use purely unidirectional flows, while other applications might also use unicast feedbacks from the receivers. For instance, this is the case when considering RTP/RTCP based source flows. Depending on the specific situation, it is RECOMMENDED that the baseline secure FEC Framework operation inherits from <a href="#RFC5775">[RFC5775]</a> in case of purely unidirectional sender-to-group flows, or <a href="#RFC5740">[RFC5740]</a> in case both sender-to-group and unicast feedbacks flows are needed.</p>
<p id="rfc.section.9.5.p.5">Note that the IPsec/ESP requirements profiles outlined in <a href="#RFC5775">[RFC5775]</a> and <a href="#RFC5740">[RFC5740]</a> are commonly available on many potential hosts. They can form the basis of a secure mode of operation. One potential limitation, however, is the need for privileged user authorization. However, automated key management implementations are typically configured with the privileges necessary to affect system IPsec configuration.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> Operations and Management Considerations</h1>
<p id="rfc.section.10.p.1">The question of operating and managing the FEC Framework and the associated FEC scheme(s) is of high practical importance. The goals of this section are to discuss the general requirements, aspects related to a specific deployment and solutions whenever possible.</p>
<p id="rfc.section.10.p.2">In particular, this section discusses the questions of interoperability across vendors/use cases and whether defining mandatory to implement (but not mandatory to use) solutions is beneficial.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#sec_ops1" id="sec_ops1">What are the Key Aspects to Consider?</a>
</h1>
<p id="rfc.section.10.1.p.1">Several aspects need to be considered since they will directly impact the way the FEC Framework and the associated FEC schemes can be operated and managed.</p>
<p id="rfc.section.10.1.p.2">This section lists them as follows:</p>
<p></p>

<ul>
<li>A Single Small Generic Component within a Larger (and Often Legacy) Solution: The FEC Framework is one component within a larger solution which includes both one or several upper-layer applications (that generate one or several ADU flows) and an underlying protocol stack. A key design principle is that the FEC Framework should be able to work without making any assumption with respect to either the upper-layer application(s) or the underlying protocol stack, even if there are special cases where assumptions are made.</li>
<li>One-to-One with Feedback vs. One-to-Many with Feedback vs.  One-to-Many without Feedback Scenarios: The FEC Framework can be used in use cases that completely differ from one another. Some use cases are one-way (e.g., in broadcast networks), with either a one-to-one, one-to-many or many-to-many transmission model, and the receiver(s) cannot send any feedback to the sender(s). Other use cases follow a bidirectional one-to-one, one-to-many, or many-to-many scenario, and the receiver(s) can send feedback to the sender(s).</li>
<li>Non-FEC Framework Capable Receivers: With the one-to-many and many-to-many use cases, the receiver population might have different capabilities with respect to the FEC Framework itself and the supported FEC schemes. Some receivers might not be capable of decoding the repair packets belonging to a particular FEC scheme, while some other receivers might not be supporting the FEC Framework at all.</li>
<li>Internet vs. non-Internet Networks: The FEC Framework can be useful in many use cases that use a transport network that is not the public Internet (e.g., with IPTV or Mobile TV). In such networks, the operational and management considerations can be achieved through an open or proprietary solution, which is specified outside of the IETF.</li>
<li>Congestion Control Considerations: See <a href="#sec_congestion">Section 8</a> for a discussion on whether congestion control is needed or not, and its relationships with the FEC Framework.</li>
<li>Within End-Systems vs. within Middleboxes: The FEC Framework can be used within end-systems, very close to the upper-layer application, or within dedicated middleboxes, for instance when it is desired to protect one or several flows while they cross a lossy channel between two or more remote sites.</li>
<li>Protecting a Single Flow vs. Several Flows Globally: The FEC Framework can be used to protect a single flow, or several flows globally.</li>
</ul>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> Operational and Management Recommendations</h1>
<p id="rfc.section.10.2.p.1">Overall, from the discussion of <a href="#sec_ops1">Section 10.1</a>, it is clear that the CDPs and FEC schemes compatible with the FEC Framework widely differ in their capabilities, application and deployment scenarios such that a common operation and management method or protocol that works well for all of them would be too complex to define. Thus, as a design choice, the FEC Framework does not dictate the use of any particular technology or protocol for transporting FEC data, managing the hosts, signaling the configuration information or encoding the configuration information. This provides flexibility and is one of the main goals of the FEC Framework.  However, this section gives some RECOMMENDED guidelines.</p>
<p></p>

<ul>
<li>A Single Small Generic Component within a Larger (and Often Legacy) Solution: It is anticipated that the FEC Framework will often be used to protect one or several RTP streams. Therefore, implementations SHOULD make feedback information accessible via RTCP to enable users to take advantage of the tools using (or used by) RTCP to operate and manage the FEC Framework instance along with the associated FEC schemes.</li>
<li>One-to-One with Feedback vs. One-to-Many with Feedback vs.  One-to-Many without Feedback Scenarios: With use cases that are one-way, the FEC Framework sender does not have any way to gather feedback from receivers. With use cases that are bidirectional, the FEC Framework sender can collect detailed feedback (e.g., in case of a one-to-one scenario) or at least occasional feedback (e.g., in case of a multicast, one-to-many scenario). All these applications have naturally different operational and management aspects. If any, they also have different requirements or features for collecting feedback, processing it and acting on it. The data structures for carrying the feedback also vary.<br><br>Implementers SHOULD make feedback available using either an in-band or out-of-band asynchronous reporting mechanism.  When an out-of-band solution is preferred, a standardized reporting mechanism, such as Syslog <a href="#RFC5424">[RFC5424]</a> or SNMP notifications <a href="#RFC3411">[RFC3411]</a>, is RECOMMENDED. When required, a mapping mechanism between the Syslog and SNMP reporting mechanisms could be used, as described in <a href="#RFC5675">[RFC5675]</a> and <a href="#RFC5676">[RFC5676]</a>. </li>
<li>Non-FEC Framework Capable Receivers: <a href="#sourcepackets">Section 5.3</a> gives recommendations on how to provide backward compatibility in presence of receivers that cannot support the FEC scheme being used, or the FEC Framework itself: basically the use of Explicit Source FEC Payload ID is banned. Additionally, a non-FEC Framework capable receiver MUST also have a means not to receive the repair packets that it will not be able to decode in the first place or a means to identify and discard them appropriately upon receiving them. This SHOULD be achieved by sending repair packets on a different transport-layer flow. In case of RTP transport and if both source and repair packets will be sent on the same transport-layer flow, this SHOULD be achieved by using an RTP framing for FEC repair packets with a different payload type. It is the responsibility of the sender to select the appropriate mechanism when needed.</li>
<li>Within End-Systems vs. within Middleboxes: When the FEC Framework is used within middleboxes, it is RECOMMENDED that the paths between the hosts where the sending applications run and the middlebox that performs FEC encoding be as reliable as possible, i.e., are not prone to packet loss, packet reordering, or varying delays in delivering packets. <br><br>Similarly, it is RECOMMENDED that the paths between the middleboxes that perform FEC decoding and the end-systems where the receiving applications operate, in situations where this is a different host, be as reliable as possible. <br><br>
</li>
<li>Management of Communication Issues Before Reaching the Sending FECFRAME Instance: Let us consider situations where the FEC Framework is used within middleboxes.  At the sending side, the general reliability recommendation for the path between the sending applications and the middlebox is important but it may not guarantee that a loss, reordering or important delivery delay cannot happen, for whatever reason. If such a rare event happens, this event SHOULD NOT compromise the operation of the FECFRAME instances, neither at the sending side nor receiving side. This is particularly important with FEC schemes that do not modify the ADU for backward compatibility purposes (i.e., do not use any Explicit Source FEC Payload ID) and rely for instance on the RTP sequence number field to identify FEC source packets within their source block. In this case, packet loss or packet reordering leads to a gap in the RTP sequence number space seen by the FECFRAME instance. Similarly, varying delay in delivering packets over this path can lead to significant timing issues. With FEC schemes that indicate in the Repair FEC Payload ID, for each source block, the base RTP sequence number and number of consecutive RTP packets that belong to this source block, a missing ADU or an ADU delivered out of order could cause the FECFRAME sender to switch to a new source block. However, some FEC schemes and/or receivers may not necessarily handle such varying source block sizes. In this case, one could consider duplicating the last ADU received before the loss, or inserting zero'ed ADU(s), depending on the ADU flow nature. Implementers SHOULD consider the consequences of such alternative approaches based on their use cases.</li>
<li>Protecting a Single Flow vs. Several Flows Globally: In the general case, the various ADU flows that are globally protected can have different features, and in particular different real-time requirements (in case of real-time flows). The process of globally protecting these flows SHOULD take into account the requirements of each individual flow. In particular, it would be counter-productive to add repair traffic to a real-time flow for which the FEC decoding delay at a receiver makes decoded ADUs for this flow useless because they do not satisfy the associated real-time constraints. From a practical point of view, this means that the source block creation process at the sending FEC Framework instance, SHOULD consider the most stringent real-time requirements of the ADU flows being globally protected.</li>
<li>ADU Flow Bundle Definition and Flow Delivery: By design a repair flow might enable a receiver to recover the ADU flow(s) that it protects even if none of the associated FEC source packets are received. Therefore, when defining the bundle of ADU flows that are globally protected and when defining which receiver receives which flow, the sender SHOULD make sure that the ADU flow(s) and repair flow(s) of that bundle will only be received by receivers that are authorized to receive all the ADU flows of that bundle. See <a href="#sec_pro_tog">Section 9.4</a> for additional recommendations for situations where a strict access control to ADU flows is needed. <br><br>Additionally when multiple ADU flows are globally protected, a receiver who wants to benefit from FECFRAME loss protection SHOULD receive all the ADU flows of the bundle. Otherwise, the missing FEC source packets would be considered as lost which might significantly reduce the efficiency of the FEC scheme.</li>
</ul>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">FEC schemes for use with this framework are identified in protocols using FEC Encoding IDs. Values of FEC Encoding IDs are subject to IANA registration. For this purposes, this document creates a new registry called FEC Framework (FECFRAME) FEC Encoding IDs.</p>
<p id="rfc.section.11.p.2">The values that can be assigned within the FEC Framework (FECFRAME) FEC Encoding ID registry are numeric indexes in the range (0, 255).  Values of 0 and 255 are reserved. Assignment requests are granted on an IETF Consensus basis as defined in <a href="#RFC5226">[RFC5226]</a>. <a href="#fecscheme">Section 5.6</a> defines explicit requirements that documents defining new FEC Encoding IDs should meet.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> Acknowledgments</h1>
<p id="rfc.section.12.p.1">This document is based in part on <a href="#I-D.watson-tsvwg-fec-sf">[I-D.watson-tsvwg-fec-sf]</a> and so thanks are due to the additional authors of that document, Mike Luby, Magnus Westerlund and Stephan Wenger. That document was in turn based on the FEC Streaming Protocol defined by 3GPP in <a href="#MBMSTS">[MBMSTS]</a>, and thus, thanks are also due to the participants in 3GPP SA Working Group 4.  Further thanks are due to the members of the FECFRAME Working Group for their comments and reviews.</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative references</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3095">[RFC3095]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Burmeister, C.</a>, <a>Degermark, M.</a>, <a>Fukushima, H.</a>, <a>Hannu, H.</a>, <a>Jonsson, L-E.</a>, <a>Hakenberg, R.</a>, <a>Koren, T.</a>, <a>Le, K.</a>, <a>Liu, Z.</a>, <a>Martensson, A.</a>, <a>Miyazaki, A.</a>, <a>Svanbro, K.</a>, <a>Wiebke, T.</a>, <a>Yoshimura, T.</a> and <a>H. Zheng</a>, "<a href="http://tools.ietf.org/html/rfc3095">RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed</a>", RFC 3095, July 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5052">[RFC5052]</b></td>
<td class="top">
<a>Watson, M.</a>, <a>Luby, M.</a> and <a>L. Vicisano</a>, "<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>", RFC 5052, August 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3550">[RFC3550]</b></td>
<td class="top">
<a>Schulzrinne, H.</a>, <a>Casner, S.</a>, <a>Frederick, R.</a> and <a>V. Jacobson</a>, "<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>", STD 64, RFC 3550, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5424">[RFC5424]</b></td>
<td class="top">
<a>Gerhards, R.</a>, "<a href="http://tools.ietf.org/html/rfc5424">The Syslog Protocol</a>", RFC 5424, March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3411">[RFC3411]</b></td>
<td class="top">
<a>Harrington, D.</a>, <a>Presuhn, R.</a> and <a>B. Wijnen</a>, "<a href="http://tools.ietf.org/html/rfc3411">An Architecture for Describing Simple Network Management Protocol (SNMP) Management Frameworks</a>", STD 62, RFC 3411, December 2002.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative references</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.watson-tsvwg-fec-sf">[I-D.watson-tsvwg-fec-sf]</b></td>
<td class="top">
<a>Watson, M</a>, "<a href="http://tools.ietf.org/html/draft-watson-tsvwg-fec-sf-00">Forward Error Correction (FEC) Streaming Framework</a>", Internet-Draft draft-watson-tsvwg-fec-sf-00, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5725">[RFC5725]</b></td>
<td class="top">
<a>Begen, A.</a>, <a>Hsu, D.</a> and <a>M. Lague</a>, "<a href="http://tools.ietf.org/html/rfc5725">Post-Repair Loss RLE Report Block Type for RTP Control Protocol (RTCP) Extended Reports (XRs)</a>", RFC 5725, February 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4566">[RFC4566]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4588">[RFC4588]</b></td>
<td class="top">
<a>Rey, J.</a>, <a>Leon, D.</a>, <a>Miyazaki, A.</a>, <a>Varsa, V.</a> and <a>R. Hakenberg</a>, "<a href="http://tools.ietf.org/html/rfc4588">RTP Retransmission Payload Format</a>", RFC 4588, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-fecframe-sdp-elements">[I-D.ietf-fecframe-sdp-elements]</b></td>
<td class="top">
<a>Begen, A</a>, "<a href="http://tools.ietf.org/html/draft-ietf-fecframe-sdp-elements-11">Session Description Protocol Elements for FEC Framework</a>", Internet-Draft draft-ietf-fecframe-sdp-elements-11, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3711">[RFC3711]</b></td>
<td class="top">
<a>Baugher, M.</a>, <a>McGrew, D.</a>, <a>Naslund, M.</a>, <a>Carrara, E.</a> and <a>K. Norrman</a>, "<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>", RFC 3711, March 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5740">[RFC5740]</b></td>
<td class="top">
<a>Adamson, B.</a>, <a>Bormann, C.</a>, <a>Handley, M.</a> and <a>J. Macker</a>, "<a href="http://tools.ietf.org/html/rfc5740">NACK-Oriented Reliable Multicast (NORM) Transport Protocol</a>", RFC 5740, November 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5675">[RFC5675]</b></td>
<td class="top">
<a>Marinov, V.</a> and <a>J. Schoenwaelder</a>, "<a href="http://tools.ietf.org/html/rfc5675">Mapping Simple Network Management Protocol (SNMP) Notifications to SYSLOG Messages</a>", RFC 5675, October 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5676">[RFC5676]</b></td>
<td class="top">
<a>Schoenwaelder, J.</a>, <a>Clemm, A.</a> and <a>A. Karmakar</a>, "<a href="http://tools.ietf.org/html/rfc5676">Definitions of Managed Objects for Mapping SYSLOG Messages to Simple Network Management Protocol (SNMP) Notifications</a>", RFC 5676, October 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4303">[RFC4303]</b></td>
<td class="top">
<a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4383">[RFC4383]</b></td>
<td class="top">
<a>Baugher, M.</a> and <a>E. Carrara</a>, "<a href="http://tools.ietf.org/html/rfc4383">The Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Secure Real-time Transport Protocol (SRTP)</a>", RFC 4383, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5775">[RFC5775]</b></td>
<td class="top">
<a>Luby, M.</a>, <a>Watson, M.</a> and <a>L. Vicisano</a>, "<a href="http://tools.ietf.org/html/rfc5775">Asynchronous Layered Coding (ALC) Protocol Instantiation</a>", RFC 5775, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="MBMSTS">[MBMSTS]</b></td>
<td class="top">
<a>3GPP</a>, "<a>Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs</a>", 3GPP TS 26.346, April 2005.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mark Watson</span> 
	  <span class="n hidden">
		<span class="family-name">Watson</span>
	  </span>
	</span>
	<span class="org vcardline">Netflix, Inc.</span>
	<span class="adr">
	  <span>100 Winchester Circle</span>

	  <span class="vcardline">
		<span class="locality">Los Gatos</span>,  
		<span class="region">CA</span> 
		<span class="code">95032</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:watsonm@netflix.com">watsonm@netflix.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ali Begen</span> 
	  <span class="n hidden">
		<span class="family-name">Begen</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  <span>181 Bay Street</span>

	  <span class="vcardline">
		<span class="locality">Toronto</span>,  
		<span class="region">ON</span> 
		<span class="code">M5J 2T3</span>
	  </span>
	  <span class="country-name vcardline">Canada</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:abegen@cisco.com">abegen@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Vincent Roca</span> 
	  <span class="n hidden">
		<span class="family-name">Roca</span>
	  </span>
	</span>
	<span class="org vcardline">INRIA</span>
	<span class="adr">
	  <span>655, av. de l'Europe</span>
<span>Inovallee; Montbonnot</span>

	  <span class="vcardline">
		<span class="locality">ST ISMIER cedex</span>,  
		<span class="region"></span>
		<span class="code">38334</span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:vincent.roca@inria.fr">vincent.roca@inria.fr</a></span>

<span class="vcardline">URI: <a href="http://planete.inrialpes.fr/people/roca/">http://planete.inrialpes.fr/people/roca/</a></span>

  </address>
</div>

</body>
</html>