SERIAL_BITS = 32.

TaskReporting=FastAbort is operational on that third-party
TaskReporting=FastAbort functionality (Section 13.23), it may end up
TaskReporting=FastAbort operational (FastAbort sessions) even while
AsyncEvent=5 (Section 11.9) on each connection of each third-
key=value in the data part of a Login or Text Request or Response.
key=value in the data part of the following Login or Text Response or
Key=value pairs may span PDU boundaries.  An initiator or target that
key=value pair.

DataSegmentLength = 0

N = 2q + 1, where q is also prime) and the generator g is a primitive
ErrorRecoveryLevel=2 whenever there is a relatively high likelihood
ErrorRecoveryLevel=0.

key=value pairs of its own as part of a sequence and not only in
ErrorRecoveryLevel = 2
AuthMethod = <list-of-values>

KRB_AP_REQ=<KRB_AP_REQ>

KRB_AP_REP=<KRB_AP_REP>

SRP_U=<U> TargetAuth=Yes     /* or TargetAuth=No */

SRP_GROUP=<G1,G2...> SRP_s=<s>

SRP_A=<A> SRP_GROUP=<G>

SRP_B=<B>

SRP_M=<M>

SRP_HM=<H(A | M | K)>

CHAP_A=<A1,A2...>

CHAP_A=<A> CHAP_I=<I> CHAP_C=<C>

CHAP_N=<N> CHAP_R=<R>

CHAP_N=<N> CHAP_R=<R> CHAP_I=<I> CHAP_C=<C>

CHAP_N=<N> CHAP_R=<R>

HeaderDigest = <list-of-values>
DataDigest = <list-of-values>

MaxConnections=<numerical-value-from-1-to-65535>

TargetName=<iSCSI-name-value>

TargetName=iqn.1993-11.com.disk-vendor:diskarrays.sn.45678

TargetName=eui.020000023B040506

TargetName=naa.62004567BA64678D0123456789ABCDEF
InitiatorName=<iSCSI-name-value>

InitiatorName=iqn.1992-04.com.os-vendor.plan9:cdrom.12345

InitiatorName=iqn.2001-02.com.ssp.users:customer235.host90

InitiatorName=naa.52004567BA64678D

TargetAlias=<iSCSI-local-name-value>

TargetAlias=Bob-s Disk

TargetAlias=Database Server 1 Log Disk

TargetAlias=Web Server 3 Disk 20
InitiatorAlias=<iSCSI-local-name-value>

InitiatorAlias=Web Server 4

InitiatorAlias=spyalley.nsa.gov

InitiatorAlias=Exchange Server

TargetAddress=domainname[:port][,portal-group-tag]

TargetAddress=10.0.0.1:5003,1

TargetAddress=[1080:0:0:0:8:800:200C:417A],65

TargetAddress=[1080::8:800:200C:417A]:5003,1

TargetAddress=computingcenter.example.com,23

TargetPortalGroupTag=<16-bit-binary-value>

TargetPortalGroupTag=1

InitialR2T=<boolean-value>

Offset=Immediate Data Length and Desired Data Transfer
Length=(min(FirstBurstLength, Expected Data Transfer Length) -
ImmediateData=<boolean-value>

MaxRecvDataSegmentLength=<numerical-value-512-to-(2**24 - 1)>

MaxBurstLength=<numerical-value-512-to-(2**24 - 1)>

FirstBurstLength=<numerical-value-512-to-(2**24 - 1)>

DefaultTime2Wait=<numerical-value-0-to-3600>

DefaultTime2Retain=<numerical-value-0-to-3600>

MaxOutstandingR2T=<numerical-value-from-1-to-65535>
DataPDUInOrder=<boolean-value>

DataSequenceInOrder=<boolean-value>

ErrorRecoveryLevel=<numerical-value-0-to-2>

SessionType=<Discovery|Normal>

TaskReporting=<list-of-values>

InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=KRB5,SRP,None

AuthMethod=KRB5

KRB_AP_REQ=<krb_ap_req>

KRB_AP_REP=<krb_ap_rep>

MaxBurstLength=8192

InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=SRP,KRB5,None

AuthMethod=KRB5

KRB_AP_REQ=krb_ap_req

InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=KRB5,SRP,None

AuthMethod=SRP

SRP_U=<user>
TargetAuth=Yes

SRP_N=<N>
SRP_g=<g>
SRP_s=<s>

SRP_A=<A>

SRP_B=<B>

SRP_M=<M>

SRP_HM=<H(A | M | K)>

InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=KRB5,SRP,None

AuthMethod=SRP

SRP_U=<user>
TargetAuth=No

SRP_N=<N>
SRP_g=<g>
SRP_s=<s>

SRP_A=<A>

SRP_B=<B>

SRP_M=<M>
InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=KRB5,CHAP,None

AuthMethod=CHAP

CHAP_A=<A1,A2>

CHAP_A=<A1>
CHAP_I=<I>
CHAP_C=<C>

CHAP_N=<N>
CHAP_R=<R>
CHAP_I=<I>
CHAP_C=<C>
CHAP_N=<N>
CHAP_R=<R>

InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=KRB5,CHAP,None

AuthMethod=CHAP

CHAP_A=<A1,A2>
CHAP_A=<A1>
CHAP_I=<I>
CHAP_C=<C>

CHAP_N=<N>
CHAP_R=<R>

InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
InitiatorName=iqn.1999-07.com.os:hostid.77
TargetName=iqn.1999-07.com.example:diskarray.sn.88
AuthMethod=KRB5,SRP,None
AuthMethod=None

TargetName=<target-name-goes-here>

TargetAddress=<hostname-or-ipaddress>[:<tcp-port>],
      <portal-group-tag>

SendTargets=All

TargetName=iqn.1993-11.com.example:diskarray.sn.8675309

TargetName=iqn.1993-11.com.example:diskarray.sn.8675309

TargetAddress=10.1.0.45:3000,1

TargetAddress=10.1.1.45:3000,2

TargetName=iqn.1993-11.com.example:diskarray.sn.1234567

TargetAddress=10.1.0.45:3000,1

TargetAddress=10.1.1.45:3000,2

TargetName=iqn.1993-11.com.example:diskarray.sn.8675309

TargetAddress=10.1.0.45:3000,1

TargetAddress=10.1.1.46:3000,1

TargetAddress=10.1.0.47:3000,2

TargetAddress=10.1.1.48:3000,2

TargetAddress=10.1.1.49:3000,3

send-data-SNACK = TRUE;
LastRequiredDataSN = CurrentPDU.DataSN;
               } else {
             if (TCB.SoFarInOrder = TRUE) {
                 if (current DataSN is expected) {
                      Increment TCB.ExpectedDataSN.
                 } else {
                         TCB.SoFarInOrder = FALSE;
send-data-SNACK = TRUE;
send-data-SNACK = TRUE;
LastRequiredDataSN = CurrentPDU.DataSN - 1;
                  }
                  if (send-data-SNACK is TRUE and
                    task is not already considered failed) {
send-status-SNACK = TRUE;
send-recovery-R2T = TRUE;
send-recovery-R2T = TRUE;
send-recovery-R2T = TRUE;
snack-failure = FALSE;
snack-failure = TRUE;
snack-failure = TRUE;
send-status-SNACK = FALSE;
send-status-SNACK = TRUE;
send-status-SNACK = TRUE;
send-status-SNACK = FALSE;
send-status-SNACK = Evaluate-a-StatSN(Connection,
                                             CurrentPDU);
AffectedConnection = Connection;
NewConnection = Pick-A-Logged-In-Connection(Session);
NewConnection = Connection;
NewConnection = Pick-A-Logged-In-Connection(Session);
NewConnection =
                     CreateTransportConnection(Session.OtherEndInfo);
DifferentConnection =
                      Pick-A-Logged-In-Connection(Session);
                    Build-And-Send-Async(DifferentConnection,
                          DroppedConnection, DefaultTime2Wait,
                            DefaultTime2Retain);
Y = Yes (cleared/discarded/reset on the event specified in the row).
        Unless otherwise noted, the clearing action is only applicable
        for the issuing initiator port.

N = No (not affected on the event specified in the row, i.e., stays
        at previous value).

NA = Not Applicable or Not Defined.
                            +------+------+------+------+------+
                            |IT (1)|IC (2)|CT (5)|ST (6)|PP (7)|
     +----------------------+------+------+------+------+------+
     |connection failure (8)|Y     |Y     |N     |N     |Y     |
     +----------------------+------+------+------+------+------+
     |connection state      |NA    |NA    |Y     |N     |NA    |
     |timeout (9)           |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |session timeout/      |Y     |Y     |Y     |Y     |Y (14)|
     |closure/reinstatement |      |      |      |      |      |
     |(10)                  |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |session continuation  |NA    |NA    |N (11)|N     |NA    |
     |(12)                  |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |successful connection |Y     |Y     |Y     |N     |Y (13)|
     |close logout          |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |session failure (18)  |Y     |Y     |N     |N     |Y     |
     +----------------------+------+------+------+------+------+
     |successful recovery   |Y     |Y     |N     |N     |Y (13)|
     |Logout                |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |failed Logout         |Y     |Y     |N     |N     |Y     |
     +----------------------+------+------+------+------+------+
     |connection Login      |NA    |NA    |NA    |Y (15)|NA    |
     |(leading)             |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |connection Login      |NA    |NA    |N (11)|N     |Y     |
     |(non-leading)         |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |TARGET COLD RESET (16)|Y (20)|Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
     |TARGET WARM RESET (16)|Y (20)|Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
     |LU reset (19)         |Y (20)|Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
     |power cycle (16)      |Y     |Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+

     (1)  Incomplete TTTs (IT) are Target Transfer Tags on which the
          target is still expecting PDUs to be received.  Examples
          include TTTs received via R2T, NOP-In, etc.

     (2)  Immediate Commands (IC) are immediate commands, but waiting
          for execution on a target (for example, ABORT TASK SET).
     (5)  Connection Tasks (CT) are tasks that are active on the iSCSI
          connection in question.

     (6)  Session Tasks (ST) are tasks that are active on the entire
          iSCSI session.  A union of "connection tasks" on all
          participating connections.

     (7)  Partial PDUs (PP) (if any) are PDUs that are partially sent
          and waiting for transport window credit to complete the
          transmission.

     (8)  Connection failure is a connection exception condition - one
          of the transport connections shut down, transport connections
          reset, or transport connections timed out, which abruptly
          terminated the iSCSI Full Feature Phase connection.  A
          connection failure always takes the connection state machine
          to the CLEANUP_WAIT state.

     (9)  Connection state timeout happens if a connection spends more
          time than agreed upon during login negotiation in the
          CLEANUP_WAIT state, and this takes the connection to the FREE
          state (M1 transition in connection cleanup state diagram; see
          Section 8.2).

     (10) Session timeout, closure, and reinstatement are defined in
          Section 6.3.5.

     (11) This clearing effect is "Y" only if it is a connection
          reinstatement and the operational ErrorRecoveryLevel is less
          than 2.

     (12) Session continuation is defined in Section 6.3.6.

     (13) This clearing effect is only valid if the connection is being
          logged out on a different connection and when the connection
          being logged out on the target may have some partial PDUs
          pending to be sent.  In all other cases, the effect is "NA".

     (14) This clearing effect is only valid for a "close the session"
          logout in a multi-connection session.  In all other cases, the
          effect is "NA".

     (15) Only applicable if this leading connection login is a session
          reinstatement.  If this is not the case, it is "NA".

     (16) This operation affects all logged-in initiators.

     (18) Session failure is defined in Section 6.3.6.
     (19) This operation affects all logged-in initiators, and the
          clearing effects are only applicable to the LU being reset.

     (20) With standard multi-task abort semantics (Section 4.2.3.3), a
          TARGET WARM RESET or a TARGET COLD RESET or a LU reset would
          clear the active TTTs upon completion.  However, the FastAbort
          multi-task abort semantics defined by Section 4.2.3.4 do not
          guarantee that the active TTTs are cleared by the end of the
          reset operations.  In fact, the FastAbort semantics are
          designed to allow clearing the TTTs in a "lazy" fashion after
          the TMF Response is delivered.  Thus, when
TaskReporting=FastAbort (Section 13.23) is operational on a
