
Network Working Group                                           C. Davis
Internet Draft                                         Kapor Enterprises
Updates: RFCs 1034, 1035                                        P. Vixie
                                                       Vixie Enterprises
                                                              T. Goodwin
                                                                   PIPEX
                                                            I. Dickinson
                                                   University of Warwick
                                                           November 1994

 A Means for Expressing Location Information in the Domain Name System

Status of this Memo

   This document is an Internet-Draft.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as ``work in progress.''

   To learn the current status of any Internet-Draft, please check the
   ``1id-abstracts.txt'' listing contained in the Internet- Drafts
   Shadow Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),
   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or
   ftp.isi.edu (US West Coast).

1. Abstract

   This Internet-Draft describes a mechanism to allow the DNS to carry
   location information about hosts, networks, and subnets.  Such
   information for a small subset of hosts is currently contained in the
   flat-file UUCP maps.  However, just as the DNS replaced the use of
   HOSTS.TXT to carry host and network address information, it is
   possible to replace the UUCP maps as carriers of location
   information.

   This Internet-Draft defines the format of a new Resource Record (RR)
   for the Domain Name System (DNS), and reserves a corresponding DNS
   type mnemonic (LOC) and numerical code (29).

   This Internet-Draft assumes that the reader is familiar with the DNS
   [RFC 1034, RFC 1035].  The data shown in our examples is for
   pedagogical use and does not necessarily reflect the real Internet.




Davis, Vixie, Goodwin & Dickinson                               [Page 1]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


2. RDATA Format

       MSB                                           LSB
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      0|  VERSION  |   SIZE    | HORIZ PRE |  VERT PRE |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      2|                   LATITUDE                    |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      4|                   LATITUDE                    |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      6|                   LONGITUDE                   |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      8|                   LONGITUDE                   |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     10|                   ALTITUDE                    |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     12|                   ALTITUDE                    |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   (octet)

where:

VERSION      Version number of the representation.  This must be zero.
             Implementations are required to check this field and make
             no assumptions about the format of unrecognized versions.

SIZE         The size of the described entity, in log10(meters),
             expressed as a 4-bit integer, with 2^3 representing 0 and
             lower values representing negative numbers.  For hosts,
             this will often be zero (i.e. 1m).  Larger entities, such
             as multinational companies' domains, will use larger
             values.  The largest possible value is 7 and the smallest
             possible value is -7.  A value of all zero is prohibited.

HORIZ PRE    The horizontal precision of the data, in log10(meters),
             expressed as a 4-bit integer, with 2^3 representing 0 and
             lower values representing negative numbers.  This is
             treated as an "accurate to within N meters" value.  For
             example, if the latitude and longitude have been determined
             using differential GPS, this value would be 0 (i.e. 1m).
             If survey maps and building blueprints are used, the value
             might be 1 (i.e. 10m) or 2 (100m).  If standard values for
             a large area are used, the value could be as high as 6
             (100km).  The largest possible value is 7 and the smallest
             possible value is -7.  A value of all zero is prohibited.

VERT PRE     The vertical precision of the point described by the
             (LATITUDE, LONGITUDE, ALTITUDE) tuple, in log10(meters),



Davis, Vixie, Goodwin & Dickinson                               [Page 2]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


             expressed as a 4-bit integer, with 2^3 representing 0 and
             lower values representing negative numbers.  This is
             treated as an "accurate to within N meters" value.  The
             largest possible value is 7 and the smallest possible value
             is -7.  A value of all zero is prohibited.

LATITUDE     The latitude of the center of the sphere described by the
             SIZE field, expressed as a 32-bit integer, most significant
             octet first (network standard byte order), in thousandsth
             of a second of arc.  2^31 represents the equator; numbers
             above that are north latitude.

LONGITUDE    The longitude of the center of the sphere described by the
             SIZE field, expressed as a 32-bit integer, most significant
             octet first (network standard byte order), in thousandths
             of a second of arc, rounded away from the prime meridian.
             2^31 represents the prime meridian; numbers above that are
             east longitude.

ALTITUDE     The altitude of the center of the sphere described by the
             SIZE field, expressed as a 32-bit integer, most significant
             octet first (network standard byte order), in centimeters,
             from a base of 100,000m below the [WGS 84] reference
             spheroid used by GPS (semimajor axis a=6378137.0,
             reciprocal flattening rf=298.257223563).

3. Master File Format

   The LOC record is expressed in a master file in the following format:

   <owner> <TTL> <class> LOC ( d1 [m1 [s1]] {"N"|"S"} d2 [m2 [s2]]
                               {"E"|"W"} alt["m"] [siz["m"] [hp["m"]
                               [vp["m"]]]] )

   (The parentheses are used for multi-line data as specified in [RFC
   1035] section 5.1.)

   where:

       d1:          [0 .. 90]       (degrees latitude)
       d2:          [0 .. 180]      (degrees longitude)
       m1, m2:      [0 .. 59]       (minutes latitude/longitude)
       s1, s2:      [0 .. 59.999]   (seconds latitude/longitude)
       alt:         [-100000.00 .. 42939672.96] BY .1 (altitude in
   meters)
       siz, hp, vp: "0.0000001" | "0.000001" | "0.00001" | "0.0001" |
                     "0.001" | "0.01" | "0.1" | "1" | "10" | "100" |
                     "1000" | "10000" | "100000" | "1000000" |



Davis, Vixie, Goodwin & Dickinson                               [Page 3]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


                     "10000000" (size/precision in meters)

   If omitted, minutes and seconds default to zero, size defaults to 1m,
   horizontal precision defaults to 10000m, and vertical precision
   defaults to 10m.  These defaults are chosen to represent typical
   ZIP/postal code area sizes, since it is often easy to find
   approximate geographical location by ZIP/postal code.

4. Application use of the LOC RR

4.1 Suggested Uses

   Some uses for the LOC RR have already been suggested, including the
   USENET backbone flow maps, a "visual traceroute" application showing
   the geographical path of an IP packet, and network management
   applications that could use LOC RRs to generate a map of hosts and
   routers being managed.

4.2 Search Algorithms

   This section specifies how to use the DNS to translate domain names
   and/or IP addresses into location information.

   If an application wishes to have a "fallback" behavior, displaying a
   less precise or larger area when a host does not have an associated
   LOC RR, it MAY support use of the algorithm in section 4.2.3, as
   noted in sections 4.2.1 and 4.2.2.  If fallback is desired, this
   behaviour is the RECOMMENDED default, but in some cases it may need
   to be modified based on the specific requirements of the application
   involved.

   This search algorithm is designed to allow network administrators to
   specify the location of a network or subnet without requiring LOC RR
   data for each individual host.  For example, a computer lab with 24
   workstations, all of which are on the same subnet and in basically
   the same location, would only need a LOC RR for the subnet.
   (However, if the file server's location has been more precisely
   measured, a separate LOC RR for it can be placed in the DNS.)

4.2.1 Searching by Name

   If the application is beginning with a name, rather than an IP
   address (as the USENET backbone flow maps do), it MUST check for a
   LOC RR associated with that name.  (CNAME records should be followed
   as for any other RR type.)

   If there is no LOC RR for that name, all A records (if any)
   associated with the name MAY be checked for network (or subnet) LOC



Davis, Vixie, Goodwin & Dickinson                               [Page 4]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


   RRs using the "Searching by Network or Subnet" algorithm (4.2.3).  If
   multiple A records exist and have associated network or subnet LOC
   RRs, the application may choose to use any, some, or all of the LOC
   RRs found, possibly in combination.  It is suggested that multi-homed
   hosts have LOC RRs for their name in the DNS to avoid any ambiguity
   in these cases.

   Note that domain names that do not have associated A records must
   have a LOC RR associated with their name in order for location
   information to be accessible.

4.2.2 Searching by Address

   If the application is beginning with an IP address (as a "visual
   traceroute" application might be) it MUST first map the address to a
   name using the IN-ADDR.ARPA namespace (see [RFC 1034], section
   5.2.1), then check for a LOC RR associated with that name.

   If there is no LOC RR for the name, the address MAY be checked for
   network (or subnet) LOC RRs using the "Searching by Network or
   Subnet" algorithm (4.2.3).

4.2.3 Searching by Network or Subnet

   Even if a host's name does not have any associated LOC RRs, the
   network(s) or subnet(s) it is on may.  If the application wishes to
   search for such less specific data, the following algorithm SHOULD be
   followed to find a network or subnet LOC RR associated with the IP
   address.  This algorithm is adapted slightly from that specified in
   [RFC 1101], sections 4.3 and 4.4.

   Since subnet LOC RRs are (if present) more specific than network LOC
   RRs, it is best to use them if available.  In order to do so, we
   build a stack of network and subnet names found while performing the
   [RFC 1101] search, then work our way down the stack until a LOC RR is
   found.

   1. create a host-zero address using the network portion of the IP
      address (one, two, or three bytes for class A, B, or C networks,
      respectively).  For example, for the host 128.9.2.17, on the class
      B network 128.9, this would result in the address "128.9.0.0".

   2. Reverse the octets, suffix IN-ADDR.ARPA, and query for PTR and A
      records.  Retrieve:

               0.0.9.128.IN-ADDR.ARPA.  PTR    isi-net.isi.edu.
                                        A      255.255.255.0




Davis, Vixie, Goodwin & Dickinson                               [Page 5]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


      Push the name "isi-net.isi.edu" onto the stack of names to be
      searched for LOC RRs later.

   3. Since an A RR was found, repeat using mask from RR
      (255.255.255.0), constructing a query for 0.2.9.128.IN-ADDR.ARPA.
      Retrieve:

               0.2.9.128.IN-ADDR.ARPA.  PTR    div2-subnet.isi.edu.
                                        A      255.255.255.240

      Push the name "div2-subnet.isi.edu" onto the stack of names to be
      searched for LOC RRs later.

   4. Since another A RR was found, repeat using mask 255.255.255.240
      (x'FFFFFFF0'), constructing a query for 16.2.9.128.IN-ADDR.ARPA.
      Retrieve:

               16.2.9.128.IN-ADDR.ARPA. PTR    inc-subsubnet.isi.edu.

      Push the name "inc-subsubnet.isi.edu" onto the stack of names to
      be searched for LOC RRs later.

   5. Since no A RR is present at 16.2.9.128.IN-ADDR.ARPA., there are no
      more subnet levels to search.  We now pop the top name from the
      stack and check for an associated LOC RR.  Repeat until a LOC RR
      is found.

      In this case, assume that inc-subsubnet.isi.edu does not have an
      associated LOC RR, but that div2-subnet.isi.edu does.  We will
      then use div2-subnet.isi.edu's LOC RR as an approximation of this
      host's location.  (Note that even if isi-net.isi.edu has a LOC RR,
      it will not be used if a subnet also has a LOC RR.)

4.3 Applicability to non-IN Classes and non-IP Addresses

   The LOC record is defined for all RR classes, and may be used with
   non-IN classes such as HS and CH.  The semantics of such use are not
   defined by this memo.

   The search algorithm in section 4.2.3 may be adapted to other
   addressing schemes by extending [RFC 1101]'s encoding of network
   names to cover those schemes.  Such extensions are not defined by
   this memo.

5. References

   [RFC 1034] Mockapetris, P., "Domain Names - Concepts and Facilities",
              STD 13, RFC 1034, USC/Information Sciences Institute,



Davis, Vixie, Goodwin & Dickinson                               [Page 6]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


              November 1987.

   [RFC 1035] Mockapetris, P., "Domain Names - Implementation and
              Specification", STD 13, RFC 1035, USC/Information Sciences
              Institute, November 1987.

   [RFC 1101] Mockapetris, P., "DNS Encoding of Network Names and Other
              Types", RFC 1101, USC/Information Sciences Institute,
              April 1989.

   [WGS 84] United States Department of Defense; DoD WGS-1984 - Its
              Definition and Relationships with Local Geodetic Systems;
              Washington, D.C.; 1985; Report AD-A188 815 DMA; 6127; 7-
              R-138-R; CV, KV;

6. Security Considerations

   High-precision LOC RR information could be used to help plan a
   penetration of physical security, leading to potential denial-of-
   machine attacks.  To avoid any appearance of suggesting this method
   to potential attackers, we declined the opportunity to name this RR
   "ICBM".

7. Authors' Addresses

   Christopher Davis
   Kapor Enterprises, Inc.
   238 Main Street, Suite 400
   Cambridge, MA 02142

   Phone: +1 617 576 4532

   Email: ckd@kei.com


   Paul Vixie
   Vixie Enterprises
   Star Route Box 159A
   Woodside, CA 94062

   Phone: +1 415 747 0204

   Email: paul@vix.com


   Tim Goodwin
   Public IP Exchange Ltd (PIPEX)
   216 The Science Park



Davis, Vixie, Goodwin & Dickinson                               [Page 7]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


   Cambridge CB4 4WA
   UK

   Phone: +44 1223 250250

   Email: tim@pipex.net


   Ian Dickinson
   Computing Services
   University of Warwick
   Coventry CV4 7AL
   UK

   Phone: +44 1203 524217

   Email: cudep@csv.warwick.ac.uk

Appendix A: Sample Conversion Routines

   These routines are the ones used in BIND 4.9.3 for conversion between
   zone file and RDATA formats.

/*
 * loc_rr.c.  includes routines to convert between on-the-wire RR format
 * and zone file format.  Does not contain conversion to/from decimal
 * degrees; divide or multiply by 60*60*1000 for that.
 */

#include <stdlib.h>             /* abort() */
#include <sys/param.h>
#include <netinet/in.h>         /* ntohl/htonl */
#include <arpa/nameser.h>       /* for PUTLONG, bit types if needed */

#include "../conf/portability.h"

/* "signed" version of ntohl.  host 0 = net (1<<31) */
static int32_t
ntohls(x)
        u_int32_t x;
{
        return (ntohl(x) - (1<<31));
}

/* "signed" version of htonl.  host 0 = net (1<<31) */
static u_int32_t
htonls(x)
        int32_t x;



Davis, Vixie, Goodwin & Dickinson                               [Page 8]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


{
        return (htonl(x) + (1<<31));
}

/* takes a log10 precision value, returns a string representation. */
static const char *
precision2string(precval)
        int8_t precval;
{
        switch (precval) {
        case -7:
                return ("0.0000001");
        case -6:
                return ("0.000001");
        case -5:
                return ("0.00001");
        case -4:
                return ("0.0001");
        case -3:
                return ("0.001");
        case -2:
                return ("0.01");
        case -1:
                return ("0.1");
        case 0:
                return ("1");
        case 1:
                return ("10");
        case 2:
                return ("100");
        case 3:
                return ("1000");
        case 4:
                return ("10000");
        case 5:
                return ("100000");
        case 6:
                return ("1000000");
        case 7:
                return ("10000000");
        default:
                return ("1");   /* XXX error checking? */
        }
        /* NOTREACHED */
        abort();
}

/* converts lat/lon to unsigned encoded 32-bit number.  moves pointer. */



Davis, Vixie, Goodwin & Dickinson                               [Page 9]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


static u_int32_t
latlon2ul(latlonstrptr)
        char **latlonstrptr;
{
        register char *cp;
        u_int32_t retval;
        int deg = 0, min = 0, secs = 0, secsfrac = 0;

        cp = *latlonstrptr;

        while (isdigit(*cp))
                deg = deg * 10 + (*cp++ - '0');

        while (isspace(*cp))
                cp++;

        if (!(isdigit(*cp)))
                goto fndhemi;

        while (isdigit(*cp))
                min = min * 10 + (*cp++ - '0');

        while (isspace(*cp))
                cp++;

        if (!(isdigit(*cp)))
                goto fndhemi;

        while (isdigit(*cp))
                secs = secs * 10 + (*cp++ - '0');

        if (*cp == '.') {               /* decimal seconds */
                cp++;
                if (isdigit(*cp)) {
                        secsfrac = (*cp++ - '0') * 100;
                        if (isdigit(*cp)) {
                                secsfrac += (*cp++ - '0') * 10;
                                if (isdigit(*cp)) {
                                        secsfrac += (*cp++ - '0');
                                }
                        }
                }
        }

        while (isspace(*cp))
                cp++;

 fndhemi:



Davis, Vixie, Goodwin & Dickinson                              [Page 10]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


        switch (*cp) {
        case 'N': case 'n':
        case 'E': case 'e':
                retval = (1<<31)
                        + (((((deg * 60) + min) * 60) + secs) * 1000)
                        + secsfrac;
                break;
        case 'S': case 's':
        case 'W': case 'w':
                retval = (1<<31)
                        - (((((deg * 60) + min) * 60) + secs) * 1000)
                        - secsfrac);
                break;
        default:
                /* XXX error checking? */
                break;
        }

        cp++;                   /* skip the hemisphere */

        while (isspace(*cp))    /* move to next field */
                cp++;

        *latlonstrptr = cp;

        return (retval);
}

/* converts a zone file representation in a string to an RDATA on-the-wire
 * representation. */
u_int
loc_aton(ascii, binary)
        const char *ascii;
        u_char *binary;
{
        char *cp,*maxcp;
        u_char *bcp;

        u_int32_t latit = 0, longit = 0, alt = 0;
        int altmeters = 0, altfrac = 0, altsign = 1;
        int hp = 4;                     /* default = 10000m or 10km */
        int vp = 1;                     /* default = 10m */
        int siz = 0;                    /* default = 1m */

        cp = ascii;
        maxcp = cp + strlen(ascii);

        latit = latlon2ul(&cp);



Davis, Vixie, Goodwin & Dickinson                              [Page 11]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


        longit = latlon2ul(&cp);

        /* altitude */
        if (*cp == '-') {
                altsign = -1;
                cp++;
        }

        if (*cp == '+')
                cp++;

        while (isdigit(*cp))
                altmeters = altmeters * 10 + (*cp++ - '0');

        if (*cp == '.') {               /* decimal meters */
                cp++;
                if (isdigit(*cp)) {
                        altfrac = (*cp++ - '0') * 10;
                        if (isdigit(*cp)) {
                                altfrac += (*cp++ - '0');
                        }
                }
        }

        alt = (10000000 + (altsign * (altmeters * 100 + altfrac)));

        while (isspace(*cp) || (*cp == 'm') || (*cp == 'M'))
                cp++;

        if (cp >= maxcp)
                goto defaults;

        siz = 0;

        /* get log10s for hp, vp, siz */

        /* size */
        if (*cp == '1') {               /* positive or 0 log */
                for (cp++; *cp == '0'; cp++)
                        siz++;
        } else if (*cp == '0') {        /* negative log */
                for (cp++; *cp != '1'; cp++)
                        siz--;
        }

        cp++;

        while (isspace(*cp) || *cp == 'm' || *cp == 'M')



Davis, Vixie, Goodwin & Dickinson                              [Page 12]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


                cp++;

        if (cp >= maxcp)
                goto defaults;

        hp = 0;

        /* horiz precision */
        if (*cp == '1') {               /* positive or 0 log */
                for (cp++; *cp == '0'; cp++)
                        hp++;
        } else if (*cp == '0') {        /* negative log */
                for (cp++; *cp != '1'; cp++)
                        hp--;
        }

        cp++;

        while (isspace(*cp) || *cp == 'm' || *cp == 'M')
                cp++;

        if (cp >= maxcp)
                goto defaults;

        vp = 0;

        /* vertical precision */
        if (*cp == '1') {               /* positive or 0 log */
                for (cp++; *cp == '0'; cp++)
                        vp++;
        } else if (*cp == '0') {        /* negative log */
                for (cp++; *cp != '1'; cp++)
                        vp--;
        }

 defaults:

        if ((hp > 7) || (hp < -7))
                return (0);

        if ((vp > 7) || (vp < -7))
                return (0);

        if ((siz > 7) || (siz < -7))
                return (0);

        /* convert hp/vp/siz sign bits as with lat/long */
        hp += 8;



Davis, Vixie, Goodwin & Dickinson                              [Page 13]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


        vp += 8;
        siz += 8;

        bcp = binary;
        *bcp++ = (u_int8_t) siz;
        *bcp++ = (u_int8_t) ((hp << 4) + vp);
        PUTLONG(latit,bcp);
        PUTLONG(longit,bcp);
        PUTLONG(alt,bcp);

        return (14);
}

/* takes an on-the-wire LOC RR and prints it in zone file (human readable)
   format. */
char *
loc_ntoa(binary,ascii)
        const u_char *binary;
        char *ascii;
{
        char tmpbuf[255*3];

        register char *cp;
        register u_char *rcp;

        int latdeg, latmin, latsec, latsecfrac;
        int longdeg, longmin, longsec, longsecfrac;
        char northsouth, eastwest;
        int altmeters, altfrac;

        int32_t latval, longval, altval;
        u_int32_t templ;
        char sizeval, hpval, vpval, versionval, tempc;

        char *sizestr, *hpstr, *vpstr;

        rcp = binary;
        if (ascii)
                cp = ascii;
        else {
                ascii = tmpbuf;
                cp = tmpbuf;
        }

        tempc = *rcp++;

        versionval = tempc & 0xF0;
        sizeval = (tempc & 0x0F) - 8;



Davis, Vixie, Goodwin & Dickinson                              [Page 14]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


        if (versionval) {
                sprintf(cp,"; error: unknown LOC RR version");
                return (cp);
        }

        tempc = *rcp++;

        hpval = ((tempc & 0xF0) >> 4) - 8;
        vpval = (tempc & 0x0F) - 8;

        GETLONG(templ,rcp);
        latval = ntohls(templ);

        GETLONG(templ,rcp);
        longval = ntohls(templ);

        GETLONG(templ,rcp);
        altval = ntohl(templ) - 10000000; /* XXX might need long long */

        if (latval < 0) {
                northsouth = 'S';
                latval = -latval;
        }
        else
                northsouth = 'N';

        latsecfrac = latval % 1000;
        latval = latval / 1000;
        latsec = latval % 60;
        latval = latval / 60;
        latmin = latval % 60;
        latval = latval / 60;
        latdeg = latval;

        if (longval < 0) {
                eastwest = 'W';
                longval = -longval;
        }
        else
                eastwest = 'E';

        longsecfrac = longval % 1000;
        longval = longval / 1000;
        longsec = longval % 60;
        longval = longval / 60;
        longmin = longval % 60;
        longval = longval / 60;
        longdeg = longval;



Davis, Vixie, Goodwin & Dickinson                              [Page 15]

Expires 1994-05-25     draft-davis-dns-loc-00.txt          November 1994


        altfrac = altval % 100;
        altmeters = altval / 100;  /* XXX might truncate wrong way if neg? */

        sizestr = strdup(precision2string(sizeval));
        hpstr = strdup(precision2string(hpval));
        vpstr = strdup(precision2string(vpval));

        sprintf(cp,
                "%d %.2d %.2d.%.3d %c %d %.2d %.2d.%.3d %c %d.%dm %sm %sm %sm",
                latdeg, latmin, latsec, latsecfrac, northsouth,
                longdeg, longmin, longsec, longsecfrac, eastwest,
                altmeters, altfrac, sizestr, hpstr, vpstr);

        free(sizestr);
        free(hpstr);
        free(vpstr);

        return (cp);
}
































Davis, Vixie, Goodwin & Dickinson                              [Page 16]


