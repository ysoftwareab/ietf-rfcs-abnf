<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Coupled Congestion Control for Multipath Transport Protocols</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Requirements Language">
<link href="#rfc.section.2" rel="Chapter" title="2 Introduction">
<link href="#rfc.section.3" rel="Chapter" title="3 Coupled Congestion Control Algorithm">
<link href="#rfc.section.4" rel="Chapter" title="4 Implementation Considerations">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Computing alpha in Practice">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Implementation Considerations when CWND is Expressed in Packets">
<link href="#rfc.section.5" rel="Chapter" title="5 Discussion">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="Often endpoints are connected by multiple paths, but communications are usually restricted to a single path per connection. Resource usage within the network would be more efficient were it possible for these multiple paths to be used concurrently.  Multipath TCP is a proposal to achieve multipath transport in TCP." />
  <meta name="description" content="Often endpoints are connected by multiple paths, but communications are usually restricted to a single path per connection. Resource usage within the network would be more efficient were it possible for these multiple paths to be used concurrently.  Multipath TCP is a proposal to achieve multipath transport in TCP." />
  <meta name="keywords" content="multipath tcp congestion control" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">C. Raiciu</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">University Politehnica of Bucharest</td>
</tr>
<tr>
<td class="left">Intended status: Experimental Protocol</td>
<td class="right">M. Handley</td>
</tr>
<tr>
<td class="left">Expires: January 30, 2012</td>
<td class="right">D. Wischik</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University College London</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 29, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Coupled Congestion Control for Multipath Transport Protocols<br />
  <span class="filename">draft-ietf-mptcp-congestion-07</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Often endpoints are connected by multiple paths, but communications are usually restricted to a single path per connection. Resource usage within the network would be more efficient were it possible for these multiple paths to be used concurrently.  Multipath TCP is a proposal to achieve multipath transport in TCP.</p>
<p>New congestion control algorithms are needed for multipath transport protocols such as Multipath TCP, as single path algorithms have a series of issues in the multipath context.  One of the prominent problems is that running existing algorithms such as standard TCP independently on each path would give the multipath flow more than its fair share at a bottleneck link traversed by more than one of its subflows.  Further, it is desirable that a source with multiple paths available will transfer more traffic using the least congested of the paths, achieving a property called resource pooling where a bundle of links effectively behaves like one shared link with bigger-capacity.  This would increase the overall efficiency of the network and also its robustness to failure.</p>
<p>This document presents a congestion control algorithm which couples the congestion control algorithms running on different subflows by linking their increase functions, and dynamically controls the overall aggressiveness of the multipath flow. The result is a practical algorithm that is fair to TCP at bottlenecks while moving traffic away from congested links. </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 30, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Requirements Language</a>
</li>
<li>2.   <a href="#rfc.section.2">Introduction</a>
</li>
<li>3.   <a href="#rfc.section.3">Coupled Congestion Control Algorithm</a>
</li>
<li>4.   <a href="#rfc.section.4">Implementation Considerations</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Computing alpha in Practice</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Implementation Considerations when CWND is Expressed in Packets</a>
</li>
<li>5.   <a href="#rfc.section.5">Discussion</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Requirements Language</h1>
<p id="rfc.section.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite> .</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#sec_intro" id="sec_intro">Introduction</a>
</h1>
<p id="rfc.section.2.p.1">Multipath TCP (MPTCP, <a href="#I-D.ietf-mptcp-multiaddressed">[I-D.ietf-mptcp-multiaddressed]</a>) is a set of extensions to regular TCP <a href="#RFC0793">[RFC0793]</a> that allows one TCP connection to be spread across multiple paths. MPTCP distributes load through the creation of separate "subflows" across potentially disjoint paths.</p>
<p id="rfc.section.2.p.2">How should congestion control be performed for multipath TCP? First, each subflow must have its own congestion control state (i.e. cwnd) so that capacity on that path is matched by offered load.  The simplest way to achieve this goal is to simply run standard TCP congestion control on each subflow. However this solution is unsatisfactory as it gives the multipath flow an unfair share when the paths taken by its different subflows share a common bottleneck.</p>
<p id="rfc.section.2.p.3">Bottleneck fairness is just one requirement multipath congestion control should meet. The following three goals capture the desirable properties of a practical multipath congestion control algorithm: </p>

<ul>
<li>Goal 1 (Improve Throughput) A multipath flow should perform at least as well as a single path flow would on the best of the paths available to it. </li>
<li>Goal 2 (Do no harm) A multipath flow should not take up more capacity from any of the resources shared by its different paths, than if it was a single flow using only one of these paths.  This guarantees it will not unduly harm other flows.</li>
<li>Goal 3 (Balance congestion) A multipath flow should move as much traffic as possible off its most congested paths, subject to meeting the first two goals.</li>
</ul>

<p> </p>
<p id="rfc.section.2.p.4">Goals 1 and 2 together ensure fairness at the bottleneck. Goal 3 captures the concept of resource pooling <a href="#WISCHIK">[WISCHIK]</a>: if each multipath flow sends more data through its least congested path, the traffic in the network will move away from congested areas. This improves robustness and overall throughput, among other things.  The way to achieve resource pooling is to effectively "couple" the congestion control loops for the different subflows.  </p>
<p id="rfc.section.2.p.5">We propose an algorithm that couples the additive increase function of the subflows, and uses unmodified TCP behavior in case of a drop. The algorithm relies on the traditional TCP mechanisms to detect drops, to retransmit data, etc.</p>
<p id="rfc.section.2.p.6">Detecting shared bottlenecks reliably is quite difficult, but is just one part of a bigger question.  This bigger question is how much bandwidth a multipath user should use in total, even if there is no shared bottleneck.</p>
<p id="rfc.section.2.p.7">The congestion controller aims to set the multipath flow's aggregate bandwidth to be the same as a regular TCP flow would get on the best path available to the multipath flow.  To estimate the bandwidth of a regular TCP flow, the multipath flow estimates loss rates and round trip times and computes the target rate. Then it adjusts the overall aggresiveness (parameter alpha) to achieve the desired rate.  </p>
<p id="rfc.section.2.p.8">While the mechanism above applies always, its effect depends on whether the multipath TCP flow influences or does not influence the link loss rates (low vs. high statistical multiplexing).  If MPTCP does not influence link loss rates, MPTCP will get the same throughput as TCP on the best path.  In cases with low statistical multiplexing, where the multipath flow influences the loss rates on the path, the multipath throughput will be strictly higher than a single TCP would get on any of the paths.  In particular, if using two idle paths, multipath throughput will be sum of the two paths' throughput.</p>
<p id="rfc.section.2.p.9">This algorithm ensures bottleneck fairness and fairness in the broader, network sense.  We acknowledge that current TCP fairness criteria are far from ideal, but a multipath TCP needs to be deployable in the current Internet. If needed, new fairness criteria can be implemented by the same algorithm we propose by appropriately scaling the overall aggressiveness.</p>
<p id="rfc.section.2.p.10">It is intended that the algorithm presented here can be applied to other multipath transport protocols, such as alternative multipath extensions to TCP, or indeed any other congestion-aware transport protocols. However, for the purposes of example this document will, where appropriate, refer to the MPTCP protocol.</p>
<p id="rfc.section.2.p.11">The design decisions and evaluation of the congestion control algorithm are published in <a href="#NSDI">[NSDI]</a>.  </p>
<p id="rfc.section.2.p.12">The algorithm presented here only extends standard TCP congestion control for multipath operation.  It is foreseeable that other congestion controllers will be implemented for multipath transport to achieve the bandwidth-scaling properties of the newer congestion control algorithms for regular TCP (such as Compound TCP and Cubic). </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#sec_cc" id="sec_cc">Coupled Congestion Control Algorithm</a>
</h1>
<p id="rfc.section.3.p.1">The algorithm we present only applies to the increase phase of the congestion avoidance state specifying how the window inflates upon receiving an ack.  The slow start, fast retransmit, and fast recovery algorithms, as well as the multiplicative decrease of the congestion avoidance state are the same as in standard TCP<a href="#RFC5681">[RFC5681]</a>.</p>
<p id="rfc.section.3.p.2">Let cwnd_i be the congestion window on the subflow i. Let tot_cwnd be the sum of the congestion windows of all subflows in the connection.  Let p_i, rtt_i and mss_i be the loss rate, round trip time (i.e. smoothed round trip time estimate used by TCP) and maximum segment size on subflow i. </p>
<p id="rfc.section.3.p.3">We assume throughout this document that the congestion window is maintained in bytes, unless otherwise specified. We briefly describe the algorithm for packet-based implementations of cwnd in section <a href="#sec_impl_packet">Section 4.2</a>.  </p>
<div id="#rfc.figure.1"></div>
<pre>           
               alpha * bytes_acked * mss_i   bytes_acked * mss_i
         min ( --------------------------- , ------------------- )  (1)
                        tot_cwnd                   cwnd_i
            </pre>
<p id="rfc.section.3.p.4">Our proposed "Linked Increases" algorithm MUST: </p>

<ul><li>For each ack received on subflow i, increase cwnd_i by </li></ul>

<p> </p>
<p id="rfc.section.3.p.5">The increase formula (1) takes the minimum between the computed increase for the multipath subflow (first argument to min), and the increase TCP would get in the same scenario (the second argument).  In this way, we ensure that any multipath subflow cannot be more aggressive than a TCP flow in the same circumstances, hence achieving goal 2 (do no harm).  </p>
<p id="rfc.section.3.p.6">"alpha" is a parameter of the algorithm that describes the aggresiveness of the multipath flow.  To meet Goal 1 (improve throughput), the value of alpha is chosen such that the aggregate throughput of the multipath flow is equal to the throughput a TCP flow would get if it ran on the best path. </p>
<p id="rfc.section.3.p.7">To get an intuition of what the algorithm is trying to do, let's take the case where all the subflows have the same round trip time and MSS. In this case the algorithm will grow the total window by approximately alpha*MSS per RTT.  This increase is distributed to the individual flows according to their instantaneous window size.  Subflow i will increase by alpha*cwnd_i/tot_cwnd segments per RTT.</p>
<p id="rfc.section.3.p.8">Note that, as in standard TCP, when tot_cwnd is large the increase may be 0. In this case the increase MUST be set to 1. We discuss how to implement this formula in practice in the next section. </p>
<p id="rfc.section.3.p.9">We assume implementations use an approach similar to appropriate byte counting (ABC, <a href="#RFC3465">[RFC3465]</a>), where the bytes_acked variable records the number of bytes newly acknowledged. If this is not the case, bytes_acked SHOULD be set to mss_i.</p>
<p id="rfc.section.3.p.10">To compute tot_cwnd, it is an easy mistake to sum up cwnd_i across all subflows: when a flow is in fast retransmit, its cwnd is typically inflated and no longer represents the real congestion window. The correct behavior is to use the ssthresh value for flows in fast retransmit when computing tot_cwnd. To cater for connections that are app limited, the computation should consider the minimum between flight_size_i and cwnd_i, and flight_size_i and ssthresh_i where appropriate.  </p>
<p id="rfc.section.3.p.11">The total throughput of a multipath flow depends on the value of alpha and the loss rates, maximum segment sizes and round trip times of its paths. Since we require that the total throughput is no worse than the throughput a single TCP would get on the best path, it is impossible to choose a-priori a single value of alpha that achieves the desired throughput in every occasion. Hence, alpha must be computed based on the observed properties of the paths. </p>
<p id="rfc.section.3.p.12">The formula to compute alpha is: </p>
<div id="#rfc.figure.2"></div>
<pre>           
	                           cwnd_i 
	                      max --------
			       i         2
			           rtt_i
	  alpha = tot_cwnd * ----------------               (2)
	                    /      cwnd_i \ 2
	                    | sum ---------|
			    \  i   rtt_i  /

            </pre>
<p id="rfc.section.3.p.13">The formula (2) is derived by equalizing the rate of the multipath flow with the rate of a TCP running on the best path, and solving for alpha.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Implementation Considerations</h1>
<p id="rfc.section.4.p.1">Equation (2) implies that alpha is a floating point value. This would require performing costly floating point operations whenever an ACK is received, Further, in many kernels floating point operations are disabled. There is an easy way to approximate the above calculations using integer arithmetic.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Computing alpha in Practice</h1>
<p id="rfc.section.4.1.p.1">Let alpha_scale be an integer. When computing alpha, use alpha_scale * tot_cwnd instead of tot_cwnd, and do all the operations in integer arithmetic. </p>
<div id="#rfc.figure.3"></div>
<pre>           
               alpha * bytes_acked * mss_i   bytes_acked * mss_i
         min ( --------------------------- , ------------------- )  (3)
                alpha_scale * tot_cwnd              cwnd_i
            </pre>
<p id="rfc.section.4.1.p.2">Then, scale down the increase per ack by alpha_scale. The resulting algorithm is a simple change from Equation (1): </p>

<ul><li>For each ack received on subflow i, increase cwnd_i by </li></ul>

<p> </p>
<p id="rfc.section.4.1.p.3">The alpha_scale parameter denotes the precision we want for computing alpha.  Observe that the errors in computing the numerator or the denominator in the formula for alpha are quite small, as the cwnd in bytes is typically much larger than the RTT (measured in ms). </p>
<p id="rfc.section.4.1.p.4">With these changes, all the operations can be done using integer arithmetic. We propose alpha_scale be a small power of two, to allow using faster shift operations instead of multiplication and division.  Our experiments show that using alpha_scale=512 works well in a wide range of scenarios.  Increasing alpha_scale increases precision, but also increases the risk of overflow when computing alpha.  Using 64bit operations would solve this issue. Another option is to dynamically adjust alpha_scale when computing alpha; in this way we avoid overflow and obtain maximum precision.  </p>
<p id="rfc.section.4.1.p.5">It is possible to implement the algorithm by calculating tot_cwnd on each ack, however this would be costly especially when the number of subflows is large. To avoid this overhead the implementation MAY choose to maintain a new per connection state variable called tot_cwnd. If it does so, the implementation will update tot_cwnd value whenever the individual subflows' windows are updated.  Updating only requires one more addition or subtraction operation compared to the regular, per subflow congestion control code, so its performance impact should be minimal. </p>
<p id="rfc.section.4.1.p.6">Computing alpha per ack is also costly. We propose alpha to be a per connection variable, computed whenever there is a drop and once per RTT otherwise. More specifically, let cwnd_new be the new value of the congestion window after it is inflated or after a drop.  Update alpha only if the quotient of cwnd_i/mss_i differs from the quotient of cwnd_new_i/mss_i.  </p>
<p id="rfc.section.4.1.p.7">In certain cases with small RTTs, computing alpha can still be expensive. We observe that if RTTs were constant, it is sufficient to compute alpha once per drop, as alpha does not change between drops (the insight here is that cwnd_i/cwnd_j = constant as long as both windows increase). Experimental results show that even if round trip times are not constant, using average round trip time per sawtooth instead of instantaneous round trip time (i.e. TCP's smoothed RTT estimator) gives good precision for computing alpha. Hence, it is possible to compute alpha only once per drop using a modified version of equation (2) where rtt_i is replaced with rtt_avg_i.  </p>
<p id="rfc.section.4.1.p.8">If using average round trip time, rtt_avg_i will be computed by sampling the rtt_i whenever the window can accommodate one more packet, i.e.  when cwnd / mss &lt; (cwnd+increase)/mss. The samples are averaged once per sawtooth into rtt_avg_i.  This sampling ensures that there is no sampling bias for larger windows.</p>
<p id="rfc.section.4.1.p.9">Given tot_cwnd and alpha, the congestion control algorithm is run for each subflow independently, with similar complexity to the standard TCP increase code <a href="#RFC5681">[RFC5681]</a>. </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#sec_impl_packet" id="sec_impl_packet">Implementation Considerations when CWND is Expressed in Packets</a>
</h1>
<p id="rfc.section.4.2.p.1">When the congestion control algorithm maintains cwnd in packets rather than bytes, the algorithms above must change to take into account path mss.  </p>
<p id="rfc.section.4.2.p.2">To compute the increase when an ack is received, the implementation for multipath congestion control is a simple extension of the standard TCP code.  In standard TCP cwnd_cnt is an additional state variable that tracks the number of segments acked since the last cwnd increment; cwnd is incremented only when cwnd_cnt &gt; cwnd; then cwnd_cnt is set to 0. </p>
<p id="rfc.section.4.2.p.3">In the multipath case, cwnd_cnt_i is maintained for each subflow as above, and cwnd_i is increased by 1 when cwnd_cnt_i &gt; max(alpha_scale * tot_cwnd / alpha, cwnd_i).  </p>
<p id="rfc.section.4.2.p.4">When computing alpha for packet-based stacks, the errors in computing the terms in the denominator are larger (this is because cwnd is much smaller and rtt may be comparatively large). Let max be the index of the subflow used in the numerator.  To reduce errors, it is easiest to move rtt_max (once calculated) from the numerator to the denominator, changing equation (2) to obtain the equivalent formula below. </p>
<div id="#rfc.figure.4"></div>
<pre>
                                            cwnd_max 
     alpha = alpha_scale * tot_cwnd * -----------------------     (4)
                                     /     rtt_max * cwnd_i \ 2
                                     | sum -----------------|
                                     \  i        rtt_i      /

            </pre>
<p id="rfc.section.4.2.p.5">Note that the calculation of alpha does not take into account path mss, and is the same for stacks that keep cwnd in bytes or packets.  With this formula, the algorithm for computing alpha will match the rate of TCP on the best path in B/s for byte-oriented stacks, and in packets/s in packet-based stacks.  In practice, mss rarely changes between paths so this shouldn't be a problem.</p>
<p id="rfc.section.4.2.p.6">However, it is simple to derive formulae allowing packet-based stacks to achieve byte rate fairness (and viceversa) if needed. In particular, for packet-based stacks wanting byte-rate fairness, equation (4) above changes as follows: cwnd_max is replaced by cwnd_max * mss_max * mss_max, while cwnd_i is replaced with cwnd_i * mss_i.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Discussion</h1>
<p id="rfc.section.5.p.1">The algorithm we've presented fully achieves Goals 1 and 2, but does not achieve full resource pooling (Goal 3).  Resource pooling requires that no traffic should be transferred on links with higher loss rates.  To achieve perfect resource pooling, one must couple both increase and decrease of congestion windows across subflows, as in <a href="#KELLY">[KELLY]</a>.</p>
<p id="rfc.section.5.p.2">There are a few problems with such a fully-coupled controller. First, it will probe insufficiently paths with high loss rates, and will fail to detect free capacity when it becomes available.  Second, such controllers tend to exhibit "flappiness": when the paths have similar levels of congestion, the congestion controller will tend to allocate all the window to one random subflow, and allocate zero window to the other subflows. The controller will perform random flips between these stable points. This doesn't seem desirable in general, and is particularly bad when the achieved rates depend on the RTT (as in the current Internet): in such a case, the resulting rate with fluctuate unpredictably depending on which state the controller is in, hence violating Goal 1. </p>
<p id="rfc.section.5.p.3">By only coupling increases our proposal probes high-loss paths, detecting free capacity quicker.  Our proposal does not suffer from flappiness but also achieves less resource pooling.  The algorithm will allocate window to the subflows such that p_i * cwnd_i = constant, for all i. Thus, when the loss rates of the subflows are equal, each subflow will get an equal window, removing flappiness.  When the loss rates differ, progressively more window will be allocated to the flow with the lower loss rate.  In contrast, perfect resource pooling requires that all the window should be allocated on the path with the lowest loss rate. Further details can be found in <a href="#NSDI">[NSDI]</a>.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec_security" id="sec_security">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">One security concern relates to what we call the traffic-shifting attack: on-path attackers can drop packets belonging to a multipath subflow, which in turn makes the path seem congested and will force the sender's congestion controller to avoid that path and push more data over alternate subflows. </p>
<p id="rfc.section.6.p.2">The attacker's goal is to create congestion on the corresponding alternative paths. This behaviour is entirely feasible, but will only have minor effects: by design, the coupled congestion controller is less (or similarly) aggressive on any of its paths than a single TCP flow. Thus, the biggest effect this attack can have is to make a multipath subflow be as aggressive as a single TCP flow.  </p>
<p id="rfc.section.6.p.3">Another effect of the traffic-shifting attack is that the new path can monitor all the traffic, whereas before it could only see a subset of traffic. We believe that if privacy is needed, splitting traffic across multiple paths with MPTCP is not the right solution in the first place; end-to-end encryption should be used instead.  </p>
<p id="rfc.section.6.p.4">Besides the traffic-shifting attack mentioned above, the coupled congestion control algorithm defined in this draft adds no other security considerations to those found in <a href="#I-D.ietf-mptcp-multiaddressed">[I-D.ietf-mptcp-multiaddressed]</a> and <a href="#RFC6181">[RFC6181]</a>. Detailed security analysis for the Multipath TCP protocol itself is included in <a href="#I-D.ietf-mptcp-multiaddressed">[I-D.ietf-mptcp-multiaddressed]</a> and <a href="#RFC6181">[RFC6181]</a>.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">We thank Christoph Paasch for his suggestions for computing alpha in packet-based stacks. The authors are supported by Trilogy (http://www.trilogy-project.org), a research project (ICT-216372) partially funded by the European Community under its Seventh Framework Program.  The views expressed here are those of the author(s) only.  The European Commission is not liable for any use that may be made of the information in this document.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document does not require any action from IANA.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5681">[RFC5681]</b></td>
<td class="top">
<a>Allman, M.</a>, <a>Paxson, V.</a> and <a>E. Blanton</a>, "<a href="http://tools.ietf.org/html/rfc5681">TCP Congestion Control</a>", RFC 5681, September 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3465">[RFC3465]</b></td>
<td class="top">
<a>Allman, M.</a>, "<a href="http://tools.ietf.org/html/rfc3465">TCP Congestion Control with Appropriate Byte Counting (ABC)</a>", RFC 3465, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6181">[RFC6181]</b></td>
<td class="top">
<a>Bagnulo, M.</a>, "<a href="http://tools.ietf.org/html/rfc6181">Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6181, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mptcp-multiaddressed">[I-D.ietf-mptcp-multiaddressed]</b></td>
<td class="top">
<a>Ford, A</a>, <a>Raiciu, C</a>, <a>Handley, M</a> and <a>O Bonaventure</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mptcp-multiaddressed-04">TCP Extensions for Multipath Operation with Multiple Addresses</a>", Internet-Draft draft-ietf-mptcp-multiaddressed-04, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="WISCHIK">[WISCHIK]</b></td>
<td class="top">
<a title="University College London">Wischik, D.</a>, <a title="University College London">Handley, M.</a> and <a title="UC3M, Madrid">M. Bagnulo Braun</a>, "<a>The Resource Pooling Principle</a>", ACM SIGCOMM CCR vol. 38 num. 5, pp. 47-52, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="NSDI">[NSDI]</b></td>
<td class="top">
<a title="University College London">Wischik, D.</a>, <a title="University College London">Raiciu, C.</a>, <a title="University College London">Greenhalgh, A.</a> and <a title="University College London">M. Handley</a>, "<a>Design, Implementation and Evaluation of Congestion Control for Multipath TCP</a>", Usenix NSDI , March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="KELLY">[KELLY]</b></td>
<td class="top">
<a title="University of Cambridge">Kelly, F.</a> and <a title="University of Cambridge">T. Voice</a>, "<a>Stability of end-to-end algorithms for joint routing and rate control</a>", ACM SIGCOMM CCR vol. 35 num. 2, pp. 5-12, 2005.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Costin Raiciu</span> 
	  <span class="n hidden">
		<span class="family-name">Raiciu</span>
	  </span>
	</span>
	<span class="org vcardline">University Politehnica of Bucharest</span>
	<span class="adr">
	  <span>Splaiul Independentei 313</span>

	  <span class="vcardline">
		<span class="locality">Bucharest</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Romania</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:costin.raiciu@cs.pub.ro">costin.raiciu@cs.pub.ro</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mark Handley</span> 
	  <span class="n hidden">
		<span class="family-name">Handley</span>
	  </span>
	</span>
	<span class="org vcardline">University College London</span>
	<span class="adr">
	  <span>Gower Street</span>

	  <span class="vcardline">
		<span class="locality">London</span>,  
		<span class="region"></span>
		<span class="code">WC1E 6BT</span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:m.handley@cs.ucl.ac.uk">m.handley@cs.ucl.ac.uk</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Damon Wischik</span> 
	  <span class="n hidden">
		<span class="family-name">Wischik</span>
	  </span>
	</span>
	<span class="org vcardline">University College London</span>
	<span class="adr">
	  <span>Gower Street</span>

	  <span class="vcardline">
		<span class="locality">London</span>,  
		<span class="region"></span>
		<span class="code">WC1E 6BT</span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:d.wischik@cs.ucl.ac.uk">d.wischik@cs.ucl.ac.uk</a></span>

  </address>
</div>

</body>
</html>