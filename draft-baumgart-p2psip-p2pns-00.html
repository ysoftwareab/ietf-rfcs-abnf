<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Peer-to-Peer Name Service (P2PNS)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Peer-to-Peer Name Service (P2PNS)">
<meta name="keywords" content="name service">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">P2PSIP Working Group</td><td class="header">I. Baumgart</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Institute of Telematics,</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">Universitaet Karlsruhe
      (TH)</td></tr>
<tr><td class="header">Expires: May 12, 2008</td><td class="header">November 09, 2007</td></tr>
</table></td></tr></table>
<h1><br />Peer-to-Peer Name Service (P2PNS)<br />draft-baumgart-p2psip-p2pns-00</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 12, 2008.</p>

<h3>Abstract</h3>

<p>This document describes P2PNS, a secure distributed name service for
      P2PSIP. P2PNS can be used to resolve SIP AoRs to Contact URIs without
      using DNS or central SIP servers. P2PNS provides
      several security mechanisms to efficiently prevent identity theft and to
      ensure the uniqueness of SIP AoRs in a completely decentralized and
      untrusted network without login servers. The proposed proxy architecture
      allows a seamless integration of legacy SIP UAs, avoids modifications to
      the complex SIP protocol stack and facilitates the deployment of P2PSIP
      networks. Because P2PNS provides a generic name service it is not
      limited to P2PSIP but can also be used e.g. to build a distributed DNS
      system.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Background<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Structured Peer-to-Peer Networks<br />
<a href="#anchor4">3.</a>&nbsp;
Terminology<br />
<a href="#anchor5">4.</a>&nbsp;
Goals for P2PNS<br />
<a href="#anchor6">5.</a>&nbsp;
Design Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.1.</a>&nbsp;
P2PNS Architecture<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.2.</a>&nbsp;
P2PNS Name Resolution<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#twostage">5.2.1.</a>&nbsp;
Two-stage Name Resolution<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.2.2.</a>&nbsp;
Direct Name Resolution<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">5.2.3.</a>&nbsp;
P2PNS Cache<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">5.3.</a>&nbsp;
KBR Design<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#KBRSec">5.3.1.</a>&nbsp;
KBR Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">5.3.1.1.</a>&nbsp;
Secure NodeID Assignment<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">5.3.1.2.</a>&nbsp;
Lookup over Disjoint Paths<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.3.1.3.</a>&nbsp;
Secure Routing Table Maintenance<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.4.</a>&nbsp;
DHT Design<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DHTSec">5.4.1.</a>&nbsp;
DHT Security<br />
<a href="#Service">6.</a>&nbsp;
Service Discovery<br />
<a href="#anchor16">7.</a>&nbsp;
P2PNS Interface<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#REGISTER">7.1.</a>&nbsp;
REGISTER<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">7.2.</a>&nbsp;
RESOLVE<br />
<a href="#anchor18">8.</a>&nbsp;
P2PNS Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#P2PSIP">8.1.</a>&nbsp;
P2PSIP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">8.2.</a>&nbsp;
Distributed DNS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">8.3.</a>&nbsp;
Zeroconf Service Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">8.4.</a>&nbsp;
HIP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">8.5.</a>&nbsp;
Jabber / XMPP<br />
<a href="#anchor23">9.</a>&nbsp;
Bootstrapping<br />
<a href="#anchor24">10.</a>&nbsp;
NAT Traversal<br />
<a href="#anchor25">11.</a>&nbsp;
Open Issues<br />
<a href="#Acknowledgments">12.</a>&nbsp;
Acknowledgments<br />
<a href="#IANA">13.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">14.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">15.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">15.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">15.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>An emerging use case for peer-to-peer protocols are decentralized
      VoIP networks. The IETF P2PSIP working group has been formed to develop
      protocols for using the <a class='info' href='#RFC3261'>Session Initiation
      Protocol (SIP)<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a> [1] in networks without centralized servers. These
      decentralized VoIP networks can e.g. be used as failover for traditional
      server-based SIP networks in emergency cases.
</p>
<p>In traditional SIP networks the main task of a SIP server is to
      resolve an Address of Record (AoR) to the current IP address (Contact
      URI) of a user. This name resolution usually depends on DNS. In this
      paper we present a distributed name service using a DHT to resolve AoRs
      to Contact URIs without relying on DNS and central SIP servers. Apart
      from this decentralized name resolution the call setup is based on the
      standard SIP protocol. The benefit of this approach is that we can
      easily connect legacy SIP phones to our P2PSIP network. This connection
      is accomplished by a SIP proxy located between SIP phone and DHT which
      handles the name resolution.
</p>
<p>Currently there are several other P2PSIP proposals like <a class='info' href='#I-D.bryan-p2psip-reload'>RELOAD<span> (</span><span class='info'>Bryan, D., &ldquo;REsource LOcation And Discovery (RELOAD),&rdquo; July&nbsp;2007.</span><span>)</span></a> [3] and <a class='info' href='#I-D.baset-p2psip-p2pp'>P2PP<span> (</span><span class='info'>Baset, S. and H. Schulzrinne, &ldquo;Peer-to-Peer Protocol (P2PP),&rdquo; July&nbsp;2007.</span><span>)</span></a> [4] which are similar to our
      P2PNS approach. We therefore focus on two aspects in this document which
      we think have been neglected by similar proposals. The first aspect is
      flexibility: P2PNS is a generic name service and not limited to P2PSIP.
      Other applications for P2PNS are e.g. decentralized <a class='info' href='#RFC1035'>DNS<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - implementation and specification,&rdquo; November&nbsp;1987.</span><span>)</span></a> [5], decentralized <a class='info' href='#RFC3920'>XMPP<span> (</span><span class='info'>Saint-Andre, P., Ed., &ldquo;Extensible Messaging and Presence Protocol (XMPP): Core,&rdquo; October&nbsp;2004.</span><span>)</span></a> [6] or decentralized <a class='info' href='#RFC4423'>HIP<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a> [7]. In P2PNS there is a clear separation
      between the overlay layer (key-based routing), the data storage layer
      (distributed hash table), the name resolution layer (P2PNS Cache) and
      the protocols, that utilize the name service (like SIP or DNS). In this
      architecture the specification of the key-based routing protocol is independent
      from P2PSIP and KBR protocol implementations can therefore easily be reused
      for other peer-to-peer applications.
</p>
<p>The second aspect is security: We propose several security mechanisms
      to provide a high level of security in a completely decentralized
      network without login severs. In particular P2PNS provides mechanisms to
      guarantee the uniqueness of P2PNames and to prevent identity theft.
      These security mechanisms are based on a cryptographically generated
      nodeID, which is used to authenticate overlay nodes.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Background</h3>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Structured Peer-to-Peer Networks</h3>

<p>In this section we provide some background on structured
        peer-to-peer networks. A common service which is provided by all
        structured peer-to-peer networks is the <a class='info' href='#CommonAPI'>key-based routing layer (KBR)<span> (</span><span class='info'>Dabek, F., Zhao, B., Druschel, P., Kubiatowicz, J., and I. Stoica, &ldquo;Towards a Common API for Structured Peer-to-Peer           Overlays,&rdquo; 2003.</span><span>)</span></a> [8]. This layer
        provides efficient routing to identifiers called keys from a large
        identifier space. Every participating node in the overlay chooses a
        unique nodeID from the same id space and maintains a routing table
        with nodeIDs and IP addresses of neighbors in the overlay topology.
        Every node is responsible for a particular range in the identifier
        space, usually for all keys close to its nodeID in the id space. The
        KBR layer provides a route() method to efficiently route a message to
        an arbitrary key by successively forwarding the message to overlay
        neighbors which have a nodeID closer to the destination key. For P2PNS
        we propose to use the <a class='info' href='#Kademlia'>Kademlia<span> (</span><span class='info'>Maymounkov, P. and D. Mazieres, &ldquo;Kademlia: A Peer-to-Peer Information System Based on the XOR           Metric,&rdquo; March&nbsp;2002.</span><span>)</span></a> [9] protocol
        as KBR layer, although our findings can also be applied to other KBR
        protocols.
</p>
<p>On top of the KBR we use a distributed hash table (DHT), which is a
        distributed storage service for storing (key, value) data records. The
        DHT layer provides the two methods get(key) and put(key, value). The
        node responsible for storing a data record with a specific key is
        discovered by using the route() method of the underlying KBR
        layer.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [2].
</p>
<p>Terminology defined in <a class='info' href='#RFC3261'>RFC 3261<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a> [1] and the
      <a class='info' href='#I-D.ietf-p2psip-concepts'>Concepts and Terminology for
      Peer-to-Peer SIP<span> (</span><span class='info'>Bryan, D., &ldquo;Concepts and Terminology for Peer to Peer SIP,&rdquo; July&nbsp;2007.</span><span>)</span></a> [10] draft is used without definition.
</p>
<p></p>
<blockquote class="text">
<p>DHT: Distributed hash table as defined in <a class='info' href='#CommonAPI'>[8]<span> (</span><span class='info'>Dabek, F., Zhao, B., Druschel, P., Kubiatowicz, J., and I. Stoica, &ldquo;Towards a Common API for Structured Peer-to-Peer           Overlays,&rdquo; 2003.</span><span>)</span></a>.
</p>
<p>KBR: Key-based routing layer as defined in <a class='info' href='#CommonAPI'>[8]<span> (</span><span class='info'>Dabek, F., Zhao, B., Druschel, P., Kubiatowicz, J., and I. Stoica, &ldquo;Towards a Common API for Structured Peer-to-Peer           Overlays,&rdquo; 2003.</span><span>)</span></a>.
</p>
<p>Node: An instance of an participant in the overlay.
</p>
<p>NodeID: A unique 160 bit identifier used to address nodes in the
          overlay. In <a class='info' href='#I-D.ietf-p2psip-concepts'>Concepts and
          Terminology for Peer-to-Peer SIP<span> (</span><span class='info'>Bryan, D., &ldquo;Concepts and Terminology for Peer to Peer SIP,&rdquo; July&nbsp;2007.</span><span>)</span></a> [10] this is called Peer-ID.
</p>
<p>P2PName: An arbitrary string which can be resolved to a Transport
          Address by using P2PNS.
</p>
<p>ServiceName: An well-known name for a service which can be
          resolved to the Transport Address of a node offering this
          service.
</p>
<p>Transport Address: The IP address and port used to address a
          node.
</p>
<p>
</p>
</blockquote>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Goals for P2PNS</h3>

<p>The name service P2PNS should fulfill the following requirements:
</p>
<p></p>
<ul class="text">
<li>The name service should not be limited to P2PSIP, but also
          support e.g. distributed DNS. Therefore the name service should be
          independent from the SIP protocol.
</li>
<li>The P2PNS architecture should be completely decentralized. In
          particular it should not depend on any central login servers or
          other trustworthy authorities.
</li>
<li>The user should be able to choose an arbitrary P2PName.
</li>
<li>P2PNS should provide mechanisms to guarantee the uniqueness of
          P2PNames and prevent identity theft.
</li>
<li>For P2PSIP applications P2PNS should support unmodified legacy
          SIP UAs and provide gateway functionality between P2PSIP and
          server-based SIP networks.
</li>
</ul>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Design Overview</h3>

<p>In this section we describe our P2PNS architecture and several
      security extensions for the KBR and DHT layer.
</p>
<p>
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
P2PNS Architecture</h3>

<p>The P2PNS architecture comprises a name resolution and caching
        layer (P2PNS Cache) on top of an external overlay which provides KBR
        and DHT services. The KBR service can be provided by any structured
        peer-to-peer protocol which provides a <a class='info' href='#CommonAPI'>Common
        API<span> (</span><span class='info'>Dabek, F., Zhao, B., Druschel, P., Kubiatowicz, J., and I. Stoica, &ldquo;Towards a Common API for Structured Peer-to-Peer           Overlays,&rdquo; 2003.</span><span>)</span></a> [8] interface and contains the security extensions from <a class='info' href='#KBRSec'>Section&nbsp;5.3.1<span> (</span><span class='info'>KBR Security</span><span>)</span></a>. Applications like a SIP proxy connect to
        P2PNS by using a XML-RPC interface which provides register() and
        resolve() functions. The P2PNS architecture is shown in the
        following figure.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+-------------+             +---------------------------------------+
| P2PNS Cache |&lt;-----------&gt;| Application (SIP proxy, DNS Resolver) |
+-------------+  register() +---------------------------------------+
  ^         ^    resolve()
  | put()   |
  | get()   |
  v         |
+-----+     |
| DHT |     |
+-----+     |
  |         |
  | join()  |
  | route() |
  | lookup()|
  v         v
+-------------+
|     KBR     |
+-------------+
</pre></div>
<p>
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
P2PNS Name Resolution</h3>

<p>P2PNS offers two alternatives for resolving a P2PName to the
        current transport address:
</p>
<a name="twostage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Two-stage Name Resolution</h3>

<p>The preferred alternative is to use a two-stage approach to
          resolve a P2PName to the current transport address. For this purpose
          every peer chooses once a 160 bit nodeID for joining the overlay.
          This nodeID is retained even if the peer changes its IP address or
          leaves the overlay from time to time. The KBR layer allows us to
          efficiently resolve the nodeID to the current IP address of a peer
          by using the lookup() or route() methods. By choosing the nodeID as
          P2PName the name resolution layer could therefore use the KBR
          service to resolve a P2PName without using a DHT.
</p>
<p>Because using the nodeID as P2PName is against the requirement of
          letting the user choose an arbitrary string as P2PName we
          additionally store a mapping from the arbitrary P2PName to the
          corresponding nodeID in the DHT. In this case the name resolution
          layer first queries the DHT for the nodeID of the destination node
          and in a second step resolves this nodeID to the node's current IP
          address. If the user wants to register a transport address different
          from the node's current IP address this mapping is stored locally at
          the destination node. In this case the name resolution process
          involves the lookup of this mapping at the destination node as the
          final step.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Direct Name Resolution</h3>

<p>Instead of using the two-stage name resolution approach, it is
          also possible to directly store a P2PName to transport address
          mapping in the DHT. But due to the proposed security mechanisms in
          <a class='info' href='#DHTSec'>Section&nbsp;5.4.1<span> (</span><span class='info'>DHT Security</span><span>)</span></a> storing and modifying data records in
          the DHT is very bandwidth consuming, because data records are
          replicated on several nodes. However by using the two-stage approach
          it is not necessary to modify data records, because the P2PName to
          nodeID mapping doesn't change. So an IP address change has an effect
          on the KBR layer only, which can be handled very efficiently.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
P2PNS Cache</h3>

<p>To reduce communication overhead and lookup latency when
          resolving the same P2PName several times, the static P2PName to
          nodeID mappings are cached locally.
</p>
<p>The nodeID to transport address mapping may also be cached.
          Because this mapping can be outdated, it has to be verified. This is
          done by trying to directly contact the destination node using the
          stored destination transport address. If this verification fails, the
          mapping is refreshed by using the KBR lookup() method.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
KBR Design</h3>

<p>The current P2PNS implementation uses <a class='info' href='#Kademlia'>Kademlia<span> (</span><span class='info'>Maymounkov, P. and D. Mazieres, &ldquo;Kademlia: A Peer-to-Peer Information System Based on the XOR           Metric,&rdquo; March&nbsp;2002.</span><span>)</span></a> [9] as KBR protocol,
        although the P2PNS approach is not limited to a specific KBR protocol.
        Kademlia was chosen, because it is simple to implement, is already
        insusceptible to several common attacks and is the only widely
        deployed structured overlay network in the Internet today (i.e.
        BitTorrent, OverNet and eMule). The specification of a KBR protocol is
        out of scope of this document. Instead we propose to use the P2PP
        proposal <a class='info' href='#I-D.baset-p2psip-p2pp'>[4]<span> (</span><span class='info'>Baset, S. and H. Schulzrinne, &ldquo;Peer-to-Peer Protocol (P2PP),&rdquo; July&nbsp;2007.</span><span>)</span></a> and extend it by
        the following security extensions.
</p>
<a name="KBRSec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
KBR Security</h3>

<p>The security of the P2PNS architecture largely depends on the
          security of the KBR layer. As shown in <a class='info' href='#SecureRouting'>[11]<span> (</span><span class='info'>Castro, M., Druschel, P., Ganesh, A., Rowstron, A., and D. Wallach, &ldquo;Secure routing for structured peer-to-peer overlay           networks,&rdquo; 2002.</span><span>)</span></a> KBR protocols have to fulfill three
          requirements to provide a high level of security. On the basis of
          these requirements we decided to use Kademlia as KBR protocol and
          extended it by several security enhancements (<a class='info' href='#SKademlia'>S/Kademlia<span> (</span><span class='info'>Baumgart, I. and S. Mies, &ldquo;S/Kademlia: A Practicable Approach Towards Secure Key-Based           Routing,&rdquo; December&nbsp;2007.</span><span>)</span></a> [12]). In the following these
          requirements and security enhancements are summarized:
</p>
<p>
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.1"></a><h3>5.3.1.1.&nbsp;
Secure NodeID Assignment</h3>

<p>Most important it should be hard for an attacker to generate a
            large number of nodeIDs (Sybil attack) or to choose a particular
            nodeID freely (Eclipse attack). In P2PNS every node generates a
            224 bit <a class='info' href='#X9.62'>ECDSA<span> (</span><span class='info'>American National Standards Institute, &ldquo;ANSI X9.62-2005, Public Key Cryptography for the Financial           Services Industry: The Elliptic Curve Digital Signature Algorithm           (ECDSA),&rdquo; .</span><span>)</span></a> [13] public key pair and
            calculates its nodeID by applying a cryptographic hash function
            H(x) on its public key k_pub. The current implementation uses the
            <a class='info' href='#FIPS180-2'>SHA-1<span> (</span><span class='info'>National Insitute of Standards and             Technology, &ldquo;FIPS 180-2, &quot;Secure Hash Standard&quot;,&rdquo; 2002.</span><span>)</span></a> [14] hash function. To impede the
            generation of a large number of nodeIDs we additionally make use
            of crypto puzzles. A simple crypto puzzle is given below:
</p>
<p></p>
<ol class="text">
<li>Generate a new public key pair (k_priv, k_pub).
</li>
<li>Calculate H(H(k_pub)) and check, if the first c bit are
                0.
</li>
<li>If the condition in step 2 is not true, repeat step 1.
                Otherwise the crypto puzzle is solved and the nodeID is
                H(k_pub).
</li>
</ol><p>This approach has several benefits compared to the usual
            approach to generate the nodeID by applying a hash function on the
            IP address of the node. First the node may keep the nodeID if the
            IP address changes. Furthermore the public key approach can be
            used in networks with NAT (Network Address Translation), in which
            several nodes share the same public IP address.
</p>
<p>The public key pair (k_priv, k_pub) is used in the following to
            authenticate overlay signaling. For this purpose overlay messages
            are signed with k_priv. In this way the receiving node may use the
            public key k_pub attached to the message to verify the
            authorship.
</p>
<p>To provide a higher level of security the nodeID assignment can
            additionally be restricted by using certificates of an offline
            CA.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.2"></a><h3>5.3.1.2.&nbsp;
Lookup over Disjoint Paths</h3>

<p>As second requirement the overlay should provide several
            disjoint and preferably short paths to all destination keys to
            successfully deliver messages in presence of malicious nodes. The
            number of disjoint paths depends particularly on the employed
            overlay topology (e.g. ring, hypercube or de Bruijn graph). The
            Kademlia protocol is based on a hypercube topology and provides
            the bucket size parameter k, which can be used to tune routing
            table redundancy to the required level of security.
</p>
<p>We studied the influence of disjoint paths on lookup success in
            a network with malicious nodes by using the OverSim framework. The
            simulation results <a class='info' href='#SKademlia'>[12]<span> (</span><span class='info'>Baumgart, I. and S. Mies, &ldquo;S/Kademlia: A Practicable Approach Towards Secure Key-Based           Routing,&rdquo; December&nbsp;2007.</span><span>)</span></a> for Kademlia
            showed a significant increase in lookup success by using several
            disjoint paths.
</p>
<p>Most overlay protocols can be used with recursive as well as
            iterative routing. In P2PNS iterative routing is used to ensure
            the resulting paths are really disjoint. Furthermore with
            iterative routing the originator of the lookup can constantly
            monitor the lookup progress. Yet iterative routing exhibits the
            disadvantage of roughly doubling the time for a lookup to finish
            in comparison to recursive routing.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.3"></a><h3>5.3.1.3.&nbsp;
Secure Routing Table Maintenance</h3>

<p>An important security property of KBR protocols is the
            robustness of the signaling protocol for routing table maintenance
            in the presence of malicious nodes. As long as the nodeID
            selection is limited, Kademlia is very robust against adversarial
            routing table manipulations due to is implicit stabilization by
            incoming lookup requests. Because Kademlia uses a
            least-recently-used replacement strategy for routing table
            updates, new nodes are only added if older nodes fail. Therefore
            Kademlia is not vulnerable to the flooding of bogus routing
            updates once the network is bootstrapped.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
DHT Design</h3>

<p>The DHT layer is a distributed storage service for storing (key,
        value) data records. The DHT layer provides the two methods get(key)
        and put(key, value) to the upper layer. The nodes responsible for
        storing a data record with a specific key are discovered by using the
        route() or lookup() method of the underlying KBR layer.
</p>
<a name="DHTSec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
DHT Security</h3>

<p>The proposed security mechanisms in <a class='info' href='#KBRSec'>Section&nbsp;5.3.1<span> (</span><span class='info'>KBR Security</span><span>)</span></a>
          are the basis for providing a secure DHT service. Yet the DHT layer
          has to fulfill additional requirements to secure the stored P2PName
          to nodeID mappings:
</p>
<p></p>
<ul class="text">
<li>Data records may only be deleted or modified by the owner of
              the record.
</li>
<li>Data records should be replicated on several nodes to inhibit
              manipulation by single malicious nodes.
</li>
<li>The DHT should be secure against insertion DoS attacks.
</li>
</ul><p>In order to prevent the unauthorized modification of data
          records the DHT layer additionally stores the nodeID of the owner
          along with the data. If a node wants to subsequently modify a data
          record, it has to sign the modification request with its private key
          k_priv. The receiver of the request has verify the signature and to
          ensure that H(k_pub) coincides with the nodeID of the data record's
          owner.
</p>
<p>The node, that is responsible for storing a data record is
          determined by means of the key of the record. In this case the key
          is the hash value of the P2PName. In order to prevent users from
          choosing an already existing P2PName, the DHT only stores a single
          data record for a each key. Consequently the user how stores his
          P2PName first is eligible for this name.
</p>
<p>Data records are replicated on several nodes, because a malicious
          node may arbitrarily tamper with locally stored data records. The
          replicas are stored on neighbor nodes close to the key as these
          nodes can be efficiently discovered by a single KBR lookup.
</p>
<p>A peer resolves a P2PName to nodeID mapping by querying all
          replicas in parallel. Thereupon the peer makes a majority decision
          on all received replies to determine the most plausible destination
          nodeID. In order to handle churn every newly joined node first
          requests all data records in his responsibility from his neighbor
          nodes and stores them locally.
</p>
<p>Finally the DHT has to be protected against adversarial flooding
          of insertion requests. This is important because the verification of
          the signature of a STORE message is computational expensive.
          Moreover the storage of unnecessary data records consums valuable
          peer ressources. To compensate for the computational ressources for
          verifying the signature of a STORE message, the requesting node has
          to solve the following crypto puzzle:
</p>
<p>For the key k of the data record determine an appropriate b, so
          that the first c bits of H(k XOR b) are equal to the first c bits of
          the own nodeID. The constant c is used to specify the complexity of
          the puzzle and b is the solution of the puzzle.
</p>
<p>The crypto puzzle makes the insertion of a large number of data
          records harder, but doesn't completely prevent an insertion DoS
          attack. Therefore we additionally limit the allow number of data
          records per owner by using the following approach: To store a new
          data record the owner O sends a GRANT message to all neighbors close
          to his own nodeID after solving the crypto puzzle. These neighbors
          store all keys of the data records that O has already stored in the
          DHT. If the maximum number of allowed data records per owner is
          exceeded the GRANT message is rejected. In a second step the node O
          sends a STORE message with his data record containing the AoR to
          nodeID mapping to all replicating nodes. These nodes use a CHECK
          message to verify if the neighbor nodes of O have authorized the
          storage and finally store the data record locally.
</p>
<p>These proposed security mechanisms make the storage and
          modification of data records rather expensive in terms of
          computational and communication costs. But by using the two-stage
          approach of <a class='info' href='#twostage'>Section&nbsp;5.2.1<span> (</span><span class='info'>Two-stage Name Resolution</span><span>)</span></a> the static P2PName to
          nodeID mapping has to be stored only once when new P2PName is
          registered for the first time. If a node later change its IP address
          or temporarily leaves the network, this is efficiently handled by
          the KBR layer without involving complex DHT operations.
</p>
<p>
</p>
<a name="Service"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Service Discovery</h3>

<p>P2PNS also supports service discovery in a similar way to name
      resolution. This can e.g. be used to locate STUN servers or bootstrap
      nodes.
</p>
<p>A node registers a service by calling register() (see <a class='info' href='#REGISTER'>Section&nbsp;7.1<span> (</span><span class='info'>REGISTER</span><span>)</span></a>) with a well-known service name (e.g. "STUN").
      This service registration is stored in the DHT by a put(H(ServiceName),
      nodeID) call similar to storing a P2PName/nodeID mapping. Because the
      same service may be provided by different nodes, a ServiceName/nodeID
      mapping in the DHT is allowed to contain several different nodeIDs.
      Consequently a ServiceName record has no dedicated owner like a P2PName
      record (see <a class='info' href='#DHTSec'>Section&nbsp;5.4.1<span> (</span><span class='info'>DHT Security</span><span>)</span></a>). To anyhow inhibit malicious nodes
      from arbitrarily modifying ServiceName records, the only allowed
      modification is to add the own nodeID to a record.
</p>
<p>If the service directory is used to store a large number of nodes for
      a ServiceName, the load in the DHT should be balanced by using multiple
      hash functions <a class='info' href='#MultipleHash'>[15]<span> (</span><span class='info'>Xia, Y., Chen, S., and V. Korgaonkar, &ldquo;Load Balancing with Multiple Hash Functions in Peer-to-Peer           Networks,&rdquo; 2006.</span><span>)</span></a>.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
P2PNS Interface</h3>

<p>P2PNS provides a XML-RPC interface with the following procedures to
      register and resolve P2PNames:
</p>
<a name="REGISTER"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
REGISTER</h3>

<p>The register() procedure is used to register a new P2PName or to
        update the transport address for an existing P2PName. The same
        procedure is also used to register a service (see <a class='info' href='#Service'>Section&nbsp;6<span> (</span><span class='info'>Service Discovery</span><span>)</span></a>). The register() procedure uses the following
        parameters:
</p>
<p></p>
<ul class="text">
<li>Name (&lt;base64&gt;): The name to register.
</li>
<li>Transport Address (&lt;base64&gt;): The current IP address and
            port for the given P2PName. If this is empty, the node's current
            IP address and KBR port is used.
</li>
<li>Type (&lt;int&gt;):
<ul class="text">
<li>0: The name is registered as P2PName.
</li>
<li>1: The name is registered as a service.
</li>
</ul>
</li>
<li>TTL (&lt;int&gt;): The time-to-live for this mapping in
            seconds.
</li>
</ul>

<p>The return value is an &lt;int&gt;:
</p>
<p></p>
<ul class="text">
<li>0: The registration was successful.
</li>
<li>1: The registration was rejected, because the name is already
            registered by another node.
</li>
<li>2: The registration failed, because the overlay is not
            available.
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
RESOLVE</h3>

<p>The resolve() procedure is used to resolve a registered P2PName to
        the current corresponding transport address. The same procedure is
        also used for service discovery (see <a class='info' href='#Service'>Section&nbsp;6<span> (</span><span class='info'>Service Discovery</span><span>)</span></a>).
        The resolve() procedure uses the following parameters:
</p>
<p></p>
<ul class="text">
<li>Name (&lt;base64&gt;): The name to resolve.
</li>
<li>Type (&lt;int&gt;):
<ul class="text">
<li>0: The given name is a P2PName.
</li>
<li>1: The given name is a service.
</li>
</ul>
</li>
</ul>

<p>The return value is an &lt;array&gt;:
</p>
<p></p>
<ul class="text">
<li>Transport Address (&lt;base64&gt;): The current IP address and
            port for the given name.
</li>
<li>Error code (&lt;int&gt;):
<ul class="text">
<li>0: The name resolution was successful.
</li>
<li>1: The name resolution failed, because the name is not
                registered.
</li>
<li>2: The name resolution failed, because the overlay is not
                available.
</li>
</ul>
</li>
</ul>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
P2PNS Usage</h3>

<p>This section describes how P2PNS can be utilized for different
      application scenarios like P2PSIP or distributed DNS.
</p>
<a name="P2PSIP"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
P2PSIP</h3>

<p>In order to facilitate the use of legacy server-based SIP phones,
        we propose to employ a proxy architecture. In this architecture every
        P2PSIP peer consists of a SIP UA, a local SIP proxy as well as a P2PNS
        implementation. The proxy is used as a location server for resolving
        AoRs to Contact URIs by using the P2PNS services. To facilitate the
        interconnection of P2PSIP and server-based SIP networks we propose to
        use AoRs of the form username@p2pname.org. The username part can be
        freely chosen by the user whereas the domain part p2pname.org is fixed
        and used to identify the P2PSIP network. In order to connect the
        P2PSIP network to the server-based SIP network DNS is used. In this
        case the domain name p2pname.org
        should contain a SRV DNS record pointing to several of the P2PSIP
        proxies which are used to forward SIP INVITEs to the appropriate P2PSIP nodes.
        This can also be used to interconnect multiple P2PSIP networks by
        using different domain parts for each overlay. In a pure P2PSIP
        network DNS is not used at all. The following figure shows the P2PNS
        architecture for P2PSIP:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+-------------+             +-----------+
| P2PNS Cache |&lt;-----------&gt;| SIP proxy |
+-------------+  register() +-----------+
  ^         ^    resolve()        ^
  | put()   |                     |
  | get()   |                     | SIP
  v         |                     |
+-----+     |                     v
| DHT |     |               +-----------+
+-----+     |               |  SIP UA   |
  ^         |               +-----------+
  | join()  |
  | route() |
  | lookup()|
  v         v
+-------------+
|     KBR     |
+-------------+
</pre></div>
<p>
</p>
<p>The following figure illustrates an example of
        an AoR registration. In the first step the UA at peer Y sends a SIP
        REGISTER message with the AoR U to the local P2PSIP proxy. The proxy
        then connects to the P2PNS XML-RPC interface and calls register(U). If the
        the P2PNS layer is not already connected to the overlay, it joins with
        the nodeID ID_Y. Finally the P2PNS layer stores the AoR to nodeID mapping in the
        DHT.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
..................................................
.                      2.register(U)             .
.       +-------------+            +-----------+ .
.       | P2PNS Cache |&lt;-----------| SIP proxy | .
.       +-------------+            +-----------+ .
.         |         |                    ^       .
. 4.put(  |         |    1.REGISTER(To:U)|       .
. U,ID_Y) |         |       (SIP)        |       .
.         v         |                    |       .
.       +-----+     |                    |       .
.       | DHT |     |3.join(ID_Y)  +-----------+ .
.       +-----+     |              |  SIP UA   | .
.                   v              +-----------+ .
.       +-------------+               User U     .
.       |     KBR     |                          .
.       +-------------+                          .
..................................................
  Peer Y
</pre></div>
<p>
</p>
<p>The following figure shows how the user at peer
        X establishes a call to the AoR U. At first the UA sends an INVITE to
        the local P2PSIP proxy. Subsequently the proxy queries P2PNS by a
        resolve(U) call. The P2PNS layer first fetches the corresponding
        nodeID for the AoR U from the DHT (if the mapping is not already
        cached). In the next step the obtained
        nodeID gets resolved to the current IP address of peer Y. Finally the
        INVITE message gets forwarded to the UA of U via the proxy at peer Y.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
............................................
.                2.resolve(U)       5.INVITE(To:U) (SIP)
. +-------------+            +-----------+ .  ..........
. | P2PNS Cache |&lt;-----------| SIP proxy |---&gt;.User U  .
. +-------------+            +-----------+ .  .@ Peer Y.
.   |         |                    ^       .  ..........
.   |3.get(U) |      1.INVITE(To:U)|       .
.   |         |         (SIP)      |       .
.   v         |                    |       .
. +-----+     |4.lookup(ID_X)      |       .
. | DHT |     |              +-----------+ .
. +-----+     |              |  SIP UA   | .
.             v              +-----------+ .
. +-------------+               User V     .
. |     KBR     |                          .
. +-------------+                          .
............................................
  Peer X
</pre></div>
<p>
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Distributed DNS</h3>

<p>Similar to the P2PSIP approach P2PNS can be used to build
        a distributed DNS system by adding P2PNS support to a caching-only name server.
        For distributed DNS a P2PName is a FQDN of the form
        arbitrary_hostname.p2pname.org. For all name resolution requests to
        *.p2pname.org the name server queries P2PNS using a XML-RPC resolve() call.
</p>
<p>
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Zeroconf Service Discovery</h3>

<p>P2PNS could also be used for wide-area service discovery by adding P2PNS
        support to a mDNS/DNS-SD<a class='info' href='#I-D.cheshire-dnsext-dns-sd'>[16]<span> (</span><span class='info'>Krochmal, M. and S. Cheshire, &ldquo;DNS-Based Service Discovery,&rdquo; August&nbsp;2006.</span><span>)</span></a> implementation. This way legacy applications with DNS-SD support
        can use P2PNS for service discovery, if DNS is not available.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
HIP</h3>

<p>The <a class='info' href='#RFC4423'>Host Identity Protocol<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a> [7] uses DNS
        to resolve Host Identity Tags (HITs) to IP addresses. Alternatively
        the <a class='info' href='#I-D.ahrenholz-hiprg-dht'>HIP DHT Interface<span> (</span><span class='info'>Ahrenholz, J., &ldquo;HIP DHT Interface,&rdquo; February&nbsp;2007.</span><span>)</span></a> [17] draft
        proposes to use OpenDHT for HIT lookups. Similarly P2PNS can be used in two
        ways to resolve a HIT without DNS:
</p>
<p></p>
<ul class="text">
<li>Register the HIT as P2PName (This is similar to the <a class='info' href='#I-D.ahrenholz-hiprg-dht'>HIP DHT Interface<span> (</span><span class='info'>Ahrenholz, J., &ldquo;HIP DHT Interface,&rdquo; February&nbsp;2007.</span><span>)</span></a> [17]
            proposal)
</li>
<li>Use the HIT as nodeID. This allows an efficient HIT resolution
            by only using the KBR layer (Only the second stage of the
            two-stage approach described in <a class='info' href='#twostage'>Section&nbsp;5.2.1<span> (</span><span class='info'>Two-stage Name Resolution</span><span>)</span></a> is
            needed).
</li>
</ul>

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.5"></a><h3>8.5.&nbsp;
Jabber / XMPP</h3>

<p>A decentralized <a class='info' href='#RFC3920'>XMPP<span> (</span><span class='info'>Saint-Andre, P., Ed., &ldquo;Extensible Messaging and Presence Protocol (XMPP): Core,&rdquo; October&nbsp;2004.</span><span>)</span></a> [6] network, which
        is independent from DNS can be realized with P2PNS analogous to <a class='info' href='#P2PSIP'>Section&nbsp;8.1<span> (</span><span class='info'>P2PSIP</span><span>)</span></a> by adding a P2PNS interface to a XMPP server.
        In this case the Jabber ID (JID) is of the form username@p2pname.org
        with the fixed domain part p2pname.org.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Bootstrapping</h3>

<p>P2PNS uses a combination of the following bootstrap mechanisms to
      find a bootstrap node:
</p>
<p></p>
<ul class="text">
<li>Locate local peers by using mDNS as described in the <a class='info' href='#I-D.garcia-p2psip-dns-sd-bootstrapping'>P2PSIP bootstrapping
          using DNS-SD<span> (</span><span class='info'>Garcia, G., &ldquo;P2PSIP bootstrapping using DNS-SD,&rdquo; October&nbsp;2007.</span><span>)</span></a> [18] draft.
</li>
<li>If DNS is available, try to use DNS-SD as described in the <a class='info' href='#I-D.garcia-p2psip-dns-sd-bootstrapping'>P2PSIP bootstrapping
          using DNS-SD<span> (</span><span class='info'>Garcia, G., &ldquo;P2PSIP bootstrapping using DNS-SD,&rdquo; October&nbsp;2007.</span><span>)</span></a> [18] draft.
</li>
<li>Try to connect to a node from a list of stored nodes known from previous
          sessions.
</li>
<li>Probe random IP addresses from a list of given IP address
          ranges (e.g. dial-in networks).
</li>
</ul>

<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
NAT Traversal</h3>

<p>The current implementation uses <a class='info' href='#RFC3489'>STUN<span> (</span><span class='info'>Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, &ldquo;STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs),&rdquo; March&nbsp;2003.</span><span>)</span></a> [19]
      for NAT traversal. Further versions of P2PNS should also support ICE
      <a class='info' href='#I-D.ietf-mmusic-ice'>[20]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address  Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; September&nbsp;2007.</span><span>)</span></a> for better NAT traversal.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Open Issues</h3>

<p>There are a lot of open issues. Some of these are:
</p>
<p></p>
<ol class="text">
<li>Which KBR protocols shows the best performance for P2PNS? The
          Broose protocol seems to be a promising alternative to Kademlia.
</li>
<li>Where should the private key k_priv be stored (DHT, P2PNS Cache,
          SIP proxy)?
</li>
<li>Is it necessary to sign all messages or should only "important"
          messages be signed?
</li>
<li>What is the performance (bandwidth consumption/latency) of the
          two-stage approach compared to the direct approach?
</li>
</ol>

<a name="Acknowledgments"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgments</h3>

<p>This research was supported by the German Federal Ministry of
      Education and Research as part of the ScaleNet project 01BU567. The
      author likes to thank Sebastian Mies for his valuable contributions to
      this work.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
IANA Considerations</h3>

<p>This document has no actions for IANA.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Security Considerations</h3>

<p>Using crypto puzzles as defense against Sybil attacks is currently
      the most promising approach in completely decentralized networks.
      However crypto puzzles only make a Sybil attack harder and cannot
      completely prevent it. If the attacker has sufficient computing
      ressources to solve a large number of crypto puzzles particularly small
      networks as well as the bootstrap phase are still vulnerable to attacks.
      In these cases the nodeID assignment should additionally be restricted
      by using certificates of an offline CA.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3261">[1]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[2]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>15.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.bryan-p2psip-reload">[3]</a></td>
<td class="author-text">Bryan, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-bryan-p2psip-reload-01.txt">REsource LOcation And Discovery (RELOAD)</a>,&rdquo; draft-bryan-p2psip-reload-01 (work in progress), July&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-bryan-p2psip-reload-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.baset-p2psip-p2pp">[4]</a></td>
<td class="author-text">Baset, S. and H. Schulzrinne, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-baset-p2psip-p2pp-00.txt">Peer-to-Peer Protocol (P2PP)</a>,&rdquo; draft-baset-p2psip-p2pp-00 (work in progress), July&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-baset-p2psip-p2pp-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1035">[5]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1035, November&nbsp;1987 (<a href="http://www.rfc-editor.org/rfc/rfc1035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3920">[6]</a></td>
<td class="author-text"><a href="mailto:stpeter@jabber.org">Saint-Andre, P., Ed.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3920">Extensible Messaging and Presence Protocol (XMPP): Core</a>,&rdquo; RFC&nbsp;3920, October&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3920.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3920.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3920.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4423">[7]</a></td>
<td class="author-text">Moskowitz, R. and P. Nikander, &ldquo;<a href="http://tools.ietf.org/html/rfc4423">Host Identity Protocol (HIP) Architecture</a>,&rdquo; RFC&nbsp;4423, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4423.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="CommonAPI">[8]</a></td>
<td class="author-text">Dabek, F., Zhao, B., Druschel, P., Kubiatowicz, J., and I. Stoica, &ldquo;Towards a Common API for Structured Peer-to-Peer
          Overlays,&rdquo; Proceedings of the 2nd International Workshop on         Peer-to-Peer Systems (IPTPS '03)&nbsp;, 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="Kademlia">[9]</a></td>
<td class="author-text">Maymounkov, P. and D. Mazieres, &ldquo;Kademlia: A Peer-to-Peer Information System Based on the XOR
          Metric,&rdquo; Lecture Notes in Computer Science, Peer-to-Peer         Systems: First International Workshop (IPTPS 2002)&nbsp;, March&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-p2psip-concepts">[10]</a></td>
<td class="author-text">Bryan, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-p2psip-concepts-00.txt">Concepts and Terminology for Peer to Peer SIP</a>,&rdquo; draft-ietf-p2psip-concepts-00 (work in progress), July&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-p2psip-concepts-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SecureRouting">[11]</a></td>
<td class="author-text">Castro, M., Druschel, P., Ganesh, A., Rowstron, A., and D. Wallach, &ldquo;Secure routing for structured peer-to-peer overlay
          networks,&rdquo; SIGOPS Oper. Syst. Rev, ACM Press&nbsp;, 2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="SKademlia">[12]</a></td>
<td class="author-text">Baumgart, I. and S. Mies, &ldquo;S/Kademlia: A Practicable Approach Towards Secure Key-Based
          Routing,&rdquo; Proceedings of the International Workshop on Peer-to-Peer Networked Virtual Environments 2007 (P2P-NVE 2007), Hsinchu, Taiwan&nbsp;, December&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="X9.62">[13]</a></td>
<td class="author-text">American National Standards Institute, &ldquo;ANSI X9.62-2005, Public Key Cryptography for the Financial
          Services Industry: The Elliptic Curve Digital Signature Algorithm
          (ECDSA).&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS180-2">[14]</a></td>
<td class="author-text">National Insitute of Standards and
            Technology, &ldquo;FIPS 180-2, "Secure Hash Standard",&rdquo; 2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="MultipleHash">[15]</a></td>
<td class="author-text">Xia, Y., Chen, S., and V. Korgaonkar, &ldquo;Load Balancing with Multiple Hash Functions in Peer-to-Peer
          Networks,&rdquo; Proceedings of the 12th International Conference         on Parallel and Distributed Systems (ICPADS'06)&nbsp;, 2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.cheshire-dnsext-dns-sd">[16]</a></td>
<td class="author-text">Krochmal, M. and S. Cheshire, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-04.txt">DNS-Based Service Discovery</a>,&rdquo; draft-cheshire-dnsext-dns-sd-04 (work in progress), August&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ahrenholz-hiprg-dht">[17]</a></td>
<td class="author-text">Ahrenholz, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ahrenholz-hiprg-dht-01.txt">HIP DHT Interface</a>,&rdquo; draft-ahrenholz-hiprg-dht-01 (work in progress), February&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ahrenholz-hiprg-dht-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.garcia-p2psip-dns-sd-bootstrapping">[18]</a></td>
<td class="author-text">Garcia, G., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-garcia-p2psip-dns-sd-bootstrapping-00.txt">P2PSIP bootstrapping using DNS-SD</a>,&rdquo; draft-garcia-p2psip-dns-sd-bootstrapping-00 (work in progress), October&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3489">[19]</a></td>
<td class="author-text">Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, &ldquo;<a href="http://tools.ietf.org/html/rfc3489">STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)</a>,&rdquo; RFC&nbsp;3489, March&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3489.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[20]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-18.txt">Interactive Connectivity Establishment (ICE): A Protocol for Network Address  Translator (NAT) Traversal for Offer/Answer Protocols</a>,&rdquo; draft-ietf-mmusic-ice-18 (work in progress), September&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-18.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ingmar Baumgart</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Institute of Telematics, Universitaet Karlsruhe
      (TH)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Zirkel 2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Karlsruhe,   76128</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49 721 608 8281</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:baumgart@tm.uka.de">baumgart@tm.uka.de</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
