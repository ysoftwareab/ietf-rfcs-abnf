<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>RPL: Routing Protocol for Low Power
    and Lossy Networks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="RPL: Routing Protocol for Low Power
    and Lossy Networks">
<meta name="keywords" content="Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Networking Working Group</td><td class="header">T. Winter, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">&nbsp;</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header"> ROLL Design Team</td></tr>
<tr><td class="header">Expires: March 19, 2010</td><td class="header">IETF ROLL WG</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">September 15, 2009</td></tr>
</table></td></tr></table>
<h1><br />RPL: Routing Protocol for Low Power
    and Lossy Networks<br />draft-ietf-roll-rpl-01</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on March 19, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document specifies the Routing Protocol for Low Power and Lossy
      Networks (RPL), in accordance with the requirements described in <a class='info' href='#I-D.ietf-roll-building-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;building&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Martocci, J., Riou, N., Mil, P., and W. Vermeylen, &ldquo;Building Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; August&nbsp;2009.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-home-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;home&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Porcu, G., &ldquo;Home Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-indus-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;indus&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Networks, D., Thubert, P., Dwars, S., and T. Phinney, &ldquo;Industrial Routing Requirements in Low Power and Lossy Networks,&rdquo; June&nbsp;2009.</span><span>)</span></a>, and <a class='info' href='#RFC5548'>[RFC5548]<span> (</span><span class='info'>Dohler, M., Watteyne, T., Winter, T., and D. Barthel, &ldquo;Routing Requirements for Urban Low-Power and Lossy Networks,&rdquo; May&nbsp;2009.</span><span>)</span></a>.
</p>
<h3>Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Design Principles<br />
<a href="#Terminology">2.</a>&nbsp;
Terminology<br />
<a href="#ProtocolModel">3.</a>&nbsp;
Protocol Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.1.</a>&nbsp;
Problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.2.</a>&nbsp;
Protocol Properties Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.1.</a>&nbsp;
IPv6 Architecture<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.2.2.</a>&nbsp;
Path Properties for LLN Traffic Flows<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.2.3.</a>&nbsp;
Constraint Based Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.2.4.</a>&nbsp;
Autonomous Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.3.</a>&nbsp;
Protocol Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.3.1.</a>&nbsp;
DAG Construction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.3.2.</a>&nbsp;
Source Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">3.3.3.</a>&nbsp;
Destination Advertisement<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">3.4.</a>&nbsp;
Other Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DAGRank">3.4.1.</a>&nbsp;
DAG Rank and Loop Avoidance<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">3.4.2.</a>&nbsp;
DAG Parent Selection, Stability, and Greediness<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SectionDAGMerge">3.4.3.</a>&nbsp;
Merging DAGs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">3.4.4.</a>&nbsp;
Local and Temporary Routing Decision<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">3.4.5.</a>&nbsp;
Scalability<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">3.4.6.</a>&nbsp;
Maintenance of Routing Adjacency<br />
<a href="#ConstrainedLLNs">4.</a>&nbsp;
Constraint Based Routing in LLNs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">4.1.</a>&nbsp;
Routing Metrics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">4.2.</a>&nbsp;
Routing Constraints<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">4.3.</a>&nbsp;
Constraint Based Routing<br />
<a href="#SpecCore">5.</a>&nbsp;
Specification of Core Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DAGInformationOption">5.1.</a>&nbsp;
DAG Information Option<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.1.1.</a>&nbsp;
DIO base option<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">5.2.</a>&nbsp;
Conceptual Data Structures<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">5.2.1.</a>&nbsp;
Candidate Neighbors<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">5.2.2.</a>&nbsp;
DAGs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">5.3.</a>&nbsp;
Initialization and Configuration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DAGDiscovery">5.4.</a>&nbsp;
DAG Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">5.4.1.</a>&nbsp;
RA-DIO Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">5.4.2.</a>&nbsp;
RA-DIO Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TrickleImplementation">5.4.3.</a>&nbsp;
Trickle Timer for RA Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DAGHeartbeat">5.5.</a>&nbsp;
DAG Heartbeat<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">5.6.</a>&nbsp;
DAG Selection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">5.7.</a>&nbsp;
Administrative rank<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CandidateParentStates">5.8.</a>&nbsp;
Candidate DAG Parent States and Stability<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DAGHeldUp">5.8.1.</a>&nbsp;
Held-Up<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">5.8.2.</a>&nbsp;
Held-Down<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DAGCollision">5.8.3.</a>&nbsp;
Collision<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">5.8.4.</a>&nbsp;
Instability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">5.9.</a>&nbsp;
Guidelines for Objective Code Points<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">5.9.1.</a>&nbsp;
Objective Function<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor55">5.9.2.</a>&nbsp;
Objective Code Point 0 (OCP 0)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DestinationAdvertisement">5.10.</a>&nbsp;
Establishing Routing State Outward Along the DAG<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor59">5.10.1.</a>&nbsp;
Destination Advertisement Message Formats<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor60">5.10.2.</a>&nbsp;
Destination Advertisement Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#MaintenanceRoutingAdjacency">5.11.</a>&nbsp;
Maintenance of Routing Adjacency<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PacketForwarding">5.12.</a>&nbsp;
Packet Forwarding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor67">5.12.1.</a>&nbsp;
Loop Taxonomy<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor71">5.13.</a>&nbsp;
Expectations of Link Layer Behavior<br />
<a href="#anchor72">6.</a>&nbsp;
Summary of RPL Timers<br />
<a href="#SpecOptions">7.</a>&nbsp;
Protocol Extensions<br />
<a href="#Manageability">8.</a>&nbsp;
Manageability Considerations<br />
<a href="#Security">9.</a>&nbsp;
Security Considerations<br />
<a href="#IANA">10.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor73">10.1.</a>&nbsp;
DAG Information Option<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor74">10.2.</a>&nbsp;
Objective Code Point<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor75">10.3.</a>&nbsp;
Destination Advertisement Option<br />
<a href="#Acknowledgements">11.</a>&nbsp;
Acknowledgements<br />
<a href="#anchor76">12.</a>&nbsp;
Contributors<br />
<a href="#rfc.references1">13.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">13.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">13.2.</a>&nbsp;
Informative References<br />
<a href="#Requirements">Appendix&nbsp;A.</a>&nbsp;
Deferred Requirements<br />
<a href="#Examples">Appendix&nbsp;B.</a>&nbsp;
Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor79">B.1.</a>&nbsp;
Moving Down a DAG<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor80">B.2.</a>&nbsp;
Link Removed<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor81">B.3.</a>&nbsp;
Link Added<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor82">B.4.</a>&nbsp;
Node Removed<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor83">B.5.</a>&nbsp;
New LBR Added<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DestinationAdvertisementExample">B.6.</a>&nbsp;
Destination Advertisement<br />
<a href="#AdditionalExamples">Appendix&nbsp;C.</a>&nbsp;
Additional Examples<br />
<a href="#TODO">Appendix&nbsp;D.</a>&nbsp;
Outstanding Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor84">D.1.</a>&nbsp;
Additional Support for P2P Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor85">D.2.</a>&nbsp;
Loop Detection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor86">D.3.</a>&nbsp;
DAO Fan-out<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor87">D.4.</a>&nbsp;
Source Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor88">D.5.</a>&nbsp;
Address / Header Compression<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The defining characteristics of Low Power and Lossy Networks (LLNs)
      offer unique challenges to a routing solution. The IETF ROLL Working
      Group has defined application-specific routing requirements for a Low
      Power and Lossy Network (LLN) routing protocol <a class='info' href='#I-D.ietf-roll-building-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;building&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Martocci, J., Riou, N., Mil, P., and W. Vermeylen, &ldquo;Building Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; August&nbsp;2009.</span><span>)</span></a> <a class='info' href='#I-D.ietf-roll-home-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;home&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Porcu, G., &ldquo;Home Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; November&nbsp;2008.</span><span>)</span></a> <a class='info' href='#I-D.ietf-roll-indus-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;indus&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Networks, D., Thubert, P., Dwars, S., and T. Phinney, &ldquo;Industrial Routing Requirements in Low Power and Lossy Networks,&rdquo; June&nbsp;2009.</span><span>)</span></a> <a class='info' href='#RFC5548'>[RFC5548]<span> (</span><span class='info'>Dohler, M., Watteyne, T., Winter, T., and D. Barthel, &ldquo;Routing Requirements for Urban Low-Power and Lossy Networks,&rdquo; May&nbsp;2009.</span><span>)</span></a>. RPL is a new routing protocol designed to meet
      these requirements.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Design Principles</h3>

<p>RPL was designed with the objective to meet the requirements
        spelled out in <a class='info' href='#I-D.ietf-roll-building-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;building&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Martocci, J., Riou, N., Mil, P., and W. Vermeylen, &ldquo;Building Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; August&nbsp;2009.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-home-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;home&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Porcu, G., &ldquo;Home Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-indus-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;indus&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Networks, D., Thubert, P., Dwars, S., and T. Phinney, &ldquo;Industrial Routing Requirements in Low Power and Lossy Networks,&rdquo; June&nbsp;2009.</span><span>)</span></a>, and <a class='info' href='#RFC5548'>[RFC5548]<span> (</span><span class='info'>Dohler, M., Watteyne, T., Winter, T., and D. Barthel, &ldquo;Routing Requirements for Urban Low-Power and Lossy Networks,&rdquo; May&nbsp;2009.</span><span>)</span></a>. Because those requirements are heterogeneous
        and sometimes incompatible in nature, the approach is first taken to
        design a protocol capable of supporting a core set of functionalities
        corresponding to the intersection of the requirements. (Note: it is
        intended that as this design evolves optional features may be added to
        address some application specific requirements). All "MUST"
        application requirements that cannot be satisfied by RPL will be
        specifically listed in the Appendix A, accompanied by a
        justification.
</p>
<p>The core set of functionalities is to be capable of operating in
        the most severely constrained environments, with minimal requirements
        for memory, energy, processing, communication, and other consumption
        of limited resources from nodes. Trade-offs inherent in the
        provisioning of protocol features will be exposed to the implementer
        in the form of configurable parameters, such that the implementer can
        further tweak and optimize the operation of RPL as appropriate to a
        specific application and implementation. Finally, RPL is designed to
        consult implementation specific policies to determine, for example,
        the evaluation of routing metrics.
</p>
<p>A set of companion documents to this specification will provide
        further guidance in the form of applicability statements specifying a
        set of operating points appropriate to the Building Automation, Home
        Automation, Industrial, and Urban application scenarios.
</p>
<a name="Terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The terminology used in this document is consistent with and
      incorporates that described in `Terminology in Low power And Lossy
      Networks' <a class='info' href='#I-D.ietf-roll-terminology'>[I&#8209;D.ietf&#8209;roll&#8209;terminology]<span> (</span><span class='info'>Vasseur, J., &ldquo;Terminology in Low power And Lossy Networks,&rdquo; March&nbsp;2010.</span><span>)</span></a>. The
      terminology is extended in this document as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Autonomous:</dt>
<dd>Refers to the ability of a routing
          protocol to independently function without requiring any external
          influence or guidance. Includes self-organization capabilities.
</dd>
<dt>DAG:</dt>
<dd>Directed Acyclic Graph- A directed graph having
          the property that all edges are oriented in such a way that no
          cycles exist. In the RPL context, all edges are contained in paths
          oriented toward and terminating at a root node (a DAG root, or sink-
          typically a LBR).
</dd>
<dt>DAGID:</dt>
<dd>DAG Identifier- A globally unique identifier
          for a DAG. All nodes who are members of a DAG have knowledge of the
          DAGID. This knowledge is used to identify peer nodes within the DAG
          in order to coordinate DAG Maintenance while avoiding loops.
</dd>
<dt>DAG Parent:</dt>
<dd>A parent of a node within a DAG is one of
          the immediate successors of the node on a path towards the DAG root.
          For each DAGID that a node is a member of, the node will maintain a
          set containing one or more DAG Parents. If a node is a member of
          multiple DAGs then it must conceptually maintain a set of DAG
          Parents for each DAGID.
</dd>
<dt>DAG Sibling:</dt>
<dd>A sibling of a node within a DAG is
          defined in this specification to be any neighboring node which is
          located at the same rank (depth) within a DAG. Note that siblings
          defined in this manner do not necessarily share a common parent. For
          each DAG that a node is a member of, the node will maintain a set of
          DAG Siblings. If a node is a member of multiple DAGs then it must
          conceptually maintain a set of DAG Siblings for each DAG.
</dd>
<dt>DAG Root:</dt>
<dd>A DAG root is a sink within the DAG graph.
          All paths in the DAG terminate at a DAG root, and all DAG edges
          contained in the paths terminating at a DAG root are oriented toward
          the DAG root. There must be at least one DAG Root per DAG, and in
          some cases there may be more than one. In many use cases,
          source-sink represents a dominant traffic flow, where the sink is a
          DAG root. Maintaining default routing towards DAG roots is therefore
          a prominent functionality for RPL.
</dd>
<dt>Grounded:</dt>
<dd>A DAG is grounded if it contains a DAG Root
          offering a default route to an external routed infrastructure such
          as the Internet.
</dd>
<dt>Floating:</dt>
<dd>A DAG is floating if is not Grounded. A
          floating DAG may install a default route, although it is not
          expected to reach any additional external routed infrastructure such
          as the Internet.
</dd>
<dt>Inward:</dt>
<dd>In the context of RPL, inward refers to the
          direction from leaf nodes towards DAG roots, following the
          orientation of the edges within the DAG.
</dd>
<dt>Outward:</dt>
<dd>In the context of RPL, outward refers to the
          direction from DAG roots towards leaf nodes, going against the
          orientation of the edges within the DAG.
</dd>
<dt>P2P:</dt>
<dd>Point-to-point. This refers to traffic exchanged
          between two nodes.
</dd>
<dt>P2MP:</dt>
<dd>Point-to-Multipoint. This refers to traffic
          between one node and a set of nodes. This is similar to the P2MP
          concept in Multicast or MPLS Traffic Engineering (<a class='info' href='#RFC4461'>[RFC4461]<span> (</span><span class='info'>Yasukawa, S., &ldquo;Signaling Requirements for Point-to-Multipoint Traffic-Engineered MPLS Label Switched Paths (LSPs),&rdquo; April&nbsp;2006.</span><span>)</span></a> and <a class='info' href='#RFC4875'>[RFC4875]<span> (</span><span class='info'>Aggarwal, R., Papadimitriou, D., and S. Yasukawa, &ldquo;Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs),&rdquo; May&nbsp;2007.</span><span>)</span></a>). A
          common RPL use case involves P2MP flows from or through a DAG Root
          outward towards other nodes contained in the DAG.
</dd>
<dt>MP2P:</dt>
<dd>Multipoint-to-Point; used to describe a
          particular traffic pattern. A common RPL use case involves MP2P
          flows collecting information from many nodes in the DAG, flowing
          inwards towards DAG roots. Note that a DAG root may not be the
          ultimate destination of the information, but it is a common transit
          node.
</dd>
<dt>OCP:</dt>
<dd>Objective Code Point. In RPL, the Objective Code
          Point (OCP) indicates which routing metrics, optimization
          objectives, and related functions are in use in a DAG. Instances of
          the Objective Code Point are further described in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<p>Note that in this document, the terms `node' and `LLN router' are
      used interchangeably.
</p>
<a name="ProtocolModel"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Protocol Model</h3>

<p>The aim of this section is to describe RPL in the spirit of <a class='info' href='#RFC4101'>[RFC4101]<span> (</span><span class='info'>Rescorla, E. and IAB, &ldquo;Writing Protocol Models,&rdquo; June&nbsp;2005.</span><span>)</span></a>. An architectural protocol overview (the big
      picture of the protocol) is provided in this section. Protocol details
      can be found in further sections.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Problem</h3>

<p>Some well-defined LLN application-specific scenarios are Building
        Automation, Home Automation, Industrial, and Urban; for which the
        unique routing requirements have been detailed respectively in <a class='info' href='#I-D.ietf-roll-building-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;building&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Martocci, J., Riou, N., Mil, P., and W. Vermeylen, &ldquo;Building Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; August&nbsp;2009.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-home-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;home&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Porcu, G., &ldquo;Home Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-indus-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;indus&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Networks, D., Thubert, P., Dwars, S., and T. Phinney, &ldquo;Industrial Routing Requirements in Low Power and Lossy Networks,&rdquo; June&nbsp;2009.</span><span>)</span></a>, and <a class='info' href='#RFC5548'>[RFC5548]<span> (</span><span class='info'>Dohler, M., Watteyne, T., Winter, T., and D. Barthel, &ldquo;Routing Requirements for Urban Low-Power and Lossy Networks,&rdquo; May&nbsp;2009.</span><span>)</span></a>. Within these application-specific scenarios
        there are some common elements required of routing. RPL intends to
        address the requirements of these application-specific scenarios, and
        it is further intended to be flexible enough to extend to other
        application scenarios.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Protocol Properties Overview</h3>

<p>RPL demonstrates the following properties, consistent with the
        requirements specified by the requirements documents.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
IPv6 Architecture</h3>

<p>RPL is strictly compliant with layered IPv6 architecture.
</p>
<p>Further, RPL is designed with consideration to the practical
          support and implementation of IPv6 architecture on devices which may
          operate under severe resource constraints, including but not limited
          to memory, processing power, energy, and communication. The RPL
          design does not presume high quality reliable links, and should be
          able to operate over lossy links (usually low bandwidth with low
          packet delivery success rate).
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Path Properties for LLN Traffic Flows</h3>

<p>Multipoint-to-point (MP2P) and Point-to-multipoint (P2MP) traffic
          flows from nodes within the LLN from and to egress points are very
          common in LLNs. Low power and lossy network Border Router (LBR)
          nodes may typically be at the root of such flows, although such
          flows are not exclusively rooted at LBRs as determined on an
          application-specific basis. In particular, several applications such
          as building or home automation do require P2P (Point-to-Point)
          communication.
</p>
<p>As required by the aforementioned routing requirements documents,
          RPL supports the installation of multiple paths. The use of multiple
          paths include sending duplicated traffic along diverse paths, as
          well as to support advanced features such as Class of Service (CoS)
          based routing, or simple load balancing among a set of paths (which
          could be useful for the LLN to spread traffic load and avoid fast
          energy depletion on some nodes).
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
Constraint Based Routing</h3>

<p>The RPL design supports constraint based routing, based on a set
          of routing metrics. The routing metrics supported by RPL are
          specified in a companion document to this specification, <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>. RPL signals the
          metrics and related objective functions in use in a particular
          implementation by means of an Objective Code Point (OCP). Both the
          routing metrics and the OCP help determine the construction of the
          Directed Acyclic Graphs (DAG) using a distributed path computation
          algorithm.
</p>
<p>RPL supports the computation and installation of different paths
          in support of and optimized for a set of application and
          implementation specific constraints, as guided by an OCP. Traffic
          may subsequently be directed along the appropriate constrained path
          based on traffic marking within the IPv6 header. For more details on
          the approach towards constraint-based routing, see <a class='info' href='#ConstrainedLLNs'>Section&nbsp;4<span> (</span><span class='info'>Constraint Based Routing in LLNs</span><span>)</span></a>.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4"></a><h3>3.2.4.&nbsp;
Autonomous Operation</h3>

<p>Nodes running RPL are able to independently and autonomously
          discover a network topology and compute and install routes, without
          requiring further administrative interaction.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Protocol Operation</h3>

<p>LLN nodes running RPL will construct Directed Acyclic Graphs (DAGs)
        rooted at designated nodes that generally have some application
        significance, such as providing a default route to an external routed
        infrastructure. The DAG is sufficient to support inward MP2P traffic
        flows, flowing inward along the LLN towards a sink (DAG Root), which
        is one of the dominant traffic flows described in the requirements
        documents (<a class='info' href='#I-D.ietf-roll-building-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;building&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Martocci, J., Riou, N., Mil, P., and W. Vermeylen, &ldquo;Building Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; August&nbsp;2009.</span><span>)</span></a>,
        <a class='info' href='#I-D.ietf-roll-home-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;home&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Porcu, G., &ldquo;Home Automation Routing Requirements in Low Power and Lossy Networks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, <a class='info' href='#I-D.ietf-roll-indus-routing-reqs'>[I&#8209;D.ietf&#8209;roll&#8209;indus&#8209;routing&#8209;reqs]<span> (</span><span class='info'>Networks, D., Thubert, P., Dwars, S., and T. Phinney, &ldquo;Industrial Routing Requirements in Low Power and Lossy Networks,&rdquo; June&nbsp;2009.</span><span>)</span></a>, and <a class='info' href='#RFC5548'>[RFC5548]<span> (</span><span class='info'>Dohler, M., Watteyne, T., Winter, T., and D. Barthel, &ldquo;Routing Requirements for Urban Low-Power and Lossy Networks,&rdquo; May&nbsp;2009.</span><span>)</span></a>).
</p>
<p>By utilizing a DAG for dominant MP2P flows, RPL allows each node to
        select and maintain potentially multiple successors capable of
        forwarding traffic inwards towards the root. The DAG does not present
        as many single points of failure as a tree, and in addition can offer
        a node a set of pre-computed successors in support of, e.g. local
        route repair in case of a temporary failure, load balancing, or short
        term fluctuations in link characteristics.
</p>
<p>A DAG also serves to restrict the routing problem on the nodes when
        it is used as a reference topology. This allows nodes to determine
        their positions in a DAG relative to each other and provides a means
        to coordinate route repair in a way that endeavors to avoid loops.
        These mechanisms will be described in more detail later in this
        specification.
</p>
<p>As DAGs are organized, RPL will use a Destination Advertisement
        mechanism to build up routing state in support of outward P2MP traffic
        flows. This mechanism, using the DAG as a reference, `paints' the
        underlying LLN graph, guided along the DAG, such that the routes
        toward destination prefixes in the outward direction may be set up. As
        the DAG undergoes modification during DAG maintenance, the Destination
        Advertisement mechanism can be triggered to update the outward routing
        state.
</p>
<p>Arbitrary P2P traffic MAY flow inward along the DAG until a common
        parent is reached who has stored routing state and is capable of
        directing the traffic outward along the correct outward path. In the
        present specification RPL does not specify nor preclude any additional
        mechanisms that may be capable to compute and install more optimal
        routes into LLN nodes in support of arbitrary P2P traffic. (Note that
        in some application scenarios it may be important to support arbitrary
        P2P traffic along more optimal paths `across' the DAG). This
        functionality is to be investigated further in a future revision.
</p>
<p>This section further describes the high level operation of RPL.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
DAG Construction</h3>

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.1"></a><h3>3.3.1.1.&nbsp;
Overview of a Typical Case</h3>

<p>RPL constructs one or more base routing topologies, in the form
            of DAGs, over gradients defined by optimizing cost metrics along
            paths rooted at designated nodes.
</p>
<p>DAGs may be grounded, in which case the DAG Root (e.g. an LBR)
            is offering a default route to an external routed infrastructure
            such as the Internet. A typical goal for a node participating in
            DAG Construction may be to find and join a grounded DAG. Any DAG
            which is not grounded is floating, and default routes may still be
            provisioned toward the DAG root although with no expectations of
            reaching an external infrastructure.
</p>
<p>In the context of a particular LLN application one or more
            nodes will be capable of, e.g. serving as an LBR or acting as a
            data collection point, and thus be provisioned to act as the most
            preferred DAG roots. These nodes will begin the process of
            constructing a DAG by occasionally emitting Router Advertisements
            containing the necessary information for neighboring nodes to
            evaluate the DAG Root as a potential DAG parent. This information
            will include a DAGID, a DAGPreference, and an Objective Code Point
            (OCP). The DAGID is an identifier unique to the DAG. The
            DAGPreference offers a way to engineer the formation of the DAG in
            support of the application, by providing a mechanism by which the
            DAG may look attractive for other nodes to join. The OCP provides
            information as to which metrics and optimization goals are being
            employed across the DAG. Note that a single DAG Root may
            conceptually root different DAGs with different OCPs as required
            to support different sets of routing constraints. In this case the
            DAG Root must provision each different DAG with a different DAGID.
            Note that if multiple nodes acting as DAG roots are rooting the
            same DAG, i.e. presenting the same DAGID, then they must have some
            means of coordinating with each other when emitting Router
            Advertisements (This may be the case, for example, when the DAG is
            provisioned with a `virtual root' through some backbone
            mechanism). This is described further below.
</p>
<p>Nodes who hear Router Advertisements, advertising a specific
            DAGID, will take into consideration several criteria when
            processing the extracted DAG information. A node may seek a DAG
            advertising a specific OCP, reflecting the implementation specific
            routing constraints understood by the node. In particular, a node
            will be seeking to find a least cost path satisfying some
            objective function as indicated by the OCP according to some
            routing metrics defined in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>. For example, the
            least cost path may be determined in part by minimizing energy
            along a path, or latency, or avoiding the use of battery powered
            nodes. A node may be seeking to explicitly join a grounded DAG.
            Further, a node may seek the minimum DAGPreference when selecting
            a DAG, all else being equal. Based on the evaluation of such
            criteria, a node may determine if the node who emitted the Router
            Advertisement should be considered as a potential DAG parent. If
            so, then the node may add the advertising node to its set of
            candidate DAG parents for the advertised DAGID, and after waiting
            for a designated delay, the node may follow the procedures to
            activate the advertising node as a DAG parent and may then be
            considered to have joined the DAG designated by DAGID.
</p>
<p>When a node adds the first DAG parent to the set of DAG parents
            for a particular DAGID, the node is said to have joined, or
            attached to, the DAG designated by DAGID. Adding additional DAG
            parents beyond the first simply increases path diversity inwards
            toward the DAG root. When a node removes the last DAG Parent from
            the set of DAG parents for a particular DAGID, the node is said to
            have left, or detached from, the DAG designated by DAGID. RPL will
            coordinate the joining, leaving, and movement of nodes within a
            DAGID in such a way so as to avoid the formation of loops, as
            described further below.
</p>
<p>As nodes join the DAG they are able advertise the fact by
            beginning to multicast the DAG information in Router
            Advertisements (to neighbors with a link-local scope). In this
            way, nodes are able to join the DAG at ever-increasing rank
            outward from the DAG root. As nodes continue to receive DAG
            multicasts they may continue to expand their set of DAG parents,
            while employing loop avoidance strategies as describe below, in
            order to build path diversity inwards toward the DAG root.
</p>
<p>Using the information conveyed in the metrics of its most
            preferred DAG parent, its own metrics, and the conventions and
            functions indicated by the OCP, a node is able to compute a rank
            value within the DAG which it will use to coordinate its DAG
            maintenance.
</p>
<p>In addition to identifying DAG parents, a node also may hear
            the Router Advertisements of other neighboring nodes at the same
            rank within the DAG. In this way a node can discover DAG
            Siblings.
</p>
<p>A node may order its set of DAG parents according to some
            implementation specific preference. To this list the node may also
            append a similarly ordered set of DAG siblings. By forwarding
            traffic intended for the default destination towards the DAG
            parents, the node is able to support the main Multipoint-to-point
            (MP2P) traffic flows required by a typical LLN application. By
            using the ordered set of DAG parents and DAG siblings the node is
            able to take advantage of path diversity. For example, preferring
            to forward traffic towards parents guarantees to get the traffic
            inwards, closer to the DAG root, by definition, regardless of
            which parent is selected. In this example, if forwarding towards
            parents is not possible, perhaps due to a transient phenomena,
            then a node may then choose to forward traffic towards siblings,
            moving across the DAG at the same level (neither inwards or
            outwards). When receiving traffic forwarded from a sibling, the
            traffic should not be forwarded back to the same sibling in order
            to avoid a 2-node loop. In a further example, a forwarding
            implementation may choose to decrease the hop limit more quickly
            when forwarding along sibling paths than along parent paths. A
            forwarding engine may behave in a manner similar to these
            examples, however the specific implementation of a forwarding
            engine and related path diversity strategies is beyond the scope
            of this specification. Various related techniques are currently
            under investigation to be added in a later revision of this
            specification.
</p>
<p>Note that the further interaction of the routing solution and
            the forwarding engine, in particular how they utilize and react to
            changes in metrics, and how the forwarding engine may use the
            constrained set of successors provided by the routing engine based
            on L2 triggers and metrics, is under investigation.
</p>
<p>By employing this procedure, the LLN is able to set up a
            path-constrained DAG, rooted at designated nodes, with other nodes
            organized along paths leading inward toward the DAG root. MP2P
            traffic intended for the destinations available to or through the
            DAG root, e.g. the default destination or other advertised
            prefixes, flows inward along the DAG towards the root, and nodes
            forwarding traffic are able to leverage the path diversity of the
            DAG as necessary.
</p>
<p>The DAG is then used by RPL as a reference topology,
            constraining the LLN routing problem, on which to build additional
            routing mechanisms.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.2"></a><h3>3.3.1.2.&nbsp;
Further Operation</h3>

<p>The sub-DAG of a node is the set of other nodes of greater rank
            in the DAG that might use a path towards the DAG root that
            contains this node. Rank in the DAG is defined such that nodes
            contained in the sub-DAG of a specific node should have a greater
            rank than the node. This is an important property that is
            leveraged for loop avoidance- if a node has lesser rank then it is
            NOT in the sub-DAG. (An arbitrary node with greater rank may or
            may not be contained in the sub-DAG). Paths through siblings are
            not contained in this set.
</p>
<p>As a further illustration, consider the DAG examples in <a class='info' href='#Examples'>Appendix&nbsp;B<span> (</span><span class='info'>Examples</span><span>)</span></a>. Consider Node (24) in the DAG Example
            depicted in <a class='info' href='#DAGExample'>Figure&nbsp;12<span> (</span><span class='info'>Example DAG</span><span>)</span></a>. In this example,
            the sub-DAG of Node (24) is comprised of Nodes (34), (44), and
            (45).
</p>
<p>A DAG may also be floating. Floating DAGs may be encountered,
            for example, during coordinated reconfigurations of the network
            topology wherein a node and its sub-DAG breaks off the DAG,
            temporarily becomes a floating DAG, and reattaches to a grounded
            DAG at a different (more optimal) location. (Such coordination
            endeavors to avoid the construction of transient loops in the
            LLN). A DAG, or a sub-DAG, may also become floating because of a
            network element failure. Note that in the case where a floating
            DAG exists as a consequence of DAG repair, the floating DAG is
            also intended to be transient and carries a marking to make it
            less attractive. Some specific application scenarios may employ
            permanent floating DAGS, e.g. DAGs without connectivity to an
            external routed infrastructure, as a matter of normal operation.
            In such cases the floating DAG is likely to have been provisioned
            by the application with a marking to make it more attractive.
            DAGPreference, a configurable property that may be used to
            engineer the attractiveness of a DAG, is further described
            below.
</p>
<p>A node will generally join at least one DAG, typically (but not
            necessarily) to or through a grounded DAG rooted at an LBR. In
            some cases, as suitable to the application scenario, a DAG may
            still provision the default route toward DAG Parents and not be
            connected to a backbone network or the Internet.
</p>
<p>This specification does not preclude a node from joining
            multiple DAGs. In one such case, a particular application may
            require the node to maintain membership in multiple DAGs in order
            to satisfy competing constraints, for example to support different
            types of traffic, similar to the concept of MTR (Multi-topology
            routing) as supported by other routing protocols such as IS-IS
            <a class='info' href='#RFC5120'>[RFC5120]<span> (</span><span class='info'>Przygienda, T., Shen, N., and N. Sheth, &ldquo;M-ISIS: Multi Topology (MT) Routing in Intermediate System to Intermediate Systems (IS-ISs),&rdquo; February&nbsp;2008.</span><span>)</span></a> or OSPF <a class='info' href='#RFC4915'>[RFC4915]<span> (</span><span class='info'>Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P. Pillay-Esnault, &ldquo;Multi-Topology (MT) Routing in OSPF,&rdquo; June&nbsp;2007.</span><span>)</span></a>, although the RPL mechanisms will
            significantly differ from the ones specified for these protocols.
            (Note that not all constrained traffic cases may require multiple
            DAGs). In support of such cases the RPL implementation must
            independently maintain requisite information and state for each
            DAG in parallel. In cases where a competing constraints must be
            satisfied toward the same DAG root, the OCP should differ by
            definition and may serve to coordinate the maintenance of the
            multiple DAGs. Further, additional recommendations for the
            operation of loop avoidance/loop detection mechanisms in the
            presence of multiple DAGs are under investigation.
</p>
<p>An administered preference (DAGPreference) shall be associated
            with each DAG. In cases where a RPL node has a choice of joining
            more than one DAG to satisfy a particular constraint, and all else
            being equal, the node will seek to join the DAG with the lowest
            preference value. In practice this mechanism may be assist in
            engineering the construction of a DAG as appropriate to an
            application. For example, nodes that are to become DAG roots in
            support of a particular application role, e.g. as a data sink or a
            controller, may be provisioned with a low DAG preference, e.g.
            0x00. Nodes who are serving as the DAG root of a transient DAG,
            e.g. for DAG repair, may take on a high DAG preference, e.g. 0xFF.
            Nodes will then be able to yield their transient DAGs to join the
            DAGs with lower DAGPreference.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.3"></a><h3>3.3.1.3.&nbsp;
Router Advertisement - DAG Information Option (RA-DIO)</h3>

<p>The IPv6 Router Advertisement mechanism (as specified in <a class='info' href='#RFC4861'>[RFC4861]<span> (</span><span class='info'>Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;Neighbor Discovery for IP version 6 (IPv6),&rdquo; September&nbsp;2007.</span><span>)</span></a>) is used by RPL in order to build and
            maintain a DAG.
</p>
<p>The IPv6 Router Advertisement message is augmented with a DAG
            Information Option (DIO) in order to facilitate the formation and
            maintenance of DAGs. The information conveyed in the DIO includes
            the following:
</p>
<p></p>
<ul class="text">
<li>A DAGID used to identify the DAG as sourced from the DAG
                Root. Typically the (potentially compressed) IPv6 address of
                the DAG Root. May be tested for equality. The DAGID MUST be
                unique to a single DAG in the scope of the LLN. If the DAG
                Root is rooting multiple DAGs, each must be provisioned with
                their own IPv6 address and thus derive unique DAGIDs.
</li>
<li>Objective Code Point (OCP) as described below.
</li>
<li>Rank information used by nodes to determine their
                relationships in the DAG relative to each other, i.e. parents,
                siblings, or children. This is not a metric, although its
                derivation is typically closely related to one or more metrics
                as specified by the OCP. Used to support loop avoidance
                strategies and in support of ordering alternate successors
                when engaged in path maintenance.
</li>
<li>Sequence number originated from the DAG root, used to aid
                in identification of dependent sub-DAGs and coordinate
                topology changes in a manner so as to avoid loops.
</li>
<li>Indications for the DAG, e.g. grounded or floating.
</li>
<li>DAG configuration parameters.
</li>
<li>A vector of path metrics. As discussed in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a> such metrics
                may be cumulative, may report a maximum, minimum, or average
                scalar value, or a link property.
</li>
<li>List of additional destination prefixes reachable via the
                DAG root.
</li>
</ul>

<p>The Router Advertisements are issued whenever a change is
            detected to the DAG such that a node is able to determine that a
            region of the DAG has become inconsistent. As the DAG stabilizes
            the period at which Router Advertisements occur is configured to
            taper off, reducing the steady-state overhead of DAG maintenance.
            The periodic issue of Router Advertisements, along with the
            triggered Router Advertisements in response to inconsistency, is
            one feature that enables RPL to operate in the presence of
            unreliable links.
</p>
<p>The RA-DIO and related mechanisms are described in more detail
            in <a class='info' href='#SpecCore'>Section&nbsp;5<span> (</span><span class='info'>Specification of Core Protocol</span><span>)</span></a>.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.4"></a><h3>3.3.1.4.&nbsp;
Objective Code Point (OCP)</h3>

<p>The OCP is seeded by the DAG Root and serves to convey and
            control the optimization functions used within the DAG. The OCP is
            further specified in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>. Each instance of
            an allocated OCP indicates:
</p>
<p></p>
<ul class="text">
<li>The set of metrics used within the DAG
</li>
<li>The objective functions used to determine the least cost
                constrained paths in order to optimize the DAG
</li>
<li>The function used to compute DAG Rank
</li>
<li>The functions used to construct derived metrics for
                propagation within a DIO
</li>
</ul>

<p>For example, an objective code point might indicate that the
            DAG is using ETX as a metric, that the optimization goal is to
            minimize ETX, that DAG Rank is equivalent to ETX, and that DIO
            propagation entails adding the advertised ETX of the most
            preferred parent to the ETX of the link to the most preferred
            parent.
</p>
<p>By using defined OCPs that are understood by all nodes in a
            particular implementation, and by conveying them in the DIO, RPL
            nodes may work to build optimized LLN using a variety of
            application and implementation specific metrics and goals.
</p>
<p>A default OCP, OCP 0, is specified with a well-defined default
            behavior. OCP 0 is used to define RPL behaviors in the case where
            a node encounters a DIO containing a code point that it does not
            support.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.5"></a><h3>3.3.1.5.&nbsp;
Selection of Feasible DAG Parents</h3>

<p>The decision for a node to join a DAG may be optimized
            according to implementation specific policy functions on the node
            as indicated by one or more specific OCP values. For example, a
            node may be configured for one goal to optimize a bandwidth metric
            (OCP-1), and with a parallel goal to optimize for a reliability
            metric (OCP-2). Thus two DAGs, with two unique DAGIDs, may be
            constructed and maintained in the LLN: DAG-1 would be optimized
            according to OCP-1, whereas DAG-2 would be optimized according to
            OCP-2. A node may then maintain two parallel sets of DAG parents
            and related data structures. Note that in such a case traffic may
            directed along the appropriate constrained DAG based on traffic
            marking within the IPv6 header.
</p>
<p>As a node hears RAs from its neighbors it may process their
            DIOs. At this time the node may be able to take into
            consideration, for example, the following:
</p>
<p></p>
<ul class="text">
<li>Is the neighboring node heard reliably enough, and are the
                metrics stable enough, that a local degree of confidence may
                be established with respect to the neighboring node? Should
                the neighboring node be considered in the set of candidate
                neighbors?
</li>
<li>In consultation with implementation specific policy (OCP
                goal), is the neighboring node a feasible parent from a
                constrained-path perspective?
</li>
<li>According to the implementation specific policy (OCP), does
                the neighboring node offer a better optimized position into
                the DAG?
</li>
<li>Does the neighboring node offer a DAG with a better
                DAGPreference for an otherwise currently satisfied
                optimization objective, all else being equal?
</li>
<li>Is the neighboring node a peer (sibling) within the
                DAG?
</li>
</ul>

<p>Based on such considerations, the node may incorporate the
            neighboring node into the set of DAG parents according to
            implementation specific algorithms that are outside the scope of
            this document.
</p>
<p>When the node inserts the first DAG parent into the empty DAG
            parent set, it is able to join the DAG. After the DAG parent set
            is updated, the node will consult a rank computation function
            indicated by the OCP for the DAG in order to determine its rank
            value, which it will subsequently advertise when it emits its own
            DIOs. A general property of the rank value presented by the node
            is that it should be greater than that presented by any of its DAG
            parents. A node must maintain its DAG Parent set such that its
            most preferred parent from the OCP goals also has the greatest
            rank value in the DAG parent set. All reliable neighboring nodes
            of a lesser rank than the node may then be considered as potential
            DAG parents (Note that as a consequence of satisfying a particular
            OCP goal, the most preferred parent may not necessarily be the
            potential parent of least rank, for example a potential parent of
            lesser rank may also be an energy constrained device that is to
            generally be avoided and thus not the most preferred). No nodes of
            greater rank than the most preferred parent may be in the DAG
            Parent set; to allow such nodes will introduce a possibility to
            create loops (by potentially allowing a packet to make backwards
            progress as it is forwarded in the DAG). All neighboring nodes of
            equal rank may be considered as siblings within the DAG (even
            though they may not have parents in common, they may still provide
            path diversity towards the DAG root).
</p>
<p>The computation of rank, and related properties, are further
            described in <a class='info' href='#DAGRank'>Section&nbsp;3.4.1<span> (</span><span class='info'>DAG Rank and Loop Avoidance</span><span>)</span></a>.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.5.1"></a><h3>3.3.1.5.1.&nbsp;
Example</h3>

<p>For example, suppose that a node (N) is not attached to any
              DAG, and that it is in range of nodes (A), (B), (C), (D), and
              (E). Let all nodes be configured to use an OCP which defines a
              policy such that ETX is to be minimized and paths with the
              attribute `Blue' should be avoided. Let the rank computation
              indicated by the OCP simply reflect the ETX aggregated along the
              path. Let the links between node (N) and its neighbors (A-E) all
              have an ETX of 1 (which is learned by node (N) through some
              implementation specific method). Let node (N) be configured to
              send Router Solicitations to probe for nearby DAGs.
</p>
<p></p>
<ul class="text">
<li>Node (N) transmits a Router Solicitation.
</li>
<li>Node (B) responds. Node (N) investigates the DIO, and
                  learns that Node (B) is a member of DAGID 1 at rank 4, and
                  not `Blue'. Node (N) takes note of this, but is not yet
                  confident.
</li>
<li>Similarly, Node (N) hears from Node (A) at rank 9, Node
                  (C) at rank 5, and Node (E) at rank 4.
</li>
<li>Node (D) responds. Node (D) has a DIO that indicates that
                  it is a member of DAGID 1 at rank 2, but it carries the
                  attribute `Blue'. Node (N)'s policy function rejects Node
                  (D), and no further consideration is given.
</li>
<li>This process continues until Node (N), based on
                  implementation specific policy, builds up enough confidence
                  to trigger a decision to join DAGID 1. Let Node (N)
                  determine its most preferred parent to be Node (E).
</li>
<li>Node (N) adds Node (E) (rank 4) to its set of DAG Parents
                  for DAGID 1. Following the mechanisms specified by the OCP,
                  and given that the ETX is 1 for the link between (N) and
                  (E), Node (N) is now at rank 5 in DAGID 1.
</li>
<li>Node (N) adds Node (B) (rank 4) to its set of DAG Parents
                  for DAGID 1.
</li>
<li>Node (N) is a sibling of Node (C), both are at rank
                  5.
</li>
<li>Node (N) may now forward traffic intended for the default
                  destination inward along DAGID 1 via nodes (B) and (E). In
                  some cases, e.g. if nodes (B) and (E) are tried and fail,
                  node (N) may also choose to forward traffic to its sibling
                  node (C), without making inward progress but with the
                  intention that node (C) or a following successor can make
                  inward progress. Should Node (C) not have a viable parent,
                  it should never send the packet back to Node (N) (to avoid a
                  2-node loop).
</li>
</ul>

<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.6"></a><h3>3.3.1.6.&nbsp;
DAG Maintenance</h3>

<p>When a node moves within a DAG, the move is defined as updating
            the set of DAG Parents for a particular DAGID, i.e. adding or
            deleting DAG Parents. Not all moves entail changes in rank.
</p>
<p>A jump in the context of a DAG is attaching to a new DAGID, in
            such a way that an old DAGID is replaced by the new DAGID. In
            particular, when an old DAGID is left, all associated parents are
            no longer feasible, and a new DAGID is joined.
</p>
<p>When a node in a DAG follows a DAG parent, it means that the
            DAG parent has changed its DAGID (e.g. by joining a new DAG) and
            that the node updates its own DAGID in order to keep the DAG
            parent.
</p>
<p>A frozen sub-DAG is a subset of nodes in the sub-DAG of a node
            who have been informed of a change to the node, and choose to
            follow the node in a manner consistent with the change, for
            example in preparation for a coordinated move. Nodes in the
            sub-DAG who hear of a change and have other options than to follow
            the node do not have to become part of the frozen sub-DAG, for
            example such a node may be able to remain attached to the original
            DAG through a different DAG parent. A further example may be found
            in <a class='info' href='#SectionDAGMaintenance'>Section&nbsp;3.4.1.1<span> (</span><span class='info'>Example</span><span>)</span></a>.
</p>
<p>When the node encounters new candidate neighbors that offer
            higher positions in the DAG, it may incorporate them directly into
            its set of DAG parents. In this case the node may update its
            choice of most preferred parent, possibly causing its own
            advertised rank to decrease, and discarding any former parents now
            of a deeper rank. This case is `moving inwards along the DAG' and
            does not require any additional coordination for loop
            avoidance.
</p>
<p>If the DAG parent set of the node becomes completely depleted,
            the node will have detached from the DAG, and may, if so
            configured, become the root of its own transient floating DAG with
            a high DAGPreference (0xFF) (thus beginning the process of
            establishing the frozen sub-DAG), and then may reattach to the
            original DAG at a lower point if it is able (after hearing RA-DIOs
            from alternate attachment points).
</p>
<p>When the node encounters candidate parents that are in a
            different DAG, and decides to leave the current DAG in order to
            join the different DAG, it may do so safely without regard to loop
            avoidance. However, it may not return immediately to the current
            DAG as such movement may result in the creation of loops.
</p>
<p>When a node, and perhaps a related frozen sub-DAG, jumps to a
            different DAG, the move is coordinated by a DAG Hop timer. The DAG
            Hop timer allows the nodes who will attach closer to the sink of
            the new DAG to `jump' first, and then drag dependent nodes behind
            them, thus endeavoring to efficiently coordinate the attachment of
            the frozen sub-DAG into the new DAG. A further illustration of
            this mechanism may be found in <a class='info' href='#SectionDAGMerge'>Section&nbsp;3.4.3<span> (</span><span class='info'>Merging DAGs</span><span>)</span></a>.
</p>
<p><a class='info' href='#SpecCore'>Section&nbsp;5<span> (</span><span class='info'>Specification of Core Protocol</span><span>)</span></a> contains more detail on the
            processes and rules used for DAG discovery and maintenance.
</p>
<p><a class='info' href='#Examples'>Appendix&nbsp;B<span> (</span><span class='info'>Examples</span><span>)</span></a> provides additional examples of
            DAG discovery and maintenance.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
Source Routing</h3>

<p>A Source Routing mechanism for RPL is currently under
          investigation.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3"></a><h3>3.3.3.&nbsp;
Destination Advertisement</h3>

<p>As RPL constructs DAGs, nodes are able to learn a set of default
          routes in order to send traffic to the sink. However, this mechanism
          alone is not sufficient to support P2MP traffic flowing outward
          along the DAG from the DAG root toward nodes. A Destination
          Advertisement mechanism is employed by RPL to build up routing state
          in support of these outward flows. The Destination Advertisement
          mechanism may not be supported in all implementations, as
          appropriate to the application requirements. A DAG Root that
          supports using the Destination Advertisement mechanism to build up
          routing state will indicate such in the DIO. A DAG Root that
          supports using the Destination Advertisement mechanism MUST be
          capable of allocating enough state to store the routing state
          received from the LLN.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3.1"></a><h3>3.3.3.1.&nbsp;
Destination Advertisement Option (DAO)</h3>

<p>A Destination Advertisement Option (DAO) is used to convey the
            Destination information inward along the DAG toward the DAG
            root.
</p>
<p>The information conveyed in the DAO includes the following:
</p>
<p></p>
<ul class="text">
<li>A lifetime and sequence counter to determine the freshness
                of the Destination Advertisement.
</li>
<li>Depth information used by nodes to determine how far away
                the destination (the source of the Destination Advertisement)
                is
</li>
<li>Prefix information to identify the destination, which may
                be a prefix, an individual host, or multicast listeners
</li>
<li>Reverse Route information to record the nodes visited
                (along the outward path) when the intermediate nodes along the
                path cannot support storing state for Hop-By-Hop routing.
</li>
</ul>

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3.2"></a><h3>3.3.3.2.&nbsp;
Destination Advertisement Operation</h3>

<p>As the DAG is constructed and maintained, nodes are capable to
            emit messages containing Destination Advertisement Options to a
            subset of their DAG Parents. The selection of this subset is
            according to an implementation specific policy.
</p>
<p>As a special case, a node may periodically emit a link-local
            multicast message containing a Destination Advertisement Options
            advertising its locally available destination prefixes. This
            mechanism allows for the one-hop neighbors of a node to learn
            explicitly of the prefixes on the node, and in some application
            specific scenarios this is desirable in support of provisioning a
            trivial `one-hop' route. In this case, nodes who receive the
            multicast Destination Advertisement may use it to provision the
            one-hop route only, and not engage in any additional processing
            (so as not to engage the mechanisms used by a DAG Parent).
</p>
<p>When a (unicast) DAO reaches a node capable of storing routing
            state, the node extracts information from the DAO and updates its
            local database with a record of the DAO and who it was received
            from. When the node later propagates DAOs, it selects the best
            (least depth) information for each destination and conveys this
            information again in the form of DAOs to a subset of its own DAG
            parents. At this time the node may perform route aggregation if it
            is able, thus reducing the overall number of DAOs.
</p>
<p>When a (unicast) DAO reaches a node incapable of storing
            additional state, the node MUST append the next-hop address (from
            which neighbor the DAO was received) to a Reverse Route Stack
            carried within the DAO. The node then passes the DAO on to one or
            more of its DAG parents without storing any additional state.
</p>
<p>When a node that is capable of storing routing state encounters
            a (unicast) DAO with a Reverse Route Stack that has been
            populated, the node knows that the DAO has traversed a region of
            nodes that did not record any routing state. The node is able to
            detach and store the Reverse Route State and associate it with the
            destination described by the DAO. Subsequently the node may use
            this information to construct a source route in order to bridge
            the region of nodes that are unable to support Hop-By-Hop routing
            to reach the destination.
</p>
<p>In this way the Destination Advertisement mechanism is able to
            provision routing state in support of P2MP traffic flows outward
            along the DAG, and as according to the available resources in the
            network.
</p>
<p>Further aggregations of DAOs by destinations are possible in
            order to support additional scalability.
</p>
<p>A further example of the operation of the Destination
            Advertisement mechanism is available in <a class='info' href='#DestinationAdvertisementExample'>Appendix&nbsp;B.6<span> (</span><span class='info'>Destination Advertisement</span><span>)</span></a>
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Other Considerations</h3>

<a name="DAGRank"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
DAG Rank and Loop Avoidance</h3>

<p>When nodes select DAG Parents, they should select the most
          preferred parent according to their implementation specific
          objectives, using the cost metrics conveyed in the DIOs along the
          DAG in conjunction with the related objective functions as specified
          by the OCP.
</p>
<p>Based on this selection, the metrics conveyed by the most
          preferred DAG parent, the nodes own metrics and configuration, and a
          related function defined by the objective code point, a node will be
          able to compute a value for its rank as a consequence of selecting a
          most preferred DAG parent.
</p>
<p>It is important to note that the DAG Rank is not itself a metric,
          although its value is derived from and influenced by the use of
          metrics to select DAG parents and take up a position in the DAG. In
          other words, routing metrics and OCP (not rank directly) are used to
          determine the DAG structure and consequently the path cost. The only
          aim of the rank is to inform loop avoidance as explained hereafter.
          The computation of the DAG Rank MUST be done in such a way so as to
          maintain the following properties for any nodes M and N who are
          neighbors in the LLN:
</p>
<p></p>
<blockquote class="text">
<p>For a node N, and its most preferred parent M, DAGRank(N)
              &gt; DAGRank(M) must hold. Further, all parents in the DAG
              parent set must be of a rank less than or equal to DAGRank(M).
              In other words, the rank presented by a node N MUST be greater
              (deeper) than that presented by any of its parents. (This
              mechanism serves to avoid loops in the case where an alternate
              parent is used- if no alternate parent is deeper than the
              preferred parent then loops are avoided. The risk of loops
              occurs if there is a chance for an alternate parent to forward
              traffic to a deeper successor, which may be in the sub-DAG, and
              traffic then makes backwards progress and comes back to the node
              again).
</p>
<p>If DAGRank(M) &lt; DAGRank(N), then M is located in a more
              optimum position than N in the DAG with respect to the metrics
              and optimizations defined by the objective code point. Node M
              may safely be a DAG Parent for Node N without risk of creating a
              loop. For example, a Node M of rank 3 is located in a more
              optimum position than a Node N of rank 5. A packet directed
              inwards and forwarded from Node N to Node M will always make
              forward progress with respect to the DAG organization on that
              link; there is no risk of Node M at rank 3 forwarding the packet
              back into Node N's sub-DAG at rank of 5 or greater (which would
              be a sufficient condition for a loop to occur).
</p>
<p>If DAGRank(M) == DAGRank(N), then M and N are located
              positions of relatively the same optimality within the DAG. In
              some cases, Node M may be used as a successor by Node N, but
              with related chance of creating a loop that must be detected and
              broken by some other means. If Node M is at rank 3 and node N is
              at rank 3, then they are siblings; by definition Node M and N
              cannot be in each others sub-DAG. They may then forward to each
              other failing serviceable parents, making `sideways' progress
              (but not reverse progress). If another sibling or more gets
              involved there may then be some chance for 3 or more way loops,
              which is the risk of sibling forwarding.
</p>
<p>If DAGRank(M) &gt; DAGRank(N), then node M is located in a
              less optimum position than N in the DAG with respect to the
              metrics and optimizations defined by the objective code point.
              Further, Node (M) may in fact be in Node (N)'s sub-DAG. There is
              no advantage to Node (N) selecting Node (M) as a DAG Parent, and
              such a selection may create a loop. For example, if Node M is of
              rank 3 and Node N is of rank 5, then by definition Node N is in
              a less optimum position than Node N. Further, Node N at rank 5
              may in fact be in Node M's own sub-DAG, and forwarding a packet
              directed inwards towards the DAG root from M to N will result in
              backwards progress and possibly a loop.
</p>
</blockquote>

<p>For example, the DAG Rank could be computed in such a way so as
          to closely track ETX when the objective function is to minimize ETX,
          or latency when the objective function is to minimize latency, or in
          a more complicated way as appropriate to the objective code point
          being used within the DAG.
</p>
<p>The DAG rank is subsequently used to restrict the options a node
          has for movement within the DAG and to coordinate movements in order
          to avoid the creation of loops.
</p>
<p>A node may safely move `up' in the DAG, causing its DAG rank to
          decrease and moving closer to the DAG root without risking the
          formation of a loop.
</p>
<p>A node may not consider to move `down' the DAG, causing its DAG
          rank to increase and moving further from the DAG root. Such a move
          will entail moving to a less optimum position in the DAG in all
          cases, as defined by the objective code point. In the case where a
          node looses connectivity to the DAG, it must first leave the DAG
          before it may then rejoin at a deeper point. This allows for the
          node to coordinate moving down, freezing its own sub-DAG and
          poisoning stale routes to the DAG, and minimizing the chances of
          re-attaching to its own sub-DAG thinking that it has found the
          original DAG again. If a node where allowed to re-attach into its
          own sub-DAG a loop would most certainly occur, and may not be broken
          until a count-to-infinity process elapses. The procedure of
          detaching before moving down eliminates the need to
          count-to-infinity.
</p>
<p>Any neighboring nodes of lesser or equal rank to the current most
          preferred DAG parent are eligible to be considered as alternate DAG
          parents.
</p>
<p>The goal of a guaranteed consistent and loop free global routing
          solution for an LLN may not be practically achieved given the real
          behavior and volatility of the underlying metrics. The trade offs to
          achieve a stable approximation of global convergence may be too
          restrictive with respect to the need of the LLN to react quickly in
          response to the lossy environment. Globally the LLN may be able to
          achieve a weak convergence, in particular as link changes are able
          to be handled locally and result in minimal changes to global
          topology.
</p>
<p>RPL does not aim to guarantee loop free path selection, or strong
          global convergence. In order to reduce control overhead, in
          particular the expense of mechanisms such as count-to-infinity, RPL
          does try to avoid the creation of loops when undergoing topology
          changes. Further mechanisms to mitigate the impact of loops, such as
          loop detection when forwarding, are under investigation.
</p>
<a name="SectionDAGMaintenance"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1.1"></a><h3>3.4.1.1.&nbsp;
Example</h3>
<br /><hr class="insert" />
<a name="DAGMaintenance"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       :                      :                      :
       :                      :                      :
      (A)                    (A)                    (A)
       |\                     |                      |
       | `-----.              |                      |
       |        \             |                      |
      (B)       (C)          (B)       (C)          (B)
                 |                      |             \
                 |                      |              `-----.
                 |                      |                     \
                (D)                    (D)                    (C)
                                                               |
                                                               |
                                                               |
                                                              (D)

           -1-                    -2-                    -3-

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: DAG Maintenance&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Consider the example depicted in <a class='info' href='#DAGMaintenance'>Figure&nbsp;1<span> (</span><span class='info'>DAG Maintenance</span><span>)</span></a>-1. In this example, Node (A) is
            attached to a DAG at some rank d. Node (A) is a DAG Parent of
            Nodes (B) and (C). Node (C) is a DAG Parent of Node (D). There is
            also an undirected sibling link between Nodes (B) and (C).
</p>
<p>In this example, Node (C) may safely forward to Node (A)
            without creating a loop. Node (C) may not safely forward to Node
            (D), contained within it's own sub-DAG, without creating a loop.
            Node (C) may forward to Node (B) in some cases, e.g. the link
            (C)-&gt;(A) is temporarily unavailable, but with some chance of
            creating a loop (e.g. if multiple nodes in a set of siblings start
            forwarding `sideways' in a cycle) and requiring the intervention
            of additional mechanisms to detect and break the loop.
</p>
<p>Consider the case where Node (C) hears a DIO from a Node (Z) at
            a lesser rank and superior position in the DAG than node (A). Node
            (C) may safely undergo the process to evict node (A) from its DAG
            Parent set and attach directly to Node (Z) without creating a
            loop, because its rank will decrease.
</p>
<p>Consider the case where the link (C)-&gt;(A) becomes nonviable,
            and node (C) must move to a deeper rank within the DAG:
</p>
<p></p>
<ul class="text">
<li>Node (C) must first detach from the DAG by removing Node
                (A) from its DAG Parent set, leaving an empty DAG Parent set.
                Node (C) becomes the root of its own floating, less preferred,
                DAG.
</li>
<li>Node (D), hearing a modified RA-DIO from Node (C), follows
                Node (C) into the floating DAG. This is depicted in <a class='info' href='#DAGMaintenance'>Figure&nbsp;1<span> (</span><span class='info'>DAG Maintenance</span><span>)</span></a>-2. In general, any node with
                no other options in the sub-DAG of Node (C) will follow Node
                (C) into the floating DAG, maintaining the structure of the
                sub-DAG.
</li>
<li>Node (C) hears a RA-DIO from Node (B) and determines it is
                able to rejoin the grounded DAG by reattaching at a deeper
                rank to Node (B). Node (C) starts a DAG Hop timer to
                coordinate this move.
</li>
<li>The timer expires and Node (C) adds Node (B) to its DAG
                Parent set. Node (C) has now safely moved deeper within the
                grounded DAG without creating any loops. Node (D), and any
                other sub-DAG of Node (C), will hear the modified RA-DIO
                sourced from Node (C) and follow Node (C) in a coordinated
                manner to reattach to the grounded DAG. The final DAG is
                depicted in <a class='info' href='#DAGMaintenance'>Figure&nbsp;1<span> (</span><span class='info'>DAG Maintenance</span><span>)</span></a>-3
</li>
</ul>

<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
DAG Parent Selection, Stability, and Greediness</h3>

<p>If a node is greedy and attempts to move deeper in the DAG,
          beyond its most preferred parent, in order to increase the size of
          the DAG Parent set, then an instability can result. This is
          illustrated in <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>.
</p>
<p>Suppose a node is willing to receive and process a RA-DIOs from a
          node in its own sub-DAG, and in general a node deeper than it. In
          such cases a chance exists to create a feedback loop, wherein two or
          more nodes continue to try and move in the DAG in order to optimize
          against each other. In some cases this will result in an
          instability. It is for this reason that RPL mandates that a node
          MUST NOT receive and process RA-DIOs from deeper nodes. This rule
          creates an `event horizon', whereby a node cannot be influenced into
          an instability by the action of nodes that may be in its own
          sub-DAG.
</p>
<a name="GreedyExample"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2.1"></a><h3>3.4.2.1.&nbsp;
Example</h3>
<br /><hr class="insert" />
<a name="Greedy"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      (A)                    (A)                    (A)
       |\                     |\                     |\
       | `-----.              | `-----.              | `-----.
       |        \             |        \             |        \
      (B)       (C)          (B)        \            |        (C)
                               \        |            |        /
                                `-----. |            | .-----`
                                       \|            |/
                                       (C)          (B)

           -1-                    -2-                    -3-

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Greedy DAG Parent Selection&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Consider the example depicted in <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>.
            A DAG is depicted in 3 different configurations. A usable link
            between (B) and (C) exists in all 3 configurations. In <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-1, Node (A) is a DAG Parent for Nodes (B)
            and (C), and (B)--(C) is a sibling link. In <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-2, Node (A) is a DAG Parent for Nodes (B)
            and (C), and Node (B) is also a DAG Parent for Node (C). In <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-3, Node (A) is a DAG Parent for Nodes (B)
            and (C), and Node (C) is also a DAG Parent for Node (B).
</p>
<p>If a RPL node is too greedy, in that it attempts to optimize
            for an additional number of parents beyond its preferred parent,
            then an instability can result. Consider the DAG illustrated in
            <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-1. In this example, Nodes (B) and
            (C) may most prefer Node (A) as a DAG Parent, but are operating
            under the greedy condition that will try to optimize for 2
            parents.
</p>
<p></p>
<ul class="text">
<li>Let <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-1 be the initial
                condition.
</li>
<li>Suppose Node (C) first is able to leave the DAG and rejoin
                at a lower rank, taking both Nodes (A) and (B) as DAG parents
                as depicted in <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-2. Now Node (C)
                is deeper than both Nodes (A) and (B), and Node (C) is
                satisfied to have 2 DAG parents.
</li>
<li>Suppose Node (B), in its greediness, is willing to receive
                and process a DIO from Node (C) (against the rules of RPL),
                and then Node (B) leaves the DAG and rejoins at a lower rank,
                taking both Nodes (A) and (C) as DAG Parents. Now Node (B) is
                deeper than both Nodes (A) and (C) and is satisfied with 2 DAG
                parents.
</li>
<li>Then Node (C) will leave and rejoin deeper, to again get 2
                parents
</li>
<li>Then Node (B) will leave and rejoin deeper, to again get 2
                parents
</li>
<li>...
</li>
<li>The process will repeat, and the DAG will oscillate between
                <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-2 and <a class='info' href='#Greedy'>Figure&nbsp;2<span> (</span><span class='info'>Greedy DAG Parent Selection</span><span>)</span></a>-3 until the nodes count to infinity
                and restart the cycle again.
</li>
<li>This cycle can be averted through mechanisms in RPL: 
<ul class="text">
<li>Nodes (B) and (C) stick at a rank sufficient to attach
                    to their most preferred parent (A) and don't go for any
                    deeper (worse) alternate parents (Nodes are not
                    greedy)
</li>
<li>Nodes (B) and (C) don't process DIOs from nodes deeper
                    than themselves (possibly in their own sub-DAGs)
</li>
</ul>
</li>
</ul>

<a name="SectionDAGMerge"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Merging DAGs</h3>

<p>The merging of DAGs is coordinated in a way such as to try and
          merge two DAGs cleanly, preserving as much DAG structure as
          possible, and in the process effecting a clean merge with minimal
          likelihood of forming transient loops
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3.1"></a><h3>3.4.3.1.&nbsp;
Example</h3>
<br /><hr class="insert" />
<a name="DAGMerge"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                             :
                             :
                            (A)       (D)
                             |         |
                             |         |
                             |         |
                            (B)       (E)
                             |         |
                             |         |
                             |         |
                            (C)       (F)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Merging DAGs&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Consider the example depicted in <a class='info' href='#DAGMerge'>Figure&nbsp;3<span> (</span><span class='info'>Merging DAGs</span><span>)</span></a>. Nodes (A), (B), and (C) are part of
            some larger grounded DAG, where Node (A) is at a rank of d, Node
            (B) at d+1, and Node (C) at d+2. The DAG comprised of Nodes (D),
            (E), and (F) is a floating, less preferred, DAG, with Node (D) as
            the DAG root. This floating DAG may have been formed, for example,
            in the absence of a grounded DAG or when Node (D) had to detach
            from a grounded DAG and (E) and (F) followed. All nodes are using
            compatible objective code points.
</p>
<p>Nodes (D), (E), and (F) would rather join the more preferred
            grounded DAG if they are able than to remain in the less preferred
            floating DAG.
</p>
<p>Next, let links (C)--(D) and (A)--(E) become viable. The
            following sequence of events may then occur in a typical case:
</p>
<p></p>
<ul class="text">
<li>Node (D) will receive and process a RA-DIO from Node (C) on
                link (C)--(D). Node (D) will consider Node (C) a candidate
                neighbor, will note that Node (C) is in a grounded DAG at rank
                d+2, and will begin the process to join the grounded DAG at
                rank d+3. Node (D) will start a DAG Hop timer, logically
                associated with the grounded DAG at Node (C), to coordinate
                the jump. The DAG Hop timer will have a duration proportional
                to d+2.
</li>
<li>Similarly, Node (E) will receive and process a RA-DIO from
                Node (A) on link (A)--(E). Node (E) will consider Node (A) a
                candidate neighbor, will note that Node (A) is in a grounded
                DAG at rank d, and will begin the process to join the grounded
                DAG at rank d+1. Node (E) will start a DAG Hop timer,
                logically associated with the grounded DAG at Node (A), to
                coordinate the jump. The DAG Hop timer will have a duration
                proportional to d.
</li>
<li>Node (F) takes no action, for Node (F) has observed nothing
                new to act on.
</li>
<li>Node (E)'s DAG Hop timer for the grounded DAG at Node (A)
                expires first. Node (E), upon the DAG Hop timer expiry, is
                removes Node (D), thus emptying the DAG parent set for the
                floating DAG and leaving the floating DAG. Node (E) then jumps
                to the grounded DAG by entering Node (A) into the set of DAG
                Parents for the grounded DAG. Node (E) is now in the grounded
                DAG at rank d+1. Node (E), by jumping into the grounded DAG,
                has created an inconsistency and will begin to emit RA-DIOs
                more frequently.
</li>
<li>Node (F) will receive and process a RA-DIO from Node (E).
                Node (F) will observe that Node (E) has changed its DAGID and
                will directly follow Node (E) into the grounded DAG. Node (F)
                is now a member of the grounded DAG at rank d+2. Note that any
                additional sub-DAG of Node (E) would continue to join into the
                grounded DAG in this coordinated manner.
</li>
<li>Node (D) will receive a RA-DIO from Node (E). Since Node
                (E) is now in a different DAG, Node (D) may process the RA-DIO
                from Node (E). Node (D) will observe that, via node (E), it
                could attach to the grounded DAG at rank d+2. Node (D) will
                start another DAG Hop timer, logically associated with the
                grounded DAG at Node (E), with a duration proportional to d+1.
                Node (D) now is running two DAG hop timers, one which was
                started with duration proportional to d+1 and one proportional
                to d+2.
</li>
<li>Generally, Node (D) will expire the timer associated with
                the jump to the grounded DAG at node (E) first. Node (D) may
                then jump to the grounded DAG by entering Node (E) into its
                DAG Parent set for the grounded DAG. Node (D) is now in the
                grounded DAG at rank d+2.
</li>
<li>In this way RPL has coordinated a merge between the more
                preferred grounded DAG and the less preferred floating DAG,
                such that the nodes within the two DAGs come together in a
                generally ordered manner, avoiding the formation of loops in
                the process.
</li>
</ul>

<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4"></a><h3>3.4.4.&nbsp;
Local and Temporary Routing Decision</h3>

<p>Although implementation specific, it is worth noting that a node
          may decide to implement some local routing decision based on some
          metrics, as observed locally or reported in the DIO. For example,
          the routing may reflect a set of successors (next-hop), along with
          various aggregated metrics used to load balance the traffic
          according to some local policy. Such decisions are local and
          implementation specific.
</p>
<p>Routing stability is crucial in a LLN: in the presence of
          unstable links, the first option consists of removing the link from
          the DAG and triggering a DAG recomputation across all of the nodes
          affected by the removed link. Such a naive approach could
          unavoidably lead to frequent and undesirable changes of the DAG,
          routing instability, and high-energy consumption. The alternative
          approach adopted by RPL relies on the ability to temporarily not use
          a link toward a successor marked as valid, with no change on the DAG
          structure. If the link is perceived as non-usable for some period of
          time (locally configurable), this triggers a DAG recomputation,
          through the DAG Discovery mechanism further detailed in <a class='info' href='#DAGDiscovery'>Section&nbsp;5.4<span> (</span><span class='info'>DAG Discovery</span><span>)</span></a>, after reporting the link failure.
          Note that this concept may be extended to take into account other
          link characteristics: for the sake of illustration, a node may
          decide to send a fixed number of packets to a particular successor
          (because of limited buffering capability of the successor) before
          starting to send traffic to another successor.
</p>
<p>According to the local policy function, it is possible for the
          node to order the DAG parent set from `most preferred' to `least
          preferred'. By constructing such an ordered set, and by appending
          the set with siblings, the node is able to construct an ordered list
          of preferred next hops to assist in local and temporary routing
          decisions. The use of the ordered list by a forwarding engine is
          loosely constrained, and may take into account the dynamics of the
          LLN. Further, a forwarding engine implementation may decide to
          perform load balancing functions using hash-based mechanisms to
          avoid packet re-ordering. Note however, that specific details of a
          forwarding engine implementation are beyond the scope of this
          document.
</p>
<p>These decisions may be local and/or temporary with the objective
          to maintain the DAG shape while preserving routing stability.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5"></a><h3>3.4.5.&nbsp;
Scalability</h3>

<p>As each node selects DAG Parents according to implementation
          specific objectives, RPL is able to dynamically partition an LLN
          network into different regions, each anchored by a DAG root.
          Multiple DAG roots may be deployed in accordance with an
          implementation specific policy designed to limit the size of a
          partition, e.g. for performance or other reasons.
</p>
<p>A further example is illustrated in <a class='info' href='#AdditionalExamples'>Appendix&nbsp;C<span> (</span><span class='info'>Additional Examples</span><span>)</span></a>.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.6"></a><h3>3.4.6.&nbsp;
Maintenance of Routing Adjacency</h3>

<p>In order to relieve the LLN of the overhead of periodic
          keepalives, RPL MAY employ an as-needed mechanism of NS/NA in order
          to verify routing adjacencies just prior to forwarding data. Pending
          the outcome of verifying the routing adjacency, the packet may
          either be forwarded or an alternate next-hop may be selected.
</p>
<a name="ConstrainedLLNs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Constraint Based Routing in LLNs</h3>

<p>This aim of this section is to make a clear distinction between
      routing metrics and constraints and define the term constraint based
      routing as used in this document.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Routing Metrics</h3>

<p>Routing metrics are used by the routing protocol to compute the
        shortest path according to one of more defined metrics. IGPs such as
        IS-IS (<a class='info' href='#RFC5120'>[RFC5120]<span> (</span><span class='info'>Przygienda, T., Shen, N., and N. Sheth, &ldquo;M-ISIS: Multi Topology (MT) Routing in Intermediate System to Intermediate Systems (IS-ISs),&rdquo; February&nbsp;2008.</span><span>)</span></a>) and OSPF (<a class='info' href='#RFC4915'>[RFC4915]<span> (</span><span class='info'>Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P. Pillay-Esnault, &ldquo;Multi-Topology (MT) Routing in OSPF,&rdquo; June&nbsp;2007.</span><span>)</span></a>) compute the shortest path according to a
        Link State Data Base (LSDB) using link metrics configured by the
        network administrator. Such metrics can represent the link bandwidth
        (in which case the metric is usually inversely proportional to the
        bandwidth), delay, etc. Note that in some cases the metric is a
        polynomial function of several metrics defining different link
        characteristics. The resulting shortest path cost is equal to the sum
        (or multiplication) of the link metrics along the path: such metrics
        are said to be additive or multiplicative metrics.
</p>
<p>Some routing protocols support more than one metric: in the vast
        majority of the cases, one metric is used per (sub)topology. Less
        often, a second metric may be used as a tie breaker in the presence of
        ECMP (Equal Cost Multiple Paths). The optimization of multiple metrics
        is known as an NP complete problem and is sometimes supported by some
        centralized path computation engine.
</p>
<p>In the case of RPL, it is virtually impossible to define *the*
        metric, or even a composite, that will fit it all:
</p>
<p></p>
<ul class="text">
<li>Some information apply to path setup time, other apply to
            packet forwarding time.
</li>
<li>Some values are aggregated hop-by-hop, others are triggers from
            L2.
</li>
<li>Some properties are very stable, others vary rapidly.
</li>
<li>Some data are useful in a given scenario and useless in
            another.
</li>
<li>Some arguments are scalar, others statistical.
</li>
</ul>

<p>For that reason, the RPL protocol core is agnostic to the logic
        that handles metrics. A node will be configured with some external
        logic to use and prioritize certain metrics for a specific scenario.
        As new heterogeneous devices are installed to support the evolution of
        a network, or as networks form in a totally ad-hoc fashion, it will
        happen that nodes that are programmed with antagonistic logics and
        conflicting or orthogonal priorities end up participating in the same
        network. It is thus RECOMMENDED to use consistent parent selection
        policy, as per Objective Code Points (OCP), to ensure consistent
        optimized paths.
</p>
<p>RPL is designed to survive and still operate, though in a somewhat
        degraded fashion, when confronted to such heterogeneity. The key
        design point is that each node is solely responsible for setting the
        vector of metrics that it sources in the DAG, derived in part from the
        metrics sourced from its preferred parent. As a result, the DAG is not
        broken if another node makes its decisions in as antagonistic fashion,
        though an end-to-end path might not fully achieve any of the
        optimizations that nodes along the way expect. The default operation
        specified in OCP 0 clarifies this point.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Routing Constraints</h3>

<p>A constraint is a link or a node characteristic that must be
        satisfied by the computed path (using boolean values or lower/upper
        bounds) and is by definition neither additive nor multiplicative.
        Examples of links constraints are "available bandwidth",
        "administrative values (e.g. link coloring)", "protected versus
        non-protected links", "link quality" whereas a node constraint can be
        the level of battery power, CPU processing power, etc.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Constraint Based Routing</h3>

<p>The notion of constraint based routing consists of finding the
        shortest path according to some metrics satisfying a set of
        constraints. A technique consists of first filtering out all links and
        nodes that cannot satisfy the constraints (resulting in a
        sub-topology) and then computing the shortest path.
</p>
<p></p>
<blockquote class="text">
<p>Example 1:
</p>
<blockquote class="text">
<p>Link Metric:&nbsp;&nbsp;&nbsp;&nbsp; Bandwidth
</p>
<p>Link Constraint: Blue
</p>
<p>Node Constraint: Mains-powered node
</p>
</blockquote>
<p>
</p>
<p>Objective function 1:
</p>
<blockquote class="text">
<p>"Find the shortest path (path with lowest cost where the path
              cost is the sum of all link costs (Bandwidth)) along the path
              such that all links are colored `Blue' and that only traverses
              Mains-powered nodes."
</p>
</blockquote>
<p>
</p>
<p>
</p>
<p>
</p>
<p>Example 2:
</p>
<blockquote class="text">
<p>Link Metric:&nbsp;&nbsp;&nbsp;&nbsp; Delay
</p>
<p>Link Constraint: Bandwidth
</p>
</blockquote>
<p>
</p>
<p>Objective function 2:
</p>
<blockquote class="text">
<p>"Find the shortest path (path with lowest cost where the path
              cost is the sum of all link costs (Delay)) along the path such
              that all links provide at least X Bit/s of reservable
              bandwidth."
</p>
</blockquote>
</blockquote>

<a name="SpecCore"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Specification of Core Protocol</h3>

<a name="DAGInformationOption"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
DAG Information Option</h3>

<p>The DAG Information Option carries a number of metrics and other
        information that allows a node to discover a DAG, select its DAG
        parents, and identify its siblings while employing loop avoidance
        strategies.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
DIO base option</h3>

<p>The DAG Information Option is a container option, which might
          contain a number of suboptions. The base option regroups the minimum
          information set that is mandatory in all cases.
</p>
<p><br /><hr class="insert" />
<a name="DIObase"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |    Length     |G|D|A|  Rsvd   |   Sequence    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | DAGPreference |                BootTimeRandom                 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   NodePref.   |    DAGRank    |           DAGDelay            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | DIOIntDoubl.  |  DIOIntMin.   |     DAGObjectiveCodePoint     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           PathDigest                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                            DAGID                              |
    +                                                               +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   sub-option(s)...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: DIO Base Option&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p></p>
<blockquote class="text"><dl>
<dt>Type:</dt>
<dd>8-bit unsigned identifying the DIO base
              option. The value is to be assigned by the IANA.
</dd>
<dt>Length:</dt>
<dd>8-bit unsigned integer set to 4 when there
              is no suboption. The length of the option (including the type
              and length fields and the suboptions) in units of 8 octets.
</dd>
<dt>Grounded (G):</dt>
<dd>The Grounded (G) flag is set when
              the DAG root is offering connectivity to an external routed
              infrastructure such as the Internet.
</dd>
<dt>Destination Advertisement Trigger (D):</dt>
<dd>The
              Destination Advertisement Trigger (D) flag is set when the DAG
              root or another node in the successor chain decides to trigger
              the sending of Destination Advertisements in order to update
              routing state for the outward direction along the DAG, as
              further detailed in <a class='info' href='#DestinationAdvertisement'>Section&nbsp;5.10<span> (</span><span class='info'>Establishing Routing State Outward Along the DAG</span><span>)</span></a>. Note that the use and
              semantics of this flag are still under investigation.
</dd>
<dt>Destination Advertisement Supported (A) :</dt>
<dd>The
              Destination Supported (A) bit is set when the DAG root is
              capable to support the collection of Destination Advertisement
              related routing state and enables the Destination Advertisement
              mechanism within the DAG.
</dd>
<dt>Reserved:</dt>
<dd>5-bit unsigned integer set to 0 by the
              DAG root and left unchanged by nodes propagating the DIO.
</dd>
<dt>Sequence Number:</dt>
<dd>8-bit unsigned integer set by the
              DAG root, incremented with each new DIO it sends on a link, and
              propagated with no change outwards along the DAG.
</dd>
<dt>DAGPreference:</dt>
<dd>8-bit unsigned integer set by the
              DAG root to its preference and unchanged at propagation. Default
              is 0 (lowest preference). The DAG preference provides an
              administrative mechanism to engineer the self-organization of
              the LLN, for example indicating the most preferred LBR. If a
              node has the option to join a DAG of lower preference while
              still meeting other optimization objectives, then the node will
              seek the minimum available preference.
</dd>
<dt>BootTimeRandom:</dt>
<dd>A random value computed at boot
              time and recomputed in case of a duplication with another node.
              The concatenation of the NodePreference and the BootTimeRandom
              is a 32-bit extended preference that is used to resolve
              collisions. It is set by each node at propagation time.
</dd>
<dt>NodePreference:</dt>
<dd>The administrative preference of
              that LLN Node. Default is 0. 255 is the highest possible
              preference. Set by each LLN Node at propagation time. Forms a
              collision tiebreaker in combination with BootTimeRandom.
</dd>
<dt>DAGRank:</dt>
<dd>8-bit unsigned integer. The DAG rank of
              the DAG root is 0. The DAG Rank of a node attached to the DAG
              should be greater than rank of its deepest DAG parent, as
              computed by an implementation specific routine. All nodes in the
              DAG advertise their DAG rank in the DAG Information Options that
              they append to the RA messages over their LLN interfaces as part
              of the propagation process.
</dd>
<dt>DAGDelay:</dt>
<dd>16-bit unsigned integer set by the DAG
              root indicating the delay before changing the DAG configuration,
              in TBD-units. A default value is TBD. It is expected to be an
              order of magnitude smaller than the RA-interval. It is also
              expected to be an order of magnitude longer than the typical
              propagation delay inside the LLN.
</dd>
<dt>DIOIntervalDoublings:</dt>
<dd>8-bit unsigned integer. Used
              to configure the trickle timer governing when RA-DIO should be
              sent within the DAG. DIOIntervalDoublings is the number of times
              that the DIOIntervalMin is allowed to be doubled during the
              trickle timer operation, i.e. DIOIntervalMax = DIOIntervalMin *
              2^(DIOIntervalDoublings).
</dd>
<dt>DIOIntervalMin:</dt>
<dd>8-bit unsigned integer. Used to
              configure the trickle timer governing when RA-DIO should be sent
              within the DAG. The minimum configured interval for the RA-DIO
              trickle timer in units of ms is 2^DIOIntervalMin. For example, a
              DIOIntervalMin value of 16ms is expressed as 4.
</dd>
<dt>DAGObjectiveCodePoint:</dt>
<dd>The DAG Objective Code
              Point is used to indicate the cost metrics, objective functions,
              and methods of computation and comparison for DAGRank in use in
              the DAG. The DAG OCP is set by the DAG Root. (Objective Code
              Points are to be further defined in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</dd>
<dt>PathDigest:</dt>
<dd>32-bit unsigned integer CRC, updated
              by each LLN Node. This is the result of a CRC-32c computation on
              a bit string obtained by appending the received value and the
              ordered set of DAG parents at the LLN Node. DAG roots use a
              'previous value' of zeroes to initially set the PathDigest. Used
              to determine when something in the set of successor paths has
              changed.
</dd>
<dt>DAGID:</dt>
<dd>128-bit unsigned integer which uniquely
              identify a DAG. This value is set by the DAG root. The global
              IPv6 address of the DAG root can be used.
</dd>
</dl></blockquote>

<p>The following values MUST NOT change during the propagation of
          the DIO outwards along the DAG: Type, Length, G, DAGPreference,
          DAGDelay and DAGID. All other fields of the DIO are updated at each
          hop of the propagation.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1.1"></a><h3>5.1.1.1.&nbsp;
DIO Suboptions</h3>

<p>In addition to the minimum options presented in the base
            option, a number of suboptions are defined for the DIO:
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1.1.1"></a><h3>5.1.1.1.1.&nbsp;
Format</h3>

<p><br /><hr class="insert" />
<a name="DIOsub"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Subopt. Type | Subopt Length | Suboption Data...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: DIO Suboption Generic Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p></p>
<blockquote class="text"><dl>
<dt>Suboption Type:</dt>
<dd>8-bit identifier of the type
                  of suboption. When processing a DIO containing a suboption
                  for which the Suboption Type value is not recognized by the
                  receiver, the receiver MUST silently ignore and skip over
                  the suboption, correctly handling any remaining options in
                  the message.
</dd>
<dt>Suboption Length:</dt>
<dd>8-bit unsigned integer,
                  representing the length in octets of the suboption, not
                  including the suboption Type and Length fields.
</dd>
<dt>Suboption Data:</dt>
<dd>A variable length field that
                  contains data specific to the option.
</dd>
</dl></blockquote>

<p>The following subsections specify the DIO suboptions which
              are currently defined for use in the DAG Information Option.
</p>
<p>Implementations MUST silently ignore any DIO suboptions
              options that they do not understand.
</p>
<p>DIO suboptions may have alignment requirements. Following the
              convention in IPv6, these options are aligned in a packet such
              that multi-octet values within the Option Data field of each
              option fall on natural boundaries (i.e., fields of width n
              octets are placed at an integer multiple of n octets from the
              start of the header, for n = 1, 2, 4, or 8).
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1.1.2"></a><h3>5.1.1.1.2.&nbsp;
Pad1</h3>

<p>The Pad1 suboption does not have any alignment requirements.
              Its format is as follows:
</p>
<p><br /><hr class="insert" />
<a name="DIOsubPad1"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |   Type = 0    |
    +-+-+-+-+-+-+-+-+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Pad 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p>NOTE! the format of the Pad1 option is a special case - it
              has neither Option Length nor Option Data fields.
</p>
<p>The Pad1 option is used to insert one octet of padding in the
              DIO to enable suboptions alignment. If more than one octet of
              padding is required, the PadN option, described next, should be
              used rather than multiple Pad1 options.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1.1.3"></a><h3>5.1.1.1.3.&nbsp;
PadN</h3>

<p>The PadN option does not have any alignment requirements. Its
              format is as follows:
</p>
<p><br /><hr class="insert" />
<a name="DIOsubPadN"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
    |   Type = 1    | Subopt Length | Subopt Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Pad N&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p>The PadN option is used to insert two or more octets of
              padding in the DIO to enable suboptions alignment. For N (N &gt;
              1) octets of padding, the Option Length field contains the value
              N-2, and the Option Data consists of N-2 zero-valued octets.
              PadN Option data MUST be ignored by the receiver.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1.1.4"></a><h3>5.1.1.1.4.&nbsp;
DAG Metric Container</h3>

<p>The DAG Metric Container suboption may be aligned as
              necessary to support its contents. Its format is as follows:
</p>
<p><br /><hr class="insert" />
<a name="DIOsubLLNMetric"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
    |   Type = 2    | Container Len | DAG Metric Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: DAG Metric Container&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p>The DAG Metric Container is used to report aggregated path
              metrics along the DAG. The DAG Metric Container may contain a
              number of discrete node, link, and aggregate path metrics as
              chosen by the implementer. The Container Length field contains
              the length in octets of the DAG Metric Data. The order, content,
              and coding of the DAG Metric Container data is as specified in
              <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</p>
<p>The processing and propagation of the DAG Metric Container is
              governed by implementation specific policy functions.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1.1.5"></a><h3>5.1.1.1.5.&nbsp;
Destination Prefix</h3>

<p>The Destination Prefix suboption has an alignment requirement
              of 4n+1. Its format is as follows:
</p>
<p><br /><hr class="insert" />
<a name="DIOsubDestinationPrefix"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 3    |    Length     | Prefix Length |Resvd|Prf|Resvd|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Prefix Lifetime                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Destination Prefix (Variable Length)              |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: DAG Destination Prefix&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p>The Destination Prefix suboption is used when the DAG root
              needs to indicate that it offers connectivity to destination
              prefixes other than the default. This may be useful in cases
              where more than one LBR is operating within the LLN and offering
              connectivity to different administrative domains, e.g. a home
              network and a utility network. In such cases, upon observing the
              Destination Prefixes offered by a particular DAG root, a node
              MAY decide to join multiple DAGs in support of a particular
              application.
</p>
<p>The Length is coded as the length of the suboption in octets,
              excluding the Type and Length fields. The Prefix Length is an
              8-bit unsigned integer that indicates the number of leading bits
              in the destination prefix. Prf is the Route Preference as in
              <a class='info' href='#RFC4191'>[RFC4191]<span> (</span><span class='info'>Draves, R. and D. Thaler, &ldquo;Default Router Preferences and More-Specific Routes,&rdquo; November&nbsp;2005.</span><span>)</span></a>. The Destination Prefix contains
              Prefix Length significant bits of the destination prefix. The
              remaining bits of the Destination Prefix, as required to
              complete the trailing octet, are set to 0.
</p>
<p>The Prefix Lifetime is a 32-bit unsigned integer representing
              the length of time in seconds (relative to the time the packet
              is sent) that the Destination Prefix is valid for route
              determination. A value of all one bits (0xFFFFFFFF) represents
              infinity. A value of all zero bits (0x00000000) indicates a loss
              of reachability.
</p>
<p>In the event that a DAG root may need to specify that it
              offers connectivity to more than one destination, the
              Destination Prefix suboption may be repeated.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Conceptual Data Structures</h3>

<p>The RPL implementation must maintain the following conceptual data
        structures in support of DAG Discovery:
</p>
<p></p>
<ul class="text">
<li>A set of Candidate Neighbors
</li>
<li>For each DAG:
</li>
<ul class="text">
<li>A set of Candidate DAG Parents
</li>
<li>A set of DAG Parents (which are a subset of Candidate DAG
              Parents and may be implemented as such)
</li>
</ul>
</ul>

<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Candidate Neighbors</h3>

<p>The set of Candidate Neighbors is to be populated by neighbors
          who are discovered by the neighbor discovery mechanism and further
          qualified as statistically stable as per the mechanisms discussed in
          <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>. The Candidate
          Neighbors, and related metrics, should demonstrate
          stability/reliability beyond a certain threshold, and it is
          recommended that a local confidence value be maintained with respect
          to the neighbor in order to track this. Implementations may choose
          to bound the maximum size of the Candidate Neighbor set, in which
          case a local confidence value will assist in ordering neighbors to
          determine which ones should remain in the Candidate Neighbor set and
          which should be evicted.
</p>
<p>If Neighbor Unreachability Detection (NUD) determines that a
          Candidate Neighbor is no longer reachable, then it shall be removed
          from the Candidate Neighbor set. In the case that the Candidate
          Neighbor has associated states in the DAG Parent set or active DA
          entries, then the removal of the Candidate Neighbor shall be
          coordinated with tearing down these states. All provisioned routes
          associated with the Candidate Neighbor should be removed.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
DAGs</h3>

<p>A DAG may be uniquely identified by within the LLN by its unique
          DAGID. When a single device is capable to root multiple DAGs in
          support of an application need for multiple optimization objectives
          it is expected to produce a different and unique DAGID for each of
          the multiple DAGs.
</p>
<p>For each DAG that a node is, or may become, a member of, the
          implementation MUST keep a conceptual record of:
</p>
<p></p>
<ul class="text">
<li>DAGID
</li>
<li>DAGObjectiveCodePoint
</li>
<li>A set of Destination Prefixes offered by the DAG root
</li>
<li>A set of candidate DAG Parents
</li>
<li>A timer to govern the sending of DIOs for the DAG
</li>
<li>DAGSequenceNumber
</li>
</ul>

<p>When a DAG is discovered for which no DAG data structure is
          instantiated, and the node wants to join (i.e. the neighbor is to
          become a Candidate DAG Parent in the Held-Up state), then the DAG
          data structure is instantiated.
</p>
<p>When the Candidate DAG Parent set is depleted (i.e. the last
          Candidate DAG Parent has timed out of the Held-Down state), then the
          DAG data structure may be deallocated. An implementation should
          delay before deallocating the DAG data structure in order to observe
          that the DAGSequenceNumber has incremented should any new candidate
          DAG Parents appear for the DAG.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.1"></a><h3>5.2.2.1.&nbsp;
Candidate DAG Parents</h3>

<p>When the DAG is self-rooted, the set of candidate DAG Parents
            is empty.
</p>
<p>In all other cases, for each candidate DAG Parent in the set,
            the implementation MUST keep a record of:
</p>
<p>
              </p>
<ul class="text">
<li>a reference to the neighboring device which is the DAG
                parent
</li>
<li>a record of most recent information taken from the DAG
                Information Object last processed from the candidate DAG
                Parent
</li>
<li>a state associated with the role of the candidate as a
                potential DAG Parent {Current, Held-Up, Held-Down, Collision},
                further described in <a class='info' href='#CandidateParentStates'>Section&nbsp;5.8<span> (</span><span class='info'>Candidate DAG Parent States and Stability</span><span>)</span></a>
</li>
<li>A DAG Hop Timer, if instantiated
</li>
<li>A Held-Down Timer, if instantiated
</li>
</ul><p>
            
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.1.1"></a><h3>5.2.2.1.1.&nbsp;
DAG Parents</h3>

<p>Note that the subset of candidate DAG Parents in the
              `Current' state comprises the set of DAG Parents, i.e. the nodes
              actively acting as parents in the DAG.
</p>
<p>DAG Parents may be ordered, according to the OCP. When
              ordering DAG Parents, in consultation with the OCP, the most
              preferred DAG Parent may be identified. All current DAG Parents
              must have a rank less than or equal to that of the most
              preferred DAG Parent.
</p>
<p>When nodes are added to or removed from the DAG Parent set
              the most preferred DAG Parent may have changed and should be
              reevaluated. Any nodes having a rank greater than the most
              preferred parent after such a change must be placed in the
              Held-Down state and evicted as per the procedures described in
              <a class='info' href='#CandidateParentStates'>Section&nbsp;5.8<span> (</span><span class='info'>Candidate DAG Parent States and Stability</span><span>)</span></a>
</p>
<p>An implementation may choose to keep these records as an
            extension of the Default Router List (DRL).
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Initialization and Configuration</h3>

<p>An implementation must provide a means, e.g. a set of APIs, to
        allow the node to initialize/configure the RPL implementation. The RPL
        implementation on the node must be provisioned to know:
</p>
<p></p>
<blockquote class="text">
<p>Is the node serving a role in an application scenario whereby
            it should permanently act as a DAG root? (For example, the node
            may act as an LBR, provide Internet access, serve as an
            application specific data-collection point, or provide application
            control to the LLN.) If so,
</p>
<blockquote class="text">
<p>What is the DAGPreference value for the self-rooted DAG
              (likely 0)?
</p>
<p>What OCP are supported?
</p>
<p>Is connectivity to external infrastructure provided (is the
              DAG grounded?)
</p>
<p>What destination prefixes are offered?
</p>
<p>What is the DAGDelay?
</p>
<p>Is the Destination Advertisement mechanism in effect?
</p>
<p>What are the values for DIOIntervalDoublings,
              DIOIntervalMin?
</p>
<p>Is the node to periodically emit DIOs (e.g. revise the DAG
              Sequence Number upwards) in order to provide a heartbeat for the
              DAG? If so, with what period?
</p>
</blockquote>
<p>If the node does not permanently act as a DAG root, should it
            actively root a (floating, DAGPreference 0xFF) DAG when no other
            DAG is available? (For example, a battery powered node may not
            wish expend energy to do this, but will instead passively listen
            for other options).
</p>
<p>For each DAG that the node may root, what is the DAGID?
</p>
<p>What are the supported OCP (optimization goals)?
</p>
<p>What, if any, destination prefixes are being sought, associated
            with supported OCP?
</p>
</blockquote>

<p>When a node is provisioned with a set of optimization goals,
        effectively indicating targeted OCPs for given destinations (possibly
        including the default destination), it may conceptually organize these
        into a table where each row indicates an optimization goal. As DAGs
        are joined in order to satisfy optimization objectives, references to
        the DAG supporting the objective may be entered into each row. In this
        way a node may track which objectives are satisfied by which DAGs, as
        well as which objectives are unsatisfied by any DAG. This will help to
        inform a nodes decision to join a new DAG, or perhaps leave an
        existing DAG in order to join a better alternate DAG, in order to meet
        specific optimization objectives.
</p>
<a name="DAGDiscovery"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
DAG Discovery</h3>

<p>DAG Discovery locates the nearest sink and forms a Directed Acyclic
        Graph towards that sink, by identifying a set of DAG parents. During
        this process DAG Discovery also identifies siblings, which may be used
        later to provide additional path diversity towards the DAG root. DAG
        Discovery enables nodes to implement different policies for selecting
        their DAG parents in the DAG by using implementation specific policy
        functions. DAG Discovery specifies a set of rules to be followed by
        all implementations in order to ensure interoperation. DAG Discovery
        also standardizes the format that is used to advertise the most common
        information that is used in order to select DAG parents.
</p>
<p>One of these information, the DAG rank, is used by DAG Discovery to
        provide loop avoidance even if nodes implement different policies. The
        DAG Rank is computed as specified by the Objective Code Point in use
        by the DAG, demonstrating the properties described in <a class='info' href='#DAGRank'>Section&nbsp;3.4.1<span> (</span><span class='info'>DAG Rank and Loop Avoidance</span><span>)</span></a>. The rank should be computed in such a way so
        as to provide a comparable basis with other nodes which may not use
        the same metric at all.
</p>
<p>In order to organize and maintain loopless structure, the DAG
        Discovery implementation in the nodes MUST obey to the following rules
        and definitions:
</p>
<p></p>
<ol class="text">
<li>A node that does not have any DAG parents in a DAG is the root
            of its own floating DAG. It's rank is 1. A node will end up in
            that situation when it looses all of its current feasible parents,
            i.e. the set of DAG parents becomes depleted. In that case, the
            node SHOULD remember the DAGID and the sequence counter in the DIO
            of the lost parents for a period of time which covers multiple
            DIO.
</li>
<li>A LLN Node that is attached to an infrastructure that does not
            support DIO, is the DAG root of its own grounded DAG. It's rank is
            1.
</li>
<li>A router sending a RA without DIO is considered a grounded
            infrastructure at rank 0. (For example, a router that is in
            communication with an LLN node but not running RPL such as a
            backbone router in communication with an LBR)
</li>
<li>The DAG root exposes the DAG in the RA-DIO and nodes propagate
            the DIO outwards along the DAG with the RAs that they forward over
            their LLN links.
</li>
<li>A node MAY move at any time, with no delay, within its DAG as
            long as such a move does not increase its own DAG rank, as per the
            rank calculation indicated by the OCP. If a node is required to
            move such that it cannot stay within the DAG without a rank
            increase, then it needs to first leave the DAG. In other words a
            node that is already part of a DAG MAY move or follow a DAG parent
            at any time and with no delay in order to be closer, or stay as
            close, to the DAG root of its current DAG as it already is. But a
            node MUST NOT move outwards along the DAG that it is attached,
            except in the special case when choosing to follow the last DAG
            parent in the set of DAG parents. RAs received from other routers
            located higher in the same DAG may be considered as coming from
            candidate parents. RAs received from other routers located at the
            same rank in the same DAG may be considered as coming from
            siblings. Nodes MUST ignore RAs that are received from other
            routers located deeper within the same DAG.
</li>
<li>A node may jump from its current DAG into any different DAG if
            it is preferred for reasons of connectivity, configured
            preference, free medium time, size, security, bandwidth, DAG rank,
            or whatever metrics the LLN cares to use. A node may jump at any
            time and to whatever rank it reaches in the new DAG, but it may
            have to wait for a DAG Hop timer to elapse in order to do so. This
            allows the new higher parts (closer to the sink) of the DAG to
            move first, thus allowing stepped DAG reconfigurations and
            limiting relative movements. A node SHOULD NOT join a previous DAG
            (identified by its DAGID) unless the sequence number in the DIO
            has incremented since the node left that DAG. A newer sequence
            number indicates that the candidate parents were not attached
            behind this node, as they kept getting subsequent DIOs with new
            sequence numbers from the same DAG. In the event that old sequence
            numbers (two or more behind the present value) are encountered
            they are considered stale and the corresponding parent SHOULD be
            removed from the set.
</li>
<li>If a node has selected a new set of DAG parents but has not
            moved yet (because it is waiting for DAG Hop timer to elapse), the
            node is unstable and refrains from sending RA-DIOs for that
            DAG.
</li>
<li>If a node receives a RA-DIO from one of its DAG parents, and if
            the parent contains a different DAGID, indicating that the parent
            has left the DAG, and if the node can remain in the current DAG
            through an alternate DAG parent, then the node should remove the
            DAG parent which has joined the new DAG from its DAG parent set
            and remain in the original DAG. If the node was the last DAG
            parent then the node SHOULD follow that parent.
</li>
<li>When a node detects or causes a DAG inconsistency, as described
            in <a class='info' href='#TrickleInconsistencies'>Section&nbsp;5.4.3.2<span> (</span><span class='info'>Determination of Inconsistency</span><span>)</span></a>, then the node
            sends an unsolicited RA-DIO message to its one-hop neighbors. The
            RA contains an updated DIO to propagate the new DAG information.
            Such an event will also cause the trickle timer governing the
            periodic RAs to be reset.
</li>
<li>If a DAG parent increases its rank such that the node rank
            would have to change, and if the node does not wish to follow
            (e.g. it has alternate options), then the DAG parent should be
            evicted from the DAG parent set. If the DAG parent is the last in
            the DAG parent set, then the node may chose to follow it.
</li>
</ol>

<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
RA-DIO Reception</h3>

<p>When an DIO is received from a source device SRC, the receiving
          node must first determine whether or not the DIO should be accepted
          for further processing, and subsequently present the DIO for further
          processing if eligible.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1.1"></a><h3>5.4.1.1.&nbsp;
Determination of Eligibility for DIO Processing</h3>

<p>
              </p>
<blockquote class="text">
<p>If the DIO is malformed, then the DIO is not eligible for
                further processing.
</p>
<p>If SRC is not a member of the candidate neighbor set, then
                the RA-DIO is not eligible for further processing. (Further
                evaluation/confidence of this neighbor is necessary)
</p>
<p>If the DIO advertises a DAG that the node is already a
                member of, then:
</p>
<blockquote class="text">
<p>If the rank of SRC as reported in the DIO is less then
                  that of the node within the DAG, then the DIO MUST be
                  considered for further processing
</p>
<p>If the rank of SRC as reported in the DIO is equal to
                  that of the node within the DAG, then SRC is marked as a
                  sibling and the DIO is not eligible for further
                  processing.
</p>
<p>If the rank of SRC as reported in the DIO is lesser than
                  that of the node within the DAG, and SRC is not a DAG
                  Parent, then the DIO is not eligible for further
                  processing
</p>
</blockquote>
<p>If SRC is a DAG Parent for any other DAG that the node is
                attached to, then the DIO MUST be considered for further
                processing (the DAG Parent may have jumped).
</p>
<p>If the DIO advertises a DAG that offers a better (new or
                alternate) solution to an optimization objective desired by
                the node, then the DIO MUST be considered for further
                processing.
</p>
</blockquote><p>
            
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1.2"></a><h3>5.4.1.2.&nbsp;
Overview of DIO Processing</h3>

<p>
              </p>
<blockquote class="text">
<p>
</p>
<p>If the DIO is for a new/alternate DAG:
</p>
<blockquote class="text">
<p>Instantiate a data structure for the new/alternate DAG if
                  necessary
</p>
<p>Place the neighbor in the Candidate DAG Parent set
</p>
<p>Has the node sent an RA within the risk window as
                  described in <a class='info' href='#DAGCollision'>Section&nbsp;5.8.3<span> (</span><span class='info'>Collision</span><span>)</span></a>? If so, perform
                  the collision detection described in <a class='info' href='#DAGCollision'>Section&nbsp;5.8.3<span> (</span><span class='info'>Collision</span><span>)</span></a>. If a collision occurs, place the
                  Candidate DAG Parent in the collision state and do not
                  process the DIO any further as described in <a class='info' href='#CandidateParentStates'>Section&nbsp;5.8<span> (</span><span class='info'>Candidate DAG Parent States and Stability</span><span>)</span></a>.
</p>
<p>If the SRC node is also a DAG Parent for another DAG that
                  the node is a member of, and if the new/alternate DAG
                  satisfies an equivalent optimization objective as the other
                  DAG, then the DAG Parent is known to have jumped.
</p>
<blockquote class="text">
<p>Remove SRC as a DAG Parent from the other DAG (place it
                    in the held-down state)
</p>
<p>If the other DAG is now empty of candidate Parents,
                    then directly follow SRC into the new DAG by adding it as
                    a DAG Parent in the Current state
</p>
<p>Else ignore the DIO (do not follow the parent).
</p>
</blockquote>
<p>If the new/alternate DAG offers a better solution to the
                  optimization objectives, then prepare to jump: copy the DIO
                  information into the record for the Candidate DAG Parent,
                  place the Candidate DAG Parent into the Held-Up state, and
                  start the DAG Hop timer as per <a class='info' href='#DAGHeldUp'>Section&nbsp;5.8.1<span> (</span><span class='info'>Held-Up</span><span>)</span></a>.
</p>
</blockquote>
<p>If the DIO is for a known/existing DAG:
</p>
<blockquote class="text">
<p>Process the DIO as per the rules in <a class='info' href='#DAGDiscovery'>Section&nbsp;5.4<span> (</span><span class='info'>DAG Discovery</span><span>)</span></a>
</p>
</blockquote>
</blockquote><p>
            
</p>
<p>As candidate parents are identified, they may subsequently be
          promoted to DAG parents by following the rules of DAG Discovery as
          described in <a class='info' href='#DAGDiscovery'>Section&nbsp;5.4<span> (</span><span class='info'>DAG Discovery</span><span>)</span></a>. When a node adds
          another node to its set of candidate parents, the node becomes
          attached to the DAG through the parent node.
</p>
<p>In the DAG Discovery implementation, the most preferred parent
          should be used to restrict which other nodes may become DAG parents.
          All nodes in the DAG Parent set should be of a rank less than or
          equal to the most preferred DAG parent. (This case may occur, for
          example, if an energy constrained device is at a lesser rank but
          should be avoided as per an optimization objective, resulting in a
          more preferred parent at a greater rank).
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
RA-DIO Transmission</h3>

<p>Each node maintains a timer that governs when to multicast RAs.
          This timer is implemented as a trickle timer operating over a
          variable interval. Trickle timers are further detailed in <a class='info' href='#TrickleImplementation'>Section&nbsp;5.4.3<span> (</span><span class='info'>Trickle Timer for RA Transmission</span><span>)</span></a>. The governing parameters for
          the timer should be configured consistently across the DAG, and are
          provided by the DAG root in the DIO. In addition to periodic RAs,
          each LLN node will respond to Router Solicitation messages according
          to <a class='info' href='#RFC4861'>[RFC4861]<span> (</span><span class='info'>Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;Neighbor Discovery for IP version 6 (IPv6),&rdquo; September&nbsp;2007.</span><span>)</span></a>.
</p>
<p></p>
<ul class="text">
<li>When a node is unstable, because any DAG Hop timer is running
              in preparation for a jump, then the node must not transmit
              unsolicited RA-DIOs (i.e. the node will remain silent when the
              timer expires).
</li>
<li>When a node detects an inconsistency, it may reset the
              interval of the trickle timer to a minimum value, causing RAs to
              be emitted more frequently as part of a strategy to quickly
              correct the inconsistency. Such inconsistencies may be, for
              example, an update to a key parameter (e.g. sequence number) in
              the DIO or a point-to-point loop detected when a node located
              inwards along the DAG forwards traffic intended for the default
              destination. Inconsistencies are further detailed in <a class='info' href='#TrickleInconsistencies'>Section&nbsp;5.4.3.2<span> (</span><span class='info'>Determination of Inconsistency</span><span>)</span></a>.
</li>
<li>When a node enters a mode of consistent operation within a
              DAG, i.e. DIOs from its DAG Parents are consistent and no other
              inconsistencies are detected, it may begin to open up the
              interval of the trickle timer towards a maximum value, causing
              RAs to be emitted less frequently, thus reducing network
              maintenance overhead and saving energy consumption (which is of
              utmost importance for battery-operated nodes).
</li>
<li>When a node is initialized, it may be configured to remain
              silent and not multicast any RAs until it has encountered and
              joined a DAG (perhaps initially probing for a nearby DAG with an
              RS). Alternately, it may choose to root its own floating DAG and
              begin multicasting RAs using a default trickle configuration.
              The second case may be advantageous if it is desired for
              independent nodes to begin aggregating into scattered floating
              DAGs in the absence of a grounded node, for example in support
              of LLN installation and commissioning.
</li>
</ul>

<p>Note that if multiple DAG roots are participating in the same
          DAG, i.e. offering DIOs with the same DAGID, then they must
          coordinate with each other to ensure that their DIOs are consistent
          when they emit RA-DIOs. In particular the Sequence number must be
          identical from each DAG root, regardless of which of the multiple
          DAG roots issues the DIO, and changes to the Sequence number should
          be issued at the same time. The specific mechanism of this
          coordination, e.g. along a backbone between DAG roots, is beyond the
          scope of this specification.
</p>
<a name="TrickleImplementation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
Trickle Timer for RA Transmission</h3>

<p>RPL treats the construction of a DAG as a consistency problem,
          and uses a trickle timer <a class='info' href='#Levis08'>[Levis08]<span> (</span><span class='info'>Levis, P., Brewer, E., Culler, D., Gay, D., Madden, S., Patel, N., Polastre, J., Shenker, S., Szewczyk, R., and A. Woo, &ldquo;The Emergence of a Networking Primitive in           Wireless Sensor Networks,&rdquo; July&nbsp;2008.</span><span>)</span></a> to control
          the rate of control broadcasts. The operation of this timer is in
          support of the procedures further discussed in <a class='info' href='#DAGDiscovery'>Section&nbsp;5.4<span> (</span><span class='info'>DAG Discovery</span><span>)</span></a>
</p>
<p>For each DAG that a node is part of, the node must maintain a
          single trickle timer. The required state contains the following
          conceptual items:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>I:</dt>
<dd>The current length of the communication
              interval
</dd>
<dt>T:</dt>
<dd>A timer with a duration set to a random value
              in the range [I/2, I]
</dd>
<dt>C:</dt>
<dd>Redundancy Counter
</dd>
<dt>I_min:</dt>
<dd>The smallest communication interval in
              milliseconds. This value is learned from the DIO as
              (2^DIOIntervalMin)ms. The default value is
              DEFAULT_DIO_INTERVAL_MIN.
</dd>
<dt>I_doublings:</dt>
<dd>The number of times I_min should be
              doubled before maintaining a constant rate, i.e. I_max = I_min *
              2^I_doublings. This value is learned from the DIO as
              DIOIntervalDoublings. The default value is
              DEFAULT_DIO_INTERVAL_DOUBLINGS.
</dd>
</dl></blockquote>

<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3.1"></a><h3>5.4.3.1.&nbsp;
Resetting the Trickle Timer</h3>

<p>The trickle timer for a DAGID is reset by:
</p>
<p></p>
<ol class="text">
<li>Setting I_min and I_doublings to the values learned from
                the RA-DIO.
</li>
<li>Setting C to zero.
</li>
<li>Setting I to I_min.
</li>
<li>Setting T to a random value as described above.
</li>
<li>Restarting the trickle timer to expire after a duration
                T
</li>
</ol>

<p>When an LLN learns about a DAG through a RA and makes the
            decision to join it, it initializes the state of the trickle timer
            by resetting the trickle timer and listening. Each time it hears a
            consistent RA for this DAG from a DAG Parent, it increments C.
</p>
<p>When the timer fires at time T, the node compares C to the
            redundancy constant, DEFAULT_DIO_REDUNDANCY_CONSTANT. If C is less
            than that value, the node generates a new RA and broadcasts it.
            When the communication interval I expires, the node doubles the
            interval I so long as it has previously doubled it fewer then
            I_doubling times, resets C, and chooses a new T value.
</p>
<a name="TrickleInconsistencies"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3.2"></a><h3>5.4.3.2.&nbsp;
Determination of Inconsistency</h3>

<p>The trickle timer is reset whenever an inconsistency is
            detected within the DAG, for example:
</p>
<p></p>
<ul class="text">
<li>The node joins a new DAGID
</li>
<li>The node moves within a DAGID
</li>
<li>The node receives a modified DIO from a DAG parent
</li>
<li>A DAG parent forwards a packet intended for the default
                route, indicating an inconsistency and possible loop.
</li>
<li>A metric communicated in the DIO is determined to be
                inconsistent, as according to a implementation specific path
                metric selection engine.
</li>
<li>The rank of a DAG parent has changed.
</li>
</ul>

<p>The implementation SHOULD provide an API whereby any procedure
            that detects an inconsistency may cause the trickle timer to
            reset.
</p>
<a name="DAGHeartbeat"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
DAG Heartbeat</h3>

<p>The DAG Root makes the sole determination of when to revise the
        DAGSequenceNumber by incrementing it upwards. When the
        DAGSequenceNumber is increased an inconsistency results, causing
        RA-DIOs to be sent back outwards along the DAG to convey the change.
        The degree to which this mechanism is relied on may be determined by
        the implementation- on one hand it may serve as a periodic heartbeat,
        refreshing the DAG states, and on the other hand it may result in a
        constant steady-state control cost overhead which is not
        desirable.
</p>
<p>Some implementations may provide an administrative API at the DAG
        Root whereby the DAGSequenceNumber may be caused to increment in
        response to some policy outside of the scope of RPL.
</p>
<p>Other implementations may make use of a periodic timer to
        automatically increment the DAGSequenceNumber, resulting in a periodic
        DAG Heartbeat at a rate appropriate to the application and
        implementation.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
DAG Selection</h3>

<p>The DAG selection is implementation and algorithm dependent. Nodes
        SHOULD prefer to join DAGs advertising OCPs and destinations
        compatible with their implementation specific objectives. In order to
        limit erratic movements, and all metrics being equal, nodes SHOULD
        keep their previous selection. Also, nodes SHOULD provide a means to
        filter out a candidate parent whose availability is detected as
        fluctuating, at least when more stable choices are available. Nodes
        MAY place the failed candidate parent in a Hold Down mode that ensures
        that the candidate parent will not be reused for a given period of
        time.
</p>
<p>When connection to a fixed network is not possible or preferable
        for security or other reasons, scattered DAGs MAY aggregate as much as
        possible into larger DAGs in order to allow connectivity within the
        LLN. How to balance these DAGs is implementation dependent, and MAY
        use a specific visitor-counter suboption in the DIO.
</p>
<p>A node SHOULD verify that bidirectional connectivity and adequate
        link quality is available with a candidate neighbor before it
        considers that candidate as a DAG parent.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.7"></a><h3>5.7.&nbsp;
Administrative rank</h3>

<p>When the DAG is formed under a common administration, or when a
        node performs a certain role within a community, it might be
        beneficial to associate a range of acceptable rank with that node. For
        instance, a node that has limited battery should be a leaf unless
        there is no other choice, and may then augment the rank computation
        specified by the OCP in order to expose an exaggerated rank.
</p>
<a name="CandidateParentStates"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.8"></a><h3>5.8.&nbsp;
Candidate DAG Parent States and Stability</h3>

<p>Candidate DAG Parents may or may not be eligible to act as DAG
        Parents depending on runtime conditions. The following states are
        defined:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Current</dt>
<dd>This candidate parent is in the set of DAG
            parents and may be used for forwarding traffic inward along the
            DAG. When a candidate parent is placed into the Current state, or
            taken out of the Current state, it is necessary to re-evaluate
            which of the remaining DAG Parents is the most preferred DAG
            Parent and its rank. At that time any remaining DAG Parents of
            greater rank than the most preferred DAG parent must be placed in
            the Held-Down state, and the hold-down timer started, in order to
            be evicted as DAG Parents.
</dd>
<dt>Held-Up</dt>
<dd>This parent can not be used until the DAG
            hop timer elapses.
</dd>
<dt>Held-Down</dt>
<dd>This candidate parent can not be used till
            hold down timer elapses. At the end of the hold-down period, the
            candidate is removed from the Candidate DAG Parent set, and may be
            reinserted if it appears again with a RA.
</dd>
<dt>Collision</dt>
<dd>This candidate parent can not be used till
            its next RA.
</dd>
</dl></blockquote>

<a name="DAGHeldUp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.8.1"></a><h3>5.8.1.&nbsp;
Held-Up</h3>

<p>This state is managed by the DAG Hop timer, it serves 2
          purposes:
</p>
<p></p>
<blockquote class="text">
<p>Delay the reattachment of a sub-DAG that has been forced to
              detach. This is not as safe as the use of the sequence, but
              still covers that when a sub-DAG has detached, the Router
              Advertisement - DAG Information Option that is initiated by the
              new DAG root has a chance to spread outward along the sub-DAG so
              that two different DAGs have formed.
</p>
<p>Limit RA-DIO storms when two DAGs collide/merge. The idea is
              that between the nodes from DAG A that decide to move to DAG B,
              those that see the highest place (closer to the DAG root) in DAG
              B will move first and advertise their new locations before other
              nodes from DAG A actually move.
</p>
</blockquote>

<p>A new DAG is discovered upon a router advertisement message with
          or without a RA-DIO. The node joins the DAG by selecting the source
          of the RA message as a DAG parent (and possible default gateway) and
          propagating the DIO accordingly.
</p>
<p>When a new DAG is discovered, the candidate parent that
          advertises the new DAG is placed in a held up state for the duration
          of a DAG Hop timer. If the resulting new set of DAG parents is more
          preferable than the current one, or if the node is intending to
          maintain a membership in the new DAG in addition to its current DAG,
          the node expects to jump and becomes unstable.
</p>
<p>A node that is unstable may discover other candidate parents from
          the same new DAG during the instability phase. It needs to start a
          new DAG Hop timer for all these. The first timer that elapses for a
          given new DAG clears them all for that DAG, allowing the node to
          jump to the highest position available in the new DAG.
</p>
<p>The duration of the DAG Hop timer depends on the DAG Delay of the
          new DAG and on the rank of candidate parent that triggers it:
          (candidates rank + random) * candidate's DAG_delay (where 0 &lt;=
          random &lt; 1). It is randomized in order to limit collisions and
          synchronizations.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.8.2"></a><h3>5.8.2.&nbsp;
Held-Down</h3>

<p>When a neighboring node is 'removed' from the Default Router
          List, it is actually held down for a hold down timer period, in
          order to prevent flapping. This happens when a node disappears (upon
          expiration timer).
</p>
<p>When the hold down timer elapses, the node is removed from the
          Candidate DAG Parent set.
</p>
<a name="DAGCollision"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.8.3"></a><h3>5.8.3.&nbsp;
Collision</h3>

<p>A race condition occurs if 2 nodes send RA-DIO at the same time
          and then attempt to join each other. This might happen, for example,
          between nodes which act as DAG root of their own DAGs. In order to
          detect the situation, LLN Nodes time stamp the sending of RA-DIO.
          Any RA-DIO received within a short link-layer-dependent period
          introduces a risk. To resolve the collision, a 32bits extended
          preference is constructed from the DIO by concatenating the
          NodePreference with the BootTimeRandom.
</p>
<p>A node that decides to add a candidate to its DAG parents will do
          so between (candidate rank) and (candidate rank + 1) times the
          candidate DAG Delay. But since a node is unstable as soon as it
          receives the RA-DIO from the desired candidate, it will restrain
          from sending a RA-DIO between the time it receives the RA and the
          time it actually jumps. So the crossing of RA may only happen during
          the propagation time between the candidate and the node, plus some
          internal queuing and processing time within each machine. It is
          expected that one DAG delay normally covers that interval, but
          ultimately it is up to the implementation and the configuration of
          the candidate parent to define the duration of risk window.
</p>
<p>There is risk of a collision when a node receives an RA, for
          another candidate that is more preferable than the current
          candidate, within the risk window. In the face of a potential
          collision, the node with lowest extended preference processes the
          RA-DIO normally, while the router with the highest extended
          preference places the other in collision state, does not start the
          DAG hop timer, and does not become instable. It is expected that
          next RAs between the two will not cross anyway.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.8.4"></a><h3>5.8.4.&nbsp;
Instability</h3>

<p>A node is instable when it is prepared to shortly replace a set
          of DAG parents in order to jump to a different DAGID. This happens
          typically when the node has selected a more preferred candidate
          parent in a different DAG and has to wait for the DAG hop timer to
          elapse before adjusting the DAG parent set. Instability may also
          occur when the entire current DAG parent set is lost and the next
          best candidates are still held up. Instability is resolved when the
          DAG hop timer of all the candidate(s) causing instability elapse.
          Such candidates then change state to Current or Held- Down.
</p>
<p>Instability is transient (in the order of DAG hop timers). When a
          node is unstable, it MUST NOT send RAs with DIO. This avoids loops
          when node A decides to attach to node B and node B decides to attach
          to node A. Unless RAs cross (see Collision section), a node receives
          DIO from stable candidate parents, which do not plan to attach to
          the node, so the node can safely attach to them.
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.9"></a><h3>5.9.&nbsp;
Guidelines for Objective Code Points</h3>

<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.9.1"></a><h3>5.9.1.&nbsp;
Objective Function</h3>

<p>An objective function (OF) selects a DAG to join, and a number of
          peers in that DAG as parents. The OF computes an ordered list of
          parents and provides load balancing guidance. The OF is also
          responsible to compute the rank of the device within the DAG.
</p>
<p>An Objective Function is indicated in the DIO using an objective
          code point (OCP). The objective code point are administered by IANA
          that might delegate some ranges to other organizations. This
          specification reserves OCP 0, in support of default operation.
</p>
<p>Most Objective Functions are expected to follow the same abstract
          behavior:
</p>
<ul class="text">
<li>The parent selection is triggered each time an event indicates
            that a potential next_hop information is updated. This might
            happen upon a RA-DIO, a timer elapse, or a trigger indicating that
            the state of a Candidate Neighbor has changed.
</li>
<li>An OF scans all the interfaces on the device. Although there
            may typically be only one interface in most application scenarios,
            there might be multiple of them and an interface might be
            configured to be usable or not for RPL operation. An interface can
            also be configured with a preference or dynamically learned to be
            better than another by some heuristics that might be link-layer
            dependent and are out of scope. An interface might not be ready
            for IPv6 operation with a usable link-local address. Finally an
            interface might or not match a required criterion for an Objective
            Function, for instance a degree of security. As a result some
            interfaces might be completely excluded from the computation,
            while others might be more or less preferred.
</li>
<li>The OF scans all the Candidate Neighbors on the possible
            interfaces to check whether they can act as an attachment router
            for a DAG. There might be multiple of them and a Candidate
            Neighbor might need to pass some validation tests before it can be
            used. In particular, some link layers require experience on the
            activity with a router to enable and raise the router value as a
            next_hop.
</li>
<li>The OF computes self's rank by adding the step of rank to that
            candidate to the rank of that candidate. The step of rank is
            estimated as follows:
</li>
<ul class="text">
<li>When a router has reached a value that's qualified as normal,
              the step of rank for that hop is 4.
</li>
<li>The step of rank might vary from 1 to 16.
</li>
<ul class="text">
<li>1 indicates a unusually good link, for instance a link
                between powered devices in a mostly battery operated
                environment.
</li>
<li>16 indicates a link that can hardly be used to forward any
                packet, for instance a radio link with quality indicator or
                expected transmission count that flirts with the acceptable
                threshold.
</li>
</ul>
<li>Candidate Neighbors that would cause self's rank to increase
              are ignored
</li>
</ul>
<li>As it scans all the Candidate Neighbors, the OF keeps the
            current best parent and compares its capabilities with the current
            Candidate Neighbor. The OF defines a number of tests that are
            critical to reach the Objective. A test between the routers
            determines an order relation.
</li>
<ul class="text">
<li>If the routers are roughly equal for that relation then the
              next test is attempted between the routers,
</li>
<li>Else the best of the 2 becomes the current best parent and
              the scan continues with the next Candidate Neighbor
</li>
<li>One of these tests might include comparing the resulting
              ranks but it isn't necessarily so
</li>
</ul>
<li>When the scan is complete, the preferred parent is elected and
            self's rank is computed as the preferred parent rank plus the step
            in rank with that parent.
</li>
<li>Other rounds of scans might be necessary to elect alternate
            parents and siblings. Self's rank is now determined by the new
            preferred parent if it has changed. In the next rounds:
</li>
<ul class="text">
<li>Candidate Neighbors that are not in the same DAG are
              ignored
</li>
<li>Candidate Neighbors that would cause self's rank to increase
              are ignored
</li>
<li>Candidate Neighbors of a better rank than self (non-siblings)
              are preferred
</li>
</ul>
</ul>
<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.9.2"></a><h3>5.9.2.&nbsp;
Objective Code Point 0 (OCP 0)</h3>

<p>Here follows the specification for the Objective Function for OCP
          0. This is a very simple references to help design more complex
          Objective Functions. In particular, the Objective Function described
          here does not use physical metrics as described in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>, but are only based
          on abstract information from the DIO such as rank and administrative
          preference.
</p>
<p>OCP 0 is as a default fall back behavior when a node joins a DAG
          but does not support the OF that's preferred for this DAG.
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.9.2.1"></a><h3>5.9.2.1.&nbsp;
OCP 0 Objective Function (OF0)</h3>

<p>OF0 favors the connectivity. That is, the Objective Function is
            designed to find the nearest sink into a 'grounded' topology, and
            if there's none then join any network per order of administrative
            preference.
</p>
<p>OF0 selects a preferred parent and a backup next_hop if that's
            available. The backup next_hop might be a parent or a sibling. All
            the traffic is routed via the preferred parent. When the link
            conditions do not let a packet through to the preferred parent,
            the packet is passed to the backup next_hop.
</p>
<p>The step of rank is 4 for each hop.
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.9.2.2"></a><h3>5.9.2.2.&nbsp;
Selection of the Preferred Parent</h3>

<p>As it scans all the Candidate Neighbors, OF0 keeps the parent
            that is the best for the following criteria (in order):
</p>
<p></p>
<ol class="text">
<li>The interface must be usable and the administrative
                preference (if any) applies first.
</li>
<li>A candidate that would cause the node to augment the rank
                in the current DAG is not considered.
</li>
<li>A router that is validated as usable is better.
</li>
<li>If none are grounded then a DAG with a better DAG
                preference wins.
</li>
<li>A router that offers connectivity to a grounded DAG is
                better.
</li>
<li>A lesser resulting rank is better.
</li>
<li>A DAG for which there is an alternate parent is better.
                This check is optional. It is performed by computing the
                backup next_hop while assuming that this router won.
</li>
<li>The DAG that was in use already is preferred.
</li>
<li>The router with a better router preference wins.
</li>
<li>The preferred parent that was in use already is better.
</li>
<li>A router that is fresher (most recent RA) is better.
</li>
</ol>

<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.9.2.3"></a><h3>5.9.2.3.&nbsp;
Selection of the Backup next_hop</h3>

<ul class="text">
<li>The interface must be usable and the administrative
              preference (if any) applies first.
</li>
<li>A candidate that would cause the node to augment the rank in
              the current DAG is not considered.
</li>
<li>The preferred parent is ignored
</li>
<li>Candidate Neighbors that are not in the same DAG are
              ignored
</li>
<li>Candidate Neighbors that would cause self's rank (from that
              determined by the preferred parent) to increase are ignored
</li>
<li>Candidate Neighbors of a better rank than self (non-siblings)
              are preferred
</li>
<li>A router that is validated as usable is better
</li>
<li>The router with a better router preference wins
</li>
<li>The backup next_hop that was in use already is better.
</li>
</ul>
<a name="DestinationAdvertisement"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10"></a><h3>5.10.&nbsp;
Establishing Routing State Outward Along the DAG</h3>

<p>The Destination Advertisement mechanism supports the dissemination
        of routing state required to support traffic flows outward along the
        DAG, from the DAG root toward nodes.
</p>
<p>Note that some aspects of the Destination Advertisement mechanism
        are still under investigation.
</p>
<p>As a result of Destination Advertisement operation:
</p>
<p></p>
<ul class="text">
<li>DAG Discovery establishes a DAG oriented toward a DAG root
            using extended Neighbor Discovery RS/RA flows, along which inward
            routes toward the DAG root are set up.
</li>
<li>Destination Advertisement extends Neighbor Discovery in order
            to establish outward routes along the DAG, along paths containing
            DA parents. Such paths consist of:
</li>
<ul class="text">
<li>Hop-By-Hop routing state within islands of `stateful'
              nodes.
</li>
<li>Source Routing `bridges' across nodes who do not retain
              state.
</li>
</ul>
</ul>

<p>Destinations disseminated with the Destination Advertisement
        mechanism may be prefixes, individual hosts, or multicast listeners.
        The mechanism supports nodes of varying capabilities as follows:
</p>
<p></p>
<ul class="text">
<li>When nodes are capable of storing routing state, they may
            inspect Destination Advertisements and learn hop-by-hop routing
            state toward destinations. In this process they may also learn
            necessary piecewise source routes to traverse regions of the LLN
            that do not maintain routing state. They may perform route
            aggregation on known destinations before emitting Destination
            Advertisements.
</li>
<li>When nodes are incapable of storing routing state, they may
            forward Destination Advertisements, recording the reverse route as
            the go in order to support the construction of piecewise source
            routes.
</li>
</ul>

<p>Nodes that are capable of storing routing state, and finally the
        DAG roots, are able to learn which destinations are contained in the
        sub-DAG below the node, and via which next-hop neighbors. The
        dissemination and installation of this routing state into nodes allows
        for Hop-By-Hop routing from the DAG root outwards along the DAG. The
        mechanism is further enhance by supporting the construction of source
        routes across stateless `gaps' in the DAG, where nodes are incapable
        of storing additional routing state. An adaptation of this mechanism
        allows for the implementation of loose-source or landmark (waypoint)
        routing.
</p>
<p>A special case, the reception of a Destination Advertisement
        addressed to a link-local multicast address, allows for a node to
        learn destination prefixes directly available from its one-hop
        neighbors.
</p>
<p>The design choice behind this is not to synchronize the parent and
        children databases along the DAG, but instead to update them regularly
        to cover from the loss of packets. The rationale for that choice is
        time variations in connectivity across unreliable links. If the
        topology can be expected to change frequently, synchronization might
        be an excessive goal in terms of exchanges and protocol complexity.
        The approach used here results in a simple protocol with no real
        peering. The Destination Advertisement mechanism hence provides for
        periodic updates of the derivative routing state, as cued by
        occasional RAs and other mechanisms, similarly to other protocols such
        as RIP <a class='info' href='#RFC2453'>[RFC2453]<span> (</span><span class='info'>Malkin, G., &ldquo;RIP Version 2,&rdquo; November&nbsp;1998.</span><span>)</span></a>.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.1"></a><h3>5.10.1.&nbsp;
Destination Advertisement Message Formats</h3>

<a name="DAOptionMessage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.1.1"></a><h3>5.10.1.1.&nbsp;
DAO Option</h3>

<p>RPL extends Neighbor Discovery <a class='info' href='#RFC4861'>[RFC4861]<span> (</span><span class='info'>Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;Neighbor Discovery for IP version 6 (IPv6),&rdquo; September&nbsp;2007.</span><span>)</span></a>
            and RFC4191 <a class='info' href='#RFC4191'>[RFC4191]<span> (</span><span class='info'>Draves, R. and D. Thaler, &ldquo;Default Router Preferences and More-Specific Routes,&rdquo; November&nbsp;2005.</span><span>)</span></a> to allow a node to
            include a Destination Advertisement option, which includes prefix
            information, in the Neighbor Advertisements (NAs). A prefix option
            is normally present in Router Advertisements (RAs) only, but the
            NA is augmented with this option in order to propagate destination
            information inwards along the DAG. The option is named the
            Destination Advertisement Option (DAO), and an NA containing this
            option may be referred to as a Destination Advertisement. The RPL
            use of Destination Advertisements allows the nodes in the DAG to
            build up routing state for nodes contained in the sub-DAG in
            support of traffic flowing outward along the DAG.
</p>
<p><br /><hr class="insert" />
<a name="DAOption"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |    Length     | Prefix Length |    RRCount    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          DAO Lifetime                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Route Tag                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   DAO Depth   |   Reserved    |         DAO Sequence          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   Prefix (Variable Length)                    |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Reverse Route Stack (Variable Length)             |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Destination Advertisement Option (DAO)&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

</p>
<p></p>
<blockquote class="text"><dl>
<dt>Type:</dt>
<dd>8-bit unsigned identifying the Destination
                Advertisement option. The value is to be assigned by the
                IANA.
</dd>
<dt>Length:</dt>
<dd>8-bit unsigned integer. The length of
                the option (including the Type and Length fields) in units of
                8 octets.
</dd>
<dt>Prefix Length:</dt>
<dd>Number of valid leading bits in
                the IPv6 Prefix.
</dd>
<dt>RRCount:</dt>
<dd>8-bit unsigned integer. This counter is
                used to count the number of entries in the Reverse Route
                Stack. A value of `0' indicates that no Reverse Route Stack is
                present.
</dd>
<dt>DAO Lifetime:</dt>
<dd>32-bit unsigned integer. The
                length of time in seconds (relative to the time the packet is
                sent) that the prefix is valid for route determination. A
                value of all one bits (0xFFFFFFFF) represents infinity. A
                value of all zero bits (0x00000000) indicates a loss of
                reachability.
</dd>
<dt>Route Tag:</dt>
<dd>32-bit unsigned integer. The Route
                Tag may be used to give a priority to prefixes that should be
                stored. This may be useful in cases where intermediate nodes
                are capable of storing a limited amount of routing state. The
                further specification of this field and its use is under
                investigation.
</dd>
<dt>DAO Depth:</dt>
<dd>Set to 0 by the node that owns the
                prefix and first issues the DAO. Incremented by all LLN nodes
                that propagate the DAO.
</dd>
<dt>Reserved:</dt>
<dd>8-bit unused field. It MUST be
                initialized to zero by the sender and MUST be ignored by the
                receiver.
</dd>
<dt>DAO Sequence:</dt>
<dd>Incremented by the node that owns
                the prefix for each new DAO for that prefix.
</dd>
<dt>Prefix:</dt>
<dd>Variable-length field containing an IPv6
                address or a prefix of an IPv6 address. The Prefix Length
                field contains the number of valid leading bits in the prefix.
                The bits in the prefix after the prefix length (if any) are
                reserved and MUST be initialized to zero by the sender and
                ignored by the receiver.
</dd>
<dt>Reverse Route Stack:</dt>
<dd>Variable-length field
                containing a sequence of RRCount (possibly compressed) IPv6
                addresses. A node who adds on to the Reverse Route Stack will
                append to the list and increment the RRCount.
</dd>
</dl></blockquote>

<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2"></a><h3>5.10.2.&nbsp;
Destination Advertisement Operation</h3>

<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.1"></a><h3>5.10.2.1.&nbsp;
Overview</h3>

<p>Note that some aspects of the Destination Advertisement
            mechanism are still under investigation
</p>
<p>According to implementation specific policy, a subset or all of
            the feasible parents in the DAG may be selected to receive prefix
            information from the Destination Advertisement mechanism. This
            subset of DAG parents shall be designated the set of DA
            parents.
</p>
<p>RPL takes advantage of the DAG structure and allows a node
            capable of storing sufficient routing state to autonomously
            discover the destinations below itself through the operation of
            the Destination Advertisement mechanism. This allows participating
            nodes to build up routing state to support traffic flowing
            outwards along the DAG. Destination Advertisement messages convey
            the necessary information to learn the destinations.
</p>
<p>As Destination Advertisements for particular destinations move
            inwards along the DAG, a sequence counter is used to guarantee
            their freshness. The sequence counter is incremented by the source
            of the DAO (the node that owns the prefix), each time it issues a
            DAO for its prefix. Nodes who receive the DAO and, if scope
            allows, will be forwarding a DAO for the unmodified destination
            inwards along the DAG, will leave the sequence number unchanged.
            Intermediate nodes will check the sequence counter before
            processing a DAO, and if the DAO is unchanged (the sequence
            counter has not changed), then the DAO will be discarded without
            additional processing. Further, if the DAO appears to be out of
            synch (the sequence counter is 2 or more behind the present value)
            then the DAO state is considered to be stale and may be purged,
            and the DAO is discarded. A depth is also added for tracking
            purposes; the depth is incremented at each hop as the DAO is
            propagated up the DAG. Nodes who are storing routing state may use
            the depth to determine which possible next-hops for the
            destination are more optimal.
</p>
<p>If Destination Advertisements are activated in the DIO as
            indicated by the `D' bit, the node sends unicast Destination
            Advertisements to its DA parents, and only accepts unicast
            Destination Advertisements from any nodes BUT those contained in
            the DA parent subset.
</p>
<p>Every NA to a DA parent MAY contain one or more DAOs. Receiving
            a DAG Discovery RA-DIO with the `D' Destination Advertisement bit
            set from a DAG parent stimulates the sending of a delayed
            Destination Advertisement back, with the collection of all known
            prefixes (that is the prefixes learned via Destination
            Advertisements for nodes lower in the DAG, and any connected
            prefixes). If the Destination Advertisement Supported (A) bit is
            set in the DIO for the DAG, then a Destination Advertisement is
            also sent to a DAG parent once it has been added to the DA parent
            set after a movement, or when the list of advertised prefixes has
            changed. Destination Advertisements may also be scheduled for
            sending when the PathDigest of the DIO has changed, indicating
            that some aspect of the inwards paths along the DAG has been
            modified.
</p>
<p>Destination Advertisements may advertise positive (prefix is
            present) or negative (removed) DAOs. A no-DAO is stimulated by the
            disappearance of a prefix below. This is discovered by timing out
            after a request (a RA-DIO) or by receiving a no-DAO. A no-DAO is a
            conveyed as a DAO with a DAO Lifetime of 0.
</p>
<p>A node who is capable of recording the state information
            conveyed in a unicast DAO will do so upon receiving and processing
            the DAO, thus building up routing state concerning destinations
            below it in the DAG. If a node capable of recording state
            information receives a DAO containing a Reverse Route Stack, then
            the node knows that the DAO has traversed one or more nodes that
            did not retain any routing state as it traversed the path from the
            DAO source to the node. The node may then extract the Reverse
            Route Stack and retain the included state in order to specify
            Source Routing instructions along the return path towards the
            destination. The node MUST set the RRCount back to zero and clear
            the Reverse Route Stack prior to passing the DAO information
            on.
</p>
<p>A node who is unable to record the state information conveyed
            in the DAO will append the next-hop address to the Reverse Route
            Stack, increment the RRCount, and then pass the Destination
            Advertisement on without recording any additional state. In this
            way the Reverse Route Stack will come to contain a vector of next
            hops that must be traversed along the reverse path that the DAO
            has traveled. The vector will be ordered such that the node
            closest to the destination will appear first in the list. In such
            cases the node may choose to convey the Destination Advertisement
            to one or more DAG Parents in order of preference as guided by an
            implementation specific policy.
</p>
<p>In hybrid cases, some nodes along the path a Destination
            Advertisement follows inward along the DAG may store state and
            some may not. The Destination Advertisement mechanism allows for
            the provisioning of routing state such that when a packet is
            traversing outwards along the DAG, some nodes may be able to
            directly forward to the next hop, and other nodes may be able to
            specify a piecewise source route in order to bridge spans of
            stateless nodes within the path on the way to the desired
            destination.
</p>
<p>In the degenerate case, no node is able to store any routing
            state as Destination Advertisements pass by, and the DAG Root ends
            up with DAOs that contain a completely specified route back to the
            originating node in the form of the inverted Reverse Route Stack.
            A DAG Root should not request nor indicate support for Destination
            Advertisements if it is not able to store the Reverse Route Stack
            information in the degenerate case.
</p>
<p>Information learned through Destination Advertisements can be
            redistributed in a routing protocol, MANET or IGP. But the MANET
            or the IGP SHOULD NOT be redistributed into Destination
            Advertisements. This creates a hierarchy of routing protocols
            where DA routes stand somewhere between connected and IGP
            routes.
</p>
<p>The Destination Advertisement mechanism requires stateful nodes
            to maintain lists of known prefixes. A prefix entry contains the
            following abstract information:
</p>
<p></p>
<ul class="text">
<li>A reference to the ND entry that was created for the
                advertising neighbor.
</li>
<li>The IPv6 address and interface for the advertising
                neighbor.
</li>
<li>The logical equivalent of the full Destination
                Advertisement information (including the prefixes, depth, and
                Reverse Route Stack, if any).
</li>
<li>A 'reported' Boolean to keep track whether this prefix was
                reported already, and to which of the DA parents.
</li>
<li>A counter of retries to count how many RA-DIOs were sent on
                the interface to the advertising neighbor without reachability
                confirmation for the prefix.
</li>
</ul>

<p>Note that nodes may receive multiple information from different
            neighbors for a specific destination, as different paths through
            the DAG may be propagating information inwards along the DAG for
            the same destination. A node who is recording routing state will
            keep track of the information from each neighbor independently,
            and when it comes time to propagate the DAO for a particular
            prefix to the DA parents, then the DAO information will be
            selected from among the advertising neighbors who offer the least
            depth to the destination.
</p>
<p>The Destination Advertisement mechanism stores the prefix
            entries in one of 3 abstract lists; the Connected, the Reachable
            and the Unreachable lists.
</p>
<p>The Connected list corresponds to the prefixes owned and
            managed by the local node.
</p>
<p>The Reachable list contains prefixes for which the node keeps
            receiving DAOs, and for those prefixes which have not yet timed
            out.
</p>
<p>The Unreachable list keeps track of prefixes which are no
            longer valid and in the process of being destroyed, in order to
            send no-DAOs to the DA parents.
</p>
<a name="DATimers"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.1.1"></a><h3>5.10.2.1.1.&nbsp;
Destination Advertisement Timers</h3>

<p>The Destination Advertisement mechanism requires 2 timers;
              the DelayNA timer and the DestroyTimer.
</p>
<p></p>
<ul class="text">
<li>The DelayNA timer is armed upon a stimulation to send a
                  Destination Advertisement (such as a DIO from a DA parent).
                  When the timer is armed, all entries in the Reachable list
                  as well as all entries for Connected list are set to not
                  reported yet for that particular DA parent.
</li>
<li>The DelayNA timer has a duration that is DEF_NA_LATENCY
                  divided by a multiple of the DAG rank of the node. The
                  intention is that nodes located deeper in the DAG should
                  have a shorter DelayNA timer, allowing DAOs a chance to be
                  reported from deeper in the DAG and potentially aggregated
                  along sub-DAGs before propagating further inwards.
</li>
<li>The DestroyTimer is armed when at least one entry has
                  exhausted its retries, which means that a number of RA-DIO
                  were sent toward the reporting neighbor but that the entry
                  was not confirmed with a DAO. When the destroy timer
                  elapses, for all exhausted entries, the associated route is
                  removed, and the entry is scheduled to be destroyed.
</li>
<li>The Destroy timer has a duration of min
                  (MAX_DESTROY_INTERVAL, RA_INTERVAL).
</li>
</ul>

<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.2"></a><h3>5.10.2.2.&nbsp;
Multicast Destination Advertisement messages</h3>

<p>It is also possible for a node to multicast a DAO to the
            link-local scope all-nodes multicast address FF02::1. This message
            will be received by all node listening in range of the emitting
            node. The objective is to enable direct P2P communication, between
            destination prefixes directly supported by neighboring nodes,
            without needing the RPL routing structure to relay the
            packets.
</p>
<p>A multicast DAO MUST be used only to advertise information
            about self, i.e. prefixes in the Connected list. This would
            typically be a multicast group that this node is listening to or a
            global address owned by this node, though it can be used to
            advertise any prefix owned by this node as well. A multicast DAO
            is not used for routing and does not presume any DAG relationship
            between the emitter and the receiver; it MUST NOT be used to relay
            information learned (e.g. information in the Reachable list) from
            another node.
</p>
<p>A node receiving a multicast DAO addressed to FF02::1 MAY
            install prefixes contained in the DAO in the routing table for
            local use. Such a node MUST NOT perform any other processing on
            the DAO (i.e. such a node does not presume it is a DA parent).
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.3"></a><h3>5.10.2.3.&nbsp;
Unicast Destination Advertisement messages from child to parent</h3>

<p>When sending a Destination Advertisement to a DA parent, a LLN
            Node includes the DAOs about not already reported prefix entries
            in the Reachable and Connected lists, as well as no-DAOs for all
            the entries in the Unreachable list. Depending on its policy and
            ability to retain routing state, the receiving node SHOULD keep a
            record of the reported DAO. If the DAO offers the best route to
            the prefix as determined by policy and other prefix records, the
            node SHOULD install a route to the prefix in the DAO via the link
            local address of the reporting neighbor and it SHOULD further
            propagate the information, either as a DAO or by means of
            redistribution into a routing protocol.
</p>
<p>The RA-DIO from the DAG root is used to synchronize the whole
            DAG, including the periodic reporting of Destination
            Advertisements back up the DAG. Its period is expected to vary,
            depending on the configuration of the trickle timer that governs
            the RAs.
</p>
<p>When a node receives a RA-DIO over an LLN interface from a DA
            parent, the DelayNA is armed to force a full update.
</p>
<p>When the node broadcasts a RA-DIO on an LLN interface, for all
            entries on that interface:
</p>
<p></p>
<ul class="text">
<li>If the entry is CONFIRMED, it goes PENDING with the retry
                count set to 0.
</li>
<li>If the entry is PENDING, the retry count is incremented. If
                it reaches a maximum threshold, the entry goes ELAPSED If at
                least one entry is ELAPSED at the end of the process: if the
                Destroy timer is not running then it is armed with a
                jitter.
</li>
</ul>

<p>Since the DelayNA has a duration that decreases with the depth,
            it is expected to receive all DAOs from all children before the
            timer elapses and the full update is sent to the DA parents.
</p>
<p>Once the Destroy timer is elapsed, the prefix entry is
            scheduled to be destroyed and moved to the Unreachable list if
            there are any DA parents that need to be informed of the change in
            status for the prefix, otherwise the prefix entry is cleaned up
            right away. The prefix entry is removed from the Unreachable list
            when no more DA parents need to be informed. This condition may be
            satisfied when a no-DAO is sent to all current DA parents
            indicating the loss of the prefix, and noting that in some cases
            parents may have been removed from the set of DA parents.
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.4"></a><h3>5.10.2.4.&nbsp;
Other events</h3>

<p>Finally, the Destination Advertisement mechanism responds to a
            series of events, such as:
</p>
<p></p>
<ul class="text">
<li>Destination Advertisement operation stopped: All entries in
                the abstract lists are freed. All the routes learned from DAOs
                are destroyed.
</li>
<li>Interface going down: for all entries in the Reachable list
                on that interface, the associated route is removed, and the
                entry is scheduled to be destroyed.
</li>
<li>Loss of routing adjacency: When the routing adjacency for a
                neighbor is lost, as per the procedures described in <a class='info' href='#MaintenanceRoutingAdjacency'>Section&nbsp;5.11<span> (</span><span class='info'>Maintenance of Routing Adjacency</span><span>)</span></a>, and if the
                associated entries are in the Reachable list, the associated
                routes are removed, and the entries are scheduled to be
                destroyed.
</li>
<li>Changes to DA parent set: All entries in the Reachable list
                are set to not 'reported' and DelayNA is armed.
</li>
</ul>

<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.5"></a><h3>5.10.2.5.&nbsp;
Aggregation of prefixes by a node</h3>

<p>There may be number of cases where a aggregation may be shared
            within a platoon of nodes. In such a case, it is possible to use
            aggregation techniques with Destination Advertisements and improve
            scalability. For example, consider a platoon formed by
            firefighters and their commander. Specifically, the commander may
            be configured as the Destination Advertisement aggregator for a
            group prefix. At run time, the commander absorbs the individual
            DAO information received from the platoon members down its sub-DAG
            and only reports the aggregation up the DAG. This works fine when
            the whole platoon is attached within the commander's sub-DAG.
</p>
<p>Other cases might occur for which additional support is
            required:
</p>
<p></p>
<ol class="text">
<li>The commander is attached within the sub-DAG of one of its
                platoon members.
</li>
<li>A platoon member is somewhere else within the DAG.
</li>
<li>A platoon member is somewhere else in the LLN.
</li>
</ol>

<p>In all those cases, a node situated above the commander in the
            DAG but not above the platoon member will see the advertisements
            for the aggregation owned by the commander but not that of the
            individual platoon member prefix. So it will route all the packets
            for the platoon member towards the commander, but the commander
            will have no route to the individual platoon member and will fail
            to forward.
</p>
<p>Additional protocols may be applied beyond the scope of this
            specification to dynamically elect/provision a commander and
            platoon in order to provide route summarization for a sub-DAG.
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.10.2.6"></a><h3>5.10.2.6.&nbsp;
Default Values</h3>

<p>DEF_NA_LATENCY = To Be Determined
</p>
<p>MAX_DESTROY_INTERVAL = To Be Determined
</p>
<a name="MaintenanceRoutingAdjacency"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.11"></a><h3>5.11.&nbsp;
Maintenance of Routing Adjacency</h3>

<p>The selection of successors, along the default paths inward along
        the DAG, or along the paths learned from Destination Advertisements
        outward along the DAG, leads to the formation of routing adjacencies
        that require maintenance.
</p>
<p>In IGPs such as OSPF <a class='info' href='#RFC4915'>[RFC4915]<span> (</span><span class='info'>Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P. Pillay-Esnault, &ldquo;Multi-Topology (MT) Routing in OSPF,&rdquo; June&nbsp;2007.</span><span>)</span></a> or IS-IS <a class='info' href='#RFC5120'>[RFC5120]<span> (</span><span class='info'>Przygienda, T., Shen, N., and N. Sheth, &ldquo;M-ISIS: Multi Topology (MT) Routing in Intermediate System to Intermediate Systems (IS-ISs),&rdquo; February&nbsp;2008.</span><span>)</span></a>, the maintenance of a routing adjacency
        involves the use of Keepalive mechanisms (Hellos) or other protocols
        such as BFD (<a class='info' href='#I-D.ietf-bfd-base'>[I&#8209;D.ietf&#8209;bfd&#8209;base]<span> (</span><span class='info'>Katz, D. and D. Ward, &ldquo;Bidirectional Forwarding Detection,&rdquo; February&nbsp;2009.</span><span>)</span></a>) and MANET
        Neighborhood Discovery Protocol (NHDP <a class='info' href='#I-D.ietf-manet-nhdp'>[I&#8209;D.ietf&#8209;manet&#8209;nhdp]<span> (</span><span class='info'>Clausen, T., Dearlove, C., and J. Dean, &ldquo;MANET Neighborhood Discovery Protocol (NHDP),&rdquo; July&nbsp;2009.</span><span>)</span></a>). Unfortunately, such an approach
        is not desirable in constrained environments such as LLN and would
        lead to excessive control traffic in light of the data traffic with a
        negative impact on both link loads and nodes resources. Overhead to
        maintain the routing adjacency should be minimized. Furthermore, it is
        not always possible to rely on the link or transport layer to provide
        information of the associated link state. The network layer needs to
        fall back on its own mechanism.
</p>
<p>Thus RPL makes use of a different approach consisting of probing
        the neighbor using a Neighbor Solicitation message (see <a class='info' href='#RFC4861'>[RFC4861]<span> (</span><span class='info'>Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;Neighbor Discovery for IP version 6 (IPv6),&rdquo; September&nbsp;2007.</span><span>)</span></a>). The reception of a Neighbor Advertisement
        (NA) message with the "Solicited Flag" set is used to verify the
        validity of the routing adjacency. Such mechanism MAY be used prior to
        sending a data packet. This allows for detecting whether or not the
        routing adjacency is still valid, and should it not be the case,
        select another feasible successor to forward the packet.
</p>
<a name="PacketForwarding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.12"></a><h3>5.12.&nbsp;
Packet Forwarding</h3>

<p>When forwarding a packet to a destination, precedence is given to
        selection of a next-hop successor, with consideration given to
        selecting a DAG/OCP to follow as per marking in the IPv6 header, as
        follows:
</p>
<p></p>
<ol class="text">
<li>If the packet header contains any source routing directives
            (TBD) then the highest precedence should be given to follow
            them.
</li>
<li>If there is an entry in the routing table matching the
            destination that has been provisioned outside of the context of
            RPL, e.g. through an application intervention or a co-hosted (P2P)
            routing protocol, then use that successor.
</li>
<li>If there is an entry in the routing table matching the
            destination that has been learned from a multicast Destination
            Advertisement (e.g. the destination is a one-hop neighbor), then
            use that successor.
</li>
<li>If there is an entry in the routing table matching the
            destination that has been learned from a unicast Destination
            Advertisement (e.g. the destination is located outwards along the
            sub-DAG), then use that successor.
</li>
<li>If there is a DAG offering a route to a prefix matching the
            destination, then select one of those DAG Parents as a
            successor.
</li>
<li>If there is a DAG offering a default route with a compatible
            OCP, then select one of those DAG Parents as a successor.
</li>
<li>If there is a DAG offering a route to a prefix matching the
            destination, but all DAG Parents have been tried and are
            temporarily unavailable (as determined by the forwarding
            procedure), then select a DAG sibling as a successor.
</li>
<li>Finally, if no DAG siblings are available, the packet is
            dropped. ICMP Destination Unreachable may be invoked. An
            inconsistency is detected.
</li>
</ol>

<p>TTL MUST be decremented when forwarding. If the packet is being
        forwarded via a sibling, then the TTL may be decremented more
        aggressively (by more than one) to limit the impact of possible
        loops.
</p>
<p>Note that unless overridden by a source routing directive or a
        route that has been provisioned outside of RPL, the chosen successor
        MUST NOT be the neighbor who was the predecessor of the packet (split
        horizon).
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.12.1"></a><h3>5.12.1.&nbsp;
Loop Taxonomy</h3>

<p>The following is a summary of the sort of loops that may occur
          within RPL. This is provided in part as a basis for discussion of
          loop detection at forwarding.
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.12.1.1"></a><h3>5.12.1.1.&nbsp;
DAG Loops</h3>

<p>A DAG loop may occur when a node detaches from the DAG and
            reattaches to a device in its prior sub-DAG that has missed the
            whole detachment sequence and kept advertising the original DAG.
            This may happen in particular when RA-DIOs are missed. Use of the
            DAG sequence number can eliminate this type of loop. If the DAG
            sequence number is not in use, the protection is limited (it
            depends on propagation of DIOs during DAG hop timer), and
            temporary loops might occur. RPL will move to eliminate such a
            loop as soon as a DIO is received from a parent that appears to be
            going down, as the child has to detach from it immediately. (The
            alternate choice of staying attached and following the parent in
            its fall would have counted to infinity and led to detach as
            well).
</p>
<p>Consider Node (24) in the DAG Example depicted in <a class='info' href='#DAGExample'>Figure&nbsp;12<span> (</span><span class='info'>Example DAG</span><span>)</span></a>, and its sub-DAG Nodes (34), (44), and
            (45). An example of a DAG loop would be if Node (24) were to
            detach from the DAG rooted at (LBR), and Node (45) were to miss
            the detachment sequence. Subsequently, if the link (24)--(45) were
            to become viable and Node (24) heard Node (45) advertising the DAG
            rooted at (LBR), a DAG loop (45-&gt;34-&gt;24-&gt;45) may form if
            Node (24) attaches to Node (45).
</p>
<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.12.1.2"></a><h3>5.12.1.2.&nbsp;
DAO Loops</h3>

<p>A DAO loop may occur when the parent has a route installed by a
            DAO via a child, but the child has cleaned up the state. This loop
            happens when a no-DAO was missed till a heartbeat cleans up all
            states. The DAO loop is not explicitly handled by the current
            specification. Split horizon, not forwarding a packet back to the
            node it came from, may mitigate the DAO loop in some cases, but
            does not eliminate it.
</p>
<p>Consider Node (24) in the DAG Example depicted in <a class='info' href='#DAGExample'>Figure&nbsp;12<span> (</span><span class='info'>Example DAG</span><span>)</span></a>. Suppose Node (24) has received a DA
            from Node (34) advertising a destination at Node (45).
            Subsequently, if Node (34) tears down the DA state for the
            destination and Node (24) did not hear a no-DAO to clean up the
            state, a DAO loop may exist. Node (24) will forward traffic
            destined for Node (45) to Node (34), who may then naively return
            it into a loop (if split horizon is not in place). A more
            complicated DAO loop may result if Node (34) instead passes the
            traffic to it's sibling, Node (33), potentially resulting in a
            (24-&gt;34-&gt;33-&gt;23-&gt;13-&gt;24) loop.
</p>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.12.1.3"></a><h3>5.12.1.3.&nbsp;
Sibling Loops</h3>

<p>Sibling loops occur when a group of siblings keep choosing
            amongst themselves as successors such that a packet does not make
            forward progress. The current draft limits those loops to some
            degree by split horizon (do not send back to the same sibling) and
            parent preference (always prefer parents vs. siblings). Further
            approaches to mitigate sibling loops may include:
</p>
<p></p>
<ul class="text">
<li>aggressively dropping the TTL to limit the impact of the
                loops
</li>
<li>randomizing the next hop to try and exit the loop if there
                is one one
</li>
<li>maintaining per packet states
</li>
<li>tunneling or source routing (path vector)
</li>
</ul>

<p>Consider the DAG Example depicted in <a class='info' href='#DAGExample'>Figure&nbsp;12<span> (</span><span class='info'>Example DAG</span><span>)</span></a>. Suppose that Node (32) and (34) are
            reliable neighbors, and thus are siblings. Then, in the case where
            Nodes (22), (23), and (24) are transiently unavailable, and with
            no other guiding strategy, a sibling loop may exist, e.g.
            (33-&gt;34-&gt;32-&gt;33) as the siblings keep choosing amongst
            each other in an uncoordinated manner.
</p>
<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.13"></a><h3>5.13.&nbsp;
Expectations of Link Layer Behavior</h3>

<p>This specification does not rely on any particular features of a
        specific link layer technologies. It is anticipated that an
        implementer should be able to operate RPL over a variety of different
        low power wireless or PLC (Power Line Communication) link layer
        technologies.
</p>
<p>Implementers may find <a class='info' href='#RFC3819'>RFC 3819<span> (</span><span class='info'>Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &ldquo;Advice for Internet Subnetwork Designers,&rdquo; July&nbsp;2004.</span><span>)</span></a> [RFC3819] a
        useful reference when designing a link layer interface between RPL and
        a particular link layer technology.
</p>
<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Summary of RPL Timers</h3>

<p></p>
<blockquote class="text"><dl>
<dt>DIO Timer</dt>
<dd>One instance per DAG that a node is a member
          of. Expiry triggers RA-DIO transmission. Trickle timer with variable
          interval in [0, DIOIntervalMin..2^DIOIntervalDoublings]. See <a class='info' href='#TrickleImplementation'>Section&nbsp;5.4.3<span> (</span><span class='info'>Trickle Timer for RA Transmission</span><span>)</span></a>
</dd>
<dt>DAG Hop Timer</dt>
<dd>Up to one instance per candidate DAG
          Parent in the `Held-Up' state per DAG that a node is going to jump
          to. Expiry triggers candidate DAG Parent to become a DAG Parent in
          the `Current' state, as well as cancellation of any other DAG Hop
          timers associated with other DAG Parents for that DAG. Duration is
          computed based on the rank of the candidate DAG parent and DAG
          delay, as (candidates rank + random) * candidate's DAG_delay (where
          0 &lt;= random &lt; 1). See <a class='info' href='#DAGHeldUp'>Section&nbsp;5.8.1<span> (</span><span class='info'>Held-Up</span><span>)</span></a>.
</dd>
<dt>Hold-Down Timer</dt>
<dd>Up to one instance per candidate DAG
          Parent in the `Held-Down' state per DAG. Expiry triggers the
          eviction of the candidate DAG Parent from the candidate DAG Parent
          set. The interval should be chosen as appropriate to prevent
          flapping. See <a class='info' href='#CandidateParentStates'>Section&nbsp;5.8<span> (</span><span class='info'>Candidate DAG Parent States and Stability</span><span>)</span></a>
</dd>
<dt>DAG Heartbeat Timer</dt>
<dd>Up to one instance per DAG that
          the node is acting as DAG Root of. May not be supported in all
          implementations. Expiry triggers revision of DAGSequenceNumber,
          causing a new series of updated RA-DIO to be sent. Interval should
          be chosen appropriate to propagation time of DAG and as appropriate
          to application requirements (e.g. response time vs. overhead). See
          <a class='info' href='#DAGHeartbeat'>Section&nbsp;5.5<span> (</span><span class='info'>DAG Heartbeat</span><span>)</span></a>
</dd>
<dt>DelayNA Timer</dt>
<dd>Up to one instance per DA Parent (the
          subset of DAG Parents chosen to receive Destination Advertisements)
          per DAG. Expiry triggers sending of NA-DAO to the DA Parent. The
          interval is to be proportional to DEF_NA_LATENCY/(node rank), such
          that nodes of greater rank (further outward along the DAG) expire
          first, coordinating the sending of DAOs to allow for a chance of
          aggregation. See <a class='info' href='#DATimers'>Section&nbsp;5.10.2.1.1<span> (</span><span class='info'>Destination Advertisement Timers</span><span>)</span></a>
</dd>
<dt>DestroyTimer</dt>
<dd>Up to one instance per DA entry per
          neighbor (i.e. those neighbors who have given DAO to this node as a
          DAG Parent) Expiry triggers a change in state for the DA entry,
          setting up to do unreachable (No-DAO) advertisements or immediately
          deallocating the DA entry if there are no DA Parents. The interval
          is min(MAX_DESTROY_INTERVAL, RA_INTERVAL). See <a class='info' href='#DATimers'>Section&nbsp;5.10.2.1.1<span> (</span><span class='info'>Destination Advertisement Timers</span><span>)</span></a>
</dd>
</dl></blockquote>

<a name="SpecOptions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Protocol Extensions</h3>

<a name="Manageability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Manageability Considerations</h3>

<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>Security Considerations for RPL are to be developed in accordance
      with recommendations laid out in, for example, <a class='info' href='#I-D.tsao-roll-security-framework'>[I&#8209;D.tsao&#8209;roll&#8209;security&#8209;framework]<span> (</span><span class='info'>Tsao, T., Alexander, R., Daza, V., and A. Lozano, &ldquo;A Security Framework for Routing over Low Power and Lossy Networks,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
DAG Information Option</h3>

<p>IANA is requested to allocate a new Neighbor Discovery Option Type
        from the IPv6 Neighbor Discovery Option Formats Registry in order to
        represent the DAG Information Option as described in <a class='info' href='#DAGInformationOption'>Section&nbsp;5.1<span> (</span><span class='info'>DAG Information Option</span><span>)</span></a>
</p>
<a name="anchor74"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Objective Code Point</h3>

<p>This specification requests that an Objective Code Point registry,
        as to be specified in <a class='info' href='#I-D.ietf-roll-routing-metrics'>[I&#8209;D.ietf&#8209;roll&#8209;routing&#8209;metrics]<span> (</span><span class='info'>Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;Routing Metrics used for Path Calculation in Low Power and Lossy Networks,&rdquo; April&nbsp;2010.</span><span>)</span></a>, reserve the Objective
        Code Point value 0x0000, for the purposes designated as OCP 0 in this
        document.
</p>
<p>
</p>
<a name="anchor75"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Destination Advertisement Option</h3>

<p>IANA is requested to allocate a new Neighbor Discovery Option Type
        from the IPv6 Neighbor Discovery Option Formats Registry in order to
        represent the Destination Advertisement Option as described in <a class='info' href='#DAOptionMessage'>Section&nbsp;5.10.1.1<span> (</span><span class='info'>DAO Option</span><span>)</span></a>
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgements</h3>

<p>The ROLL Design Team would like to acknowledge the review, feedback,
      and comments from Dominique Barthel, Yusuf Bashir, Mathilde Durvy,
      Manhar Goindi, Mukul Goyal, Richard Kelsey, Quentin Lampin, Philip
      Levis, Jerry Martocci, Alexandru Petrescu, and Don Sturek.
</p>
<p>The ROLL Design Team would like to acknowledge the guidance and input
      provided by the ROLL Chairs, David Culler and JP Vasseur.
</p>
<p>The ROLL Design Team would like to acknowledge prior contributions of
      Richard Kelsey, Robert Assimiti, Mischa Dohler, Julien Abeille, Ryuji
      Wakikawa, Teco Boot, Patrick Wetterwald, Bryan Mclaughlin, Carlos J.
      Bernardos, Thomas Watteyne, Zach Shelby, Dominique Barthel, Caroline
      Bontoux, Marco Molteni, Billy Moon, and Arsalan Tavakoli, in addition to
      contributions from <a class='info' href='#I-D.thubert-roll-fundamentals'>[I&#8209;D.thubert&#8209;roll&#8209;fundamentals]<span> (</span><span class='info'>Thubert, P., Watteyne, T., Shelby, Z., and D. Barthel, &ldquo;LLN Routing Fundamentals,&rdquo; April&nbsp;2009.</span><span>)</span></a>
      and <a class='info' href='#I-D.tavakoli-hydro'>[I&#8209;D.tavakoli&#8209;hydro]<span> (</span><span class='info'>Tavakoli, A., Dawson-Haggerty, S., Hui, J., and D. Culler, &ldquo;HYDRO: A Hybrid Routing Protocol for Lossy and Low Power Networks,&rdquo; March&nbsp;2009.</span><span>)</span></a> which have provided useful
      design considerations to RPL.
</p>
<a name="anchor76"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Contributors</h3>

<p>ROLL Design Team in alphabetical order:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Anders Brandt
Zensys, Inc.
Emdrupvej 26
Copenhagen, DK-2100
Denmark

Email: abr@zen-sys.com


Thomas Heide Clausen
LIX, Ecole Polytechnique, France

Phone: +33 6 6058 9349
EMail: T.Clausen@computer.org
URI:   http://www.ThomasClausen.org/


Stephen Dawson-Haggerty
UC Berkeley
Soda Hall, UC Berkeley
Berkeley, CA  94720
USA

Email: stevedh@cs.berkeley.edu


Jonathan W. Hui
Arch Rock Corporation
501 2nd St. Ste. 410
San Francisco, CA  94107
USA

Email: jhui@archrock.com


Kris Pister
Dust Networks
30695 Huntwood Ave.
Hayward,   94544
USA

Email: kpister@dustnetworks.com


Pascal Thubert
Cisco Systems
Village d'Entreprises Green Side
400, Avenue de Roumanille
Batiment T3
Biot - Sophia Antipolis  06410
FRANCE

Phone: +33 497 23 26 34
Email: pthubert@cisco.com


Tim Winter (editor)

wintert@acm.org
</pre></div>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-bfd-base">[I-D.ietf-bfd-base]</a></td>
<td class="author-text">Katz, D. and D. Ward, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-bfd-base-09.txt">Bidirectional Forwarding Detection</a>,&rdquo; draft-ietf-bfd-base-09 (work in progress), February&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-bfd-base-09.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-manet-nhdp">[I-D.ietf-manet-nhdp]</a></td>
<td class="author-text">Clausen, T., Dearlove, C., and J. Dean, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-manet-nhdp-10.txt">MANET Neighborhood Discovery Protocol (NHDP)</a>,&rdquo; draft-ietf-manet-nhdp-10 (work in progress), July&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-manet-nhdp-10.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-roll-building-routing-reqs">[I-D.ietf-roll-building-routing-reqs]</a></td>
<td class="author-text">Martocci, J., Riou, N., Mil, P., and W. Vermeylen, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-building-routing-reqs-06.txt">Building Automation Routing Requirements in Low Power and Lossy Networks</a>,&rdquo; draft-ietf-roll-building-routing-reqs-06 (work in progress), August&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-building-routing-reqs-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-roll-home-routing-reqs">[I-D.ietf-roll-home-routing-reqs]</a></td>
<td class="author-text">Porcu, G., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-home-routing-reqs-06.txt">Home Automation Routing Requirements in Low Power and Lossy Networks</a>,&rdquo; draft-ietf-roll-home-routing-reqs-06 (work in progress), November&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-home-routing-reqs-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-roll-indus-routing-reqs">[I-D.ietf-roll-indus-routing-reqs]</a></td>
<td class="author-text">Networks, D., Thubert, P., Dwars, S., and T. Phinney, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-indus-routing-reqs-06.txt">Industrial Routing Requirements in Low Power and Lossy Networks</a>,&rdquo; draft-ietf-roll-indus-routing-reqs-06 (work in progress), June&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-indus-routing-reqs-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-roll-routing-metrics">[I-D.ietf-roll-routing-metrics]</a></td>
<td class="author-text">Vasseur, J., Kim, M., Networks, D., and H. Chong, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-routing-metrics-06.txt">Routing Metrics used for Path Calculation in Low Power and Lossy Networks</a>,&rdquo; draft-ietf-roll-routing-metrics-06 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-routing-metrics-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-roll-terminology">[I-D.ietf-roll-terminology]</a></td>
<td class="author-text">Vasseur, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-terminology-03.txt">Terminology in Low power And Lossy Networks</a>,&rdquo; draft-ietf-roll-terminology-03 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-roll-terminology-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.tavakoli-hydro">[I-D.tavakoli-hydro]</a></td>
<td class="author-text">Tavakoli, A., Dawson-Haggerty, S., Hui, J., and D. Culler, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-tavakoli-hydro-01.txt">HYDRO: A Hybrid Routing Protocol for Lossy and Low Power Networks</a>,&rdquo; draft-tavakoli-hydro-01 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-tavakoli-hydro-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.thubert-roll-fundamentals">[I-D.thubert-roll-fundamentals]</a></td>
<td class="author-text">Thubert, P., Watteyne, T., Shelby, Z., and D. Barthel, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-thubert-roll-fundamentals-01.txt">LLN Routing Fundamentals</a>,&rdquo; draft-thubert-roll-fundamentals-01 (work in progress), April&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-thubert-roll-fundamentals-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.tsao-roll-security-framework">[I-D.tsao-roll-security-framework]</a></td>
<td class="author-text">Tsao, T., Alexander, R., Daza, V., and A. Lozano, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-tsao-roll-security-framework-02.txt">A Security Framework for Routing over Low Power and Lossy Networks</a>,&rdquo; draft-tsao-roll-security-framework-02 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-tsao-roll-security-framework-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Levis08">[Levis08]</a></td>
<td class="author-text">Levis, P., Brewer, E., Culler, D., Gay, D., Madden, S., Patel, N., Polastre, J., Shenker, S., Szewczyk, R., and A. Woo, &ldquo;<a href="http://portal.acm.org/citation.cfm?id=1364804">The Emergence of a Networking Primitive in
          Wireless Sensor Networks</a>,&rdquo; Communications of the ACM,&nbsp;v.51 n.7, July&nbsp;2008 (<a href="http://portal.acm.org/citation.cfm?id=1364804">HTML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2453">[RFC2453]</a></td>
<td class="author-text"><a href="mailto:gmalkin@baynetworks.com">Malkin, G.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2453">RIP Version 2</a>,&rdquo; STD&nbsp;56, RFC&nbsp;2453, November&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2453.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2453.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2453.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3819">[RFC3819]</a></td>
<td class="author-text">Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &ldquo;<a href="http://tools.ietf.org/html/rfc3819">Advice for Internet Subnetwork Designers</a>,&rdquo; BCP&nbsp;89, RFC&nbsp;3819, July&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3819.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4101">[RFC4101]</a></td>
<td class="author-text">Rescorla, E. and IAB, &ldquo;<a href="http://tools.ietf.org/html/rfc4101">Writing Protocol Models</a>,&rdquo; RFC&nbsp;4101, June&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4101.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4191">[RFC4191]</a></td>
<td class="author-text">Draves, R. and D. Thaler, &ldquo;<a href="http://tools.ietf.org/html/rfc4191">Default Router Preferences and More-Specific Routes</a>,&rdquo; RFC&nbsp;4191, November&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4191.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4461">[RFC4461]</a></td>
<td class="author-text">Yasukawa, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4461">Signaling Requirements for Point-to-Multipoint Traffic-Engineered MPLS Label Switched Paths (LSPs)</a>,&rdquo; RFC&nbsp;4461, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4461.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4861">[RFC4861]</a></td>
<td class="author-text">Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &ldquo;<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>,&rdquo; RFC&nbsp;4861, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4861.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4875">[RFC4875]</a></td>
<td class="author-text">Aggarwal, R., Papadimitriou, D., and S. Yasukawa, &ldquo;<a href="http://tools.ietf.org/html/rfc4875">Extensions to Resource Reservation Protocol - Traffic Engineering (RSVP-TE) for Point-to-Multipoint TE Label Switched Paths (LSPs)</a>,&rdquo; RFC&nbsp;4875, May&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4875.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4915">[RFC4915]</a></td>
<td class="author-text">Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P. Pillay-Esnault, &ldquo;<a href="http://tools.ietf.org/html/rfc4915">Multi-Topology (MT) Routing in OSPF</a>,&rdquo; RFC&nbsp;4915, June&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4915.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5120">[RFC5120]</a></td>
<td class="author-text">Przygienda, T., Shen, N., and N. Sheth, &ldquo;<a href="http://tools.ietf.org/html/rfc5120">M-ISIS: Multi Topology (MT) Routing in Intermediate System to Intermediate Systems (IS-ISs)</a>,&rdquo; RFC&nbsp;5120, February&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5120.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5548">[RFC5548]</a></td>
<td class="author-text">Dohler, M., Watteyne, T., Winter, T., and D. Barthel, &ldquo;<a href="http://tools.ietf.org/html/rfc5548">Routing Requirements for Urban Low-Power and Lossy Networks</a>,&rdquo; RFC&nbsp;5548, May&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5548.txt">TXT</a>).</td></tr>
</table>

<a name="Requirements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Deferred Requirements</h3>

<p>NOTE: RPL is still a work in progress. At this time there remain many
      unsatisfied application requirements, but these are to be addressed as
      RPL is further specified.
</p>
<a name="Examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Examples</h3>

<p>Consider the example LLN physical topology in <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a>. In this example the links depicted are all
      usable L2 links. Suppose that all links are equally usable, and that the
      implementation specific policy function is simply to minimize hops. This
      LLN physical topology then yields the DAG depicted in <a class='info' href='#DAGExample'>Figure&nbsp;12<span> (</span><span class='info'>Example DAG</span><span>)</span></a>, where the links depicted are the edges
      toward DAG parents. This topology includes one DAG, rooted by an LBR
      node (LBR) at depth 1. The LBR node will issue RAs containing DIO, as
      governed by a trickle timer. Nodes (11), (12), (13), have selected (LBR)
      as their only parent, attached to the DAG at depth 2, and periodically
      advertise RA-DIO multicasts. Node (22) has selected (11) and (12) in its
      DAG parent set, and advertises itself at depth 3. Node (22) thus has a
      set of DAG parents {(11), (12)} and siblings {((21), (23)}.
</p><br /><hr class="insert" />
<a name="LLNExample"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)
                                  / | \
                             .---`  |  `----.
                            /       |        \
                         (11)------(12)------(13)
                          | \       | \       | \
                          |  `----. |  `----. |  `----.
                          |        \|        \|        \
                         (21)------(22)------(23)      (24)
                          |        /|        /|         |
                          |  .----` |  .----` |         |
                          | /       | /       |         |
                         (31)------(32)------(33)------(34)
                          |        /| \       | \       | \
                          |  .----` |  `----. |  `----. |  `----.
                          | /       |        \|        \|        \
                .--------(41)      (42)      (43)------(44)------(45)
               /         /         /| \       | \
         .----`    .----`    .----` |  `----. |  `----.
        /         /         /       |        \|        \
     (51)------(52)------(53)------(54)------(55)------(56)

</pre></div>
<p>Note that the links depicted represent the usable L2
        connectivity available in the LLN. For example, Node (31) can
        communicate directly with its neighbors, Nodes (21), (22), (32), and
        (41). Node (31) cannot communicate directly with any other nodes, e.g.
        (33), (23), (42). In this example these links offer bidirectional
        communication, and `bad' links are not depicted.
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Example LLN Topology&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="DAGExample"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)
                                  / | \
                             .---`  |  `----.
                            /       |        \
                         (11)      (12)      (13)
                          | \       | \       | \
                          |  `----. |  `----. |  `----.
                          |        \|        \|        \
                         (21)      (22)      (23)      (24)
                          |        /|        /|         |
                          |  .----` |  .----` |         |
                          | /       | /       |         |
                         (31)      (32)      (33)      (34)
                          |        /| \       | \       | \
                          |  .----` |  `----. |  `----. |  `----.
                          | /       |        \|        \|        \
                .--------(41)      (42)      (43)      (44)      (45)
               /         /         /| \       | \
         .----`    .----`    .----` |  `----. |  `----.
        /         /         /       |        \|        \
     (51)      (52)      (53)      (54)      (55)      (56)

</pre></div>
<p>Note that the links depicted represent directed links in
        the DAG overlaid on top of the physical topology depicted in <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a>. As such, the depicted edges represent the
        relationship between nodes and their DAG parents, wherein all depicted
        edges are directed and oriented `up' on the page toward the DAG root
        (LBR). The DAG provides the default routes within the LLN, and serves
        as the foundation on which RPL builds further routing structure, e.g.
        through the Destination Advertisement mechanism.
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: Example DAG&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor79"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.1"></a><h3>B.1.&nbsp;
Moving Down a DAG</h3>

<p>Consider node (56) in the example of <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a>. In the unmodified example, node (56) is
        at depth 6 with one DAG parent, {(43)}, and one sibling (55). Suppose,
        for example, that node (56) wished to expand its DAG parent set to
        contain node (55), as {(43), (55)}. Such a change would require node
        (56) to detach from the DAG, to defer reattachment until a loop
        avoidance algorithm has completed, and to then reattach to the DAG
        with {(43), (55)} as it's DAG parents. When node (56) detaches from
        the DAG, it is able to act as the root of its own floating DAG and
        establish its frozen sub-DAG (which is empty). Node (56) can then
        observe that Node (55) is still attached to the original DAG, that its
        sequence number is able to increment, and deduce that Node (55) is
        safely not behind Node (56). There is then little change for a loop,
        and Node (56) may safely reattach to the DAG, with parents {(43),
        (55)}. At reattachment time, node (56) would present itself with a
        depth deeper than that of its deepest DAG parent (node (55) at depth
        6), depth 7.
</p>
<a name="anchor80"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.2"></a><h3>B.2.&nbsp;
Link Removed</h3>

<p>Consider the example of <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a> when link
        (13)-(24) goes down.
</p>
<p></p>
<ul class="text">
<li>Node (24) will detach and become the root of its own floating
            DAG
</li>
<li>Node (34) will learn that its DAG parent is now part of its own
            floating DAG, will consider that it can remain a part of the DAG
            rooted at node (LBR) via node (33), and will initiate procedures
            to detach from DAG (LBR) in order to re-attach at a lower
            depth.
</li>
<li>Node (45) will similarly make preparations to remain attached
            to the DAG rooted at (LBR) by detaching from Node (34) and
            re-attaching at a lower depth to node (44).
</li>
<li>Node (34) will complete re-attachment to Node (33) first, since
            it is able to attach closer to the root of the DAG.
</li>
<li>Node (45) will cancel plans to detach/reattach, keep node (34)
            as a DAG parent, and update its dependent depth accordingly.
</li>
<li>Node (45) may now anyway add node (44) to its set of DAG
            parents, as such an addition does not require any modification to
            its own depth.
</li>
<li>Node (24) will observe that it may reattach to the DAG rooted
            at node (LBR) by selecting node (34) as its DAG parent, thus
            reversing the relationship that existed in the initial state.
</li>
</ul>

<a name="anchor81"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.3"></a><h3>B.3.&nbsp;
Link Added</h3>

<p>Consider the example of <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a> when link
        (12)-(42) appears.
</p>
<p></p>
<ul class="text">
<li>Node (42) will see a chance to get closer to the LBR by adding
            (12) to its set of DAG parents, {(32), (12)}
</li>
<li>Node (42) may be content to leave its advertised depth at 5,
            reflecting a depth deeper than its deepest parent (32).
</li>
<li>Node (42) may now choose to remain where it is, with two
            parents {(12), (32)}. Should there be a reason for Node (42) to
            evict Node (32) from its set of DAG parents, Node (42) would then
            advertise itself at depth 2, thus moving up the DAG. In this case,
            Node (53), (54), and (55) may similarly follow and advertise
            themselves at depth 3.
</li>
</ul>

<a name="anchor82"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.4"></a><h3>B.4.&nbsp;
Node Removed</h3>

<p>Consider the example of <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a> when node
        (41) disappears.
</p>
<p></p>
<ul class="text">
<li>Node (51) and (52) will now have empty DAG parent sets and be
            detached from the DAG rooted by (LBR), advertising themselves as
            the root of their own floating DAGs.
</li>
<li>Node (52) would observe a chance to reattach to the DAG rooted
            at (LBR) by adding Node (53) to its set of DAG parents, after an
            appropriate delay to avoid creating loops. Node (52) will then
            advertise itself in the DAG rooted at (LBR) at depth 7.
</li>
<li>Node (51) will then be able to reattach to the DAG rooted at
            (LBR) by adding Node (52) to its set of DAG parents and
            advertising itself at depth 8.
</li>
</ul>

<a name="anchor83"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.5"></a><h3>B.5.&nbsp;
New LBR Added</h3>

<p>Consider the example of <a class='info' href='#LLNExample'>Figure&nbsp;11<span> (</span><span class='info'>Example LLN Topology</span><span>)</span></a> when a
        new LBR, (LBR2) appears, with connectivity (LBR2)-(52),
        (LBR2)-(53).
</p>
<p></p>
<ul class="text">
<li>Nodes (52) and Node (53) will see a chance to join a new DAG
            rooted at (LBR2) with a depth of 2. Node (52) and (53) may take
            this chance immediately, as there is no risk of forming loops when
            joining a DAG that has never before been encountered. Note that
            the nodes may choose to join the new DAG rooted at (LBR2) if and
            only if (LBR2) offers more optimum properties in line with the
            implementation specific local policy.
</li>
<li>Nodes (52) and (53) begin to send RA-DIO advertising themselves
            at depth 2 in the DAGID (LBR2).
</li>
<li>Nodes (51), (41), (42), and (54) may then choose to join the
            new DAG at depth 3, possibly to get closer to the DAG root. Note
            that in a more advanced case, these nodes also remain members of
            the DAG rooted at (LBR), for example in support of different
            constraints for different types of traffic.
</li>
<li>Node (55) may then join the new DAG at depth 4, possibly to get
            closer to the DAG root.
</li>
<li>The remaining nodes may choose to remain in their current
            positions within the DAG rooted at node (LBR), since there is no
            clear advantage to be gained by moving to DAG (LBR2).
</li>
</ul>

<a name="DestinationAdvertisementExample"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B.6"></a><h3>B.6.&nbsp;
Destination Advertisement</h3>

<p>Consider the example DAG depicted in <a class='info' href='#DAGExample'>Figure&nbsp;12<span> (</span><span class='info'>Example DAG</span><span>)</span></a>. Suppose that Nodes (22) and (32) are
        unable to record routing state. Suppose that Node (42) is able to
        perform prefix aggregation on behalf of Nodes (53), (54), and
        (55).
</p>
<p></p>
<ul class="text">
<li>Node (53) would send a DAO to Node (42), indicating the
            availability of destination (53).
</li>
<li>Node (54) and Node (55) would similarly send DAOs to Node (42)
            indicating their own destinations.
</li>
<li>Node (42) would collect and store the routing state for
            destinations (53), (54), and (55).
</li>
<li>In this example, Node (42) may then be capable of representing
            destinations (42), (53), (54), and (55) in the aggregation
            (42').
</li>
<li>Node (42) sends a DAO advertising destination (42') to Node
            32.
</li>
<li>Node (32) does not want to maintain any routing state, so it
            adds onto to the Reverse Route Stack in the DAO and passes it on
            to Node (22) as (42'):[(42)]. It may send a separate DAO to
            indicate destination (32).
</li>
<li>Node (22) does not want to maintain any routing state, so it
            adds on to the Reverse Route Stack in the DAO and passes it on to
            Node (12) as (42'):[(42), (32)]. It also relays the DAO containing
            destination (32) to Node 12 as (32):[(32)], and finally may send a
            DAO for itself indicating destination (22).
</li>
<li>Node (12) is capable to maintain routing state again, and
            receives the DAOs from Node (22). Node (12) then learns:
</li>
<ul class="text">
<li>Destination (22) is available via Node (22)
</li>
<li>Destination (32) is available via Node (22) and the piecewise
              source route to (32)
</li>
<li>Destination (42') is available via Node (22) and the
              piecewise source route to (32), (42').
</li>
</ul>
<li>Node (12) sends DAOs to (LBR), allowing (LBR) to learn routes
            to the destinations (12), (22), (32), and (42'). (42), (53), (54),
            and (55) are available via the aggregation (42'). It is not
            necessary for Node (12) to propagate the piecewise source routes
            to (LBR).
</li>
</ul>

<a name="AdditionalExamples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Additional Examples</h3>

<p>Consider the expanded example LLN physical topology in <a class='info' href='#LLNExample2'>Figure&nbsp;13<span> (</span><span class='info'>Expanded LLN Topology</span><span>)</span></a>. In this example an additional LBR is
      added. Suppose that all nodes are configured with an implementation
      specific policy function that aims to minimize the number of hops, and
      that both LBRs are configured to root different DAGIDs. We may now walk
      through the formation of the two DAGs.
</p><br /><hr class="insert" />
<a name="LLNExample2"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)                    (LBR2)
                                  / | \                    /    \
                             .---`  |  `----.             /      \
                            /       |        \            |      |
                         (11)------(12)------(13)      (14)      (15)
                          | \       | \       | \       |        /|
                          |  `----. |  `----. |  `----. |  .----` |
                          |        \|        \|        \| /       |
                         (21)------(22)------(23)      (24)      (25)
                          |        /|        /|         |        / /
                          |  .----` |  .----` |  .-----]|[------` /
                          | /       | /       | /       |        /
                         (31)------(32)------(33)------(34)-----`
                          |        /| \       | \       | \
                          |  .----` |  `----. |  `----. |  `----.
                          | /       |        \|        \|        \
                .--------(41)      (42)      (43)------(44)------(45)
               /         /         /| \       | \
         .----`    .----`    .----` |  `----. |  `----.
        /         /         /       |        \|        \
     (51)------(52)------(53)------(54)------(55)------(56)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;13: Expanded LLN Topology&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="DAGStep1"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)                    (LBR2)
                                  / | \                    /    \
                             .---`  |  `----.             /      \
                            /       |        \            |      |
                         (11)      (12)      (13)      (14)      (15)



                         (21)      (22)      (23)      (24)      (25)



                         (31)      (32)      (33)      (34)



                         (41)      (42)      (43)      (44)      (45)



     (51)      (52)      (53)      (54)      (55)      (56)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;14: DAG Construction Step 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="DAGStep2"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)                    (LBR2)
                                  / | \                    /    \
                             .---`  |  `----.             /      \
                            /       |        \            |      |
                         (11)      (12)      (13)      (14)      (15)
                          | \       | \       |         |        /|
                          |  `----. |  `----. |         |  .----` |
                          |        \|        \|         | /       |
                         (21)      (22)      (23)      (24)      (25)



                         (31)      (32)      (33)      (34)



                         (41)      (42)      (43)      (44)      (45)



     (51)      (52)      (53)      (54)      (55)      (56)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;15: DAG Construction Step 2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="DAGStep3"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)                    (LBR2)
                                  / | \                    /    \
                             .---`  |  `----.             /      \
                            /       |        \            |      |
                         (11)      (12)      (13)      (14)      (15)
                          | \       | \       |         |        /|
                          |  `----. |  `----. |         |  .----` |
                          |        \|        \|         | /       |
                         (21)      (22)      (23)      (24)      (25)
                          |        /|        /          |        / /
                          |  .----` |  .----`    .-----]|[------` /
                          | /       | /         /       |        /
                         (31)      (32)      (33)      (34)-----`



                         (41)      (42)      (43)      (44)      (45)



     (51)      (52)      (53)      (54)      (55)      (56)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;16: DAG Construction Step 3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="DAGStep4"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)                    (LBR2)
                                  / | \                    /    \
                             .---`  |  `----.             /      \
                            /       |        \            |      |
                         (11)      (12)      (13)      (14)      (15)
                          | \       | \       |         |        /|
                          |  `----. |  `----. |         |  .----` |
                          |        \|        \|         | /       |
                         (21)      (22)      (23)      (24)      (25)
                          |        /|        /          |        / /
                          |  .----` |  .----`    .-----]|[------` /
                          | /       | /         /       |        /
                         (31)      (32)      (33)      (34)-----`
                          |        /|         | \       | \
                          |  .----` |         |  `----. |  `----.
                          | /       |         |        \|        \
                         (41)      (42)      (43)      (44)      (45)



     (51)      (52)      (53)      (54)      (55)      (56)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;17: DAG Construction Step 4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="DAGStep5"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                  (LBR)                    (LBR2)
                                  / | \                    /    \
                             .---`  |  `----.             /      \
                            /       |        \            |      |
                         (11)      (12)      (13)      (14)      (15)
                          | \       | \       |         |        /|
                          |  `----. |  `----. |         |  .----` |
                          |        \|        \|         | /       |
                         (21)      (22)      (23)      (24)      (25)
                          |        /|        /          |        / /
                          |  .----` |  .----`    .-----]|[------` /
                          | /       | /         /       |        /
                         (31)      (32)      (33)      (34)-----`
                          |        /|         | \       | \
                          |  .----` |         |  `----. |  `----.
                          | /       |         |        \|        \
                .--------(41)      (42)      (43)      (44)      (45)
               /         /         /|         | \
         .----`    .----`    .----` |         |  `----.
        /         /         /       |         |        \
     (51)      (52)      (53)      (54)      (55)      (56)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;18: DAG Construction Step 5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="TODO"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;
Outstanding Issues</h3>

<p>This section enumerates some outstanding issues that are to be
      addressed in future revisions of the RPL specification.
</p>
<a name="anchor84"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.1"></a><h3>D.1.&nbsp;
Additional Support for P2P Routing</h3>

<p>In some situations the baseline mechanism to support arbitrary P2P
        traffic, by flowing inward along the DAG until a common parent is
        reached and then flowing outward, may not be suitable for all
        application scenarios. A related scenario may occur when the outward
        paths setup along the DAG by the destination advertisement mechanism
        are not be the most desirable outward paths for the specific
        application scenario (in part because the DAG links may not be
        symmetric). It may be desired to support within RPL the discovery and
        installation of more direct routes `across' the DAG. Such mechanisms
        need to be investigated.
</p>
<a name="anchor85"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2"></a><h3>D.2.&nbsp;
Loop Detection</h3>

<p>It is under investigation to complement the loop avoidance
        strategies provided by RPL with a loop detection mechanism that may be
        employed when traffic is forwarded.
</p>
<a name="anchor86"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.3"></a><h3>D.3.&nbsp;
DAO Fan-out</h3>

<p>When DAOs are relayed to more than one DAG Parent, in some cases a
        situation may be created where a large number of DAOs conveying
        information about the same destination flow inward along the DAG. It
        is desirable to bound/limit the multiplication/fan-out of DAOs in this
        manner.
</p>
<a name="anchor87"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.4"></a><h3>D.4.&nbsp;
Source Routing</h3>

<p>In support of nodes who maintain minimal routing state, and to make
        use of the collection of piecewise source routes from the Destination
        Advertisement mechanism, there needs to be some investigation of a
        mechanism to specify, attach, and follow source routes for packets
        traversing the LLN.
</p>
<a name="anchor88"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.5"></a><h3>D.5.&nbsp;
Address / Header Compression</h3>

<p>In order to minimize overhead within the LLN it is desirable to
        perform some sort of address and/or header compression, perhaps via
        labels, addresses aggregation, or some other means. This is still
        under investigation.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tim Winter (editor)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:wintert@acm.org">wintert@acm.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ROLL Design Team</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">IETF ROLL WG</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dtroll@external.cisco.com">dtroll@external.cisco.com</a></td></tr>
</table>
</body></html>
