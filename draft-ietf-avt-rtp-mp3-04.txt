Network Working Group                                   Ross Finlayson
Internet-Draft                                          LIVE.COM
Expire in six months                                    2000.11.11
Category: Informational

             A More Loss-Tolerant RTP Payload Format for MP3 Audio

                     <draft-ietf-avt-rtp-mp3-04.txt>

1. Status of this Memo

       This document is an Internet-Draft and is in full conformance
       with all provisions of Section 10 of RFC2026.

       Internet-Drafts are working documents of the Internet Engineering
       Task Force (IETF), its areas, and its working groups.  Note that
       other groups may also distribute working documents as
       Internet-Drafts.

       Internet-Drafts are draft documents valid for a maximum of six
       months and may be updated, replaced, or obsoleted by other
       documents at any time.  It is inappropriate to use Internet-
       Drafts as reference material or to cite them other than as
       "work in progress."

       The list of current Internet-Drafts can be accessed at
       http://www.ietf.org/ietf/1id-abstracts.txt

       The list of Internet-Draft Shadow Directories can be accessed at
       http://www.ietf.org/shadow.html.

2. Abstract

While the RTP payload format defined in RFC 2250 is generally applicable
to all forms of MPEG audio or video, it is less suitable for MPEG 1
or 2, layer III audio (commonly known as "MP3").  The reason for this is
that an MP3 frame is not a true "Application Data Unit" - it contains a
back-pointer to data in earlier frames, and so cannot be decoded
independently of these earlier frames.  Because RFC 2250 defines that
packet boundaries coincide with frame boundaries, it handles packet loss
inefficiently when carrying MP3 data.  The loss of an MP3 frame will
render some data in previous (or future) frames useless, even if they
are received without loss.

In this document we define an alternative RTP payload format for MP3
audio.  This format uses a data-preserving rearrangement of the original
MPEG frames, so that packet boundaries now coincide with true MP3
"Application Data Units", which can also (optionally) be rearranged in
an interleaving pattern.  This new format is therefore more
data-efficient than RFC 2250 in the face of packet loss.


3. The Structure of MP3 Frames

In this section we give a brief overview of the structure of a MP3 frame.
(For more detailed description, see the official MPEG 1 audio [2] and
MPEG 2 audio [3] specifications.)

Each MPEG audio frame begins with a 4-byte header.  Information defined by
this header includes:
- Whether the audio is MPEG 1 or MPEG 2.
- Whether the audio is layer I, II, or III.
        (The remainder of this document assumes layer III, i.e., "MP3")
- Whether the audio is mono or stereo.
- Whether or not there is a 2-byte CRC field following the header.
- (indirectly) The size of the frame.

The following structures appear after the header:
- (optionally) A 2-byte CRC field
- A "side info" structure.  This has the following length:
	- 32 bytes for MPEG 1 stereo
	- 17 bytes for MPEG 1 mono, or for MPEG 2 stereo
	- 9 bytes for MPEG 2 mono
- Encoded audio data, plus optional ancillary data
	(filling out the rest of the frame)

For the purpose of this document, the "side info" structure is the most
important, because it defines the location and size of the "Application
Data Unit" (ADU) that an MP3 decoder will process.  In particular, the
"side info" structure defines:
- "main_data_begin": This is a back-pointer (in bytes) to the start of the
	ADU.  The back-pointer is counted from the beginning of the frame,
	and counts only encoded audio data and any ancillary data
	(i.e., ignoring any header, CRC, or "side info" fields).

An MP3 decoder processes each ADU independently.  The ADUs will generally
vary in length, but their average length will, of course, be that of the
of the MP3 frames (minus the length of the header, CRC, and "side info"
fields).  (In MPEG literature, this ADU is sometimes referred to as
a "bit reservoir".)


4. A New Payload Format

4.1 ADU frames

As noted in [4], a payload format should be designed so that packet
boundaries coincide with "codec frame boundaries" - i.e., with ADUs.
In the RFC 2250 payload format for MPEG audio [1], each RTP packet
payload contains MP3 frames.  In this new payload format for MP3 audio,
however, each RTP packet payload contains "ADU frames", where an
"ADU frame" is defined as:
	- The 4-byte MPEG header
		(the same as the original MP3 frame, except that the
		 first 11 bits are replaced with an "Interleaving
		 Sequence Number", as described in section 7)
	- The optional 2-byte CRC field
		(the same as the original MP3 frame)
	- The "side info" structure
		(the same as the original MP3 frame)
	- The complete sequence of encoded audio data (and any ancillary
		data) for the ADU (i.e., running from the start of this
		MP3 frame's "main_data_begin" back-pointer, up to the
		start of the next MP3 frame's back-pointer)

4.2 ADU descriptors

Within each RTP packet payload, each "ADU frame" is prepended by a
1 or 2-byte "ADU descriptor", which gives the size of the ADU, and
indicates whether or not this packet's data is a continuation of the
previous packet's data.  (This occurs only when a single
"ADU descriptor"+"ADU frame" is too large to fit within a RTP packet.)

An ADU descriptor consists of the following fields
- "C": Continuation flag (1 bit):
	1 if the data following the ADU descriptor is a continuation of
	an ADU frame that was too large to fit within a single RTP
	packet; 0 otherwise.
- "T": Descriptor Type flag (1 bit):
	0 if this is a 1-byte ADU descriptor;
	1 if this is a 2-byte ADU descriptor.
- "ADU size" (6 or 14 bits):
	The size (in bytes) of the ADU frame that will follow this
	ADU descriptor (i.e., NOT including the size of the descriptor
	itself).  A 2-byte ADU descriptor (with a 14-bit "ADU size"
	field) is used for ADU frames sizes of 64 bytes or more.  For
	smaller ADU frame sizes, senders MAY alternatively use a 1-byte
	ADU descriptor (with a 6-bit "ADU size" field).  Receivers MUST
	be able to accept an ADU descriptor of either size.

Thus, a 1-byte ADU descriptor is formatted as follows:

      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     |C|0|  ADU size |
     +-+-+-+-+-+-+-+-+

and a 2-byte ADU descriptor is formatted as follows:

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |C|1|     ADU size (14 bits)    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

4.3 Packing rules

Each RTP packet payload begins with a "ADU descriptor", followed by
"ADU frame" data.  Normally, this "ADU descriptor"+"ADU frame" will
fit completely within the RTP packet.  In this case, more than one
successive "ADU descriptor"+"ADU frame" MAY be packed into a single RTP
packet, provided that they all fit completely.

If, however, a single "ADU descriptor"+"ADU frame" is too large to fit
within an RTP packet, then it is split across two or more successive RTP
packets.  Each such packet begins with an ADU descriptor.  The first
packet's descriptor has a "C" (continuation) flag of 0; the following
packets' descriptors each have a "C" flag of 1.  Each descriptor has the
same "ADU size" value: the size of entire "ADU frame" (not just the
portion that will fit within a single RTP packet).  Each such packet
(even the last one) contains only one "ADU descriptor".

4.4 RTP payload type

The (static) payload type 14 that was defined for MPEG audio [5]
MUST NOT be used.  Instead, a different, dynamic payload type MUST be
used - i.e., one in the range [96,127].

4.5 Handling received data

Note that no information is lost by converting a sequence of MP3 frames to
a corresponding sequence of "ADU frames", so a receiving RTP implementation
can either feed the ADU frames directly to an appropriately modified MP3
decoder, or convert them back into a sequence of MP3 frames, as described
in appendix A.2 below.


5. Handling Multiple MPEG Audio Layers

The RTP payload format described here is intended only for MPEG 1 or 2,
layer III audio ("MP3").  In contrast, layer I and layer II frames are
self-contained, without a back-pointer to earlier frames.  However, it
is possible (although unusual) for a sequence of audio frames to consist
of a mixture of layer III frames and layer I or II frames.  When such a
sequence is transmitted, only layer III frames are converted to ADUs;
layer I or II frames are sent 'as is' (except for the prepending of an
"ADU descriptor").  Similarly, the receiver of a sequence of frames
- using this payload format - leaves layer I and II frames untouched
(after removing the prepended "ADU descriptor), but converts layer III
frames from "ADU frames" to regular MP3 frames.  (Recall that each
frame's layer is identified from its 4-byte MPEG header.)


6. Frame Packetizing and Depacketizing

The transmission of a sequence of MP3 frames takes the following steps:
	MP3 frames
		-1-> ADU frames
			-2-> interleaved ADU frames
				-3-> RTP packets

Step 1, the conversion of a sequence of MP3 frames to a corresponding
sequence of ADU frames, takes place as described in sections 3 and 4.1.
(Note also the pseudo-code in appendix A.1.)

Step 2 is the reordering of the sequence of ADU frames in an
(optional) interleaving pattern, prior to packetization, as described
in section 7 below.  (Note also the pseudo-code in appendix B.1.)
Interleaving helps reduce the effect of packet loss, by distributing
consecutive ADU frames over more than one packet.  (Note that because
of the back-pointer in MP3 frames, interleaving can be applied
- in general - only to ADU frames.  Thus, interleaving was not possible
for RFC 2250.)

Step 3 is the packetizing of a sequence of (interleaved) ADU frames
into RTP packets - as described in section 4.3 above.  When computing
the RTP timestamps for each packet, this step ignores any reordering
that took place in step 2, and treats the sequence of packetized
ADU frames as if they were generated sequentially.  I.e., the RTP
timestamps on outgoing packets are always monotonically nondecreasing,
regardless of interleaving.

Similarly, a sequence of received RTP packets is handled as follows:
	RTP packets
		-4-> RTP packets ordered by RTP sequence number
			-5-> interleaved ADU frames
				-6-> ADU frames
					-7-> MP3 frames

Step 4 is the usual sorting of incoming RTP packets using the RTP
sequence number.

Step 5 is the depacketizing of ADU frames from RTP packets - i.e., the
reverse of step 3.  As part of this process, a receiver uses the "C"
(continuation) flag in the ADU descriptor to notice when an ADU frame
is split over more than one packet (and to discard the ADU frame
entirely if one of these packets is lost).

Step 6 is the rearranging of the sequence of ADU frames back to its
original order (except for ADU frames missing due to packet loss),
as described in section 7 below.  (Note also the pseudo-code in
appendix B.2.)

Step 7 is the conversion of the sequence of ADU frames into a
corresponding sequence of MP3 frames - i.e., the reverse of step 1.
(Note also the pseudo-code in appendix A.2.)  With an appropriately
modified MP3 decoder, an implementation may omit this step; instead,
it could feed ADU frames directly to the (modified) MP3 decoder.


7. ADU Frame Interleaving

In MPEG audio frames (MPEG 1 or 2; all layers) the high-order 11 bits of
the 4-byte MPEG header ('syncword') are always all-one (i.e., 0xFFE).
When reordering a sequence of ADU frames for transmission, we reuse
these 11 bits as an "Interleaving Sequence Number" (ISN).
(Upon reception, they are replaced with 0xFFE once again.)

The structure of the ISN is (a,b), where:
	- a == bits 0-8:	8-bit Interleave Index (within Cycle)
	- b == bits 9-11: 	3-bit Interleave Cycle Count

I.e., the 4-byte MPEG header is reused as follows:

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Interleave Idx| Cyc Cnt|  The rest of the original MPEG header |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Example: An interleave cycle of size 8, with a stride of 4, would have
a pattern of: 0,4,2,6,1,5,3,7 - giving the following sequence of ISNs:
(0,0) (4,0) (2,0) (6,0) (1,0) (5,0) (3,0) (7,0) (0,1) (4,1) (2,1) etc.
So, in this example, a sequence of ADU frames
          f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 (etc.)
would get reordered, in step 2, into:
          (0,0)f0 (4,0)f4 (2,0)f2 (6,0)f6 (1,0)f1 (5,0)f5 (3,0)f3 (7,0)f7
          (0,1)f8 (4,1)f12 (2,1)f10 (etc.)
and the reverse reordering (along with replacement of the 0xFFE) would
occur upon reception.

The reason for breaking the ISN into "Interleave Cycle Count" and
"Interleave Index" (rather than just treating it as a single 11-bit
counter) is to give receivers a way of knowing when an ADU frame
should be 'released' to the ADU->MP3 conversion process (step 7
above), rather than waiting for more interleaved ADU frames to arrive.
E.g., in the example above, when the receiver sees a frame with
ISN (<something>,1), it knows that it can release all previously-seen
frames with ISN (<something>,0), even if some other (<something>,0)
frames remain missing due to packet loss.  A 8-bit Interleave Index
allows interleave cycles of size up to 256.

The choice of an interleaving order can be made independently of RTP
packetization.  Thus, a simple implementation could choose an
interleaving order first, reorder the ADU frames accordingly (step 2),
then simply pack them sequentially into RTP packets (step 3).  However,
the size of ADU frames - and thus the number of ADU frames that will
fit in each RTP packet - will typically vary in size, so a more optimal
implementation would combine steps 2 and 3, by choosing an interleaving
order that better reflected the number of ADU frames packed within
each RTP packet.

Each receiving implementation of this payload format MUST recognize
the ISN and be able to perform deinterleaving of incoming ADU frames
(step 6).  However, a sending implementation of this payload format
MAY choose not to perform interleaving - i.e., by omitting step 2.
In this case, the high-order 11 bits in each 4-byte MPEG header would
remain at 0xFFE.  Receiving implementations would thus see a sequence
of identical ISNs (all 0xFFE), treat this as if the Interleave Cycle
Count had wrapped-around, and simply release the sequence of incoming
ADU frames sequentially to the ADU->MP3 conversion process (step 7),
without reordering.


8. SDP Payload Format Description

Pending any future standardization of this payload format, SDP "rtpmap"
attributes [6] use the name "X-MP3" to denote this format.


9. Security Considerations

The security considerations for this payload format are identical to
those noted for RFC 2250 [1].


10. Acknowledgements

The suggestion of adding an interleaving option (using the first bits
of the MPEG 'syncword' - which would otherwise be all-ones - as an
interleaving index) is due to Dave Singer and Stefan Gewinner.  Feedback
from Chris Sloan led to the addition of an "ADU descriptor" preceding
each ADU frame in the RTP packet.


11. References

[1] Hoffman, D., Fernando, G., Goyal, V., and Civanlar, M.
      "RTP Payload Format for MPEG1/MPEG2 Video", RFC 2250, January 1998.
[2] ISO/IEC International Standard 11172-3; "Coding of moving pictures
      and associated audio for digital storage media up to about 1,5
      Mbits/s - Part 3: Audio", 1993.
[3] ISO/IEC International Standard 13818-3; "Generic coding of moving
      pictures and associated audio information - Part 3: Audio", 1998.
[4] Handley, M.
      "Guidelines for Writers of RTP Payload Format Specifications"
      Work-in-Progress, Internet-Draft
      "draft-ietf-avt-rtp-format-guidelines-04.txt", October 1999.
[5] Schulzrinne, H.
      "RTP Profile for Audio and Video Conferences with Minimal Control"
      RFC 1890, January 1996.
[6] Handley, M., Jacobson, V.,
      "SDP: Session Description Protocol",
      RFC 2327, April 1998.


9. Author's Address

	Ross Finlayson,
	Live Networks, Inc. (LIVE.COM)
	email: finlayson@live.com
	WWW: http://www.live.com/


Appendix A. Translating Between "MP3 Frames" and "ADU Frames"

The following 'pseudo code' describes how a sender using this payload
format can translate a sequence of regular "MP3 Frames" to "ADU Frames",
and how a receiver can perform the reverse translation: from "ADU Frames"
to "MP3 Frames".

We first define the following abstract data structures:

- "Segment": A record that represents either a "MP3 Frame" or an
    "ADU Frame".  It consists of the following fields:
	- "header": the 4-byte MPEG header
	- "headerSize": a constant (== 4)
	- "sideInfo": the 'side info' structure, *including* the optional
		2-byte CRC field, if present
	- "sideInfoSize": the size (in bytes) of the above structure
	- "frameData": the remaining data in this frame
	- "frameDataSize": the size (in bytes) of the above data
	- "backpointer": the size (in bytes) of the backpointer for
		this frame
	- "aduDataSize": the size (in bytes) of the ADU associated with
		this frame.  (If the frame is already an "ADU Frame", then
		aduDataSize == frameDataSize)
	- "mp3FrameSize": the total size (in bytes) that this frame would
		have if it were a regular "MP3 Frame".
		(If it is already a "MP3 Frame", then
		mp3FrameSize == headerSize + sideInfoSize + frameDataSize)
		Note that this size can be derived completely from "header".

- "SegmentQueue": A FIFO queue of "Segment"s, with operations
	- void enqueue(Segment)
	- Segment dequeue()
	- Boolean isEmpty()
	- Segment head()
	- Segment tail()
	- Segment previous(Segment):
		returns the segment prior to a given one
	- Segment next(Segment): returns the segment after a given one
	- unsigned totalDataSize(): returns the sum of the "frameDataSize"
	  fields of each entry in the queue

A.1 Converting a sequence of "MP3 Frames" to a sequence of "ADU Frames":

SegmentQueue pendingMP3Frames; // initially empty
while (1) {
	// Enqueue new MP3 Frames, until we have enough data to generate
	// the ADU for a frame:
	do {
		int totalDataSizeBefore
			= pendingMP3Frames.totalDataSize();

		Segment newFrame = 'the next MP3 Frame';
		pendingMP3Frames.enqueue(newFrame);

		int totalDataSizeAfter
			= pendingMP3Frames.totalDataSize();
	} while (totalDataSizeBefore < newFrame.backpointer ||
		  totalDataSizeAfter < newFrame.aduDataSize);

	// We now have enough data to generate the ADU for the most
	// recently enqueued frame (i.e., the tail of the queue).
	// (The earlier frames in the queue - if any - must be discarded,
	// as we don't have enough data to generate their ADUs.)
	Segment tailFrame = pendingMP3Frames.tail();

	// Output the header and side info:
	output(tailFrame.header);
	output(tailFrame.sideInfo);

	// Go back to the frame that contains the start of our ADU data:
	int offset = 0;
	Segment curFrame = tailFrame;
	int prevBytes = tailFrame.backpointer;
	while (prevBytes > 0) {
		curFrame = pendingMP3Frames.previous(curFrame);
		int dataHere = curFrame.frameDataSize;
		if (dataHere < prevBytes) {
			prevBytes -= dataHere;
		} else {
			offset = dataHere - prevBytes;
			break;
		}
	}

	// Dequeue any frames that we no longer need:
	while (pendingMP3Frames.head() != curFrame) {
		pendingMP3Frames.dequeue();
	}

	// Output, from the remaining frames, the ADU data that we want:
	int bytesToUse = tailFrame.aduDataSize;
	while (bytesToUse > 0) {
		int dataHere = curFrame.frameDataSize - offset;
		int bytesUsedHere
			= dataHere < bytesToUse ? dataHere : bytesToUse;

		output("bytesUsedHere" bytes from curFrame.frameData,
			starting from "offset");

		bytesToUse -= bytesUsedHere;
      		offset = 0;
		curFrame = pendingMP3Frames.next(curFrame);
	}
}

A.2 Converting a sequence of "ADU Frames" to a sequence of "MP3 Frames":

SegmentQueue pendingADUFrames; // initially empty
while (1) {
	while (needToGetAnADU()) {
		Segment newADU = 'the next ADU Frame';
		pendingADUFrames.enqueue(newADU);

		insertDummyADUsIfNecessary();
	}

	generateFrameFromHeadADU();
}

Boolean needToGetAnADU() {
	// Checks whether we need to enqueue one or more new ADUs before
	// we have enough data to generate a frame for the head ADU.
	Boolean needToEnqueue = True;

	if (!pendingADUFrames.isEmpty()) {
		Segment curADU = pendingADUFrames.head();
		int endOfHeadFrame = curADU.mp3FrameSize
			- curADU.headerSize - curADU.sideInfoSize;
		int frameOffset = 0;

		while (1) {
			int endOfData = frameOffset
				- curADU.backpointer + curADU.aduDataSize;
			if (endOfData >= endOfHeadFrame) {
				// We have enough data to generate a frame.
				needToEnqueue = False;
				break;
			}

			frameOffset += curADU.mp3FrameSize
				- curADU.headerSize - curADU.sideInfoSize;
			if (curADU == pendingADUFrames.tail()) break;
			curADU = pendingADUFrames.next(curADU);
		}
	}

    return needToEnqueue;
}

void generateFrameFromHeadADU() {
	Segment curADU = pendingADUFrames.head();

	// Output the header and side info:
	output(curADU.header);
	output(curADU.sideInfo);

	// Begin by zeroing out the rest of the frame, in case the ADU
	// data doesn't fill it in completely:
	int endOfHeadFrame = curADU.mp3FrameSize
		- curADU.headerSize - curADU.sideInfoSize;
	output("endOfHeadFrame" zero bytes);

	// Fill in the frame with appropriate ADU data from this and
	// subsequent ADUs:
	int frameOffset = 0;
	int toOffset = 0;

	while (toOffset < endOfHeadFrame) {
		int startOfData = frameOffset - curADU.backpointer;
		if (startOfData > endOfHeadFrame) {
			break; // no more ADUs are needed
		}
		int endOfData = startOfData + curADU.aduDataSize;
		if (endOfData > endOfHeadFrame) {
			endOfData = endOfHeadFrame;
		}

		int fromOffset;
		if (startOfData <= toOffset) {
			fromOffset = toOffset - startOfData;
			startOfData = toOffset;
			if (endOfData < startOfData) {
				endOfData = startOfData;
			}
		} else {
			fromOffset = 0;
	
			// leave some zero bytes beforehand:
			toOffset = startOfData;
		}

		int bytesUsedHere = endOfData - startOfData;
		output(starting at offset "toOffset, "bytesUsedHere" bytes
			from "&curADU.frameData[fromOffset]");
		toOffset += bytesUsedHere;

		frameOffset += curADU.mp3FrameSize
			- curADU.headerSize - curADU.sideInfoSize;
		curADU = pendingADUFrames.next(curADU);
	}

	pendingADUFrames.dequeue();
}

void insertDummyADUsIfNecessary() {
	// The tail segment (ADU) is assumed to have been recently
	// enqueued.  If its backpointer would overlap the data
	// of the previous ADU, then we need to insert one or more empty,
	// 'dummy' ADUs ahead of it.  (This situation should occur only if
	// an intermediate ADU was missing - e.g., due to packet loss.)
	while (1) {
		Segment tailADU = pendingADUFrames.tail();
    		int prevADUend; // relative to the start of the tail ADU

		if (pendingADUFrames.head() != tailADU) {
			// there is a previous ADU
			Segment prevADU
				= pendingADUFrames.previous(tailADU);
			prevADUend
				= prevADU.mp3FrameSize + prevADU.backpointer
				  - prevADU.headerSize - curADU.sideInfoSize;
			if (prevADU.aduDataSize > prevADUend) {
				// this shouldn't happen if the previous ADU
				// was well-formed
				prevADUend = 0;
			} else {
				prevADUend -= prevADU.aduDataSize;
			}
		} else {
			prevADUend = 0;
		}

		if (tailADU.backpointer > prevADUend) {
			// Insert a 'dummy' ADU in front of the tail.
			// This ADU can have the same "header" (and thus
			// "mp3FrameSize") as the tail ADU, but should have
			// an "aduDataSize" of zero.  The simplest way to do
			// this is to copy the "sideInfo" from the tail ADU,
			// and zero out the "main_data_begin" and all of the
			// "part2_3_length" fields.
		} else {
			break; // no more dummy ADUs need to be inserted
		}
	}
}


Appendix B: Interleaving and Deinterleaving

The following 'pseudo code' describes how a sender can reorder a
sequence of "ADU Frames" according to an interleaving pattern (step 2),
and how a receiver can perform the reverse reordering (step 6).

B.1 Interleaving a sequence of "ADU Frames":

We first define the following abstract data structures:
- "interleaveCycleSize": an integer in the range [1,256]
- "interleaveCycle": an array, of size "interleaveCycleSize",
	containing some permutation of the integers from the set
	[0 .. interleaveCycleSize-1]
	e.g., if "interleaveCycleSize" == 8, "interleaveCycle" might
	contain: 0,4,2,6,1,5,3,7
- "inverseInterleaveCycle": an array containing the inverse of the
	permutation in "interleaveCycle" - i.e., such that
		interleaveCycle[inverseInterleaveCycle[i]] == i
- "ii": the current Interleave Index (initially 0)
- "icc": the current Interleave Cycle Count (initially 0)
- "aduFrameBuffer": an array, of size "interleaveCycleSize", of
	ADU Frames that are awaiting packetization

while (1) {
	int positionOfNextFrame = inverseInterleaveCycle[ii];
	aduFrameBuffer[positionOfNextFrame] = the next ADU frame;
	replace the high-order 11 bits of this frame's MPEG header
	    with (ii,icc);
		// Note: Be sure to leave the remaining 21 bits as is
	if (++ii == interleaveCycleSize) {
		// We've finished this cycle, so pass all
		// pending frames to the packetizing step
		for (int i = 0; i < interleaveCycleSize; ++i) {
			pass aduFrameBuffer[i] to the packetizing step;
		}

		ii = 0;
		icc = (icc+1)%8;
	}
}

B.2 Deinterleaving a sequence of (interleaved) "ADU Frames":
		
We first define the following abstract data structures:
- "ii": the Interleave Index from the current incoming ADU frame
- "icc": the Interleave Cycle Count from the current incoming ADU frame
- "iiLastSeen": the most recently seen Interleave Index
	(initially, some integer *not* in the range [0,255])
- "iccLastSeen": the most recently seen Interleave Cycle Count
	(initially, some integer *not* in the range [0,7])
- "aduFrameBuffer": an array, of size 32, of (pointers to)
	ADU Frames that have just been depacketized
	(initially, all entries are NULL)

while (1) {
	aduFrame = the next ADU frame from the depacketizing step;
	(ii,icc) = "the high-order 11 bits of aduFrame's MPEG header";
	"the high-order 11 bits of aduFrame's MPEG header" = 0xFFE;
		// Note: Be sure to leave the remaining 21 bits as is

	if (icc != iccLastSeen || ii == iiLastSeen) {
		// We've started a new interleave cycle
		// (or interleaving was not used).  Release all
		// pending ADU frames to the ADU->MP3 conversion step:
		for (int i = 0; i < 32; ++i) {
			if (aduFrameBuffer[i] != NULL) {
				release aduFrameBuffer[i];
				aduFrameBuffer[i] = NULL;
			}
		}
	}

	iiLastSeen = ii;
	iccLastSeen = icc;
	aduFrameBuffer[ii] = aduFrame;
}

