XML Digital Signatures Working Group               D. Eastlake,
INTERNET-DRAFT                                     IBM
draft-ietf-xmldsig-core-02                         J. Reagle,
Expires May 19, 1999                               W3C/MIT
                                                   D. Solo,
                                                   Citigroup

                         XML-Signature Core Syntax
                                      
Copyright Notice

   Copyright (c) 1999 The Internet Society & W3C (MIT, INRIA, Keio), All
   Rights Reserved.
   
IETF Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.
   
   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.
   
   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."
   
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.
   
W3C Status of this document

   This document is a production of the joint IETF/W3C XML Signature
   Working Group.
   
   http://www.w3.org/Signature
   
   The comparable html draft of this version may be found at
   
   http://www.w3.org/TR/1999/WD-xmldsig-core-19991119/
   
   The latest version of this draft series may be found at:
   
   http://www.w3.org/TR/xmldsig-core
   
   This is a public WG Draft that follows the November IETF meeting.
   Consequently it includes a editoral changes and recrafting though no
   major design changes. This version includes the experimental use of
   XML Schema and XML entity references. The XML schema declarations
   within the specification may contain errors, though the complete WG
   schema definition does validate to the Schema DTD. We expect the final

Eastlake, Reagle, Solo					[Page 1]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   draft will include a DTD and schema.
   
   Please send comments to the editors and cc: the list
   <w3c-ietf-xmldsig@w3.org>. Publication as a Working Draft does not
   imply endorsement by the W3C membership or IESG. This is a draft
   document and may be updated, replaced or obsoleted by other documents
   at any time. It is inappropriate to cite W3C Drafts as other than
   "work in progress." A list of current W3C working drafts can be found
   at http://www.w3.org/TR
   
   Patent disclosures relevant to this specification may be found on the
   WG's patent disclosure page.
   
Abstract

   This document specifies the syntax and processing rules for the
   encoding of digital signatures using XML. Such signatures can provide
   integrity, message authentication, and/or signer authentication
   services for data of any type, whether located within the XML that
   includes the signature or locatable elsewhere.
   
Table of Contents

     1. Introduction
          1.1 Editorial Conventions
          1.2 Design Philosophy
          1.3 Namespaces and Identifiers
          1.4 Versions
     2. Signature Overview
          2.1 The Signature Element
          2.2 The SignedInfo Element
          2.3 The ObjectReference Element
          2.4 The Manifest and Package Elements
          2.5 The SignatureProperties Element
     3. Core Signature Syntax
          3.1 The Signature element
          3.2 The SignatureValue Element
          3.3 The SignedInfo Element
          3.4 The KeyInfo Element
          3.5 The Object Element
     4. Additional Signature Syntax
          4.1 The Manifest and Package Elements
          4.2 The SignatureProperties Element
          4.3 Processing Instructions
          4.4 Comments in dsig Elements
     5. Algorithms
          5.1 Algorithm Identifiers, Parameters, and Implementation
            Requirements
          5.2 Message Digests
          5.3 Message Authentication Codes
          5.4 Signature Algorithms
          5.5 Canonicalization Algorithms
          5.6 Transform Algorithms

Eastlake, Reagle, Solo					[Page 2]
 
Internet Draft		XML-Signature Core Syntax	November 1999


     6.0 Processing rules
          6.1 Generation
          6.2 Signature Validation
     7.0 Security Considerations
          7.1 Only What is Signed is Secure
          7.2 Only What is "Seen" Should be Signed
          7.3 Check the Security Model
          7.4 Algorithms, Key Lengths, Etc.
     8.0 Example syntax
     9.0 Schema
     10 Definitions
     11.0 Other Useful Types (normative)
     12.0 References
     13.0 Acknowledgements (non-normative)
     14.0 Open Issues (non-normative)
       
1.0 Introduction

   This document describes the proposed syntax and processing rules for
   the XML Digital Signature specification. This specification provides a
   mechanism for applying digital signatures to XML documents and other
   Internet resources and encoding those signatures as XML.
   
   The structure allows for both embedded and detached signatures. An
   embedded signature can include the signature within the signed object
   or embed the signed object within the signature. A detached signature
   allows the signature to be independent of the object. The processing
   structure allows for switching between embedded and detached
   signatures without necessarily invalidating the signature.
   
   This document also defines other useful types including methods of
   referencing collections of resources, and key management and algorithm
   definitions.
   
  1.1 Editorial Conventions
  
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].
   
   This document includes a list of open issues which are still being
   addressed by the working group and may include editorial comments
   within the text.
   
  1.2 Design Philosophy
  
   The design philosophy and requirements of this specification are
   addressed in the XML-Signature Requirements document
   [XML-Signature-RD].
   
  1.3 Namespaces and Identifiers
  
   The XML namespace [XML-namespace] URI that MUST be used by

Eastlake, Reagle, Solo					[Page 3]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   experimental implementations of this dated specification is:
   
   xmlns="http://www.w3.org/1999/11/xmldsig-core"
   
   While applications MUST support XML and XML-namespaces, the use of
   internal entities or our "dsig" XML namespace prefix and
   defaulting/scoping conventions are OPTIONAL; we use these facilities
   so as to provide compact and readable examples.
   
   This specification uses Uniform  Resource Identifiers [URI] to
   identify resources, algorithms, and semantics. The URI in the
   namespace declaration above is also used as a prefix for URIs under
   the control of this specification. For resources not under the control
   of this specification, we use the designated Uniform Resource Names
   [URN] or Uniform Resource Locators [URL] defined by the external
   specification. If an external specification has not allocated itself a
   Uniform Resource Identifier we allocate an identifier under our own
   namespace. For instance:
   
   SignatureProperties is identified and defined by this specifications
          namespace
          http://www.w3.org/1999/11/dsig-core/SignatureProperties
          
   XSLT is identified and defined by an external namespace
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   SHA1 is identified via this specification's namespace and defined via
          a normative reference
          http://www.w3.org/1999/11/dsig-core/SHA1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          
   Finally, in order to provide for terse namespace declarations we use
   XML internal entities as macros within URIs. For instance:
   
   <?xml version="1.0" ?>
   <!DOCTYPE Signature SYSTEM "xmldsig.dtd" [
   <!ENTITY dsig 'http://www.w3.org/1999/10/signature-core'>]>
     ...
     <SignedInfo>
       <SignatureMethod Algorithm="&dsig;/dsaWithSHA-1"/>
       ...
     </SignedInfo>
   
   Security Comment: XML processors will automatically expand entity
   declarations prior to signature generation. Consequently, this feature
   does not permit a substitution attack whereby an attacker replaces the
   entity declaration with another so as to change the meaning of the
   signature. Furthemore, we define this entity as part of the Signature
   XML Schema such that one does not have to rely upon an internal subset
   declaration. However, since this specification presently permits a
   CanonicalizationMethod of null over SignedInfo, entity declarations
   will not be expanded in those instances (or where the schema is not

Eastlake, Reagle, Solo					[Page 4]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   present) and we have not completely assessed the security risk.
   
  1.4 Versions
  
   No provision is made for an explicit version number in this syntax. If
   a future version is needed, it is expected to use a different
   Namespace.
   
2.0 Signature Overview

   This section provides an overview of XML digital signature syntax and
   processing. The formal specification is provided in º3. The editors
   assume the reader is familiar with basic digital signature and XML
   concepts.
   
  2.1 The Signature Element
  
   XML digital signatures are very flexible and may be used to apply
   signatures to any type of resource. The resource(s) being signed may
   be included within the signature, outside the signature in the same
   document, or completely outside of the document.
   
   XML digital signatures are represented by the Signature element which
   has the following structure:
   
   <Signature>
     (SignedInfo)
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The required SignedInfo element is the information which is actually
   signed. SignedInfo includes a digest calculated over each of the data
   objects being signed. The core signature verification includes the
   verification of these digests. The algorithms used in calculating the
   SignatureValue are also included in the signed information. The
   signature can not cover itself so the SignatureValue element is
   outside SignedInfo.
   
   KeyInfo indicates what key was used to create the signature, such as
   certificates, key names, and key agreement algorithms and information
   -- we define only a few. KeyInfo is optional for two reasons. First,
   KeyInfo might contain information the signer does not wish to reveal
   to all signature verifiers. Second, the information may be known
   within the application's context and need not be represented
   explicitly. However, if the signer wishes to bind the keying
   information to the signature, an ObjectReference can easily identify
   and include the KeyInfo as part of the signature.
   
   Object is an optional element for including data within a signature.
   The data can be optionally typed and/or encoded.
   

Eastlake, Reagle, Solo					[Page 5]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   Signature properties, such as time of signing, can be included in the
   SignatureProperties element. (These properties are traditionally
   called signature "attributes" although that term in that context has
   no relationship to the XML term "attribute" SignatureProperties can be
   included within an Object and signed at the signer's discretion.
   
  2.2 The SignedInfo Element
  
   The SignedInfo element has the structure indicated below.
   
   <Signature>
     <SignedInfo>
       (CanonicalizationMethod)?
       (SignatureMethod)
       (ObjectReference)+
     </SignedInfo>
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The CanonicalizationMethod is the algorithm which is used to
   canonicalize the SignedInfo element before it is digested as part of
   the signature operation. In the absence of a CanonicalizationMethod
   element, no canonicalization is done.
   
   The SignatureMethod is the algorithm used to convert the canonicalized
   SignedInfo into the SignatureValue. It is a combination of a digest
   algorithm and a key dependent algorithm and possibly other algorithms
   such as padding, for example RSA-SHA1 or HMAC-SHA1. The algorithm
   names are signed to resist attacks based on substituting a weaker
   algorithm.
   
   To promote application interoperability we specify mandatory to
   implement canonicalization, digest, and signature algorithms. We
   specify additional algorithms as Recommended or Optional and the
   signature design permits arbitrary signer algorithm specification.
   
   The ObjectReference element identifies a resource, specifies any
   transformations, specifies the digest algorithm, and includes the
   resulting digest value. A resource is signed by computing the contents
   digest value and the signature over that value. The signature is later
   checked via resource (defn) and signature validation (defn).
   
  2.3 The ObjectReference Element
  
   The ObjectReference element has the structure indicated below.
   
   ...
   <SignedInfo>
      (CanonicalizationMethod)?
      (SignatureMethod)
      <ObjectReference (URI=? | IDREF=?) Type=?>

Eastlake, Reagle, Solo					[Page 6]
 
Internet Draft		XML-Signature Core Syntax	November 1999


        (Transforms)?
        (DigestMethod)
        (DigestValue)
      </ObjectReference>+
   </SignedInfo>
   ...
   
   The optional URI/IDREF attribute of ObjectReference idenitifies the
   signed resource.
   
   Several mechanisms are provided for maintaining signature validity
   over resources which can not be persistently identified via a URL.
   First, no pointer to the signed object need be given at all for one
   ObjectReference in a Signature. Second, objects within ObjectReference
   need not be identified via URLs, instead location independent URIs
   (such as a URN or other URI schemes) are permitted -- by definition.
   Note, if a URL is used to identify an ojbect, this acts as an
   assertion by the signer that they are signing the content of the
   dereferenced URL. Third, the ObjectReference may reference a Manifest
   or the like which references instructions for dereferencing the
   appropriate content.
   
   The optional Type attribute provides information about the content of
   the resource identified by URI/IDREF. In particular, it can indicate
   that an Object contains a SignatureProperties, Manifest, or Package
   elements.
   
   Transforms is an optional ordered list of processing steps that are
   applied to the resource's content before it is digested. Transforms
   can include arbitrary specifications such as canonicalization,
   encoding/decoding (including compression/inflation), XSLT and XPath.
   XSLT/XPath transforms permit the signer to derive an XML document that
   omits portions of the source document. Consequently those excluded
   portions can change without affecting signature validity (this is how
   we address the requirement of signing portions of a document.) For
   example, if the resource being signed encloses the signature itself,
   such a transform must be used to exclude the signature value from its
   own computation  If no Transforms element is present, the resource's
   content identified by the URI/IDREF is digested directly.
   
   Arbritrary user specified transforms are permitted. To promote
   interoperability, we specify mandatory to implement canonicalization
   and decoding algorithms. Additional canonicalization, coding, XSLT,
   and XPath based transform algorithms are specified as recommended or
   optional;
   
   DigestMethod is the algorithm applied to the object after Transforms
   is applied to yield the DigestValue. The signing of the DigestValue is
   what bind's a resources content to the signer's key.
   
  2.4 The Manifest and Package Elements
  
   There are cases where it is efficient to have one signature cover many

Eastlake, Reagle, Solo					[Page 7]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   items. One approach is to include multiple ObjectReferences within
   SignedInfo. Since the core verification behavior includes verifying
   the digests of objects referenced within SignedInfo, some applications
   may need an alternative approach which allows pushing the validation
   decision to the application. This allows more complex processing to be
   defined on an application specific basis. For example, it may be
   sufficient if the signature's validity for n out of m of the items can
   be verified or there may be a large number of items that it is desired
   to sign with multiple signature algorithms and / or keys where listing
   all of the items within the SignedInfo element of each Signature is
   too verbose.
   
   To answer these requirements, additional object types have been
   defined which may be referenced by SignedInfo. The Manifest element is
   provided which similarly contains a collection of references and
   objects (like SignedInfo), but leaves it entirely up to the
   application which digest or digests it will verify. Multiple
   signatures over the possibly large number of items in a Manifest need
   only point to the Manifest from one ObjectReference in each
   signature's SignedInfo.
   
   The structure of Manifest, which reuses the ObjectReference and Object
   elements described above, is as follows:
   
   <Manifest>
     (ObjectReference)+
     (Object)*
   </Manifest>
   
   A Package is syntactically identical to a Manifest but asserts the
   identity of each of its ObjectReference elements after Transforms
   application.
   
   Manifest and Package may appear as the content of an Object.
   
  2.5 The SignatureProperties Element
  
   Statements or assertions concerning data blocks should be included in
   those data blocks or in other data blocks signed in parallel with
   them. Statements about the signature process itself, however, such as
   time of signing or serial number or hardware used in calculation of
   the signature, can be included in a SignatureProperties block. Such
   blocks can be signed, via an ObjectReference, or not, as appropriate.
   
   <SignatureProperties>
     <SignatureProperty Target= >
       (ObjectReference)+
       (Object)*
     </SignatureProperty>*
   </Manifest>
   
   The structure of SignatureProperties is shown above. It reuses the
   ObjectReference and Object elements. The mandatory Target attribute

Eastlake, Reagle, Solo					[Page 8]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   references the element to which the property applies.
   
3.0 Core Signature Syntax

   The general structure of an XML signature is described in section 2
   above. This section provides detailed syntax of the core signature
   features and actual exampes. The syntax is defined via [XML-Schema]
   with the following XML preamble, declaration, and internal entity:
   
   <?xml version='1.0'?>
   <!DOCTYPE schema
   SYSTEM
   'http://www.w3.org/TR/1999/WD-xmlschema-1-19991105/structures.dtd'
   [
   <!ENTITY dsig 'http://www.w3.org/1999/10/signature-core'>
   ]>
   <schema targetNS='http://www.w3.org/1999/10/signature-core'
      version='0.1'
      xmlns='http://www.w3.org/1999/XMLSchema'>
   <textEntity
   name="dsig">http://www.w3.org/1999/10/signature-core</textEntity>
   
  3.1 The Signature element
  
   The Signature element is the root element of a XML Signature. A simple
   example of a complete signature follows:
   
   <!DOCTYPE Signature [
   <!ENTITY dsig 'http://www.w3.org/1999/10/signature-core'>]>
   <Signature xmlns="http://www.w3.org/1999/11/xmldsig-core">
     <SignedInfo>
       <!ENTITY dsig "http://www.w3.org/1999/11/xmldsig-core">
       <CanonicalizationMethod
        Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
       <SignatureMethod Algorithm="&dsig;/dsaWithSHA-1"/>
       <ObjectReference Location="http://www.mypage.com">
         <DigestMethod Algorithm="&dsig;/sha1"/>
         <DigestValue encoding="&dsig;/base64">a23bcd43</DigestValue>
       </ObjectReference>
     </SignedInfo>
     <SignatureValue >dd2323dd</SignatureValue>
     <KeyInfo>
        <keyname>Solo</keyname>
     </KeyInfo>
   </Signature>
   
   Note: this example will be revised to include generated hash/signature
   values that validate.
   
   <element name='Signature'>
     <archetype order='seq' content='elemOnly'>
       <element ref='SignedInfo'/>
       <element ref='SignatureValue'/>

Eastlake, Reagle, Solo					[Page 9]
 
Internet Draft		XML-Signature Core Syntax	November 1999


       <element ref='KeyInfo' minOccurs='0' maxOccurs='1' />
       <element ref='Object' minOccurs='0' maxOccurs='*'/>
     </archetype'>
   </element>
   
  3.2 The SignatureValue Element
  
   The SignatureValue element contains the actual value of the digital
   signature. The encoding of this value is determined by the
   SignatureMethod used. For all SignatureMethods specified herein, that
   encoding is Base 64 [RFC2045]. The ability to define a SignatureMethod
   and SignatureValue pair which includes multiple distinct signatures is
   explicitly permitted (e.g. "rsawithsha-1 and ecdsawithsha-1").
   
   <element name='SignatureValue' type='string'/>
   
  3.3 The SignedInfo Element
  
   The structure of SignedInfo includes a canonicalization algorithm, a
   signature algorithm, and one or more references to objects. The
   SignedInfo element may contain an optional ID attribute that will
   allow it to be referenced by other signatures and objects.
   
   <element name='SignedInfo'>
     <archetype order='seq' content='elemOnly'>
       <element ref='CanonicalizationMethod' minOccurs='0'
        maxOccurs='1'/>
       <element ref='SignatureMethod'/>
       <element ref='ObjectReference' minOccurs='1' maxOccurs='*'/>
       <attribute name='Id' type='ID' />
     </archtype>
   </element>
   
   SignedInfo does not include explicit signature properties. If an
   application needs to associate properties (such as signing time,
   signing device, etc.) with the signature, it may add an additional
   Object that includes that data and reference that Object via an
   ObjectReference. See the SignatureProperties element below.
   
    3.3.1 The CanonicalizationMethod Element
    
   CanonicalizationMethod is an optional element which specifies the
   canonicalization algorithm applied to the SignedInfo element prior to
   performing signature calculations. This element uses the general
   structure here for algorithms in which a URI is used to identify the
   algorithm and the contents of the element contain any parameter needed
   by the algorithm. Possible options may include a minimal algorithm
   (CRLF and charset normalization), or more extensive operations such as
   [XML-C14N]. An expected default for this value will be defined once
   the specification of XML aware canonicalization algorithms are
   finalized. If the CanonicalizationMethod is omitted, no change is made
   to SignedInfo.
   

Eastlake, Reagle, Solo					[Page 10]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   <element name='CanonicalizationMethod'>
     <archetype>
       <attribute name='Algorithm' type='uri' />
     </archetype>
   </element>
   
    3.3.2 The SignatureMethod Element
    
   SignatureMethod is a required element which specifies the algorithm
   used for signature generation and validation. This algorithm
   identifies all cryptographic functions involved in the signature
   operation (e.g. hashing, public key algorithms, MACs, etc.). This
   element uses the general structure here for algorithms in which a URI
   is included as an attribute naming the algorithm and contents of the
   element contain any parameter needed by the algorithm. While there is
   a single identifier, that identifier may specify a format containing
   multiple distinct signature values.
   
   <element name='SignatureMethod'>
     <archetype>
       <attribute name='Algorithm' type='uri' />
     </archetype>
   </element>
   
    3.3.3 The ObjectReference Element
    
   ObjectReference is an element that may occur one or more times. It
   identifies the object being signed, the type of the object, an
   optional list of transforms to be applied prior to digesting, a digest
   algorithm and digest value. An optional ID attribute permits an
   ObjectReference to be easily referenced from elsewhere.
   
   <element name='ObjectReference' minOccurs='1' maxOccurs='*'>
     <archetype order='seq'>
       <element ref='Transforms' minOccurs='0' maxOccurs='*'/>
       <element ref='DigestMethod'/>
       <element ref='DigestValue'/>
       <attribute name='Id' type='ID' />
       <attribute name='URI' type='uri' />
       <attribute name='IDREF' type='IDREF' />
       <attribute name='Type' type='string' />
     </archetype>
   </element>
   
   The URI/IDREF attribute identifies the Object using a URI [URI] or
   IDREF [XML]. We distinguish between URIs and IDREFs so as to provide
   expositional clarity and ease signature processing in the face of
   confusion about URIs and fragment identifiers. As specified by RFC2396
   [URI], URIs can be used in conjunction with a fragment identifier by
   use of a separating pound symbol '#', but the URI proper does not
   include the fragment identifier. (The meaning of the fragment is
   defined by the resource's MIME type). URI/IDREF only permits a 'clean'
   URI or IDREF; fragment identification is specified under Transforms.

Eastlake, Reagle, Solo					[Page 11]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   This choice permits ObjectReferences to identify a fragment of a
   document that is encoded: the ObjectReference identifies the resource,
   the first Transform specifies decoding, the second Transform specifies
   the fragement.
   
   Note that a null URI (URI="") is permitted and identifies the parent
   document.
   
   If the URI/IDREF attribute is omitted all-together, the receiving
   application is expected to know the identity of the object. For
   example, a lightweight data protocol might ommit this attribute given
   the identity of the object is part of the application context. This
   attribute may be omitted from at most one ObjectReference in any
   particular SignedInfo, Manifest, or Package.
   
   The digest algorithm is applied to the content yielded after the URI
   is dereferenced, decoded, and transformed. If the URI indicates an XML
   document, the document is assumed to be unparsed prior to the
   application of Transforms. If there are no Transforms, then the
   indicated resource is passed to the digest algorithm unmodified.
   
   The optional Type attribute contains information about the type of
   object being signed (e.g. manifest, package, signature properties,
   document). This is represented as a URI. For example:
   
   Type="&dsig;/Manifest"
   Type="&dsig;/SignatureProperty"
   
    3.3.3.1 The Transforms Element
    
   Transforms is an optional element that contains one or more operations
   to be performed on an indicated resource prior to digest calculation.
   (These operations are different from the CanonicalizationMethod
   specified in the Signature that id applied over SignedInfo.) If the
   Transforms element is omitted, the exact data referenced is digested
   byte for byte.
   
   The Transforms element contains an ordered list of Transform elements.
   The output of each Transform serves as input to the next Transform.
   The input to the first Transform is the raw data yielded by
   dereferencing the resource identifier. The output from the last
   Transform is the input for the DigestMethod algorithm.
   
   Each Transform consists of an Algorithm attribute, optional MimeType
   and Charset attributes, and content parameters, if any, appropriate
   for the given algorithm. The Algorithm attribute value specifies the
   name of the algorithm to be performed, and the Transform content
   provides additional data to govern the algorithm's processing of the
   input resource.
   
   The optional MimeType and Charset (IANA registered character set)
   attributes are made available to algorithms which need and are
   otherwise unable to deduce that information about the data they are

Eastlake, Reagle, Solo					[Page 12]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   processing.
   
   <element name='Transforms' minOccurs='0' maxOccurs='1'>
     <archetype>
       <element ref='Transform'/>
       <attribute name='Algorithm' type='string' />
     </archetype>
   </element>
   <element name='Transform' minOccurs='1' maxOccurs='*'>
     <archetype>
       <attribute name='Algorithm' type='uri' />
       <attribute name='Encoding' type='uri' />
       <attribute name='Type' type='uri' />
     </archetype>
   </element>
   
   Examples of resource transforms include but are not limited to base-64
   decoding [RFC2045], canonicalization [XML-c14n], XPath filtering
   [Xpath], and XSLT [XSLT]. The generic definition of the Transform
   element also allows application-specific transform algorithms. For
   example, the transform could be a decompression routine given by a
   Java class appearing as a base-64 encoded parameter to the Java
   Transform algorithm. However, applications should refrain from using
   application-specific transforms whenever possible since the resulting
   signature will not necessarily be verifiable outside of the
   application domain. The section Transform Algorithms defines the list
   of standard transformations.
   
   Implementation Comment: When transformations are applied the signer is
   not signing the native (original) document but the resulting
   (transformed) document.
   
    3.3.3.2 The DigestMethod Element
    
   DigestMethod is a required element which identifies the digest
   algorithm to be applied to the signed object. This element uses the
   general structure here for algorithms in which a URI is included as an
   attribute naming the algorithm and optional contents of the element
   contain any parameter needed by the algorithm.
   
   <element name='DigestMethod'>
     <archetype>
        <element name='Parameter' minOccurs='0' maxOccurs='*'/>
        <attribute name='Algorithm' type='uri' />
     </archetype>
   </element>
   
    3.3.3.3 The DigestValue Element
    
   DigestValue is an element which contains the encoded value of the
   digest. The optional Encoding attribute gives the encoding method
   which defaults to Base 64 [RFC2045].
   

Eastlake, Reagle, Solo					[Page 13]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   <element name='DigestValue' type='string'>
     <archetype>
       <attribute name='Encoding' type='uri' default="&dsig;/Base64"/ />
     </archetype>
   </element>
   
  3.4 The KeyInfo Element
  
   KeyInfo may contain keys, names, certificates and other public key
   management information (such as inband key distribution or agreement
   data or data supporting any other method.) This specification defines
   a few simple types but applications may place (embed) their own key
   identification and exchange semantics within this element through the
   XML-namespace facility. [XML-namespace]
   
   <element name='KeyInfo' minOccurs='0' maxOccurs='1'>
     <archetype order='seq' content='any'>
       <element name='KeyName' type='string' />
       <element name='KeyValue' type='string' />
       <element name='SubjectName' type='string' />
       <element name='RetrievalMethod' type='string' />
       <element ref='X509Data' type='string'>
       <element ref='PGPData' type='string'>
       <element name='MgmtData' type='string' minOccurs='0'
   maxOccurs='1'/>
     </archetype>
   </element>
   
   KeyInfo is an optional element which enables the recipient(s) to
   obtain the key(s) needed to validate the signature. If omitted, the
   recipient is expected to be able to identify the key based on
   application context information. This element contains one KeyInfo
   data element providing information for the recipient(s). Applications
   may define and use any mechanism they choose through inclusion of
   elements from a different namespace.
   
   Compliant versions implementing KeyInfo MUST implement KeyValue, and
   SHOULD implement RetrievalMethod.
     * KeyName contains an identifier for the key which may be useful to
       the recipient. This may be a name, index, etc.
     * KeyValue contains the actual key(s) used to validate the
       signature. If the key is sent in protected form, the MgmtData
       element should be used. Specific types must be defined for each
       algorithm type (see algorithms).
     * SubjectName contains one or more names for the sender. Forms to be
       supported include a simple name string, encoded DN, email address,
       etc.
     * RetrievalMethod is a URI which may be used to obtain key and/or
       certificate information. The URI should contain the complete
       string for retrieving the key needed for this message (rather than
       a generic URI).
     * X509Data contains an identifier of the key/cert used for
       validation (either an IssuerSerial value, a subject name, or a

Eastlake, Reagle, Solo					[Page 14]
 
Internet Draft		XML-Signature Core Syntax	November 1999


       subjectkeyID) and an optional collection of certificates and
       revocation/status information which may be used by the recipient.
       IssuerSerial contains the encoded issuer name (RFC 2253) along
       with the serial number.
     * PGPData data associated with a PGP key.
     * MgmtData contains in-band key distribution or agreement data.
       Examples may include DH key exchange, RSA key encryption etc.
       
   <element name='X509Data' type='string'>
     <archetype order='seq' content='any'>
       <element name='X509IssuerSerial' type='string'>
         <archetype order='seq' content='elemOnly'>
           <element name='X509Name' type='string' />
           <element name='X509SerialNumber' type='string' />
         </archetype>
       </element>
       <element name='X509SKI' type='string' />
       <element name='X509Name' type='string' />
       <element name='X509Certificate' type='string' />
       <element name='X509CRL' type='string' />
     </archetype>
   </element>
   <element name='PGPData' type='string'>
     <archetype order='seq' content='elemOnly'>
       <element name='PGPKeyID' type='string' />
       <element name='PGPKeyPacket' type='string' />
     </archetype>
   </element>
   <element name='MgmtData' type='string' minOccurs='0' maxOccurs='1'/>
     </archetype>
   </element>
   
   Note:  This section is preliminary. A more detailed version will be
   included in a subsequent version of this specification.
   
  3.5 The Object Element
  
   Object is an optional element which may occur one or more times. When
   present, this element may contain any data. The Object element may
   include optional type, ID, and encoding attributes.
   
   The Object's ID is referenced from the ObjectReference in SignedInfo.
   This element is used for embedded signatures where the object being
   signed is to be included in the signature document. The digest is
   calculated over the entire Object element including start and end
   tags. If the application wishes to exclude the <Object> tags from the
   digest calculation a transform must be used. (Exclusion of the object
   tags may be desired for cases where the signature is intended to
   survive a change between embedded and detached objects or where the
   content of the Object is an encoding of an original binary document
   and it is desired to extract and decode so as to sign the original
   bitwise representation.)
   

Eastlake, Reagle, Solo					[Page 15]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   <element name='Object' minOccurs='0' maxOccurs='*'>
     <archetype content='any'>
       <attribute name='Id' type='ID' />
       <attribute name='Type' type='uri' />
       <attribute name='Encoding' type='uri' />
     </archetype>
   </element>
   
4.0 Additional Signature Syntax

   This section describes the optional to implement Manifest and Package
   elements and describes the handling of XML Processing Instructions and
   Comments.
   
  4.1 The Manifest and Package Elements
  
   The Manifest element provides a list of ObjectReferences. The
   difference from the list in SignedInfo is that it is application
   defined which, if any, of the digests are actually checked against the
   objects referenced and what to do if the object is inaccessible or the
   digest compare fails. If a Manifest is pointed to from SignedInfo, the
   digest over the Manifest itself will be checked by the core signature
   verification behavior. The digests within such a Manifest are checked
   at application discretion. If a Manifest is referenced from another
   Manifest, even the overall digest of this two level deep Manifest
   might not be checked.
   
   A Package has the same syntax as a Manifest but also asserts the
   equality of each of its referenced objects, after any transforms. The
   testing of this equality and action if it fails is also entirely at
   the discretion of the applicaiton.
   
   <element name='Manifest'>
     <archetype>
       <element ref='ObjectReference' minOccurs='1' maxOccurs='*'/>
       <element ref='Object' minOccurs='0' maxOccurs='*'/>
       <attribute name='Id' type='id' />
     </archetype>
   </element>
   
   <element name='Package'>
     <archetype>
       <element ref='ObjectReference' minOccurs='1' maxOccurs='*'/>
       <element ref='Object' minOccurs='0' maxOccurs='*'/>
       <attribute name='Id' type='id' />
     </archetype>
   </element>
   
  4.2 4.2 The SignatureProperties Element
  
   Additional information items concerning the signature or particular
   ObjectReferences can be placed in SignatureProperty elements within a
   SignatureProperties element within an Object. This should be such

Eastlake, Reagle, Solo					[Page 16]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   information as signing time or the serial number of crypto hardware
   used. An additional information concerning data being signed should be
   with that data.
   
   <element name='SignatureProperties' >
     <archetype >
       <element ref='SignatureProperty' minOccurs='1' maxOccurs='*'>
       <attribute name='Target' type='idref' />
     </archetype>
   </element>
   
  4.3 Processing Instructions
  
   TDB - will specify the use, if any, of XML processing instructions by
   this specification and the handling of PIs appearing within elements
   specified in this document.
   
  4.4 4.4 Comments in dsig Elements
  
   TDB - will specify the use, if any, and handling of XML comments
   appearing within elements specified in this document.
   
5.0 Algorithms

   This section identifies algorithms used with the XML digital signature
   standard. Entries contain the identifier to be used in Signature
   elements, a reference to the formal specification, and definitions,
   where applicable, for the representation of keys and the results of
   cryptographic operations.
   
  5.1 Algorithm Identifiers, Parameters, and Implementation Requirements
  
   Algorithms are identified by URIs that appear as an attribute to the
   element that identifies the algorithms role (DigestMethod, Transform,
   SignatureMethod, or CanonicalizationMethod). All algorithms used
   herein take parameters but in many cases they are implicit. For
   example, a SignatureMethod is implicitly given two parameters: the
   keying info and the output of CanonicalizationMethod (or SignedInfo
   directly if there is no CanonicalizationMethod). Explicit additional
   parameters to an algorithm appear as content elements within the
   algorithm role element. Such parameter elements have a description
   element name, which is frequently algorithm specific, and MUST be in
   an algorithm specific namespace.
   
   This specification defines a set of algorithms, their URIs, and
   requirements for implementation. Requirements are specified over
   implementation, not over requirements for signature use. Furthermore,
   the mechanism is extensible, alternative algorithms may be used by
   signature applications.
   
   Algorithm Type Algorithm Requirements Algorithm URI
   Digest
     SHA1 REQUIRED &dsig;/sha1

Eastlake, Reagle, Solo					[Page 17]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   Encoding
     Base64 REQUIRED &dsig;/base64
     QuotedPrintable RECOMMENDED &dsig;/qp
   MAC
     HMAC-SHA1 REQUIRED &dsig;/hmac-sha1
   Signature
     DSAwithSHA1 (DSS) REQUIRED &dsig;/dsa
     RSAwithSHA1 RECOMMENDED &dsig;/rsa-sha1
     ECDSAwithSHA1 OPTIONAL &dsig;/ecdsa
   Canonicalization
     minimal REQUIRED &dsig;/minimal
     XML-Canonicalization RECOMMENDED
   http://www.w3.org/1999/07/WD-xml-c14n-19990729
   Transform
     XSLT RECOMMENDED http://www.w3.org/TR/1999/PR-xslt-19991008
     XPath RECOMMENDED http://www.w3.org/TR/1999/PR-xpath-19991008
     XPointer RECOMMENDED http://www.w3.org/1999/07/WD-xptr-19990709
     Java OPTIONAL urn:ECMA-org:java
   
  5.2 Message Digests
  
   Only one digest algorithm is defined herein. However, it is expected
   that one or more additional strong digest algorithms will come out of
   the US Advanced Encryption Standard effort. Use of MD5 [RFC xxxx] is
   NOT RECOMMENDED because recent advances in cryptography have cast
   doubt on its strength.
   
   Digest algorithms take as an implicit parameter a byte string to be
   digested.
   
    5.2.1 SHA-1
    
   The SHA-1 algorithm  [SHA-1] identifier is &dsig;/sha1. The SHA-1
   algorithm takes no explicit parameters. An example of an SHA-1
   DigestAlg element is
   
   <DigestMethod Algorithm="&dsig;/sha1"/>
   
   An SHA-1 digest is a 160-bit string. The content of the DigestValue
   element shall be the base64 encoding of this bit string viewed as a
   20-octet octet stream. Example: the DigestValue element for the
   message digest
   
   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
   
   from Appendix A of the SHA-1 standard would be
   
   <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>
   
  5.3 Message Authentication Codes
  
   MAC algorithms take two implicit parameters, their keying material
   determined from KeyInfo and the byte stream output by

Eastlake, Reagle, Solo					[Page 18]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. MACs and signature algorithms are
   syntactically identical but a MAC implies a shared secret key.
   
    5.3.1 HMAC
    
   The HMAC algorithm [HMAC] identifiers are &dsig;/hmac-sha1. The HMAC
   algorithm takes the truncation length in bits as a parameter
   (parameter identifier urn:ietf-org:hmac-outputlength). An example of
   an HMAC SignatureMethod element:
   
   <SignatureMethod Algorithm="&dsig;/hmac-sha1">
     <hmac-outputlength xmlns="&dsig;/hmac-sha1">
        128
     </hmac-outputlength>
   </SignatureMethod>
   
   The output of the HMAC algorithm is ultimately the output (possibly
   truncated) of the chosen digest algorithm. This value shall be base64
   encoded in the same straightforward fashion as the output of the
   digest algorithms. Example: the SignatureValue element for the
   HMAC-MD5 digest
   
   9294727A 3638BB1C 13F48EF8 158BFC9D
   
   from the test vectors in [RFC 2104] would be
   
   <SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>
   
  5.4 Signature Algorithms
  
   Signature algorithms take two implicit parameters, their keying
   material determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. Signature and MAC algorithms are syntactically
   identical but a signature implies public key cryptography.
   
    5.4.1 DSA
    
   The DSA algorithm [DSA] identifier is &dsig;/dsa. The DSA algorithm
   takes no explicit parameters. An example of a DSA SignatureMethod
   element is
   
   <SignatureMethod Algorithm="&dsig;/dsa"/>
   
   The output of the DSA algorithm consists of a pair of integers usually
   referred by the pair (r, s). The signature value shall consist of the
   base64 encoding of the concatenation of two octet-streams that
   respectively result from the octet-encoding of the values r and s.
   Integer to octet-stream conversion shall be done according to the
   I2OSP operation defined in the PKCS #1 specification with a k
   parameter equal to 20. Example: the SignatureValue element for a DSA
   signature (r, s) with values specified in hexadecimal

Eastlake, Reagle, Solo					[Page 19]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   
   r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0
   s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8
   
   from the example in Appendix 5 of the DSS standard would be
   
   <SignatureValue
   >i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==</SignatureVa
   lue
   >
   
   DSA key values have the following set of fields: P, Q, G and Y are
   mandatory when appearing as a key value, J, seed and pgenCounter are
   optional but SHOULD be present. (The seed and pgenCounter fields MUST
   both either appear or be absent). All parameters are encoded as base64
   values.
   
   <!ELEMENT DssKeyValue (P, Q, G, Y, J?, (seed, pgenCounter)?) >
   <!-- Each of these fields consists a CDATA where the data is base64
   encoded -->
   
    5.4.2 RSA
    
   The expression "RSA algorithm" as used in this document refers to the
   RSASSA-PKCS1-v1_5 algorithm described in RFC 2437  [RSA].
   
   The RSA algorithm identifiers are &dsig;/rsa-sha1 and
   urn:rsasdi-com:rsa-md5. The RSA algorithm takes no parameters. An
   example of an RSA SignatureMethod element is
   
   <SignatureMethod Algorithm="&dsig;/rsa-sha1"/>
   
   The output of the RSA algorithm is an octet string. The SignatureValue
   content for an RSA signature shall be the base64 encoding of this
   octet string. Example: TBD
   
   RSA key values have two fields: Modulus and Exponent.
   
   <!ELEMENT RSAKeyValue ( Modulus, Exponent ) > <!-- Each field contains
   a CDATA which is the value for that item base64 encoded -->
   
    5.4.3 ECDSA
    
   The expression ECDSA  [ECDSA] as used in this document refers to the
   signature algorithms specified in ANSI X9.62.  Additional details are
   to be provided.
   
  5.5 5.5 Canonicalization Algorithms
  
    5.5.1 Null Canonicalization
    
   Null canonicalization, i.e., no modification whatsoever, can be
   achieved for signed data by simply not putting any canonicalization in

Eastlake, Reagle, Solo					[Page 20]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   the Transforms element (omitting it entirely if no other tranforms are
   needed) for a data object or omitting CanonicalizationMethod for
   SignedInfo.
   
    5.5.2 Minimal Canonicalization
    
   The algorithm identifier for the minimal canonicalization is
   &dsig;/minimal. An example of a minimal canonicalization element is
   
   <CanonicalizationMethod Algorithm="&dsig;/minimal"/>
   
   The minimal canonicalization algorithm:
     * converts the character encoding to UTF-8, removing the encoding
       pseudo-attribute
     * normalizes line endings
       
   This algorithm is only applicable to XML resources.
   
    5.5.3 Canonical XML
    
   The algorithm identifier for XML canonicalization is
   http://www.w3.org/1999/07/WD-xml-c14n-19990729. An example of an XML
   canonicalization element is
   
   <CanonicalizationMethod
   Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
   
   See the Canonical XML specification.
   
  5.6 Transform Algorithms
  
   A Transform algorithm has three implicit parameters. The first is the
   byte stream from the ObjectReference URI/IDREF or as the output of an
   earlier Transform. The second and third are the optional MimeType and
   Charset attributes that can be specified on the Transform element.
   
   Application developers are strongly encouraged to support all
   transforms listed in this section as RECOMMENDED unless the
   application environment has severe resource constraints that would
   make such support impractical. The working group goal is to maximize
   application interoperability on XML signatures, and the working group
   expects ubiquitous availability of software to support these
   transforms that can be incorporated into applications without
   extensive development.
   
    5.6.1 Canonicalization
    
   Any canonicalization algorithm that can be used for
   CanonicalizationMethod can be used as a Transform.
   
    5.6.2 Base-64 and Quoted-Printable Decoding
    
   The Algorithm values for the base 64 and quoted-printable decoding

Eastlake, Reagle, Solo					[Page 21]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   transforms [RFC2045] are &dsig;/base64 and &dsig;/qp.
   
   The base-64 Transform element has no content. The input (from the
   URI/IDREF or from the previous Transform) is base-64 decoded by this
   algorithm. This transform is useful if an application needs to sign
   the raw data associated with base-64 encoded content of an element.
   
    5.6.3 XPath Filtering
    
   The Algorithm value for the XPath filtering transform is
   "http://www.w3.org/TR/1999/PR-xpath-19991008"
   
   The Transform element content MUST conform to the XML Path Language
   (XPath) syntax.
   
   XPath assumes that an XML processor has processed the input resource.
   So, for example, entity reference expansion, normalization of
   linefeeds and attribute values are normalized, and CDATA section
   replacement are expected. As well, XPath joins all consecutive text
   characters into a single text nodes.
   
   The input resource MUST be a well-formed XML document. The result of
   applying the XPath to the input resource MUST be a node-set (as
   defined in XPath). The output of this transform is a new XML document
   with the following characteristics:
    1. The output document has the XML declaration of the input resource
       (see rule 23 XMLDecl in XML specification). If the encoding is
       UTF-16, the output document has the same byte order mark as the
       input resource.
    2. The output document contains the nodes in the node-set identified
       by the XPath, and excludes the nodes of the input resource that
       are not not in the node-set identified by the XPath.
    3. The nodes in the output document appear in the document order (as
       defined in XPath) of the input resource.
    4. The output document has all of the input resource's entity
       references expanded, except that characters corresponding to
       illegal XML are reencoded as character references (XML rule 66)
       except the ampersand and less than symbol, which are encoded using
       &amp; and &lt;, respectively.
    5. Attribute values are normalized in accordance with the rules for a
       validating XML processor (even if the implementation did not use a
       validating XML processor to parse the input resource).
       
   It is RECOMMENDED that the XPath be constructed such that the result
   of this operation is a well-formed XML document. This should be the
   case if root element of the input resource is included by the XPath
   (even if a number of its descendant elements and attributes are
   omitted by the XPath).
   
    5.6.4 XPointer Filtering
    
   The Algorithm value for the XPointer filtering transform is
   "http://www.w3.org/1999/07/WD-xptr-19990709".

Eastlake, Reagle, Solo					[Page 22]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   
   The Transform element content MUST conform to the XML Pointer Language
   (XPointer) syntax.
   
   The processing rules for XPointer filtering are identical to those for
   XPath filtering (stated above), except that the additional
   functionality offered by XPointer can be utilized in constructing the
   output node-set.
   
   The XPointer filter is particularly important if the input resource is
   processed by a validating XML processor since the XPointer barename
   shortcut could then be used to implement the well-known fragment
   identification by ID attribute.
   
   NOTE: In application environments with severe resource limitations,
   applications MAY constrain XPointer support to barename processing and
   also to determination of the ID attribute by means other than a
   validating XML processor. In fact, the use of an XML processor for
   barename resolution is OPTIONAL. However, the output expectations of
   this transform MUST be supported by the application.
   
    5.6.5 XSLT Transform
    
   The Algorithm value for the XSLT transform is
   "http://www.w3.org/TR/1999/PR-xslt-19991008"
   
   The Transform element content MUST conform to the XSL Transforms
   (XSLT) language syntax.
   
   The processing rules for the XSLT transform are stated in the XSLT
   specification.
   
    5.6.6 Java Transform
    
   The Algorithm value for the Java transform is urn:ECMA-org:java.
   
   Details to be determined.
   
   Although the Algorithm attribute of a Transform can take
   application-specific values, having a Java transform seems to be the
   most reasonable way to allow application-specific transforms that can
   be processed outside of the application domain.
   
6.0 Processing rules

   These sections describe the operations to be performed as part of
   signature generation and validation. The description is of a logical
   behavior and does not specify an order of execution, nor specify
   discrete steps.
   
  6.1 Generation
  
    1. apply Transforms determined by application to each object being

Eastlake, Reagle, Solo					[Page 23]
 
Internet Draft		XML-Signature Core Syntax	November 1999


       signed.
    2. calculate digest over each transformed object (including start and
       end tags)
    3. create ObjectReference element(s) including location of object,
       digest, digest algorithm, and transform elements, if required.
    4. create SignedInfo element with SignatureMethod,
       CanonicalizationMethod if required, and ObjectReference(s).
    5. canonicalize and calculate signature over SignedInfo based on
       algorithms in step 4.
    6. construct signature document with SignedInfo, Object (s) (if
       desired, encoding may be different than that used for signing),
       KeyInfo (if required), and SignatureValue.
       
  6.2 Signature Validation
  
    1. locate object and apply Transforms to the specified resource based
       on each ObjectReference(s) in the SignedInfo element. Each
       transform is applied in order from left to right to the object
       with the output of each transform being the input to the next.
    2. calculate digest over each transformed signed object(s) (including
       start and end tags) based on the algorithm in ObjectReference(s).
    3. compare value against DigestValue in SignedInfo for each reference
       (if any mismatch, validation fails).
    4. canonicalize the SignedInfo element based on the
       CanonicalizationMethod, if any, in SignedInfo.
    5. obtain the validation keying info from KeyInfo or externally.
    6. validate the SignatureValue based on the SignatureMethod in the
       SignedInfo element, the key obtained in step 5, and the results of
       step 4. - Digest calculation is performed over the SignedInfo
       element including start and end tags.
       
   Any processing beyond cryptographic validation (e.g. certificate
   validation, applicability decisions, time related processing) is
   outside the scope of this specification.
   
7.0 Security Considerations

   The XML digital signature standard provides a very flexible mechanism.
   In designing a system to make use of it, due consideration should be
   given to the threat model being defended against and to the factors
   covered in the subsections below.
   
  7.1 Only What is Signed is Secure
  
   The flexible Transforms mechanism, including canonicalization and
   explicit filtering and extraction, permit securing only a subset of
   data in an object. This is good for many applications where a limited
   portion of an object must change after the signature or different
   signatures secure different parts or the application modifies aspects
   of the object that are not significant and can be omitted from
   signature coverage or the like. Keep in mind that whenever this is
   done, those aspects that are not signed can be arbitrarily modified
   and the signature will still validate.

Eastlake, Reagle, Solo					[Page 24]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   
  7.2 Only What is "Seen" Should be Signed
  
   If signing is intended to convey the judgment or consent of an
   automated mechanism or person concerning some information, then it is
   normally necessary to secure as exactly as practical the information
   that was presented to that mechanism or person. Note that this can be
   accomplished by literally signing what was presented, for example the
   screen images shown a user. However, this may result in data which it
   is difficult for subsequent software to manipulate. It can be
   effective instead to secure the full data along with whatever filters,
   style sheets, or the like were used to control the part of the
   information that was presented.
   
  7.3 Check the Security Model
  
   This standard specifies public key signatures and secret key keyed
   hash authentication codes. These have substantially different security
   models. Furthermore, it permits user specified additions which may
   have other models.
   
   With public key signatures, any number of parties can hold the public
   key and verify signatures while only the parties with the secret key
   can create signatures. The number of holders of the secret key should
   be minimized and preferably be one. Confidence by verifiers in the
   public key they are using and its binding to the entity or
   capabilities represented by the corresponding secret key is an
   important issue, usually addressed by certificate or on line authority
   systems.
   
   Keyed hash authentication codes, based on secret keys, are typically
   much more efficient in terms of the computational effort required but
   have the characteristic that all verifiers need to have possession of
   the same key as the signer. Thus any verifier can forge signatures.
   
   This standard permits user provided signature algorithms and keying
   information designators. Such user provided algorithms may have
   further different security models. For example, methods involving
   biometrics usually depend on a "key" which is a physical
   characteristic of the user and thus can not be changed the way public
   or secret keys can be and may have other security model differences.
   
  7.4 Algorithms, Key Lengths, Etc.
  
   The strength of a particular signature depends on all links in the
   security chain. This includes the signature and digest algorithms
   used, the strength of the key generation [RFC 1750] and the size of
   the key, the security of key and certificate authentication and
   distribution mechanisms, protection of all cryptographic processing
   from hostile observation and tampering, etc. The security of an
   overall system would also depend on the security and integrity of its
   operating procedures, its personnel, and on the administrative
   enforcement of those procedures. The factors listed in this paragraph,

Eastlake, Reagle, Solo					[Page 25]
 
Internet Draft		XML-Signature Core Syntax	November 1999


   while critical to the overall security of a system, are mostly beyond
   the scope of this document.
   
8.0 Example syntax

   <Signature xmlns="http://www.w3.org/1999/11/xmldsig-core">
     <SignedInfo ID="5">
       <CanonicalizationMethod
        Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729"/>
       <SignatureMethod Algorithm="&dsig;/dsa"/>
       <ObjectReference URI="http://www.mypage.com">
         <Transforms>
            <Transform Algorithm="&dsig;/null">
            <Encoding Algorithm="&dsig;/base64"/>
         </Transforms>
         <DigestMethod Algorithm="&dsig;/sha1"/>
         <DigestValue>a23bcd43</DigestValue>
       </ObjectReference>
       <ObjectReference IDREF="timestamp"
          Type="&dsig;/signatureattributes">
         <Transforms>
            <CanonicalizationMethod name="http://..."/>
         </Transforms>
         <DigestMethod Algorithm="&dsig;/sha1"/>
         <DigestValue>a53uud43</DigestValue>
       </ObjectReference>
     </SignedInfo>
     <SignatureValue>dd2323dd</SignatureValue>
     <Object ID="timestamp"
      type="&dsig;/SignatureAttributes" >
       <timestamp about="5"
        xmlns="http://www.ietf.org/rfcXXXX.txt">
         <date>19990908</date>
         <time>14:34:34:34</time>
       </timestamp>
     </Object>
     <KeyInfo>
        <keyname>Solo</keyname>
     </KeyInfo>
   </Signature>
   
9.0 Schema

   [TBD: xmldsig-core-schema-19991117.xml]
   
10 Definitions

   [needs work]
   
   Authentication, Message
          ?
          
   Authentication, Signer

Eastlake, Reagle, Solo					[Page 26]
 
Internet Draft		XML-Signature Core Syntax	November 1999


          ?
          
   Data
          ?
          
   Object
          An XML element defined by this specification for embedding
          resources within a signature.
          
   Resource
          "A resource can be anything that has identity." [URI]
          
   Validation, Resource
          When the value of hash over the transformed content yielded
          from the dereferenced URI matches the DigetsValue in
          SignedInfo.
          
   Validation, Signature
          When the SignatureValue matches the result of processing
          SignedInfo with  CanonicalizationMethod and SignatureMethod as
          specified in º6.2, including the resource validation of
          SignedInfo ObjectReferences.
          
   Validation, Trust
          When the application determines that the semantics associated
          with the signature are valid. For example, the validation of
          time stamps or confirming the integrity of the signer key.
          
11 Other Useful Types (normative)

   We define the following types for use in identifying XML resources
   that include Signture semantics.
   
   http://www.w3.org/1999/11/xmldsig-core/SignatureProperties
          designates that the referenced resource is a statement about
          the referring signature.
          
   http://www.w3.org/1999/11/xmldsig-core/Manifest
          designates that the referenced resource is a collection of
          other resources.
          
   http://www.w3.org/1999/11/xmldsig-core/Package
          designates that the referenced resources is a collection of
          other resources and the creator of that collection asserts that
          the specified resources, when transformed as specified, yield
          the same exact content.
          
12 References

   DOMHASH
          Internet Draft. Digest Values for DOM (DOMHASH)
          http://search.ietf.org/internet-drafts/draft-hiroshi-dom-hash-0
          1.txt .

Eastlake, Reagle, Solo					[Page 27]
 
Internet Draft		XML-Signature Core Syntax	November 1999


          
   DSS
          FIPS PUB 186-1. Digital Signature Standard (DSS). U.S.
          Department of Commerce/National Institute of Standards and
          Technology.
          http://www.ietf.org/rfc/rfc2104.txt
          
   ECSDA
          ?ANSI X9.62
          
   HMAC
          RFC 2104. HMAC: Keyed-Hashing for Message Authentication. H.
          Krawczyk, M. Bellare, R. Canetti. INFORMATIONAL.
          
   MD5
          RFC 1321. The MD5 Message-Digest Algorithm. R. Rivest.
          INFORMATIONAL.
          http://www.ietf.org/rfc/rfc1321.txt
          
   RDF
          RDF Schema
          http://www.w3.org/TR/1999/PR-rdf-schema-19990303
          RDF Model and Syntax
          http://www.w3.org/TR/1999/REC-rdf-syntax-19990222
          
   RFC1750
          RFC1750 -- Randomness Recommendations for Security.
          http://www.ietf.org/rfc/rfc1750.txt
          
   RFC2045
          RFC 2045. Multipurpose Internet Mail Extensions (MIME) Part
          One: Format of Internet Message Bodies. N. Freed & N.
          Borenstein. DRAFT STANDARD.
          http://www.ietf.org/rfc/rfc2045.txt
          
   RFC2119
          RFC2119 -- Key words for use in RFCs to Indicate Requirement
          Levels.
          http://www.ietf.org/rfc/rfc2119.txt
          
   RSA
          RFC 2437. PKCS #1: RSA Cryptography Specifications Version 2.0.
          B. Kaliski, J. Staddon. INFORMATIONAL.
          http://www.ietf.org/rfc/rfc2432.txt
          
   SHA-1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          http://csrc.nist.gov/fips/fip180-1.pdf
          
   URI
          RFC2396 - Uniform Resource Identifiers (URI): Generic Syntax
          http://www.ietf.org/rfc/rfc2396.txt

Eastlake, Reagle, Solo					[Page 28]
 
Internet Draft		XML-Signature Core Syntax	November 1999


          
   URL
          RFC1738. Uniform Resource Locators (URL). Berners-Lee, T.,
          Masinter, L., and M. McCahill . December 1994.
          http://www.ietf.org/rfc/rfc1738.txt
          
   URN
          RFC 2141. URN Syntax. R. Moats. PROPOSED STANDARD.
          ftp://ftp.isi.edu/in-notes/rfc2141.txt
          RFC 2611. URN Namespace Definition Mechanisms. L. Daigle, D.
          van Gulik, R. Iannella, P. Falstrom. BEST CURRENT PRACTICE.
          ftp://ftp.isi.edu/in-notes/rfc2611.txt
          
   XLink
          XML Linking Language
          http://www.w3.org/1999/07/WD-xlink-19990726
          
   XML
          Extensible Markup Language (XML) Recommendation.
          http://www.w3.org/TR/1998/REC-xml-19980210
          
   XML-Canonicalization
          Canonical XML. W3C Working Draft
          http://www.w3.org/1999/07/WD-xml-c14n-19990729
          
   XML-namespace
          Namespaces in XML
          http://www.w3.org/TR/1999/REC-xml-names-19990114
          
   XPath
          XML Path Language (XPath)Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xpath-19991008
          
   XPointer
          XML Pointer Language (XPointer). W3C Working Draft.
          http://www.w3.org/1999/07/WD-xptr-19990709
          
   XML-schema
          XML Schema Part 1: Structures
          http://www.w3.org/TR/1999/WD-xmlschema-1-19991105/
          XML Schema Part 2: Datatypes
          http://www.w3.org/TR/1999/WD-xmlschema-2-19991105/
          
   XML-Signature-RD
          XML-Signature Requirements
          http://www.w3.org/1999/08/WD-xmldsig-requirements-990820
          
   XSL
          Extensible Stylesheet Language (XSL) W3C Working Draft
          http://www.w3.org/TR/1999/WD-xsl-19990421
          
   XSLT

Eastlake, Reagle, Solo					[Page 29]
 
Internet Draft		XML-Signature Core Syntax	November 1999


          XSL Transforms (XSLT) Version 1.0. W3C Proposed Recommendation
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   WebData
          Web Architecture: Describing and Exchanging Data.
          http://www.w3.org/1999/04/WebData
          
   
          
13.0 Acknowledgements (non-normative)

     * Milton Anderson, FSTC
     * Mark Bartel, JetForm Corporation (Author)
     * John Boyer, UWI.com (Author)
     * Richard Brown, Globeset
     * Donald Eastlake 3rd, IBM (Chair, Editor)
     * Barb Fox, Microsoft (Author)
     * Phillip Hallam-Baker, VeriSign Inc
     * Richard Himes, US Courts
     * Joseph Reagle, W3C (Chair, Editor)
     * Ed Simon , Entrust Technologies Inc.
     * Chris Smithies, PenOp
     * David Solo, Citigroup (Editor)
     * Winchel Todd Vincent III, GSU
     * Greg Whitehead, Signio Inc.
       
14.0 Open Issues (non-normative)

    1. More detail for KeyInfo types, based on IETF'46, we need proposals
       for the actual XML'ized algorithm parameters.
    2. Make sure we are consistent with respect to types, algorithm IDs,
       URIs, etc.
    3. The signature data structures specified in this document are not
       yet associated with a data model.



















Eastlake, Reagle, Solo					[Page 30]


