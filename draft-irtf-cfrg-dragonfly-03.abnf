Z = scalar-op(x, Y) = x*Y

Z = element-op(X, Y) = X + Y

Y = scalar-op(1, Y)

Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1

Z = scalar-op(x, Y) = Y^x mod p

Z = element-op(X, Y) = (X * Y) mod p

stretch = KDF-n(k, label)

base = H((max(Alice,Bob) | min(Alice,Bob) | password | counter)

n = len(p) + 64

temp = KDF-n(base, "Dragonfly Hunting and Pecking")

seed = (temp mod (p - 1)) + 1

found = 0
counter = 1
n = len(p) + 64
base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)
temp = KDF-n(base, "Dragonfly Hunting And Pecking")
seed = (temp mod (p - 1)) + 1
x = seed
save = base
found = 1
counter = counter + 1
y = sqrt(x^3 + ax + b)
PE = (x,y)
PE = (x,p-y)
qr = random() mod p
qnr = random() mod p
r = (random() mod (p - 1)) + 1
num = (val * r * r) mod p
num = (num * qr) mod p
num = (num * qnr) mod p
found = 0
counter = 1
n = len(p) + 64
base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)
temp = KDF-n(seed, "Dragonfly Hunting And Pecking")
seed = (temp mod (p - 1)) + 1
temp = seed ^ ((p-1)/q) mod p
PE = temp
found = 1
counter = counter + 1
scalar = (private + mask) modulo q

Element = inverse(scalar-op(mask, PE))

ss = F(scalar-op(private,
                          element-op(peer-Element,
                                     scalar-op(peer-scalar, PE))))

confirm = H(kck | scalar | peer-scalar |
                              Element | Peer-Element)

