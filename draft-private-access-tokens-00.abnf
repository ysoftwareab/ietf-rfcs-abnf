issuer-key=456...

   Upon receipt of this challenge, a Client uses the message and keys in
   the Issuance protocol (see Section 5).  If the TokenChallenge has a
   version field the Client does not recognize or support, it MUST NOT
   parse or respond to the challenge.  This document defines version 1,
   which indicates use of private tokens based on RSA Blind Signatures
   [BLINDSIG], and determines the rest of the structure contents.

   Note that it is possible for the WWW-Authenticate header to include
   multiple challenges, in order to allow the Client to fetch a batch of
   multiple tokens for future use.

   For example, the WWW-Authenticate header could look like this:

issuer-key=456..., PrivateAccessToken challenge=def..., token-key=234...,
issuer-key=567...

Sec-Token-Origin = sf-binary

Sec-Token-Client = sf-binary
Sec-Token-Nonce = sf-binary

Sec-Token-Count = sf-integer

blind = RandomScalar()
blind_key = blind * CLIENT_SECRET
blind_generator = blind * Generator()
key_proof = SchnorrProof(CLIENT_SECRET, blind_key, blind_generator)

mapping_nonce = SerializeScalar(blind)
mapping_key = SerializeElement(blind_key)
mapping_generator = SerializeElement(blind_generator)
mapping_proof = SerializeProof(key_proof)

accept = message/access-token-response
cache-control = no-cache, no-store
content-type = message/access-token-request
content-length = 512
sec-token-origin = ANON_ORIGIN_ID
sec-token-client = CLIENT_KEY
sec-token-nonce = mapping_nonce

accept = message/access-token-response
cache-control = no-cache, no-store
content-type = message/access-token-request
content-length = 512
sec-token-count = 3

valid = SchnorrVerify(mapping_generator, mapping_key, mapping_proof)

mapping_input = DeserializeElement(AccessTokenRequest.mapping_key)
index = ORIGIN_SECRET * mapping_input
mapping_index = SerializeElement(index)

blind_sig = rsabssa_blind_sign(skP, AccessTokenRequest.blinded_req)
content-type = message/access-token-response
content-length = 512
sec-token-origin = mapping_index

index = DeserializeElement(mapping_index)
nonce = DeserializeScalar(mapping_nonce)
ANON_ISSUER_ORIGIN_ID = (nonce^(-1)) * index

sig = rsabssa_finalize(ORIGIN_TOKEN_KEY, nonce, blind_sig, blind_inv)

aad = concat(encode(1, keyID),
                encode(2, kemID),
                encode(2, kdfID),
                encode(2, aeadID),
                encode(1, version),
                encode(Ne, mapping_generator),
                encode(Ne, mapping_key),
                encode(Np, mapping_proof),
                encode(1, token_key_id),
                encode(Nk, blinded_req),
                encode(32, name_key_id))
ct = context.Seal(aad, origin_name)
encrypted_origin_name = concat(enc, ct)

aad = concat(encode(1, keyID),
                encode(2, kemID),
                encode(2, kdfID),
                encode(2, aeadID),
                encode(1, version),
                encode(Ne, mapping_generator),
                encode(Ne, mapping_key),
                encode(Np, mapping_proof),
                encode(1, token_key_id),
                encode(Nk, blinded_req),
                encode(32, name_key_id))
r = RandomScalar()
u = r * base
c = HashToScalar(SerializeElement(base) ||
                    SerializeElement(target) ||
                    SerializeElement(mask),
dst = "PrivateAccessTokensProof")
z = r + (c * secret)

c = HashToScalar(SerializeElement(base) ||
                    SerializeElement(target) ||
                    SerializeElement(mask),
dst = "PrivateAccessTokensProof")
expected_left = base * z
expected_right = u + (target * c)

