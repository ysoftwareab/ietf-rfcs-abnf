<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Rx Security Object Providing Cleartext Peer Identity Assertions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Rx Security Object Providing Cleartext Peer Identity Assertions">
<meta name="keywords" content="rx">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">N/A</td><td class="header">T. Keiser</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Sine Nomine</td></tr>
<tr><td class="header">Intended status: BCP</td><td class="header">April 17, 2010</td></tr>
<tr><td class="header">Expires: October 19, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Rx Security Object Providing Cleartext Peer Identity Assertions<br />draft-tkeiser-rxrpc-sec-clear-02</h1>

<h3>Abstract</h3>

<p>
         RxRPC was originally designed as the remote procedure call layer for
         AFS-3.  Today there are a number of anonymous RxRPC applications which 
         require identity assertions in order to ensure that the desired peer 
         receives and processes a procedure call.  This memo defines a replacement 
         for the rxnull security class which provides a means for mutually agreeing
         upon who is communicating, without incurring cryptographic overhead.
         It should be noted that, much like rxnull, this security object is not
         suitable for use in a distributed environment due to its inability to
         provide integrity protection.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on October 19, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Existing Security Mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.1.1.</a>&nbsp;
rxnull<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.1.2.</a>&nbsp;
rxkad<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:mh">1.2.</a>&nbsp;
Multi-homed Host Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.3.</a>&nbsp;
Motivations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.4.</a>&nbsp;
Goals<br />
<a href="#anchor7">2.</a>&nbsp;
Conventions<br />
<a href="#anchor8">3.</a>&nbsp;
Overview of Rx RPC<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.1.</a>&nbsp;
Packet Mux<br />
<a href="#anchor10">4.</a>&nbsp;
Presenting Problems<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.1.</a>&nbsp;
Node Renumbering<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.</a>&nbsp;
Epoch ID Multi-Homing Bit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.3.</a>&nbsp;
Processing of Non-Idempotent Calls<br />
<a href="#anchor14">5.</a>&nbsp;
Rx Clear Security Class<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:constants">5.1.</a>&nbsp;
Constants<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:header">5.2.</a>&nbsp;
Security Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.3.</a>&nbsp;
Data Packet Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.4.</a>&nbsp;
Abort Packet Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.4.1.</a>&nbsp;
RXCL_ERR_UNKNOWN_VERS<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.4.2.</a>&nbsp;
RXCL_ERR_UNKNOWN_ID_TYPE<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.4.3.</a>&nbsp;
RXCL_ERR_WRONG_PEER<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.4.4.</a>&nbsp;
RXCL_ERR_XCID_UNUSPP<br />
<a href="#anchor21">6.</a>&nbsp;
Multi-Home Behavior<br />
<a href="#Acknowledgements">7.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">8.</a>&nbsp;
IANA Considerations<br />
<a href="#AFS_registrar">9.</a>&nbsp;
AFS Assigned Numbers Registrar Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">9.1.</a>&nbsp;
Definition of new registries<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">9.1.1.</a>&nbsp;
clh_version<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">9.1.2.</a>&nbsp;
clh_id_type<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">9.1.3.</a>&nbsp;
clh_flags<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">9.2.</a>&nbsp;
Allocation of new values<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">9.2.1.</a>&nbsp;
RxClear security index<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">9.2.2.</a>&nbsp;
Rx error codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">9.2.3.</a>&nbsp;
Rx Clear Security Header Version<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">9.2.4.</a>&nbsp;
Endpoint Identifier Type<br />
<a href="#Security">10.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">10.1.</a>&nbsp;
call injection<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
         RxRPC <a class='info' href='#draft-zeldovich-rx-spec'>[draft&#8209;zeldovich&#8209;rx&#8209;spec]<span> (</span><span class='info'>Zeldovich, N. and M. Meffie, &ldquo;Rx protocol (work in progress),&rdquo; November&nbsp;2009.</span><span>)</span></a> is a remote procedure call (RPC) protocol
         that evolved from earlier prototypes developed as part of the Andrew 
         Project at Carnegie Mellon University <a class='info' href='#VICE1'>[VICE1]<span> (</span><span class='info'>Satyanarayanan, M., Howard, J., Nichols, D., Sidebotham, R., Spector, A., and M. West, &ldquo;The ITC Distributed File System: Principles and Design,&rdquo; December&nbsp;1985.</span><span>)</span></a>
         <a class='info' href='#CMU-ITC-85-003'>[CMU&#8209;ITC&#8209;85&#8209;003]<span> (</span><span class='info'>Satyanarayanan, M., &ldquo;A Large-Parameter Remote Procedure Call Mechanism in Unix,&rdquo; 1985.</span><span>)</span></a>
         <a class='info' href='#CMU-ITC-84-011'>[CMU&#8209;ITC&#8209;84&#8209;011]<span> (</span><span class='info'>Satyanarayanan, M., &ldquo;RPC User Manual,&rdquo; January&nbsp;1985.</span><span>)</span></a> 
         <a class='info' href='#CMU-ITC-85-038'>[CMU&#8209;ITC&#8209;85&#8209;038]<span> (</span><span class='info'>Satyanarayanan, M., &ldquo;RPC2 User Manual,&rdquo; 1985.</span><span>)</span></a>.
         Its primary, although notably not its only, usage is by the AFS-3 
         distributed file system
         <a class='info' href='#AFS1'>[AFS1]<span> (</span><span class='info'>Howard, J., &ldquo;An Overview of the Andrew File System&quot;,&rdquo; February&nbsp;1988.</span><span>)</span></a> <a class='info' href='#AFS2'>[AFS2]<span> (</span><span class='info'>Howard, J., Kazar, M., Menees, S., Nichols, D., Satyanarayanan, M., Sidebotham, R., and M. West, &ldquo;Scale and Performance in a Distributed File System,&rdquo; February&nbsp;1988.</span><span>)</span></a>.
         Rx provides remote procedure call services over top of multiplexed 
         stateful virtual circuits called "connections".  Individual call sessions
         within the multiplexed circuits are called "channels".  Flow control, delivery
         guarantees, and security are provided at the connection level.  Stream ordering
         is performed at the channel level.  Security in Rx is handled at the connection
         level.  Thus, all calls within a given multiplexed connection must be associated
         with the same security object, which in all current use cases means the same
         security context.  Security mechanisms in Rx are pluggable --
         the Rx packet header contains a single octet field which defines the security
         mechanism to be used.  Rx packet payload encoding is under the control of the
         mutually agreed upon Rx security mechanism.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Existing Security Mechanisms</h3>

<p>
          At present, there are two Rx security mechanisms in wide deployment: rxnull,
          and rxkad.  Additionally, there was a security mechanism called rxvab,
          which was used by early VICE prototypes, never widely deployed, and considered
          to be entirely deprecated.
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.1"></a><h3>1.1.1.&nbsp;
rxnull</h3>

<p>
            As the name implies, rxnull provides 
            no-op security services for anonymous services.  Rxnull does not modify the
            packet payload in any manner.  Absolutely no cryptography is used with
            rxnull; header fields are asserted to be correct.  
          
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.2"></a><h3>1.1.2.&nbsp;
rxkad</h3>

<p>
            Rxkad was originally developed as a kerberos 4-based security
            mechanism implementing three security profiles: header integrity protection, payload
            integrity protection, and payload encryption.  With the advent of Kerberos 5
            <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>, the rxkad
            mechanism was extended to support DES Kerberos 5 tickets.  Rxkad utilizes a spare
            16-bit Rx header field to store a 16-bit cryptographic checksum of a bit-string called
            the packet pseudoheader.  The pseudoheader contains most Rx header fields, as well as
            certain other ancillary pieces of data <a class='info' href='#AFS-RX'>[AFS&#8209;RX]<span> (</span><span class='info'>Zayas, E., &ldquo;AFS-3 Programmer's Reference: Specification for the Rx Remote Procedure Call Facility,&rdquo; August&nbsp;1991.</span><span>)</span></a>.
          
</p>
<a name="sec:mh"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Multi-homed Host Support</h3>

<p>
          During the 1990s Transarc extended the Rx protocol to support multihomed hosts.
          The Transarc design involved redefining the most significant bit of the packet
          header connection identifier field.  Under the new design, the connection ID field
          was split as follows:
        
</p>
<p style='text-align: center'>Rx Header Epoch and Connection ID Fields
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|G|                               E                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             C                             | H |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>
          </p>
<blockquote class="text"><dl>
<dt>G bit: 1 bit</dt>
<dd>
              <br />

              When asserted, the (G)lobal bit indicates that the C field is globally unique.  When not
              asserted, the tuple (IPv4 address, UDP port, E, C) is used to identify an Rx connection.
              However, when multi-homed hosts are involved in a connection, the Global bit causes the
              C field to become globally unique, and thus IP address and port number matching is not
              performed as part of the virtual circuit identification process.
            
</dd>
<dt>E bits: 31 bits (unsigned integer)</dt>
<dd>
              <br />

              The (E)poch field is used to detect peer Rx state resets.  Whenever an Rx protocol stack
              is initialized, an effort should be made to assigned it a different value.  Typically, this
              is done by assigning the current Unix epoch time.
            
</dd>
<dt>C bits: 30 bits (unsigned integer)</dt>
<dd>
              <br />

              The (C)onnection bits are part of the virtual circuit identifier.  As discussed above,
              the G bit controls what other date is used as part of the virtual circuit identifier.
            
</dd>
<dt>H bits: 2 bits (unsigned integer)</dt>
<dd>
              <br />

              The c(H)annel bits are used to multiplex four RPC call channels over a single Rx
              connection.  Each packet is thus associated with a specific channel.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Motivations</h3>

<p>
           IPv4 address renumbering is a frequent occurence in many environments.  Due
           to the stateless nature of the Rx packet multiplexor, it is possible for race
           conditions to occur whereby an RPC call payload is delivered to the wrong peer.
           With the existing Rx security classes, the receiving peer will
           automatically create a new Rx connection, optionally go through a challenge/response
           phase, and then proceed to process the call arguments.  Obviously, mis-delivery of an 
           RPC call can result in incorrect behavior.  For example, in the case of AFS-3,
           mis-delivery can lead to data corruption, loss of cache coherence, and other 
           problematic situations.
        
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Goals</h3>

<p>
           Many high-performance applications based upon Rx RPC cannot tolerate 
           cryptographic overhead.  In order to ensure correctness in the face of
           transport-layer address renumbering, some form of context needs to be 
           established between client and server to permit upper-layer applications 
           to reject processing of remote procedure calls that were misdirected.
           This memo aims to replace rxnull with a minimally-intrusive security object
           that provides a stateful means of detecting address renumbering events
           without introducing cryptographic overhead.
        
</p>
<p>
           Obviously, similar race conditions can occur with the rxkad security object.
           Solving that problem is considered outside the scope of this memo.
        
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conventions</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Overview of Rx RPC</h3>

<p>
        Rx RPC is a remote procedure call mechanism built on top of UDP.  In order to establish
        a stateful call context on top of a stateless datagram protocol, Rx relies upon
        a number of client-asserted header fields to establish a flow-controlled 
        communications channel between peers.  To eliminate the need for context-establishment 
        round-trips, Rx relies upon client assertions to establish a stateful context.
      
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Packet Mux</h3>

<p>
          Rx connection objects are identified by a tuple of packet header fields.  The most
          important control field is the most-significant bit of the epoch header field.  When
          this bit is asserted, the connection object is operating in multi-homing mode, as
          specified in <a class='info' href='#draft-zeldovich-rx-spec'>[draft&#8209;zeldovich&#8209;rx&#8209;spec]<span> (</span><span class='info'>Zeldovich, N. and M. Meffie, &ldquo;Rx protocol (work in progress),&rdquo; November&nbsp;2009.</span><span>)</span></a>.
          In the normal Rx operating mode (with the multi-homing bit set to zero), Rx 
          connections are identified by the following tuple: (host, port, epoch, cid), where
          these elemenets are defined as:

          </p>
<blockquote class="text"><dl>
<dt>host:</dt>
<dd>IPv4 address of peer
</dd>
<dt>port:</dt>
<dd>UDP port of peer
</dd>
<dt>epoch:</dt>
<dd>Rx header epoch field
</dd>
<dt>cid:</dt>
<dd>Rx header cid field (channel ID bits masked to zero)
</dd>
</dl></blockquote><p>

          However, when the multi-homing bit is asserted, the connection identifier tuple becomes:
          (epoch, cid).  Thus, multi-homed Rx connection objects have a shared (epoch, cid) namespace,
          independent of peer address.
        
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Presenting Problems</h3>

<p>
        The design of this Rx security class is motivated by server and client renumbering
        incidents at large AFS-3 deployments.  When a file server is renumbered, there is a several
        hour window until the next VL_GetAddrsU RPC is performed to refresh the file server UUID
        to IPv4 address mappings in the client.  Due to the TTL-based invalidation of stale cached
        mappings, there is a substantial time interval during which RPCs can be delivered to the
        wrong file server, potentially leading to incorrect behavior.
      
</p>
<p>
        Similarly, client renumbering can lead to incorrect behavior due to a loss of cache
        coherence.  The AFS-3 callback mechanism relies upon correct knowledge of client UUID to
        IPv4 address mappings in order to deliver cache invalidation messages to clients.  When
        these mappings become stale due to intervening address renumbering events, advertisement of
        incorrect addresses, NATs, etc. these "call back" remote procedure calls may be delivered to
        the wrong client node.  In some circumstances this can lead to false state of success on the
        file server because an unintended client received, processed, and sent a response of success 
        to the file server.  Due to the success return code, the file server will no longer attempt 
        to deliver the invalidation, and the client to which the call back was supposed to be delivered 
        will continue to operate on stale cached data because it never received the cache invalidation 
        message.
      
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Node Renumbering</h3>

<p>
          When servers are renumbered, one potential outcome is that two or more
          machines running the same service will swap addresses.  In this case, there
          is a possibility for the wrong machine to correctly interpret, and attempt to
          execute, a procedure call.
        
</p>
<p>
          In some cases, execution of an RPC by the wrong endpoint will still result in correct 
          behavior.  However, this is not generally true, where execution by an unintended 
          target could result in undefined, or even dangerous, behavior.  For example, in 
          AFS-3, the existence of shadow clones could result in a situation where an RW shadow 
          clone is updated instead of the canonical RW site registered in the VLDB.
        
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Epoch ID Multi-Homing Bit</h3>

<p>
          When the multi-homing bit is asserted, (connection,epoch) tuples become
          globally unique.  This mode of operation permits clients to contact the
          server on multiple addresses, thus allowing client operating systems to route
          datagrams as desired.  Current implementations of Rx bind the connection to
          the first peer address on which a datagram was received.  Since all reply
          datagrams are sent to the bound peer, connection hijacking becomes impossible.
          Unfortunately, this comes at the expense of handling client renumbering
          events: when the bound peer address becomes unreachable, or is reassigned, 
          the Rx connection enters a simplex state and consequently all call channels
          block until the connection times out.
        
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Processing of Non-Idempotent Calls</h3>

<p>
          Another problematic symptom of Rx connections entering a simplex state involves
          non-idempotent RPCs.  The core problem is that by the time the lack of a reply
          channel is observed, the non-idempotent procedure call has already been executed.
          Rx RPCs are not generally transactional, and thus there is typically no means of
          rolling back the state-changing behavior.  Obviously, this problem is not
          unique to multihomed hosts, but it is another indication of how Rx is lacking
          compared to alternative multi-home aware protocols, such as SCTP <a class='info' href='#RFC4960'>[RFC4960]<span> (</span><span class='info'>Stewart, R., &ldquo;Stream Control Transmission Protocol,&rdquo; September&nbsp;2007.</span><span>)</span></a>.
        
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Rx Clear Security Class</h3>

<p>
        In order to overcome the dangers inherent in assuming stability of transport
        addresses, the Rx Clear security class embeds a security header in all data packets.
        This security header contains application-specific endpoint identifier assertions 
        for both the source and destination.
      
</p>
<p>
        When a datagram is received by the wrong peer, 
        an Rx abort packet will be dispatched notifying the peer of the need to re-bind 
        transport addresses for this connection object.  When such an abort packet is received
        by a client connection, the error will be immediately propagated back to the caller so
        that application-specific logic may be invoked to refresh transport-layer address mappings
        for the intended destination endpoint.  In the server case, this memo standardizes new
        multi-homing Rx connection peer binding semantics which allow for graceful handling of
        client renumbering events.
      
</p>
<a name="sec:constants"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Constants</h3>

<p>
           The Rx Clear security class makes use of several newly defined constants, which are
           defined below:
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>RX_SEC_ID_CLEAR:</dt>
<dd>
              <br />

              An Rx security index will be allocated by the Grand Central Registrar.  As with
              all Rx security indices, this 8 bit integer will uniquely identify the security
              class bound to a given Rx datagram.
            
</dd>
<dt>RXCL_HDR_VERS_1:</dt>
<dd>
              <br />

              Rx Clear security header version 1 will be allocated by the Grand Central
              Registrar.  This version number will correspond to the XDR <a class='info' href='#RFC4506'>[RFC4506]<span> (</span><span class='info'>Eisler, M., &ldquo;XDR: External Data Representation Standard,&rdquo; May&nbsp;2006.</span><span>)</span></a> 
              encoded data structure called rxClear_Header, as specified in <a class='info' href='#sec:header'>Section&nbsp;5.2<span> (</span><span class='info'>Security Header</span><span>)</span></a>.
            
</dd>
<dt>RXCL_ERR_UNKNOWN_VERS:</dt>
<dd>
              <br />

              An Rx error code will be allocated which communicates that this version of
              the Rx Clear security header is unsupported by the peer.  This error code will
              be sent as the user payload of an Rx abort packet.
            
</dd>
<dt>RXCL_ERR_UNKNOWN_ID_TYPE:</dt>
<dd>
              <br />

              An Rx error code will be allocated which communicates that this endpoint
              identifier type is not supported by the peer.  This error code will be sent
              as the user payload of an Rx abort packet.
            
</dd>
<dt>RXCL_ERR_WRONG_PEER:</dt>
<dd>
              <br />

              An Rx error code will be allocated which communicates mis-delivery of an
              Rx Clear-protected datagram to the wrong peer.  This error code will be sent 
              as the user payload of an Rx abort packet.
            
</dd>
<dt>RXCL_ERR_XCID_UNSUPP:</dt>
<dd>
              <br />

              An Rx error code will be allocated which communicates to the peer that this
              node is incapable of supporting the extended connection id field.  This error
              code will be sent as the user payload of an Rx abort packet upon receipt of
              an RxClear header containing a non-zero clh_xcid field by a node which cannot
              support extended connection identifiers.
            
</dd>
<dt>RXCL_EI_TYPE_NULL:</dt>
<dd>
              <br />

              An endpoint identifier type which provides fallback to rxnull-like semantics.
              In other words, the contents of the source and destination endpoint identifiers
              have no meaning (and SHOULD thus be zero octets in length).  In this mode of
              operation, detection of address renumbering is impossible.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="sec:header"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Security Header</h3>

<p>
          In order to communicate expectations to the peer, all data packets travelling over
          an RxClear-protected connection will include an XDR-encoded security header which carries
          identity assertions.  The RxClear mechanism uses a header rather than a challenge-
          response mechanism because the additional round-trips required by the Rx challenge-
          response mechanism were deemed too costly for the typical unauthenticated Rx call 
          workload.
        
</p>
<p>
          The proposed security header is an XDR-encoded structure defined as follows:
        
</p><br /><hr class="insert" />
<a name="rxclear_authenticator"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
struct rxClear_Header {
    u_char clh_version;          /* authenticator version number */
    u_char clh_id_type;          /* how to interpret opaque peer
                                    identifier payloads */
    u_char clh_data_off;         /* data payload offset */
    u_char clh_spares1;          /* MUST be set to zero */
    afs_uint32 clh_data_len;     /* data payload length */
    afs_uint32 clh_trl_off;      /* security trailer offset */
    afs_uint32 clh_flags;        /* miscellaneous control flags */
    afs_uint32 clh_spares2;      /* MUST be set to zero */
    afs_uint32 clh_spares3;      /* MUST be set to zero */
    opaque clh_src_id;           /* assertion of client identity */
    opaque clh_dst_id;           /* assertion of server identity */
};
</pre></div>
<p style='text-align: center'>Rx Clear Security Header
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          This security header will be an XDR-encoded data structure, which will occupy the first octets of the 
          data offset in an Rx packet -- it will start at the offset directly following the Rx packet header.
          The normal packet data will begin at the data offset specified in the clh_data_off field of the security
          header.  
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>clh_version: 8-bits (unsigned integer)</dt>
<dd>
              <br />

              This contains the version of the Rx Clear 
              security object header.  If this version is unknown by the peer, then the 
              connection must be aborted.
            
</dd>
<dt>clh_id_type: 8-bits (unsigned integer)</dt>
<dd>
              <br />

              An 8-bit unsigned integer which identifies the encoding of the XDR opaque
              fields src_id and dst_id.  Values within this 8-bit namespace are allocated 
              by the AFS Assigned Numbers Registrar.
            
</dd>
<dt>clh_data_off: 8-bits (unsigned integer)</dt>
<dd>
              <br />

              This field specifies the beginning of the data 
              payload, in units of octets from the beginning of the Rx packet payload.  
              This field is used by receivers to determine where to begin reading the 
              encapsulated data payload.
            
</dd>
<dt>clh_trl_off: 32-bits (unsigned integer)</dt>
<dd>
              <br />

              This value specifies the offset in octets of 
              the clear security class packet trailer.  A value of zero indicates the 
              absence of a security trailer.
            
</dd>
<dt>clh_flags: 32-bits (unsigned integer)</dt>
<dd>
              <br />

              This is a bitfield whose bits are used as protocol control flags.
              All flag bits whose semantics are not yet standardized MUST be sent as
              zeroes.
            
</dd>
<dt>clh_src_id: XDR opaque</dt>
<dd>
              <br />

              This field contains an application-specific source endpoint identifier.  For example, in the
              case of AFS-3, this will likely be an XDR-encoded node UUID.
            
</dd>
<dt>clh_dst_id: XDR opaque</dt>
<dd>
              <br />

              This field contains an application-specific destination endpoint identifier.  For example, in the
              case of AFS-3, this will likely be a XDR-encoded node UUID.
            
</dd>
<dt>clh_spares1: 8-bits (unsigned integer)</dt>
<dd>
              <br />

              This field is reserved for future use, and MUST
              be set to zero.  Future memos MAY define a standardized use for this field,
              and thus implementors MUST NOT make private use of this field.
            
</dd>
<dt>clh_spares2: 32-bits (unsigned integer)</dt>
<dd>
              <br />

              This field is reserved for future use, and MUST
              be set to zero.  Future memos MAY define a standardized use for this field,
              and thus implementors MUST NOT make private use of this field.
            
</dd>
<dt>clh_spares3: 32-bits (unsigned integer)</dt>
<dd>
              <br />

              This field is reserved for future use, and MUST
              be set to zero.  Future memos MAY define a standardized use for this field,
              and thus implementors MUST NOT make private use of this field.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Data Packet Validation</h3>

<p>
          Upon receipt of a data packet with the security index set to RX_SEC_ID_CLEAR, the node will XDR decode the
          security header, and subsequently validate the security header.  Following XDR decode, the node shall
          first verify that the clh_version field contains a supported version number.  In the event that the node
          does not support this RxClear version, the node will send an Rx abort packet to the peer with error code
          RXCL_ERR_UNKNOWN_VERS.
        
</p>
<p>
          The second step in validation involves the extended connection identifier field, clh_xcid.  If this node
          does not support extended cid, and the clh_xcid field is non-zero, then an abort packet with user payload
          RXCL_ERR_XCID_UNSUPP should be sent to the peer, and the connection should transition to an error state.
        
</p>
<p>
          Next, the application-specific endpoint identifier type specified in clh_id_type field is validated to ensure
          that the application layer can handle this identifier type.  If this endpoint identifier type is not 
          supported by the application layer, then the node will send an Rx abort packet with user payload of 
          RXCL_ERR_UNKNOWN_ID_TYPE, and the connection should transition to an error state.
        
</p>
<p>
          The application layer will then be asked to validate the clh_dst_id field.  If there is a mismatch, an
          abort packet will be sent to the peer with user payload RXCL_ERR_WRONG_PEER, and the Rx connection will then 
          transition into an error state.
        
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Abort Packet Handling</h3>

<p>
          Processing of received Rx Abort packets must be updated to handle the new RXCL_ERR_ error codes.  If such an error
          code is received on a connection with security index other than RX_SEC_ID_CLEAR, then behavior is undefined.
        
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
RXCL_ERR_UNKNOWN_VERS</h3>

<p>
            This error code indicates that the peer is unable to support the version of the RxClear security header sent in
            a packet.  The connection is transitioned into an error state.
          
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
RXCL_ERR_UNKNOWN_ID_TYPE</h3>

<p>
            This error code indicates that the peer is unable to support this application-specific endpoint identifier type.
            The connection is transitioned into an error state.
          
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
RXCL_ERR_WRONG_PEER</h3>

<p>
            This error code indicates that the packet was delivered to the wrong peer.  Behavior in this situation depends on
            several factors.  First, for connections where the epoch multi-homing bit is zero, the connection must be 
            transitioned to an error state.  For multi-homed connections, behavior further depends upon whether this is a
            client connection, or a server connection.  For client connections, the easiest course of action is to set the
            connection to an error state, and allow the client to re-resolve the application-specific endpoint-identifier to
            transport identifier mapping, allocate a new Rx connection, and re-try the call.

            In the case of a multi-homed server connection, the implementation SHOULD make a best-effort try to deliver the 
            call reply data to the correct destination, as this may be a non-idempotent procedure call.  This memo outlines 
            in detail new peer binding semantics for multi-homed Rx connections in another section.  Hence, whenever it is
            possible, the server will not transition a server connection into an error state upon receipt of this message.
            Instead, it SHOULD invalidate the peer currently bound to the connection so that future replies go to a different,
            hopefully correct, transport address.
          
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.4"></a><h3>5.4.4.&nbsp;
RXCL_ERR_XCID_UNUSPP</h3>

<p>
            This error code indicates that the peer is unable to support the extended connection identifier field in the
            RxClear security header.  The connection is transitioned to error state, and the implementation SHOULD mark the
            peer as being incapable of supporting extended connection identifiers so that connections allocated to this peer
            in the future contain a clh_xcid field with value zero.
          
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Multi-Home Behavior</h3>

<p>
        Rx supports multi-homed clients through the assertion of the most-significant bit in the Rx header epoch field.
        When this bit is asserted, a server will accept datagrams into a connection regardless of the source host address
        and port.  However, reply packets are always sent to the first peer address which contacted the server on any given
        (epoch, cid) tuple.  This behavior prevents connection hijacking, at the expense of robust multi-homing support.
      
</p>
<p>
        In order to properly support multi-homing this memo specifies relaxation of the peer binding policies.
        Most importantly, upon receipt of an RXCL_ERR_WRONG_PEER abort packet, an Rx server should
        not transition a server-mode connection to an error state.  Rather, it SHOULD mark the peer currently bound to the Rx
        connection as being incorrect so that responses may be sent to a different peer, as determined upon receipt of the next 
        ping packet.  Although this does open up room for connection hijacking, it does so only for anonymous connections, which
        are otherwise exposed to denial of service attacks.
      
</p>
<p>
        To address the issue of lack of response, new Rx server implementations SHOULD permit re-binding of the peer
        on server-mode connections.  To this end, servers should track liveness of peer addresses on a server connection
        in order to remove a dead peer from a connection.  If an Rx ping comes from an address other than the currently bound
        peer transport address, the Rx implementation MAY try to re-send unacknowledged packets to this other address.  If 
        these re-transmits are correctly aknowledged, the connection may be re-bound to the new peer.
      
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgements</h3>

<p>
        I would like to thank all of the participants at the 2009 Edinburgh AFS hackathon for their input into
        the design of this security mechanism.  Specifically, I would like to thank Jeffrey Altman for suggesting that it
        would be architecturally cleaner to place peer identity assertions into a security header, rather than modifying 
        AFS-3 RPCs to explicitly include application-layer identity assertions as IN parameters.  Special thanks to Randall
        Atkinson for providing useful feedback with regard to the introduction and security considerations sections.
      
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<a name="AFS_registrar"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
AFS Assigned Numbers Registrar Considerations</h3>

<p>
         This memo includes several assigned numbers requests which must
         be considered by the AFS Assigned Numbers Registrar.
      
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Definition of new registries</h3>

<p>
           This memo requests that the AFS Assigned
           Numbers Registrar allocate new registries for three fields in the Rx Clear security 
           header, as described in <a class='info' href='#sec:header'>Section&nbsp;5.2<span> (</span><span class='info'>Security Header</span><span>)</span></a>:
        
</p>
<p>
          </p>
<ul class="text">
<li>clh_version
</li>
<li>clh_id_type
</li>
<li>clh_flags
</li>
</ul><p>
        
</p>
<p>
           Allocations for the following registries are to be processed by the AFS Assigned
           Numbers Regisrar pursuant to the policies dictated in sections 2.3.2 and 2.3.3 of 
           <a class='info' href='#AFS3-STDS-CHARTER'>[AFS3&#8209;STDS&#8209;CHARTER]<span> (</span><span class='info'>Wilkinson, S., &ldquo;Options for AFS Standardisation,&rdquo; September&nbsp;2008.</span><span>)</span></a>.  
        
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1.1"></a><h3>9.1.1.&nbsp;
clh_version</h3>

<p>
              The Rx Clear security class includes a version number in its packet header.  This
              memo requests that the AFS Assigned Numbers Registrar allocate a new registry for
              tracking assigned values for this protocol field.  The unsigned 8-bit namespace
              for this registry shall be divided into three regions as follows:
          
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Range      Policy
-----      ------
0-239      standards
240-254    private use
255        reserved
</pre></div>
<p>
             Standards-track allocation requests for this registry MUST contain the following pieces of information:
          
</p>
<p>
            </p>
<ul class="text">
<li>A reference to an RFC section documenting the XDR definition of the header
</li>
</ul><p>
          
</p>
<p>
             In addition, a standards-track allocation request MAY contain the following optional elements:
          
</p>
<p>
            </p>
<ul class="text">
<li>A reference to an RFC section documenting security considerations for this header type
</li>
<li>A requested version number
</li>
</ul><p>
          
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1.2"></a><h3>9.1.2.&nbsp;
clh_id_type</h3>

<p>
             The Rx Clear security class provides a means of sending opaque application data,
             which is intended to provide a means of transmitting application-specific 
             transport-independent endpoint identifiers.  The 8-bit unsigned namespace for this
             registry shall be divided into three policy regions as follows:
          
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Range      Policy
-----      ------
0-239      standards
240-254    private use
255        reserved
</pre></div>
<p>
             Standards-track allocation requests for this registry MUST contain the following pieces of information:
          
</p>
<p>
            </p>
<ul class="text">
<li>A reference to an RFC section documenting the means of encoding the payload, such as an XDR type definition
</li>
<li>A reference to an RFC section documenting the semantics for this encoding type
</li>
</ul><p>
          
</p>
<p>
             In addition, a standards-track allocation request MAY contain the following optional elements:
          
</p>
<p>
            </p>
<ul class="text">
<li>A reference to an RFC section documenting security considerations for this encoding type
</li>
<li>A requested type identification number
</li>
</ul><p>
          
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1.3"></a><h3>9.1.3.&nbsp;
clh_flags</h3>

<p>
             The Rx Clear security class header contains a 32-bit flags bit vector.  Bits
             within this vector shall be allocated by the AFS Assigned Numbers Registrar.
             This 32-value namespace shall be subdivided into two policy regions as follows:
          
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
Range            Policy
-----            ------
2^0 to 2^27      standards
2^28 to 2^31     private use
</pre></div>
<p>
             Standards-track allocation requests for this registry MUST contain the following pieces of information:
          
</p>
<p>
            </p>
<ul class="text">
<li>A reference to an RFC section documenting the semantics for this flag
</li>
</ul><p>
          
</p>
<p>
             In addition, a standards-track allocation request MAY contain the following optional elements:
          
</p>
<p>
            </p>
<ul class="text">
<li>A reference to an RFC section documenting security considerations for this flag
</li>
<li>A requested bit position
</li>
</ul><p>
          
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Allocation of new values</h3>

<p>
           This memo also makes several allocation requests to the AFS Assigned Numbers Registrar.
        
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.1"></a><h3>9.2.1.&nbsp;
RxClear security index</h3>

<p>
             A new Rx protocol security index must be allocated.  It is anticipated that given
             the small size of the security index namepsace, the allocation will
             only be satisfied after rough consensus is established on the 
             afs3-standardization@openafs.org mailing list.
          
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.2"></a><h3>9.2.2.&nbsp;
Rx error codes</h3>

<p>
             The Rx Clear security class allocates several new Rx error codes for use
             in Rx abort packet payloads.  Given that there are multiple Rx implementations,
             it is assumed that the AFS Assigned Numbers Registrar will be responsible for 
             allocating new error table values.  Specifically, the following new Rx error
             codes need to be allocated:
          
</p>
<p>
            </p>
<ul class="text">
<li>RXCL_ERR_UNKNOWN_VERS
</li>
<li>RXCL_ERR_UNKNOWN_ID_TYPE
</li>
<li>RXCL_ERR_WRONG_PEER
</li>
<li>RXCL_ERR_XCID_UNSUPP
</li>
</ul><p>
          
</p>
<p>
             Please see <a class='info' href='#sec:constants'>Section&nbsp;5.1<span> (</span><span class='info'>Constants</span><span>)</span></a> for further details regarding these constants.
          
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.3"></a><h3>9.2.3.&nbsp;
Rx Clear Security Header Version</h3>

<p>
             This memo requests allocation of version 1 within this new namespace
             for the protocol header described in <a class='info' href='#sec:header'>Section&nbsp;5.2<span> (</span><span class='info'>Security Header</span><span>)</span></a>.
          
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.4"></a><h3>9.2.4.&nbsp;
Endpoint Identifier Type</h3>

<p>
             One endpoint type identifier is requested at this time: RXCL_EI_TYPE_NULL.
             The null endpoint identifier type shall have encoding and semantics as
             defined in <a class='info' href='#sec:constants'>Section&nbsp;5.1<span> (</span><span class='info'>Constants</span><span>)</span></a>
          
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<p>
         This protocol explicitly provides neither the means for encrypting nor integrity
         checking the contents of Rx headers or payloads.  Its use, except 
         in physically secured and isolated high-performance computing environments where
         cryptographic overhead is deemed to be unacceptable, is NOT RECOMMENDED.  Where
         use on the internet is necessary, other means of protecting the Rx protocol
         from attack, such as IPsec <a class='info' href='#RFC4301'>[RFC4301]<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> <a class='info' href='#RFC4302'>[RFC4302]<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a>
         <a class='info' href='#RFC4303'>[RFC4303]<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> are RECOMMENDED.  It should be noted that, due to its
         use of UDP as a transport, Rx is not a candidate for encapsulation within TLS
         <a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>.
      
</p>
<p>
         Rx without packet header integrity, at a minimum, is open to a call injection
         attack.  The following section outlines describes this known attack vector,
         and how the introduction of the Rx Clear security class changes the susceptibility of
         Rx to this attack.
      
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
call injection</h3>

<p>
          With rxnull, simplex injection attacks have always been possible.  For connections
          with the G bit (as described in <a class='info' href='#sec:mh'>Section&nbsp;1.2<span> (</span><span class='info'>Multi-homed Host Support</span><span>)</span></a>) asserted, this means
          that the attacker must correctly spoof the epoch and connection ID.  For injection
          of data packets into a channel, one further piece of information must be available:
          the range of packet sequence numbers currently within the valid receive window.
          Much of this information is obtainable by probing the victim with Rx protocol
          debugging packets.
        
</p>
<p>
           The Rx Clear security class changes the nature of this attack.  If an attacker,
           in addition to the information above,
           also posesses the correct endpoint identifiers for the two peers, it may hijack
           the Rx connection.  The key difference here is that the attack is full-duplex;
           all replies will now flow to the attacker instead of the original recipient.
        
</p>
<p>
           Given that both rxnull and Rx Clear are unauthenticated security objects, this is
           unlikely to result in anything more severe than a denial of service.  Furthermore,
           given the new Rx Clear abort codes, the peer will detect this situation one round trip
           after transmission of its next call, rather than ending up in a state where the
           two peers disagree on call channel window position, which is complex to detect and resolve.
        
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="AFS3-STDS-CHARTER">[AFS3-STDS-CHARTER]</a></td>
<td class="author-text">Wilkinson, S., &ldquo;<a href="http://michigan-openafs-lists.central.org/archives/afs3-standardization/2008-September/000244.html">Options for AFS Standardisation</a>,&rdquo; September&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="AFS-RX">[AFS-RX]</a></td>
<td class="author-text">Zayas, E., &ldquo;AFS-3 Programmer's Reference: Specification for the Rx Remote Procedure Call Facility,&rdquo; Transarc Corp. Tech. Rep.&nbsp;FS-00-D164, August&nbsp;1991.</td></tr>
<tr><td class="author-text" valign="top"><a name="AFS1">[AFS1]</a></td>
<td class="author-text">Howard, J., &ldquo;<a href="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-062.pdf">An Overview of the Andrew File System"</a>,&rdquo; Proc. 1988 USENIX Winter Tech. Conf.&nbsp;pp. 23-26, CMU ITC Tech. Rep.&nbsp;CMU-ITC-88-062, February&nbsp;1988.</td></tr>
<tr><td class="author-text" valign="top"><a name="AFS2">[AFS2]</a></td>
<td class="author-text">Howard, J., Kazar, M., Menees, S., Nichols, D., Satyanarayanan, M., Sidebotham, R., and M. West, &ldquo;<a href="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-068.pdf">Scale and Performance in a Distributed File System</a>,&rdquo; ACM Trans. Comp. Sys.&nbsp;Vol. 6, No. 1, pp. 51-81, CMU ITC Tech. Rep.&nbsp;CMU-ITC-87-068, February&nbsp;1988.</td></tr>
<tr><td class="author-text" valign="top"><a name="CMU-ITC-84-011">[CMU-ITC-84-011]</a></td>
<td class="author-text">Satyanarayanan, M., &ldquo;<a href="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-011.pdf">RPC User Manual</a>,&rdquo; CMU ITC Tech. Rep.&nbsp;CMU-ITC-84-011, January&nbsp;1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="CMU-ITC-85-003">[CMU-ITC-85-003]</a></td>
<td class="author-text">Satyanarayanan, M., &ldquo;<a href="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-003.pdf">A Large-Parameter Remote Procedure Call Mechanism in Unix</a>,&rdquo; CMU ITC Tech. Rep.&nbsp;CMU-ITC-85-003, 1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="CMU-ITC-85-038">[CMU-ITC-85-038]</a></td>
<td class="author-text">Satyanarayanan, M., &ldquo;<a href="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-038.pdf">RPC2 User Manual</a>,&rdquo; CMU ITC Tech. Rep.&nbsp;CMU-ITC-85-038, 1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4120">[RFC4120]</a></td>
<td class="author-text">Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;<a href="http://tools.ietf.org/html/rfc4120">The Kerberos Network Authentication Service (V5)</a>,&rdquo; RFC&nbsp;4120, July&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4120.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4506">[RFC4506]</a></td>
<td class="author-text">Eisler, M., &ldquo;<a href="http://tools.ietf.org/html/rfc4506">XDR: External Data Representation Standard</a>,&rdquo; STD&nbsp;67, RFC&nbsp;4506, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4506.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4960">[RFC4960]</a></td>
<td class="author-text">Stewart, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4960">Stream Control Transmission Protocol</a>,&rdquo; RFC&nbsp;4960, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4960.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="VICE1">[VICE1]</a></td>
<td class="author-text">Satyanarayanan, M., Howard, J., Nichols, D., Sidebotham, R., Spector, A., and M. West, &ldquo;<a href="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-039.pdf">The ITC Distributed File System: Principles and Design</a>,&rdquo; Proc. 10th ACM Symp. Operating Sys. Princ.&nbsp;Vol. 19, No. 5, CMU ITC Tech. Rep.&nbsp;CMU-ITC-85-039, December&nbsp;1985.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-zeldovich-rx-spec">[draft-zeldovich-rx-spec]</a></td>
<td class="author-text">Zeldovich, N. and M. Meffie, &ldquo;<a href="http://openafs.sinenomine.net/~mmeffie/rfc/draft-zeldovich-rx-spec-00.txt">Rx protocol (work in progress)</a>,&rdquo; November&nbsp;2009.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomas Keiser</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sine Nomine Associates</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">43596 Blacksmith Square</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ashburn, VA  20147</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 703 723 6673</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:tkeiser@sinenomine.net">tkeiser@sinenomine.net</a></td></tr>
</table>
</body></html>
