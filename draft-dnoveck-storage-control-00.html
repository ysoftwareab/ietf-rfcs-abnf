<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Storage Control Extensions for NFS Version 4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Storage Control Extensions for NFS Version 4">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">nfsv4</td><td class="header">D. Noveck</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">EMC</td></tr>
<tr><td class="header">Expires: April 18, 2011</td><td class="header">P. Erasani</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">L. Bairavasundaram</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">NetApp</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Dai</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">C. Karamonolis</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Vmware</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 15, 2010</td></tr>
</table></td></tr></table>
<h1><br />Storage Control Extensions for NFS Version 4<br />draft-dnoveck-storage-control-00</h1>

<h3>Abstract</h3>

<p>
      Developments in storage systems have made it important
      for applications to have control over the characteristics
      of the storage that will be used for their particular
      files.  The development of pNFS has added to the usefulness 
      of such control mechanisms as it has created the opportunity
      for the hierarchical organization of file names to
      be separated from the control of storage characteristics
      for individual files, including the assignment
      to storage locations to reflect the performance or
      other needs of those specific files.  This document
      proposes extensions to NFS version 4 to allow 
      storage requirements to be communicated to the NFS
      version 4 server.
    
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 18, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Storage Control Issues<br />
<a href="#anchor2">2.</a>&nbsp;
Storage Choice and API Definition<br />
<a href="#anchor3">3.</a>&nbsp;
Modes of Storage Choice<br />
<a href="#anchor4">4.</a>&nbsp;
Assuring Extensability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">4.1.</a>&nbsp;
Requirements for Extensability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.2.</a>&nbsp;
XDR Encoding for Extensability<br />
<a href="#anchor7">5.</a>&nbsp;
Storage Control<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.1.</a>&nbsp;
Property Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.1.1.</a>&nbsp;
Informative Properties<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">5.1.2.</a>&nbsp;
Enforceable Properties<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.2.</a>&nbsp;
Base Property Specifications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.2.1.</a>&nbsp;
Storage Size<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.2.2.</a>&nbsp;
Storage Use Duration<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.2.3.</a>&nbsp;
Storage Device Failure Limit<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.2.4.</a>&nbsp;
Storage System Failure Limit<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.2.5.</a>&nbsp;
Storage System Failure RPO<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.2.6.</a>&nbsp;
Storage System Failure RTO Properties<br />
<a href="#anchor21">6.</a>&nbsp;
Uses of the Attribute storage_ctl<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Creating">6.1.</a>&nbsp;
Use of storage_ctl when creating a file<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SETATTR">6.2.</a>&nbsp;
Use of storage_ctl in SETATTR<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">6.3.</a>&nbsp;
Use of storage_ctl in GETATTR/READDIR<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#VERIFY">6.4.</a>&nbsp;
Use of storage_ctl in VERIFY/NVERIFY<br />
<a href="#anchor23">7.</a>&nbsp;
The FETCH_SCNOTE Operation<br />
<a href="#Extensions">8.</a>&nbsp;
Attribute Extension<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">8.1.</a>&nbsp;
Experimental and Other Non-standardized Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">8.2.</a>&nbsp;
Standardized Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">8.3.</a>&nbsp;
The storage_ext attribute<br />
<a href="#anchor31">9.</a>&nbsp;
Summary<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">9.1.</a>&nbsp;
Errors<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">9.2.</a>&nbsp;
Semantic constraints<br />
<a href="#anchor34">10.</a>&nbsp;
Possible Future Work<br />
<a href="#anchor35">11.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Storage Control Issues</h3>

<p>
    Storage to which files may be assigned can differ in a
    number of ways, raising the issue of how to control
    the choice of storage for specific files.  The range of
    such choices is not static but can be expected to
    increase as flash memory becomes an option whose
    use needs to be controlled, or various choices of types of
    local caching need to be made.  Although all files may
    well be helped by such approaches, the degree to which
    they will be helped will vary with the type of file
    and the typical application reference pattern for it.
    In addition, the value of improved access will differ
    with quick access to certain files being of much
    greater value, thereby justifying the allocation
    of more expensive storage resources to such files.
  
</p>
<p>
    The traditional way that user decisions regarding
    assignment of storage resources have been effected
    is by assigning specific file systems to specific
    disks or sets of disks.  Files placed in that
    file system thereby get the storage characteristics
    assigned to that file system.  Where file systems
    contain storage of various types, various heuristics
    are used to assign files or pieces thereof, to storage
    of various types, generally without any external input
    about application needs.
  
</p>
<p>
    The creation of pNFS modifies this pattern in that
    data and metadata are separated.  Where pNFS is 
    used, assigning a file to a specific file system 
    now controls only where the metadata is located.  
    Different files may have their data assigned 
    to different sorts of storage,
    potentially located on different servers.  This
    gives rise to the need for a means by which the
    storage choice for a particular file may be made.
  
</p>
<p>
    NFS version 4.1 contains a layouthint attribute
    but this does not really address the problem.  The
    focus of the layouthint attribute is on the striping
    configuration, but there is a need to control 
    storage characteristics other than this.
    This is the case even when there
    is only a single stripe (that is, no striping).
    Even though this is not "parallel NFS," using 
    pNFS in this way to provide a separation of data
    and metadata, with the ability to choose locations
    for data based on its characteristics subject to
    later change in a user-transparent manner is very
    powerful, particularly if the storage location
    is subject to intelligent management.
  
</p>
<p>
    Additionally, more sophisticated storage management
    arrangements make it desirable to have a way to 
    specify details for storage handling, even when 
    pNFS is not used.  When a file system contains 
    different sorts of storage, input regarding desired
    or necessary storage characteristics can be used 
    to make storage assignment choices more in line 
    with application needs.
  
</p>
<p>
    As a result, the ability to specify desired storage
    characteristics can provide benfits, both when pNFS
    is used and when it is not, although pNFS has 
    the most immediate set of needs for means by which 
    to control storage selection.
  
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Storage Choice and API Definition</h3>

<p>
    It needs to be noted that existing API's may not 
    provide means by which some of the storage 
    characteristics described herein may be communicated 
    to NFSv4 in-kernel clients and from there, to
    NFSv4 servers.
    Nevertheless, definition of a means by which 
    these storage characteristics may be communicated
    to the NFSv4
    server is still useful for a number of reasons:
    </p>
<blockquote class="text">
<p>
        Embedded clients for particular applications
        may specify this information even without
        any API deinition. 
      
</p>
<p>
        Client implementations may use various 
        less-than-perfect ways of specifying storage
        characteristics, assigning storage chatcteristics
        based on file ownership or other nominally 
        unrealated characteristics that that corelate 
        well with customer intentions.
      
</p>
</blockquote><p>
  
</p>
<p>
    Note that if the absence of a standard kernel API 
    were sufficient to stop this work, it also probably 
    be the case that the absence of a means to communicate
    the information to remote servers might make the 
    definition of that API not worth the effort.  By 
    defining some storage characteristics and a general 
    means of communicating them and others (via an extension
    mechanism) we allow for either:
    </p>
<blockquote class="text">
<p>
        The later development of API's to specify these storage
        characteristics.
      
</p>
<p>
        The developemt of API's to specify different sets of 
        storage characteristics that can then be easily 
        assimilated to this mechanism as extsnions.
      
</p>
</blockquote><p>
  
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Modes of Storage Choice</h3>

<p>
    There are a number of different ways in which storage
    choices may be indicated:
    </p>
<ul class="text">
<li>
        The specific file system location(s) might be
        specified.
      
</li>
<li>
        Specific types of storage might be specified
        with selection of such choices as SSD, SATA, or 
        fiber channel SAN drives being made by the client 
        and effected by the MDS.
      
</li>
<li>
        Desired characteristics of storage including speed
        (latency and/or throughput), amount of storage 
        that will be needed, safety (raid-level).  Available
        storage would be selected to meet the required 
        characteristics and would be subject to active
        management as the environment changes.
      
</li>
</ul><p>
  
</p>
<p>
    These different modes of storage choice are all
    useful in different environments.  Specification
    of a specific file system imposes the least 
    need for a storage management infrastructure but
    it requires user/application knowledge.
  
</p>
<p>
    The other modes imply a sequence of progressively
    greater infrastructure requirements to map 
    specifications to specific storage systems and a
    correspondingly smaller need for user/application
    knowledge of the storage environment.  However,
    such modes of operation are very different from 
    existing storage management paradigms and the
    precise ways in which applications and storage
    might communicate are not fully understood. 
  
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Assuring Extensability</h3>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Requirements for Extensability</h3>

<p>
      As the examples of different modes of storage choice
      suggest, there are potentially a large number of
      specific items that might be specified in order to
      effect storage choice.  Further, in many cases,
      expected future developments 
      in the area of storage can be expected to extend and
      otherwise modify the characteristics which might be
      specified.
    
</p>
<p>
      The need for extensibility is important as one might 
      expect many ongoing developments, including those 
      in the areas of storage hardware, and file systems, 
      to create corresponding needs to specify relevant
      storage chatacteristics.
    
</p>
<p>
      For example, local caching, including writeback 
      caching using flash, creates the opportunity for
      greatly improved performance, at the risk of 
      greater complexity in dealing with network failures.
      This raises the issue of allowing the user to 
      make the choice of whether this greater performance
      is worth the risks and difficulties.
    
</p>
<p>
      Similarly, the development of distributed file
      systems raises many choices where performance
      will need to be balanced against various forms
      of safety issues, with specific choices reflecting 
      the specific needs of applications dealing with 
      the storage.
    
</p>
<p>
      These situations and others that we may not be
      able to predict, require that any attribute
      scheme in this area allow the specification of
      multiple storage characteristics with the 
      ability to easily extend the specification 
      so that it incorporates new 
      characteristics to govern storage selection.
      Further, the need for actual use testing before
      incorporation in an IETF standard, imposes
      new requirements as far as organizing specification
      of the characteristics.  
    
</p>
<p>
      Having "working code"
      to effect characteristic selection is not
      sufficient to demonstrate usefulness.  The working
      code may be trivial while finding out whether 
      this set of characteristics make sense for 
      applications to use or requires extension or
      modification before assuming its final form is
      not trivial.  This may require significant 
      trial use among a large set users running different 
      applications, before rhe details are ready to 
      be standardized.
    
</p>
<p>
      These factors increase the need for flexibility,
      including non-private use of characteristics
      not yet standardized.
      Accommodating this need for flexibility has
      the potential for unduly interfering with
      interoperability and the design of this
      feature will need to avoid that.
    
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
XDR Encoding for Extensability</h3>

<p>
      While each storage property could conceivably be
      made its own attribute, the burden that this would
      place on the IETF process would be immense.  
      There would be necessary co-ordination (and almost
      certain confusion) as individual experimental 
      properties needed temporary attribute numbers and
      then had to shift them to other more permanent 
      numbers.  Further, and even more of an issue,
      storage property definition would seem to require
      a minor version, which seems too heavyweight.  This
      would slow down the process beyond what should be
      for something which was its own standard-track RFC.
    
</p>
<p>
      In order to address these issues, individual 
      properties will be treated as sub-attributes 
      within a single storage_ctl attribute.  To 
      simplify assignment of sub-attribute numbers, 
      mainly in support of experimental use, multiple 
      sub-attribute spaces will be supported, to
      allow independent development of features each
      involving multiple storage properties.  Once
      such a feature is standardized, the definition of the
      specific sub-atribute space could simply be made
      the subject of a standards-track RFC, with
      no change to those using it. 
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

   typedef uin32_t  spacenum_sc;    /* Individual property space id. */
   typedef uint32_t bitmap_sc&lt;*&gt;;   /* Bit map for the presence or
                                       absence of individual properties
                                       using bit numbers assigned for
                                       the space. Like bitmap4.      */
   typedef opaque   proplist_sc&lt;*&gt;; /* Data associated with each of the
                                       properties in the bitmap_sc.
                                       Like attrlist4.               */

   struct section_sc {
      spacenum_sc   SpaceSection;   /* Section number.                */
      bitmap_sc     WhichProperties;/* Bit map of properties present. */
      proplist_sc   PropertyData;   /* Data for each of the properties
                                       specified in this section.     */
   };

  typedef section_sc fattr4_storage_ctl&lt;*&gt;;
                                    /* The attribute may have one or
                                       more property sections. */

</pre></div>
<p>
      This form of property encoding allows the property set to be 
      extended without requiring a new minor version.  Also, by allowing
      property space numbers to be assigned, property sets can be 
      developed indpendently, and converted to a standard state
      without undue interruption to those using the earlier form.
    
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Storage Control</h3>

<p>
    Storage, along with compute, memory, and network, is an integral
    part of an application's resources. Much like the other types 
    of resources
    consumed by an application, storage needs can be described using a
    set of properties. These properties may serve to describe the
    characteristics of the storage, the intended usage both temporal 
    and spatial, quality of service expectations, physical layout over
    available storage media, data access locations, geographical
    distribution, just to name a few. The collection of such
    properties together define the control an application ultimately
    wants to have on storage; conversely, they enable the storage
    system to more effectively and dynamically meet the application's
    needs as specifically expressed, rather than inferred, based on 
    fallible heuristics. Henceforth, we will
    use the term control to refer to the property collection.
  
</p>
<p>
    It is not difficult to conceive various storage properties. In
    fact, there are numerous of them, due to the diversity of
    applications and the corresponding workload characteristics, the
    ever increasing storage value-adds in the form of data services,
    and the fast changing business requirements. It is an impossible
    task to capture all of them here. Rather, the goal of this
    document is to define a framework in which new properties can be
    easily added and new semantics of the properties can be
    introduced as necessary without disruption.  It is desired
    that they be capable of being used in more limited situations,
    refined as necessary and
  
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Property Types</h3>

<p>
      There may be numerous storage properties as mentioned above. 
      We need, however, to distinguish at least two types, namely,
      informative properties and enforceable properties. There may
      very well be other systems or criteria when it comes to the 
      classification of storage properties; and extensibility shall
      apply in this case just as it does to adding new storage
      properties. However, there is a need to explicitly capture the
      distinctions between informative and enforceable properties in
      the data model, due to the impact on the storage protocol
      semantics.
    
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Informative Properties</h3>

<p>
        An informative property, as the name suggests, provides some 
        descriptive information about the storage in question. Such
        information is furnished in a single direction from the
        application to the storage system with absolutely no
        "contractual" implications. The storage system may use the
        information captured in such a property for storage
        optimization. But it is not obligated to do so. More
        importantly, the application is not offered any transparency
        as to how the storage system may utilize this information. As
        such, the information flow is strictly one-way without the
        prospect for any feedback. Examples of informative properties
        are the access pattern of the storage in use, the expected
        capacity need, and the estimated growth rate.
      
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Enforceable Properties</h3>

<p>
        In contrast, an enforceable property may have embedded in it
        varying degrees of binding effect. By that, it means the
        application specifying the property has expectations that the
        storage system not only acts upon but also conveys the
        action status back in some way. Unlike the case of an informative
        property, the information flow in this case is truly
        bi-directional, with the backward direction for monitoring 
        property status, including information on whether a property 
        has been satisfied or is in the process of being satisfied.
        In that sense, an enforceable property has a
        resemblance to an agreement, where one might monitor the
        performance of the other party.
      
</p>
<p>
        Applications seeking tighter control of the storage may resort
        to the enforceable properties. Examples of enforceable
        properties could include the type and speed of sorage but could
        also include the availability, reliability, and average
        throughput and latency.
      
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2.1"></a><h3>5.1.2.1.&nbsp;
Enforcement Level</h3>

<p>
          To allow varying degrees of control, an enforcement level
          may be associated with an enforceable property. There are
          two levels of control possible, namely, advisory and
          mandatory. Regardless of the level, the storage system should
          strive to fulfill an enforceable property. The difference
          lies in the treatment of an inability to do
          so. With an advisory enforcement level, the storage system
          shall continue to carry out the operation even if the
          property could not be fulfilled; whereas with mandatory, the
          storage shall fail the operation without making any
          modification. In any case, the failure to fulfill an
          enforceable property can be communicated to the
          application.
        
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2.2"></a><h3>5.1.2.2.&nbsp;
Compliance Status</h3>

<p>
          While control may suffice to describe the ultimate storage
          requirements, i.e., the intended behavior once it has been
          fully implemented, it does not by itself capture the dynamic
          aspects of the implementation process.  This is encompassed 
          by the concept of "compliance" which indicates the extent to
          which requested storage properties have or have not been
          provided or whether they are still in the process of being 
          provided.  Note that the word "compliance" as used here 
          has no connection with this word
          as used to describe issues conformance with a set of 
          legal requirements for recond-keeping, among other matters.
        
</p>
<p>
          Control implementation can be a fairly heavyweight process
          by nature due to the data intensity involved. This may be
          true whether it is during the initial provisioning of
          storage, or the subsequent change management, or the
          remediation of compliance violation. The data intensive
          nature of the control implementation process implies that
          the transition from non-compliance to compliance will
          not be instantaneous in the general case. In other
          words, the implementation process remains asynchronous
          relative to the operation that triggers it.
        
</p>
<p>
          The asynchronous nature of the control implementation
          process may be captured by the compliance status. The
          compliance status may have three different values, namely,
          Current, Complying, and Failed. The value Current represents
          a fully compliant state. The value Complying refers to a
          transient state in which the transition to current is in
          progress.
        
</p>
<p> 
          The value Failed represents an indefinite state of
          non-compliance. In the last case, the storage system may
          have made the determination that it is unable to fulfill
          some or all of the storage properties given the physical
          resources available.  The application will work without,
          but its performance may not be what is desired.
        
</p>
<p>
          The compliance status describes the state of the control
          fulfillment as it pertains to each property. It applies to
          an enforceable property only. Its presence is not a syntactic
          requirement as defined by the XDR specification.  Depending
          on the operational context in which the enforceable 
          property is specified, specification of compliance status
          may be either invalid, required, or optional with the
          specification of more that one such status values possible
          in some cases.
        
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2.3"></a><h3>5.1.2.3.&nbsp;
XDR Encoding for Enforceable Properties</h3>

<p>
          Enforceable properties contain a word which is of type
          enforce_sc and allows the enforcement level and compliance 
          status to be specified.  To allow greatest flexibility,
          all enforcement statuses and compliance status values
          are specified as bit values, allowing sets of enforcement
          levels and complicance status, to be specified, as 
          appropriate.
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   typedef uint32_t enforce_sc;

   const enforce_sc ENFORCE_MANDATORY = 0x1;
   const enforce_sc ENFORCE_ADVISORY = 0x2;
   const enforce_sc ENFORCE_CURENT = 0x10;
   const enforce_sc ENFORCE_COMPLYING = 0x20;
   const enforce_sc ENFORCE_FAILED = 0x40;
</pre></div>
<p>
          For most purposes, enforcement words should have a single
          enforcement level, either ENFORCE_MANDATORY 
          ENFORCE_ADVISORY.  Any enforcement word containing
          both bits will result in NFS4ERR_SCTL_BADENF being
          returned.  Specification of an enforcement word
          containing neither will generally result in
          in NFS4ERR_SCTL_BADENF being returned.  However,
          it may be specified, when doing a SETATTR that
          specifies a reserved empty parameter value to 
          remove a property specifiction.  Also, it may be
          specified when doing an VERIFY ot NVERIFY to
          specify a property without a defined enforcement
          level.
        
</p>
<p>
          When specifying a storage property as part of a 
          OPEN, CREATE. or SETATTR, no enforcement level bits
          should be specified.  If they are, the error
          NFS4ERR_SCTL_BADENF is returned.  For values
          returned by the server in response to GETATTR,
          enforcement words, containing exactly one compliance
          status bit will be returned.  When using
          storage properties as part of VERIFY or NVERIFY
          compliance words containing no compliance bits
          or any subset of the valid compliance status
          bits may be specified.
        
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Base Property Specifications</h3>

<p>
      The goal for initial inclusion in an NFS version 4 minor version
      is to define a small set of property specifications that are
      generally useful and do not require a large management
      infrastructure to implement. The following are the three
      property specifications fit that description.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   const spacenum_sc SCNUM_BASE = 1;   /* Base property space id for
                                          all properties in this
                                          group. */

   const uint32_t SCBASE_SIZE = 0;     /* Informative property for
                                          size. */
   const uint32_t SCBASE_DURATION = 1; /* Informative property for
                                          duration. */
   const uint32_t SCBASE_DEVFAIL = 2;  /* Enforceable property for
                                          a device failure limit. */
   const uint32_t SCBASE_SYSFAIL = 3;  /* Enforceable property for
                                          a system failure limit. */
   const uint32_t SCBASE_FAIL_RPO = 4; /* Enforceable property for
                                          a recovery point objective
                                          in the event of failure. */
   const uint32_t SCBASE_SFAIL_RTO = 5;/* Enforceable property for
                                          a recovery time objective
                                          in the event of system
                                          failure. */
   const uint32_t SCBASE_DLOSS_RTO = 6;/* Enforceable property for
                                          a recovery time objective
                                          in the event of data loss. */
   const uint32_t SCBASE_DISASTER_RTO = 7;/* Enforceable property for a
                                             recovery time objective in
                                             the event of disaster. */

</pre></div>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Storage Size</h3>

<p>
        The storage size is an informative property that allows the
        specification of the expected amount of storage to be
        needed. It may be used by the server in seeing if appropriate 
        space is available and in reserving space.  It is specified as 
        a 64-bit unsigned value giving a quantity of storage expressed
        in bytes.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   typedef uint64_t propbase_size;
</pre></div>
<p>
        This value may be different from the expected file size. Areas
        not allocated, because of holes for example, are not
        included. This amount of storage may not be required
        immediately if the file starts small and grows. Any derating
        of specified values is purely a matter of server
        implementation choice and will typically reflect the ability
        to move data to respond to storage overcommitment.
      
</p>
<p>
        A value of zero is invalid and would result in the error
        NFS4ERR_SCTL_BADPARM when used in an OPEN or CREATE. When
        used in SETATTR, it causes deletion of a previous 
        storage size specification.
      
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Storage Use Duration</h3>

<p>
        The storage use duration is an informative property 
        that allows the specification of the amount of time
        that the storage is expected to be needed.  It may be
        used in assigning files to storage so that space 
        conflicts are reduced.  It is specified as a
        64-bit unsigned value giving a duration in milliseconds.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   typedef uint64_t propbase_duration;
</pre></div>
<p>
        This allows times from 1 millisecond up to approximately 
        500 million years to be specified.   
        A value of zero is invalid and would result in the error
        NFS4ERR_SCTL_BADPARM when used in an OPEN or CREATE. When
        used in SETATTR, it causes deletion of a previous 
        storage duration specification.
      
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
Storage Device Failure Limit</h3>

<p>
        The storage device failure limit is an enforceable 
        property that allows the specification of a number 
        of disk drives (or other devices) that can fail 
        simultaneously with no data loss and that incurs 
        zero recovery time.  It must be the case that any
        set of devices of the specified can fail without
        data loss and with zero recovery time.
      
</p>
<p>
        Even though there is no recovery time, there may 
        be a significant recovery period of modestly reduced 
        performance while adaptation to the failure is done 
        and until the completion of which, additional
v        device failures will be considered simultaneous. 
      
</p>
<p>
        The limit is specified as a 32-bit unsigned value
        giving the minimum count of simultaneous failures 
        that can result in data loss to clients accessing 
        the file.  Storage is assigned which either matches
        this specification or provides a greater value.  
        When pNFS is involved the specification 
        applies to storage for the MDS and each DS. 
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   typedef uint32_t prop_dev_fail_lim;

   struct propbase_device_failure_limit {
       enforce_sc        DflEnforce;
       prop_dev_fail_lim DflLimit;
   };
</pre></div>
<p>
        This allows values from zero to approximately 4 billion 
        to be specified. A value of zero is valid and specifies 
        that data loss is tolerable in the event of single 
        device failure. (e.g. RAID-0) 
      
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
Storage System Failure Limit</h3>

<p>
        The storage system failure limit is an enforceable 
        property that allows the specification of the number 
        of storage systems that must be able to fail 
        simultaneously without complete data loss. 
        Storage is assigned which either matches
        this specification or provides a greater value.  
        When pNFS is involved the specification 
        applies to storage for the MDS and DS's as a 
        unit.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   typedef uint32_t prop_sys_fail_lim;

   struct propbase_system_failure_limit {
       enforce_sc        SflEnforce;
       prop_sys_fail_lim SflLimit;
   };
</pre></div>
<p>
        This allows values from zero to approximately four
        billion to be specified.  A value of zero is valid 
        and specifies data loss in the event of a single
        storage system failure is tolerable.
      
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.5"></a><h3>5.2.5.&nbsp;
Storage System Failure RPO</h3>

<p>
        The recovery point objective (RPO) is the age 
        of files that must be recovered from backup storage 
        for normal operations to resume if a computer, system, 
        device, or network failure results in data loss.
        The RPO is expressed backward in time (that is, 
        into the past) from the instant at which the 
        failure occurs, and can be specified in seconds. 
        It is an important consideration in disaster 
        recovery planning.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   typedef uint64_t prop_sys_fail_RPO;

   struct propbase_system_failure_RPO {
       enforce_sc        SfrpoEnforce;
       prop_sys_fail_RPO SfrpoTime;
   };
</pre></div>
<p>
        This allows values from zero seconds to 
        a value far beyond the age of the
        universe to be specified.  A value of zero 
        is valid and indiactes that a real-time backup that
        reflects changes immediately as made is
        required.
      
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.6"></a><h3>5.2.6.&nbsp;
Storage System Failure RTO Properties</h3>

<p>
        Recovery time objective (RTO) properties specify
        is the maximum tolerable length of time that  
        storage assigned may be unavailable in the event of various classes
        of failures.  There are three associated properties,
        each which specifies this value for a particular
        class of failure:
        </p>
<blockquote class="text">
<p>
            The system failure RTO property, with the 
            property id SCBASE_SFAIL_RTO, defines the
            recovery time objective in the event of
            failures  that do not not involve data 
            loss or data corruption.
          
</p>
<p>
            The data loss RTO property, with the 
            property id SCBASE_DLOSS_RTO, defines the
            recovery time objective in the event of
            failures  that do not not involve the
            occurrence of a disaster, defined as a
            major environmental event such as a 
            hurricane, earthquake, or flood, etc.
          
</p>
<p>
            The system failure RTO property, with the 
            property id SCBASE_DISASTER_RTO, defines the
            recovery time objective in the event of
            any falure including disasters.
          
</p>
</blockquote><p>
      
</p>
<p>
        The actual RTO is a function of the extent to 
        which the interruption disrupts normal 
        operations and the provisions made to ameliorate
        this situation.  The desired RTO is a function
        of the urgency to re-establish operations
        and the consequences of failure to promptly
        do so. It is an important consideration in 
        recovery planning.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  typedef uint64_t propbase_sys_fail_RTO;

   struct propbase_system_failure_RPO {
       enforce_sc        SfrtoEnforce;
       prop_sys_fail_RTO SfrtoTime;
   };
</pre></div>
<p>
        RTO values for all of these properties is 
        specdified as a 64-bit integer which specifies
        a number of microseconds.  Although sub-second
        RTO values may be difficult, the specification
        allows small values which might be useful in 
        the future.  The maximum value is approximately
        five-hundred thousand years.
      
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Uses of the Attribute storage_ctl</h3>

<p>
    There are four occasions in which the storage_ctl
    attribute is referred to as part of an fattr4
    when the storage_ctl mask is present.
    </p>
<ul class="text">
<li>
        As an attribute specified when creating a file
        or similar object
        by means of an OPEN or CREATE operation, in order to 
        specify the specific storage properies to control
        then locations on which the data is to be put 
        and other associated properties.
      
</li>
<li>
        As an attribute set in a SETATTR operation to
        change the requested location properties.  Servers
        or may not have the ability to change locations
        on request, but the operation structure will indicate
        whether the server has or doesn't have this ability
        when it is requested.
      
</li>
<li>
        As an attribute read in a GETATTR or READDIR 
        operation to 
        determine the currently requested storage
        properties and the degree to which they are
        current being complied with.
      
</li>
<li>
        As an attribute specified in VERIFY or NVERIFY 
        to test for current location property compliance status.
      
</li>
</ul><p>
  
</p>
<p>
    In addition to the above, a fattr4_storage_ctl of the
    of the same structure
    as storage_ctl attribute (although not within an fattr)
    also appears within the response data in the following
    situations.
    </p>
<blockquote class="text">
<p>
        For the OPEN, CREATE, and SETATTR operations, 
        when the error
        returned is NFS4ERR_SCTL_FAIL. 
        (See <a class='info' href='#Creating'>Use of storage_ctl when creating a file<span> (</span><span class='info'>Use of storage_ctl when creating a file</span><span>)</span></a> and 
        <a class='info' href='#SETATTR'>Use of storage_ctl in SETATTR<span> (</span><span class='info'>Use of storage_ctl in SETATTR</span><span>)</span></a> for details).
      
</p>
<p>
        For the response to the FETCH_SCNOTE operation,
        when there is a pending storage control note to be
        reported.
      
</p>
</blockquote><p>
  
</p>
<p>
    For most purposes, a fattr4_storage_ctl which appears 
    in OPEN, CREATE, and SETATTR requests are handled the same and 
    a fattr4_storage_ctl which appears in the 
    responses for OPEN, CREATE, and SETATTR are handled similarly,
    while the VERIFY and NVERIFY requests form a third 
    similarity group.
  
</p>
<a name="Creating"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Use of storage_ctl when creating a file</h3>

<p>
      When the storage_ctl attribute is specified when 
      creating a file, it helps decide on the location
      selected for the file data.  If all enforceable
      properties can be immediately satisfied, then
      the operation proceeds normally.
    
</p>
<p>
      If an enforceable property specified as with the manadatory
      enforcement level cannot be satisfied
      then the operation fails with the error 
      NFS4ERR_SCTL_FAIL.  The response contains, for the
      case NFS4ERR_SCTL_FAIL, a fattr4_storage_ctl value 
      which consists
      all such enforceable properties which could not 
      be satisfied.
    
</p>
<p>
      If there is a situation which is not as serious as 
      a the failure above, but still of note, then
      information relevant to that situation is stored
      as a pending storage control note, where it can
      fetched (in the same COMPOUND) by the FETCH_SCNOTE 
      operation.
    
</p>
<p>
      The following three classes of items are included
      in situations leading to a pending storage control
      note being created.
      </p>
<ul class="text">
<li>
          An enforceable property of the advisory enforcment
          level which not be satisfied, i.e its compliance 
          status is indicated as failed.
        
</li>
<li> 
          An enforceable property of the advisory enforcment
          level which could not be immediately satisfied, 
          i.e. its compliance status is indicated 
          as complying.
        
</li>
<li>
          An enforceable property of the mandatory enforcment
          level which could not be immediately satisfied, 
          i.e. its compliance status is indicated 
          as complying.
        
</li>
</ul><p>
    
</p>
<a name="SETATTR"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Use of storage_ctl in SETATTR</h3>

<p>
      A value of the storage_ctl attribute with a
      structure similar to the OPEN case is used to
      change properties for an existing file.
      Existing elements properties, not changed
      by the storage_ctl attribute remain in effect.
    
</p>
<p>
      An enforceable property of type and 
      the same enforcement level status is overridden by 
      a corresponding one in the new attributes.  To
      delete such an enforeable property element without setting a new
      one, an enforceable property with no parameter
      values is used.  Similarly, an informative property 
      will override an existing one of the same type and
      use of the that property specification with no parameters
      is used to delete an existing informative propety
      specification without replacing it.
    
</p>
<p>
      Failures and notifications are indicated via 
      the error code NFS4ERR_SCTL_FAILED and creation
      of pending storage control notes, 
      just as in the case of OPEN.
    
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Use of storage_ctl in GETATTR/READDIR</h3>

<p>
      When the storage_ctl attribute is requested as part
      of GETATTR or READDIR, the fattr4_storage_ctl 
      returned within the file attributes reflects the
      current informative properties together with the 
      enforceable properties each together with its
      current compliance status.
    
</p>
<p>
      The order of the elements need not reflect that used
      when the attribute was first set.  When enforceable
      properties specify a range of multiple possible values, the
      one returned in the attribute will reflect the value
      actually assigned.
    
</p>
<a name="VERIFY"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Use of storage_ctl in VERIFY/NVERIFY</h3>

<p>
      The storage_ctl attribute presented to VERIFY or 
      NVERIFY is interpreted as a series of properties
      each of which results in a 
      truth value.  When the truth value for all properties
      presented is true, VERIFY succeeds and NVERIFY fails.
      Conversely when not all properties have that truth 
      value, VERIFY fails and NVERIFY succeeds.
    
</p>
<p>
      When informative properties are present they are compared
      to the value set at OPEN, CREATE, or the last SETATTR.  If no 
      such value had
      been previously set, the result is treated as non-matching.
    
</p>
<p>
      Enforceable properties are classified according to
      three criteria:
      </p>
<ul class="text">
<li>
          Whether they have parameters that indicate specific
          values (With-P) or are the special values defined
          for that purpose for each parameter, which are 
          treated as 
          without parameters (Non-P) where the parameter
          values taken are those specified in the corresponding 
          property within the file's attributes.
        
</li>
<li>
          Whether they an enforcement level specified
          (With-Enf) or not (Non-Enf).
        
</li>
<li>
          Whether they together with one or more compliance 
          level levels specified (With-Comp) or not (Non-Comp).
        
</li>
</ul><p>
    
</p>
<p>
      Given the above classifications, the following sets
      of characteristics for enforceable properties
      in the context of storage_ctl for
      VERIFY, NVERIFY are treated as errors and should
      cause the return of the error NFS4ERR_SCTL_BAD.
      </p>
<ul class="text">
<li>
          Non-Comp/Non-Enf/Non-P
        
</li>
<li>
          Non-Comp/Non-Enf/With-P
        
</li>
<li>
          With-Comp/non-Enf/Non-P
        
</li>
<li>
          With-Comp/With-Enf/With-P
        
</li>
</ul><p>
    
</p>
<p>
      Given the above classifications, the following sets
      of characteristics for enforceable properties in
      the context of storage_ctl for
      VERIFY, NVERIFY are handled as discussed below.
      </p>
<blockquote class="text"><dl>
<dt>Non-Comp/With-Enf/Non-P:</dt>
<dd>
          is true iff there exists an enforceable property
          containing elements of the associated enforcement status 
          as part of the storage_ctl attribute of the
          file.
        
</dd>
<dt>Non-Comp/With-Enf/With-P:</dt>
<dd>
          is true iff the enforceable proeprty specified
          is compatible with the corresponding enforceable
          property of the associated enforcement level,
          i.e. if it is possible to satisfy both at the
          same time, without reference to whether both
          or either actually is satisfied.
        
</dd>
<dt>With-Comp/Non-Enf/With-P:</dt>
<dd>
          is true iff the enforceable property (including
          a set of of property specifications of the same type) 
          which appear in the storage_ctl attribute passed to 
          the op is consistent with the set of compliance
          levels (often a single level but sometimes two)
          in the specification.  That is, the actual compliance
          level must be one of the ones that is specified. 
        
</dd>
<dt>With-CompB/With-Enf/Non-P:</dt>
<dd>
          is true iff the enforceable property designated
          by this specification (i.e. that being of the same
          type of specification and the same enforcement 
          level) is consistent with the set of compliance
          levels (often a single level but sometimes two)
          in this specification.  That is, the actual compliance
          level must be one of the ones that is specified. 
        
</dd>
</dl></blockquote><p>
    
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
The FETCH_SCNOTE Operation</h3>

<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
SYNOPSIS</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
(cfh) -&gt; note_pres, note_fattr
</pre></div>
<a name="OP_GETFH_ARGUMENT"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
ARGUMENT</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
/* CURRENT_FH: */
void;
</pre></div>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
RESULT</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
enum SCFres_type {
        SCFres_ABSENT = 0,
        SCFres_PRESENT = 1
};

union SCFresok switch (SCFres_type note_pres) {
 case FETCH_PRES:
        fattr4_storage_ctl  note_attr;

 case FETCH_ABS:
        void;
};

union FETCHres switch (nfsstat4 status) {
 case NFS4_OK:
        /* CURRENT_FH: opened file */
        FETCH4resok      resok4;
 default:
        void;
};

</pre></div>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
DESCRIPTION</h3>

<p>
      The FETCH_SCNOTE operation is used to fetch a pending
      storage control note for a specified file handle (the
      current file handle).  Note that these notes are stored
      according to the current file handle when the operation
      which gave rise to them was executed.  Thus it will be
      the directory on (most) OPENs, and the specific file
      in the event of SETATTR.
    
</p>
<p>
      This operation uses the current filehandle value to 
      identify the storage control note being sought.
    
</p>
<p>
      The operation returns an indication of whether
      the note is present and if it is 
      a fattr4_storage_ctl value which consists
      all enforceable properties where there is a 
      lack of adequate compliance to be noted.
      The use of the the enum scnote_respval
      rather than a boolean value allows later
      extension.
    
</p>
<p>
      If the note is present, it ceases to be so
      once the operation is executed.
    
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
IMPLEMENTATION</h3>

<p>
      Storage control note items are maintained on a 
      per-COMPOUND-request basis and cease to exist
      when a COMPOUND fails due to completion or an
      the occurrence of an error.  This makes it
      desirable to place the FETCH_SCNOTE operation
      close to, generally immediately after the 
      operation capable of generating the storage
      control note.
    
</p>
<a name="Extensions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Attribute Extension</h3>

<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Experimental and Other Non-standardized Extensions</h3>

<p>
      In order to support development of extensions to allow control
      of new file system support attributes, extensions may be
      defined, each with their own proper space id. 
      The goal is to allow quick deployment of 
      new features, including those that at are vendor-specific
      at the time with the definitions of extensions being
      publicly available. 
    
</p>
<p>
      Each such extension set should be registered with IANA.
      The registration will include
      </p>
<ul class="text">
<li>
          A short name (a few words) by which the extension 
          will be known.
        
</li>
<li>
          The name or corporate identity of the owner of the
          extension.
        
</li>
<li>
          Data for the first version of the namespace 
          extension, as described below.
        
</li>
</ul><p>
    
</p>
<p>
      Iana will assign a spaceid by which the extension will be
      known. 
    
</p>
<p>
      Successive versions of spaceid properties should be
      registered by the owner of the extension,  The
      registration should include:
      </p>
<ul class="text">
<li>
          The namespace name and number.
        
</li>
<li>
          The namespace version number.  The version number
          is in the form a series of small (< 256) integers.
          The length of the series will probably be
          restricted to something between four and six.
          The version numbers will not be checked for order
          but only that they are unique for a given extension.
        
</li>
<li>
          A document in the form of an internet draft with
          information on the namespace elements paralleling
          this one.  The document will contain definitions
          and propery numbers with the space id for all of
          properties within the extension.
        <br />
<br />

          Successive version may add properties but may
          not delete them, clarifications to the semantics
          of existing properties may be made but substantive
          changes in their semantics should not be made.
        <br />
<br />

          Existing properties may not be defines as 
          invalid or mandatory-to-not-implement but they
          may be defined as incompatible with some set of
          new properties.
        
</li>
</ul><p>
    
</p>
<p>
      The definitional document should be subject to expert 
      review but the purpose of the review is to ensure that
      the document describes the extension adequately.  It should
      not be rejected simply because the expert would do
      things differently or believe the specified properties
      are useful. 
    
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Standardized Extensions</h3>

<p>
      Storage properties may be extended via a standards-track
      document in a number of ways.  Such an extension may
      be part of a new minor version, but may also be done
      independent of in a standards-track document other than
      for a new NFSv4 minor version.  When the extension occurs
      in a new minor version the document should make clear 
      whether the additional properties are recommended
      (as is normally the case) or mandatory.
    
</p>
<p>
      The following forms of extension are all valid options:
      </p>
<blockquote class="text">
<p>
          Adding additional properties to existing standardized
          property set such as PROP_BASE.
        
</p>
<p>
          Creating a new property set its own property set id.
        
</p>
<p>
          Converting a previous experimental property set to
          standards-track status based on the publication of
          the RFC [Need to clarify any possible transfer of 
          ownership issues.]
        
</p>
</blockquote><p>
    
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
The storage_ext attribute</h3>

<p>
      The storage_ext attribute is a per-fs attribute which
      contains information on the storage_ctl extensions
      suported by the server when used on the associated
      file system.  Servers will often report the same value of
      the storage_ext attribute for all file systems, but 
      client should not assume that this is the case.
    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   struct section_se {
      spacenum_sc   SpaceSction;    /* Section number. */
      bitmap_sc     WhichProperties;/* Supported properties. */
   };

   typedef section_se fattr4_storage_ext&amp;lt�&gt;;
</pre></div>
<p>
      The storage_ext attribute consists of section_se
      arrays, each of which specify the supported properties
      for a specific space_id.  The section_se arrays should
      be reported in ascending numeric order of spacenum_sc 
      values. 
    
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Summary</h3>

<p>
    This chapter serves a reference guide to things
    discussed above.  For a more discursive treatment, with
    less attention due syntax details, see above.
  
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Errors</h3>

<p>
      This proposal would involve adding the following new
      errors to the NFS version 4 minor version in which it
      is included.  
      </p>
<blockquote class="text"><dl>
<dt>NFS4ERR_SCTL_BADPROP</dt>
<dd>
          Returned when the storage_ctl attribute contains
          properties with a space id unknown to the server,
          or with property bits whose diplacement in the 
          bitmap corresponds to property numbers not known
          to the server as being associated with the current
          space id.
        <br />

          This error is returnable by OPEN, CREATE, SETATTR, VERIFY,
          and NVERIFY.
        
</dd>
<dt>NFS4ERR_SCTL_BADPARM</dt>
<dd>
          Returned when the storage_ctl attribute contains
          parameters defined as not valid in connection
          with the current property.  This includes situations
          in which multiple properties contain values
          that are defined as inconsistent (as opposed to
          not being satisfiable).
        <br />

          This error is returnable by OPEN, CREATE, SETATTR, VERIFY,
          and NVERIFY.
        
</dd>
<dt>NFS4ERR_SCTL_BADENF</dt>
<dd>
          Returned when the the storage_ctl attribute contains
          a enforceable property whose enforce_sc is invalid,
          in that it contain multiple enforcement level bits,
          contains no enforcement level bits, in a context
          in which that is not allowed or contains a set of
          compliance specification bits that is not appropriate
          in the current context. 
        <br />

          This error is returnable by OPEN, CREATE, SETATTR, VERIFY,
          and NVERIFY.
        
</dd>
<dt>NFS4ERR_SCTL_BADDATA</dt>
<dd>
          Returned when the storage_ctl contains a section_sc
          whose PropertyData array does not match the length
          of the properties specified in the associated
          WhichProperties.
        <br />

          This error is returnable by OPEN, CREATE, SETATTR, VERIFY,
          and NVERIFY.
        
</dd>
<dt>NFS4ERR_SCTL_FAIL</dt>
<dd>
          Returned when a required storage_ctl element cannot
          be satisfied.  This is as opposed to the case in which
          it is not being able to be satisfied immediately but 
          is in the process of being satisfied.
        <br />

          This error is returnable by OPEN, CREATE, and SETATTR only.
        
</dd>
</dl></blockquote><p>
    
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Semantic constraints</h3>

<p>
      This section lists the semantic contraints on property 
      specifications.  We will have situations in which the
      attribute will fully match specified XDR specification
      but the specification will not be in line with appropriate 
      contextual constraints.  This section will list those
      constraints, in order to complement the XDR definition
      above.
    
</p>
<p>
      There are four categories of constraints that need to
      be dealt with:
      </p>
<ul class="text">
<li>
          Whether the properties have the associated parameters
          specified.
        
</li>
<li>
          Whether the properties have an associated enforcement
          level specified.
        
</li>
<li>
          Whether the properties have associated compliance level(s)
          specified.
        
</li>
<li>
          Constraints that involve the validity of combinations
          of what are otherwise allowed situations with regard to
          the above.
        
</li>
</ul><p>
    
</p>
<p>
      Each property specifies a particuar value which is invalid 
      and is to be treated as inicateing the absence of property
      parameters (zero values, zero-length arays, etc.).
      Specification of the parameters associated with storage properties
      are generally required and so these special value result in
      NFS4ERR_SCTL_BADPARM being returned.  The only exceptions
      are SETATTR, 
      for which a storage property without parameters serves to 
      delete the corresponding storage propery in the existing
      attribute, and VERIFY/NVERIFY where it is allowed under
      some circumstances, to be discussed below.
    
</p>
<p>
      Specification of the enforcement level is generally required
      for enforceable properties.
      The only exception is VERIFY/NVERIFY where it is allowed under
      some circumstances, to be discussed below.
    
</p>
<p>
      Specification of the compliance status for enforceable properties
      depends on the context in which the properties appears.  For
      OPEN, CREATE, and SETATTR, specification of compliance status is not
      allowed.  VERIFY/NVERIFY specification of multiple compliance
      status values is allowed, subject to the specific combination
      constraints appropriate to VERIFY and NVERIFY as listed below.
      For all other contexts, whether in GETATTR, READDIR, the 
      responses in the NFS4ERR_SCTL_FAIL case, or in the 
      response to the FETCH_SCNOTE operation, 
      specification of compliance status is required but only a
      single compliance status must appear.
    
</p>
<p>
      In addition to the constraints listed above, in the case of
      a storage_ctl attribute within VERIFY/NVERIFY, the properties
      within the attribute must meet the additional constraints
      described in the section <a class='info' href='#VERIFY'>Use of storage_ctl in VERIFY/NVERIFY<span> (</span><span class='info'>Use of storage_ctl in VERIFY/NVERIFY</span><span>)</span></a>
    
</p>
<p>
      When sending responses to GETATTR, READDIR, OPEN, CREATE, and SETATTR,
      the server MUST obey these constraints.  When receiving OPEN,
      SETATTR, VERIFY, and NVERIFY requests that contain the 
      storage_ctl attribute, the server MUST return the error
      NFS4ERR_SCTL_BADENF if the attribute does not follow the
      specified constraints and is otherwise valid (matching the XDR 
      proeprty deinition).
    
</p>
<p>
      These constraints apply to properties introduced by extensions 
      to the storage_ctl attirbute unless explicitly overridden in
      the document defining the extension.  Such a document may add
      other contextual constraints that apply to the properties
      defined by that extension.
    
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Possible Future Work</h3>

<p>
    This document describes a basic framework for storage control and
    a basic set of properties.  It is a base for development of this
    feature and could have considerable additions before incorporation
    in NFSv4 an minor version. On the other hand, the feature is
    intended to be defined with sufficient flexibility that many 
    of these additions to the feature might be done as subsequent
    extensions, after the basic feature is made part of an NFSv4
    minor version.
  
</p>
<p>
    The question of which additions are required for an initial 
    version of the feature, which are best deferred to later and
    which proposed extensions don't really belong is a complex 
    one and will be the a major subject of the development of
    the feature.
  
</p>
<p>
    The following list, illustrates some of the possible additions
    that have had some preliminary discussion.  It is not intended
    to be exhaustive, and the examination of other additions not
    yet thought of is definitely part of the work to be done:
    </p>
<blockquote class="text">
<p>
        Addition of other properties to those in this document,
        that make sense as a basic set of properties, both
        informative and enforceable, for an initial set to be
        part of an NFSv4 minor version.
      
</p>
<p>
        Mechanisms to allow a set of properties to be applied 
        to a large set of files, including those that are
        diretory-based (with inheritance a possible part of 
        the mix), by bulk attribute change on a client-specified
        set of files, or by allowing the client to store some
        set of properties as a persistent object in file
        system, and allowing subsequent storage control attributes
        to reference that persistent object.
      
</p>
<p>
        Mechanisms to enable the client to determine possible
        choices (or ranges) for some properties within the context of
        a given server.  This would be to simplify and 
        streamline property negotation.
      
</p>
<p>
        Mechanisms by which a server could advertise various 
        possible sets of property choices to deal with 
        environments where only there only exists a small
        set of possible choices each effecting a particular
        choice for many properties, as opposed to a case
        where multiple independent property choices are
        possible.
      
</p>
</blockquote><p>
  
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgments</h3>

<p>
    Mike Eisler reviewed early drafts of this work and made important
    contributions in helping define the direction of the effort.
  
</p>
<p>
    David Black reviewed many drafts of this work and made many helpful
    suggestion that improved the quality of the result.
  
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David Noveck</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">EMC</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">228 South St.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Hopkinton, MA  01748</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 508 249 5748</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:david.noveck@emc.com">david.noveck@emc.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Pranoop R. Erasani</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NetApp</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">48980 Oat Grass Terrace</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fremont, CA  94539</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 408 306 2928</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:pranoop@netapp.com">pranoop@netapp.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lakshmi N. Bairavasundaram</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NetApp</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">475 East Java Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sunnyvale, CA  94089</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 408 419 5616</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lakshmib@netapp.com">lakshmib@netapp.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Peng Dai</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vmware</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5 Cambridge Center</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cambridge, MA  02142</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 617 528 7592</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:pdai@vmware.com">pdai@vmware.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Christos Karamonolis</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vmware</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">3401 Hillview Ave.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, CA  94304</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 650 427 2329</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ckaramonolis@vmware.com">ckaramonolis@vmware.com</a></td></tr>
</table>
</body></html>
