<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The RObust Header Compression (ROHC)
    Framework</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The RObust Header Compression (ROHC)
    Framework">
<meta name="keywords" content="I-D">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">K. Sandlund</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">G. Pelletier</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc4995'>4995</a> (if&nbsp;approved)</td><td class="header">Ericsson</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">L-E. Jonsson</td></tr>
<tr><td class="header">Expires: July 17, 2010</td><td class="header">January 13, 2010</td></tr>
</table></td></tr></table>
<h1><br />The RObust Header Compression (ROHC)
    Framework<br />draft-ietf-rohc-rfc4995bis-03</h1>

<h3>Abstract</h3>

<p>The Robust Header Compression (ROHC) protocol provides an efficient,
      flexible, and future-proof header compression concept. It is designed to
      operate efficiently and robustly over various link technologies with
      different characteristics.
</p>
<p>The ROHC framework, along with a set of compression profiles, was
      initially defined in RFC 3095. To improve and simplify the ROHC
      specifications, this document explicitly defines the ROHC framework and
      the profile for uncompressed separately. More specifically, the
      definition of the framework does not modify or update the definition of
      the framework specified by RFC 3095.
</p>
<p>This specification obsoletes RFC 4995. It fixes one interoperability
      issue that was erroneously introduced in RFC 4995, and adds some minor
      clarifications.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on July 17, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Terminology<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.1.</a>&nbsp;
Acronyms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.2.</a>&nbsp;
ROHC Terminology<br />
<a href="#anchor5">3.</a>&nbsp;
Background (Informative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.</a>&nbsp;
Header Compression Fundamentals<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.2.</a>&nbsp;
A Short History of Header Compression<br />
<a href="#anchor8">4.</a>&nbsp;
Overview of Robust Header Compression (ROHC) (Informative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#general_principles">4.1.</a>&nbsp;
General Principles<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.2.</a>&nbsp;
Compression Efficiency, Robustness, and Transparency<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.3.</a>&nbsp;
Developing the ROHC Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.4.</a>&nbsp;
Operational Characteristics of the ROHC Channel<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.5.</a>&nbsp;
Compression and Master Sequence Number (MSN)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.6.</a>&nbsp;
Static and Dynamic Parts of a Context<br />
<a href="#framework_normative">5.</a>&nbsp;
The ROHC Framework (Normative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rohc_channel">5.1.</a>&nbsp;
The ROHC Channel<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cids">5.1.1.</a>&nbsp;
Contexts and Context Identifiers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#channel_parameters">5.1.2.</a>&nbsp;
Per-Channel Parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">5.1.3.</a>&nbsp;
Persistence of Decompressor Contexts<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.2.</a>&nbsp;
ROHC Packets and Packet Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#general_rohc_format">5.2.1.</a>&nbsp;
General Format of ROHC Packets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#padding_octet">5.2.1.1.</a>&nbsp;
Format of the Padding Octet<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.2.1.2.</a>&nbsp;
Format of the Add-CID Octet<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#general_format_header">5.2.1.3.</a>&nbsp;
General Format of Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ir_packet">5.2.2.</a>&nbsp;
Initialization and Refresh (IR) Packet Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.2.2.1.</a>&nbsp;
ROHC IR Header Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.2.2.2.</a>&nbsp;
ROHC IR-DYN Header Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.2.3.</a>&nbsp;
ROHC Initial Decompressor Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.2.4.</a>&nbsp;
ROHC Feedback<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#feedback_format">5.2.4.1.</a>&nbsp;
ROHC Feedback Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rohc_segmentation">5.2.5.</a>&nbsp;
ROHC Segmentation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.2.5.1.</a>&nbsp;
Segmentation Usage Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.2.5.2.</a>&nbsp;
Segmentation Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.3.</a>&nbsp;
General Encoding Methods<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.3.1.</a>&nbsp;
Header Compression CRCs, Coverage and Polynomials<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#8_bit_crcs">5.3.1.1.</a>&nbsp;
8-bit CRCs in IR and IR-DYN Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.3.1.2.</a>&nbsp;
3-bit CRC in Compressed Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.3.1.3.</a>&nbsp;
7-bit CRC in Compressed Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#32_bit_crcs">5.3.1.4.</a>&nbsp;
32-bit Segmentation CRC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sdvl">5.3.2.</a>&nbsp;
Self-Describing Variable-Length Values<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.4.</a>&nbsp;
ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#uncompressed_ir">5.4.1.</a>&nbsp;
IR Packet<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">5.4.2.</a>&nbsp;
Normal Packet<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">5.4.3.</a>&nbsp;
Context Initialization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">5.4.4.</a>&nbsp;
Decompressor Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.4.5.</a>&nbsp;
Feedback<br />
<a href="#anchor32">6.</a>&nbsp;
Overview of a ROHC Profile (Informative)<br />
<a href="#anchor33">7.</a>&nbsp;
Acknowledgments<br />
<a href="#IANA">8.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">9.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#anchor36">Appendix&nbsp;A.</a>&nbsp;
CRC Algorithm<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>For many types of networks, reducing the deployment and operational
      costs by improving the usage of the bandwidth resources is of vital
      importance. Header compression over a link is possible because some of
      the information carried within the header of a packet becomes
      compressible between packets belonging to the same flow.
</p>
<p>For links where the overhead of the IP header(s) is problematic, the
      total size of the header may be significant. Applications carrying data
      carried within RTP <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a> will then, in addition to
      link-layer framing, have an IPv4 <a class='info' href='#RFC0791'>[RFC0791]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> header (20
      octets), a UDP <a class='info' href='#RFC0768'>[RFC0768]<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a> header (8 octets), and an RTP
      header (12 octets), for a total of 40 octets. With IPv6 <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>, the IPv6 header is 40 octets for a total of 60
      octets. Applications transferring data using TCP <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> will have 20 octets for the transport header, for a
      total size of 40 octets for IPv4 and 60 octets for IPv6.
</p>
<p>The relative gain for specific flows (or applications) depends on the
      size of the payload used in each packet. For applications such as
      Voice-over-IP, where the size of the payload containing coded speech can
      be as small as 15-20 octets, this gain will be quite significant.
      Similarly, relative gains for TCP flows carrying large payloads (such as
      file transfers) will be less than for flows carrying smaller payloads
      (such as application signaling, e.g., session initiation).
</p>
<p>As more and more wireless link technologies are being deployed to
      carry IP traffic, care must be taken to address the specific
      characteristics of these technologies within the header compression
      algorithms. Legacy header compression schemes, such as those defined in
      <a class='info' href='#RFC2507'>[RFC2507]<span> (</span><span class='info'>Degermark, M., Nordgren, B., and S. Pink, &ldquo;IP Header Compression,&rdquo; February&nbsp;1999.</span><span>)</span></a> and <a class='info' href='#RFC2508'>[RFC2508]<span> (</span><span class='info'>Casner, S. and V. Jacobson, &ldquo;Compressing IP/UDP/RTP Headers for Low-Speed Serial Links,&rdquo; February&nbsp;1999.</span><span>)</span></a>, have been shown
      to perform inadequately over links where both the lossy behavior and the
      round-trip times are non- negligible, such as those observed for example
      in wireless links and IP tunnels.
</p>
<p>In addition, a header compression scheme should handle the often
      non-trivial residual errors, i.e., where the lower layer may pass a
      packet that contains undetected bit errors to the decompressor. It
      should also handle loss and reordering before the compression point, as
      well as on the link between the compression and decompression points
      <a class='info' href='#RFC4224'>[RFC4224]<span> (</span><span class='info'>Pelletier, G., Jonsson, L-E., and K. Sandlund, &ldquo;RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets,&rdquo; January&nbsp;2006.</span><span>)</span></a>.
</p>
<p>The Robust Header Compression (ROHC) protocol provides an efficient,
      flexible, and future-proof header compression concept. It is designed to
      operate efficiently and robustly over various link technologies with
      different characteristics.
</p>
<p>RFC 3095 <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a> defines the ROHC framework along
      with an initial set of compression profiles. To improve and simplify the
      specification, the framework and the profiles' parts have been split
      into separate documents. This document explicitly defines the ROHC
      framework, but it does not modify or update the definition of the
      framework specified by RFC 3095; both documents can be used
      independently of each other. This also implies that implementations
      based on either definition will be compatible and interoperable with
      each other. However, it is the intent to let this specification replace
      RFC 3095 as the base specification for all profiles defined in the
      future.
</p>
<p>This document fixes one interoperability issue that was erroneously
      introduced in RFC 4995. The fix for this issue is located in
      <a class='info' href='#feedback_format'>Section&nbsp;5.2.4.1<span> (</span><span class='info'>ROHC Feedback Format</span><span>)</span></a> and clarifies the interpretation of
      the Size field in ROHC feedback.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>. 
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Acronyms</h3>

<p>This section lists most acronyms used for reference. </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
ACK    Acknowledgment.
CID    Context Identifier.
CO     Compressed Packet Format.
CRC    Cyclic Redundancy Check.
IR     Initialization and Refresh.
IR-DYN Initialization and Refresh, Dynamic part.
LSB    Least Significant Bit(s).
MRRU   Maximum Reconstructed Reception Unit.
MSB    Most Significant Bit(s).
MSN    Master Sequence Number.
NACK   Negative Acknowledgment.
ROHC   RObust Header Compression.
</pre></div><p>

</p> 
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
ROHC Terminology</h3>

<p>Context<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The context of the compressor is the state it uses to
              compress a header. The context of the decompressor is the state
              it uses to decompress a header. Either of these or the two in
              combination are usually referred to as "context", when it is
              clear which is intended. The context contains relevant
              information from previous headers in the packet flow, such as
              static fields and possible reference values for compression and
              decompression. Moreover, additional information describing the
              packet flow is also part of the context, for example,
              information about the change behavior of fields (e.g., the IP
              Identifier behavior, or the typical inter- packet increase in
              sequence numbers and timestamps).
</dd>
</dl></blockquote>

<p>Context damage<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>When the context of the decompressor is not consistent with
              the context of the compressor, decompression may fail to
              reproduce the original header. This situation can occur when the
              context of the decompressor has not been initialized properly or
              when packets have been lost or damaged between the compressor
              and decompressor. <br />
 Packets which cannot
              be decompressed due to inconsistent contexts are said to be lost
              due to context damage. Packets that are decompressed but contain
              errors due to inconsistent contexts are said to be damaged due
              to context damage.
</dd>
</dl></blockquote>

<p>Context repair mechanism<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Context repair mechanisms are used to resynchronize the
              contexts, an important task since context damage causes loss
              propagation. Examples of such mechanisms are NACK-based
              mechanisms, and the periodic refreshes of important context
              information, usually done in unidirectional operation. There are
              also mechanisms that can reduce the context inconsistency
              probability, for example, repetition of the same type of
              information in multiple packets and CRCs that protect
              context-updating information.
</dd>
</dl></blockquote>

<p>CRC-8 validation<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The CRC-8 validation refers to the validation of the
              integrity against bit error(s) in a received IR and IR-DYN
              header using the 8-bit CRC included in the IR/IR-DYN header.
</dd>
</dl></blockquote>

<p>CRC verification<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The CRC verification refers to the verification of the result
              of a decompression attempt using the 3-bit CRC or 7-bit CRC
              included in the header of a compressed packet format.
</dd>
</dl></blockquote>

<p>Damage propagation<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Delivery of incorrect decompressed headers due to context
              damage, that is, due to errors in (i.e., loss of or damage to)
              previous header(s) or feedback.
</dd>
</dl></blockquote>

<p>Error detection<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Detection of errors by lower layers. If error detection is
              not perfect, there will be residual errors.
</dd>
</dl></blockquote>

<p>Error propagation<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Damage propagation or loss propagation.
</dd>
</dl></blockquote>

<p>ROHC profile<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A ROHC profile is a compression protocol, which specifies how
              to compress specific header combinations. A ROHC profile may be
              tailored to handle a specific set of link characteristics, e.g.,
              loss characteristics, reordering between compression points,
              etc. ROHC profiles provide the details of the header compression
              framework defined in this document, and each compression profile
              is associated with a unique ROHC profile identifier <a class='info' href='#ROHC-ids'>[ROHC&#8209;ids]<span> (</span><span class='info'>IANA Registry, &ldquo;RObust Header Compression (ROHC) Profile Identifiers,&rdquo; 2001.</span><span>)</span></a>. When setting up a ROHC channel, the set of
              profiles supported by both endpoints of the channel is
              negotiated, and when initializing new contexts, a profile
              identifier from this negotiated set is used to associate each
              compression context with one specific profile.
</dd>
</dl></blockquote>

<p>Link<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A physical transmission path that constitutes a single IP
              hop.
</dd>
</dl></blockquote>

<p>Loss propagation<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Loss of headers, due to errors in (i.e., loss of or damage
              to) previous header(s) or feedback.
</dd>
</dl></blockquote>

<p>Packet flow<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A sequence of packets where the field values and change
              patterns of field values are such that the headers can be
              compressed using the same context.
</dd>
</dl></blockquote>

<p>Residual error<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Errors introduced during transmission and not detected by
              lower- layer error detection schemes.
</dd>
</dl></blockquote>

<p>ROHC channel<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A logical unidirectional point-to-point channel carrying ROHC
              packets from one compressor to one decompressor, optionally
              carrying ROHC feedback information on the behalf of another
              compressor-decompressor pair operating on a separate ROHC
              channel in the opposite direction. See also <a class='info' href='#RFC3759'>[RFC3759]<span> (</span><span class='info'>Jonsson, L-E., &ldquo;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples,&rdquo; April&nbsp;2004.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<p>This document also makes use of the conceptual terminology
          defined by "ROHC Terminology and Channel Mapping Examples", RFC 3759
          <a class='info' href='#RFC3759'>[RFC3759]<span> (</span><span class='info'>Jonsson, L-E., &ldquo;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples,&rdquo; April&nbsp;2004.</span><span>)</span></a>.
</p>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Background (Informative)</h3>

<p>This section provides a background to the subject of header
      compression. The fundamental ideas are described together with a
      discussion about the history of header compression schemes. The
      motivations driving the development of the various schemes are discussed
      and their drawbacks identified, thereby providing the foundations for
      the design of the ROHC framework and profiles <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a>.
      
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Header Compression Fundamentals</h3>

<p>Header compression is possible because there is significant
          redundancy between header fields; within the headers of a single
          packet, but in particular between consecutive packets belonging to
          the same flow. On the path end-to-end, the entire header information
          is necessary for all packets in the flow, but over a single link,
          some of this information becomes redundant and can be reduced, as
          long as it is transparently recovered at the receiving end of the
          link. The header size can be reduced by first sending field
          information that is expected to remain static for (at least most of)
          the lifetime of the packet flow. Further compression is achieved for
          the fields carrying information that changes more dynamically by
          using compression methods tailored to their respective assumed
          change behavior.
</p>
<p>To achieve compression and decompression, some necessary
          information from past packets is maintained in a context. The
          compressor and the decompressor update their respective contexts
          upon certain, not necessarily synchronized, events. Impairment
          events may lead to inconsistencies in the decompressor context
          (i.e., context damage), which in turn may cause incorrect
          decompression. A Robust Header Compression scheme needs mechanisms
          to minimize the possibility of context damage, in combination with
          mechanisms for context repair.
</p> 
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
A Short History of Header Compression</h3>

<p>The first header compression scheme, compressed TCP (CTCP) <a class='info' href='#RFC1144'>[RFC1144]<span> (</span><span class='info'>Jacobson, V., &ldquo;Compressing TCP/IP headers for low-speed serial links,&rdquo; February&nbsp;1990.</span><span>)</span></a>, was introduced by Van Jacobson. CTCP, also
          often referred to as VJ compression, compresses the 40 octets of the
          TCP/IP header down to 4 octets. CTCP uses delta encoding for
          sequentially changing fields. The CTCP compressor detects
          transport-level retransmissions and sends a header that updates the
          entire context when they occur. This repair mechanism does not
          require any explicit signaling between the compressor and
          decompressor.
</p>
<p>A general IP header compression scheme, IP header compression
          <a class='info' href='#RFC2507'>[RFC2507]<span> (</span><span class='info'>Degermark, M., Nordgren, B., and S. Pink, &ldquo;IP Header Compression,&rdquo; February&nbsp;1999.</span><span>)</span></a>, improves somewhat on CTCP. IP Header
          Compression (IPHC) can compress arbitrary IP, TCP, and UDP headers.
          When compressing non-TCP headers, IPHC does not use delta encoding
          and is robust. The repair mechanism of CTCP is augmented with
          negative acknowledgments, called CONTEXT_STATE messages, which
          speeds up the repair. This context repair mechanism is thus limited
          by the round-trip time of the link. IPHC does not compress RTP
          headers.
</p>
<p>CRTP <a class='info' href='#RFC2508'>[RFC2508]<span> (</span><span class='info'>Casner, S. and V. Jacobson, &ldquo;Compressing IP/UDP/RTP Headers for Low-Speed Serial Links,&rdquo; February&nbsp;1999.</span><span>)</span></a> is an RTP extension to IPHC. CRTP
          compresses the 40 octets of IPv4/UDP/RTP headers to a minimum of 2
          octets when the UDP Checksum is not enabled. If the UDP Checksum is
          enabled, the minimum CRTP header is 4 octets.
</p>
<p>On lossy links with long round-trip times, CRTP does not perform
          well <a class='info' href='#CRTP-eval'>[CRTP&#8209;eval]<span> (</span><span class='info'>Degermark, M., Hannu, H., Jonsson, L., and K. Svanbro, &ldquo;&quot;Evaluation of CRTP Performance over Cellular Radio           Networks&quot;, IEEE Personal Communication Magazine, Volume 7, number 4,           pp. 20-25, August 2000.,&rdquo; 2000.</span><span>)</span></a>. Each packet lost over the link
          causes decompression of several subsequent packets to fail, because
          the context becomes invalidated during at least one link round-trip
          time from the lost packet. Unfortunately, the large headers that
          CRTP sends when updating the context waste additional bandwidth.
</p>
<p>CRTP uses a local repair mechanism known as TWICE, which was
          introduced by IPHC. TWICE derives its name from the observation that
          when the flow of compressed packets is regular, the correct guess
          when one packet is lost between the compression points is to apply
          the update in the current packet twice. While TWICE improves CRTP
          performance significantly, <a class='info' href='#CRTP-eval'>[CRTP&#8209;eval]<span> (</span><span class='info'>Degermark, M., Hannu, H., Jonsson, L., and K. Svanbro, &ldquo;&quot;Evaluation of CRTP Performance over Cellular Radio           Networks&quot;, IEEE Personal Communication Magazine, Volume 7, number 4,           pp. 20-25, August 2000.,&rdquo; 2000.</span><span>)</span></a> also found
          that even with TWICE, CRTP doubled the number of lost packets.
</p>
<p>An enhanced variant of CRTP, called eCRTP <a class='info' href='#RFC3545'>[RFC3545]<span> (</span><span class='info'>Koren, T., Casner, S., Geevarghese, J., Thompson, B., and P. Ruddy, &ldquo;Enhanced Compressed RTP (CRTP) for Links with High Delay, Packet Loss and Reordering,&rdquo; July&nbsp;2003.</span><span>)</span></a>, means to improve the robustness of CRTP in the
          presence of reordering and packet losses, while keeping the protocol
          almost unchanged from CRTP. As a result, eCRTP does provide better
          means to implement some degree of robustness, albeit at the expense
          of additional overhead, leading to a reduction in compression
          efficiency in comparison to CRTP.
</p>

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Overview of Robust Header Compression (ROHC) (Informative)</h3>

<p>
        
<a name="general_principles"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
General Principles</h3>

<p>As mentioned earlier, header compression is possible per-link due
          to the fact that there is much redundancy between header field
          values within packets, and especially between consecutive packets
          belonging to the same flow. To utilize these properties for header
          compression, there are a few essential steps to consider.
</p>
<p>The first step consists of identifying and grouping packets
          together into different "flows", so that packet-to-packet redundancy
          is maximized in order to improve the compression ratio. Grouping
          packets into flows is usually based on source and destination host
          (IP) addresses, transport protocol type (e.g., UDP or TCP), process
          (port) numbers, and potentially additional unique application
          identifiers, such as the synchronization source (SSRC) in RTP <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>. The compressor and decompressor each establish
          a context for the packet flow and identify the context with a
          Context Identifier (CID) included in each compressed header.
</p>
<p>The second step is to understand the change patterns of the
          various header fields. On a high level, header fields fall into one
          of the following classes:
</p>
<p>
            </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
INFERRED      These fields contain values that can be inferred from
              other fields or external sources, for example, the size
              of the frame carrying the packet can often be derived
              from the link layer protocol, and thus does not have to
              be transmitted by the compression scheme.

STATIC        Fields classified as STATIC are assumed to be constant
              throughout the lifetime of the packet flow.  The value
              of each field is thus only communicated initially.

STATIC-DEF    Fields classified as STATIC-DEF are used to define a
              packet flow as discussed above.  Packets for which
              respective values of these fields differ are treated as
              belonging to different flows.  These fields are in
              general compressed as STATIC fields.

STATIC-KNOWN  Fields classified as STATIC-KNOWN are expected to have
              well-known values, and therefore their values do not
              need to be communicated.

CHANGING      These fields are expected to vary randomly, either
              within a limited value set or range, or in some other
              manner.  CHANGING fields are usually handled in more
              sophisticated ways based on a more detailed
              classification of their expected change patterns.
</pre></div><p>

          
</p>
<p>Finally, the last step is to choose the encoding method(s) that
          will be applied onto different fields based on classification. The
          encoding methods, in combination with the identified field behavior,
          provide the input to the design of the compressed header formats.
          The analysis of the probability distribution of the identified
          change patterns then provides the means to optimize the packet
          formats, where the most frequently occurring change patterns for a
          field should be encoded within the most efficient format(s).
</p>
<p>However, compression efficiency has to be traded against two
          other properties: the robustness of the encoding to losses and
          errors between the compressor and the decompressor, and the ability
          to detect and cope with errors in the decompression process.
</p>

        
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Compression Efficiency, Robustness, and Transparency</h3>

<p>The performance of a header compression protocol can be described
          with three parameters: its compression efficiency, its robustness,
          and its compression transparency.
</p>
<p>Compression efficiency<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The compression efficiency is determined by how much the
              average header size is reduced by applying the compression
              protocol.
</dd>
</dl></blockquote>

<p>Robustness<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A robust protocol tolerates packet losses, residual bit
              errors, and out-of-order delivery on the link over which header
              compression takes place, without losing additional packets or
              introducing additional errors in decompressed headers.
</dd>
</dl></blockquote>

<p>Compression transparency<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The compression transparency is a measure of the extent to
              which the scheme maintains the semantics of the original
              headers. If all decompressed headers are bitwise identical to
              the corresponding original headers, the scheme is
              transparent.
</dd>
</dl></blockquote>


        
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Developing the ROHC Protocol</h3>

<p>The challenge in developing a header compression protocol is to
          conciliate compression efficiency and robustness while maintaining
          transparency, as increasing robustness will always come at the
          expense of a lower compression efficiency, and vice-versa. The
          scheme should also be flexible enough in its design to minimize the
          impacts from the varying round-trip times and loss patterns of links
          where header compression will be used.
</p>
<p>To achieve this, the header compression scheme must provide
          facilities for the decompressor to verify decompression and detect
          potential context damage, as well as context recovery mechanisms
          such as feedback. Header compression schemes prior to the ones
          developed by the Robust Header Compression (ROHC) WG were not
          designed with the above high-level objectives in mind.
</p>
<p>The ROHC WG has developed header compression solutions to meet
          the needs of present and future link technologies. While special
          attention has been put towards meeting the more stringent
          requirements stemming from the characteristics of wireless links,
          the results are equally applicable to many other link
          technologies.
</p>
<p>RFC 3095 <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a>, "RObust Header Compression
          (ROHC): Framework and four profiles: RTP, UDP, ESP, and
          uncompressed", was published in 2001, as the first output of the
          ROHC WG. ROHC is a general and extendable framework for header
          compression, on top of which profiles can be defined for compression
          of different protocols headers. RFC 3095 introduced a number of new
          compression techniques, and was successful at living up to the
          requirements placed on it, as described in <a class='info' href='#RFC3096'>[RFC3096]<span> (</span><span class='info'>Degermark, M., &ldquo;Requirements for robust IP/UDP/RTP header compression,&rdquo; July&nbsp;2001.</span><span>)</span></a>.
</p>
<p>Interoperability testing of RFC 3095 confirms the capabilities of
          ROHC to meet its purposes, but feedback from implementers has also
          indicated that the protocol specification is complex and sometimes
          obscure. Most importantly, a clear distinction between framework and
          profiles is not obvious in <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a>, which also
          makes development of additional profiles troublesome. This document
          therefore aims at explicitly specifying the ROHC framework, while a
          companion document <a class='info' href='#RFC5225'>[RFC5225]<span> (</span><span class='info'>Pelletier, G. and K. Sandlund, &ldquo;RObust Header Compression Version 2 (ROHCv2): Profiles for           RTP, UDP, IP, ESP and UDP-Lite,&rdquo; April&nbsp;2008.</span><span>)</span></a> specifies revised
          versions of the compression profiles of RFC 3095.
</p>

        
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Operational Characteristics of the ROHC Channel</h3>

<p>Robust header compression can be used over many type of link
          technologies. The ROHC framework provides flexibility for profiles
          to address a wide range of applications, and this section lists some
          of the operational characteristics of the ROHC channel (see also
          <a class='info' href='#RFC3759'>[RFC3759]<span> (</span><span class='info'>Jonsson, L-E., &ldquo;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples,&rdquo; April&nbsp;2004.</span><span>)</span></a>).
</p>
<p>Multiplexing over a single logical channel<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The ROHC channel provides a mechanism to identify a context
              within the general ROHC packet format. The CID makes it possible
              for a logical channel that supports ROHC to transport multiple
              header- compressed flows, while still making it possible for a
              channel to be dedicated to one single packet flow without any
              CID overhead. More specifically, ROHC uses a distinct context
              identifier space per logical channel, and the context identifier
              can be omitted for one of the flows over the ROHC channel when
              configured to use a small CID space.
</dd>
</dl></blockquote>

<p>Establishment of channel parameters<br />

          </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A link layer defining support for the ROHC channel must
              provide the means to establish header compression channel
              parameters (see <a class='info' href='#rohc_channel'>Section&nbsp;5.1<span> (</span><span class='info'>The ROHC Channel</span><span>)</span></a>). This can be
              achieved through a negotiation mechanism, static provisioning,
              or some out-of-band signaling.
</dd>
</dl></blockquote>

<p>Packet type identification<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The ROHC channel defines a packet type identifier space, and
              puts restrictions with respect to the use of a number of
              identifiers that are common for all ROHC profiles. Identifiers
              that have no restrictions, i.e., identifiers that are not
              defined by this document, are available to each profile. The
              identifier is part of each compressed header, and this makes it
              possible for the link that supports the ROHC channel to allocate
              one single link layer payload type for ROHC.
</dd>
</dl></blockquote>

<p>Out-of-order delivery between compression endpoints<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>Each profile defines its own level of robustness, including
              tolerance to reordering of packets before but especially between
              compression endpoints, if any. <br />
 For
              profiles specified in <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a>, the channel
              between the compressor and decompressor is required to maintain
              in-order delivery of the packets, i.e., the definition of these
              profiles assumes that the decompressor always receives packets
              in the same order as the compressor sent them. The impacts of
              reordering on the performance of these profiles is described in
              <a class='info' href='#RFC4224'>[RFC4224]<span> (</span><span class='info'>Pelletier, G., Jonsson, L-E., and K. Sandlund, &ldquo;RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets,&rdquo; January&nbsp;2006.</span><span>)</span></a>. However, reordering before the
              compression point is handled, i.e., these profiles make no
              assumption that the compressor will receive packets in-order.
              <br />
<br />
 For the ROHCv2 profiles specified in
              <a class='info' href='#RFC5225'>[RFC5225]<span> (</span><span class='info'>Pelletier, G. and K. Sandlund, &ldquo;RObust Header Compression Version 2 (ROHCv2): Profiles for           RTP, UDP, IP, ESP and UDP-Lite,&rdquo; April&nbsp;2008.</span><span>)</span></a>, their definitions assume that the
              decompressor can receive packets out-of-order, i.e., not in the
              same order that the compressor sent them. Reordering before the
              compression point is also dealt with.
</dd>
</dl></blockquote>

<p>Duplication of packets<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The link supporting the ROHC channel is required to not
              duplicate packets (however, duplication of packets can occur
              before they reach the compressor, i.e., there is no assumption
              that the compressor will receive only one copy of each
              packet).
</dd>
</dl></blockquote>

<p>Framing<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The link layer must provide framing that makes it possible to
              distinguish frame boundaries and individual frames.
</dd>
</dl></blockquote>

<p>Error detection/protection<br />
 </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>ROHC profiles should be designed to cope with residual errors
              in the headers delivered to the decompressor. CRCs are used to
              detect decompression failures and to prevent or reduce damage
              propagation. However, it is recommended that lower layers deploy
              error detection for ROHC headers and that ROHC headers with high
              residual error rates not be delivered.
</dd>
</dl></blockquote>


        
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Compression and Master Sequence Number (MSN)</h3>

<p>Compression of header fields is based on the establishment of a
          function to a sequence number, called the master sequence number
          (MSN). This function describes the change pattern of the field with
          respect to a change in the MSN.
</p>
<p>Change patterns include, for example, fields that increase
          monotonically or by a small value, fields that seldom change,and
          fields that remain unchanging for the entire lifetime of the packet
          flow, in which case the function to the MSN is equivalent to a
          constant value.
</p>
<p>The compressor first establishes functions for each of the header
          fields, and then reliably communicates the MSN. When the change
          pattern of the field does not match the established function, i.e.,
          the existing function gives a result that is different from the
          field in the header being compressed, additional information can be
          sent to update the parameters of that function.
</p>
<p>The MSN is defined per profile. It can be either derived directly
          from one of the fields of the protocol being compressed (e.g., the
          RTP SN <a class='info' href='#RFC5225'>[RFC5225]<span> (</span><span class='info'>Pelletier, G. and K. Sandlund, &ldquo;RObust Header Compression Version 2 (ROHCv2): Profiles for           RTP, UDP, IP, ESP and UDP-Lite,&rdquo; April&nbsp;2008.</span><span>)</span></a>), or it can be created and
          maintained by the compressor (e.g., the MSN for compression of UDP
          in profile 0x0102 <a class='info' href='#RFC5225'>[RFC5225]<span> (</span><span class='info'>Pelletier, G. and K. Sandlund, &ldquo;RObust Header Compression Version 2 (ROHCv2): Profiles for           RTP, UDP, IP, ESP and UDP-Lite,&rdquo; April&nbsp;2008.</span><span>)</span></a> or the MSN in ROHC-TCP
          <a class='info' href='#RFC4996'>[RFC4996]<span> (</span><span class='info'>Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West, &ldquo;RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP),&rdquo; July&nbsp;2007.</span><span>)</span></a>).
</p>

        
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Static and Dynamic Parts of a Context</h3>

<p>A compression context can be conceptually divided into two
          different parts, the static context and the dynamic context, each
          based on the properties of the fields that are being compressed.
</p>
<p>The static part includes the information necessary to compress
          and decompress the fields whose change behavior is classified as
          STATIC, STATIC-KNOWN, or STATIC-DEF (as described in <a class='info' href='#general_principles'>Section&nbsp;4.1<span> (</span><span class='info'>General Principles</span><span>)</span></a> above).
</p>
<p>The dynamic part includes the state maintained for all the other
          fields, i.e., those that are classified as CHANGING.
</p>
      

<a name="framework_normative"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
The ROHC Framework (Normative)</h3>

<p>This section normatively defines the parts common to all ROHC
      profiles, i.e., the framework. The framework specifies the requirements
      and functionality of the ROHC channel, including how to handle multiple
      compressed packet flows over the same channel.
</p>
<p>Finally, this section specifies encoding methods used in the packet
      formats that are common to all profiles. These encoding methods may be
      reused within profile specifications for encoding fields in
      profile-specific parts of a packet format, without requiring their
      redefinition. 
<a name="rohc_channel"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
The ROHC Channel</h3>

<p>
            
<a name="cids"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Contexts and Context Identifiers</h3>

<p>Associated with each compressed flow is a context. The
              context is the state that the compressor and the decompressor
              maintain in order to correctly compress or decompress the
              headers of the packet in the flow. Each context is identified
              using a CID.
</p>
<p>A context is considered to be a new context when the CID is
              associated with a profile for the first time since the creation
              of the ROHC channel, or when the CID gets associated from the
              reception of an IR (this does not apply to the IR-DYN) with a
              different profile than the profile in the context.
</p>
<p>Context information is conceptually kept in a table. The
              context table is indexed using the CID, which is sent along with
              compressed headers and feedback information.
</p>
<p>The CID space can be either small, which means that CIDs can
              take the values 0 through 15, or large, which means that CIDs
              take values between 0 and 2^14 - 1 = 16383. Whether the CID
              space is large or small MUST be established, possibly by
              negotiation, before any compressed packet may be sent over the
              ROHC channel.
</p>
<p>The CID space is distinct for each channel, i.e., CID 3 over
              channel A and CID 3 over channel B do not refer to the same
              context, even if the endpoints of A and B are the same nodes. In
              particular, CIDs for any pair of ROHC channels are not related
              (two associated ROHC channels serving as feedback channels for
              one another do not even need to have CID spaces of the same
              size).
</p>

            
<a name="channel_parameters"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Per-Channel Parameters</h3>

<p>The ROHC channel is based on a number of parameters that form
              part of the established channel state and the per-context state.
              The state of the ROHC channel MUST be established before the
              first ROHC packet may be sent, which may be achieved using
              negotiation protocols provided by the link layer (see also <a class='info' href='#RFC3241'>[RFC3241]<span> (</span><span class='info'>Bormann, C., &ldquo;Robust Header Compression (ROHC) over PPP,&rdquo; April&nbsp;2002.</span><span>)</span></a>, which describes an option for negotiation
              of ROHC parameters for PPP). This section describes some of this
              channel state information in an abstract way:
</p>
<p>LARGE_CIDS: Boolean; if false, the small CID representation
              (0 octets or 1 prefix octet, covering CID 0 to 15) is used; if
              true, the large CID representation (1 or 2 embedded CID octets
              covering CID 0 to 16383) is used. See also <a class='info' href='#cids'>Section&nbsp;5.1.1<span> (</span><span class='info'>Contexts and Context Identifiers</span><span>)</span></a> and <a class='info' href='#general_format_header'>Section&nbsp;5.2.1.3<span> (</span><span class='info'>General Format of Header</span><span>)</span></a>.
</p>
<p>MAX_CID: Non-negative integer; highest CID number to be used
              by the compressor (note that this parameter is not coupled to,
              but in effect further constrained by, LARGE_CIDS). This value
              represents an agreement by the decompressor that it can provide
              sufficient memory resources to host at least MAX_CID+1 contexts;
              the decompressor MUST maintain established contexts within this
              space until either the CID gets re-used by the establishment of
              a new context, or until the channel is taken down.
</p>
<p>PROFILES: Set of non-negative integers, where each integer
              indicates a profile supported by both the compressor and the
              decompressor. A profile is identified by a 16-bit value, where
              the 8 LSB bits indicate the actual profile, and the 8 MSB bits
              indicate the variant of that profile. The ROHC compressed header
              format identifies the profile used with only the 8 LSB bits;
              this means that if multiple variants of the same profile are
              available for a ROHC channel, the PROFILES set after negotiation
              MUST NOT include more than one variant of the same profile. The
              compressor MUST NOT compress using a profile that is not in
              PROFILES.
</p>
<p>FEEDBACK_FOR: Optional reference to a ROHC channel in the
              opposite direction between the same compression endpoints. If
              provided, this parameter indicates to which other ROHC channel
              any feedback sent on this ROHC channel refers (see <a class='info' href='#RFC3759'>[RFC3759]<span> (</span><span class='info'>Jonsson, L-E., &ldquo;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples,&rdquo; April&nbsp;2004.</span><span>)</span></a>).
</p>
<p>MRRU: Non-negative integer. Maximum Reconstructed Reception
              Unit. This is the size of the largest reconstructed unit in
              octets that the decompressor is expected to reassemble from
              segments (see <a class='info' href='#rohc_segmentation'>Section&nbsp;5.2.5<span> (</span><span class='info'>ROHC Segmentation</span><span>)</span></a>). This size
              includes the segmentation CRC. If MRRU is negotiated to be 0,
              segmentation MUST NOT be used on the channel, and received
              segments MUST be discarded by the decompressor.
</p>

            
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
Persistence of Decompressor Contexts</h3>

<p>As part of the negotiated channel parameters, the compressor
              and decompressor have through the MAX_CID parameter agreed on
              the highest context identification (CID) number to be used. By
              agreeing on the MAX_CID, the decompressor also agrees to provide
              memory resources to host at least MAX_CID+1 contexts, and an
              established context with a CID within this negotiated space
              SHOULD be kept by the decompressor until either the CID gets
              re-used, or the channel is taken down or re-negotiated.
</p>
          
 
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
ROHC Packets and Packet Types</h3>

<p>This section uses the following convention in the diagrams when
          representing various ROHC packet types, formats, and fields: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      - colons ":" indicate that the part is optional
      - slashes "/" indicate variable length
</pre></div><p>

</p>
<p>The ROHC packet type indication scheme has been designed to
          provide optional padding, a feedback packet type, an optional
          Add-CID octet (which includes 4 bits of CID), and a simple
          segmentation and reassembly mechanism.
</p>
<p>The following packet types are reserved at the ROHC framework
          level: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      11100000 : Padding
      1110nnnn : Add-CID octet (nnnn=CID with values 0x1 through 0xF)
      11110    : Feedback
      11111000 : IR-DYN packet
      1111110  : IR packet
      1111111  : Segment
</pre></div><p>

</p>
<p>Other packet types can be defined and used by individual
          profiles: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      0        : available (not reserved by ROHC framework)
      10       : available (not reserved by ROHC framework)
      110      : available (not reserved by ROHC framework)
      1111101  : available (not reserved by ROHC framework)
      11111001 : available (not reserved by ROHC framework)
</pre></div><p>
 
<a name="general_rohc_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
General Format of ROHC Packets</h3>

<p>A ROHC packet has the following general format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    --- --- --- --- --- --- --- ---
   :           Padding             :
    --- --- --- --- --- --- --- ---
   :           Feedback            :
    --- --- --- --- --- --- --- ---
   :            Header             :
    --- --- --- --- --- --- --- ---
   :           Payload             :
    --- --- --- --- --- --- --- ---
</pre></div><p>

</p>
<p>Padding: Any number (zero or more) of padding octets, where
              the format of a padding octet is as defined in <a class='info' href='#padding_octet'>Section&nbsp;5.2.1.1<span> (</span><span class='info'>Format of the Padding Octet</span><span>)</span></a>.
</p>
<p>Feedback: Any number (zero or more) of feedback elements,
              where the format of a feedback element is as defined in <a class='info' href='#feedback_format'>Section&nbsp;5.2.4.1<span> (</span><span class='info'>ROHC Feedback Format</span><span>)</span></a>.
</p>
<p>Header: Either a profile-specific CO header (see <a class='info' href='#general_format_header'>Section&nbsp;5.2.1.3<span> (</span><span class='info'>General Format of Header</span><span>)</span></a>), an IR or IR-DYN header (see
              <a class='info' href='#ir_packet'>Section&nbsp;5.2.2<span> (</span><span class='info'>Initialization and Refresh (IR) Packet Types</span><span>)</span></a>), or a ROHC Segment (see <a class='info' href='#rohc_segmentation'>Section&nbsp;5.2.5<span> (</span><span class='info'>ROHC Segmentation</span><span>)</span></a>). There can be at most one Header
              in a ROHC packet, but it may also be omitted (if the packet
              contains Feedback only).
</p>
<p>Payload: Corresponds to zero or more octets of payload from
              the uncompressed packet, starting with the first octet in the
              uncompressed packet after the last header compressible by the
              current profile.
</p>
<p>At least one of Feedback or Header MUST be present. 
<a name="padding_octet"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1.1"></a><h3>5.2.1.1.&nbsp;
Format of the Padding Octet</h3>

<p>Padding octet: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0   0   0   0   0 |
   +---+---+---+---+---+---+---+---+
</pre></div><p>
 Note: The Padding octet MUST NOT be interpreted
                  as an Add-CID octet for CID 0.
</p> 
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1.2"></a><h3>5.2.1.2.&nbsp;
Format of the Add-CID Octet</h3>

<p>Add-CID octet: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 |      CID      |
   +---+---+---+---+---+---+---+---+
</pre></div><p>
 CID: 0x1 through 0xF indicates CIDs 1 through
                  15.
</p>
<p>Note: The Padding octet looks like an Add-CID octet for
                  CID 0.
</p> 
<a name="general_format_header"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1.3"></a><h3>5.2.1.3.&nbsp;
General Format of Header</h3>

<p>All ROHC packet types have the following general Header
                  format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0              x-1  x       7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         :  if CID 1-15 and small CIDs
   +--- --- --- --- ---+--- --- ---+
   | type indication   |   body    |  1 octet (8-x bits of body)
   +--- --- --- --- ---+--- --- ---+
   :                               :
   /    0, 1, or 2 octets of CID   /  1 or 2 octets if large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   /             body              /  variable length
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>type indication: ROHC packet type.
</p>
<p>body: Interpreted according to the packet type indication
                  and CID information, as defined by individual profiles.
</p>
<p>Thus, the header either starts with a packet type
                  indication or has a packet type indication immediately
                  following an Add-CID octet.
</p>
<p>When the ROHC channel is configured with a small CID
                  space:</p>
<ul class="text">
<li>If an Add-CID immediately precedes the packet type
                      indication, the packet has the CID of the Add-CID;
                      otherwise, it has CID 0.
</li>
<li>A small CID with the value 0 is represented using
                      zero bits; therefore, a flow associated with CID 0 has
                      no CID overhead in the compressed header. In such case,
                      Header starts with a packet type indication.
</li>
<li>A small CID with a value from 1 to 15 is represented
                      using the Add-CID octet as described above. The Header
                      starts with the Add-CID octet, followed by a packet type
                      indication.
</li>
<li>There is no large CID in the Header.
</li>
</ul>

<p>When the ROHC channel is configured with a large CID
                  space:</p>
<ul class="text">
<li>The large CID is always present and is represented
                      using the encoding scheme of <a class='info' href='#sdvl'>Section&nbsp;5.3.2<span> (</span><span class='info'>Self-Describing Variable-Length Values</span><span>)</span></a>,
                      limited to two octets. In this case, the Header starts
                      with a packet type indication.
</li>
</ul>

 
<a name="ir_packet"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Initialization and Refresh (IR) Packet Types</h3>

<p>IR packet types contain a profile identifier, which
              determines how the rest of the header is to be interpreted. They
              also associate a profile with a context. The stored profile
              parameter further determines the syntax and semantics of the
              packet type identifiers and packet types used with a specific
              context.
</p>
<p>The IR and IR-DYN packets always update the context for all
              context- updating fields carried in the header. They never clear
              the context, except when initializing a new context (see <a class='info' href='#cids'>Section&nbsp;5.1.1<span> (</span><span class='info'>Contexts and Context Identifiers</span><span>)</span></a>), or unless the profile indicated in the
              Profile field specifies otherwise. 
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.1"></a><h3>5.2.2.1.&nbsp;
ROHC IR Header Format</h3>

<p>The IR header associates a CID with a profile, and
                  typically also initializes the context. It can typically
                  also refresh all (or parts of) the context. For IR, Header
                  has the following general format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         :  if CID 1-15 and small CID
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | x |  IR type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        /  1 or 2 octets if large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   / profile specific information  /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>x: Profile specific information. Interpreted according to
                  the profile indicated in the Profile field of the IR
                  header.
</p>
<p>Profile: The profile associated with the CID. In the IR
                  header, the profile identifier is abbreviated to the 8 least
                  significant bits (see <a class='info' href='#channel_parameters'>Section&nbsp;5.1.2<span> (</span><span class='info'>Per-Channel Parameters</span><span>)</span></a>).
</p>
<p>CRC: 8-bit CRC (see <a class='info' href='#8_bit_crcs'>Section&nbsp;5.3.1.1<span> (</span><span class='info'>8-bit CRCs in IR and IR-DYN Headers</span><span>)</span></a>).
</p>
<p>Profile specific information: The content of this part of
                  the IR header is defined by the individual profiles. It is
                  interpreted according to the profile indicated in the
                  Profile field.
</p> 
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2.2"></a><h3>5.2.2.2.&nbsp;
ROHC IR-DYN Header Format</h3>

<p>In contrast to the IR header, the IR-DYN header can never
                  initialize a non-initialized context. However, it can
                  redefine what profile is associated with a context, if the
                  profile indicated in the IR-DYN header allows this. Thus,
                  this packet type is also reserved at the framework level.
                  The IR-DYN header typically also initializes or refreshes
                  parts of a context. For IR-DYN, Header has the following
                  general format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         :  if CID 1-15 and small CID
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0   0   0 |  IR-DYN type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        /  1 or 2 octets if large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   / profile specific information  /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>Profile: The profile associated with the CID. This is
                  abbreviated in the same way as in IR packets.
</p>
<p>CRC: 8-bit CRC (see <a class='info' href='#8_bit_crcs'>Section&nbsp;5.3.1.1<span> (</span><span class='info'>8-bit CRCs in IR and IR-DYN Headers</span><span>)</span></a>).
</p>
<p>Profile specific information: The content of this part of
                  the IR-DYN header is defined by the individual profiles. It
                  is interpreted according to the profile indicated in the
                  Profile field.
</p>
 
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
ROHC Initial Decompressor Processing</h3>

<p>Initially, all contexts are in no context state. Thus, all
              packets referencing a non-initialized context, except packets
              that have enough information on the static fields, cannot be
              decompressed by the decompressor.
</p>
<p>When the decompressor receives a packet of type IR, the
              profile indicated in the IR packet determines how it is to be
              processed.</p>
<ul class="text">
<li>If the 8-bit CRC fails to verify the integrity of the
                  Header, the packet MUST NOT be decompressed and delivered to
                  upper layers. If a profile is indicated in the context, the
                  logic of that profile determines what, if any, feedback is
                  to be sent. If no profile is noted in the context, the logic
                  used to determine what, if any, feedback to send is up to
                  the implementation. However, it may be suitable to take no
                  further actions, as any part of the IR header covered by the
                  CRC may have caused the failure.
</li>
</ul>

<p>When the decompressor receives a packet of type IR-DYN, the
              profile indicated in the IR-DYN packet determines how it is to
              be processed.</p>
<ul class="text">
<li>If the 8-bit CRC fails to verify the integrity of the
                  header, the packet MUST NOT be decompressed and delivered to
                  upper layers. If a profile is indicated in the context, the
                  logic of that profile determines what, if any, feedback is
                  to be sent. If no profile is noted in the context, the logic
                  used to determine what, if any, feedback to send is up to
                  the implementation. However, it may be suitable to take no
                  further actions, as any part of the IR-DYN header covered by
                  the CRC may have caused the failure.
</li>
<li>If the context has not already been initialized, the
                  packet MUST NOT be decompressed and delivered to upper
                  layers. The logic of the profile indicated in the IR-DYN
                  header (if verified by the 8-bit CRC), determines what, if
                  any, feedback is to be sent.
</li>
</ul>

<p>If a parsing error occurs for any packet type, the
              decompressor MUST discard the packet without further processing.
              For example, a CID field is present in the compressed header
              when the large CID space is used for the ROHC channel, and the
              field is coded using the self- describing variable-length
              encoding of <a class='info' href='#sdvl'>Section&nbsp;5.3.2<span> (</span><span class='info'>Self-Describing Variable-Length Values</span><span>)</span></a>; if the field starts with 110
              or 111, this would generate a parsing error for the decompressor
              because this field must not be encoded with a size larger than 2
              octets.
</p>
<p>It is RECOMMENDED that profiles disallow the decompressor to
              make a decompression attempt for packets carrying only a 3-bit
              CRC after it has invalidated some or all of the entire dynamic
              context, until a packet that contains sufficient information on
              the dynamic fields is received, decompressed, and successfully
              verified by a 7- or 8-bit CRC.
</p> 
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
ROHC Feedback</h3>

<p>Feedback carries information from the decompressor to the
              compressor. Feedback can be sent over a ROHC channel that
              operates in the same direction as the feedback.
</p>
<p>The general ROHC packet format allows transport of feedback
              using interspersion or piggybacking (see <a class='info' href='#RFC3759'>[RFC3759]<span> (</span><span class='info'>Jonsson, L-E., &ldquo;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples,&rdquo; April&nbsp;2004.</span><span>)</span></a>), or a combination of both, over a ROHC
              channel. This is facilitated by the following properties:
</p>
<p>Reserved packet type:</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>A feedback packet type is reserved at the framework
                  level. The packet type can carry variable-length feedback
                  information.
</dd>
</dl></blockquote>

<p>CID information:</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The feedback information sent on a particular channel is
                  passed to, and interpreted by, the compressor associated
                  with feedback on that channel. Thus, each feedback element
                  contains CID information from the channel for which the
                  feedback is sent. The ROHC feedback scheme thus requires
                  that a channel carries feedback to at most one compressor.
                  How a compressor is associated with the feedback for a
                  particular channel is outside the scope of this
                  specification. See also <a class='info' href='#RFC3759'>[RFC3759]<span> (</span><span class='info'>Jonsson, L-E., &ldquo;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples,&rdquo; April&nbsp;2004.</span><span>)</span></a>.
</dd>
</dl></blockquote>

<p>Length information:</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>The length of a feedback element can be determined by
                  examining the first few octets of the feedback. This enables
                  piggybacking of feedback, and also the concatenation of more
                  than one feedback element in a packet. The length
                  information thus decouples the decompressor from the
                  associated same-side compressor, as the decompressor can
                  extract the feedback information from the compressed header
                  without parsing its content and hand over the extracted
                  information.
</dd>
</dl></blockquote>

<p>The association between compressor-decompressor pairs
              operating in opposite directions, for the purpose of exchanging
              piggyback and/or interspersed feedback, SHOULD be maintained for
              the lifetime of the ROHC channel. Otherwise, it is RECOMMENDED
              that the compressor be notified if the feedback channel is no
              longer available: the compressor SHOULD then restart compression
              by creating a new context for each packet flow, and SHOULD use a
              CID value that was not previously associated with the profile
              used to compress the flow.
</p>
<a name="feedback_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4.1"></a><h3>5.2.4.1.&nbsp;
ROHC Feedback Format</h3>

<p>ROHC defines three different categories of feedback
                messages: acknowledgment (ACK), negative ACK (NACK), and NACK
                for the entire context (STATIC-NACK). Other types of
                information may be defined in profile-specific feedback
                information.
</p>
<p>
                  </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>ACK: Acknowledges successful decompression of a packet.
                    Indicates that the decompressor considers its context to
                    be valid.
</dd>
<dt></dt>
<dd>NACK: Indicates that the decompressor considers some or
                    all of the dynamic part of its context invalid.
</dd>
<dt></dt>
<dd>STATIC-NACK : Indicates that the decompressor considers
                    its entire static context invalid, or that it has not been
                    established.
</dd>
</dl></blockquote><p>
                
</p>
<p>Feedback sent on a ROHC channel consists of one or more
                concatenated feedback elements, where each feedback element
                has the following format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   0 |   Code    |  feedback type
   +---+---+---+---+---+---+---+---+
   :             Size              :  if Code = 0
   +---+---+---+---+---+---+---+---+
   :         Add-CID octet         :  if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   :                               :
   /           large CID           /  1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   /         FEEDBACK data         /  variable length
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>Code:</p>
<blockquote class="text"><dl>
<dt></dt>
<dd>0 indicates that a Size octet is present.
</dd>
<dt></dt>
<dd>1-7 indicates the total size of the FEEDBACK data field
                    and the CID field (if any), in octets.
</dd>
</dl></blockquote>

<p>Size: Indicates the total size of the FEEDBACK data field
                and the CID field (if any), in octets.
</p>
<p>FEEDBACK data: FEEDBACK-1 or FEEDBACK-2 (see below).
</p>
<p>CID information in a feedback element indicates the context
                for which feedback is sent. The LARGE_CIDS parameter that
                controls whether a large CID is present is taken from the
                channel state of the receiving compressor's channel, not from
                the state of the channel carrying the feedback.
</p>
<p>The large CID field, if present, is encoded according to
                <a class='info' href='#sdvl'>Section&nbsp;5.3.2<span> (</span><span class='info'>Self-Describing Variable-Length Values</span><span>)</span></a>, and it MUST NOT be encoded using more
                than 2 octets.
</p>
<p>The FEEDBACK data field can have either of the following
                two formats:
</p>
<p>FEEDBACK-1: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | profile specific information  |  1 octet
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>FEEDBACK-2: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype|                       |
   +---+---+   profile specific    /  at least 2 octets
   /             information       |
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>
                  </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Acktype:  0 = ACK
             1 = NACK
             2 = STATIC-NACK
             3 is reserved (MUST NOT be used.  Otherwise unparseable.)
</pre></div><p>

                
</p> 
<a name="rohc_segmentation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.5"></a><h3>5.2.5.&nbsp;
ROHC Segmentation</h3>

<p>ROHC defines a simple segmentation protocol. The compressor
              may perform segmentation, e.g., to accommodate packets that are
              larger than a specific size configured for the channel. 
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.5.1"></a><h3>5.2.5.1.&nbsp;
Segmentation Usage Considerations</h3>

<p>The ROHC segmentation protocol is not particularly
                  efficient. It is not intended to replace link layer
                  segmentation functions; these SHOULD be used whenever
                  available and efficient for the task at hand.
</p>
<p>The ROHC segmentation protocol has been designed with an
                  assumption of in-order delivery of packets between the
                  compressor and the decompressor, using only a CRC for error
                  detection, and no sequence numbers. If in-order delivery
                  cannot be guaranteed, ROHC segmentation MUST NOT be
                  used.
</p>
<p>The segmentation protocol also assumes that all segments
                  of a ROHC packet corresponding to one context are received
                  without interference from other ROHC packets over the
                  channel, including any ROHC packet corresponding to a
                  different context. Based on this assumption, segments do not
                  carry CID information, and therefore cannot be associated
                  with a specific context until all segments have been
                  received and the whole unit has been reconstructed.
</p> 
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.5.2"></a><h3>5.2.5.2.&nbsp;
Segmentation Protocol</h3>

<p>ROHC segmentation is applied to the combination of the
                  Header and the Payload fields of the ROHC packet, as defined
                  in <a class='info' href='#general_rohc_format'>Section&nbsp;5.2.1<span> (</span><span class='info'>General Format of ROHC Packets</span><span>)</span></a>.
</p>
<p>Segment format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   1 | F |  segment type
   +---+---+---+---+---+---+---+---+
   /           Segment             /  variable length
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>F: Final bit. If set, it indicates that this is the last
                  segment of a reconstructed unit.
</p>
<p>Padding and/or Feedback may precede the segment type
                  octet. There is no per-segment CID, but CID information is
                  of course part of the reconstructed unit. The reconstructed
                  unit MUST NOT contain padding, segments, or feedback.
</p>
<p>When a final segment is received, the decompressor
                  reassembles the segment carried in this packet and any
                  non-final segments that immediately preceded it into a
                  single reconstructed unit, in the order they were received.
                  All segments for one reconstructed unit have to be received
                  consecutively and in the correct order by the decompressor.
                  If a non-segment ROHC packet directly follows a non- final
                  segment, the reassembly of the current reconstructed unit is
                  aborted and the decompressor MUST discard the non-final
                  segments so far received on this channel.
</p>
<p>Reconstructed unit: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   /            Header             /
   +---+---+---+---+---+---+---+---+
   :            Payload            :
   +---+---+---+---+---+---+---+---+
   /              CRC              /  4 octets
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>Header: See <a class='info' href='#general_rohc_format'>Section&nbsp;5.2.1<span> (</span><span class='info'>General Format of ROHC Packets</span><span>)</span></a>
</p>
<p>Payload: See <a class='info' href='#general_rohc_format'>Section&nbsp;5.2.1<span> (</span><span class='info'>General Format of ROHC Packets</span><span>)</span></a>
</p>
<p>CRC: 32-bit CRC computed using the polynomial of <a class='info' href='#32_bit_crcs'>Section&nbsp;5.3.1.4<span> (</span><span class='info'>32-bit Segmentation CRC</span><span>)</span></a>
</p>
<p>If the reconstructed unit is 4 octets or less, or if the
                  CRC fails, or if it is larger than the channel parameter
                  MRRU (see <a class='info' href='#channel_parameters'>Section&nbsp;5.1.2<span> (</span><span class='info'>Per-Channel Parameters</span><span>)</span></a> ), the
                  reconstructed unit MUST be discarded by the decompressor. If
                  the CRC succeeds, the reconstructed unit can be further
                  processed.
</p>

 
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
General Encoding Methods</h3>

<p>
            
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
Header Compression CRCs, Coverage and Polynomials</h3>

<p>This section describes how to calculate the CRCs used by
              ROHC. For all CRCs, the algorithm used to calculate the CRC is
              the same as the one used in <a class='info' href='#RFC1662'>[RFC1662]<span> (</span><span class='info'>Simpson, W., &ldquo;PPP in HDLC-like Framing,&rdquo; July&nbsp;1994.</span><span>)</span></a>, defined
              in Appendix A of this document, with the polynomials specified
              in subsequent sections. 
<a name="8_bit_crcs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.1"></a><h3>5.3.1.1.&nbsp;
8-bit CRCs in IR and IR-DYN Headers</h3>

<p>The coverage for the 8-bit CRC in the IR and IR-DYN
                  headers is profile-dependent, but it MUST cover at least the
                  initial part of the header ending with the Profile field,
                  including the CID or an Add-CID octet. Feedback and padding
                  are not part of Header (<a class='info' href='#general_rohc_format'>Section&nbsp;5.2.1<span> (</span><span class='info'>General Format of ROHC Packets</span><span>)</span></a>) and are thus not included
                  in the CRC calculation. As a rule of thumb for profile
                  specifications, any other information that initializes the
                  decompressor context SHOULD also be covered by a CRC.
</p>
<p>More specifically, the 8-bit CRC does not cover only and
                  entirely the original uncompressed header; therefore, it
                  does not provide the means for the decompressor to verify a
                  decompression attempt, or the means to verify the
                  correctness of the entire decompressor context. However,
                  when successful, it does provide enough robustness for the
                  decompressor to update its context with the information
                  carried within the IR or the IR-DYN header.
</p>
<p>The CRC polynomial for the 8-bit CRC is: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C(x) = 1 + x + x^2 + x^8
</pre></div><p>

</p>
<p>When computing the CRC, the CRC field in the header is
                  set to zero, and the initial content of the CRC register is
                  set to all 1's.
</p> 
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.2"></a><h3>5.3.1.2.&nbsp;
3-bit CRC in Compressed Headers</h3>

<p>The 3-bit CRC in compressed headers is calculated over
                  all octets of the entire original header, before
                  compression, in the following manner.
</p>
<p>The initial content of the CRC register is set to all
                  1's.
</p>
<p>The polynomial for the 3-bit CRC is: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C(x) = 1 + x + x^3
</pre></div><p>

</p>
<p>The purpose of the 3-bit CRC is to provide the means for
                  the decompressor to verify the outcome of a decompression
                  attempt for small compressed headers, and to detect context
                  damage based on aggregated probability over a number of
                  decompression attempts. It is however too weak to provide
                  enough success guarantees from the decompression of one
                  single header. Therefore, compressed headers carrying a
                  3-bit CRC are normally not suitable to perform context
                  repairs at the decompressor; hence, profiles should refrain
                  from allowing decompression of such a header when some or
                  the entire decompressor context is assumed invalid.
</p> 
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.3"></a><h3>5.3.1.3.&nbsp;
7-bit CRC in Compressed Headers</h3>

<p>The 7-bit CRC in compressed headers is calculated over
                  all octets of the entire original header, before
                  compression, in the following manner.
</p>
<p>The initial content of the CRC register is set to all
                  1's.
</p>
<p>The polynomial for the 7-bit CRC is: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C(x) = 1 + x + x^2 + x^3 + x^6 + x^7
</pre></div><p>

</p>
<p>The purpose of the 7-bit CRC is to provide the means for
                  the decompressor to verify the outcome of a decompression
                  attempt for a larger compressed header, and to provide
                  enough protection to validate a context repair at the
                  decompressor. The 7-bit CRC is strong enough to assume a
                  repair to be successful from the decompression of one single
                  header; hence, profiles may allow decompression of a header
                  carrying a 7-bit CRC when some of the decompressor context
                  is assumed invalid.
</p> 
<a name="32_bit_crcs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1.4"></a><h3>5.3.1.4.&nbsp;
32-bit Segmentation CRC</h3>

<p>The 32-bit CRC is used by the segmentation scheme to
                  verify the reconstructed unit, and it is thus calculated
                  over the segmented unit, i.e., over the Header and the
                  Payload fields of the ROHC packet.
</p>
<p>The initial content of the CRC register is set to all
                  1's.
</p>
<p>The polynomial for the 32-bit CRC is: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +
             x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32.
</pre></div><p>

</p>
<p>The purpose of the 32-bit CRC is to verify the
                  reconstructed unit.
</p>


            
<a name="sdvl"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Self-Describing Variable-Length Values</h3>

<p>The values of many fields and compression parameters can vary
              widely. To optimize the transfer of such values, a variable
              number of octets are used to encode them. The first few bits of
              the first octet determine the number of octets used:
</p>
<p>
                </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   First bit is 0: 1 octet.
            7 bits transferred.
            Up to 127 decimal.
            Encoded octets in hexadecimal: 00 to 7F

   First bits are 10: 2 octets.
            14 bits transferred.
            Up to 16 383 decimal.
            Encoded octets in hexadecimal: 80 00 to BF FF

   First bits are 110: 3 octets.
            21 bits transferred.
            Up to 2 097 151 decimal.
            Encoded octets in hexadecimal: C0 00 00 to DF FF FF

   First bits are 111: 4 octets.
            29 bits transferred.
            Up to 536 870 911 decimal.
            Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF
</pre></div><p>

              
</p>
          
 
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)</h3>

<p>This section describes the uncompressed ROHC profile. The profile
          identifier for this profile is 0x0000.
</p>
<p>Profile 0x0000 provides a way to send IP packets without
          compressing them. This can be used for any packet for which a
          compression profile is not available in the set of profiles
          supported by the ROHC channel, or for which compression is not
          desirable for some reason.
</p>
<p>After initialization, the only overhead for sending packets using
          Profile 0x0000 is the size of the CID. When uncompressed packets are
          frequent, Profile 0x0000 should be associated with a CID the size of
          zero or one octet. Profile 0x0000 SHOULD be associated with at most
          one CID. 
<a name="uncompressed_ir"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
IR Packet</h3>

<p>The initialization and refresh packet (IR packet) for Profile
              0x0000 has the following Header format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 |res|
   +---+---+---+---+---+---+---+---+
   :                               :
   /    0-2 octets of CID info     / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |         Profile = 0x00        | 1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              | 1 octet
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>res: MUST be set to zero; otherwise, the decompressor MUST
              discard the packet.
</p>
<p>Profile: 0x00
</p>
<p>CRC: 8-bit CRC, computed using the polynomial of <a class='info' href='#8_bit_crcs'>Section&nbsp;5.3.1.1<span> (</span><span class='info'>8-bit CRCs in IR and IR-DYN Headers</span><span>)</span></a>. The CRC covers the first octet of the IR
              Header through the Profile octet of the IR Header, i.e., it does
              not cover the CRC itself. Neither does it cover any preceding
              Padding or Feedback, nor the Payload.
</p>
<p>For the IR packet, Payload has the following format: </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    --- --- --- --- --- --- --- ---
   :                               : (optional)
   /           IP packet           / variable length
   :                               :
    --- --- --- --- --- --- --- ---
</pre></div><p>

</p>
<p>IP packet: An uncompressed IP packet may be included in the
              IR packet. The decompressor determines if the IP packet is
              present by considering the length of the IR packet.
</p> 
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
Normal Packet</h3>

<p>A Normal packet is a normal IP packet plus CID information.
              For the Normal Packet, the following format corresponds to the
              Header and Payload (as defined in <a class='info' href='#general_rohc_format'>Section&nbsp;5.2.1<span> (</span><span class='info'>General Format of ROHC Packets</span><span>)</span></a>): </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   |   first octet of IP packet    |
   +---+---+---+---+---+---+---+---+
   :                               :
   /    0-2 octets of CID info     / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |                               |
   /       rest of IP packet       / variable length
   |                               |
   +---+---+---+---+---+---+---+---+
</pre></div><p>

</p>
<p>Note that the first octet of the IP packet starts with the
              bit pattern 0100 (IPv4) or 0110 (IPv6). This does not conflict
              with any reserved packet types.
</p>
<p>When the channel uses small CIDs, and profile 0x0000 is
              associated with a CID &gt; 0, an Add-CID octet precedes the IP
              packet. When the channel uses large CIDs, the CID is placed so
              that it starts at the second octet of the combined
              Header/Payload format above.
</p>
<p>A Normal Packet may carry Padding and/or Feedback as any
              other ROHC packet, preceding the combined Header/Payload.
</p> 
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
Context Initialization</h3>

<p>The compressor initializes the static context associated with
              the UNCOMPRESSED profile by sending IR packets (see <a class='info' href='#uncompressed_ir'>Section&nbsp;5.4.1<span> (</span><span class='info'>IR Packet</span><span>)</span></a>). During context initialization, it
              is RECOMMENDED that the compressor sends IR packets until it is
              reasonably confident that the decompressor has successfully
              received at least one IR packet. This confidence can for example
              be based on feedback from the decompressor, or from knowledge of
              the characteristics of the link.
</p>
<p>The compressor SHOULD periodically transmit IR packets for a
              context associated with the UNCOMPRESSED profile, at least until
              it receives feedback from the decompressor for that context. The
              compressor MAY stop the periodic sending of IR packets once it
              has received feedback.
</p> 
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.4"></a><h3>5.4.4.&nbsp;
Decompressor Operation</h3>

<p>When an IR packet is received, the decompressor first
              validates its header using the 8-bit CRC.</p>
<ul class="text">
<li>If the header fails validation, the decompressor MUST NOT
                  deliver the IP packet to upper layers.
</li>
<li>If the header is successfully validated, the
                  decompressor
<ol class="text">
<li>initializes the context if it has no valid context
                      for the given CID already associated to the specified
                      profile,
</li>
<li>delivers the IP packet to upper layers if
                      present,
</li>
<li>MAY send an ACK.
</li>
</ol>
</li>
</ul>

<p>When any other packet is received while the decompressor has
              no context, it is discarded without further action.
</p>
<p>When a Normal packet is received and the decompressor has a
              valid context, the IP packet is extracted and delivered to upper
              layers.
</p> 
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.5"></a><h3>5.4.5.&nbsp;
Feedback</h3>

<p>The only kind of feedback defined by Profile 0x0000 is ACK,
              using the FEEDBACK-1 format of <a class='info' href='#feedback_format'>Section&nbsp;5.2.4.1<span> (</span><span class='info'>ROHC Feedback Format</span><span>)</span></a>, where the value of the profile-
              specific octet in the FEEDBACK-1 is 0 (zero). The FEEDBACK-2
              format is thus not defined for Profile 0x0000.
</p>


<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Overview of a ROHC Profile (Informative)</h3>

<p>The ROHC protocol consists of a framework part and a profile part.
      The framework defines the mechanisms common to all profiles, while the
      profile defines the compression algorithm and profile specific packet
      formats.
</p>
<p><a class='info' href='#framework_normative'>Section&nbsp;5<span> (</span><span class='info'>The ROHC Framework (Normative)</span><span>)</span></a> specifies the details of the
      ROHC framework. This section provides an informative overview of the
      elements that make a profile specification. The normative specification
      of individual profiles is outside the scope of this document.
</p>
<p>A ROHC profile defines the elements that build up the compression
      protocol. A ROHC profile consists of:
</p>
<p>Packet formats:</p>
<ul class="text">
<li>Bits-on-the-wire
<blockquote class="text"><dl>
<dt></dt>
<dd>The profile defines the layout of the bits for
              profile-specific packet types that it defines, and for the
              profile-specific parts of packet types common to all profiles
              (e.g., IR and IR-DYN).
</dd>
</dl></blockquote>
</li>
<li>Field encodings
<blockquote class="text"><dl>
<dt></dt>
<dd>Bits and groups of bits from the packet format layout,
              referred to as Compressed fields, represent the result of an
              encoding method specific for that compressed field within a
              specific packet format. The profile defines these encoding
              methods.
</dd>
</dl></blockquote>
</li>
<li>Updating properties
<blockquote class="text"><dl>
<dt></dt>
<dd>The profile-specific packet formats may update the state of
              the decompressor, and may do so in different ways. The profile
              defines how individual profile-specific fields, or entire
              profile-specific packet types, update the decompressor
              context.
</dd>
</dl></blockquote>
</li>
<li>Verification
<blockquote class="text"><dl>
<dt></dt>
<dd>Packets that update the state of the decompressor are
              verified to prevent incorrect updates to the decompressor
              context. The profile defines the mechanisms used to verify the
              decompression of a packet.
</dd>
</dl></blockquote>
</li>
</ul>

<p>Context management:</p>
<ul class="text">
<li>Robustness logic
<blockquote class="text"><dl>
<dt></dt>
<dd>Packets may be lost or reordered between the compressor and
              the decompressor. The profile defines mechanism to minimize the
              impacts of such events and prevent damage propagation.
</dd>
</dl></blockquote>
</li>
<li>Repair mechanism
<blockquote class="text"><dl>
<dt></dt>
<dd>Despite the robustness logic, impairment events may still
              lead to decompression failure(s), and even to context damage at
              the decompressor. The profile defines context repair mechanisms,
              including feedback logic if used.
</dd>
</dl></blockquote>
</li>
</ul>

<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Acknowledgments</h3>

<p>The authors would like to acknowledge all who have contributed to
      previous ROHC work, and especially to the authors of RFC 3095 <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a>, which is the technical basis for this document.
      Thanks also to the various individuals who contributed to the RFC 3095
      corrections and clarifications document <a class='info' href='#RFC4815'>[RFC4815]<span> (</span><span class='info'>Jonsson, L-E., Sandlund, K., Pelletier, G., and P. Kremer, &ldquo;RObust Header Compression (ROHC): Corrections and Clarifications to RFC 3095,&rdquo; February&nbsp;2007.</span><span>)</span></a>, from
      which technical contents, when applicable, have been incorporated into
      this document. Committed WG document reviewers were Carl Knutsson,
      Biplab Sarkar and Robert Stangarone, who reviewed the document during
      working group last-calls. Additional thanks to Bert Wijnen and Brian
      Carpenter for comments during IETF last-call.
      Also thanks to Jani Juvan for discovering the error in the feedback
      structure in <a class='info' href='#RFC4995'>[RFC4995]<span> (</span><span class='info'>Jonsson, L-E., Pelletier, G., and K. Sandlund, &ldquo;The RObust Header Compression (ROHC) Framework,&rdquo; July&nbsp;2007.</span><span>)</span></a> which made this document
      necessary. 
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>An IANA registry for "RObust Header Compression (ROHC) Profile
      Identifiers" <a class='info' href='#ROHC-ids'>[ROHC&#8209;ids]<span> (</span><span class='info'>IANA Registry, &ldquo;RObust Header Compression (ROHC) Profile Identifiers,&rdquo; 2001.</span><span>)</span></a> was created by RFC 3095 <a class='info' href='#RFC3095'>[RFC3095]<span> (</span><span class='info'>Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed,&rdquo; July&nbsp;2001.</span><span>)</span></a>. The assignment policy, as outlined by RFC 3095, is
      the following:
</p>
<p>The ROHC profile identifier is a non-negative integer. In many
      negotiation protocols, it will be represented as a 16-bit value. Due to
      the way the profile identifier is abbreviated in ROHC packets, the 8
      least significant bits of the profile identifier have a special
      significance: Two profile identifiers with identical 8 LSBs should be
      assigned only if the higher-numbered one is intended to supersede the
      lower-numbered one. To highlight this relationship, profile identifiers
      should be given in hexadecimal (as in 0x1234, which would for example
      supersede 0x0A34).
</p>
<p>Following the policies outlined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>, the
      IANA policy for assigning new values for the profile identifier shall be
      Specification Required: values and their meanings must be documented in
      an RFC or in some other permanent and readily available reference, in
      sufficient detail that interoperability between independent
      implementations is possible. In the 8 LSBs, the range 0 to 127 is
      reserved for IETF standard-track specifications; the range 128 to 254 is
      available for other specifications that meet this requirement (such as
      Informational RFCs). The LSB value 255 is reserved for future
      extensibility of the present specification.
</p>
<p>The following profile identifiers have so far been allocated:
</p>
<p>
        </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Profile Identifier    Usage                      Reference
   ------------------    ----------------------     ---------
   0x0000                ROHC uncompressed          RFC XXXX [RFC-ed]
   0x0001                ROHC RTP                   RFC 3095
   0x0002                ROHC UDP                   RFC 3095
   0x0003                ROHC ESP                   RFC 3095
   0x0004                ROHC IP                    RFC 3843
   0x0005                ROHC LLA                   RFC 3242
   0x0105                ROHC LLA with R-mode       RFC 3408
   0x0006                ROHC TCP                   RFC 4996
   0x0007                ROHC RTP/UDP-Lite          RFC 4019
   0x0008                ROHC UDP-Lite              RFC 4019
   0x0101                ROHCv2 RTP                 RFC 5225
   0x0102                ROHCv2 UDP                 RFC 5225
   0x0103                ROHCv2 ESP                 RFC 5225
   0x0104                ROHCv2 IP                  RFC 5225
   0x0107                ROHCv2 RTP/UDP-Lite        RFC 5225
   0x0108                ROHCv2 UDP-Lite            RFC 5225
</pre></div><p>

      
</p>
<p>New profiles will need new identifiers to be assigned by the IANA,
      but this document does not require any additional IANA action.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>Because encryption eliminates the redundancy that header compression
      schemes try to exploit, there is some inducement to forego encryption of
      headers in order to enable operation over low-bandwidth links.
</p>
<p>A malfunctioning or malicious header compressor could cause the
      header decompressor to reconstitute packets that do not match the
      original packets but still have valid headers and possibly also valid
      transport checksums. Such corruption may be detected with end-to-end
      authentication and integrity mechanisms, which will not be affected by
      the compression. Moreover, the ROHC header compression scheme uses an
      internal checksum for verification of reconstructed headers, which
      reduces the probability of producing decompressed headers not matching
      the original ones without this being noticed.
</p>
<p>Denial-of-service attacks are possible if an intruder can introduce,
      for example, bogus IR, IR-DYN, or FEEDBACK packets onto the link and
      thereby cause compression efficiency to be reduced. However, an intruder
      having the ability to inject arbitrary packets at the link layer in this
      manner raises additional security issues that dwarf those related to the
      use of header compression.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CRTP-eval">[CRTP-eval]</a></td>
<td class="author-text">Degermark, M., Hannu, H., Jonsson, L., and K. Svanbro, &ldquo;"Evaluation of CRTP Performance over Cellular Radio
          Networks", IEEE Personal Communication Magazine, Volume 7, number 4,
          pp. 20-25, August 2000.,&rdquo; 2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0768">[RFC0768]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>,&rdquo; STD&nbsp;6, RFC&nbsp;768, August&nbsp;1980 (<a href="http://www.rfc-editor.org/rfc/rfc768.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0791">[RFC0791]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;791, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc791.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1144">[RFC1144]</a></td>
<td class="author-text"><a href="mailto:van@helios.ee.lbl.gov">Jacobson, V.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1144">Compressing TCP/IP headers for low-speed serial links</a>,&rdquo; RFC&nbsp;1144, February&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1144.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc1144.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc1144.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1662">[RFC1662]</a></td>
<td class="author-text"><a href="mailto:Bill.Simpson@um.cc.umich.edu">Simpson, W.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1662">PPP in HDLC-like Framing</a>,&rdquo; STD&nbsp;51, RFC&nbsp;1662, July&nbsp;1994 (<a href="http://www.rfc-editor.org/rfc/rfc1662.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2507">[RFC2507]</a></td>
<td class="author-text"><a href="mailto:micke@sm.luth.se">Degermark, M.</a>, Nordgren, B., and <a href="mailto:steve@sm.luth.se">S. Pink</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2507">IP Header Compression</a>,&rdquo; RFC&nbsp;2507, February&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2507.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2508">[RFC2508]</a></td>
<td class="author-text"><a href="mailto:casner@cisco.com">Casner, S.</a> and <a href="mailto:van@cisco.com">V. Jacobson</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2508">Compressing IP/UDP/RTP Headers for Low-Speed Serial Links</a>,&rdquo; RFC&nbsp;2508, February&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2508.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3095">[RFC3095]</a></td>
<td class="author-text">Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &ldquo;<a href="http://tools.ietf.org/html/rfc3095">RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed</a>,&rdquo; RFC&nbsp;3095, July&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3095.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3096">[RFC3096]</a></td>
<td class="author-text">Degermark, M., &ldquo;<a href="http://tools.ietf.org/html/rfc3096">Requirements for robust IP/UDP/RTP header compression</a>,&rdquo; RFC&nbsp;3096, July&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3096.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3241">[RFC3241]</a></td>
<td class="author-text">Bormann, C., &ldquo;<a href="http://tools.ietf.org/html/rfc3241">Robust Header Compression (ROHC) over PPP</a>,&rdquo; RFC&nbsp;3241, April&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3241.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3545">[RFC3545]</a></td>
<td class="author-text">Koren, T., Casner, S., Geevarghese, J., Thompson, B., and P. Ruddy, &ldquo;<a href="http://tools.ietf.org/html/rfc3545">Enhanced Compressed RTP (CRTP) for Links with High Delay, Packet Loss and Reordering</a>,&rdquo; RFC&nbsp;3545, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3545.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3759">[RFC3759]</a></td>
<td class="author-text">Jonsson, L-E., &ldquo;<a href="http://tools.ietf.org/html/rfc3759">RObust Header Compression (ROHC): Terminology and Channel Mapping Examples</a>,&rdquo; RFC&nbsp;3759, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3759.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4224">[RFC4224]</a></td>
<td class="author-text">Pelletier, G., Jonsson, L-E., and K. Sandlund, &ldquo;<a href="http://tools.ietf.org/html/rfc4224">RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets</a>,&rdquo; RFC&nbsp;4224, January&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4224.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4815">[RFC4815]</a></td>
<td class="author-text">Jonsson, L-E., Sandlund, K., Pelletier, G., and P. Kremer, &ldquo;<a href="http://tools.ietf.org/html/rfc4815">RObust Header Compression (ROHC): Corrections and Clarifications to RFC 3095</a>,&rdquo; RFC&nbsp;4815, February&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4815.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4995">[RFC4995]</a></td>
<td class="author-text">Jonsson, L-E., Pelletier, G., and K. Sandlund, &ldquo;<a href="http://tools.ietf.org/html/rfc4995">The RObust Header Compression (ROHC) Framework</a>,&rdquo; RFC&nbsp;4995, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4995.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4996">[RFC4996]</a></td>
<td class="author-text">Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West, &ldquo;<a href="http://tools.ietf.org/html/rfc4996">RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)</a>,&rdquo; RFC&nbsp;4996, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4996.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5225">[RFC5225]</a></td>
<td class="author-text">Pelletier, G. and K. Sandlund, &ldquo;<a href="http://tools.ietf.org/html/rfc5225">RObust Header Compression Version 2 (ROHCv2): Profiles for
          RTP, UDP, IP, ESP and UDP-Lite</a>,&rdquo; RFC&nbsp;5225, April&nbsp;2008 (<a href="ftp://ftp.isi.edu/in-notes/rfc5225.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ROHC-ids">[ROHC-ids]</a></td>
<td class="author-text">IANA Registry, &ldquo;<a href="http://www.iana.org/assignments/rohc-pro-ids">RObust Header Compression (ROHC) Profile Identifiers</a>,&rdquo; 2001.</td></tr>
</table>

<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
CRC Algorithm</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     #!/usr/bin/perl -w
   use strict;
   #=================================
   #
   # ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02
   #
   # This little demo shows the four types of CRC in use in RFC 3095,
   # the specification for robust header compression.  Type your data in
   # hexadecimal form and then press Control+D.
   #
   #---------------------------------
   #
   # utility
   #
   sub dump_bytes($) {
       my $x = shift;
       my $i;
       for ($i = 0; $i &lt; length($x); ) {
     printf("%02x ", ord(substr($x, $i, 1)));
     printf("\n") if (++$i % 16 == 0);
       }
       printf("\n") if ($i % 16 != 0);
   }

   #---------------------------------
   #
   # The CRC calculation algorithm.
   #
   sub do_crc($$$) {
       my $nbits = shift;
       my $poly = shift;
       my $string = shift;

       my $crc = ($nbits == 32 ? 0xffffffff : (1 &lt;&lt; $nbits) - 1);
       for (my $i = 0; $i &lt; length($string); ++$i) {
         my $byte = ord(substr($string, $i, 1));
         for( my $b = 0; $b &lt; 8; $b++ ) {
           if (($crc &amp; 1) ^ ($byte &amp; 1)) {
             $crc &gt;&gt;= 1;
             $crc ^= $poly;
           } else {
           $crc &gt;&gt;= 1;
           }
           $byte &gt;&gt;= 1;
         }
       }
       printf "%2d bits, ", $nbits;
       printf "CRC: %02x\n", $crc;
   }

   #---------------------------------
   #
   # Test harness
   #
   $/ = undef;
   $_ = &lt;&gt;;         # read until EOF
   my $string = ""; # extract all that looks hex:
   s/([0-9a-fA-F][0-9a-fA-F])/$string .= chr(hex($1)), ""/eg;
   dump_bytes($string);

   #---------------------------------
   #
   # 32-bit segmentation CRC
   # Note that the text implies this is complemented like for PPP
   # (this differs from 8, 7, and 3-bit CRC)
   #
   #      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +
   #             x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32
   #
   do_crc(32, 0xedb88320, $string);

   #---------------------------------
   #
   # 8-bit IR/IR-DYN CRC
   #
   #      C(x) = x^0 + x^1 + x^2 + x^8
   #
   do_crc(8, 0xe0, $string);

   #---------------------------------
   #
   # 7-bit FO/SO CRC
   #
   #      C(x) = x^0 + x^1 + x^2 + x^3 + x^6 + x^7
   #
   do_crc(7, 0x79, $string);

   #---------------------------------
   #
   # 3-bit FO/SO CRC
   #
   #      C(x) = x^0 + x^1 + x^3
   #
   do_crc(3, 0x6, $string);
</pre></div>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Kristofer Sandlund</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ericsson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Box 920</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lulea  SE-971 28</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sweden</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+46 (0) 8 404 41 58</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:kristofer.sandlund@ericsson.com">kristofer.sandlund@ericsson.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ghyslain Pelletier</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ericsson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Box 920</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lulea  SE-971 28</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sweden</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+46 (0) 8 404 29 43</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ghyslain.pelletier@ericsson.com">ghyslain.pelletier@ericsson.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lars-Erik Jonsson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Optand 737</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ostersund  SE-831 92</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sweden</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+46 76 830 03 12</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lars-erik@lejonsson.com">lars-erik@lejonsson.com</a></td></tr>
</table>
</body></html>
