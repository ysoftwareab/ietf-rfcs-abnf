v=0
o=first 2520644554 2838152170 IN IP4 first.example.net
s=Example
t=0 0
c=IN IP4 192.0.2.94
m=audio 16112 RTP/AVP 96
b=AS:20
b=RS:0
b=RR:400
a=rtpmap:96 mpeg4-generic/44100
a=fmtp:96 streamtype=5; mode=rtp-midi; config=""; profile-level-id=12;
cm_unused=ABFGHJKMQTVXYZ; cm_unused=C120-127; ch_never=ADEFMQTVX;
tsmode=buffer; linerate=320000; octpos=last; mperiod=44; rtp_ptime=0;
rtp_maxptime=0; guardtime=44100; render=synthetic; rinit="audio/asc";
url="http://example.net/sa.asc";
cid="xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk"

   (The a=fmtp line has been wrapped to fit the page to accommodate
    memo formatting restrictions; it constitutes a single line in SDP.)

            Figure 1. Session description for first participant


v=0
o=second 2520644554 2838152170 IN IP4 second.example.net
s=Example
t=0 0
c=IN IP4 192.0.2.105
m=audio 5004 RTP/AVP 101
b=AS:20
b=RS:0
b=RR:400
a=rtpmap:101 mpeg4-generic/44100
a=fmtp:101 streamtype=5; mode=rtp-midi; config=""; profile-level-id=12;
cm_unused=ABFGHJKMQTVXYZ; cm_unused=C120-127; ch_never=ADEFMQTVX;
tsmode=buffer; linerate=320000;octpos=last;mperiod=44; guardtime=44100;
rtp_ptime=0; rtp_maxptime=0; render=synthetic; rinit="audio/asc";
url="http://example.net/sa.asc";
cid="xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk"

   (The a=fmtp line has been wrapped to fit the page to accommodate
    memo formatting restrictions; it constitutes a single line in SDP.)

          Figure 2. Session description for second participant
   The session descriptions use the mpeg4-generic media type (coded in
   the a=rtpmap line) to specify the use of the MPEG 4 Structured Audio
   renderer [MPEGSA].  The session descriptions also use parameters to
   customize the stream (Appendix C of [RFC4695]).  The parameter values
   are identical for both parties, yielding identical rendering
   environments for the two client hosts.

   The bandwidth (b=) AS parameter [RFC4566] [RFC3550] indicates that
   the total RTP session bandwidth is 20 kbs.  This value assumes that
   the two players send 10 kbs streams concurrently.  To derive the 10
   kbs value, we begin with the analysis of RTP MIDI payload bandwidth
   in Appendix A.4 of [NMP] and add in RTP and IP4 packet overhead and a
   small safety factor.

   The bandwidth RR parameter [RFC3556] indicates that the shared RTCP
   session bandwidth for the two parties is 400 bps.  We set the
   bandwidth SR parameter to 0 bps, to signal that sending parties and
   non-sending parties equally share the 400 bps of RTCP bandwidth.
   (Note that in this particular example, the guardtime parameter value
   of 44100 ensures that both parties are sending for the duration of
   the session.)  The 400 bps RTCP bandwidth value supports one RTCP
   packet per 5 seconds from each party, containing a Sender Report and
   CNAME information [RFC3550].

   We now show an example of code that implements the actions the
   parties take during the session.  The code is written in C and uses
   the standard network programming techniques described in [STEVENS].
   We show code for the first party (the second party takes a symmetric
   set of actions).

   Figure 3 shows how the first party initializes a pair of socket
   descriptors (rtp_fd and rtcp_fd) to send and receive UDP packets.
   After the code in Figure 3 runs, the first party may check for new
   RTP or RTCP packets by calling recv() on rtp_fd or rtcp_fd.

   Applications may use recv() to receive UDP packets on a socket using
   one of two general methods: "blocking" or "non-blocking".

   A call to recv() on a blocking UDP socket puts the calling thread to
   sleep until a new packet arrives.

   A call to recv() on a non-blocking socket acts to poll the device:
   the recv() call returns immediately, with a return value that
   indicates the polling result.  In this case, a positive return value
   signals the size of a new received packet, and a negative return
   value (coupled with an errno value of EAGAIN) indicates that no new
   packet was available.
   The choice of blocking or non-blocking sockets is a critical
   application choice.  Blocking sockets offer the lowest potential
   latency (as the OS wakes the caller as soon as a packet has arrived).
   However, audio applications that use blocking sockets must adopt a
   multi-threaded program architecture, so that audio samples may be
   generated on a "rendering thread" while the "network thread" sleeps,
   awaiting the next packet.  The architecture must also support a
   thread communication mechanism, so that the network thread has a
   mechanism to send MIDI commands the rendering thread.

   In contrast, audio applications that use non-blocking sockets may be
   coded using a single thread, that alternates between audio sample
   generation and network polling.  This architecture trades off
   increased network latency (as a packet may arrive between polls) for
   a simpler program architecture.  For simplicity, our example uses
   non-blocking sockets and presumes a single run loop.  Figure 4 shows
   how the example configures its sockets to be non-blocking.

   Figure 5 shows how to use recv() to check a non-blocking socket for
   new packets.

   The first party also uses rtp_fd and rtcp_fd to send RTP and RTCP
   packets to the second party.  In Figure 6, we show how to initialize
   socket structures that address the second party.  In Figure 7, we
   show how to use one of these structures in a sendto() call to send an
   RTP packet to the second party.

   Note that the code shown in Figures 3-7 assumes a clear network path
   between the participants.  The code may not work if firewalls or
   Network Address Translation (NAT) devices are present in the network
   path.

normal = (len < 0) && (errno == EAGAIN);

rtp_addr = calloc(1, sizeof(struct sockaddr_in));
rtcp_addr = calloc(1, sizeof(struct sockaddr_in));
