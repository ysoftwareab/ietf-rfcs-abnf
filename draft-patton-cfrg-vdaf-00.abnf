output_shares = []
input_shares = measurement_to_input_shares(public_param, input)

prep_states = []
inbound = []
outbound = []
inbound = outbound

agg_shares = []
my_output_shares = [out[j] for out in output_shares]
my_agg_share = output_to_aggregate_shares(my_output_shares)
joint_rand = Field.rand_vec(JOINT_RAND_LEN)
prove_rand = Field.rand_vec(PROVE_RAND_LEN)
query_rand = Field.rand_vec(QUERY_RAND_LEN)

proof = flp_prove(input, prove_rand, joint_rand)

verifier = flp_query(input, proof, query_rand, joint_rand)

k_query_init = gen_rand(KEY_SIZE)
verify_param = [ (j, k_query_init) for j in range(SHARES) ]
input = flp_encode(measurement)
k_joint_rand = zeros(SEED_SIZE)

leader_input_share = input
k_helper_input_shares = []
k_helper_blinds = []
k_helper_hints = []
k_blind = gen_rand(KEY_SIZE)
k_share = gen_rand(KEY_SIZE)
helper_input_share = expand(Field, k_share, INPUT_LEN)
k_hint = get_key(k_blind,
           byte(j+1) + Field.encode_vec(helper_input_share))
k_leader_blind = gen_rand(KEY_SIZE)
k_leader_hint = get_key(k_leader_blind,
         byte(0) + Field.encode_vec(leader_input_share))
joint_rand = expand(Field, k_joint_rand, JOINT_RAND_LEN)
prove_rand = expand(Field, gen_rand(KEY_SIZE), PROVE_RAND_LEN)
proof = flp_prove(input, prove_rand, joint_rand)
leader_proof_share = proof
k_helper_proof_shares = []
k_share = gen_rand(KEY_SIZE)
helper_proof_share = expand(Field, k_share, PROOF_LEN)
input_shares = []
joint_rand = expand(Field, self.k_joint_rand, JOINT_RAND_LEN)
query_rand = expand(Field, self.k_query_rand, QUERY_RAND_LEN)
verifier_share = flp_query(
           self.input_share, self.proof_share, query_rand, joint_rand)

k_joint_rand = zeros(KEY_SIZE)
verifier = vec_zeros(VERIFIER_LEN)
agg_share = vec_zeros(OUTPUT_LEN)
agg = vec_zeros(OUTPUT_LEN)
k_verify_init = gen_rand(KEY_SIZE)
A = -2*a + k
B = a*a + b - k*a + c

beta = []
A = -2*a+k
B = a*a + b - a * k + c
correlation_share = Field[l].rand_vec(5)
input_shares = [
       encode_input_share(key_0, correlation_shares_0),
       encode_input_share(key_1, correlation_shares_1),
l = self.l
value = kdpf_key.eval(l, x)
r = expand(Field[l], self.k_verify_rand, len(data_share))
verifier_share_1 = [
            a_share + inner_product(data_share, r),
            b_share + inner_product(data_share, r * r),
            c_share + inner_product(auth_share, r),
verifier_1 = Field[l].deocde_vec(inbound[0]) + \
                      Field[l].deocde_vec(inbound[1])

verifier_share_2 = [
           (verifier_1[0] * verifier_1[0] \
            - verifier_1[1] \
            - verifier_1[2]) * self.party_id \
           + A_share * verifer_1[0] \
           + B_share
verifier_2 = Field[l].decode_vec(inbound[0]) + \
                      Field[l].decode_vec(inbound[1])

agg_share = Field[l].vec_zeros(len(candidate_prefixes))
agg = Field[l].decode_vec(agg_shares[0]) + \
           Field[l].decode_vec(agg_shares[1]J)

