sig=*t7LoYw6vwL2FSZRNJPYdNdYjfZSQkaCQeqpBD1whcy/6AAamVJ2OryXoXv6ACVBQgPV13o5de9oOVcOGGMX9fsf2ve1UDw/ITpeimB7n3zcuDEePzIcPbUnicicN2yodZAfr5il7BBJTs8L+V2ZERI16nJfrOZOvUfhvuUaMDGQXx5StIj7XLiX7/caxPz5ctwglgVAwCmoVPhmYFLq391O+hEssHSk2xkY6r/D9V2cKMikBBOTZ+JFyrnS/f2B4li7YASIY0YX64ifCmCw97cQTngXax6Upoie44IAe+6JngOie9JlDgcMF3YZ1uxNGWl9VwlalSwWgi1YA9Ff7mQ;
integrity="mi";
validityUrl="https://example.com/resource.validity.1511128380";
certUrl="https://example.com/certs";
certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI;
date=1511128380; expires=1511733180

   The signatures uses a 2048-bit RSA certificate within
   "https://example.com/".

   It relies on the "MI" response header to guard the integrity of the
   response payload.

   The signature includes a "validityUrl" that includes the first time
   the resource was seen.  This allows multiple versions of a resource
   at the same URL to be updated with new signatures, which allows
   clients to avoid transferring extra data while the old versions don't
   have known security bugs.

   The certificate at "https://example.com/certs" has a "subjectAltName"
   of "example.com", meaning that if it and its signature validate, the
   exchange can be trusted as having an origin of
   "https://example.com/".

validity = {
     ? signatures: [ + bytes ]
     ? update: {
       ? size: uint,
     }
sig=*MEUCIQ...;
validityUrl="https://example.com/resource.validity.1511157180";
certUrl="https://example.com/oldcerts";
date=1511128380; expires=1511733180

sig=*MEQCIC...;
validityUrl="https://example.com/resource.validity.1511157180";
certUrl="https://example.com/newcerts";
date=1511733180; expires=1512337980

signed-exchange-header = [
     { ':method': bytes,
       ':url': bytes,
       * bytes => bytes,
     },
     { ':status': bytes,
       'signature': bytes,
       * bytes => bytes,
     },
list = version *( "," version )") The server is then expected to
