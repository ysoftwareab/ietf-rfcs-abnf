<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Protocol Support for High Availability of IKEv2/IPsec</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Issues Resolved from IPsec Cluster Problem Statement">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Large Amount of State">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Multiple Members Using the Same SA">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Avoiding Collisions in SPI Number Allocation">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Interaction with Counter Modes">
<link href="#rfc.section.4" rel="Chapter" title="4 The IKEv2/IPsec SA Counter Synchronization Problem">
<link href="#rfc.section.5" rel="Chapter" title="5 SA Counter Synchronization Solution">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Processing Rules for IKE Message ID Synchronization">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Processing Rules for IPsec Replay Counter Synchronization">
<link href="#rfc.section.6" rel="Chapter" title="6 IKEv2/IPsec Synchronization Notification Payloads">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 The IKEV2_MESSAGE_ID_SYNC_SUPPORTED Notification">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 The IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED Notification">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 The IKEV2_MESSAGE_ID_SYNC Notification">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 The IPSEC_REPLAY_COUNTER_SYNC Notification">
<link href="#rfc.section.7" rel="Chapter" title="7 Implementation Details">
<link href="#rfc.section.8" rel="Chapter" title="8 IKE SA and IPsec SA Message Sequencing">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Handling of Pending IKE Messages">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Handling of Pending IPsec Messages">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 IKE SA Inconsistencies">
<link href="#rfc.section.9" rel="Chapter" title="9 Step by Step Details">
<link href="#rfc.section.10" rel="Chapter" title="10 Interaction with other drafts">
<link href="#rfc.section.11" rel="Chapter" title="11 Security Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Acknowledgements">
<link href="#rfc.section.14" rel="Chapter" title="14 Change Log">
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 Draft -04">
<link href="#rfc.section.14.2" rel="Chapter" title="14.2 Draft -03">
<link href="#rfc.section.14.3" rel="Chapter" title="14.3 Draft -02">
<link href="#rfc.section.14.4" rel="Chapter" title="14.4 Draft -01">
<link href="#rfc.section.14.5" rel="Chapter" title="14.5 Draft  -00">
<link href="#rfc.references" rel="Chapter" title="15 References">
<link href="#rfc.references.1" rel="Chapter" title="15.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="15.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A IKEv2 Message ID Sync Examples">
<link href="#rfc.appendix.Appendix%20A.1" rel="Chapter" title="Appendix A.1 Normal Failover - Example 1">
<link href="#rfc.appendix.Appendix%20A.2" rel="Chapter" title="Appendix A.2 Normal Failover - Example 2">
<link href="#rfc.appendix.Appendix%20A.3" rel="Chapter" title="Appendix A.3 Simultaneous Failover">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="The IPsec protocol suite is widely used for business-critical network traffic.  In order to make IPsec deployments highly available, more scalable and failure-resistant, they are often implemented as IPsec High Availability (HA) clusters.  However there are many issues in IPsec HA clustering, and in particular in IKEv2 clustering. An earlier document, "IPsec Cluster Problem Statement", enumerates the issues encountered in the IKEv2/IPsec HA cluster environment. This document attempts to resolve these issues with the least possible change to the protocol.  " />
  <meta name="description" content="The IPsec protocol suite is widely used for business-critical network traffic.  In order to make IPsec deployments highly available, more scalable and failure-resistant, they are often implemented as IPsec High Availability (HA) clusters.  However there are many issues in IPsec HA clustering, and in particular in IKEv2 clustering. An earlier document, "IPsec Cluster Problem Statement", enumerates the issues encountered in the IKEv2/IPsec HA cluster environment. This document attempts to resolve these issues with the least possible change to the protocol.  " />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">R. Singh, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">G. Kalyani</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left">Expires: May 27, 2012</td>
<td class="right">Y. Nir</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Check Point</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Y. Sheffer</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Independent</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">D. Zhang</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Huawei</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">November 24, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Protocol Support for High Availability of IKEv2/IPsec<br />
  <span class="filename">draft-ietf-ipsecme-ipsecha-protocol-04</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The IPsec protocol suite is widely used for business-critical network traffic.  In order to make IPsec deployments highly available, more scalable and failure-resistant, they are often implemented as IPsec High Availability (HA) clusters.  However there are many issues in IPsec HA clustering, and in particular in IKEv2 clustering. An earlier document, "IPsec Cluster Problem Statement", enumerates the issues encountered in the IKEv2/IPsec HA cluster environment. This document attempts to resolve these issues with the least possible change to the protocol.  </p>
<p>This document proposes an extension to the IKEv2 protocol to solve the main issues of "IPsec Cluster Problem Statement" in the commonly deployed hot-standby cluster, and provides implementation advice for other issues.  The main issues to be solved are the synchronization of IKEv2 Message ID counters, and of IPsec Replay Counters.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 27, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Issues Resolved from IPsec Cluster Problem Statement</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Large Amount of State</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Multiple Members Using the Same SA</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Avoiding Collisions in SPI Number Allocation</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Interaction with Counter Modes</a>
</li>
<li>4.   <a href="#rfc.section.4">The IKEv2/IPsec SA Counter Synchronization Problem</a>
</li>
<li>5.   <a href="#rfc.section.5">SA Counter Synchronization Solution</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Processing Rules for IKE Message ID Synchronization</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Processing Rules for IPsec Replay Counter Synchronization</a>
</li>
<li>6.   <a href="#rfc.section.6">IKEv2/IPsec Synchronization Notification Payloads</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">The IKEV2_MESSAGE_ID_SYNC_SUPPORTED Notification</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">The IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED Notification</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">The IKEV2_MESSAGE_ID_SYNC Notification</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">The IPSEC_REPLAY_COUNTER_SYNC Notification</a>
</li>
<li>7.   <a href="#rfc.section.7">Implementation Details</a>
</li>
<li>8.   <a href="#rfc.section.8">IKE SA and IPsec SA Message Sequencing</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Handling of Pending IKE Messages</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Handling of Pending IPsec Messages</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">IKE SA Inconsistencies</a>
</li>
<li>9.   <a href="#rfc.section.9">Step by Step Details</a>
</li>
<li>10.   <a href="#rfc.section.10">Interaction with other drafts</a>
</li>
<li>11.   <a href="#rfc.section.11">Security Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Acknowledgements</a>
</li>
<li>14.   <a href="#rfc.section.14">Change Log</a>
</li>
<li>14.1.   <a href="#rfc.section.14.1">Draft -04</a>
</li>
<li>14.2.   <a href="#rfc.section.14.2">Draft -03</a>
</li>
<li>14.3.   <a href="#rfc.section.14.3">Draft -02</a>
</li>
<li>14.4.   <a href="#rfc.section.14.4">Draft -01</a>
</li>
<li>14.5.   <a href="#rfc.section.14.5">Draft  -00</a>
</li>
<li>15.   <a href="#rfc.references">References</a>
</li>
<li>15.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>15.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">IKEv2 Message ID Sync Examples</a>
</li>
<li>Appendix A.1.   <a href="#rfc.appendix.Appendix%20A.1">Normal Failover - Example 1</a>
</li>
<li>Appendix A.2.   <a href="#rfc.appendix.Appendix%20A.2">Normal Failover - Example 2</a>
</li>
<li>Appendix A.3.   <a href="#rfc.appendix.Appendix%20A.3">Simultaneous Failover</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">The IPsec protocol suite, including IKEv2, is a major building block of virtual private networks (VPNs).  In order to make such VPNs highly available, more scalable and failure-resistant, these VPNs are implemented as IKEv2/IPsec Highly Available (HA) cluster. However there are many issues with the IKEv2/IPsec HA cluster.  The problem statement draft  <a href="#sync_problem">Section 4</a> enumerates the issues around the IKEv2/IPsec HA cluster solution.  </p>
<p id="rfc.section.1.p.2">In the case of a hot-standby cluster implementation of IKEv2/IPsec based VPNs, the IKEv2/IPsec session is first established between the peer and the active member of the cluster. Later, the active member continuously syncs/updates the IKE/IPsec SA state to the standby member of the cluster. This primary SA state sync-up takes place upon each SA bring-up and/or rekey.  Performing the SA state synchronization/update for every single IKE and IPsec message is very costly, so normally it is done periodically.  As a result, when the failover event happens, this is first detected by the standby member and, possibly after a considerable amount of time, it becomes the active member.  During this failover process the peer is unaware of the failover event, and keeps sending IKE requests and IPsec packets to the cluster, as in fact it is allowed to do because of the IKEv2 windowing feature.  After the newly-active member starts, it detects the mismatch in IKE Message ID values and IPsec replay counters and needs to resolve this situation.  Please see <a href="#sync_problem">Section 4</a> for more details of the problem.  </p>
<p id="rfc.section.1.p.3">This document proposes an extension to the IKEv2 protocol to solve the main issues of IKE Message ID synchronization and IPsec SA replay counter synchronization and gives implementation advice for others. Following is a summary of the solutions provided in this document: </p>
<p></p>

<ul>
<li>IKEv2 Message ID synchronization: this is done by syncing up the expected send and receive Message ID values with the peer, and updating the values at the newly active cluster member.  </li>
<li>IPsec Replay Counter synchronization: this is done by incrementing the cluster's outgoing SA replay counter values by a "large" number; in addition, the newly-active member requests the peer to increment the replay counter values it is using for the peer's outgoing traffic.  </li>
</ul>

<p> </p>
<p id="rfc.section.1.p.5">Although this document describes the IKEv2 Message ID and IPsec replay counter synchronization in the context of an IPsec HA cluster, the solution provided is generic and can be used in other scenarios where IKEv2 Message ID or IPsec SA replay counter synchronization may be required.  </p>
<p id="rfc.section.1.p.6">Implementations differ on the need to synchronize the IKEv2 Message ID and/or IPsec replay counters.  Both of these problems are handled separately, using a separate notification for each capability. This provides the flexibility of implementing either or both of these solutions.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.  </p>
<p id="rfc.section.2.p.2">"SA Counter Synchronization Request/Response" are the request viz. response of the informational exchange defined in this document to synchronize the IKEv2/IPsec SA counter information between one member of the cluster and the peer.  </p>
<p id="rfc.section.2.p.3">Some of the terms listed below are reused from  <a href="#RFC6027">[RFC6027]</a> with further clarification in the context of the current document.  </p>
<p></p>

<ul>
<li>"Hot Standby Cluster", or "HS Cluster" is a cluster where only one of the members is active at any one time.  This member is also referred to as the "active" member, whereas the other(s) are referred to as "standby" members.  VRRP <a href="#RFC5798">[RFC5798]</a> is one method of building such a cluster. The goal of the Hot Standby Cluster is to create the illusion of a single virtual gateway to the peer(s).  </li>
<li>"Active Member" is the primary member in the Hot-Standby cluster. It is responsible for forwarding packets on behalf of the virtual gateway.  </li>
<li>"Standby Member" is the primary backup member. This member takes control, i.e. becomes the active member, after the failover event.  </li>
<li>"Peer" is an IKEv2/IPsec endpoint that maintains an IPsec connection with the Hot-Standby cluster. The Peer identifies the cluster by the cluster's (single) IP address. If a failover event occurs, the standby member of the cluster becomes active, and the peer normally doesn't notice that failover has taken place.  Although we treat the peer as a single entity, it may also be a cluster.  </li>
<li>"Multiple failover" is the situation where, in a cluster with three or more members, multiple failover events happen in rapid succession, e.g. from M1 to M2, and then to M3.  It is our goal that the implementation should be able to handle this situation, i.e.  to handle the new failover event even if it is still processing the old failover.  </li>
<li>"Simultaneous failover" is the situation where two clusters have an IPsec connection between them, and failover happens at both ends at the same time.  It is our goal that implementations should be able to handle simultaneous failover.  </li>
</ul>

<p> </p>
<p id="rfc.section.2.p.5">The generic term "IKEv2/IPsec SA Counters" is used throughout this document.  This term refers to both IKEv2 Message ID counters and IPsec replay counters.  According to the IPsec standards, the IKEv2 Message ID counter is mandatory, and used to ensure reliable delivery as well as to protect against message replay in IKEv2; the IPsec SA replay counters are optional, and are used to provide the IPsec anti-replay feature.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Issues Resolved from IPsec Cluster Problem Statement</h1>
<p id="rfc.section.3.p.1">The IPsec Cluster Problem Statement <a href="#RFC6027">[RFC6027]</a> enumerates the problems raised by IPsec clusters.  The following table lists the problem statement's sections that are resolved by this document.  </p>

<ul>
<li>3.2.  Lots of Long Lived State </li>
<li>3.3.  IKE Counters</li>
<li>3.4.  Outbound SA Counters</li>
<li>3.5.  Inbound SA Counters</li>
<li>3.6.  Missing Synchronization Messages</li>
<li>3.7.  Simultaneous use of IKE and IPsec SAs by Different Members <ul><li>3.7.1.  Outbound SAs using counter modes</li></ul>
<p> </p>
</li>
<li>3.8.  Different IP addresses for IKE and IPsec</li>
<li>3.9.  Allocation of SPIs</li>
</ul>

<p> </p>
<p id="rfc.section.3.p.2">The main problem areas are solved using the protocol extension defined below, starting with <a href="#sync_solution">Section 5</a>; additionally, this section provides implementation advice for other issues in the following subsections.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#lotsofstate" id="lotsofstate">Large Amount of State</a>
</h1>
<p id="rfc.section.3.1.p.1">Section 3.2 of the Problem Statement mentions that a lot of state needs to be synchronized for a cluster to be transparent. The actual volume of that data is very much implementation-dependent, and even for the same implementation, the amounts of data may vary wildly. An IPsec gateway used for inter-domain VPN with a dozen other gateways, and having SAs that are rekeyed every 8 hours, will need a lot less synchronization traffic than a similar gateway used for remote access, and supporting 10,000 clients. This is because counter synchronization is proportional to the number of SAs and requires little data, and the setting up of an SA requires a lot of data. Additionally, remote access IKE and IPsec SA setup tend to happen at a particular time of day, so the example gateway with the 10,000 clients may see 30-50 IKE SA setups per second at 9:00 AM. This would require very heavy synchronization traffic over that short period of time.</p>
<p id="rfc.section.3.1.p.2">If a large volume of traffic is necessary, it may be advisable to use a dedicated high-speed network interface for synch traffic. When packet loss can be made extremely low, it may be advisable to use a stateless transport such as UDP, to minimize network overhead.</p>
<p id="rfc.section.3.1.p.3">If these methods are insufficient, it may be prudent that for some SAs the entire state is not synchronized. Instead, only an indication of the SA's existence is synchronized. This, in combination with a sticky solution (as described in section 3.7 of the problem statement) ensures that the traffic from a particular peer does not reach a different member before an actual failover happens. When that happens, the method described in <a href="#I-D.ietf-ipsecme-failure-detection">[I-D.ietf-ipsecme-failure-detection]</a> can be used to quickly force the peer to set up a new SA.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#needmultiple" id="needmultiple">Multiple Members Using the Same SA</a>
</h1>
<p id="rfc.section.3.2.p.1">In a load-sharing cluster of the "duplicate" variety (see section 3.7 of the problem statement) multiple members may need to send traffic with the same selectors. To actually use the same SA the cluster would have to synchronize the Replay Counter after every packet, and that would impose unreasonable requirements on the synch connection.</p>
<p id="rfc.section.3.2.p.2">A far better solution would be to not synchronize the outbound SA, and create multiple outbound SAs, one for each member. The problem with this option is that the peer might view these multiple parallel SAs as redundant, and tear down all but one of them.</p>
<p id="rfc.section.3.2.p.3">Section 2.8 of <a href="#RFC5996">[RFC5996]</a> specifically allows multiple parallel SAs, but the reason given for this is to have multiple SAs with different QoS attributes. So while this is not a new requirement of IKEv2 implementations, we re-iterate here that IPsec peers MUST accept the long-term existence of multiple parallel SAs, even when QoS mechanisms are not in use.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#collisions" id="collisions">Avoiding Collisions in SPI Number Allocation</a>
</h1>
<p id="rfc.section.3.3.p.1">Section 3.9 of the problem statement describes the problem of two cluster members allocating the same SPI number for two different SAs. This would violate section 4.4.2.1 of <a href="#RFC4301">[RFC4301]</a>. There are several schemes to allow implementations to avoid such collisions, such as partitioning the SPI space, a request-response over the synch channel, and locking mechanisms. We believe that these are sufficiently robust and available so that we don't need to make an exception to RFC 4301, and we can leave this problem for the implementations to solve. Cluster members MUST NOT generate multiple inbound SAs with the same SPI.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#countermodes" id="countermodes">Interaction with Counter Modes</a>
</h1>
<p id="rfc.section.3.4.p.1">For SAs involving counter mode ciphers such as CTR <a href="#RFC3686">[RFC3686]</a> or GCM <a href="#RFC4106">[RFC4106]</a> there is yet another complication. The initial vector for such modes MUST NOT be repeated, and senders use methods such as counters or LFSRs to ensure this property. For an SA shared between multiple active members (load sharing cases), implementations MUST ensure that no initial vector is ever repeated. Similar concerns apply to an SA failing over from one member to another. See <a href="#RFC6054">[RFC6054]</a> for a discussion of this problem in another context.</p>
<p id="rfc.section.3.4.p.2">Just as in the SPI collision problem, there are ways to avoid a collision of initial vectors, and this is left up to implementations. In the context of load sharing, parallel SAs are a simple solution to this problem as well.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sync_problem" id="sync_problem">The IKEv2/IPsec SA Counter Synchronization Problem</a>
</h1>
<p id="rfc.section.4.p.1">The IKEv2 protocol <a href="#RFC5996">[RFC5996]</a> states that "An IKE endpoint MUST NOT exceed the peer's stated window size for transmitted IKE requests".  </p>
<p id="rfc.section.4.p.2">All IKEv2 messages are required to follow a request-response paradigm.  The initiator of an IKEv2 request MUST retransmit the request, until it has received a response from the peer.  IKEv2 introduces a windowing mechanism that allows multiple requests to be outstanding at a given point of time, but mandates that the sender's window should not move until the oldest message it has sent is acknowledged.  Loss of even a single message leads to repeated retransmissions followed by an IKEv2 SA teardown if the retransmissions remain unacknowledged.  </p>
<p id="rfc.section.4.p.3">An IPsec Hot Standby Cluster is required to ensure that in the case of failover, the standby member becomes active immediately.  The standby member is expected to have the exact value of the Message ID counter as the active member had before failover.  Even assuming the best effort to update the Message ID values from active to standby member, the values at the standby member can still be stale due to the following reasons: </p>

<ul>
<li>The standby member is unaware of the last message that was received and acknowledged by the previously active member, as the failover event could have happened before the standby member could be updated.  </li>
<li>The standby member does not have information about on-going unacknowledged requests sent by the previously active member.  As a result after the failover event, the newly active member cannot retransmit those requests.  </li>
</ul>

<p> </p>
<p id="rfc.section.4.p.4">When a standby member takes over as the active member, it can only initialize the Message ID values from the previously updated values.  This would make it reject requests from the peer when these values are stale.  Conversely, the standby member may end up reusing a stale Message ID value which would cause the peer to drop the request.  Eventually there is a high probability of the IKEv2 and corresponding IPsec SAs getting torn down simply because of a transitory Message ID mismatch and retransmission of requests, negating the benefits of the high availability cluster despite the periodic update between the cluster members.  </p>
<p id="rfc.section.4.p.5">A similar issue is also observed with IPsec anti-replay counters if anti-replay protection is enabled, which is commonly the case. Regardless of how well the ESP and AH SA counters are synchronized from the active to the standby member, there is a chance that the standby member would end up with stale counter values.  The standby member would then use those stale counter values when sending IPsec packets.  The peer would reject/drop such packets since when the anti-replay protection feature is enabled, duplicate use of counters is not allowed. Note that IPsec allows the sender to skip some counter values and continue sending with higher counter values.  </p>
<p id="rfc.section.4.p.6">We conclude that a mechanism is required to ensure that the standby member has correct Message ID and IPsec counter values when it becomes active, so that sessions are not torn down as a result of mismatched counters.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sync_solution" id="sync_solution">SA Counter Synchronization Solution</a>
</h1>
<p id="rfc.section.5.p.1">This document proposes two separate approaches to resolving the issues of mismatched IKE Message ID values and IPsec counter values.</p>
<p></p>

<ul>
<li>In the case of IKE Message ID values, the newly active cluster member and the peer negotiate a pair of new values so that future IKE messages will not be dropped.</li>
<li>For IPsec counter values, the newly-active member and the peer both increment their respective counter values, "skipping forward" by a large number, to ensure that no IPsec counters are ever reused.</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.3">Although conceptually separate, the two synchronization processes would typically take place simultaneously.</p>
<p id="rfc.section.5.p.4">First, the peer and the active member of the cluster negotiate their ability to support IKEv2 Message ID synchronization and/or IPsec Replay Counter synchronization. This is done by exchanging one or both of the IKEV2_MESSAGE_ID_SYNC_SUPPORTED and IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED notifications during the IKE_AUTH exchange. When negotiating these capabilities, the responder MUST NOT assert support of a capability unless such support was asserted by the initiator. Only a capability whose support was asserted by both parties can be used during the lifetime of the SA.</p>
<p id="rfc.section.5.p.5">This per-IKE SA information is shared with the other cluster members.  </p>
<div id="#rfc.figure.1"></div>
<pre> 
          
Peer                                                  Active Member
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
HDR, SK {IDi, [CERT], [CERTREQ], [IDr], AUTH, 
     [N(IKEV2_MESSAGE_ID_SYNC_SUPPORTED),]
     [N(IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED),]
     SAi2, TSi, TSr} ----------&gt;

&lt;-------- HDR, SK {IDr, [CERT+], [CERTREQ+], AUTH, 
               [N(IKEV2_MESSAGE_ID_SYNC_SUPPORTED),]
               [N(IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED),] SAr2, TSi, TSr} 
      
          
        </pre>
<p id="rfc.section.5.p.6">After a failover event, the standby member MAY use the IKE Message ID and/or IPsec Replay Counter synchronization capability when it becomes the active member, and provided support for the capabilities used has been negotiated.  Following that, the peer MUST respond to any synchronization message it receives from the newly-active cluster member, subject to the rules noted below.  </p>
<p id="rfc.section.5.p.7">After the failover event, when the standby member becomes active, it has to synchronize its SA counters with the peer. There are now three possible cases:</p>
<p></p>

<ol>
<li>The cluster member wishes to only perform IKE Message ID value synchronization. In this case it initiates an Informational exchange, with Message ID zero and the sole notification IKEV2_MESSAGE_ID_SYNC.</li>
<li>If the newly-active member wishes to perform only IPsec replay counter synchronization, it generates a regular IKEv2 Informational exchange using the current Message ID values, and containing the IPSEC_REPLAY_COUNTER_SYNC notification.</li>
<li>If synchronization of both counters is needed, the cluster member generates a zero-Message ID message as in case #1, and includes both notifications in this message.</li>
</ol>

<p> </p>
<p id="rfc.section.5.p.9">This figure contains the IKE message exchange used for SA counter synchronization. The following subsections describe the details of the sender and receiver processing of each message.</p>
<div id="#rfc.figure.2"></div>
<pre> 
          
Standby [Newly Active] Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
HDR, SK {N(IKEV2_MESSAGE_ID_SYNC),
     [N(IPSEC_REPLAY_COUNTER_SYNC)]} --------&gt;
                                
             &lt;--------- HDR, SK {N(IKEV2_MESSAGE_ID_SYNC)}
          
        </pre>
<p id="rfc.section.5.p.10">Alternatively, if only IPsec Replay Counter synchronization is desired, a normal Informational exchange is used, where the Message ID is non-zero:</p>
<div id="#rfc.figure.3"></div>
<pre> 
          
Standby [Newly Active] Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
HDR, SK{N(IPSEC_REPLAY_COUNTER_SYNC)} --------&gt;
                                
             &lt;--------- HDR
          
        </pre>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Processing Rules for IKE Message ID Synchronization</h1>
<p id="rfc.section.5.1.p.1">The newly-active member sends a request containing two counter value, one for the member (itself) and another for the peer, as well as a random nonce. We denote the values M1 and P1.  The peer responds with a message containing two counter values, M2 and P2. The goal of the rules below is to prevent an attacker from replaying a synchronization message, thereby invalidating IKE messages that are currently in process.</p>
<p></p>

<ul>
<li>M1 is the next sender's Message ID to be used by the member. M1 MUST be chosen so that it is larger than any value known to have been used. It is RECOMMENDED to increment the known value at least by the size of the IKE sender window.</li>
<li>P1 SHOULD be 1 more than the last Message ID value received from the peer, but may be any higher value.</li>
<li>The member SHOULD communicate the sent values to the other cluster members, so that if a second failover event takes place, the synchronization message is not replayed. Such a replay would result in the eventual deletion of the IKE SA (see below).</li>
<li>The peer MUST reject any received synchronization message if M1 is lower than or equal to the highest value it has seen from the cluster. This includes any previous received synchronization messages.</li>
<li>M2 MUST be at least the higher of the received M1, and one more than the highest sender value received from the cluster. This includes any previous received synchronization messages.</li>
<li>P2 MUST be the higher of the received P1 value, and one more than the highest sender value used by the peer.</li>
<li>The request contains a Nonce field. This field MUST be returned in the response, unchanged.  A response MUST be silently dropped if the received Nonce does not match the one that was sent.</li>
<li>Both the request and the response MUST NOT contain any additional payloads, other than an optional IPSEC_REPLAY_COUNTER_SYNC notification in the request.</li>
<li>The request and the response MUST both be sent with a Message ID value of zero.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Processing Rules for IPsec Replay Counter Synchronization</h1>
<p id="rfc.section.5.2.p.1">Upon failover, the newly-active member MUST increment its own Replay Counter (the counter used for outgoing traffic), so as to prevent the case of its traffic being dropped by the peer as replay. We note that IPsec allows the replay counter to skip forward by any amount. The estimate is based on the outgoing IPsec bandwidth and the frequency of synchronization between cluster members.  In those implementations where it is difficult to estimate this value, the counter can be incremented by a very large number, e.g. 2**30.  In the latter case, a rekey SHOULD follow shortly afterwards, to ensure that the counter never wraps around.</p>
<p id="rfc.section.5.2.p.2">Next,&#160;the cluster member estimates the number of incoming messages it might have missed, using similar logic. The member sends out a IPSEC_REPLAY_COUNTER_SYNC notification, either stand-alone or together with a IKEV2_MESSAGE_ID_SYNC notification.</p>
<p id="rfc.section.5.2.p.3">If the IPSEC_REPLAY_COUNTER_SYNC is included in the same message as IKEV2_MESSAGE_ID_SYNC, the peer MUST process the Message ID notification first (which might cause the entire message to be dropped as a replay).  Then, it MUST increment the replay counters for all Child SAs associated with the current IKE SA by the amount requested by the cluster member.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sync_payload" id="sync_payload">IKEv2/IPsec Synchronization Notification Payloads</a>
</h1>
<p id="rfc.section.6.p.1">This section lists the new notification payload types defined by this extension.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> The IKEV2_MESSAGE_ID_SYNC_SUPPORTED Notification</h1>
<p id="rfc.section.6.1.p.1">This notification payload is included in the IKE_AUTH request/response to indicate support of the IKEv2 Message ID synchronization mechanism described in this document.  </p>
<div id="#rfc.figure.4"></div>
<pre> 
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 </pre>
<p id="rfc.section.6.1.p.2">The 'Next Payload', 'Payload Length', 'Protocol ID', 'SPI Size', and 'Notify Message Type' fields are the same as described in Section 3 of <a href="#RFC5996">[RFC5996]</a>.  The 'SPI Size' field MUST be set to 0 to indicate that the SPI is not present in this message.  The 'Protocol ID' MUST be set to 0, since the notification is not specific to a particular security association.  The 'Payload Length' field is set to the length in octets of the entire payload, including the generic payload header.  The 'Notify Message Type' field is set to indicate IKEV2_MESSAGE_ID_SYNC_SUPPORTED, value TBD by IANA. There is no data associated with this notification.  </p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> The IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED Notification</h1>
<p id="rfc.section.6.2.p.1">This notification payload is included in the IKE_AUTH request/response to indicate support for the IPsec SA Replay Counter synchronization mechanism described in this document.  </p>
<div id="#rfc.figure.5"></div>
<pre> 
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </pre>
<p id="rfc.section.6.2.p.2">The 'Next Payload', 'Payload Length', 'Protocol ID', 'SPI Size', and 'Notify Message Type' fields are the same as described in Section 3 of <a href="#RFC5996">[RFC5996]</a> .  The 'SPI Size' field MUST be set to 0 to indicate that the SPI is not present in this message.  The 'Protocol ID' MUST be set to 0, since the notification is not specific to a particular security association.  The 'Payload Length' field is set to the length in octets of the entire payload, including the generic payload header.  The 'Notify Message Type' field is set to indicate IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED, value TBD by IANA. There is no data associated with this notification.  </p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> The IKEV2_MESSAGE_ID_SYNC Notification</h1>
<p id="rfc.section.6.3.p.1">This notification payload type (value TBD by IANA) is defined to synchronize the IKEv2 Message ID values between the newly-active (formerly standby) cluster member and the peer.  </p>
<div id="#rfc.figure.6"></div>
<pre> 

                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Nonce Data                                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             EXPECTED_SEND_REQ_MESSAGE_ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             EXPECTED_RECV_REQ_MESSAGE_ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 

  </pre>
<p id="rfc.section.6.3.p.2">It contains the following data.</p>

<ul>
<li>Nonce Data (4 octets): the random nonce data. The data should be identical in the synchronization request and response.  </li>
<li>EXPECTED_SEND_REQ_MESSAGE_ID (4 octets): this field is used by the sender of this notification payload to indicate the Message ID it will use in the next request that it will send to the other protocol peer.  </li>
<li>EXPECTED_RECV_REQ_MESSAGE_ID (4 octets): this field is used by the sender of this notification payload to indicate the Message ID it is expecting in the next request to be received from the other protocol peer.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> The IPSEC_REPLAY_COUNTER_SYNC Notification</h1>
<p id="rfc.section.6.4.p.1">This notification payload type (value TBD by IANA) is defined to synchronize the IPsec SA Replay Counters between the newly-active (formerly standby) cluster member and the peer.  Since there may be numerous IPsec SAs established under a single IKE SA, we do not directly synchronize the value of each one. Instead, a delta value is sent and all Replay Counters for Child SAs of this IKE SA are incremented by the same value. Note that this solution requires that all these Child SAs either use or do not use Extended Sequence Numbers <a href="#RFC4301">[RFC4301]</a>.  This notification is only sent by the cluster.  </p>
<div id="#rfc.figure.7"></div>
<pre> 
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
|                 Incoming IPsec SA delta value                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
  </pre>
<p id="rfc.section.6.4.p.2">The notification payload contains the following data.  </p>

<ul><li>Incoming IPsec SA delta value (4 or 8 octets): The sender requests that the peer should increment all the Child SA Replay Counters for the sender's incoming (the peer's outgoing) traffic by this value.  The size of this field depends on the ESN bit associated with the Child SAs: if the ESN bit is 1, the field's size is 8 octets, otherwise it is 4 octets. We note that this constrains the Child SAs of each IKE SA to either all have the ESN bit on or off.  </li></ul>

<p> </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Implementation Details</h1>
<p id="rfc.section.7.p.1">This protocol does not change any of the existing IKEv2 rules regarding Message ID values.</p>
<p id="rfc.section.7.p.2">The standby member can initiate the synchronization of IKEv2 Message ID's under different circumstances.  </p>

<ul>
<li>When it receives a problematic IKEv2/IPsec packet, i.e. a packet outside its expected receive window.</li>
<li>When it has to send the first IKEv2/IPsec packet after a failover event.</li>
<li>When it has just received control from the active member and wishes to update the values proactively, so that it need not start this exchange later, when sending or receiving the request.  </li>
</ul>

<p> </p>
<p id="rfc.section.7.p.3">The standby member can initiate the synchronization of IPsec SA Replay Counters: </p>

<ul><li>If there has been traffic using the IPsec SA in the recent past and the standby member suspects that its Replay Counter may be stale.</li></ul>

<p> </p>
<p id="rfc.section.7.p.4">Since there can be a large number of sessions at the standby member, and sending synchronization exchanges for all of them may result in overload, the standby member can choose to initiate the exchange in a "lazy" fashion: only when it has to send or receive the request. In general, the standby member is free to initiate this exchange at its discretion.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> IKE SA and IPsec SA Message Sequencing</h1>
<p id="rfc.section.8.p.1">The straightforward definitions of message sequence numbers, retransmissions and replay protection in IPsec and IKEv2 are strained by the failover scenarios described in this document. This section describes some policy choices that need to be made by implementations in this setting.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Handling of Pending IKE Messages</h1>
<p id="rfc.section.8.1.p.1">After sending its "receive" counter, the cluster member MUST reject any incoming IKE messages that are outside its declared window. A similar rule applies to the peer. Local policies vary, and strict implementations will reject any incoming IKE message arriving before Message ID synchronization is complete.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Handling of Pending IPsec Messages</h1>
<p id="rfc.section.8.2.p.1">For IPsec, there is often a trade-off between security and reliability of the protected protocols.  Here again there is some leeway for local policy. Some implementations might accept incoming traffic that is outside the replay window for some time after the failover event. Strict implementations will only accept traffic that's inside the "safe" window.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> IKE SA Inconsistencies</h1>
<p id="rfc.section.8.3.p.1">IKEv2 is normally a reliable protocol. As long as an IKE SA is valid, both peers share a single, consistent view of the IKE SA and all associated Child SAs. Failover situations as described in this document may involve forced deletion of IKE messages, resulting in inconsistencies, such as Child SAs that exist on only one of the peers. Such SAs would cause an INVALID_SPI to be returned when used by that peer.</p>
<p id="rfc.section.8.3.p.2">The Working Group discussed at some point a proposed set of rules for dealing with such situations. However we believe that these situations should be rare in practice; as a result the "default" behavior of tearing down the entire IKE SA is to be preferred over the complexity of dealing with a multitude of edge cases.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Step by Step Details</h1>
<p id="rfc.section.9.p.1">This section goes through the sequence of steps of a typical failover event, looking at a case where the IKEv2 Message ID values are synchronized.  </p>

<ul>
<li>The active cluster member and the peer device establish the session.  They both announce the capability to synchronize counter information by sending the IKEV2_MESSAGE_ID_SYNC_SUPPORTED notification in the IKE_AUTH Exchange.  </li>
<li>Some time later, the active member dies, and a standby member takes over.  The standby member sends its own idea of the IKE Message IDs (both incoming and outgoing) to the peer in an Informational message exchange with Message ID zero.  </li>
<li>The peer first authenticates the message.  The peer compares the received values with the values available locally and picks the higher value.  It then updates its Message IDs with the higher values and also propose the same values in its response.  </li>
<li>The peer should not wait for any pending responses while responding with the new Message ID values.  For example, if the window size is 5 and the peer's window is 3-7, and if the peer has sent requests 3, 4, 5, 6, 7 and received responses only for 4, 5, 6, 7 but not for 3, then it should include the value 8 in its EXPECTED_SEND_REQ_MESSAGE_ID payload and should not wait for a response to message 3 anymore.  </li>
<li>Similarly, the peer should also not wait for pending (incoming) requests.  For example if the window size is 5 and the peer's window is 3-7  and if the peer has received requests 4, 5, 6, 7 but not 3, then it should send the value 8 in the EXPECTED_RECV_REQ_MESSAGE_ID payload, and should not expect to receive message 3 anymore.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> Interaction with other drafts</h1>
<p id="rfc.section.10.p.1">The usage scenario of the IKEv2/IPsec SA counter synchronization proposal is that an IKEv2 SA has been established between the active member of a hot-standby cluster and a peer, then a failover event occurred with the standby member becoming active. The proposal further assumes that the IKEv2 SA state was continuously synchronized between the active and standby members of the cluster before the failover event.  </p>

<ul>
<li>Session resumption <a href="#RFC5723">[RFC5723]</a> assumes that a peer (client or initiator) detects the need to re-establish the session. In IKEv2/IPsec SA counter synchronization, it is the newly-active member (a gateway or responder) that detects the need to synchronize the SA counter after the failover event.  Also in a hot-standby cluster, the peer establishes the IKEv2/IPsec session with a single IP address that represents the whole cluster, so the peer normally does not detect the event of failover in the cluster unless the standby member takes too long to become active and the IKEv2 SA times out by use of the IKEv2 liveness check mechanism. To conclude, session resumption and SA counter synchronization after failover are mutually exclusive.  </li>
<li>The IKEv2 Redirect mechanism for load-balancing <a href="#RFC5685">[RFC5685]</a> can be used either during the initial stages of SA setup (the IKE_SA_INIT and IKE_AUTH exchanges) or after session establishment. SA counter synchronization is only useful after the IKE SA has been established and a failover event has occurred.  So, unlike Redirect, it is irrelevant during the first two exchanges.  Redirect after the session has been established is mostly useful for timed or planned shutdown/maintenance. A real failover event cannot be detected by the active member ahead of time, and so using Redirect after session establishment is not possible in the case of failover.  So, Redirect and SA counter synchronization after failover are mutually exclusive.  </li>
<li>IKEv2 Failure Detection <a href="#I-D.ietf-ipsecme-failure-detection">[I-D.ietf-ipsecme-failure-detection]</a> solves a similar problem where the peer can rapidly detect that a cluster member has crashed based on a token. It is unrelated to the current scenario because the goal in failover is for the peer not to notice that a failure has occurred.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.11.p.1">Since Message ID synchronization messages need to be sent with Message ID zero, they are potentially vulnerable to replay attacks. Because of the semantics of this protocol, these can only be denial-of-service (DoS) attacks, and we are aware of two variants.  </p>

<ul>
<li>Replay of Message ID synchronization request: This is countered by the requirement that the Send counter sent by the cluster member should always be monotonically increasing, a rule that the peer enforces by silently dropping messages that contradict it.  </li>
<li>Replay of the Message ID synchronization response: This is countered by sending the nonce data along with the synchronization payload.  The same nonce data has to be returned in the response.  Thus the standby member will accept a reply only for the current request.  After it receives a valid response, it MUST NOT process the same response again and MUST discard any additional responses.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> IANA Considerations</h1>
<p id="rfc.section.12.p.1">This document introduces four new IKEv2 Notification Message types as described in Section 6. The new Notify Message Types must be assigned values between 16396 and 40959.</p>
<div id="#rfc.table.1"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Name</th>
<th class="left">Value</th>
</tr></thead>
<tbody>
<tr>
<td class="left">IKEV2_MESSAGE_ID_SYNC_SUPPORTED</td>
<td class="left">TBD by IANA</td>
</tr>
<tr>
<td class="left">IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED</td>
<td class="left">TBD by IANA</td>
</tr>
<tr>
<td class="left">IKEV2_MESSAGE_ID_SYNC</td>
<td class="left">TBD by IANA</td>
</tr>
<tr>
<td class="left">IPSEC_REPLAY_COUNTER_SYNC</td>
<td class="left">TBD by IANA</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> Acknowledgements</h1>
<p id="rfc.section.13.p.1">We would like to thank Pratima Sethi and Frederic Detienne for their review comments and valuable suggestions for the initial version of the document.  </p>
<p id="rfc.section.13.p.2">We would also like to thank the following people (in alphabetical order) for their review comments and valuable suggestions:  Dan Harkins, Paul Hoffman, Steve Kent, Tero Kivinen, David McGrew, and Pekka Riikonen.  </p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#history" id="history">Change Log</a>
</h1>
<p id="rfc.section.14.p.1">This section lists all the changes in this document. </p>
<p id="rfc.section.14.p.2">NOTE TO RFC EDITOR: Please remove this section before publication.</p>
<h1 id="rfc.section.14.1">
<a href="#rfc.section.14.1">14.1.</a> Draft -04</h1>
<p id="rfc.section.14.1.p.1">Extended Sec. 3 for better coverage of other IPsec cluster-related issues, and how they are resolved within the existing standards.</p>
<h1 id="rfc.section.14.2">
<a href="#rfc.section.14.2">14.2.</a> Draft -03</h1>
<p id="rfc.section.14.2.p.1">Clarified the rules for Message ID sync, so that replay attacks can be avoided without a failover counter.</p>
<p id="rfc.section.14.2.p.2">Added wording regarding inconsistent IKE state (basically choosing to ignore the problem) and further rules dealing with pending traffic.</p>
<p id="rfc.section.14.2.p.3">The IPsec replay counter delta value now refers to incoming traffic. The associated notification is only sent from the cluster to the peer, and not back.</p>
<h1 id="rfc.section.14.3">
<a href="#rfc.section.14.3">14.3.</a> Draft -02</h1>
<p id="rfc.section.14.3.p.1">Addressed comments by Yaron Sheffer posted on the WG mailing list. </p>
<p id="rfc.section.14.3.p.2">Numerous editorial changes. </p>
<h1 id="rfc.section.14.4">
<a href="#rfc.section.14.4">14.4.</a> Draft -01</h1>
<p id="rfc.section.14.4.p.1">Added "Multiple and Simultaneous failover' scenarios as pointed out by Pekka Riikonen.</p>
<p id="rfc.section.14.4.p.2">Now document provides a mechanism to sync either IKEv2 message or IPsec replay counter or both to cater different types of implementations. </p>
<p id="rfc.section.14.4.p.3">HA cluster's "failover count' is used to encounter replay of sync requests by attacker. </p>
<p id="rfc.section.14.4.p.4">The sync of IPsec SA replay counter optimized to to have just one global bumped-up outgoing IPsec SA counter of ALL Child SAs under an IKEv2 SA. </p>
<p id="rfc.section.14.4.p.5">The examples added for IKEv2 Message ID sync to provide more clarity. </p>
<p id="rfc.section.14.4.p.6">Some edits as per comments on mailing list to enhance clarity. </p>
<h1 id="rfc.section.14.5">
<a href="#rfc.section.14.5">14.5.</a> Draft  -00</h1>
<p id="rfc.section.14.5.p.1">Version 00 is identical to draft-kagarigi-ipsecme-ikev2-windowsync-04, started as WG document.  </p>
<p id="rfc.section.14.5.p.2">Added IPSECME WG HA design team members as authors. </p>
<p id="rfc.section.14.5.p.3">Added comment in Introduction to discuss the window sync process on WG mailing list to solve some concerns. </p>
<h1 id="rfc.references">
<a href="#rfc.references">15.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">15.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="1">[1]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="2">[2]</b></td>
<td class="top">
<a>Kent, S.</a> and <a>K. Seo</a>, "<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>", RFC 4301, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="3">[3]</b></td>
<td class="top">
<a>Kaufman, C.</a>, <a>Hoffman, P.</a>, <a>Nir, Y.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5996">Internet Key Exchange Protocol Version 2 (IKEv2)</a>", RFC 5996, September 2010.</td>
</tr>
<tr>
<td class="reference"><b id="4">[4]</b></td>
<td class="top">
<a>Nir, Y.</a>, "<a href="http://tools.ietf.org/html/rfc6027">IPsec Cluster Problem Statement</a>", RFC 6027, October 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">15.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="1">[1]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="http://tools.ietf.org/html/rfc3686">Using Advanced Encryption Standard (AES) Counter Mode With IPsec Encapsulating Security Payload (ESP)</a>", RFC 3686, January 2004.</td>
</tr>
<tr>
<td class="reference"><b id="2">[2]</b></td>
<td class="top">
<a>Viega, J.</a> and <a>D. McGrew</a>, "<a href="http://tools.ietf.org/html/rfc4106">The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)</a>", RFC 4106, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="3">[3]</b></td>
<td class="top">
<a>Devarapalli, V.</a> and <a>K. Weniger</a>, "<a href="http://tools.ietf.org/html/rfc5685">Redirect Mechanism for the Internet Key Exchange Protocol Version 2 (IKEv2)</a>", RFC 5685, November 2009.</td>
</tr>
<tr>
<td class="reference"><b id="4">[4]</b></td>
<td class="top">
<a>Sheffer, Y.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc5723">Internet Key Exchange Protocol Version 2 (IKEv2) Session Resumption</a>", RFC 5723, January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="5">[5]</b></td>
<td class="top">
<a>Nadas, S.</a>, "<a href="http://tools.ietf.org/html/rfc5798">Virtual Router Redundancy Protocol (VRRP) Version 3 for IPv4 and IPv6</a>", RFC 5798, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="6">[6]</b></td>
<td class="top">
<a>McGrew, D.</a> and <a>B. Weis</a>, "<a href="http://tools.ietf.org/html/rfc6054">Using Counter Modes with Encapsulating Security Payload (ESP) and Authentication Header (AH) to Protect Group Traffic</a>", RFC 6054, November 2010.</td>
</tr>
<tr>
<td class="reference"><b id="7">[7]</b></td>
<td class="top">
<a>Nir, Y</a>, <a>Wierbowski, D</a>, <a>Detienne, F</a> and <a>P Sethi</a>, "<a href="http://tools.ietf.org/html/draft-ietf-ipsecme-failure-detection-08">A Quick Crash Detection Method for IKE</a>", Internet-Draft draft-ietf-ipsecme-failure-detection-08, April 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#Examples" id="Examples">IKEv2 Message ID Sync Examples</a>
</h1>
<p id="rfc.section.Appendix A.p.1">This (non-normative) section presents some examples that illustrate how the IKEv2 Message ID values are synchronized.  We use a tuple notation, denoting the two counters EXPECTED_SEND_REQ_MESSAGE_ID and EXPECTED_RECV_REQ_MESSAGE_ID on a member as (EXPECTED_SEND_REQ_MESSAGE_ID, EXPECTED_RECV_REQ_MESSAGE_ID).  </p>
<h1 id="rfc.appendix.Appendix A.1">
<a href="#rfc.appendix.Appendix%20A.1">Appendix A.1.</a> Normal Failover - Example 1</h1>
<div id="#rfc.figure.8"></div>
<pre> 

Standby (Newly Active) Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sync Request (2, 3) --------&gt;
                    
                          Peer has the values (4, 5) so it sends             
             &lt;------------- (4, 5) as the Sync Response

        </pre>
<h1 id="rfc.appendix.Appendix A.2">
<a href="#rfc.appendix.Appendix%20A.2">Appendix A.2.</a> Normal Failover - Example 2</h1>
<div id="#rfc.figure.9"></div>
<pre> 

Standby (Newly Active) Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sync Request (2, 5) --------&gt;
                    
                          Peer has the values (2, 4) so it sends   
             &lt;-------------(5, 4) as the Sync Response

        </pre>
<h1 id="rfc.appendix.Appendix A.3">
<a href="#rfc.appendix.Appendix%20A.3">Appendix A.3.</a> Simultaneous Failover</h1>
<p id="rfc.section.Appendix A.3.p.1">In the case of simultaneous failover, both sides send the synchronization request, but whichever side has the higher value will be eventually synchronized.  </p>
<div id="#rfc.figure.10"></div>
<pre> 

Standby (Newly Active) Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Sync Request (4,4)     -----&gt;

                 &lt;-------------- Sync Request (5,5)

Sync Response (5,5)    ----&gt;

                     &lt;--------  Sync Response (5,5)

        </pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Raj Singh (Editor)</span> 
	  <span class="n hidden">
		<span class="family-name">Singh, Ed.</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems, Inc.</span>
	<span class="adr">
	  <span>Divyashree Chambers, B Wing, O'Shaugnessy Road</span>

	  <span class="vcardline">
		<span class="locality">Bangalore</span>,  
		<span class="region">Karnataka</span> 
		<span class="code">560025</span>
	  </span>
	  <span class="country-name vcardline">India</span>
	</span>
	<span class="vcardline">Phone: +91 80 4301 3320</span>

<span class="vcardline">EMail: <a href="mailto:rsj@cisco.com">rsj@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Kalyani Garigipati</span> 
	  <span class="n hidden">
		<span class="family-name">Kalyani</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems, Inc.</span>
	<span class="adr">
	  <span>Divyashree Chambers, B Wing, O'Shaugnessy Road</span>

	  <span class="vcardline">
		<span class="locality">Bangalore</span>,  
		<span class="region">Karnataka</span> 
		<span class="code">560025</span>
	  </span>
	  <span class="country-name vcardline">India</span>
	</span>
	<span class="vcardline">Phone: +91 80 4426 4831</span>

<span class="vcardline">EMail: <a href="mailto:kagarigi@cisco.com">kagarigi@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Yoav Nir</span> 
	  <span class="n hidden">
		<span class="family-name">Nir</span>
	  </span>
	</span>
	<span class="org vcardline">Check Point Software Technologies Ltd.</span>
	<span class="adr">
	  <span>5 Hasolelim St.</span>

	  <span class="vcardline">
		<span class="locality">Tel Aviv</span>,  
		<span class="region"></span>
		<span class="code">67897</span>
	  </span>
	  <span class="country-name vcardline">Israel</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ynir@checkpoint.com">ynir@checkpoint.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Yaron Sheffer</span> 
	  <span class="n hidden">
		<span class="family-name">Sheffer</span>
	  </span>
	</span>
	<span class="org vcardline">Independent</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:yaronf.ietf@gmail.com">yaronf.ietf@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dacheng Zhang</span> 
	  <span class="n hidden">
		<span class="family-name">Zhang</span>
	  </span>
	</span>
	<span class="org vcardline">Huawei Technologies Ltd.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:zhangdacheng@huawei.com">zhangdacheng@huawei.com</a></span>

  </address>
</div>

</body>
</html>