D_ITER = 0x00 in the iterations of the LM-OTS algorithms

D_PBLC = 0x01 when computing the hash of all of the iterates in
D_MESG = 0x02 when computing the hash of the message in the LM-
D_LEAF = 0x03 when computing the hash of the leaf of an LMS
D_INTR = 0x04 when computing the hash of an interior node of an
tmp = x[i]
tmp = H(tmp || I || q || u16str(i) || u8str(j) || D_ITER)
sum = 0
sum = sum + (2^w - 1) - coef(S, i, w)
Q = H(C || I || q || D_MESG || message)
a = coef(Q || Cksm(Q), i, w)
tmp = x[i]
tmp = H(tmp || I || q || u16str(i) || u8str(j) || D_ITER)
type = first 4 bytes
C = next n bytes
q = next four bytes
Q = H(C || I || q || D_MESG || message)
a = (2^w - 1) - coef(Q || Cksm(Q), i, w)
tmp = y[i]
tmp = H(tmp || I || q || u16str(i) || u8str(j) || D_ITER)
candidate = H(I || q || z[0] || z[1] || ... || z[p-1] || D_PBLC)
tmp = candidate public key computed from LM-OTS signature and message
tmp = H(tmp || I || u32str(node_num) || D_LEAF)
i = 0
n = node number = 2^h + q
tmp = H(path[i] || tmp || I || u32str(node_num/2) || D_INTR)
tmp = H(tmp || path[i] || I || u32str(node_num/2) || D_INTR)
node_num = node_num/2
i = i + 1
ots_reserved         = 0,
lmots_sha256_n16_w1  = 1,
lmots_sha256_n16_w2  = 2,
lmots_sha256_n16_w4  = 3,
lmots_sha256_n16_w8  = 4,
lmots_sha256_n32_w1  = 5,
lmots_sha256_n32_w2  = 6,
lmots_sha256_n32_w4  = 7,
lmots_sha256_n32_w8  = 8
lms_reserved       = 0,
lms_sha256_n32_h20 = 1,
lms_sha256_n32_h10 = 2,
lms_sha256_n32_h5  = 3,
lms_sha256_n16_h20 = 4,
lms_sha256_n16_h10 = 5,
lms_sha256_n16_h5  = 6
reserved             = 0,
type_lms_public_key  = 1,
type_lms_private_key = 2,
type_hss_public_key  = 3,
type_hss_private_key = 4,
type_hss_signature   = 5
n=16, the LM-OTS iterates a 55-byte value (that is, the string that
c = Cksm(H(message)) (see Section 4.7).  To attempt a forgery, an
a = coef(h, j, w), and

b = coef(c, k, w), and
u = ceil(8*n/w)
v = ceil((floor(lg((2^w - 1) * u)) + 1) / w)
ls = (number of bits in sum) - (v * w)
p = u + v

level = 0;
r = node number
siblings = ""
siblings = (pop(data stack) || siblings)
level = pop(integer stack)
r = node number
public_key = pop(data stack)

   Note that this pseudocode expects that all 2^h leaves of the tree
   have equal depth.  Neither stack ever contains more than h+1
   elements.  For typical parameters, these stacks will hold around 512
   bytes of data.
