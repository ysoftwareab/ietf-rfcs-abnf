<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Trust Anchor Management Problem Statement</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Trust Anchor Management Problem Statement">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">R. Reddy</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">National Security Agency</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">C. Wallace</td></tr>
<tr><td class="header">Expires: August 21, 2008</td><td class="header">Cygnacom Solutions</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">February 18, 2008</td></tr>
</table></td></tr></table>
<h1><br />Trust Anchor Management Problem Statement<br />draft-ietf-pkix-ta-mgmt-problem-statement-01</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on August 21, 2008.</p>

<h3>Abstract</h3>

<p>
        A trust anchor is an authoritative entity represented via a public key and associated data.  The public key is used to verify digital signatures and the associated data is used to constrain the types of information for which the trust anchor is authoritative.  A relying party uses trust anchors to determine if a digitally signed object is valid by verifying a digital signature using the trust anchor's public key, and by enforcing the constraints expressed in the associated data for the trust anchor.  This document describes some of the problems associated with the lack of a standard trust anchor management mechanism as well as problems that must be addressed by such a mechanism.  This document discusses only public keys as trust anchors; symmetric key trust anchors are not considered.
      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Terminology<br />
<a href="#anchor3">2.</a>&nbsp;
Problem Statement<br />
<a href="#anchor4">3.</a>&nbsp;
Functional Properties<br />
<a href="#anchor5">4.</a>&nbsp;
Security Considerations<br />
<a href="#anchor6">5.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">6.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">6.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">6.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
        Digital signatures are used in many applications.  For digital signatures to provide integrity and
        authentication, the public key used to verify the digital signature must be "trusted", i.e., accepted by a relying paty (RP) as authoritative for an application.  A public key used to verify a signature must be configured as a trust anchor or contained in a certificate that can be transitively verified by a certification path terminating at a trust anchor.  Directly trusted public keys are known as trust anchors.  A Trust Anchor is a public key and associated data used by a relying party to validate a signature on a signed object where the object is either: 
</p>
<p>
        </p>
<ul class="text">
<li>a public key certificate that begins a certification path terminated by a signature certificate or encryption certificate
</li>
<li>an object (other than a public key certificate) that cannot be validated via use of a certification path
</li>
</ul><p>
      
</p>
<p>
        Trust anchors have only local significance, i.e., each RP is configured with a set of trust anchors, either by the RP or by an entity that manages TAs in the context in which the RP operates. The associated data often is used to define the scope of a trust anchor, by imposing constraints on the signatures it may be used to verify. For example, if a trust anchor is used to verify signatures on X.509 certificates, these constraints may include a combination of name spaces, certificate policies, or application/usage types.  Whenever a signature is verified, a trust anchor must be used, either by verifying the signature directly using a TA or by validating a certification path that begins with a TA.
      
</p>
<p>One particular use of digital signatures is the verification of signatures on firmware packages loaded into hardware modules, such as cryptographic modules, cable boxes, routers, etc.  Since such devices are often managed remotely, the devices must be able to authenticate the source of management interactions and can use trust anchors to perform this authentication.  However, trust anchors require management as well.
      
</p>
<p>
        All applications that rely upon digital signatures rely upon some means of managing one or more sets of trust anchors.  These sets of trust anchors are referred to in this document as trust anchor stores.  Often, the means of managing trust anchor stores are application-specific and rely upon out-of-band means to establish and maintain trustworthiness.  An application may use multiple trust anchor stores and a given trust anchor store may be used by multiple applications.  Trust anchor stores are managed by trust anchor managers.
      
</p>
<p>
        In some cases, a device may have a single trust anchor that is
        hard-wired or managed only through physical access to the device.
        However, to support the ability to delegate different TA managment functions to
        different authorities, the device may require multiple trust anchors.  It
        may be desirable to manage these trust anchors using similar means as
        software updates, certificate requests, etc., to enable code reuse.
      
</p>
<p>This section provides an introduction and defines basic terminology.  Section 2 describes problems with current trust anchor management methods.  Sections 3 and 4 describe functional properties and security considerations for a trust anchor management solution, and essentially define requirements for a trust anchor management solution.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Terminology</h3>

<p>The following terms are defined in order to provide a vocabulary for describing requirements for trust anchor management.
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Trust Anchor: </dt>
<dd>
              A trust anchor is an authoritative entity represented via a public key and associated data.  The public key is used to verify digital signatures and the associated data is used to constrain the types of information for which the trust anchor is authoritative.  A relying party uses trust anchors to determine if a digitally signed object is valid by verifying a digital signature using the trust anchor's public key, and by enforcing the constraints expressed in the associated data for the trust anchor.
            
</dd>
<dt>Trust Anchor Manager: </dt>
<dd>
              A trust anchor manager is a role responsible for managing the contents of a trust anchor store.  
            
</dd>
<dt>Trust Anchor Store: </dt>
<dd>
              A trust anchor store is a set of one or more trust anchors.  A trust anchor store may be managed by one or more trust anchor managers.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Problem Statement</h3>

<p>
        Trust anchors are used to support many application scenarios. Most
        Internet browsers and email clients use trust anchors when authenticating
        TLS sessions, verifying signed email and generating encrypted email by validating a certification path to a server's certificate or a mail originator's or recipient's certificate.
        Many software distributions are digitally signed to enable
        authentication of the software source to be performed prior to
        installation.  Trust anchors that support these applications are
        typically installed as part of the operating system (OS) or application,
        installed using an enterprise configuration management system or
        installed directly by an OS or application user.  An application and platform-independent way to manage TAs would be preferable.
      
</p>
<p>
        Trust anchors are typically stored in application- or operating system-
        specific trust anchor stores.  Often, a single machine may have a
        number of different trust anchor stores that may not be
        synchronized.  Reviewing the contents of
        a particular trust anchor store typically involves use of a
        proprietary tool that interacts with a particular type of trust
        store.
      
</p>
<p>
        The presence of a trust anchor in a particular store often conveys implicit authorization to validate signatures for any contexts from which the store is accessed.  For example, the public key of a timestamp authority (TSA) may be installed in a trust anchor store to validate signatures on timestamps.  However, if the store containing this TA is used by multiple applications that serve different purposes, the same key may be used (inappropriately) to validate other types of objects such as certificates or OCSP responses.  There is currently no standard means of limiting the applicability (scope) of a trust anchor except by placing different TAs in different stores and limiting the set of applications that access a given TA store.
      
</p>
<p>
        Trust relationships between PKIs are negotiated by policy
        authorities.  Negotiations frequently require significant time to
        ensure all participating parties' requirements are satisfied.  These
        requirements are expressed, to some extent, in public key
        certificates via policy constraints, name constraints and etc.  In order for these requirements to be enforced, trust
        anchor stores must be managed in accord with policy authority
        intentions and avoid circumventing constraints defined in a cross-certificate by recognizing the subject of the cross certificate as a trust anchor.
      
</p>
<p>
        Trust anchors are often represented as self-signed certificates,
        which provide no useful means of establishing the validity of the
        information contained in the certificate.  Confidence in the integrity of a trust anchor is typically  established
        through out-of-band means, often by checking the "fingerprint" (one-way hash) of the
        self-signed certificate with an authoritative source.  Routine trust
        anchor re-key operations typically require similar out-of-band
        checks. Ideally, only the initial set of trust anchors installed in a
        particular trust anchor store should require out-of-band verification,
        particularly when the costs of performing out-of-band checks
        commensurate with the security requirements of applications using the trust anchor store are high.
      
</p>
<p>
        Despite the prevalent use of trust anchors, there is neither a
        standard means for discovering which trust anchors installed in a
        particular trust anchor store nor a standard means of managing those trust anchors.  The
        remainder of this document describes some of the functional
        characteristics a solution to this problem should exhibit along with
        some security considerations.
      
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Functional Properties</h3>

<p>
        A general-purpose solution for the management of trust anchors must
        be transport independent in order to apply to a range of device
        communications environments.  It should also be applicable in both session-oriented and store-and-forward contexts.  At a minimum, it must enable a trust anchor manager to discovery which TA stores are present, to add trust anchors to, remove trust anchors from, and determine which trust anchors are installed in a particular trust anchor store.
      
</p>
<p>
        Trust anchor configurations may be uniform across an enterprise, or
        they may be unique to a single application or small set of applications.
        A protocol for TA management must allow a TA management transaction, to be directed to all TA stores for which the manager is responsible, targeted to
        an enumerated list of one or more groups of trust anchor stores, or targeted to an individual trust anchor store.
      
</p>
<p>
        Once installed into a trust anchor store, a trust anchor represents an entity with authority
        recognized by applications that use that store.  It is important to be able to define the scope of
        authority associated with each trust anchor.  That scope be very specific (e.g., a trust anchor public
        key may be limited to verification of firmware updates only), or more general (such as to validate certification paths for certificates issued to users or devices).  It should be
        possible to authorize a trust anchor to delegate authority (to other TAs) and
        to prevent delegation.
      
</p>
<p>
        A trust anchor manager has significant control over a device or application
        due to the ability to control what other authorities are recognized.  In some cases, a trust anchor manager may be the legal owner of a device or application.  In other cases, a trust anchor manager may be an entity responsible for the operation of a device, such as a firmware provider for a cable or satellite TV set top box.  A trust anchor manager may be
        static over the life of a device, or it may change as legal ownership
        or other factors change.  A trust anchor management protocol should
        enable secure transfer of control of a device from one trust anchor manager to
        another.  It also should enable delegation of TA management control over specific aspects of the device,
        without requiring delegation of the overall trust anchor management capability itself.
        Trust anchor re-key is one type of transfer that must be supported.
      
</p>
<p>
        A trust anchor management protocol must be capable of managing trust
        anchors that can be used to validate certification paths in
        accordance with <a class='info' href='#RFC3280'>[RFC3280]<span> (</span><span class='info'>Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; April&nbsp;2002.</span><span>)</span></a>.  Minimally, the definition of a trust anchor
        must include a public key, a public key algorithm and, if necessary,
        public key parameters.  When the public key is used to validate
        certification paths, a distinguished name also must be included.  A
        public key identifier should be included to enable other applications
        of the trust anchor, for example, verification of data signed using
        the Cryptographic Message Syntax SignedData structure <a class='info' href='#RFC3852'>[RFC3852]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a>.
      
</p>
<p>
        Trust anchors may be explicitly authorized for a limited set of
        purposes.  For example, a trust anchor may be authorized for verification of signed firmware packages <a class='info' href='#RFC4108'>[RFC4108]<span> (</span><span class='info'>Housley, R., &ldquo;Using Cryptographic Message Syntax (CMS) to Protect Firmware Packages,&rdquo; August&nbsp;2005.</span><span>)</span></a> but not authorized for validating certification paths.
        A trust anchor management protocol must enable the management of trust
        anchors that do not serve as trust anchors for
        certification path validation.
      
</p>
<p>
        Connections between PKIs can be accomplished using different means.
        Unilateral or bilateral cross-certification can be performed, or a
        community may simply elect to explicitly accept a trust anchor from
        another community.  Typically, these decisions occur at the
        enterprise level.  In some scenarios, it can be useful to establish
        these connections for a small community within an enterprise.
        Enterprise-wide mechanisms such as cross-certificates are ill-suited
        for this purpose since certificate revocation or expiration affects
        the entire enterprise.  A trust anchor management protocol can
        address this issue by supporting limited installation of trust
        anchors and by supporting expression of constraints on trust anchor usage.  Limited installation requires
        the ability to identify the members of the community that are
        authorized to rely upon a particular trust anchor, as well as the
        ability to query and report on the contents of trust anchor
        stores.  The trust anchor constraints can represent the limitations that would have been expressed in a cross-certificate and limited installation ensures the recognition of the trust anchor does not necessarily encompass and entire enterprise.
      
</p>
<p>
        There is no standardized format for trust anchors.  Self-signed X.509 certificates are typically used but <a class='info' href='#RFC3280'>[RFC3280]<span> (</span><span class='info'>Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; April&nbsp;2002.</span><span>)</span></a> does not mandate a particular trust anchor representation.  It requires only that a trust anchor's public key information and distinguished name be available during certification path validation.  Minimally, a trust anchor management protocol should support management of trust anchors represented as self-signed certificates or as a distinguished name and public key information.
      
</p>
<p>
        A trust anchor manager must be able to authenticate which device
        produced a report listing the contents of a trust anchor store and, be able to confirm the contents of the report have
        not been subsequently altered.  Replay of old reports (from the same device)
        must be detectable by a TA manager.
      
</p>
<p>
        A trust anchor definition should enable the representation of
        constraints that influence certification path validation or otherwise establish the scope of usage of
        the trust anchor public key.  Examples of such constraints are name constraints, certificate policies and key usage.  A trust anchor manager must be able to establish the constraints associated with every trust anchor controlled by the manager.
      
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Security Considerations</h3>

<p>The integrity of trust anchor management transactions must be assured, i.e.,  and it must be possible to authenticate the originator of a TA management transaction and confirm the authorization of the originator for that transaction.
</p>
<p>
        Traditionally, a trust anchor is distributed out-of-band with
        its integrity checked manually prior to installation.  Installation typically is performed by anyone with sufficient
        administrative privilege on the system receiving the trust anchor.
        A trust anchor management protocol should enable TA integrity to be
        checked automatically by relying upon a public key that is resident
        in a client system participating in the protocol.  
      
</p>
<p>
        The public key used to authenticate the trust anchor management
        transactions may have been placed in the client as the result of an
        earlier transaction, or during an initial bootstrap configuration
        operation.  In most scenarios, at least one public key authorized for trust anchor
        management must be placed in each trust store to be managed during the
        initial configuration of the trust store.  This public key may be
        transported and checked using traditional out-of-band means.  In all scenarios, regardless of the authentication mechanism, at least one trust anchor manager must be established for each trust store during the initial configuration of the trust store.
      
</p>
<p>
        An entity receiving trust anchor information must be able to
        authenticate the party providing the information and must be able to
        confirm the party is authorized to provide that trust anchor information.
        A trust anchor manager may be authorized to participate in trust anchor
        management protocol exchanges, but be limited to managing trust anchors
        within a particular scope.  Alternatively, a trust anchor manager may be
        authorized to participate in trust anchor management protocol
        exchanges without any constraints on the types of trust anchors that
        may be managed.  Clear subordination rules must be defined so that an administrator can determine, unambiguously, the scope of authority for any trust anchor installed in a device.
      
</p>
<p>
        Some devices that utilize trust anchors may have no access to a reliable
        source of time.  Trust anchor management transactions should enable
        such devices to engage in trust anchor management protocol exchanges without being
        subject to replay attacks that could add old or no-longer-trusted
        trust anchors to a trust anchor store.
      
</p>
<p>
        Compromise of a private key corresponding to a trust anchor can have significant
        negative consequences.  A trust anchor management protocol must
        enable recovery from the compromise of a trust
        anchor private key, including the private key authorized to serve as
        a source of trust anchor information.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
IANA Considerations</h3>

<p>None.  Please remove this section prior to publication as an RFC.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3280">[RFC3280]</a></td>
<td class="author-text">Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;<a href="http://tools.ietf.org/html/rfc3280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;3280, April&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3280.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3852">[RFC3852]</a></td>
<td class="author-text">Housley, R., &ldquo;<a href="http://tools.ietf.org/html/rfc3852">Cryptographic Message Syntax (CMS)</a>,&rdquo; RFC&nbsp;3852, July&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3852.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4108">[RFC4108]</a></td>
<td class="author-text">Housley, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4108">Using Cryptographic Message Syntax (CMS) to Protect Firmware Packages</a>,&rdquo; RFC&nbsp;4108, August&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4108.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Raksha Reddy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">National Security Agency</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Suite 6751</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">9800 Savage Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fort Meade, MD  20755</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:r.reddy@radium.ncsc.mil">r.reddy@radium.ncsc.mil</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Carl Wallace</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cygnacom Solutions</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Suite 5200</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">7925 Jones Branch Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">McLean, VA  22102</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:cwallace@cygnacom.com">cwallace@cygnacom.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
