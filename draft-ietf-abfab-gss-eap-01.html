<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>A GSS-API Mechanism for the Extensible Authentication Protocol</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Discovery">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Authentication">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Secure Association Protocol">
<link href="#rfc.section.2" rel="Chapter" title="2 Requirements notation">
<link href="#rfc.section.3" rel="Chapter" title="3 EAP Channel Binding and Naming">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Mechanism Name Format">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Exported Mechanism Names">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Acceptor Name RADIUS AVP">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Proxy Verification of Acceptor Name">
<link href="#rfc.section.4" rel="Chapter" title="4 Selection of EAP Method">
<link href="#rfc.section.5" rel="Chapter" title="5 Context Tokens">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Mechanisms and Encryption Types">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Context Options">
<link href="#rfc.section.6" rel="Chapter" title="6 Acceptor Services">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 GSS-API Channel       Binding">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Per-message security">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Pseudo Random Function">
<link href="#rfc.section.7" rel="Chapter" title="7 Open Mechanism Issues">
<link href="#rfc.section.8" rel="Chapter" title="8 Applicability Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document defines protocols, procedures, and conventions to be employed by peers implementing the Generic Security Service Application Program Interface (GSS-API) when using the EAP mechanism.  Through the GS2 family of mechanisms, these protocols also define how Simple Authentication and Security Layer (SASL, RFC 4422) applications use the Extensible Authentication Protocol." />
  <meta name="description" content="This document defines protocols, procedures, and conventions to be employed by peers implementing the Generic Security Service Application Program Interface (GSS-API) when using the EAP mechanism.  Through the GS2 family of mechanisms, these protocols also define how Simple Authentication and Security Layer (SASL, RFC 4422) applications use the Extensible Authentication Protocol." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">S. Hartman, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Painless Security</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">J. Howlett</td>
</tr>
<tr>
<td class="left">Expires: August 21, 2011</td>
<td class="right">JANET(UK)</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 17, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">A GSS-API Mechanism for the Extensible Authentication Protocol<br />
  <span class="filename">draft-ietf-abfab-gss-eap-01.txt</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines protocols, procedures, and conventions to be employed by peers implementing the Generic Security Service Application Program Interface (GSS-API) when using the EAP mechanism.  Through the GS2 family of mechanisms, these protocols also define how Simple Authentication and Security Layer (SASL, RFC 4422) applications use the Extensible Authentication Protocol.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 21, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Discovery</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Authentication</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Secure Association Protocol</a>
</li>
<li>2.   <a href="#rfc.section.2">Requirements notation</a>
</li>
<li>3.   <a href="#rfc.section.3">EAP Channel Binding and Naming</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Mechanism Name Format</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Exported Mechanism Names</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Acceptor Name RADIUS AVP</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Proxy Verification of Acceptor Name</a>
</li>
<li>4.   <a href="#rfc.section.4">Selection of EAP Method</a>
</li>
<li>5.   <a href="#rfc.section.5">Context Tokens</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Mechanisms and Encryption Types</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Context Options</a>
</li>
<li>6.   <a href="#rfc.section.6">Acceptor Services</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">GSS-API Channel       Binding</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Per-message security</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Pseudo Random Function</a>
</li>
<li>7.   <a href="#rfc.section.7">Open Mechanism Issues</a>
</li>
<li>8.   <a href="#rfc.section.8">Applicability Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">The ABFAB architecture <a href="#I-D.lear-abfab-arch">[I-D.lear-abfab-arch]</a> describes an architecture for providing federated access management to applications using the Generic Security Services Application Programming Interface (GSS-API) <a href="#RFC2743">[RFC2743]</a> and Simple Authentication and Security Layers (SASL) <a href="#RFC4422">[RFC4422]</a>. This specification provides the core mechanism for bringing federated authentication to these applications.</p>
<p id="rfc.section.1.p.2">The Extensible Authentication Protocol (EAP) <a href="#RFC3748">[RFC3748]</a> defines a framework for authenticating a network access client and server in order to gain access to a network.  A variety of different EAP methods are in wide use; one of EAP's strengths is that for most types of credentials in common use, there is an EAP method that permits the credential to be used.</p>
<p id="rfc.section.1.p.3">EAP is often used in conjunction with a backend authentication server via RADIUS <a href="#RFC3579">[RFC3579]</a> or Diameter <a href="#RFC4072">[RFC4072]</a>.  In this mode, the NAS simply tunnels EAP packets over the backend authentication protocol to a home EAP/AAA server for the client.  After EAP succeeds, the backend authentication protocol is used to communicate key material to the NAS.  In this mode, the NAS need not be aware of or have any specific support for the EAP method used between the client and the home EAP server.  The client and EAP server share a credential that depends on the EAP method; the NAS and AAA server share a credential based on the backend authentication protocol in use.  The backend authentication server acts as a trusted third party enabling network access even though the client and NAS may not actually share any common authentication methods.  As described in the architecture document, using AAA proxies, this mode can be extended beyond one organization to provide federated authentication for network access. </p>
<p id="rfc.section.1.p.4">The GSS-API provides a generic framework for applications to use security services including authentication and per-message data security.  Between protocols that support GSS-API directly or protocols that support SASL <a href="#RFC4422">[RFC4422]</a>, many application protocols can use GSS-API for security services.  However, with the exception of Kerberos <a href="#RFC4121">[RFC4121]</a>, few GSS-API mechanisms are in wide use on the Internet.  While GSS-API permits an application to be written independent of the specific GSS-API mechanism in use, there is no facility to separate the server from the implementation of the mechanism as there is with EAP and backend authentication servers.  </p>
<p id="rfc.section.1.p.5">The goal of this specification is to combine GSS-API's support for application protocols with EAP/AAA's support for common credential types and for authenticating to a server without requiring that server to specifically support the authentication method in use.  In addition, this specification supports thearchitecture goal of transporting attributes about subjects to relying parties.  Together this combination will provide federated authentication and authorisation for GSS-API applications.</p>
<p id="rfc.section.1.p.6">This mechanism is a GSS-API mechanism that encapsulates an EAP conversation.  From the perspective of RFC 3748, this specification defines a new lower-layer protocol for EAP. From the prospective of the application, this specification defines a new GSS-API mechanism.</p>
<p id="rfc.section.1.p.7">Section 1.3 of <a href="#RFC5247">[RFC5247]</a> outlines the typical conversation between EAP peers where an EAP key is derived:</p>

<ul>
<li>Phase 0: Discovery</li>
<li>Phase 1: Authentication</li>
<li>1a: EAP authentication</li>
<li>1b: AAA Key Transport (optional)</li>
<li>Phase 2: Secure Association Protocol</li>
<li>2a: Unicast Secure Association</li>
<li>2b: Multicast Secure Association (optional)</li>
</ul>

<p> </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Discovery</h1>
<p id="rfc.section.1.1.p.1">GSS-API peers discover each other and discover support for GSS-API in an application-dependent mechanism.  SASL <a href="#RFC4422">[RFC4422]</a> describes how discovery of a particular SASL mechanism such as a GSS-API mechanism is conducted.  The Simple and Protected Negotiation mechanism (SPNEGO) <a href="#RFC4178">[RFC4178]</a> provides another approach for discovering what GSS-API mechanisms are available.  The specific approach used for discovery is out of scope for this mechanism.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Authentication</h1>
<p id="rfc.section.1.2.p.1">GSS-API authenticates a party called the GSS-API initiator to the GSS-API acceptor, optionally providing authentication of the acceptor to the initiator.  Authentication starts with a mechanism-specific message called a context token sent from the initiator to the acceptor.  The acceptor may respond, followed by the initiator, and so on until authentication succeeds or fails.  GSS-API context tokens are reliably delivered by the application using GSS-API.  The application is responsible for in-order delivery and retransmission.</p>
<p id="rfc.section.1.2.p.2">EAP authentication can be started by either the peer or the authenticator, although the first EAP message travels from the authenticator to the peer.  The EAP peer maps onto the GSS-API initiator.  The role of the GSS-API acceptor is split between the EAP authenticator and the EAP server. When these two entities are combined, the division resembles GSS-API acceptors in other mechanisms. When a more typical deployment is used and there is a passthrough authenticator, most context establishment takes place on the EAP server and per-message operations take place on the authenticator. EAP messages from the peer to the authenticator are called responses; messages from the authenticator to the peer are called requests.  </p>
<p id="rfc.section.1.2.p.3">This specification permits a GSS-API peer to hand-off the processing of the EAP packets to a remote EAP server by using AAA protocols such as RADIUS, RadSec or Diameter. In this case, the GSS-API peer acts as an EAP pass-through authenticator.  If EAP authentication is successful, and where the chosen EAP method supports key derivation, EAP keying material may also be derived. If an AAA protocol is used, this can also be used to replicate the EAP Key from the EAP server to the EAP authenticator.</p>
<p id="rfc.section.1.2.p.4">See <a href="#CONTEXT">Section 5</a> for details of the authentication exchange.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Secure Association Protocol</h1>
<p id="rfc.section.1.3.p.1">After authentication succeeds, GSS-API provides a number of per-message security services that can be used:</p>

<ul class="empty">
<li>GSS_Wrap() provides integrity and optional confidentiality for a message.</li>
<li>GSS_GetMIC() provides integrity protection for data sent independently of the GSS-API</li>
<li>GSS_Pseudo_random <a href="#RFC4401">[RFC4401]</a> provides key derivation functionality.</li>
</ul>

<p> </p>
<p id="rfc.section.1.3.p.2">These services perform a function similar to security association protocols in network access.  Like security association protocols, these services need to be performed near the authenticator/acceptor even when a AAA protocol is used to separate the authenticator from the EAP server.  The key used for these per-message services is derived from the EAP key; the EAP peer and authenticator derive this key as a result of a successful EAP authentication. In the case that the EAP authenticator is acting as a pass-through it obtains it via the AAA protocol.  See <a href="#ACCEPTOR-SERVICES">Section 6</a> for details.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Requirements notation</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> EAP Channel Binding and Naming</h1>
<p id="rfc.section.3.p.1">EAP authenticates a realm.  The peer knows that it has exchanged authentication with an EAP server in a given realm.  Today, the peer does not typically know which NAS it is talking to securely.  That is often fine for network access.  However privileges to delegate to a chat server seem very different than privileges for a file server or trading site.  Also, an EAP peer knows the identity of the home realm, but perhaps not even the visited realm.  </p>
<p id="rfc.section.3.p.2">In contrast, GSS-API takes a name for both the initiator and acceptor as inputs to the authentication process.  When mutual authentication is used, both parties are authenticated.  The granularity of these names is somewhat mechanism dependent.  In the case of the Kerberos mechanism, the acceptor name typically identifies both the protocol in use (such as IMAP) and the specific instance of the service being connected to.  The acceptor name almost always identifies the administrative domain providing service.  </p>
<p id="rfc.section.3.p.3">An EAP GSS-API mechanism needs to provide GSS-API naming semantics in order to work with existing GSS-API applications.  EAP channel binding <a href="#I-D.ietf-emu-chbind">[I-D.ietf-emu-chbind]</a> is used to provide GSS-API naming semantics.  Channel binding sends a set of attributes from the peer to the EAP server either as part of the EAP conversation or as part of a secure association protocol.  In addition, attributes are sent in the backend authentication protocol from the authenticator to the EAP server.  The EAP server confirms the consistency of these attributes.  Confirming attribute consistency also involves checking consistency against a local policy database as discussed below.  In particular, the peer sends the name of the acceptor it is authenticating to as part of channel binding.  The acceptor sends its full name as part of the backend authentication protocol.  The EAP server confirms consistency of the names.</p>
<p id="rfc.section.3.p.4">EAP channel binding is easily confused with a facility in GSS-API also called channel binding.  GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used as authentication inside some tunnel; it is similar to a facility called cryptographic binding in EAP.  See <a href="#RFC5056">[RFC5056]</a> for a discussion of the differences between these two facilities and <a href="#CHANNEL-BINDING">Section 6.1</a> for how GSS-API channel binding is handled in this mechanism.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#NAME-FORM" id="NAME-FORM">Mechanism Name Format</a>
</h1>
<p id="rfc.section.3.1.p.1">Before discussing how the initiator and acceptor names are validated in the AAA infrastructure, it is necessary to discuss what composes a name for an EAP GSS-API mechanism.  GSS-API permits several types of generic names to be imported using GSS_Import_name().  Once a mechanism is chosen, these names are converted into a mechanism name form.  This section first discusses the mechanism name form and then discusses what name forms are supported.</p>
<div id="#rfc.figure.1"></div>
<pre>
        ; Define name-string to handle escaping and prevent / and @
        empty =
        user-or-service = name-string
        host = empty/name-string
        realm = name-string
        service-specific = name-string
        service-specifics = service-specific 0*('/' service-specifics)
        name = user-or-service '/' host [ '/' service-specifics] [ '@'
                realm ]
</pre>
<p id="rfc.section.3.1.p.2">The string representation of the GSS-EAP mechanism name has the following ABNF <a href="#RFC5234">[RFC5234]</a> representation: </p>
<p id="rfc.section.3.1.p.3">The user-or-service component is the portion of a network access identifier (NAI) before the '@' symbol  for initiator names and the service name from the registry of GSS-API host-based services in the case of acceptor names <a href="#GSS-IANA">[GSS-IANA]</a>. The host portion is empty for initiators and typically contains the domain name of the system on which an acceptor service is running. Some services MAY require additional parameters to distinguish the entity being authenticated against. Such parameters are encoded in the service-specifics portion of the name. The EAP server MUST reject authentication of any acceptor name that has a non-empty service-specifics component unless the EAP server understands the service-specifics and authenticates them. The interpretation of the service-specifics is scoped by the user-or-service portion. The realm is the realm portion of a NAI for initiator names. The realm is the administrative realm of a service for an acceptor name.</p>
<p id="rfc.section.3.1.p.4">The string representation of this name form is designed to be generally compatible with the string representation of Kerberos names defined in <a href="#RFC1964">[RFC1964]</a>.</p>
<p id="rfc.section.3.1.p.5">The GSS_C_NT_USER_NAME form represents the name of an individual user.  From the standpoint of this mechanism it may take the form either of an undecorated user name or a network access identifier (NAI) <a href="#RFC4282">[RFC4282]</a>. The name is split into the part proceeding the realm which is the user-or-service portion of the mechanism name and the realm portion which is the realm portion of the mechanism name.</p>
<p id="rfc.section.3.1.p.6">The GSS_C_NT_HOSTBASED_SERVICE name form  represents a service running on a host; it is textually represented as "HOST@SERVICE".  This name form is required by most SASL profiles and is used by many existing applications that use the Kerberos GSS-API mechanism.  While support for this name form is critical, it presents an interesting challenge in terms of EAP channel binding.  Consider a case where the server communicates with a "server proxy," or a AAA server near the server.  That server proxy communicates with the EAP server.  The EAP server and server proxy are in different administrative realms.  The server proxy is in a position to verify that the request comes from the indicated host.  However the EAP server cannot make this determination directly.  So, the EAP server needs to determine whether to trust the server proxy to verify the host portion of the acceptor name.  This trust decision depends both on the host name and the realm of the server proxy.  In effect, the EAP server decides whether to trust that the realm of the server proxy is the right realm for the given hostname and then makes a trust decision about the server proxy itself.  The same problem appears in Kerberos: there, clients decide what Kerberos realm to trust for a given hostname.  The service portion of this name is imported into the user-or-service portion of the mechanism name; the host portion is imported into the host portion of the mechanism name. The realm portion is empty. However, authentication will typically fail unless some AAA component indicates the realm to the EAP server. If the application server knows its realm, then it should be indicated in the outgoing AAA request. Otherwise, a proxy SHOULD add the realm. An alternate form of this name type MAY be used on acceptors; in this case the name form is "service" with no host component. This is imported with the service as user-or-service and an empty host and realm portion. This form is useful when a service is unsure which name an initiator knows it by.</p>
<p id="rfc.section.3.1.p.7">Sometimes, the client may know what AAA realm a particular host should belong to.  In this case it would be desirable to use a name form that included a service, host and realm.  Syntactically, this appears the same as the domain-based name discussed in <a href="#RFC5178">[RFC5178]</a>, but the semantics are not similar enough  semantics to use the same name form.</p>
<p id="rfc.section.3.1.p.8">If the null name type or the GSS_EAP_NT_EAP_NAME (oid XXX) is imported, then the string representation above should be directly imported. Mechanisms MAY support the GSS_KRB5_NT_KRB5_PRINCIPAL_NAME name form with the OID  {iso(1) member-body(2) United States(840) mit(113554) infosys(1) gssapi(2) krb5(2) krb5_name(1)}.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Exported Mechanism Names</h1>
<p id="rfc.section.3.2.p.1">GSS-API provides the GSS_Export_name call.  This call can be used to export the binary representation of a name.  This name form can be stored on access control lists for binary comparison.</p>
<p id="rfc.section.3.2.p.2">The exported name token MUST use the format described in section 3.2 of RFC 2743. The mechanism specific portion of this name token is the string format of the mechanism name described in <a href="#NAME-FORM">Section 3.1</a>.</p>
<p id="rfc.section.3.2.p.3">RFC 2744 <a href="#RFC2744">[RFC2744]</a> places the requirement that the result of importing a name, canonicalizing it to a mechanism and then exporting it needs to be the same as importing that name, obtaining credentials for that principal, initiating a context with those credentials and exporting the name on the acceptor. In practice, GSS mechanisms often, but not always meet this requirement. For names expected to be used as initiator names, this requirement is met. However, permitting empty host and realm components when importing hostbased services may make it possible for an imported name to differ from the exported name actually used. Other mechanisms such as Kerberos have similar situations where imported and exported names may differ.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#RADIUS_AVP" id="RADIUS_AVP">Acceptor Name RADIUS AVP</a>
</h1>
<p id="rfc.section.3.3.p.1">Currently, GSS-EAP uses a RADIUS vendor-specific attribute for carrying the acceptor name. The VSA with enterprise ID 25622 is formatted as a VSA according to the recommendation in the RADIUS specification. The following sub-attributes are defined: </p>
<div id="#rfc.table.1"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Name</th>
<th class="left">Attribute</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="left">GSS-Acceptor-Service-Name</td>
<td class="left">128</td>
<td class="left">user-or-service portion of name</td>
</tr>
<tr>
<td class="left">GSS-Acceptor-Host-Name</td>
<td class="left">129</td>
<td class="left">host portion of name</td>
</tr>
<tr>
<td class="left">GSS-Acceptor-Service-specific</td>
<td class="left">130</td>
<td class="left">service-specifics portion of name</td>
</tr>
<tr>
<td class="left">GSS-Acceptor-Realm-Name</td>
<td class="left">131</td>
<td class="left">Realm portion of name</td>
</tr>
</tbody>
</table>
<p id="rfc.section.3.3.p.2">All these items are strings. See <a href="#NAME-FORM">Section 3.1</a> for details of the values in a name.</p>
<p id="rfc.section.3.3.p.3">If RADIUS is used as an AAA transport, the acceptor MUST send the acceptor name in the VSA.</p>
<p id="rfc.section.3.3.p.4">If mutual authentication is requested, the initiator MUST require that the EAP method in use support channel binding and MUST send the acceptor name as part of the channel binding data. The client MUST NOT indicate mutual authentication unless all name elements that the client supplied are in the channel binding response. For example, if the client supplied a hostname in channel binding data, the hostname MUST be in a successful channel binding response.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Proxy Verification of Acceptor Name</h1>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#NEGO" id="NEGO">Selection of EAP Method</a>
</h1>
<p id="rfc.section.4.p.1">The specification currently describes a single GSS-API mechanism.  The peer and authenticator exchange EAP messages.  The GSS-API mechanism specifies no constraints about what EAP method types are used; text in the specification says that negotiation of which EAP method to use happens at the EAP layer.</p>
<p id="rfc.section.4.p.2">EAP does not provide a facility for an EAP server to advertise what methods are available to a peer.  Instead, a server starts with its preferred method selection.  If the peer does not accept that method, the peer sends a NAK response containing the list of methods supported by the client.</p>
<p id="rfc.section.4.p.3">Providing multiple facilities to negotiate which security mechanism to use is undesirable.  Section 7.3 of <a href="#RFC4462">[RFC4462]</a>describes the problem referencing the SSH key exchange negotiation and the SPNEGO GSS-API mechanism.  If a client preferred an EAP method A, a non-EAP authentication mechanism B, and then an EAP method C, then the client would have to commit to using EAP before learning whether A is actually supported.  Such a client might end up using C when B is available.  </p>
<p id="rfc.section.4.p.4">The standard solution to this problem is to perform all the negotiation at one layer.  In this case, rather than defining a single GSS-API mechanism, a family of mechanisms should be defined.  Each mechanism corresponds to an EAP method.  The EAP method type should be part of the GSS-API OID.  Then, a GSS-API rather than EAP facility can be used for negotiation.</p>
<p id="rfc.section.4.p.5">Unfortunately, using a family of mechanisms has a number of problems.  First, GSS-API assumes that both the initiator and acceptor know the entire set of mechanisms that are available.  Some negotiation mechanisms are driven by the client; others are driven by the server.  With EAP GSS-API, the acceptor does not know what methods the EAP server implements.  The EAP server that is used depends on the identity of the client.  The best solution so far is to accept the disadvantages of multi-layer negotiation and commit to using EAP GSS-API before a specific EAP method.  This has two main disadvantages.  First, authentication may fail when other methods might allow authentication to succeed.  Second, a non-optimal security mechanism may be chosen.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#CONTEXT" id="CONTEXT">Context Tokens</a>
</h1>
<p id="rfc.section.5.p.1">All context establishment tokens emitted by the EAP mechanism SHALL have the framing described in section 3.1 of [RFC2743], as illustrated by the following pseudo-ASN.1 structures: </p>
<div id="#rfc.figure.2"></div>
<pre>         
GSS-API DEFINITIONS ::=
         BEGIN

         MechType ::= OBJECT IDENTIFIER
         -- representing EAP mechanism
         GSSAPI-Token ::=
         -- option indication (delegation, etc.) indicated within
         -- mechanism-specific token
         [APPLICATION 0] IMPLICIT SEQUENCE {
                 thisMech MechType,
                 innerToken ANY DEFINED BY thisMech
                    -- contents mechanism-specific
                    -- ASN.1 structure not required
                 }
         END
</pre>
<p id="rfc.section.5.p.2">The innerToken field contains  an EAP packet or special token.  The first EAP packet SHALL be a EAP response/identity packet from the initiator to acceptor.  The acceptor SHALL respond either with an EAP request or an EAP failure packet.</p>
<p id="rfc.section.5.p.3">The initiator and acceptor will continue exchanging response/request packets until authentication succeeds or fails.</p>
<p id="rfc.section.5.p.4">After the EAP authentication succeeds, channel binding tokens are exchanged; see <a href="#CHANNEL-BINDING">Section 6.1</a> for details.  Currently, the channel binding tokens are the only types of special tokens in use.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Mechanisms and Encryption Types</h1>
<p id="rfc.section.5.1.p.1">This mechanism family uses the security services of the Kerberos cryptographic framework <a href="#RFC3961">[RFC3961]</a>.  As such, a particular encryption type needs to be chosen.  A new GSS-API OID should be defined for EAP GSS-API with a given Kerberos crypto system.  This document defines the eap-aes128-cts-hmac-sha1-96 GSS-API mechanism. XXX define an OID for that and use the right language to get that into the appropriate SASL registry.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Context Options</h1>
<p id="rfc.section.5.2.p.1">GSS-API provides a number of optional per-context services requested by flags on the call to GSS_Init_sec_context and indicated as outputs from both GSS_Init_sec_context and GSS_Accept_sec_context.  This section describes how these services are handled. Which services the client selects in the call to GSS_Init_sec_context controls what EAP methods MAY be used by the client. Section 7.2 of RFC 3748 describes a set of security claims for EAP. As described below, the selected GSS options place requirements on security claims that MUST be met. </p>
<p id="rfc.section.5.2.p.2">This GSS mechanism MUST only be used with EAP methods that provide dictionary attack resistance.</p>
<p id="rfc.section.5.2.p.3">Whenever one of Integrity, confidentiality, sequencing or replay detection is requested, the EAP method MUST support key derivation. Whenever key derivation is supported, all of these services MUST be indicated in the output to GSS_Init_sec_context and GSS_Accept_sec_context regardless of which services were requested.</p>
<p id="rfc.section.5.2.p.4">The PROT_READY service is never available with this mechanism.  Implementations MUST NOT offer this flag or permit per-message security services to be used before context establishment.</p>
<p id="rfc.section.5.2.p.5">When mutual authentication is requested, the EAP method MUST support mutual authentication and channel binding. See <a href="#RADIUS_AVP">Section 3.3</a> for details on what is required for successful mutual authentication.</p>
<p id="rfc.section.5.2.p.6">Open issue: handling of lifetime parameters.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#ACCEPTOR-SERVICES" id="ACCEPTOR-SERVICES">Acceptor Services</a>
</h1>
<p id="rfc.section.6.p.1">The context establishment process may be passed through to a EAP server via a backend authentication protocol.  However after the EAP authentication succeeds, security services are provided directly by the acceptor.  </p>
<p id="rfc.section.6.p.2">This mechanism uses an RFC 3961 cryptographic key called the context root key (CRK).  The CRK is derived from the GMSK (GSS-API MSK). The GMSK is the result of the random-to-key <a href="#RFC3961">[RFC3961]</a> operation consuming the appropriate number of bits from the EAP master session  key.  For example for aes128-cts-hmac-sha1-96, the random-to-key operation consumes 16 octets of key material; thus the first 16 bytes of the master session key are input to random-to-key to form the GMSK.</p>
<div id="#rfc.figure.3"></div>
<pre>
Tn = pseudo-random(KMSK, n || "rfc4121-gss-eap")
CRK = truncate(L, T1 || T2 || .. || Tn)
L = output RFC 3961 key size
</pre>
<p id="rfc.section.6.p.3">The CRK is derived from the GMSK using the following procedur</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#CHANNEL-BINDING" id="CHANNEL-BINDING">GSS-API Channel       Binding</a>
</h1>
<p id="rfc.section.6.1.p.1">GSS-API channel binding <a href="#RFC5554">[RFC5554]</a> is a protected facility for exchanging a cryptographic name for an enclosing channel between the initiator and acceptor.  The initiator sends channel binding data and the acceptor confirms that channel binding data has been checked.</p>
<p id="rfc.section.6.1.p.2">The acceptor SHOULD accept any channel binding providing by the initiator if null channel bindings are passed into gss_accept_sec_context.  Protocols such as HTTP Negotiate depend on this behavior of some Kerberos implementations.  It is reasonable for the protocol to distinguish an acceptor ignoring channel bindings from an acceptor successfully validating them.  No facility is currently provided for an initiator implementation to expose this distinction to the initiator code.</p>
<p id="rfc.section.6.1.p.3">In this mechanism an extension option of type 0 with the critical bit set is sent from the initiator to the acceptor. This option contains a GSS_Wrap token of the channel binding data passed into GSS_Init_sec_context.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Per-message security</h1>
<p id="rfc.section.6.2.p.1">The per-message tokens of section 4 of RFC 4121 are used.  The CRK SHALL be treated as the initiator sub-session key, the acceptor sub-session key and the ticket session key.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Pseudo Random Function</h1>
<p id="rfc.section.6.3.p.1">The pseudo random function defined in <a href="#RFC4402">[RFC4402]</a> is used.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Open Mechanism Issues</h1>
<p></p>

<ul>
<li>The extension tokens</li>
<li>Server name indication</li>
<li>Empty target name</li>
<li>Context token format description not right</li>
</ul>

<p> </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Applicability Considerations</h1>
<p id="rfc.section.8.p.1">Section 1.3 of RFC 3748 provides the applicability statement for EAP.  Among other constraints, EAP is scoped for use in network access.  This specification anticipates using EAP beyond its current scope.  The assumption is that some other document will discuss the issues surrounding the use of EAP for application authentication and expand EAP's applicability.  That document  will likely enumerate considerations that a specific use of EAP for application authentication needs to handle.  Examples of such considerations might include the multi-layer negotiation issue, deciding when EAP or some other mechanism should be used, and so forth.  This section serves as a placeholder to discuss any such issues with regard to the use of EAP and GSS-API.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Security Considerations</h1>
<p id="rfc.section.9.p.1">RFC 3748 discusses security issues surrounding EAP.  RFC 5247 discusses the security and requirements surrounding key management that leverages the AAA infrastructure.  These documents are critical to the security analysis of this mechanism.  </p>
<p id="rfc.section.9.p.2">RFC 2743 discusses generic security considerations for the GSS-API.  RFC 4121 discusses security issues surrounding the specific per-message services used in this mechanism.</p>
<p id="rfc.section.9.p.3">As discussed in <a href="#NEGO">Section 4</a>, this mechanism may introduce multiple layers of security negotiation into application protocols.  Multiple layer negotiations are vulnerable to a bid-down attack when a mechanism negotiated at the outer layer is preferred to some but not all mechanisms negotiated at the inner layer; see section 7.3 of <a href="#RFC4462">[RFC4462]</a> for an example.  One possible approach to mitigate this attack is to construct security policy such that the preference for all mechanisms negotiated in the inner layer falls between preferences for two outer layer mechanisms or falls at one end of the overall ranked preferences including both the inner and outer layer.  Another approach is to only use this mechanism when it has specifically been selected for a given service.  The second approach is likely to be common in practice because one common deployment will involved an EAP supplicant interacting with a user to select a given identity.  Only when an identity is successfully chosen by the user will this mechanism be attempted.</p>
<p id="rfc.section.9.p.4">The security of this mechanism depends on the use and verification of EAP channel binding.  Today EAP channel binding is in very limited deployment.  If EAP channel binding is not used, then the system may be vulnerable to phishing attacks where a user is diverted from one service to another.  These attacks are possible with EAP today although not typically with common GSS-API mechanisms.</p>
<p id="rfc.section.9.p.5">Every proxy in the AAA chain from the authenticator to the EAP server needs to be trusted to help verify channel bindings and to protect the integrity of key material.  GSS-API applications may be built to assume a trust model where the acceptor is directly responsible for authentication.  However, GSS-API is definitely used with trusted-third-party mechanisms such as Kerberos.</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2743">[RFC2743]</b></td>
<td class="top">
<a href="mailto:jlinn@rsasecurity.com" title="RSA Laboratories">Linn, J.</a>, "<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>", RFC 2743, January 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3748">[RFC3748]</b></td>
<td class="top">
<a>Aboba, B.</a>, <a>Blunk, L.</a>, <a>Vollbrecht, J.</a>, <a>Carlson, J.</a> and <a>H. Levkowetz</a>, "<a href="http://tools.ietf.org/html/rfc3748">Extensible Authentication Protocol (EAP)</a>", RFC 3748, June 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3961">[RFC3961]</b></td>
<td class="top">
<a>Raeburn, K.</a>, "<a href="http://tools.ietf.org/html/rfc3961">Encryption and Checksum Specifications for Kerberos 5</a>", RFC 3961, February 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4401">[RFC4401]</b></td>
<td class="top">
<a>Williams, N.</a>, "<a href="http://tools.ietf.org/html/rfc4401">A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API)</a>", RFC 4401, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4402">[RFC4402]</b></td>
<td class="top">
<a>Williams, N.</a>, "<a href="http://tools.ietf.org/html/rfc4402">A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism</a>", RFC 4402, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4121">[RFC4121]</b></td>
<td class="top">
<a>Zhu, L.</a>, <a>Jaganathan, K.</a> and <a>S. Hartman</a>, "<a href="http://tools.ietf.org/html/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>", RFC 4121, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4282">[RFC4282]</b></td>
<td class="top">
<a>Aboba, B.</a>, <a>Beadles, M.</a>, <a>Arkko, J.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc4282">The Network Access Identifier</a>", RFC 4282, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5056">[RFC5056]</b></td>
<td class="top">
<a>Williams, N.</a>, "<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>", RFC 5056, November 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5554">[RFC5554]</b></td>
<td class="top">
<a>Williams, N.</a>, "<a href="http://tools.ietf.org/html/rfc5554">Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings</a>", RFC 5554, May 2009.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-emu-chbind">[I-D.ietf-emu-chbind]</b></td>
<td class="top">
<a>Hartman, S</a>, <a>Clancy, T</a> and <a>K Hoeper</a>, "<a href="http://tools.ietf.org/html/draft-ietf-emu-chbind-11">Channel Binding Support for EAP Methods</a>", Internet-Draft draft-ietf-emu-chbind-11, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2744">[RFC2744]</b></td>
<td class="top">
<a href="mailto:John_Wray@Iris.com" title="Iris Associates">Wray, J.</a>, "<a href="http://tools.ietf.org/html/rfc2744">Generic Security Service API Version 2 : C-bindings</a>", RFC 2744, January 2000.</td>
</tr>
<tr>
<td class="reference"><b id="GSS-IANA">[GSS-IANA]</b></td>
<td class="top">
<a>IANA</a>, "<a>GSS-API Service Name Registry</a>", .</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.lear-abfab-arch">[I-D.lear-abfab-arch]</b></td>
<td class="top">
<a>Howlett, J</a>, <a>Hartman, S</a>, <a>Tschofenig, H</a> and <a>E Lear</a>, "<a href="http://tools.ietf.org/html/draft-lear-abfab-arch-02">Application Bridging for Federated Access Beyond Web (ABFAB) Architecture</a>", Internet-Draft draft-lear-abfab-arch-02, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1964">[RFC1964]</b></td>
<td class="top">
<a href="mailto:John.Linn@ov.com" title="OpenVision Technologies">Linn, J.</a>, "<a href="http://tools.ietf.org/html/rfc1964">The Kerberos Version 5 GSS-API Mechanism</a>", RFC 1964, June 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4072">[RFC4072]</b></td>
<td class="top">
<a>Eronen, P.</a>, <a>Hiller, T.</a> and <a>G. Zorn</a>, "<a href="http://tools.ietf.org/html/rfc4072">Diameter Extensible Authentication Protocol (EAP) Application</a>", RFC 4072, August 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3579">[RFC3579]</b></td>
<td class="top">
<a>Aboba, B.</a> and <a>P. Calhoun</a>, "<a href="http://tools.ietf.org/html/rfc3579">RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)</a>", RFC 3579, September 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4178">[RFC4178]</b></td>
<td class="top">
<a>Zhu, L.</a>, <a>Leach, P.</a>, <a>Jaganathan, K.</a> and <a>W. Ingersoll</a>, "<a href="http://tools.ietf.org/html/rfc4178">The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism</a>", RFC 4178, October 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4422">[RFC4422]</b></td>
<td class="top">
<a>Melnikov, A.</a> and <a>K. Zeilenga</a>, "<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>", RFC 4422, June 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4462">[RFC4462]</b></td>
<td class="top">
<a>Hutzelman, J.</a>, <a>Salowey, J.</a>, <a>Galbraith, J.</a> and <a>V. Welch</a>, "<a href="http://tools.ietf.org/html/rfc4462">Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol</a>", RFC 4462, May 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5178">[RFC5178]</b></td>
<td class="top">
<a>Williams, N.</a> and <a>A. Melnikov</a>, "<a href="http://tools.ietf.org/html/rfc5178">Generic Security Service Application Program Interface (GSS-API) Internationalization and Domain-Based Service Names and Name Type</a>", RFC 5178, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5247">[RFC5247]</b></td>
<td class="top">
<a>Aboba, B.</a>, <a>Simon, D.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5247">Extensible Authentication Protocol (EAP) Key Management Framework</a>", RFC 5247, August 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sam Hartman</span> editor
	  <span class="n hidden">
		<span class="family-name">Hartman</span>
	  </span>
	</span>
	<span class="org vcardline">Painless Security</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:hartmans-ietf@mit.edu">hartmans-ietf@mit.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Josh Howlett</span> 
	  <span class="n hidden">
		<span class="family-name">Howlett</span>
	  </span>
	</span>
	<span class="org vcardline">JANET(UK)</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:josh.howlett@ja.net">josh.howlett@ja.net</a></span>

  </address>
</div>

</body>
</html>