concise-software-identity = {
    global-attr,
    * entity-entry,
    * evidence-entry,
    * link-entry,
    * software-meta-entry,
    * payload-entry,
    * any-element-entry,
NMTOKEN = text            ; .regexp to add some validation?
NMTOKENS = [ * NMTOKEN ]

any-attr = text
any-element = any

date-time = time
any-uri = uri

global-attr = (
    * (text => any-attr),
    ? lang,
meta-type = (
    global-attr,
    * (text => any-attr),
meta-element = [
    global-attr,
    * (text => any-attr),
resource-collection = (
    global-attr,
    * (directory-entry // file-entry // process-entry // resource-entry)
file = {
    filesystem-item,
    ? size,
    ? version,
    * (text => any-attr),
filesystem-item = (
    meta-type,
    ? key,
    ? location,
    name,
    ? root,
directory = {
    filesystem-item,
    path-elements,
process = {
    global-attr,
    name,
    ? pid,
resource = {
    global-attr,
    type,
entity = {
    global-attr,
    meta-elements,
    name,
    ? reg-id,
    role,
    ? thumbprint,
evidence = {
    global-attr,
    resource-collection,
    ? date,
    ? device-id,
link = {
    global-attr,
    ? artifact,
    href,
    ? media,
    ? ownership,
    rel,
    ? type,
    ? use,
software-meta = {
    global-attr,
    ? activation-status,
    ? channel-type,
    ? colloquial-version,
    ? description,
    ? edition,
    ? entitlement-data-required,
    ? entitlement-key,
    ? generator,
    ? persistent-id,
    ? product,
    ? product-family,
    ? revision,
    ? summary,
    ? unspsc-code,
    ? unspsc-version,
payload = {
    global-attr,
    resource-collection,
tag-id = (0: text)
name = (1: text)
entity-entry = (2: entity)
evidence-entry = (3: evidence)
link-entry = (4: link)
software-meta-entry = (5: software-meta)
payload-entry = (6: payload)
any-element-entry = (7: any-element)
corpus = (8: bool)
patch = (9: bool)
media = (10: text)
supplemental = (11: bool)
tag-version = (12: integer)
version = (13: text)
version-scheme = (14: NMTOKEN)
lang = (15: text)
directory-entry = (16: directory)
file-entry = (17: file)
process-entry = (18: process)
resource-entry = (19: resource)
size = (20: integer)
key = (21: bool)
location = (22: text)
root = (23: text)
path-elements = (24: ([ * (directory / file) ]))
pid = (25: integer)
type = (26: text)
meta-elements = (27: ([ * meta-element ]))
reg-id = (28: any-uri)
role = (29: NMTOKENS)
thumbprint = (30: text)
date = (31: date-time)
device-id = (32: text)
artifact = (33: text)
href = (34: any-uri)
ownership = (35: ("shared" / "private" / "abandon"))
rel = (36: NMTOKEN)
use = (37: ("optional" / "required" / "recommended"))
activation-status = (38: text)
channel-type = (39: text)
colloquial-version = (40: text)
description = (41: text)
edition = (42: text)
entitlement-data-required = (43: bool)
entitlement-key = (44: text)
generator = (45: text)
persistent-id = (46: text)
product = (47: text)
product-family = (48: text)
revision = (49: text)
summary = (50: text)
unspsc-code = (51: text)
unspsc-version = (52: text)


coswid-hash = [
     hash-alg-id: int / tstr,
     hash-value: bstr,
file-hash = bstr .cbor coswid-hash


signed-software-identity = #6.997(COSE-Sign1-coswid) ; see TBS7 in current COSE I-D

label = int / tstr  ; see COSE I-D 1.4.
values = any        ; see COSE I-D 1.4.

unprotected-signed-coswid-header = {
    1 => int / tstr,            ; algorithm identifier
    3 => "application/coswid",  ; request for CoAP IANA registry to become an int
    * label => values,
protected-signed-coswid-header = {
    4 => bstr,                  ; key identifier
    * label => values,
COSE-Sign1-coswid = [
    protected: bstr .cbor protected-signed-coswid-header,
    unprotected: unprotected-signed-coswid-header,
    payload: bstr .cbor concise-software-identity,
    signature: bstr,
