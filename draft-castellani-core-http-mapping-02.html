<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Best practices for HTTP-CoAP mapping implementation </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Cross-protocol resource identification using URIs">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 URI mapping">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Homogeneous mapping">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Embedded mapping">
<link href="#rfc.section.3.1.2.1" rel="Chapter" title="3.1.2.1 HTML5 scheme handler registration">
<link href="#rfc.section.4" rel="Chapter" title="4 HTTP-CoAP implementation">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Placement and deployment">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Basic mapping">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Caching and congestion control">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Cache Refresh via Observe">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Use of CoAP blockwise transfer">
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 Use case: HTTP/IPv4-CoAP/IPv6 proxy">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Multiple message exchanges mapping">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Relevant features of existing standards">
<link href="#rfc.section.4.3.1.1" rel="Chapter" title="4.3.1.1 Multipart messages">
<link href="#rfc.section.4.3.1.2" rel="Chapter" title="4.3.1.2 Immediate message delivery">
<link href="#rfc.section.4.3.1.3" rel="Chapter" title="4.3.1.3 Detailing source information">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Multicast mapping">
<link href="#rfc.section.4.3.2.1" rel="Chapter" title="4.3.2.1 URI identification and mapping">
<link href="#rfc.section.4.3.2.2" rel="Chapter" title="4.3.2.2 Request handling">
<link href="#rfc.section.4.3.2.3" rel="Chapter" title="4.3.2.3 Example">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Multicast responses caching">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 Subscription mapping">
<link href="#rfc.section.5" rel="Chapter" title="5 CoAP-HTTP implementation">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Placement and Deployment">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Basic mapping">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Payloads and Media Types">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Max-Age and ETag Options">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Use of CoAP blockwise transfer">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 HTTP Status Codes 1xx and 3xx">
<link href="#rfc.section.5.2.5" rel="Chapter" title="5.2.5 Examples">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Traffic overflow">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Cross-protocol security policy mapping">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Handling secured exchanges">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Spoofing and Cache Poisoning">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Subscription">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Internal Mapping Functions (from an implementer's perspective)">
<link href="#rfc.appendix.Appendix%20A.1" rel="Chapter" title="Appendix A.1 URL Map Algorithm">
<link href="#rfc.appendix.Appendix%20A.2" rel="Chapter" title="Appendix A.2 Security Policy Map Algorithm">
<link href="#rfc.appendix.Appendix%20A.3" rel="Chapter" title="Appendix A.3 Content-Type Map Algorithm">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This draft aims at being a base reference documentation for HTTP-CoAP proxy implementors.  It details deployment options, discusses possible approaches for URI mapping, and provides useful considerations related to protocol translation." />
  <meta name="description" content="This draft aims at being a base reference documentation for HTTP-CoAP proxy implementors.  It details deployment options, discusses possible approaches for URI mapping, and provides useful considerations related to protocol translation." />
  <meta name="keywords" content="CoAP, HTTP-CoAP mapping" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CoRE Working Group</td>
<td class="right">A.P. Castellani</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">University of Padova</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">S. Loreto</td>
</tr>
<tr>
<td class="left">Expires: May 03, 2012</td>
<td class="right">Ericsson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">A. Rahman</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">InterDigital Communications, LLC</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Fossati</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">KoanLogic</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">E. Dijk</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Philips Research</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 31, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Best practices for HTTP-CoAP mapping implementation <br />
  <span class="filename">draft-castellani-core-http-mapping-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This draft aims at being a base reference documentation for HTTP-CoAP proxy implementors.  It details deployment options, discusses possible approaches for URI mapping, and provides useful considerations related to protocol translation.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 03, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Cross-protocol resource identification using URIs</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">URI mapping</a>
</li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">Homogeneous mapping</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Embedded mapping</a>
</li>
<li>3.1.2.1.   <a href="#rfc.section.3.1.2.1">HTML5 scheme handler registration</a>
</li>
<li>4.   <a href="#rfc.section.4">HTTP-CoAP implementation</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Placement and deployment</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Basic mapping</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Caching and congestion control</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Cache Refresh via Observe</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Use of CoAP blockwise transfer</a>
</li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">Use case: HTTP/IPv4-CoAP/IPv6 proxy</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Multiple message exchanges mapping</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Relevant features of existing standards</a>
</li>
<li>4.3.1.1.   <a href="#rfc.section.4.3.1.1">Multipart messages</a>
</li>
<li>4.3.1.2.   <a href="#rfc.section.4.3.1.2">Immediate message delivery</a>
</li>
<li>4.3.1.3.   <a href="#rfc.section.4.3.1.3">Detailing source information</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Multicast mapping</a>
</li>
<li>4.3.2.1.   <a href="#rfc.section.4.3.2.1">URI identification and mapping</a>
</li>
<li>4.3.2.2.   <a href="#rfc.section.4.3.2.2">Request handling</a>
</li>
<li>4.3.2.3.   <a href="#rfc.section.4.3.2.3">Example</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Multicast responses caching</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">Subscription mapping</a>
</li>
<li>5.   <a href="#rfc.section.5">CoAP-HTTP implementation</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Placement and Deployment</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Basic mapping</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">Payloads and Media Types</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Max-Age and ETag Options</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Use of CoAP blockwise transfer</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">HTTP Status Codes 1xx and 3xx</a>
</li>
<li>5.2.5.   <a href="#rfc.section.5.2.5">Examples</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Traffic overflow</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Cross-protocol security policy mapping</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Handling secured exchanges</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Spoofing and Cache Poisoning</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Subscription</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Internal Mapping Functions (from an implementer's perspective)</a>
</li>
<li>Appendix A.1.   <a href="#rfc.appendix.Appendix%20A.1">URL Map Algorithm</a>
</li>
<li>Appendix A.2.   <a href="#rfc.appendix.Appendix%20A.2">Security Policy Map Algorithm</a>
</li>
<li>Appendix A.3.   <a href="#rfc.appendix.Appendix%20A.3">Content-Type Map Algorithm</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">RESTful protocols, such as HTTP <a href="#RFC2616">[RFC2616]</a> and CoAP <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>, can interoperate through an intermediary proxy which performs cross-protocol mapping.</p>
<p id="rfc.section.1.p.2">A reference about the mapping process is provided in Section 8 of <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.  However, depending on the involved application, deployment scenario, or network topology, such mapping could be realized using a wide range of intermediaries.</p>
<p id="rfc.section.1.p.3">Moreover, the process of implementing such a proxy could be complex, and details regarding its internal procedures and design choices deserve further discussion, which is provided in this document.</p>
<p id="rfc.section.1.p.4">This draft is organized as follows: </p>

<ul>
<li>
<a href="#terminology">Section 2</a> describes terminology to identify different mapping approaches and the related proxy deployments;</li>
<li>
<a href="#URI">Section 3</a> discusses impact of the mapping on URI and describes notable options;</li>
<li>
<a href="#hc">Section 4</a> and <a href="#ch">Section 5</a> respectively analyze the mapping from HTTP to CoAP and viceversa;</li>
<li>
<a href="#sec">Section 6</a> discusses possible security impact related to the mapping.</li>
</ul>
<p id="rfc.section.1.p.5">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.p.1">A device providing cross-protocol HTTP-CoAP mapping is called an HTTP-CoAP cross-protocol proxy (HC proxy).</p>
<p id="rfc.section.2.p.2">Regular HTTP proxies are usually same-protocol proxies, because they can map from HTTP to HTTP.  CoAP same-protocol proxies are intermediaries for CoAP to CoAP exchanges.  However the discussion about these entities is out-of-scope of this document.</p>
<p id="rfc.section.2.p.3">At least two different kinds of HC proxies exist: </p>

<ul>
<li>One-way cross-protocol proxy (1-way proxy): This proxy translates from a client of a protocol to a server of another protocol but not vice-versa.</li>
<li>Two-way (or bidirectional) cross-protocol proxy (2-way proxy): This proxy translates from a client of both protocols to a server supporting one protocol.</li>
</ul>

<p> </p>
<p id="rfc.section.2.p.4">1-way and 2-way HC proxies are realized using the following general types of proxies: </p>

<dl>
<dt>Forward proxy (F):</dt>
<dd style="margin-left: 8">Is a proxy known by the client (either CoAP or HTTP) used to access a specific cross-protocol server (respectively HTTP or CoAP).  Main feature: server(s) do not require to be known in advance by the proxy (ZSC: Zero Server Configuration).</dd>
<dt>Reverse proxy (R):</dt>
<dd style="margin-left: 8">Is a proxy known by the client to be the server, however for a subset of resources it works as a proxy, by knowing the real server(s) serving each resource.  When a cross-protocol resource is accessed by a client, the request will be silently forwarded by the reverse proxy to the real server (running a different protocol).  If a response is received by the reverse proxy, it will be mapped, if possible, to the original protocol and sent back to the client.  Main feature: client(s) do not require to know in advance the proxy (ZCC: Zero Client Configuration).</dd>
<dt>Interception proxy (I):</dt>
<dd style="margin-left: 8">This proxy <a href="#RFC3040">[RFC3040]</a> can intercept any origin protocol request (HTTP or CoAP) and map it to the destination protocol, without any kind of knowledge about the client or server involved in the exchange.  Main feature: client(s) and server(s) do not require to know or be known in advance by the proxy (ZCC and ZSC).</dd>
</dl>

<p> </p>
<p id="rfc.section.2.p.5">The proxy can be placed in the network at three different logical locations: </p>

<dl>
<dt>Server-side proxy (SS):</dt>
<dd style="margin-left: 8">A proxy placed on the same network domain of the server;</dd>
<dt>Client-side proxy (CS):</dt>
<dd style="margin-left: 8">A proxy placed on the same network domain of the client;</dd>
<dt>External proxy (E):</dt>
<dd style="margin-left: 8">A proxy placed in a network domain external to both endpoints, it is in the network domain neither of the client nor of the server.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#URI" id="URI">Cross-protocol resource identification using URIs</a>
</h1>
<p id="rfc.section.3.p.1">A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource.  It enables uniform identification of resources via a separately defined extensible set of naming schemes <a href="#RFC3986">[RFC3986]</a>.</p>
<p id="rfc.section.3.p.2">URIs are formed of at least three components: scheme, authority and path.  The scheme is the first part of the URI, and it often corresponds to the protocol used to access the resource.  However, as noted in Section 1.2.2 of <a href="#RFC3986">[RFC3986]</a> the scheme does not imply that a particular protocol is used to access the resource.</p>
<p id="rfc.section.3.p.3">Clients using URIs to identify target resources (e.g. HTTP web browsers) may support only a limited set of schemes (i.e. 'http', 'https').  If such clients need to interoperate with resources identified by an unsupported scheme (e.g. 'coap'), the existence of a URI using a scheme supported by the client is required for interoperability.</p>
<p id="rfc.section.3.p.4">Both CoAP and HTTP implement the REST paradigm, so, in principle, the same resource can be made available in each protocol if protocol translation is applied.</p>
<p id="rfc.section.3.p.5">In general two different procedures can be used to access cross-protocol resources: </p>

<dl>
<dt>Protocol-aware access:</dt>
<dd style="margin-left: 8">The client accesses the cross-protocol resource using the original URI using a cross-protocol proxy (e.g. uses 'coap' scheme URI inside the HTTP request); protocol translation is provided by a cross-protocol proxy.  Both CoAP and HTTP support this access method.  HTTP defines that proxy or servers MUST accept even an absolute-URI as request-target, see Section 4.1.2 of <a href="#I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</a>.  CoAP provides Proxy-URI option having absolute-URI as value, see Section 5.10.3 of <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.</dd>
<dt>Protocol-agnostic access:</dt>
<dd style="margin-left: 8">The client accesses the cross-protocol resource using an URI with a scheme supported by the client (e.g. uses 'http' scheme to access a CoAP resource), URI and protocol translation is provided by a cross-protocol proxy.  In order to use this method a URI identifying an equivalent resource MUST exist, and SHOULD be provided by the cross-protocol proxy.</dd>
</dl>

<p> </p>
<p id="rfc.section.3.p.6">URI mapping is NOT required when using protocol-aware access, the following section is focused on URI mapping techniques for protocol-agnostic access.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#URI-mapping" id="URI-mapping">URI mapping</a>
</h1>
<p id="rfc.section.3.1.p.1">When accessing cross-protocol resources in a protocol-agnostic way, clients MUST use an URI with a scheme supported by the client.</p>
<p id="rfc.section.3.1.p.2">Since determination of equivalence of URIs (e.g. whether or not they identify the same resource) is based on lexicographic comparison, URI domains using different schemes are fully distinct: resources identified by the same authority and path tuple change when switching the scheme.</p>
<p id="rfc.section.3.1.p.3">Example: Assume that the following resource exists - "coap://node.coap.something.net/foo".  The resource identified by "http://node.coap.something.net/foo" may not exist or be non-equivalent to the one identified by the 'coap' scheme.</p>
<p id="rfc.section.3.1.p.4">If a cross-protocol URI exists providing an equivalent representation of the native protocol resource, it can be provided by a different URI (in terms of authority and path).  The mapping of an URI between HTTP and CoAP is said HC URI mapping.</p>
<p id="rfc.section.3.1.p.5">Example: The HC URI mapping to HTTP of the CoAP resource identified by "coap://node.coap.something.net/foo" is "http://node.something.net/foobar".</p>
<p id="rfc.section.3.1.p.6">The process of providing the HC URI mapping could be complex, since a proper mechanism to statically or dynamically (discover) map the resource HC URI mapping is required.</p>
<p id="rfc.section.3.1.p.7">Two static HC URI mappings are discussed in the following subsections.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#URI-homogeneous-mapping" id="URI-homogeneous-mapping">Homogeneous mapping</a>
</h1>
<p id="rfc.section.3.1.1.p.1">The URI mapping between CoAP and HTTP is called homogeneous, if the same resource is identified by URIs with different schemes.</p>
<p id="rfc.section.3.1.1.p.2">Example: The CoAP resource "//node.coap.something.net/foo" identified either by the URI "coap://node.coap.something.net/foo", and or by the URI "http://node.coap.something.net/foo" is the same.  When the resource is accessed using HTTP, the mapping from HTTP to CoAP is performed by an HC proxy</p>
<p id="rfc.section.3.1.1.p.3">When homogeneous HC URI mapping is available, HC-I proxies are easily implementable.</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#URI-embedded-mapping" id="URI-embedded-mapping">Embedded mapping</a>
</h1>
<p id="rfc.section.3.1.2.p.1">The mapping is said to be embedded, if the HC URI mapping of the resource embeds inside it the authority and path part of the native URI.</p>
<p id="rfc.section.3.1.2.p.2">Example: The CoAP resource "coap://node.coap.something.net/foo" can be accessed at "http://hc-proxy.something.net/coap/node.coap.something.net/foo".</p>
<p id="rfc.section.3.1.2.p.3">This mapping technique can be used to reduce the mapping complexity in an HC reverse proxy.</p>
<h1 id="rfc.section.3.1.2.1">
<a href="#rfc.section.3.1.2.1">3.1.2.1.</a> <a href="#HTML5-mapping" id="HTML5-mapping">HTML5 scheme handler registration</a>
</h1>
<p id="rfc.section.3.1.2.1.p.1">The draft HTML5 standard offers a mechanism that allows an HTTP user agent to register a custom scheme handler through an HTML5 web page.  This feature permits to an HC proxy to be registered as "handler" for URIs with the 'coap' or 'coaps' schemes using an HTML5 web page which embeds the custom scheme handler registration call registerProtocolHandler() described in Section 6.5.1.2 of <a href="#W3C.HTML5">[W3C.HTML5]</a>.</p>
<p id="rfc.section.3.1.2.1.p.2">Example: the HTML5 homepage of a HC proxy at h2c.example.org could include the method call:</p>
<div id="#rfc.figure.1"></div>
<pre>
registerProtocolHandler('coap', 'proxy?url=%s', 'example HC proxy')
</pre>
<p id="rfc.section.3.1.2.1.p.3">This registration call will prompt the  HTTP user agent to ask for the user's permission to register the HC proxy as a handler for all 'coap' URIs.  If the user accepts, whenever a 'coap' link is requested, the request will be fulfilled through the HC proxy: URI "coap://foo.org/a" will be transformed into URI "http://h2c.example.org/proxy?url=coap://foo.org/a".  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#hc" id="hc">HTTP-CoAP implementation</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#hc-placement" id="hc-placement">Placement and deployment</a>
</h1>
<p id="rfc.section.4.1.p.1">In typical scenarios the HC proxy is expected to be server-side (SS), in particular deployed at the edge of the constrained network.</p>
<p id="rfc.section.4.1.p.2">The arguments supporting SS placement are the following: </p>

<dl>
<dt>TCP/UDP:</dt>
<dd style="margin-left: 8">Translation between HTTP and CoAP requires also a TCP to UDP mapping; UDP performance over the unconstrained Internet may not be adequate.  In order to minimize the number of required retransmissions and overall reliability, TCP/UDP conversion SHOULD be performed at a SS placed proxy.</dd>
<dt>Caching:</dt>
<dd style="margin-left: 8">Efficient caching requires that all the CoAP traffic is intercepted by the same proxy, thus an SS placement, collecting all the traffic, is strategical for this need.</dd>
<dt>Multicast:</dt>
<dd style="margin-left: 8">To support using local-multicast functionalities available in the constrained network, the HC proxy MAY require a network interface directly attached to the constrained network.</dd>
</dl>
<div id="#rfc.figure.2"></div>
<div id="#fig-http-coap-deployment"></div>
<pre>
    
                            +------+                                                                              
                            |      |                                                                                                                 
                            | DNS  |                                                                              
                            |      |                                                                              
                            +------+                             
                                                --------------------
                                               /                    \
                                              /  /-----\     /-----\ \
                                             /     CoAP       CoAP    \
                                            /    server      server    \
                                           ||    \-----/     \-----/   ||
                                     +----------+                      ||
                                     | HTTP/CoAP|        /-----\       ||
                                     |  Proxy   |          CoAP        ||
                                     |(HC Proxy)|         server       ||
    +------+                         +----------+        \-----/       ||
    |HTTP  |                               ||   /-----\                ||
    |Client|                               ||    CoAP                  ||
    +------+                                \    server                /
                                             \  \-----/               /
                                              \         /-----\      /
                                               \         CoAP       /
                                                \        server    /
                                                 \      \-----/   /
                                                  ----------------
    
        </pre>
<p id="rfc.section.4.1.p.3">Other important aspects involved in the selection of which type of proxy deployment, whose choice impacts its placement too, are the following: </p>

<dl>
<dt>Client/Proxy/Network configuration overhead:</dt>
<dd style="margin-left: 8">Forward proxies require either static configuration or discovery support in the client.  Reverse proxies require either static configuration, server discovery or embedded URI mapping in the proxy.  Interception proxies typically require single router configuration for a whole network.</dd>
<dt>Scalability/Availability:</dt>
<dd style="margin-left: 8">Both aspects are typically addressed using redundancy.  CS deployments, due to the limited catchment area and administrative-wide domain of operation, have looser requirements on this.  SS deployments, in dense/popular/critical environments, have stricter requirements and MAY need to be replicated.  Stateful proxies (e.g. reverse) may be complex to replicate.</dd>
</dl>
<p id="rfc.section.4.1.p.4">Discussion about security impacts of different deployments is covered in <a href="#sec">Section 6</a>.</p>
<p><a href="#tab-hc-deployments">Table 1</a> shows some interesting HC proxy deployment scenarios, and notes the advantages related to each scenario.</p>
<div id="#rfc.table.1"></div>
<div id="#tab-hc-deployments"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Interesting HC proxy deployments</caption>
<thead><tr>
<th class="left">Feature </th>
<th class="right">F CS </th>
<th class="right">R SS </th>
<th class="right">I SS </th>
</tr></thead>
<tbody>
<tr>
<td class="left">TCP/UDP </td>
<td class="right">- </td>
<td class="right">+ </td>
<td class="right">+ </td>
</tr>
<tr>
<td class="left">Multicast </td>
<td class="right">- </td>
<td class="right">+ </td>
<td class="right">+ </td>
</tr>
<tr>
<td class="left">Caching </td>
<td class="right">- </td>
<td class="right">+ </td>
<td class="right">+ </td>
</tr>
<tr>
<td class="left">Scalability/Availability </td>
<td class="right">+ </td>
<td class="right">+/- </td>
<td class="right">+ </td>
</tr>
<tr>
<td class="left">Configuration </td>
<td class="right">- </td>
<td class="right">- </td>
<td class="right">+ </td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.1.p.6">Guidelines proposed in the previous paragraphs have been used to fill out the above table.  In the first three rows, it can be seen that SS deployment is preferred versus CS.  Scalability/Availability issues can be generally handled, but some complexity may be involved in reverse proxies scenarios. Configuration overhead could be simplified when interception proxies deployments are feasible.</p>
<p id="rfc.section.4.1.p.7">When support for legacy HTTP clients is required, it may be preferable using configuration/discovery free deployments.  Discovery procedures for client or proxy auto-configuration are still under active-discussion: see <a href="#I-D.vanderstok-core-bc">[I-D.vanderstok-core-bc]</a>, <a href="#I-D.bormann-core-simple-server-discovery">[I-D.bormann-core-simple-server-discovery]</a> or <a href="#I-D.shelby-core-resource-directory">[I-D.shelby-core-resource-directory]</a>.  Static configuration of multiple forward proxies is typically not feasible in existing HTTP clients.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Basic mapping</h1>
<p id="rfc.section.4.2.p.1">The mapping of HTTP requests to CoAP and of the response back to HTTP is defined in Section 8.2 of <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.</p>
<p id="rfc.section.4.2.p.2">The mapping of a CoAP response code to HTTP is not straightforward, this mapping MUST be operated accordingly to Table 4 of <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.</p>
<p id="rfc.section.4.2.p.3">No temporal upper bound is defined for a CoAP server to provide the response, thus for long delays the HTTP client or any other proxy in between MAY timeout.  Further discussion is available in Section 7.1.4 of <a href="#I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</a>.</p>
<p id="rfc.section.4.2.p.4">The HC proxy MUST define an internal timeout for each pending CoAP request, because the CoAP server may silently die before completing the request.</p>
<p id="rfc.section.4.2.p.5">Even if the DNS protocol may not be used inside the constrained network, maintaining valid DNS entries describing the hosts available on such network helps offering the CoAP resources to HTTP clients.</p>
<p id="rfc.section.4.2.p.6">An example of the usefulness of such entries is described in <a href="#hc-v4v6">Section 4.2.4</a>.</p>
<p id="rfc.section.4.2.p.7">HTTP connection pipelining (section 7.1.2.2 of <a href="#I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</a>) is transparent to the CoAP network: the HC proxy will sequentially serve the pipelined requests by issuing different CoAP requests.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#hc-caching" id="hc-caching">Caching and congestion control</a>
</h1>
<p id="rfc.section.4.2.1.p.1">The HC proxy SHOULD limit the number of requests to CoAP servers by responding, where applicable, with a cached representation of the resource.</p>
<p id="rfc.section.4.2.1.p.2">Duplicate idempotent pending requests to the same resource SHOULD in general be avoided, by duplexing the response to the relevant hosts without duplicating the request.  </p>
<p id="rfc.section.4.2.1.p.3">If the HTTP client times out and drops the HTTP session to the proxy (closing the TCP connection), the HC proxy SHOULD wait for the response and cache it if possible.  Further idempotent requests to the same resource can use the result present in cache, or, if a response has still to come, requests will wait on the open CoAP session.</p>
<p id="rfc.section.4.2.1.p.4">Resources experiencing a high access rate coupled with high volatility MAY be observed <a href="#I-D.ietf-core-observe">[I-D.ietf-core-observe]</a> by the HC proxy to keep their cached representation fresh while minimizing the number of needed messages.  See <a href="#refresh_via_observe">Section 4.2.2</a> for a heuristics that enables the HC proxy to decide whether observing is a more convenient strategy than ordinary refreshing via Max-Age/ETag-based mechanisms. </p>
<p id="rfc.section.4.2.1.p.5">Specific deployments may show highly congested servers/resources -- e.g. multicast resources (see <a href="#hc-multicast">Section 4.3.2</a>), popular servers, etc.  A careful analysis is required to pick the correct caching policy involving these resources, also taking into consideration the security implications that may impact these targets specifically, and the constrained network in general.</p>
<p id="rfc.section.4.2.1.p.6">To this end when traffic reduction obtained by the caching mechanism is not adequate, the HC proxy could apply stricter policing by limiting the amount of aggregate traffic to the constrained network.  In particular, the HC proxy SHOULD pose a rigid upper limit to the number of concurrent CoAP request pending on the same constrained network; further request MAY either be queued or dropped.  In order to efficiently apply this congestion control, the HC proxy SHOULD be SS placed.</p>
<p id="rfc.section.4.2.1.p.7">Further discussion on congestion control can be found in <a href="#I-D.eggert-core-congestion-control">[I-D.eggert-core-congestion-control]</a>.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#refresh_via_observe" id="refresh_via_observe">Cache Refresh via Observe</a>
</h1>
<p id="rfc.section.4.2.2.p.1">There are cases where using CoAP observe protocol <a href="#I-D.ietf-core-observe">[I-D.ietf-core-observe]</a> to handle proxy cache refresh may be preferable to the validation mechanism based on ETag's defined in section 5.6.2 of <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.  For example: sleeping nodes, possibly showing high variance in requests' distribution, would greatly benefit from a server driven cache update mechanism.  Other expected candidates would be the crowded or very low throughput networks, where minimization of the total number of exchanged messages is a major goal.</p>
<p id="rfc.section.4.2.2.p.2">This subsection aims at providing a practical evaluation method to decide whether the refresh of a cached resource R is more efficiently handled via ETag validation or by establishing an observation on R.</p>
<p id="rfc.section.4.2.2.p.3">Let T_R be the mean time between two client requests to resource R, F_R be the freshness lifetime of R, and M_R be the total number of messages exchanged by the cache towards resource R in order to validate its freshness.  Assumed a negligible initial cost for establishing the observation relationship (one only message), an observation on R lessens M_R (i.e. it's a better cache update choice then using ETag validation) iff T_R &lt; 2*F_R, or equivalently, iff the mean arrival time of requests for resource R is greater than half the refresh rate of R.</p>
<p id="rfc.section.4.2.2.p.4">The above relation can easily be grasped by noticing that, in case the mean interarrival time between requests is less than the refresh rate of R, an observation does not generate any unnecessary validation message, and is therefore optimal.  Further, since the number of messages used by ETag's validation is twice the observation cost (request/response vs server push), the bound on T_R can be doubled.</p>
<p id="rfc.section.4.2.2.p.5">As a rule of thumb, volatile resources (i.e. those showing tiny freshness lifetime) with access rate in the order of half their refresh rate, are good candidates for implementing observer-based cache refresh.  Imagine a sensor providing one new value every second, and clients accessing it on average once every 1.5 seconds: in one single day of usage, 28800 messages may have been saved if HC establishes an observation on the sensor resource.</p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#hc-block" id="hc-block">Use of CoAP blockwise transfer</a>
</h1>
<p id="rfc.section.4.2.3.p.1">An HC proxy SHOULD support CoAP blockwise transfers <a href="#I-D.ietf-core-block">[I-D.ietf-core-block]</a> to allow transport of large CoAP payloads while avoiding link-layer fragmentation in LLNs, and to cope with small datagram buffers in CoAP end-points as described in <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.  An HC proxy SHOULD attempt to retry a CoAP PUT or POST request with a payload using blockwise transfer if the destination CoAP server responded with 4.13 (Request Entity Too Large) to the original request.  An HC proxy SHOULD attempt to use blockwise transfer when sending a CoAP PUT or POST request message that is larger than BLOCKWISE_THRESHOLD. The value of BLOCKWISE_THRESHOLD is implementation-specific, for example it may set by an administrator, preset to a known or typical UDP datagram buffer size for CoAP end-points, to N times the size of a link-layer frame where e.g. N=5, preset to a known IP MTU value, or set to a known Path MTU value.  </p>
<p id="rfc.section.4.2.3.p.2">For improved latency an HC proxy MAY initiate a blockwise CoAP request triggered by an incoming HTTP request even when the HTTP request message has not yet been fully received, but enough data has been received to send one or more data blocks to a CoAP server already.  </p>
<h1 id="rfc.section.4.2.4">
<a href="#rfc.section.4.2.4">4.2.4.</a> <a href="#hc-v4v6" id="hc-v4v6">Use case: HTTP/IPv4-CoAP/IPv6 proxy</a>
</h1>
<p id="rfc.section.4.2.4.p.1">This section covers the expected common use case regarding an HTTP/IPv4 client accessing a CoAP/IPv6 resource.</p>
<p id="rfc.section.4.2.4.p.2">While HTTP and IPv4 are today widely adopted communication protocols in the Internet, a pervasive deployment of constrained nodes exploiting the IPv6 address space is expected: enabling direct interoperability of such technologies is a valuable goal.</p>
<p id="rfc.section.4.2.4.p.3">An HC proxy supporting IPv4/IPv6 mapping is said to be a v4/v6 proxy.</p>
<p id="rfc.section.4.2.4.p.4">An HC v4/v6 proxy SHOULD always try to resolve the URI authority, and SHOULD prefer using the IPv6 resolution if available.  The authority part of the URI is used internally by the HC proxy and SHOULD not be mapped to CoAP.</p>
<p><a href="#fig-simple-http-coap">Figure 3</a> shows an HTTP client on IPv4 (C) accessing a CoAP server on IPv6 (S) through an HC proxy on IPv4/IPv6 (P).  The DNS has an A record for "node.coap.something.net" resolving to the IPv4 address of the HC proxy, and an AAAA record with the IPv6 address of the CoAP server.</p>
<div id="#rfc.figure.3"></div>
<div id="#fig-simple-http-coap"></div>
<pre>

C     P     S
|     |     |
|     |     |  Source: IPv4 of C
|     |     |  Destination: IPv4 of P
+----&gt;|     |  GET /foo HTTP/1.1
|     |     |  Host: node.coap.something.net
|     |     |  ..other HTTP headers ..
|     |     |
|     |     |  Source: IPv6 of P
|     |     |  Destination: IPv6 of S
|     +----&gt;|  CON GET
|     |     |  URI-Path: foo
|     |     |
|     |     |  Source: IPv6 of S
|     |     |  Destination: IPv6 of P
|     |&lt;----+  ACK
|     |     |
|     |     |  ... Time passes ...
|     |     |
|     |     |  Source: IPv6 of S
|     |     |  Destination: IPv6 of P
|     |&lt;----+  CON 2.00
|     |     |  "bar"
|     |     |
|     |     |  Source: IPv6 of P
|     |     |  Destination: IPv6 of S
|     +----&gt;|  ACK
|     |     |
|     |     |  Source: IPv4 of P
|     |     |  Destination: IPv4 of C
|&lt;----+     |  HTTP/1.1 200 OK
|     |     |  .. other HTTP headers ..
|     |     |
|     |     |  bar
|     |     |

            </pre>
<p id="rfc.section.4.2.4.p.6">The proposed example shows the HC proxy operating also the mapping between IPv4 to IPv6 using the authority information available in any HTTP 1.1 request.  This way, IPv6 connectivity is not required at the HTTP client when accessing a CoAP server over IPv6 only, which is a typical expected use case.</p>
<p id="rfc.section.4.2.4.p.7">When P is an interception HC proxy, the CoAP request SHOULD have the IPv6 address of C as source (IPv4 can always be mapped into IPv6).</p>
<p id="rfc.section.4.2.4.p.8">The described solution takes into account only the HTTP/IPv4 clients accessing CoAP/IPv6 servers; this solution does not provide a full fledged mapping from HTTP to CoAP.</p>
<p id="rfc.section.4.2.4.p.9">In order to obtain a working deployment for HTTP/IPv6 clients, a different HC proxy access method may be required, or Internet AAAA records should not point to the node anymore (the HC proxy should use a different DNS database pointing to the node).</p>
<p id="rfc.section.4.2.4.p.10">When an HC interception proxy deployment is used this solution is fully working even with HTTP/IPv6 clients.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Multiple message exchanges mapping</h1>
<p id="rfc.section.4.3.p.1">This section discusses the mapping of the multicast and observe features of CoAP, which have no corresponding primitive in HTTP, and as such are not immediately translatable.</p>
<p id="rfc.section.4.3.p.2">The mapping, which must be considered in both the arrow directions (H-&gt;C, C-&gt;H) may involve multi-part responses, as in the multicast use case, asynchronous delivery through HTTP bidirectional techniques, and HTTP Web Linking in order to reduce the semantics lost in the translation.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> Relevant features of existing standards</h1>
<p id="rfc.section.4.3.1.p.1">Various features provided by existing standards are useful to efficiently represent sessions involving multiple messages.</p>
<h1 id="rfc.section.4.3.1.1">
<a href="#rfc.section.4.3.1.1">4.3.1.1.</a> Multipart messages</h1>
<p id="rfc.section.4.3.1.1.p.1">In particular, the "multipart/*" media type, defined in Section 5.1 of <a href="#RFC2046">[RFC2046]</a>, is a suitable solution to deliver multiple CoAP responses within a single HTTP payload.  Each part of a multipart entity SHOULD be represented using "message/http" media type containing the full mapping of a single CoAP response as previously described.</p>
<h1 id="rfc.section.4.3.1.2">
<a href="#rfc.section.4.3.1.2">4.3.1.2.</a> Immediate message delivery</h1>
<p id="rfc.section.4.3.1.2.p.1">An HC proxy may prefer to transfer each CoAP response immediately after its reception.  This is possible thanks to the HTTP Transfer-Encoding "chunked", that enables transferring single responses without any further delay.</p>
<p id="rfc.section.4.3.1.2.p.2">A detailed discussion on the use of chunked Transfer-Encoding to stream data over HTTP can be found in <a href="#RFC6202">[RFC6202]</a>.  Large delays between chunks can lead the HTTP session to timeout, more details on this issue can be found in <a href="#I-D.thomson-hybi-http-timeout">[I-D.thomson-hybi-http-timeout]</a>.</p>
<p id="rfc.section.4.3.1.2.p.3">An HC proxy MAY prefer (e.g. to avoid buffering) to transfer each response related to a multicast request as soon as it comes in from the server.  One possible way to achieve this result is using the "chunked" Transfer-Encoding in the HTTP response, to push individual responses until some trigger is fired (timeout, max number of messages, etc.).</p>
<p id="rfc.section.4.3.1.2.p.4">An example showing immediate delivery of CoAP responses using HTTP chunks will be provided in <a href="#hc-subscription">Section 4.3.4</a>, while describing its application to an observe session.</p>
<h1 id="rfc.section.4.3.1.3">
<a href="#rfc.section.4.3.1.3">4.3.1.3.</a> Detailing source information</h1>
<p id="rfc.section.4.3.1.3.p.1">Under some circumstances, responses may come from different sources (i.e. responses to a multicast request); in this case details about the actual source of each CoAP response SHOULD be provided to the client.  Source information can be represented using HTTP Web Linking as defined in <a href="#RFC5988">[RFC5988]</a>, by adding the actual source URI into each response using Link option with "via" relation type.</p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#hc-multicast" id="hc-multicast">Multicast mapping</a>
</h1>
<p id="rfc.section.4.3.2.p.1">In order to establish a multicast communication such a feature should be offered either by the network (i.e. IP multicast, link-layer multicast, etc.) or by a gateway (i.e. the HC proxy).  Rationale on the methods available to obtain such a feature is out-of-scope of this document, and extensive discussion of group communication techniques is available in <a href="#I-D.rahman-core-groupcomm">[I-D.rahman-core-groupcomm]</a>.</p>
<p id="rfc.section.4.3.2.p.2">Additional considerations related to handling multicast requests mapping are detailed in the following sections.</p>
<h1 id="rfc.section.4.3.2.1">
<a href="#rfc.section.4.3.2.1">4.3.2.1.</a> URI identification and mapping</h1>
<p id="rfc.section.4.3.2.1.p.1">In order to successfully handle a multicast request, the HC proxy MUST successfully perform the following tasks on the URI: </p>

<dl>
<dt>Identification:</dt>
<dd style="margin-left: 8">The HC proxy MUST understand whether the requested URI identifies a group of nodes.</dd>
<dt>Mapping:</dt>
<dd style="margin-left: 8">The HC proxy MUST know how to distribute the multicast request to involved servers; this process is specific of the group communication technology used.</dd>
</dl>
<p id="rfc.section.4.3.2.1.p.2">When using IPv6 multicast paired with DNS, the mapping to IPv6 multicast is simply done using DNS resolution.  If the group management is performed at the proxy, the URI or part of it (i.e. the authority) can be mapped using some static or dynamic table available at the HC proxy.  In Section 3.5 of <a href="#I-D.rahman-core-groupcomm">[I-D.rahman-core-groupcomm]</a> discusses a method to build and maintain a local table of multicast authorities.</p>
<h1 id="rfc.section.4.3.2.2">
<a href="#rfc.section.4.3.2.2">4.3.2.2.</a> Request handling</h1>
<p id="rfc.section.4.3.2.2.p.1">When the HC proxy receives a request to a URI that has been successfully identified and mapped to a group of nodes, it SHOULD start a multicast proxying operation, if supported by the proxy.</p>
<p id="rfc.section.4.3.2.2.p.2">Multicast request handling consists of the following steps: </p>

<dl>
<dt>Multicast TX:</dt>
<dd style="margin-left: 8">The HC proxy sends out the request on the CoAP side by using the methods offered by the specific group communication technology used in the constrained network;</dd>
<dt>Collecting RXs:</dt>
<dd style="margin-left: 8">The HC proxy collects every response related to the request;</dd>
<dt>Timeout:</dt>
<dd style="margin-left: 8">The HC proxy has to pay special attention in multicast timing, detailed discussion about timing depends upon the particular group communication technology used;</dd>
<dt>Distributing RXs to the client:</dt>
<dd style="margin-left: 8">The HC proxy can distribute the responses in two different ways: batch delivering them at the end of the process or on timeout, or immediately delivering them as they are available.  Batch requires more caching and introduces delays but may lead to lower TCP overhead and simpler processing.  Immediate delivery is the converse.  A trade-off solution of partial batch delivery may also be feasible and efficient in some circumstances.</dd>
</dl>
<h1 id="rfc.section.4.3.2.3">
<a href="#rfc.section.4.3.2.3">4.3.2.3.</a> Example</h1>
<p><a href="#fig-multicast-http-coap">Figure 4</a> shows an HTTP client (C) requesting the resource "/foo" to a group of CoAP servers (S1/S2/S3) through an HC proxy (P) which uses IP multicast to send the corresponding CoAP request.</p>
<div id="#rfc.figure.4"></div>
<div id="#fig-multicast-http-coap"></div>
<pre>

C     P     S1    S2    S3
|     |     |     |     |
+----&gt;|     |     |     |  GET /foo HTTP/1.1
|     |     |     |     |  Host: group-of-nodes.coap.something.net
|     |     |     |     |  .. other HTTP headers ..
|     |     |     |     |
|     +----&gt;|----&gt;|----&gt;|  NON GET
|     |     |     |     |  URI-Path: foo
|     |     |     |     |
|     |&lt;----------+     |  NON 2.00
|     |     |     |     |  "S2"
|     |     |     |     |
|     | X---------------+  NON 2.00
|     |     |     |     |  "S3"
|     |     |     |     |
|     |&lt;----+     |     |  NON 2.00
|     |     |     |     |  "S1"
|     |     |     |     |
|     |     |     |     |  ... Timeout ...
|     |     |     |     |
|&lt;----+     |     |     |  HTTP/1.1 200 OK
|     |     |     |     |  Content-Type: multipart/mixed; boundary="response"
|     |     |     |     |  .. other HTTP headers ..
|     |     |     |     |
|     |     |     |     |  --response
|     |     |     |     |  Content-Type: message/http
|     |     |     |     |
|     |     |     |     |  HTTP/1.1 200 OK
|     |     |     |     |  Link: &lt;http://node2.coap.something.net/foo&gt;; rel=via
|     |     |     |     |
|     |     |     |     |  S2
|     |     |     |     |
|     |     |     |     |  --response
|     |     |     |     |  Content-Type: message/http
|     |     |     |     |
|     |     |     |     |  HTTP/1.1 200 OK
|     |     |     |     |  Link: &lt;http://node1.coap.something.net/foo&gt;; rel=via
|     |     |     |     |
|     |     |     |     |  S1
|     |     |     |     |
|     |     |     |     |  --response--
|     |     |     |     |

          </pre>
<p id="rfc.section.4.3.2.3.p.2">The example proposed in the above diagram does not make any assumption on which underlying group communication technology is available in the constrained network.  Some detailed discussion is provided about it along the following lines.</p>
<p id="rfc.section.4.3.2.3.p.3">C makes a GET request to group-of-nodes.coap.something.net.  This domain name MAY either resolve to the address of P, or to the IPv6 multicast address of the nodes (if IP multicast is supported and P is an interception proxy), or the proxy P is specifically known by the client that sends this request to it.</p>
<p id="rfc.section.4.3.2.3.p.4">To successfully start multicast proxying operation, the HC proxy MUST know that the destination URI involves a group of CoAP servers, e.g. the authority group-of-nodes.coap.something.net is known to identify a group of nodes either by using an internal lookup table, using DNS paired with IPv6 multicast, or by using some other special technique.</p>
<p id="rfc.section.4.3.2.3.p.5">A specific implementation option is proposed to further explain the proposed example.  Assume that DNS is configured such that all subdomain queries to coap.something.net, such as group-of-nodes.coap.something.net, resolve to the address of P.  P performs the HC URI mapping by removing the 'coap' subdomain from the authority and by switching the scheme from 'http' to 'coap' (result: "coap://group-of-node.something.net/foo"); "group-of-nodes.something.net" is resolved to an IPv6 multicast address to which S1, S2 and S3 belong.  The proxy handles this request as multicast and sends the request "GET /foo" to the multicast group .</p>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#mcast-caching" id="mcast-caching">Multicast responses caching</a>
</h1>
<p id="rfc.section.4.3.3.p.1">We call perfect caching when the proxy uses only the cached representations to provide a response to the HTTP client.  In the case of a multicast CoAP request, perfect caching is not adequate. This section updates the general caching guidelines of <a href="#hc-caching">Section 4.2.1</a> with specific guidelines for the multicast use case.</p>
<p id="rfc.section.4.3.3.p.2">Due to the inherent unreliable nature of the NON messages involved and since nodes may have dynamic membership in multicast groups, responding only with previously cached responses without issuing a new multicast request is not recommended.  This perfect caching behaviour leads to miss responses of nodes that later joined the multicast group, and/or to repeately serve partial representations due to message losses.  Therefore a multicast CoAP request SHOULD be sent by a HC proxy for each incoming request addressed to a multicast group.</p>
<p id="rfc.section.4.3.3.p.3">Caching of multicast responses is still a valuable goal to pursue reduce network congestion, battery consumption and response latency.  Some considerations to be performed when adopting a multicast caching behaviour are outlined in the following paragraph.</p>
<p id="rfc.section.4.3.3.p.4">Caching of multicast GET responses MAY be implemented by adopting some technique that takes into account either knowledge about dynamic characteristics of group membership (occurrence or frequency of group changes) or even better its full knowledge (list of nodes currently part of the group).</p>
<p id="rfc.section.4.3.3.p.5">When using a technique exploiting this knowledge, valid cached responses SHOULD be served from cache.</p>
<h1 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> <a href="#hc-subscription" id="hc-subscription">Subscription mapping</a>
</h1>
<p id="rfc.section.4.3.4.p.1">TBD</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#ch" id="ch">CoAP-HTTP implementation</a>
</h1>
<p id="rfc.section.5.p.1">The CoAP protocol <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a> allows CoAP clients to request CoAP proxies to perform an HTTP request on their behalf.  This is accomplished by the CoAP client populating an HTTP absolute URI in the 'Proxy-URI' option of the CoAP request to the CoAP proxy.  An absolute URI is an HTTP URI that does not contain a fragment component <a href="#RFC3986">[RFC3986]</a>.  The proxy then composes an HTTP request with the given URI and sends it to the appropriate HTTP origin server.  The server then returns the HTTP response to the proxy, which the proxy returns to the CoAP client via a CoAP response</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#CoAP_Placement_Deployment" id="CoAP_Placement_Deployment">Placement and Deployment</a>
</h1>
<p id="rfc.section.5.1.p.1">In typical scenarios, for communication from a CoAP client to an HTTP origin server, the HC proxy is expected to be located on the client-side (CS).  Specifically, the HC proxy is expected to be deployed at the edge of the constrained network as shown in <a href="#fig-coap-http-deployment">Figure 5</a>.</p>
<p id="rfc.section.5.1.p.2">The arguments supporting CS placement are as follows: </p>

<dl>
<dt>Client/Proxy/Network configuration overhead:</dt>
<dd style="margin-left: 8">CoAP clients require either static proxy configuration or proxy discovery support.  This overhead is simplified if the proxy is placed on the same network domain of the client.</dd>
<dt>TCP/UDP:</dt>
<dd style="margin-left: 8">Translation between CoAP and HTTP requires also UDP to TCP mapping; UDP performance over the unconstrained Internet may not be adequate.  In order to minimize the number of required retransmissions on the constrained part of the network and the overall reliability, TCP/UDP conversion SHOULD be performed as soon as possible in the network path.</dd>
<dt>Caching:</dt>
<dd style="margin-left: 8">Efficient caching requires that all the CoAP traffic is intercepted by the same proxy, thus a CS placement, collecting all the traffic, is strategic for this need.</dd>
</dl>
<div id="#rfc.figure.5"></div>
<div id="#fig-coap-http-deployment"></div>
<pre>
    
                            +------+
                            |      |
                            | DNS  |
                            |      |
                            +------+
                                                --------------------
                                               //                  \\
                                              /    /-----\   /---\   \
                                             /       CoAP     CoAP    \
                                            ||      client   client   ||
                                     +----------+  \-----/  \-----/   ||
                                     | HTTP/CoAP|            /-----\  ||
                                     |  Proxy   |              CoAP   ||
                                     |(HC Proxy)|             client  ||
    +------+                         +----------+            \-----/  ||
    |HTTP  |                                ||  /-----\               ||
    |Origin|                                ||    CoAP                ||
    |Server|                                 \   client   /-----\     /
    +------+                                  \ \-----/     CoAP     /
                                               \           client   /
                                                \\        \-----/ //
                                                 ------------------ 
    
        </pre>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#CoAP_HTTP_Mapping" id="CoAP_HTTP_Mapping">Basic mapping</a>
</h1>
<p id="rfc.section.5.2.p.1">The basic mapping of CoAP methods to HTTP is defined in <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.  Specifically the {GET, PUT, POST, DELETE} set of CoAP methods are mapped to the equivalent HTTP methods.</p>
<p id="rfc.section.5.2.p.2">In general, an implementation will translate and forward CoAP requests to the HTTP origin server and translate back HTTP responses to CoAP responses, typically employing a certain amount of caching to make this translation more efficient.  This section gives some hints for implementing the translation.  In addition, some examples are given to illustrate the mappings.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> Payloads and Media Types</h1>
<p id="rfc.section.5.2.1.p.1">CoAP supports only a subset of media types.  A proxy should convert payloads and approximate content-types as closely as possible.  For example, if a HTTP server returns a resource representation in "text/plain; charset=iso-8859-1" format, the proxy should convert the payload to "text/plain; charset=utf-8" format.  If conversion is not possible, the proxy can specify a media type of "application/octet-stream".</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> Max-Age and ETag Options</h1>
<p id="rfc.section.5.2.2.p.1">The proxy can determine the Max-Age Option for responses to GET requests by calculating the freshness lifetime (see Section 13.2.4 of <a href="#RFC2616">[RFC2616]</a>) of the HTTP resource representation retrieved.  The Max-Age Option for responses to POST, PUT or DELETE requests should always be set to 0.</p>
<p id="rfc.section.5.2.2.p.2">The proxy can assign entity tags to responses it sends to a client.  These can be generated locally, if the proxy employs a cache, or be derived from the ETag header field in a response from the HTTP origin server, in which case the proxy can optimize future requests to the HTTP by using Conditional Requests.  Note that CoAP does not support weak entity tags.</p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#ch-block" id="ch-block">Use of CoAP blockwise transfer</a>
</h1>
<p id="rfc.section.5.2.3.p.1">A CH proxy SHOULD support CoAP blockwise transfers <a href="#I-D.ietf-core-block">[I-D.ietf-core-block]</a> to allow transport of large CoAP payloads while avoiding link-layer fragmentation in LLNs, and to cope with small datagram buffers in CoAP end-points as described in <a href="#I-D.ietf-core-block">[I-D.ietf-core-block]</a>.</p>
<p id="rfc.section.5.2.3.p.2">For improved latency a CH proxy MAY initiate a HTTP request triggered by an incoming blockwise CoAP request even when blocks of the CoAP request have only been partially received by the proxy, in cases where the Content-Length field is not going to be used in the HTTP request.  This is useful especially if the network between proxy and HTTP server involves low-bandwidth links.</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> HTTP Status Codes 1xx and 3xx</h1>
<p id="rfc.section.5.2.4.p.1">CoAP does not have provisional responses (HTTP Status Codes 1xx) or responses indicating that further action needs to be taken (HTTP Status Codes 3xx).  When a proxy receives such a response from the HTTP server, the response should cause the proxy to complete the request, for example, by following redirects.  If the proxy is unable or unwilling to do so, it can return a 5.02 (Bad Gateway) error.</p>
<h1 id="rfc.section.5.2.5">
<a href="#rfc.section.5.2.5">5.2.5.</a> Examples</h1>
<p><a href="#fig-basic-coap-http">Figure 6</a> shows an example implementation of a basic CoAP GET request with an HTTP URI as the value of a Proxy-URI option.  The proxy retrieves a representation of the target resource from the HTTP origin server.  It converts the payload to a UTF-8 charset, calculates the Max-Age Option from the Expires header field, and derives an entity-tag from the ETag header field.</p>
<div id="#rfc.figure.6"></div>
<div id="#fig-basic-coap-http"></div>
<pre>

C           P           S
|           |           |
+----------&gt;|           |  CoAP Header: GET (T=CON, Code=1, MID=0x1633)
|   CoAP    |           |  Token:       0x5a
|   Get     |           |  Proxy-URI:   http://www.example.com/foo/bar
|           |           |
|           |           |
|           +----------&gt;|  HTTP/1.1  GET /foo/bar
|           |   HTTP    |  Host: www.example.com
|           |   GET     |
|           |           |
|           |           |
|&lt;----------+           |  CoAP Header: (T=ACK, Code=0, MID=0x1633)
|           |           |  
|           |           |
|           |&lt;----------+  HTTP/1.1  200 OK
|           |   HTTP    |  Date: Friday, 14 Oct 2011 15:00:00 GMT
|           |   200 OK  |  Content-Type: text/plain; charset=iso-8859-1
|           |           |  Content-Length: 11
|           |           |  Expires: Friday, 14 Oct 2011 16:00:00 GMT
|           |           |  ETag: "xyzzy"
|           |           |  Connection: close
|           |           |
|           |           |  Hello World
|           |           |
|           |           |
|&lt;----------+           |  CoAP Header: 2.00 OK (T=CON, Code=64, MID=0xAAFO)
|   CoAP    |           |  Token:       0x5a   
|  2.00 OK  |           |  C-Type:      text/plain; charset=utf-8
|           |           |  Max-Age:     3600
|           |           |  ETag:        0x78797A7A79
|           |           |  Payload:     "Hello World"
|           |           |  
+----------&gt;|           |  CoAP Header:   (T=ACK, Code=0, MID=0xAAF0)

          </pre>
<p id="rfc.section.5.2.5.p.2">The example in <a href="#fig-complex-coap-http">Figure 7</a> builds on the previous example and shows an implementation of a GET request that includes a previously returned ETag Option.  The proxy makes a Conditional Request to the HTTP origin server by including an If-None-Match header field in the HTTP GET Request.  The CoAP response indicates that the response stored by the client is fresh.  It includes a Max-Age Option calculated from the HTTP response's Expires header field.</p>
<div id="#rfc.figure.7"></div>
<div id="#fig-complex-coap-http"></div>
<pre>

C           P           S
|           |           |
+----------&gt;|           |  CoAP Header: GET (T=CON, Code=1, MID=0x1CBO)
|   CoAP    |           |  Token:       0x7b
|   Get     |           |  Proxy-URI:   http://www.example.com/foo/bar
|           |           |  ETag:        0x78797A7A79
|           |           |
|           |           |
|           +----------&gt;|  HTTP/1.1  GET /foo/bar
|           |   HTTP    |  Host: www.example.com
|           |   GET     |  If-None-Match: "xyzzy"
|           |           |
|           |           |
|&lt;----------+           |  CoAP Header: (T=ACK, Code=0, MID=0x1CBO)
|           |           |  
|           |           |
|           |&lt;----------+  HTTP/1.1  304 Not Modified
|           |   HTTP    |  Date: Friday, 14 Oct 2011 17:00:00 GMT
|           |   304     |  Expires: Friday, 14 Oct 2011 18:00:00 GMT
|           |           |  ETag: "xyzzy"
|           |           |  Connection: close 
|           |           |
|           |           |
|&lt;----------+           |  CoAP Header: 2.03 Valid (T=CON, Code=67, MID=0xAAFF)
|   CoAP    |           |  Token:       0x7b   
|   2.03    |           |  Max-Age:     3600
|           |           |  ETag:        0x78797A7A79
|           |           |  
|           |           |  
+----------&gt;|           |  CoAP Header:   (T=ACK, Code=0, MID=0xAAFF)

          </pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec" id="sec">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">The security concerns raised in Section 15.7 of <a href="#RFC2616">[RFC2616]</a> also apply to the HC proxy scenario.  In fact, the HC proxy is a trusted (not rarely a transparently trusted) component in the network path.</p>
<p id="rfc.section.6.p.2">The trustworthiness assumption on the HC proxy cannot be dropped.  Even if we had a blind, bi-directional, end-to-end, tunneling facility like the one provided by the CONNECT method in HTTP, and also assuming the existence of a DTLS-TLS transparent mapping, the two tunneled ends should be speaking the same application protocol, which is not the case.  Basically, the protocol translation function is a core duty of the HC proxy that can't be removed, and makes it a necessarily trusted, impossible to bypass, component in the communication path.</p>
<p id="rfc.section.6.p.3">A reverse proxy deployed at the boundary of a constrained network is an easy single point of failure for reducing availability.  As such, a special care should be taken in designing, developing and operating it, keeping in mind that, in most cases, it could have fewer limitations than the constrained devices it is serving.</p>
<p id="rfc.section.6.p.4">The following sub paragraphs categorize and argue about a set of specific security issues related to the translation, caching and forwarding functionality exposed by an HC proxy module.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Traffic overflow</h1>
<p id="rfc.section.6.1.p.1">Due to the typically constrained nature of CoAP nodes, particular attention SHOULD be posed in the implementation of traffic reduction mechanisms (see <a href="#hc-caching">Section 4.2.1</a>), because inefficient implementations can be targeted by unconstrained Internet attackers.  Bandwidth or complexity involved in such attacks is very low.</p>
<p id="rfc.section.6.1.p.2">An amplification attack to the constrained network may be triggered by a multicast request generated by a single HTTP request mapped to a CoAP multicast resource, as considered in Section XX of <a href="#I-D.ietf-core-coap">[I-D.ietf-core-coap]</a>.</p>
<p id="rfc.section.6.1.p.3">The impact of this amplification technique is higher than an amplification attack carried out by a malicious constrained device (i.e. ICMPv6 flooding, like Packet Too Big, or Parameter Problem on a multicast destination <a href="#RFC4732">[RFC4732]</a>), since it does not require direct access to the constrained network.</p>
<p id="rfc.section.6.1.p.4">The feasibility of this attack, disruptive in terms of CoAP server availability, can be limited by access controlling the exposed HTTP multicast resource, so that only known/authorized users access such URIs.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#sec_mapping" id="sec_mapping">Cross-protocol security policy mapping</a>
</h1>
<p id="rfc.section.6.2.p.1">At the moment of this writing, CoAP and HTTP are missing any cross-protocol security policy mapping.</p>
<p id="rfc.section.6.2.p.2">The HC proxy SHOULD flexibly support security policies between the two protocols, possibly as part of the HC URI mapping function, in order to statically map HTTP and CoAP security policies at the proxy (see <a href="#appendix_secpol_map">Appendix Appendix A.2</a> for an example.)</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Handling secured exchanges</h1>
<p id="rfc.section.6.3.p.1">It is possible that the request from the client to the HC proxy is sent over a secured connection.  However, there may or may not exist a secure connection mapping to the other protocol.  For example, a secure distribution method for multicast traffic is complex and MAY not be implemented (see <a href="#I-D.rahman-core-groupcomm">[I-D.rahman-core-groupcomm]</a>).</p>
<p id="rfc.section.6.3.p.2">By default, an HC proxy SHOULD reject any secured client request if there is no configured security policy mapping.  This recommendation MAY be relaxed in case the destination network is believed to be secured by other, complementary, means.  E.g.: assumed that CoAP nodes are isolated behind a firewall (e.g. as the SS HC proxy deployment shown in <a href="#fig-http-coap-deployment">Figure 2</a>), the HC proxy may be configured to translate the incoming HTTPS request using plain CoAP (i.e. NoSec mode.)</p>
<p id="rfc.section.6.3.p.3">The HC URI mapping MUST NOT map to HTTP (see <a href="#URI-mapping">Section 3.1</a>) a CoAP resource intended to be accessed only using HTTPS.</p>
<p id="rfc.section.6.3.p.4">A secured connection that is terminated at the HC proxy, i.e. the proxy decrypts secured data locally, raises an ambiguity about the cacheability of the requested resource.  The HC proxy SHOULD NOT cache any secured content to avoid any leak of secured information.  However in some specific scenario, a security/efficiency trade-off could motivate caching secured information; in that case the caching behavior MAY be tuned to some extent on a per-resource basis (see <a href="#sec_mapping">Section 6.2</a>).</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Spoofing and Cache Poisoning</h1>
<p id="rfc.section.6.4.p.1">In web security jargon, the "cache poisoning" verb accounts for attacks where an evil user causes the proxy server to associate incorrect content to a cached resource, which work through especially crafted HTTP requests or request/response combos.</p>
<p id="rfc.section.6.4.p.2">When working in CoAP NoSec mode, the use of UDP makes cache poisoning on the constrained network easy and effective, simple address spoofing by a malicious host is sufficient to perform the attack.  The implicit broadcast nature of typical link-layer communication technologies used in constrained networks lead this attack to be easily performed by any host, even without the requirement of being a router in the network.  The ultimate outcome depends on both the order of arrival of packets (legitimate and rogue) and the processing/discarding policy at the CoAP node; attackers targeting this weakness may have less requirements on timing, thus leading the attack to succeed with high probability.</p>
<p id="rfc.section.6.4.p.3">In case the threat of a rogue mote acting in the constrained network can't be winded up by appropriate procedural means, the only way to avoid such attacks is for any CoAP server to work at least in MultiKey mode with a 1:1 key with the HC proxy.  SharedKey mode would just mitigate the attack, since a guessable MIDs and Tokens generation function at the HC proxy side would make it feasible for the evil mote to implement a "try until succeed" strategy.  Also, (authenticated) encryption at a lower layer (MAC/PHY) could be defeated by a slightly more powerful attacker, a compromised router mote.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> Subscription</h1>
<p id="rfc.section.6.5.p.1">As noted in Section 7 of <a href="#I-D.ietf-core-observe">[I-D.ietf-core-observe]</a>, when using the observe pattern, an attacker could easily impose resource exhaustion on a naive server who's indiscriminately accepting observer relationships establishment from clients.  The converse of this problem is also present, a malicious client may also target the HC proxy itself, by trying to exhaust the HTTP connection limit of the proxy by opening multiple subscriptions to some CoAP resource.</p>
<p id="rfc.section.6.5.p.2">Effective strategies to reduce success of such a DoS on the HTTP side (by forcing prior identification of the HTTP client via usual web authentication mechanisms), must always be weighted against an acceptable level of usability of the exposed CoAP resources.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Acknowledgements</h1>
<p id="rfc.section.7.p.1">Special credit is given to Klaus Hartke who provided the text for <a href="#ch">Section 5</a> and a lot of direct input to this document.  Special credit about the text in <a href="#ch">Section 5</a> is given to Carsten Bormann who provied parts of it.</p>
<p id="rfc.section.7.p.2">Thanks to Zach Shelby, Michele Rossi, Nicola Bui, Michele Zorzi, Peter Saint-Andre, Cullen Jennings, Kepeng Li, Brian Frank, Peter Van Der Stok, Kerry Lynn, Linyi Tian, Dorothy Gellert for helpful comments and discussions that have shaped the document.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2046">[RFC2046]</b></td>
<td class="top">
<a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>", RFC 2046, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5988">[RFC5988]</b></td>
<td class="top">
<a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/rfc5988">Web Linking</a>", RFC 5988, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-coap">[I-D.ietf-core-coap]</b></td>
<td class="top">
<a>Shelby, Z</a>, <a>Hartke, K</a>, <a>Bormann, C</a> and <a>B Frank</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-coap-07">Constrained Application Protocol (CoAP)</a>", Internet-Draft draft-ietf-core-coap-07, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-observe">[I-D.ietf-core-observe]</b></td>
<td class="top">
<a>Hartke, K</a> and <a>Z Shelby</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-observe-02">Observing Resources in CoAP</a>", Internet-Draft draft-ietf-core-observe-02, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-block">[I-D.ietf-core-block]</b></td>
<td class="top">
<a>Bormann, C</a> and <a>Z Shelby</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-block-04">Blockwise transfers in CoAP</a>", Internet-Draft draft-ietf-core-block-04, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.rahman-core-groupcomm">[I-D.rahman-core-groupcomm]</b></td>
<td class="top">
<a>Rahman, A</a> and <a>E Dijk</a>, "<a href="http://tools.ietf.org/html/draft-rahman-core-groupcomm-07">Group Communication for CoAP</a>", Internet-Draft draft-rahman-core-groupcomm-07, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-httpbis-p1-messaging">[I-D.ietf-httpbis-p1-messaging]</b></td>
<td class="top">
<a>Fielding, R</a>, <a>Gettys, J</a>, <a>Mogul, J</a>, <a>Nielsen, H</a>, <a>Masinter, L</a>, <a>Leach, P</a>, <a>Berners-Lee, T</a>, <a>Reschke, J</a> and <a>Y Lafon</a>, "<a href="http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-16">HTTP/1.1, part 1: URIs, Connections, and Message Parsing</a>", Internet-Draft draft-ietf-httpbis-p1-messaging-16, August 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.thomson-hybi-http-timeout">[I-D.thomson-hybi-http-timeout]</b></td>
<td class="top">
<a>Thomson, M</a>, <a>Loreto, S</a> and <a>G Wilkins</a>, "<a href="http://tools.ietf.org/html/draft-thomson-hybi-http-timeout-00">Hypertext Transfer Protocol (HTTP) Timeouts</a>", Internet-Draft draft-thomson-hybi-http-timeout-00, March 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3040">[RFC3040]</b></td>
<td class="top">
<a>Cooper, I.</a>, <a>Melve, I.</a> and <a>G. Tomlinson</a>, "<a href="http://tools.ietf.org/html/rfc3040">Internet Web Replication and Caching Taxonomy</a>", RFC 3040, January 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4732">[RFC4732]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Rescorla, E.</a>, <a>IAB</a>, "<a href="http://tools.ietf.org/html/rfc4732">Internet Denial-of-Service Considerations</a>", RFC 4732, December 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6202">[RFC6202]</b></td>
<td class="top">
<a>Loreto, S.</a>, <a>Saint-Andre, P.</a>, <a>Salsano, S.</a> and <a>G. Wilkins</a>, "<a href="http://tools.ietf.org/html/rfc6202">Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</a>", RFC 6202, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.vanderstok-core-bc">[I-D.vanderstok-core-bc]</b></td>
<td class="top">
<a>Stok, P</a> and <a>K Lynn</a>, "<a href="http://tools.ietf.org/html/draft-vanderstok-core-bc-04">CoAP Utilization for Building Control</a>", Internet-Draft draft-vanderstok-core-bc-04, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.bormann-core-simple-server-discovery">[I-D.bormann-core-simple-server-discovery]</b></td>
<td class="top">
<a>Bormann, C</a>, "<a href="http://tools.ietf.org/html/draft-bormann-core-simple-server-discovery-00">CoRE Simple Server Discovery</a>", Internet-Draft draft-bormann-core-simple-server-discovery-00, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.eggert-core-congestion-control">[I-D.eggert-core-congestion-control]</b></td>
<td class="top">
<a>Eggert, L</a>, "<a href="http://tools.ietf.org/html/draft-eggert-core-congestion-control-01">Congestion Control for the Constrained Application Protocol (CoAP)</a>", Internet-Draft draft-eggert-core-congestion-control-01, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.shelby-core-resource-directory">[I-D.shelby-core-resource-directory]</b></td>
<td class="top">
<a>Shelby, Z</a> and <a>S Krco</a>, "<a href="http://tools.ietf.org/html/draft-shelby-core-resource-directory-01">CoRE Resource Directory</a>", Internet-Draft draft-shelby-core-resource-directory-01, September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="W3C.HTML5">[W3C.HTML5]</b></td>
<td class="top">
<a>Hickson, I.</a>, "<a>HTML5</a>", World Wide Web Consortium WD (work in progress) WD-html5-20111018, October 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> Internal Mapping Functions (from an implementer's perspective)</h1>
<p id="rfc.section.Appendix A.p.1">At least three mapping functions have been identified, which take place at different stages of the HC proxy processing chain, involving the URL, Content-Type and Security Policy translation.</p>
<p id="rfc.section.Appendix A.p.2">All these maps are required to have at least URL granularity so that, in principle, each and every requested URL may be treated as an independent mapping source.</p>
<p id="rfc.section.Appendix A.p.3">In the following, the said map functions are characterized via their expected input and output, and a simple, yet sufficiently rich, configuration syntax is suggested.</p>
<p id="rfc.section.Appendix A.p.4">In the spirit of a document providing implementation guidance, the specification of a map grammar aims at putting the basis for a reusable software component (e.g. a stand-alone C library) that many different proxy implementations can link to, and benefit from.</p>
<h1 id="rfc.appendix.Appendix A.1">
<a href="#rfc.appendix.Appendix%20A.1">Appendix A.1.</a> URL Map Algorithm</h1>
<p id="rfc.section.Appendix A.1.p.1">In case the HC proxy is a reverse proxy, i.e. it acts as the origin server in face of the served network, the URL of the resource requested by its clients (perhaps having an 'http' scheme) shall be mapped to the real resource origin (perhaps in the 'coap' scheme).</p>
<p id="rfc.section.Appendix A.1.p.2">In case HC is a forward proxy, no URL translation is needed since the client already knows the "real name" of the resource.</p>
<p id="rfc.section.Appendix A.1.p.3">An interception HC proxy, instead, MAY use the homogeneous mapping strategy (see <a href="#URI-homogeneous-mapping">Section 3.1.1</a> for details) to operate without any pre-configuration need.</p>
<p id="rfc.section.Appendix A.1.p.4">As noted in Appendix B of <a href="#RFC3986">[RFC3986]</a> any correctly formatted URL can be matched by a POSIX regular expression.  By leveraging on this property, we suggest a syntax that describes the URL mapping in terms of substituting the regex-matching portions of the requested URL into the mapped URL template.</p>
<p id="rfc.section.Appendix A.1.p.5">E.g.: given the source regular expression '^http://example.com/coap/.*$' and destination template 'coap://$1' (where $1 stands for the first - and only in this specific case - substring matched by the regex pattern in the source), the input URL "http://example.com/coap/node1/resource2" translates to "coap://node1/resource2".</p>
<p id="rfc.section.Appendix A.1.p.6">This is a well established technique used in many todays web components (e.g. Django URL dispatcher, Apache mod_rewrite, etc.), which provides a compact and powerful engine to implement what essentially is an URL rewrite function.</p>
<div id="#rfc.figure.8"></div>
<pre>
INPUT
    * requested URL

OUTPUT
    * target URL

SYNTAX
    url_map [rule name] {
        requested_url   &lt;regex&gt;
        mapped_url      &lt;regex match subst template&gt;
    }

EXAMPLE 1
    url_map homogeneous {
        requested_url   '^http://.*$'
        mapped_url      'coap//$1'
    }

EXAMPLE 2
    url_map embedded {
        requested_url   '^http://example.com/coap/.*$'
        mapped_url      'coap//$1'
    }
</pre>
<p id="rfc.section.Appendix A.1.p.7">Note that many different url_map records may be given in order to build the whole mapping function.  Each of these records can be queried (in some predefined order) by the HC proxy until a match is found, or the list is exhausted.  In the latter case, depending on the mapping policy (only internal, internal then external, etc.) the original request can be refused, or the same mapping query is forwarded to one or more external URL mapping components.</p>
<h1 id="rfc.appendix.Appendix A.2">
<a href="#rfc.appendix.Appendix%20A.2">Appendix A.2.</a> <a href="#appendix_secpol_map" id="appendix_secpol_map">Security Policy Map Algorithm</a>
</h1>
<p id="rfc.section.Appendix A.2.p.1">In case the "incoming" URL has been successfully translated, the HC proxy must lookup the security policy, if any, that needs to be applied to the request/response transaction carried on the "outgoing" leg.</p>
<div id="#rfc.figure.9"></div>
<pre>
INPUT
    * target URL (after URL map has been applied)
    * original requester identity (given by cookie, or IP address, or
      crypto credentials/security context, etc.)

OUTPUT
    * security context that will be applied to access the target URL

SYNTAX
    sec_map [rule name] {
        target_url      &lt;regex&gt;     -- one or more
        requester_id    [TBD]
        sec_context     [TBD]
    }

EXAMPLE
    [TBD]
</pre>
<h1 id="rfc.appendix.Appendix A.3">
<a href="#rfc.appendix.Appendix%20A.3">Appendix A.3.</a> Content-Type Map Algorithm</h1>
<p id="rfc.section.Appendix A.3.p.1">In case a set of destination URLs is known as being limited in handling a narrow subset of mime types, a content-type map can be configured in order to let the HC proxy transparently handle the compatible/lossless format translation.</p>
<div id="#rfc.figure.10"></div>
<pre>
INPUT
    * destination URL (after URL map has been applied)
    * original content-type

OUTPUT
    * mapped content-type 

SYNTAX
    ct_map {
        target_url  &lt;regex&gt;                 -- one or more targetURLs
        ct_switch   &lt;source_ct, dest_ct&gt;    -- one or more CTs
    }

EXAMPLE
    ct_map {
        target_url  '^coap://class-1-device/.*$'
        ct_switch   */xml   application/exi
    }
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Angelo P. Castellani</span> 
	  <span class="n hidden">
		<span class="family-name">Castellani</span>
	  </span>
	</span>
	<span class="org vcardline">University of Padova</span>
	<span class="adr">
	  <span>Via Gradenigo 6/B</span>

	  <span class="vcardline">
		<span class="locality">Padova</span>,  
		<span class="region"></span>
		<span class="code">35131</span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:angelo@castellani.net">angelo@castellani.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Salvatore Loreto</span> 
	  <span class="n hidden">
		<span class="family-name">Loreto</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span>Hirsalantie 11</span>

	  <span class="vcardline">
		<span class="locality">Jorvas</span>,  
		<span class="region"></span>
		<span class="code">02420</span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:salvatore.loreto@ericsson.com">salvatore.loreto@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Akbar Rahman</span> 
	  <span class="n hidden">
		<span class="family-name">Rahman</span>
	  </span>
	</span>
	<span class="org vcardline">InterDigital Communications, LLC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Akbar.Rahman@InterDigital.com">Akbar.Rahman@InterDigital.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Thomas Fossati</span> 
	  <span class="n hidden">
		<span class="family-name">Fossati</span>
	  </span>
	</span>
	<span class="org vcardline">KoanLogic</span>
	<span class="adr">
	  <span>Via di Sabbiuno 11/5</span>

	  <span class="vcardline">
		<span class="locality">Bologna</span>,  
		<span class="region"></span>
		<span class="code">40136</span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">Phone: +39 051 644 82 68</span>

<span class="vcardline">EMail: <a href="mailto:tho@koanlogic.com">tho@koanlogic.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Esko Dijk</span> 
	  <span class="n hidden">
		<span class="family-name">Dijk</span>
	  </span>
	</span>
	<span class="org vcardline">Philips Research</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:esko.dijk@philips.com">esko.dijk@philips.com</a></span>

  </address>
</div>

</body>
</html>