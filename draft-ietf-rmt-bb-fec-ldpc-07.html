<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes">
<meta name="keywords" content="LDPC, FEC">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">RMT</td><td class="header">V. Roca</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">INRIA</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">C. Neumann</td></tr>
<tr><td class="header">Expires: May 19, 2008</td><td class="header">Thomson</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">D. Furodet</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">STMicroelectronics</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 16, 2007</td></tr>
</table></td></tr></table>
<h1><br />Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes<br />draft-ietf-rmt-bb-fec-ldpc-07.txt</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 19, 2008.</p>

<h3>Abstract</h3>

<p>This document describes two Fully-Specified FEC Schemes,
		LDPC-Staircase and LDPC-Triangle, and their application to the
		reliable delivery of data objects on the packet erasure channel
		(i.e., a communication path where packets are either received
		without any corruption or discarded during transmission).
		These systematic FEC codes belong to the well known class of
		``Low Density Parity Check'' (LDPC) codes, and are large block
		FEC codes in the sense of RFC3453. 
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">2.</a>&nbsp;
Requirements notation<br />
<a href="#anchor2">3.</a>&nbsp;
Definitions, Notations and Abbreviations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.1.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.2.</a>&nbsp;
Notations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.3.</a>&nbsp;
Abbreviations<br />
<a href="#anchor6">4.</a>&nbsp;
Formats and Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FPI">4.1.</a>&nbsp;
FEC Payload IDs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI">4.2.</a>&nbsp;
FEC Object Transmission Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.2.1.</a>&nbsp;
Mandatory Element<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#common_elements">4.2.2.</a>&nbsp;
Common Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scheme_specific_elt">4.2.3.</a>&nbsp;
Scheme-Specific Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI_encoding_format">4.2.4.</a>&nbsp;
Encoding Format<br />
<a href="#procedures">5.</a>&nbsp;
Procedures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#general">5.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#max_source_block_length">5.2.</a>&nbsp;
Determining the Maximum Source Block Length (B)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_symbol_length">5.3.</a>&nbsp;
Determining the Encoding Symbol Length (E) and Number of
Encoding Symbols per Group (G)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#max_n-algorithm">5.4.</a>&nbsp;
Determining the  Maximum Number of Encoding Symbols Generated for Any Source Block (max_n)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#n-algorithm">5.5.</a>&nbsp;
Determining the Number of Encoding Symbols of a Block (n)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_symbol_group">5.6.</a>&nbsp;
Identifying the G Symbols of an Encoding Symbol Group<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#prng">5.7.</a>&nbsp;
Pseudo Random Number Generator<br />
<a href="#ldpc_staircase">6.</a>&nbsp;
Full Specification of the LDPC-Staircase Scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">6.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#staircase_matrix">6.2.</a>&nbsp;
Parity Check Matrix Creation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_staircase">6.3.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#decoding_staircase">6.4.</a>&nbsp;
Decoding<br />
<a href="#ldpc_triangle">7.</a>&nbsp;
 Full Specification of the LDPC-Triangle Scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">7.2.</a>&nbsp;
Parity Check Matrix Creation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_triangle">7.3.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.4.</a>&nbsp;
Decoding<br />
<a href="#anchor14">8.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">8.1.</a>&nbsp;
Problem Statement<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">8.2.</a>&nbsp;
Attacks Against the Data Flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">8.2.1.</a>&nbsp;
Access to Confidential Objects<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">8.2.2.</a>&nbsp;
Content Corruption<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">8.3.</a>&nbsp;
Attacks Against the FEC Parameters<br />
<a href="#iana-cons">9.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor20">10.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#prng_example">Appendix&nbsp;A.</a>&nbsp;
Pseudo Random Number Generator Example Implementation (Informative Only)<br />
<a href="#trivial_decoding">Appendix&nbsp;B.</a>&nbsp;
Trivial Decoding Algorithm (Informative Only)<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p><a class='info' href='#RFC3453'>[RFC3453]<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a>
introduces large block FEC codes as an alternative to small
block FEC codes like Reed-Solomon.
The main advantage of such large block codes is the possibility to operate
efficiently on source blocks of size several tens of thousands (or more)
source symbols.
The present document introduces 
the Fully-Specified FEC Encoding ID 3 that is intended to be used with
the LDPC-Staircase FEC codes, and 
the Fully-Specified FEC Encoding ID 4 that is intended to be used with
the LDPC-Triangle FEC codes
<a class='info' href='#RN04'>[RN04]<span> (</span><span class='info'>Roca, V. and C. Neumann, &ldquo;Design, Evaluation and Comparison of Four 		Large Block FEC Codecs: LDPC, LDGM, LDGM-Staircase and LDGM-Triangle, Plus 		a Reed-Solomon Small Block FEC Codec,&rdquo; June&nbsp;2004.</span><span>)</span></a><a class='info' href='#MK03'>[MK03]<span> (</span><span class='info'>MacKay, D., &ldquo;Information Theory, Inference and Learning Algorithms,&rdquo; 2003.</span><span>)</span></a>.
Both schemes belong to the broad class of large block codes.
For a definition of the term Fully-Specified Scheme, see
<a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>, section 4.

</p>
<p>
LDPC codes rely on a dedicated matrix, called a "Parity Check
Matrix", at the encoding and decoding ends. The parity check matrix
defines relationships (or constraints) between the various encoding
symbols (i.e., source symbols and repair symbols), that are later used
by the decoder to reconstruct the original k source symbols if some
of them are missing. These codes are systematic, in the sense that
the encoding symbols include the source symbols in addition to the
repair symbols.
</p>
<p>
Since the encoder and decoder must operate on the same parity
check matrix, information must be communicated between them as
part of the FEC Object Transmission Information.
</p>
<p>
A publicly available reference implementation of these codes is available
and distributed under a GNU/LGPL license <a class='info' href='#LDPC-codec'>[LDPC&#8209;codec]<span> (</span><span class='info'>Roca, V., Neumann, C., Cunche, M., and J. Laboure, &ldquo;LDPC-Staircase/LDPC-Triangle Codec Reference Implementation,&rdquo; .</span><span>)</span></a>.
Besides, the code extracts included in this document
(except <a class='info' href='#prng_example'>Appendix&nbsp;A<span> (</span><span class='info'>Pseudo Random Number Generator Example Implementation (Informative Only)</span><span>)</span></a> that is only provided as an example)
are directly contributed to the IETF process by the authors of this
document and by Radford M. Neal.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
    "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
    and "OPTIONAL" in this document are to be interpreted as
    described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Definitions, Notations and Abbreviations</h3>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Definitions</h3>

<p>This document uses the same terms and definitions as those
specified in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
Additionally, it uses the following definitions:
</p>
<blockquote class="text">
<p>Source symbol:		unit of data used during the encoding process
</p>
<p>Encoding symbol:		unit of data generated by the encoding process
</p>
<p>Repair symbol:		encoding symbol that is not a source symbol
</p>
<p>Code rate:			the k/n ratio, i.e., the ratio between the number
				of source symbols and the number of encoding symbols. The code
				rate belongs to a ]0; 1] interval. A code rate close to 1 indicates
				that a small number of repair symbols have been produced during
				the encoding process
</p>
<p>Systematic code:		FEC code in which the source symbols are part
				of the encoding symbols
</p>
<p>Source block:		a block of k source symbols that are considered
				together for the encoding
</p>
<p>Encoding Symbol Group:	a group of encoding symbols that are
				sent together, within the same packet, and
				whose relationships to the source object can
				be derived from a single Encoding Symbol
				ID
</p>
<p>Source Packet:		a data packet containing only source
				symbols
</p>
<p>Repair Packet:		a data packet containing only repair
				symbols
</p>
<p>Packet Erasure Channel:	a communication path where packets are either
				dropped (e.g., by a congested router, or because the
				number of transmission errors exceeds the correction
				capabilities of the physical layer codes) or
				received. When a packet is received, it is assumed
				that this packet is not corrupted
</p>
</blockquote><p>

</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Notations</h3>

<p>This document uses the following notations:
</p>
<blockquote class="text">
<p>L		denotes the object transfer length in bytes
</p>
<p>k		denotes the source block length in symbols,
		i.e., the number of source symbols of a source block
</p>
<p>n		denotes the encoding block length, i.e., the number of
		encoding symbols generated for a source block
</p>
<p>E		denotes the encoding symbol length in bytes
</p>
<p>B		denotes the maximum source block length in symbols,
		i.e., the maximum number of source symbols per source block
</p>
<p>N		denotes the number of source blocks into which the object
		shall be partitioned
</p>
<p>G		denotes the number of encoding symbols per group, i.e.
		the number of symbols sent in the same packet
</p>
<p>CR		denotes the "code rate", i.e., the k/n ratio
</p>
<p>max_n	denotes the maximum number of encoding symbols generated
		for any source block.
		This is in particular the number of encoding symbols
		generated for a source block of size B
</p>
<p>H		denotes the parity check matrix
</p>
<p>srand(s)	denotes the initialization function of the pseudo-random
		number generator, where s is the seed (s > 0)
</p>
<p>rand(m)	denotes a pseudo-random number generator that returns
		a new random integer in [0; m-1] each time it is called
</p>
</blockquote>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Abbreviations</h3>

<p>This document uses the following abbreviations:
</p>
<blockquote class="text">
<p>ESI:		Encoding Symbol ID
</p>
<p>FEC OTI:	FEC Object Transmission Information
</p>
<p>FPI:		FEC Payload ID
</p>
<p>LDPC:	Low Density Parity Check
</p>
<p>PRNG:	Pseudo Random Number Generator
</p>
</blockquote>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Formats and Codes</h3>

<a name="FPI"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
FEC Payload IDs</h3>

<p>The FEC Payload ID is composed of the Source Block 
   Number and the Encoding Symbol ID:
</p>
<p>
</p>
<blockquote class="text">
<p>The Source Block Number (12 bit field) identifies from which source block
   of the object the encoding symbol(s) in the packet payload is(are) generated.
   There are a maximum of 2^^12 blocks per object. Source block numbering starts at 0.
</p>
<p>The Encoding Symbol ID (20 bit field) identifies which encoding
   symbol(s) generated from the source block is(are) carried in the packet payload.
   There are a maximum of 2^^20 encoding symbols per block.
   The first k values (0 to k-1) identify source symbols, the remaining n-k
   values (k to n-k-1) identify repair symbols.
</p>
</blockquote><p>

</p>
<p>There MUST be exactly one FEC Payload ID per packet.
In case of an Encoding Symbol Group,
when multiple encoding symbols are sent in the same packet,
the FEC Payload ID refers to the first symbol of the packet.
The other symbols can be deduced from the ESI of the first symbol
thanks to a dedicated function, as explained in
<a class='info' href='#encoding_symbol_group'>Section&nbsp;5.6<span> (</span><span class='info'>Identifying the G Symbols of an Encoding Symbol Group</span><span>)</span></a>

</p><br /><hr class="insert" />
<a name="fig_fec_payload_id_for_1"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Source Block Number  |      Encoding Symbol ID (20 bits)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: FEC Payload ID encoding format for FEC Encoding ID 3 and 4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="FEC_OTI"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
FEC Object Transmission Information</h3>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Mandatory Element</h3>

<p>
</p>
<ul class="text">
<li>FEC Encoding ID: 
   the LDPC-Staircase and LDPC-Triangle Fully-Specified FEC Schemes use
   respectively the FEC Encoding ID 3 (Staircase) and 4 (Triangle).
   
</li>
</ul><p>

</p>
<a name="common_elements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Common Elements</h3>

<p> The following elements MUST be defined with the present FEC Schemes:
</p>
<p>
</p>
<ul class="text">
<li>Transfer-Length (L): a non-negative integer indicating the length of the
      object in bytes.
      There are some restrictions on the maximum Transfer-Length that
      can be supported:
      
<blockquote class="text">
<p>maximum transfer length = 2^^12 * B * E
</p>
</blockquote>
      For instance, if B=2^^19 (because of a code rate of 1/2, 
      <a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a>), and if E=1024 bytes,
      then the maximum transfer length is 2^^41 bytes (or 2 TB).
      The upper limit, with symbols of size 2^^16-1 bytes and a code rate
      larger or equal to 1/2, amounts to 2^^47 bytes (or 128 TB).
      
</li>
<li>Encoding-Symbol-Length (E): a non-negative integer indicating the length
      of each encoding symbol in bytes.
</li>
<li>Maximum-Source-Block-Length (B): a non-negative integer indicating the
      maximum number of source symbols in a source block.
      There are some restrictions on the maximum B value, as explained in
      <a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a>.
      
</li>
<li>Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
      indicating the maximum number of encoding symbols generated for
      any source block.
      There are some restrictions on the maximum max_n value.
      In particular max_n is at most equal to 2^^20.
      
</li>
</ul><p>

</p>
<p><a class='info' href='#procedures'>Section&nbsp;5<span> (</span><span class='info'>Procedures</span><span>)</span></a> explains how to define the values
      of each of these elements.
</p>
<a name="scheme_specific_elt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Scheme-Specific Elements</h3>

<p> The following elements MUST be defined with the present FEC Scheme:
</p>
<p>
</p>
<ul class="text">
<li> G: a non-negative integer indicating the number of encoding symbols
    per group (i.e., per packet). The default value is 1, meaning that
    each packet contains exactly one symbol.
    Values greater than 1 can also be defined, as explained in
    <a class='info' href='#encoding_symbol_length'>Section&nbsp;5.3<span> (</span><span class='info'>Determining the Encoding Symbol Length (E) and Number of Encoding Symbols per Group (G)</span><span>)</span></a>.
    
</li>
<li> PRNG seed: the seed is a 32 bit unsigned integer between 1 and 
    0x7FFFFFFE (i.e., 2^^31-2) inclusive. This value is used to initialize the
    Pseudo Random Number Generator (<a class='info' href='#prng'>Section&nbsp;5.7<span> (</span><span class='info'>Pseudo Random Number Generator</span><span>)</span></a>).
</li>
</ul><p>

</p>
<a name="FEC_OTI_encoding_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
Encoding Format</h3>

<p>This section shows two possible encoding formats of the above FEC OTI.
    The present document does not specify when or how these encoding
    formats should be used.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4.1"></a><h3>4.2.4.1.&nbsp;
Using the General EXT_FTI Format</h3>

<p>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g., within the ALC <a class='info' href='#draft-ietf-rmt-pi-alc-revised'>[draft&#8209;ietf&#8209;rmt&#8209;pi&#8209;alc&#8209;revised]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; February&nbsp;2007.</span><span>)</span></a>
 or NORM <a class='info' href='#draft-ietf-rmt-pi-norm-revised'>[draft&#8209;ietf&#8209;rmt&#8209;pi&#8209;norm&#8209;revised]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; March&nbsp;2007.</span><span>)</span></a> protocols).

</p><br /><hr class="insert" />
<a name="fig_ext_fti"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    |    HEL = 5    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |       G       |   B (MSB)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        B (LSB)        |   Max Nb of Enc. Symbols  (max_n)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           PRNG seed                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: EXT_FTI Header for FEC Encoding ID 3 and 4.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
In particular:
</p>
<ul class="text">
<li>The Transfer-Length (L) field size (48 bits) is larger than the
	size required to store the maximum transfer length
	(<a class='info' href='#common_elements'>Section&nbsp;4.2.2<span> (</span><span class='info'>Common Elements</span><span>)</span></a>) for field alignment purposes.
</li>
<li>The Maximum-Source-Block-Length (B) field (20 bits)
	is split into two parts:
	the 8 most significant bits (MSB) are in the third 32-bit
	word of the EXT_FTI, and the remaining 12 least significant
	bits (LSB) are in the fourth 32-bit word.
</li>
</ul><p>

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4.2"></a><h3>4.2.4.2.&nbsp;
Using the FDT Instance (FLUTE specific)</h3>

<p>When it is desired that the FEC OTI be carried in the FDT Instance
of a FLUTE session <a class='info' href='#draft-ietf-rmt-flute-revised'>[draft&#8209;ietf&#8209;rmt&#8209;flute&#8209;revised]<span> (</span><span class='info'>Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; October&nbsp;2007.</span><span>)</span></a>,
the following XML attributes must be described for the associated object:
</p>
<ul class="text">
<li>FEC-OTI-FEC-Encoding-ID
</li>
<li>FEC-OTI-Transfer-length
</li>
<li>FEC-OTI-Encoding-Symbol-Length
</li>
<li>FEC-OTI-Maximum-Source-Block-Length
</li>
<li>FEC-OTI-Max-Number-of-Encoding-Symbols
</li>
<li>FEC-OTI-Scheme-Specific-Info
</li>
</ul><p>
The FEC-OTI-Scheme-Specific-Info contains the string resulting from
the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
following value:

</p><br /><hr class="insert" />
<a name="fig_scheme_specific"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        PRNG seed                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       G       |
+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: FEC OTI Scheme Specific Information to be Included in the FDT Instance
	for FEC Encoding ID 3 and 4.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
During Base64 encoding, the 5 bytes of the FEC OTI Scheme Specific Information
are transformed into a string of 8 printable characters (in the 64-character
alphabet) that is added to the FEC-OTI-Scheme-Specific-Info attribute.

</p>
<a name="procedures"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Procedures</h3>

<p>This section defines procedures that are common to FEC Encoding IDs
3 and 4.
</p>
<a name="general"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
General</h3>

<p>
The B (maximum source block length in symbols), E (encoding symbol length in bytes)
and G (number of encoding symbols per group) parameters are first determined.
The algorithms of <a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a> and
<a class='info' href='#encoding_symbol_length'>Section&nbsp;5.3<span> (</span><span class='info'>Determining the Encoding Symbol Length (E) and Number of Encoding Symbols per Group (G)</span><span>)</span></a> MAY be used to that purpose.
Using other algorithms is possible without compromising interoperability
since the B, E and G parameters are communicated to the receiver by means
of the FEC OTI.

</p>
<p>
Then, the source object MUST be partitioned using the
block partitioning algorithm specified in <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
To that purpose, the B, L (object transfer length in bytes), and E
arguments are provided.
As a result, the object is partitioned into N source blocks.
These blocks are numbered consecutively from 0 to N-1.
The first I source blocks consist of A_large source symbols, the
remaining N-I source blocks consist of A_small source symbols.
Each source symbol is E bytes in length, except perhaps the last
symbol which may be shorter.

</p>
<p>
Then, the max_n (maximum number of encoding symbols generated for any
source block) parameter is determined.
The algorithm of <a class='info' href='#max_n-algorithm'>Section&nbsp;5.4<span> (</span><span class='info'>Determining the  Maximum Number of Encoding Symbols Generated for Any Source Block (max_n)</span><span>)</span></a> MAY be used to
that purpose.
Using another algorithm is possible without compromising interoperability
since the max_n parameter is communicated to the receiver by means
of the FEC OTI.

</p>
<p>
For each block, the actual number of encoding symbols, n, MUST then be
determined using the "n-algorithm" detailed in <a class='info' href='#n-algorithm'>Section&nbsp;5.5<span> (</span><span class='info'>Determining the Number of Encoding Symbols of a Block (n)</span><span>)</span></a>.

</p>
<p>
Then, FEC encoding and decoding can be done block per block, independently.
To that purpose, a parity check matrix is created, that forms
a system of linear equations between the source and repair symbols of a
given block, where the basic operator is XOR.

</p>
<p>
This parity check matrix is logically divided into two parts:
the left side (from column 0 to k-1) describes
the occurrences of each source symbol in the system of linear
equations;
the right side (from column k to n-1) describes
the occurrences of each repair symbol in the system of linear
equations.
The only difference between the LDPC-Staircase and LDPC-Triangle
schemes is the construction of this right sub-matrix.
An entry (a "1") in the matrix at position (i,j) (i.e.,
at row i and column j) means that the symbol with ESI j
appears in equation i of the system.

</p>
<p>
When the parity symbols have been created, the sender transmits
source and parity symbols.
The way this transmission occurs can largely impact the erasure recovery
capabilities of the LDPC-* FEC.
In particular, sending parity symbols in sequence is suboptimal.
Instead it is usually recommended the shuffle these symbols.
The interested reader will find more details in <a class='info' href='#NRFF05'>[NRFF05]<span> (</span><span class='info'>Neumann, C., Roca, V., Francillon, A., and D. Furodet, &ldquo;Impacts of Packet Scheduling and Packet Loss Distribution on FEC Performances: Observations and Recommendations,&rdquo; October&nbsp;2005.</span><span>)</span></a>.

</p>
<p>
The following sections detail how the B, E, G, max_nand n parameters are determined
(respectively in
<a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a>, <a class='info' href='#encoding_symbol_length'>Section&nbsp;5.3<span> (</span><span class='info'>Determining the Encoding Symbol Length (E) and Number of Encoding Symbols per Group (G)</span><span>)</span></a>,
<a class='info' href='#max_n-algorithm'>Section&nbsp;5.4<span> (</span><span class='info'>Determining the  Maximum Number of Encoding Symbols Generated for Any Source Block (max_n)</span><span>)</span></a> and <a class='info' href='#n-algorithm'>Section&nbsp;5.5<span> (</span><span class='info'>Determining the Number of Encoding Symbols of a Block (n)</span><span>)</span></a>),
how encoding symbol groups are created
(<a class='info' href='#encoding_symbol_group'>Section&nbsp;5.6<span> (</span><span class='info'>Identifying the G Symbols of an Encoding Symbol Group</span><span>)</span></a>), and
finally <a class='info' href='#prng'>Section&nbsp;5.7<span> (</span><span class='info'>Pseudo Random Number Generator</span><span>)</span></a> details the PRNG.

</p>
<a name="max_source_block_length"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Determining the Maximum Source Block Length (B)</h3>

<p>
The B parameter (maximum source block length in symbols) depends
on several parameters:
the code rate (CR), the Encoding Symbol ID field length of the FEC
Payload ID (20 bits), as well as possible internal codec limitations.

</p>
<p>
The B parameter cannot be larger than the following values, derived
from the FEC Payload ID limitations, for a given code rate:
      </p>
<blockquote class="text">
<p>max1_B = 2^^(20 - ceil(Log2(1/CR)))
</p>
</blockquote><p>

</p>
<p>
Some common max1_B values are:
</p>
<ul class="text">
<li>CR == 1 (no repair symbol): max1_B = 2^^20 = 1,048,576
</li>
<li>1/2 &le; CR &lt; 1: max1_B = 2^^19 = 524,288 symbols
</li>
<li>1/4 &le; CR &lt; 1/2: max1_B = 2^^18 = 262,144 symbols
</li>
<li>1/8 &le; CR &lt; 1/4: max1_B = 2^^17 = 131,072 symbols
</li>
</ul><p>

</p>
<p>Additionally, a codec MAY impose other limitations on the maximum
block size. 
For instance, this is the case when the codec uses internally 16 bit
unsigned integers to store the Encoding Symbol ID, since it does not enable to
store all the possible values of a 20 bit field.
In that case, if for instance 1/2 &le; CR &lt; 1, then the maximum source block
length is 2^^15.
Other limitations may also apply, for instance because of a limited working
memory size.
This decision MUST be clarified at implementation time, when the target
use case is known. This results in a max2_B limitation.
</p>
<p>
Then, B is given by:
      </p>
<blockquote class="text">
<p>B = min(max1_B, max2_B)
</p>
</blockquote><p>
Note that this calculation is only required at the coder, since the
B parameter is communicated to the decoder through the FEC OTI.

</p>
<a name="encoding_symbol_length"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Determining the Encoding Symbol Length (E) and Number of
Encoding Symbols per Group (G)</h3>

<p>
The E parameter usually depends on the maximum transmission unit on the
path (PMTU) from the source to each receiver.
In order to minimize the protocol header overhead
(e.g., the LCT/UDP/IPv4 or IPv6 headers in case of ALC), E is chosen as large
as possible.
In that case, E is chosen so that the size of a packet composed of a single
symbol (G=1) remains below but close to the PMTU.

</p>
<p>
However other considerations can exist.
For instance, the E parameter can be made a function of the object transfer
length.
Indeed, LDPC codes are known to offer better protection for large blocks.
In case of small objects, it can be advantageous to reduce the encoding
symbol length (E) in order to artificially increase the number of symbols,
and therefore the block size.

</p>
<p>
In order to minimize the protocol header overhead, several symbols can
be grouped in the same Encoding Symbol Group (i.e., G &gt; 1).
Depending on how many symbols are grouped (G) and on the packet loss rate
(G symbols are lost for each packet erasure), this strategy might or might
not be appropriate.
A balance must therefore be found.

</p>
<p>
The current specification does not mandate any value for either E or G.
The current specification only provides an example of possible choices for E and G.
Note that this choice is done by the sender, and the E and G parameters are then
communicated to the receiver thanks to the FEC OTI.
Note also that the decoding algorithm used influences the choice of the E and G
parameters.
Indeed, increasing the number of symbols will negatively impact the processing
load when decoding is based (in part or totally) on Gaussian elimination,
whereas the impacts will be rather low when decoding is based on the
trivial algorithm sketched in <a class='info' href='#decoding_staircase'>Section&nbsp;6.4<span> (</span><span class='info'>Decoding</span><span>)</span></a>.

</p>
<p>
Example:

</p>
<p>
Let us assume that the trivial decoding algorithm sketched in <a class='info' href='#decoding_staircase'>Section&nbsp;6.4<span> (</span><span class='info'>Decoding</span><span>)</span></a>
is used.
First define the target packet payload size, pkt_sz (at most equal to the PMTU
minus the size of the various protocol headers).
The pkt_sz must be chosen in such a way that the symbol size is an
integer. This can require that pkt_sz be a multiple of 4, 8 or 16 (see the table below).
Then calculate the number of packets in the object: nb_pkts = ceil(L / pkt_sz).
Finally, thanks to nb_pkts, use the following table to find a possible G value.

</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center"><col align="center"><col align="center">
<tr><th align="center">Number of packets</th><th align="center">G</th><th align="center">Symbol size</th><th align="center">k</th></tr>
<tr>
<td align="center">4000 &le; nb_pkts</td>
<td align="center">1</td>
<td align="center">pkt_sz</td>
<td align="center">4000 &le; k</td>
</tr>
<tr>
<td align="center">1000 &le; nb_pkts &lt; 4000</td>
<td align="center">4</td>
<td align="center">pkt_sz / 4</td>
<td align="center">4000 &le; k &lt; 16000</td>
</tr>
<tr>
<td align="center">500 &le; nb_pkts &lt; 1000</td>
<td align="center">8</td>
<td align="center">pkt_sz / 8</td>
<td align="center">4000 &le; k &lt; 8000</td>
</tr>
<tr>
<td align="center">1 &le; nb_pkts &lt; 500</td>
<td align="center">16</td>
<td align="center">pkt_sz / 16</td>
<td align="center">16 &le; k &lt; 8000</td>
</tr>
</table>
<br clear="all" />

<a name="max_n-algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Determining the  Maximum Number of Encoding Symbols Generated for Any Source Block (max_n)</h3>

<p>
The following algorithm MAY be used by a sender to determine the maximum number of
encoding symbols generated for any source block (max_n) as a function of B and the
target code rate.
Since the max_n parameter is communicated to the decoder by means of the FEC OTI,
another method MAY be used to determine max_n.

</p>
<p> Input:
</p>
<blockquote class="text">
<p>B:		Maximum source block length, for any source block.
		<a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a> MAY be used to
		determine its value.
</p>
<p>CR:		FEC code rate, which is provided by the user (e.g., when
		starting a FLUTE sending application).
		It is expressed as a floating point value.
		The CR value must be such that the resulting number of
		encoding symbols per block is at most equal to 2^^20
		(<a class='info' href='#FPI'>Section&nbsp;4.1<span> (</span><span class='info'>FEC Payload IDs</span><span>)</span></a>).
</p>
</blockquote><p>

</p>
<p>
Output:
</p>
<blockquote class="text">
<p>max_n:	Maximum number of encoding symbols generated for any
		source block.
</p>
</blockquote><p>

</p>
<p>
      Algorithm:
      </p>
<blockquote class="text">
<p>max_n = ceil(B / CR);
</p>
<p>if (max_n &gt; 2^^20) then return an error ("invalid code rate");
</p>
<p>(NB: if B has been defined as explained in
		<a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a>, this
		error should never happen)
</p>
</blockquote><p>

</p>
<a name="n-algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Determining the Number of Encoding Symbols of a Block (n)</h3>

<p>The following algorithm, also called "n-algorithm", MUST be used by the sender
and the receiver to determine the number of encoding symbols for a given block (n)
as a function of B, k, and max_n.

</p>
<p> Input:
</p>
<blockquote class="text">
<p>B:		Maximum source block length, for any source block.
		At a sender, <a class='info' href='#max_source_block_length'>Section&nbsp;5.2<span> (</span><span class='info'>Determining the Maximum Source Block Length (B)</span><span>)</span></a> MAY be used to
		determine its value.
		At a receiver, this value MUST be extracted from the received FEC OTI.
</p>
<p>k:		Current source block length.
		At a sender or receiver, the block partitioning algorithm MUST be used
		to determine its value.
</p>
<p>max_n:	Maximum number of encoding symbols generated for any
		source block.
		At a sender, <a class='info' href='#max_n-algorithm'>Section&nbsp;5.4<span> (</span><span class='info'>Determining the  Maximum Number of Encoding Symbols Generated for Any Source Block (max_n)</span><span>)</span></a> MAY be used to determine its value.
		At a receiver, this value MUST be extracted from the received FEC OTI.
</p>
</blockquote><p>

</p>
<p>
Output:
</p>
<blockquote class="text">
<p>n:		Number of encoding symbols generated for this source block.
</p>
</blockquote><p>

</p>
<p>
      Algorithm:
      </p>
<blockquote class="text">
<p>n = floor(k * max_n / B);
</p>
</blockquote><p>

</p>
<a name="encoding_symbol_group"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
Identifying the G Symbols of an Encoding Symbol Group</h3>

<p>
When multiple encoding symbols are sent in the same packet, the
FEC Payload ID information of the packet MUST refer to the first
encoding symbol.
It MUST then be possible to identify each symbol from this single FEC Payload
ID. To that purpose, the symbols of an Encoding Symbol Group (i.e.
packet):
</p>
<ul class="text">
<li>MUST all be either source symbols, or repair symbols.
	Therefore only source packets and repair packets are
	permitted, not mixed ones.
</li>
<li>are identified by a function, sender(resp. receiver)_find_ESIs_of_group(),
	that takes as argument:
	
<ul class="text">
<li> for a sender, the index of the Encoding Symbol Group
	(i.e., packet) that the application wants to create,
</li>
<li> for a receiver, the ESI information contained in the
	FEC Payload ID.
</li>
</ul>
	and returns a list of G Encoding Symbol IDs.
	In case of a source packet, the G Encoding Symbol IDs are
	chosen consecutively, by incrementing the ESI.
	In case of a repair packet, the G repair symbols are
	chosen randomly, as explained below.
</li>
<li>are stored in sequence in the packet, without any padding.
	In other words, the last byte of the i-th symbol
	is immediately followed by the first byte of (i+1)-th symbol.
</li>
</ul><p>

</p>
<p>
The system must first be initialized by creating a random permutation
of the n-k indexes.
This initialization function MUST be called immediately after creating
the parity check matrix.
More precisely, since the PRNG seed is not re-initialized, no call to
the PRNG function must have happened between the time the parity check
matrix has been initialized and the time the following initialization
function is called.
This is true both at a sender and at a receiver.

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
int *txseqToID;
int *IDtoTxseq;

/*
 * Initialization function.
 * Warning: use only when G &gt; 1.
 */
void
initialize_tables ()
{
    int i;
    int randInd;
    int backup;

    txseqToID = malloc((n-k) * sizeof(int));
    IDtoTxseq = malloc((n-k) * sizeof(int));
    /* initialize the two tables that map ID
     * (i.e., ESI-k) to/from TxSequence. */
    for (i = 0; i &lt; n - k; i++) {
        IDtoTxseq[i] = i;
        txseqToID[i] = i;
    }
    /* now randomize everything */
    for (i = 0; i &lt; n - k; i++) {
        randInd = rand(n - k);
        backup  = IDtoTxseq[i];
        IDtoTxseq[i] = IDtoTxseq[randInd];
        IDtoTxseq[randInd] = backup;
        txseqToID[IDtoTxseq[i]] =  i;
        txseqToID[IDtoTxseq[randInd]] = randInd;
    }
    return;
}
</pre></div><p>


</p>
<p>
It is then possible, at the sender, to determine the sequence of
G Encoding Symbol IDs that will be part of the group.

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
/*
 * Determine the sequence of ESIs for the packet under construction
 * at a sender.
 * Warning: use only when G &gt; 1.
 * PktIdx (IN):  index of the packet, in
 *               {0..ceil(k/G)+ceil((n-k)/G)} range
 * ESIs[] (OUT): list of ESIs for the packet
 */
void
sender_find_ESIs_of_group (int      PktIdx,
                           ESI_t    ESIs[])
{
    int i;

    if (PktIdx &lt; nbSourcePkts) {
        /* this is a source packet */
        ESIs[0] = PktIdx * G;
        for (i = 1; i &lt; G; i++) {
                ESIs[i] = (ESIs[0] + i) % k;
        }
    } else {
        /* this is a repair packet */
        for (i = 0; i &lt; G; i++) {
            ESIs[i] =
                k +
                txseqToID[(i + (PktIdx - nbSourcePkts) * G)
                          % (n - k)];
        }
    }
    return;
}
</pre></div><p>


</p>
<p>
Similarly, upon receiving an Encoding Symbol Group (i.e., packet),
a receiver can determine the sequence of G Encoding Symbol IDs
from the first ESI, esi0, that is contained in the FEC Payload ID.

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
/*
 * Determine the sequence of ESIs for the packet received.
 * Warning: use only when G &gt; 1.
 * esi0 (IN):  : ESI contained in the FEC Payload ID
 * ESIs[] (OUT): list of ESIs for the packet
 */
void
receiver_find_ESIs_of_group (ESI_t    esi0,
                             ESI_t    ESIs[])
{
    int i;

    if (esi0 &lt; k) {
        /* this is a source packet */
        ESIs[0] = esi0;
        for (i = 1; i &lt; G; i++) {
            ESIs[i] = (esi0 + i) % k;
        }
    } else {
        /* this is a repair packet */
        for (i = 0; i &lt; G; i++) {
            ESIs[i] =
                k +
                txseqToID[(i + IDtoTxseq[esi0 - k])
                          % (n - k)];
        }
    }
}
</pre></div><p>


</p>
<a name="prng"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.7"></a><h3>5.7.&nbsp;
Pseudo Random Number Generator</h3>

<p>
The FEC Encoding IDs 3 and 4 rely on a pseudo-random number
generator (PRNG) that must be fully specified, in particular in order
to enable the receivers and the senders to build the same parity
check matrix.

</p>
<p>
The minimal standard generator <a class='info' href='#PM88'>[PM88]<span> (</span><span class='info'>Park, S. and K. Miller, &ldquo;Random Number Generators: Good Ones are Hard to Find,&rdquo; 1988.</span><span>)</span></a> MUST be used.
It defines a simple multiplicative congruential algorithm: Ij+1 = A * Ij
(modulo M), with the following choices: A = 7^^5 = 16807 and
M = 2^^31 - 1 = 2147483647.
Several implementations of this PRNG are known and discussed in
the literature. All of them provide the same sequence of pseudo
random numbers. A validation criteria of such a PRNG is the following:
if seed = 1, then the 10,000th value returned MUST be equal to 1043618065.

</p>
<p>
An optimized implementation of this algorithm, using only 32 bit mathematics
which does not require any division, is provided, as an example,
in <a class='info' href='#prng_example'>Appendix&nbsp;A<span> (</span><span class='info'>Pseudo Random Number Generator Example Implementation (Informative Only)</span><span>)</span></a>. Yet any other implementation of the
PRNG algorithm that matches the above validation criteria is appropriate.

</p>
<p>
This PRNG produces a 31 bit value between 1 and 0x7FFFFFFE (2^^31-2) inclusive.
When it is desired to scale the pseudo random number between 0 and maxv-1
inclusive, one must keep the most significant bits of the value returned by the
PRNG (the least significant bits are known to be less random and modulo based
solutions should be avoided <a class='info' href='#PTVF92'>[PTVF92]<span> (</span><span class='info'>Press, W., Teukolsky, S., Vetterling, W., and B. Flannery, &ldquo;Numerical Recipies in C; Second Edition,&rdquo; 1992.</span><span>)</span></a>).
The following algorithm MUST be used:

</p>
<p> Input:
</p>
<blockquote class="text">
<p>raw_value:	random integer generated by the inner PRNG algorithm,
		between 1 and 0x7FFFFFFE (2^^31-2) inclusive.
</p>
<p>maxv:	upper bound used during the scaling operation.
</p>
</blockquote><p>
Output:
</p>
<blockquote class="text">
<p>scaled_value: random integer between 0 and maxv-1 inclusive.
</p>
</blockquote><p>
Algorithm:
</p>
<blockquote class="text">
<p>scaled_value = (unsigned long) ((double)maxv * (double)raw_value / (double)0x7FFFFFFF);
</p>
<p>(NB: the above C type casting to unsigned long is equivalent to using floor() with positive
	floating point values)
</p>
</blockquote><p>

</p>
<a name="ldpc_staircase"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Full Specification of the LDPC-Staircase Scheme</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
General</h3>

<p>The LDPC-Staircase scheme is identified by the Fully-Specified FEC Encoding ID 3.

</p>
<p>
The PRNG used by the LDPC-Staircase scheme must be initialized by a seed.
This PRNG seed is an instance-specific FEC OTI attribute
(<a class='info' href='#scheme_specific_elt'>Section&nbsp;4.2.3<span> (</span><span class='info'>Scheme-Specific Elements</span><span>)</span></a>).

</p>
<a name="staircase_matrix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Parity Check Matrix Creation</h3>

<p>
The LDPC-Staircase matrix can be divided into two parts: 
the left side of the matrix defines in which equations the source symbols
are involved;
the right side of the matrix defines in which equations the repair symbols
are involved.

</p>
<p>
The left side is generated with the following algorithm:

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   /* initialize a list of all possible choices in order to
    * guarantee a homogeneous "1" distribution */
   for (h = 3*k-1; h &gt;= 0; h--) {
       u[h] = h % (n-k);
   }
   /* left limit within the list of possible choices, u[] */
   t = 0;

   for (j = 0; j &lt; k; j++) { /* for each source symbol column */
       for (h = 0; h &lt; 3; h++) { /* add 3 "1s" */
           /* check that valid available choices remain */
           for (i = t; i &lt; 3*k &amp;&amp; matrix_has_entry(u[i], j); i++);

           if (i &lt; 3*k) {
               /* choose one index within the list of possible
                * choices */
               do {
                   i = t + rand(3*k-t);
               } while (matrix_has_entry(u[i], j));
               matrix_insert_entry(u[i], j);

               /* replace with u[t] which has never been chosen */
               u[i] = u[t];
               t++;
           } else {
               /* no choice left, choose one randomly */
               do {
                   i = rand(n-k);
               } while (matrix_has_entry(i, j));
               matrix_insert_entry(i, j);
           }
       }
   }

   /* Add extra bits to avoid rows with less than two "1s".
    * This is needed when the code rate is smaller than 2/5. */
   for (i = 0; i &lt; n-k; i++) { /* for each row */
       if (degree_of_row(i) == 0) {
           j = rand(k);
           matrix_insert_entry(i, j);
       }
       if (degree_of_row(i) == 1) {
           do {
               j = rand(k);
           } while (matrix_has_entry(i, j));
           matrix_insert_entry(i, j);
       }
   }
</pre></div><p>


The right side (the staircase) is generated by the following algorithm:

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   matrix_insert_entry(0, k);    /* first row */
   for (i = 1; i &lt; n-k; i++) {   /* for the following rows */
       matrix_insert_entry(i, k+i);   /* identity */
       matrix_insert_entry(i, k+i-1); /* staircase */
   }
</pre></div><p>


</p>
<p>
Note that just after creating this parity check matrix, when
encoding symbol groups are used (i.e., G &gt; 1), the
function initializing the two random permutation tables 
(<a class='info' href='#encoding_symbol_group'>Section&nbsp;5.6<span> (</span><span class='info'>Identifying the G Symbols of an Encoding Symbol Group</span><span>)</span></a>) MUST be called.
This is true both at a sender and at a receiver.

</p>
<a name="encoding_staircase"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Encoding</h3>

<p>
Thanks to the staircase matrix, repair symbol creation is straightforward:
each repair symbol is equal to the sum of all source symbols in the
associated equation, plus the previous repair symbol (except for the first repair symbol).
Therefore encoding MUST follow the natural repair symbol order:
start with the first repair symbol, and generate repair symbol with
ESI i before symbol with ESI i+1.

</p>
<a name="decoding_staircase"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Decoding</h3>

<p>
Decoding basically consists in solving a system of n-k linear equations
whose variables are the n source and repair symbols.
Of course, the final goal is to recover the value of the k source symbols only.

</p>
<p>
To that purpose, many techniques are possible.
One of them is the following trivial algorithm <a class='info' href='#ZP74'>[ZP74]<span> (</span><span class='info'>Zyablov, V. and M. Pinsker, &ldquo;Decoding Complexity of Low-Density Codes for Transmission in a Channel                  with Erasures,&rdquo; January-March&nbsp;1974.</span><span>)</span></a>:
given a set of linear equations, if one of them has only one
remaining unknown variable, then the value of this variable is
that of the constant term.
So, replace this variable by its value in all the remaining linear
equations and reiterate. The value of several variables can
therefore be found recursively.
Applied to LDPC FEC codes working over an erasure channel, the
parity check matrix defines a set of linear equations whose
variables are the source symbols and repair symbols.
Receiving or decoding a symbol is equivalent to having the
value of a variable.
<a class='info' href='#trivial_decoding'>Appendix&nbsp;B<span> (</span><span class='info'>Trivial Decoding Algorithm (Informative Only)</span><span>)</span></a> sketches a possible implementation
of this algorithm.

</p>
<p>
A Gaussian elimination (or any optimized derivative) is another
possible decoding technique. Hybrid solutions that start by using the
trivial algorithm above and finish with a Gaussian elimination are also
possible.

</p>
<p>
Because interoperability does not depend on the decoding algorithm used,
the current document does not recommend any particular technique.
This choice is left to the codec developer.

</p>
<p>
However choosing a decoding technique will have great practical impacts.
It will impact the erasure capabilities: a Gaussian elimination 
enables to solve the system with a smaller number of known symbols
compared to the trivial technique.
It will also impact the CPU load:
a Gaussian elimination requires more processing than the above trivial algorithm.
Depending on the target use case, the codec developer will
favor one feature or the other.

</p>
<a name="ldpc_triangle"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
 Full Specification of the LDPC-Triangle Scheme</h3>

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
General</h3>

<p> LDPC-Triangle is identified by the Fully-Specified FEC Encoding ID 4.
</p>
<p>
The PRNG used by the LDPC-Triangle scheme must be initialized by a seed.
This PRNG seed is an instance-specific FEC OTI attribute
(<a class='info' href='#scheme_specific_elt'>Section&nbsp;4.2.3<span> (</span><span class='info'>Scheme-Specific Elements</span><span>)</span></a>).

</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Parity Check Matrix Creation</h3>

<p>
The LDPC-Triangle matrix can be divided into two parts: 
the left side of the matrix defines in which equations the source symbols
are involved;
the right side of the matrix defines in which equations the repair symbols
are involved.

</p>
<p>
The left side is generated with the same algorithm as that of LDPC-Staircase
(<a class='info' href='#staircase_matrix'>Section&nbsp;6.2<span> (</span><span class='info'>Parity Check Matrix Creation</span><span>)</span></a>).

</p>
<p>
The right side (the triangle) is generated with the following algorithm:

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   matrix_insert_entry(0, k);    /* first row */
   for (i = 1; i &lt; n-k; i++) {   /* for the following rows */
       matrix_insert_entry(i, k+i);   /* identity */
       matrix_insert_entry(i, k+i-1); /* staircase */
       /* now fill the triangle */
       j = i-1;
       for (l = 0; l &lt; j; l++) { /* limit the # of "1s" added */
           j = rand(j);
           matrix_insert_entry(i, k+j);
       }
   }
</pre></div><p>


</p>
<p>
Note that just after creating this parity check matrix, when
encoding symbol groups are used (i.e., G &gt; 1), the
function initializing the two random permutation tables 
(<a class='info' href='#encoding_symbol_group'>Section&nbsp;5.6<span> (</span><span class='info'>Identifying the G Symbols of an Encoding Symbol Group</span><span>)</span></a>) MUST be called.
This is true both at a sender and at a receiver.

</p>
<a name="encoding_triangle"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Encoding</h3>

<p>
Here also repair symbol creation is straightforward: each repair
symbol of ESI i is equal to the sum of all source and repair symbols
(with ESI lower than i) in the associated equation.
Therefore encoding MUST follow the natural repair symbol order:
start with the first repair symbol, and generate repair symbol with
ESI i before symbol with ESI i+1.

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
Decoding</h3>

<p>
Decoding basically consists in solving a system of n-k linear equations,
whose variables are the n source and repair symbols.
Of course, the final goal is to recover the value of the k source symbols only.
To that purpose, many techniques are possible, as explained in
<a class='info' href='#decoding_staircase'>Section&nbsp;6.4<span> (</span><span class='info'>Decoding</span><span>)</span></a>.

</p>
<p>
Because interoperability does not depend on the decoding algorithm used,
the current document does not recommend any particular technique.
This choice is left to the codec implementer.

</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Problem Statement</h3>

<p>
A content delivery system is potentially subject to many attacks:
some of them target the network (e.g., to compromise the routing infrastructure,
by compromising the congestion control component), others target
the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior),
and finally some attacks target the content itself.
Since this document focuses on a FEC building block independently of any
particular CDP (even if ALC and NORM are two natural candidates), this
section only discusses the additional threats that an arbitrary CDP may be exposed
to when using this building block.

</p>
<p>
More specifically, several kinds of attacks exist:
</p>
<ul class="text">
<li> those that are meant to give access to a confidential content (e.g., in
	  case of a non-free content),
</li>
<li> those that try to corrupt the object being transmitted (e.g., to
	  inject malicious code within an object, or to prevent a receiver
	  from using an object),
</li>
<li> and those that try to compromise the receiver's behavior (e.g., by
	  making the decoding of an object computationally expensive).
</li>
</ul><p>
These attacks can be launched either against the data flow itself (e.g.,
by sending forged symbols) or against the FEC parameters that are
sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-of-band (e.g., in
a session description).

</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Attacks Against the Data Flow</h3>

<p>
First of all, let us consider the attacks against the data flow.

</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.1"></a><h3>8.2.1.&nbsp;
Access to Confidential Objects</h3>

<p>
Access control to the object being transmitted is typically provided by means
of encryption.
This encryption can be done over the whole object (e.g., by the content provider, before the
FEC encoding process), or be done on a packet per packet basis (e.g., when IPSec/ESP
is used <a class='info' href='#RFC4303'>[RFC4303]<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a>).
If access control is a concern, it is RECOMMENDED that one of these solutions be used.
Even if we mention these attacks here, they are not related nor facilitated by
the use of FEC.

</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2.2"></a><h3>8.2.2.&nbsp;
Content Corruption</h3>

<p>
Protection against corruptions (e.g., after sending forged packets) is achieved
by means of a content integrity verification/sender authentication scheme.
This service can be provided at the object level, but in that case a receiver
has no way to identify which symbol(s) is(are) corrupted if the object is detected
as corrupted.
This service can also be provided at the packet level. In this case, after 
removing all forged packets, the object may be in some case recovered.
Several techniques can provide this source authentication/content integrity
service:
</p>
<ul class="text">
<li> at the object level, the object MAY be digitally signed (with public key
  cryptography), for instance by using RSASSA-PKCS1-v1_5 <a class='info' href='#RFC3447'>[RFC3447]<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a>.
  This signature enables a receiver to check the object integrity, once this latter has
  been fully decoded. Even if digital signatures are computationally expensive,
  this calculation occurs only once per object, which is usually acceptable;
</li>
<li> at the packet level, each packet can be digitally signed. A major limitation is
  the high computational and transmission overheads that this solution requires
  (unless Elliptic Curve Cryptography (ECC) is used).
  To avoid this problem, the signature may span a set of symbols (instead of a
  single one) in order to amortize the signature calculation.
  But if a single symbol is missing, the integrity of the whole set cannot be checked;
</li>
<li> at the packet level, a Group Message Authentication Code (MAC) <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>
  scheme can be used, for instance by using HMAC-SHA-1 with a secret key shared by all
  the group members, senders and receivers.
  This technique creates a cryptographically secured (thanks to the secret key)
  digest of a packet that is sent along with the packet.
  The Group MAC scheme  does not create prohibitive processing load nor transmission
  overhead, but it has a major limitation: it only provides a group authentication/integrity
  service since all group members share the same secret group key, which means that each
  member can send a forged packet. It is therefore restricted to situations where
  group members are fully trusted (or in association with another technique as a
  pre-check);
</li>
<li> at the packet level, TESLA <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA): 						Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a> is a very attractive
  and efficient solution that is robust to losses, provides a true authentication/integrity
  service, and does not create any prohibitive processing load or transmission overhead.
  Yet checking a packet requires a small delay (a second or more) after its reception;
</li>
</ul><p>

</p>
<p>
Techniques relying on public key cryptography (digital signatures and TESLA during
the bootstrap process, when used) require that public keys be securely associated
to the entities. This can be achieved by a Public Key Infrastructure (PKI), or by a
PGP Web of Trust, or by pre-distributing the public keys of each group member.

</p>
<p>
Techniques relying on symmetric key cryptography (group MAC) require that a
secret key be shared by all group members. This can be achieved by means of a
group key management protocol, or simply by pre-distributing the secret key
(but this manual solution has many limitations).

</p>
<p>
It is up to the developer and deployer, who know the security requirements and
features of the target application area, to define which solution is the most appropriate.
Nonetheless, in case there is any concern of the threat of object corruption, it is
RECOMMENDED that at least one of these techniques be used.

</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Attacks Against the FEC Parameters</h3>

<p>
Let us now consider attacks against the FEC parameters (or FEC OTI).
The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an FDT Instance
containing FEC OTI for the object) or out-of-band (e.g., in a session description).
Attacks on these FEC parameters can prevent the decoding of the associated object:
for instance modifying the B parameter will lead to a different block partitioning.

</p>
<p>
It is therefore RECOMMENDED that security measures be taken to guarantee the
FEC OTI integrity.
To that purpose, the packets carrying the FEC parameters sent in-band
in an EXT_FTI header extension SHOULD be protected by one of the
per-packet techniques described above: digital signature, group MAC, or TESLA.
When FEC OTI is contained in an FDT Instance, this object SHOULD be protected,
for instance by digitally signing it with XML digital signatures <a class='info' href='#RFC3275'>[RFC3275]<span> (</span><span class='info'>Eastlake, D., Reagle, J., and D. Solo, &ldquo;(Extensible Markup Language) XML-Signature Syntax and Processing,&rdquo; March&nbsp;2002.</span><span>)</span></a>.
Finally, when FEC OTI is sent out-of-band (e.g., in a session description)
this latter SHOULD be protected, for instance by digitally signing it.

</p>
<p>
The same considerations concerning the key management aspects apply here also.

</p>
<a name="iana-cons"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>
Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration.
For general guidelines on IANA considerations as they
apply to this document, see <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.

</p>
<p>
This document assigns the Fully-Specified FEC Encoding ID 3 
under the "ietf:rmt:fec:encoding" name-space to "LDPC Staircase Codes".

</p>
<p>
This document assigns the Fully-Specified FEC Encoding ID 4
under the "ietf:rmt:fec:encoding" name-space to "LDPC Triangle Codes".

</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgments</h3>

<p><a class='info' href='#n-algorithm'>Section&nbsp;5.5<span> (</span><span class='info'>Determining the Number of Encoding Symbols of a Block (n)</span><span>)</span></a> is derived from a previous Internet-Draft,
and we would like to thank S. Peltotalo and J. Peltotalo for their
contribution.
We would also like to thank Pascal Moniot, Laurent Fazio,
Aurelien Francillon, Shao Wenjian, Brian Carpenter, Magnus Westerlund, and
Alfred Hoenes for their comments.
</p>
<p>Last but not least, the authors are grateful to Radford M. Neal (University of Toronto)
whose LDPC software (http://www.cs.toronto.edu/~radford/ldpc.software.html)
inspired this work.

</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, BCP&nbsp;14, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5052">[RFC5052]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>,&rdquo; RFC&nbsp;5052, August&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3453">[RFC3453]</a></td>
<td class="author-text">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="http://tools.ietf.org/html/rfc3453">The Use of Forward Error Correction (FEC) in Reliable Multicast</a>,&rdquo; RFC&nbsp;3453, December&nbsp;2002.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ZP74">[ZP74]</a></td>
<td class="author-text">Zyablov, V. and M. Pinsker, &ldquo;Decoding Complexity of Low-Density Codes for Transmission in a Channel
                 with Erasures,&rdquo; &nbsp;Translated from Problemy Peredachi Informatsii, Vol.10, No. 1, pp.15-28, January-March&nbsp;1974.</td></tr>
<tr><td class="author-text" valign="top"><a name="RN04">[RN04]</a></td>
<td class="author-text">Roca, V. and C. Neumann, &ldquo;Design, Evaluation and Comparison of Four
		Large Block FEC Codecs: LDPC, LDGM, LDGM-Staircase and LDGM-Triangle, Plus
		a Reed-Solomon Small Block FEC Codec,&rdquo; &nbsp;INRIA Research Report RR-5225, June&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="NRFF05">[NRFF05]</a></td>
<td class="author-text">Neumann, C., Roca, V., Francillon, A., and D. Furodet, &ldquo;Impacts of Packet Scheduling and Packet Loss Distribution on FEC Performances: Observations and Recommendations,&rdquo; &nbsp;ACM CoNEXT'05 Conference, Toulouse, France
		(an extended version is available as INRIA Research Report RR-5578), October&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="LDPC-codec">[LDPC-codec]</a></td>
<td class="author-text">Roca, V., Neumann, C., Cunche, M., and J. Laboure, &ldquo;LDPC-Staircase/LDPC-Triangle Codec Reference Implementation,&rdquo; &nbsp;INRIA Rhone-Alpes and STMicroelectronics, http://planete-bcast.inrialpes.fr/.</td></tr>
<tr><td class="author-text" valign="top"><a name="MK03">[MK03]</a></td>
<td class="author-text">MacKay, D., &ldquo;Information Theory, Inference and Learning Algorithms,&rdquo; Cambridge University Press,&nbsp;ISBN: 0-521-64298-1, 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="PM88">[PM88]</a></td>
<td class="author-text">Park, S. and K. Miller, &ldquo;Random Number Generators: Good Ones are Hard to Find,&rdquo; &nbsp;Communications of the ACM, Vol. 31, No. 10, pp.1192-1201, 1988.</td></tr>
<tr><td class="author-text" valign="top"><a name="CA90">[CA90]</a></td>
<td class="author-text">Carta, D., &ldquo;Two Fast Implementations of the Minimal Standard Random Number Generator,&rdquo; &nbsp;Communications of the ACM, Vol. 33, No. 1, pp.87-88, January&nbsp;1990.</td></tr>
<tr><td class="author-text" valign="top"><a name="PTVF92">[PTVF92]</a></td>
<td class="author-text">Press, W., Teukolsky, S., Vetterling, W., and B. Flannery, &ldquo;Numerical Recipies in C; Second Edition,&rdquo; Cambridge University Press,&nbsp;ISBN: 0-521-43108-5, 1992.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-pi-alc-revised">[draft-ietf-rmt-pi-alc-revised]</a></td>
<td class="author-text">Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; &nbsp;draft-ietf-rmt-pi-alc-revised-04.txt (work in progress), February&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-pi-norm-revised">[draft-ietf-rmt-pi-norm-revised]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; &nbsp;draft-ietf-rmt-pi-norm-revised-05.txt (work in progress), March&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="draft-ietf-rmt-flute-revised">[draft-ietf-rmt-flute-revised]</a></td>
<td class="author-text">Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; &nbsp;draft-ietf-rmt-flute-revised-05.txt (work in progress), October&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3447">[RFC3447]</a></td>
<td class="author-text">Jonsson, J. and B. Kaliski, &ldquo;<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>,&rdquo; RFC&nbsp;3447, February&nbsp;2003 (<a href="ftp://ftp.isi.edu/in-notes/rfc3447.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text">&ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4082">[RFC4082]</a></td>
<td class="author-text">&ldquo;<a href="http://tools.ietf.org/html/rfc4082">Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
						Multicast Source Authentication Transform Introduction</a>,&rdquo; RFC&nbsp;4082, June&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3275">[RFC3275]</a></td>
<td class="author-text">Eastlake, D., Reagle, J., and D. Solo, &ldquo;<a href="http://tools.ietf.org/html/rfc3275">(Extensible Markup Language) XML-Signature Syntax and Processing</a>,&rdquo; RFC&nbsp;3275, March&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3275.txt">TXT</a>).</td></tr>
</table>

<a name="prng_example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Pseudo Random Number Generator Example Implementation (Informative Only)</h3>

<p>
The following is an implementation of the minimal standard generator
defined in <a class='info' href='#prng'>Section&nbsp;5.7<span> (</span><span class='info'>Pseudo Random Number Generator</span><span>)</span></a> that scales the result between 0 and maxv-1 inclusive.
It uses the Park and Miller algorithm <a class='info' href='#PM88'>[PM88]<span> (</span><span class='info'>Park, S. and K. Miller, &ldquo;Random Number Generators: Good Ones are Hard to Find,&rdquo; 1988.</span><span>)</span></a> with the optimization
suggested by D. Carta in <a class='info' href='#CA90'>[CA90]<span> (</span><span class='info'>Carta, D., &ldquo;Two Fast Implementations of the Minimal Standard Random Number Generator,&rdquo; January&nbsp;1990.</span><span>)</span></a>.
The inner algorithm relies on 32 bit mathematics only and does not require any division.

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
unsigned long           seed;

/*
 * Initialize the PRNG with a seed between
 * 1 and 0x7FFFFFFE (i.e., 2^^31-2) inclusive.
 */
void srand (unsigned long s)
{
        if ((s &gt; 0) &amp;&amp; (s &lt; 0x7FFFFFFF))
                seed = s;
        else
                exit(-1);
}

/*
 * Returns a random integer in [0; maxv-1]
 * Derived from rand31pmc, Robin Whittle,
 * September 20th, 2005.
 * http://www.firstpr.com.au/dsp/rand31/
 *      16807           multiplier constant (7^^5)
 *      0x7FFFFFFF      modulo constant (2^^31-1)
 * The inner PRNG produces a value between 1 and
 * 0x7FFFFFFE (2^^31-2) inclusive.
 * This value is then scaled between 0 and maxv-1
 * inclusive.
 */
unsigned long
rand (unsigned long maxv)
{
        unsigned long   hi, lo;

        lo = 16807 * (seed &amp; 0xFFFF);
        hi = 16807 * (seed &gt;&gt; 16);  /* binary shift to right */
        lo += (hi &amp; 0x7FFF) &lt; &lt; 16; /* binary shift to left */
        lo += hi &gt;&gt; 15;
        if (lo &gt; 0x7FFFFFFF)
                lo -= 0x7FFFFFFF;
        seed = lo;
        /* don't use modulo, least significant bits are less random
         * than most significant bits [PTVF92] */
        return ((unsigned long)
                ((double)maxv * (double)seed / (double)0x7FFFFFFF));
}
</pre></div><p>


</p>
<a name="trivial_decoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Trivial Decoding Algorithm (Informative Only)</h3>

<p>
A trivial decoding algorithm is sketched below (please see <a class='info' href='#LDPC-codec'>[LDPC&#8209;codec]<span> (</span><span class='info'>Roca, V., Neumann, C., Cunche, M., and J. Laboure, &ldquo;LDPC-Staircase/LDPC-Triangle Codec Reference Implementation,&rdquo; .</span><span>)</span></a>
for the details omitted here):

</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  Initialization: allocate a table partial_sum[n-k] of buffers, each
                  buffer being of size the symbol size. There's one
                  entry per equation since the buffers are meant to
                  store the partial sum of each equation; Reset all
                  the buffers to zero;

  /*
   * For each newly received or decoded symbol, try to make progress
   * in the decoding of the associated source block.
   * NB: in case of a symbol group (G&gt;1), this function is called for
   * each symbol of the received packet.
   * NB: a callback function indicates to the caller that new symbol(s)
   *     has(have) been decoded.
   * new_esi  (IN):  ESI of the new symbol received or decoded
   * new_symb (IN):  Buffer of the new symbol received or decoded
   */
  void
  decoding_step(ESI_t     new_esi,
                symbol_t  *new_symb)
  {
      If (new_symb is an already decoded or received symbol) {
          Return;        /* don't waste time with this symbol */
      }

      If (new_symb is the last missing source symbol) {
          Remember that decoding is finished;
          Return;        /* work is over now... */
      }

      Create an empty list of equations having symbols decoded
      during this decoding step;

      /*
       * First add this new symbol to the partial sum of all the
       * equations where the symbol appears.
       */
      For (each equation eq in which new_symb is a variable and
           having more than one unknown variable) {

          Add new_symb to partial_sum[eq];

          Remove entry(eq, new_esi) from the H matrix;

          If (the new degree of equation eq == 1) {
              /* a new symbol can be decoded, remember the
               * equation */
              Append eq to the list of equations having symbols
              decoded during this decoding step;
          }
      }

      /*
       * Then finish with recursive calls to decoding_step() for each
       * newly decoded symbol.
       */
      For (each equation eq in the list of equations having symbols
           decoded during this decoding step) {

          /*
           * Because of the recursion below, we need to check that
           * decoding is not finished, and that the equation is
           * __still__ of degree 1
           */
          If (decoding is finished) {
              break;        /* exit from the loop */
          }

          If ((degree of equation eq == 1) {
              Let dec_esi be the ESI of the newly decoded symbol in
              equation eq;

              Remove entry(eq, dec_esi);

              Allocate a buffer, dec_symb, for this symbol and
              copy partial_sum[eq] to dec_symb;

              Inform the caller that a new symbol has been
              decoded via a callback function;

              /* finally, call this function recursively */
              decoding_step(dec_esi, dec_symb);
          }
      }

      Free the list of equations having symbols decoded;
      Return;
  }
</pre></div><p>


</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vincent Roca</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">INRIA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">655, av. de l'Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Inovallee; Montbonnot</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ST ISMIER cedex  38334</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vincent.roca@inria.fr">vincent.roca@inria.fr</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/people/roca/">http://planete.inrialpes.fr/people/roca/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Christoph Neumann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">12, bd de Metz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rennes  35700</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:christoph.neumann@thomson.net">christoph.neumann@thomson.net</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/people/chneuman/">http://planete.inrialpes.fr/people/chneuman/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David Furodet</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">STMicroelectronics</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">12, Rue Jules Horowitz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BP217</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Grenoble Cedex  38019</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:david.furodet@st.com">david.furodet@st.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.st.com/">http://www.st.com/</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
