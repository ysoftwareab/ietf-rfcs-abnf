<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>RTCWeb Offer/Answer Protocol (ROAP)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Requirements and Design Goals">
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology">
<link href="#rfc.section.4" rel="Chapter" title="4 Protocol Overview">
<link href="#rfc.section.5" rel="Chapter" title="5 Semantics &amp; Syntax">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Reliability Model">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Common Fields">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Session IDs">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Seq">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Session Tokens">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 Response Tokens">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Media Setup">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 OFFER Message">
<link href="#rfc.section.5.3.1.1" rel="Chapter" title="5.3.1.1 Offerer Behavior">
<link href="#rfc.section.5.3.1.2" rel="Chapter" title="5.3.1.2 Answerer Behavior">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 ANSWER">
<link href="#rfc.section.5.3.2.1" rel="Chapter" title="5.3.2.1 moreComing Flag">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 OK">
<link href="#rfc.section.5.3.4" rel="Chapter" title="5.3.4 ERROR">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Changing Media Parameters">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Conflicting OFFERS (glare)">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Premature OFFER">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Notification of Media Termination">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Errors">
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 NOMATCH">
<link href="#rfc.section.5.6.2" rel="Chapter" title="5.6.2 TIMEOUT">
<link href="#rfc.section.5.6.3" rel="Chapter" title="5.6.3 REFUSED">
<link href="#rfc.section.5.6.4" rel="Chapter" title="5.6.4 CONFLICT">
<link href="#rfc.section.5.6.5" rel="Chapter" title="5.6.5 DOUBLECONFLICT">
<link href="#rfc.section.5.6.6" rel="Chapter" title="5.6.6 FAILED">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Companion APIs">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Capabilities">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Hints">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Stats">
<link href="#rfc.section.8" rel="Chapter" title="8 Relationship with SIP &amp; Jingle">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgments">
<link href="#rfc.section.11" rel="Chapter" title="11 Open Issues">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document describes an protocol used to negotiate media between browsers or other compatible devices. This protocol provides the state machinery needed to implement the offer/answer model (RFC 3264), and defines the semantics and necessary attributes of messages that must be exchanged. The protocol uses an abstract transport in that it does not actually define how these messages are exchanged. Rather, such exchanges are handled through web-based transports like HTTP or WebSockets. The protocol focuses solely on media negotiation and does not handle call control, call processing, or other functions." />
  <meta name="description" content="This document describes an protocol used to negotiate media between browsers or other compatible devices. This protocol provides the state machinery needed to implement the offer/answer model (RFC 3264), and defines the semantics and necessary attributes of messages that must be exchanged. The protocol uses an abstract transport in that it does not actually define how these messages are exchanged. Rather, such exchanges are handled through web-based transports like HTTP or WebSockets. The protocol focuses solely on media negotiation and does not handle call control, call processing, or other functions." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">C. Jennings</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">J.R. Rosenberg</td>
</tr>
<tr>
<td class="left">Expires: May 03, 2012</td>
<td class="right">jdrosen.net</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Uberti</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">R. Jesup</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Mozilla</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 31, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">RTCWeb Offer/Answer Protocol (ROAP)<br />
  <span class="filename">draft-jennings-rtcweb-signaling-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an protocol used to negotiate media between browsers or other compatible devices. This protocol provides the state machinery needed to implement the offer/answer model (RFC 3264), and defines the semantics and necessary attributes of messages that must be exchanged. The protocol uses an abstract transport in that it does not actually define how these messages are exchanged. Rather, such exchanges are handled through web-based transports like HTTP or WebSockets. The protocol focuses solely on media negotiation and does not handle call control, call processing, or other functions.</p>
<p>The IETF has been notified of intellectual property rights claimed in regard to some or all of the specification contained in this document.  For more information consult the online list of claimed rights.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 03, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Requirements and Design Goals</a>
</li>
<li>3.   <a href="#rfc.section.3">Terminology</a>
</li>
<li>4.   <a href="#rfc.section.4">Protocol Overview</a>
</li>
<li>5.   <a href="#rfc.section.5">Semantics &amp; Syntax</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Reliability Model</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Common Fields</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">Session IDs</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Seq</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Session Tokens</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">Response Tokens</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Media Setup</a>
</li>
<li>5.3.1.   <a href="#rfc.section.5.3.1">OFFER Message</a>
</li>
<li>5.3.1.1.   <a href="#rfc.section.5.3.1.1">Offerer Behavior</a>
</li>
<li>5.3.1.2.   <a href="#rfc.section.5.3.1.2">Answerer Behavior</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">ANSWER</a>
</li>
<li>5.3.2.1.   <a href="#rfc.section.5.3.2.1">moreComing Flag</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">OK</a>
</li>
<li>5.3.4.   <a href="#rfc.section.5.3.4">ERROR</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Changing Media Parameters</a>
</li>
<li>5.4.1.   <a href="#rfc.section.5.4.1">Conflicting OFFERS (glare)</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Premature OFFER</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Notification of Media Termination</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Errors</a>
</li>
<li>5.6.1.   <a href="#rfc.section.5.6.1">NOMATCH</a>
</li>
<li>5.6.2.   <a href="#rfc.section.5.6.2">TIMEOUT</a>
</li>
<li>5.6.3.   <a href="#rfc.section.5.6.3">REFUSED</a>
</li>
<li>5.6.4.   <a href="#rfc.section.5.6.4">CONFLICT</a>
</li>
<li>5.6.5.   <a href="#rfc.section.5.6.5">DOUBLECONFLICT</a>
</li>
<li>5.6.6.   <a href="#rfc.section.5.6.6">FAILED</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Companion APIs</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Capabilities</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Hints</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Stats</a>
</li>
<li>8.   <a href="#rfc.section.8">Relationship with SIP &amp; Jingle</a>
</li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgments</a>
</li>
<li>11.   <a href="#rfc.section.11">Open Issues</a>
</li>
<li>12.   <a href="#rfc.references">References</a>
</li>
<li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This specification defines a protocol that allows an RTCWeb browser to exchange information to control the set up of media to another browser or device. The scope of this protocol is limited to functionality required for the setup and negotiation of media and the associated transports, referred to as media control. The protocol defines the minimum set of messages and state machinery necessary to implement the offer/answer model as defined in <a href="#RFC3264">[RFC3264]</a>. The offer answer model specifies rules for the bilateral exchange of Session Description Protocol (SDP) messages <a href="#RFC4566">[RFC4566]</a> for creation of media streams.</p>
<p id="rfc.section.1.p.2">The protocol specified here defines the state machines, semantic behaviors, and messages that are exchanged between instances of the state machines. However, it does not specify the actual on the wire transport of these messages. Rather, it assumes that the implementation of this protocol would occur within the browser itself, and then browser APIs would allow the application's JavaScript to request creation of messages and insert messages into the state machine. The actual transfer of these messages would be the responsibility of the web application, and would utilize protocols such as HTTP and WebSockets. To facilitate implementation within a browser, messages are encoded in JSON <a href="#RFC4627">[RFC4627]</a>. This protocol, with appropriate selected transports, could also be implemented by a signalling gateway that converts ROAP to SIP or Jingle.</p>
<p id="rfc.section.1.p.3">This protocol is designed to be closely aligned with the PeerConnection API defined in the RTCWeb API<a href="#webrtc-api">[webrtc-api]</a> specification. It is important to note that while ROAP does not require what has been referred to as a low level API for media manipulation, ROAP does not prevent having a such an API as well and both styles of API could coexist and be used where appropriate.</p>
<p id="rfc.section.1.p.4">The protocol defined here does not provide any call control. Concepts like ringing of phones, user search, call forwarding, redirection, transfer, hold, and so on, are all the domain of call processing and are out of scope for this specification. It is assumed that the application running within the browser provides any call control based on the needs of the application, the scope of which is not a matter for standardization.</p>
<p id="rfc.section.1.p.5">Despite that fact that it has an abstract transport, ROAP is still a protocol. This means it has state machines, and it has rules governing the behavior of those state machines which guarantee that system operates properly based on any set of inputs. It is assumed that this state machinery is implemented in the browser and thus immutable by the application, which can then guarantee proper behavior regardless of the operation of the resident JavaScript. </p>
<p id="rfc.section.1.p.6">The protocol is designed to operate between two entities (browsers for example), which exchange messages "directly" - meaning that a message output by one entity is meant to be directly processed by the other entity without further modification. In practice, this means that a web server can treat ROAP messages as opaque and just shuffle them between browser instances. This allows for simple implementations.  However, more powerful applications can be built in which the web server or JavaScript can modify the messages in order to provide more complex features. As long as those modifications produce messages compliant to this specification, <a href="#RFC3264">SDP Offer/Answer</a> <cite title="NONE">[RFC3264]</cite>, <a href="#RFC4566">SDP</a> <cite title="NONE">[RFC4566]</cite>, <a href="#RFC5245">ICE</a> <cite title="NONE">[RFC5245]</cite> and any other dependencies, interoperability is still possible.</p>
<p id="rfc.section.1.p.7">This protocol is designed for two major use cases:</p>
<p></p>

<ul>
<li>Browser to browser</li>
<li>Browser to SIP device via a SIP gateway</li>
</ul>
<p id="rfc.section.1.p.9">In the browser to SIP use case, the gateway obviously needs to be somewhat more sophisticated. However, because this design is a small subset of the design space covered by SIP <a href="#RFC3261">[RFC3261]</a>, it is intended to be simple to translate to and from/SIP via a signalling gateway. Moreover, many of the elements in messages have clear mappings to elements in SIP messages, thus allowing simple, stateless translation.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Requirements and Design Goals</h1>
<p id="rfc.section.2.p.1">There has been extensive debate about the best architecture for RTCWeb signaling. To a great extent this decision is dictated by the requirements that the signaling mechanism is intended to fit. The protocol in this document was designed to minimize the amount of implementation effort required outside the browser and RTC-Web signaling gateways. This implies the following requirements:</p>
<p id="rfc.section.2.p.2">It should be possible to develop a simple browser to browser voice and video service in a small amount of code. In particular, it MUST be possible to implement a functional service such that:</p>
<p></p>

<ul>
<li>It's possible to build a web service that maintains only transaction state, not call state;</li>
<li>In the browser to browser case, the web server can simply pass protocol messages between the browser agents without examining or modifying them;</li>
<li>The service operates without needing to examine the details of the browser capabilities (e.g., new codecs should be automatically accommodated without modifying either the service or the associated JS.</li>
</ul>
<p></p>
<p id="rfc.section.2.p.5">It should be possible to implement a simple RTC-Web gateway that:</p>
<p></p>

<ul>
<li>Connects to legacy SIP devices ranging from multiscreen video phones to PSTN gateways;</li>
<li>Has a deterministic mapping between RTC-Web messages and SIP messages;</li>
<li>Permits the mechanical translation of messages without knowledge of the details of all the browser capabilities;</li>
<li>is only required to maintains transaction state, not call state (note is fine if an implementation want to maintain call state); and</li>
<li>Does not need to send or receive the media (unless also acting as a relay or a translator for codecs which are not jointly supported).</li>
</ul>
<p id="rfc.section.2.p.7">Finally it seems clear that SDP is too complicated to reinvent, so despite its manifest deficiencies we opt to take it as-is rather than trying to reinvent it.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Terminology</h1>
<p id="rfc.section.3.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.3.p.2">This draft uses the API and terminology described in <a href="#webrtc-api">[webrtc-api]</a>.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Protocol Overview</h1>
<p id="rfc.section.4.p.1">We start with a simple example. Consider the case where browser A wishes to setup up a media session with browser B. At the high level, A needs to communicate the following information:</p>
<p></p>

<ul>
<li>This is a new media session and not an update to a different session.</li>
<li>Here is A's SDP offer, including media parameters and ICE candidates.</li>
</ul>
<p id="rfc.section.4.p.3">The OFFER message is used to carry this information. For example, A might send B:</p>
<div id="#rfc.figure.1"></div>
<pre>
{
  "messageType":"OFFER",
  "offererSessionId":"13456789ABCDEF",
  "seq": 1,
  "sdp":"
v=0\n
o=- 2890844526 2890842807 IN IP4 192.0.2.1\n
s= \n
c=IN IP4 192.0.2.1\n
t=2873397496 2873404696\n
m=audio 49170 RTP/AVP 0"
}
</pre>
<p id="rfc.section.4.p.4">The messageType field indicates that this is an OFFER and the offererSessionId indicates the media session that this OFFER is associated with. B can tell that this is for a new media session because it contains a offererSessionId that he has not seen before. The sdp field contains the offer itself, which is just an ordinary SDP offer rendered as a string.</p>
<p id="rfc.section.4.p.5">If B elects to start a media session, B responds with an ANSWER message containing SDP, as shown below.</p>
<div id="#rfc.figure.2"></div>
<pre>
{
  "messageType":"ANSWER",
  "offererSessionId":"13456789ABCDEF",
  "answererSessionId":"abc1234356",
  "seq": 1,
  "sdp":"
v=0\n
o=- 2890844526 2890842807 IN IP4 192.0.2.3\n
s= \n
c=IN IP4 192.0.2.3\n
t=2873397496 2873404696\n
m=audio 49175 RTP/AVP 0"
}
</pre>
<p id="rfc.section.4.p.6">The contents of this message are more or less the same as those in the OFFER, except that B also includes a answererSessionId to uniquely identify the session from B's perspective. The combination of offererSessionId and answererSessionId uniquely identifies this session.</p>
<p id="rfc.section.4.p.7">Finally, in order to confirm that A has seen B's ANSWER, A responds with an OK message.</p>
<div id="#rfc.figure.3"></div>
<pre>
{
  "messageType":"OK",
  "offererSessionId":"13456789ABCDEF",
  "answererSessionId":"abc1234356",
  "seq": 1
}
</pre>
<p id="rfc.section.4.p.8">Note that all of these messages contain a seq field which contains a transaction sequence number. The seq field makes it possible to correlate messages which belong to the same transaction, as well as to detect duplicates, which is described later in section <a href="#sec-reliability">Section 5.1</a>.</p>
<p id="rfc.section.4.p.9">The messageType value of "OFFER" will always contain an SDP offer, and an object with a messageType value of "ANSWER" will always contain an SDP answer. The complete list of message types is defined in <a href="#sec-syntax">Section 5</a>. Only a small number of messages are permitted and much of the message set is devoted to error handling.</p>
<p id="rfc.section.4.p.10">In building web systems it is often useful for a request to contain some state that is passed back in future messages. This system includes two types of state: session state and request state. If a browser receives a message that contains state in a setSessionState attribute, any future messages it sends that have the same offererSessionId MUST include this state in a sessionState attribute. Similarly if a request contains an setResponseState attribute, that state MUST be included in any response to that request in a responseState attribute.</p>
<p id="rfc.section.4.p.11">Once a session has been set up, additional rounds of offer/answer can be sent using the OFFER/ANSWER/OK sequence. Note that the seq attribute makes it easy to differentiate these additional rounds from the initial exchange and from each other.</p>
<p id="rfc.section.4.p.12">At the point that one side which to end the session, it simply sends a SHUTDOWN message which is responded to with an OK response. A SHUTDOWN can be sent regardless of it any response has been received to the initial OFFER. The key purpose of the SHUTDOWN messages is to allow the other side to know they can clean up any state associated with the session.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sec-syntax" id="sec-syntax">Semantics &amp; Syntax</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec-reliability" id="sec-reliability">Reliability Model</a>
</h1>
<p id="rfc.section.5.1.p.1">ROAP messages are typically carried over a reliable transport (likely HTTP via XMLHttpRequest or WebSockets), so the chance of message loss is low (though non-zero), provided that the signaling service is up. However, the common web reliability and scaleability model is based on the principle that transactions are idempotent and that requests can just be discarded and will be retried. A retry of a transaction might happened if a given host was down and the DNS round robin approach wanted to move to the next server, or if a server was overloaded, or if there was a hiccup in the network. Web applications that want to work well need to deal with theses issues to get the advantages of the general web design pattern for scaleability and reliability. Because only the application knows what its internal reliability characteristics are, the JS application (and whatever associated servers it uses) are ultimately responsible for ensuring end-to-end delivery; the browser simply assumes that messages which are provided to the JS will be delivered eventually.  </p>
<p id="rfc.section.5.1.p.2">However, in order to maintain OFFER/ANSWER transaction state, the SDP state machine does need to understand when the far end has received an ANSWER if it caused an error or not.  To support this model, OFFER and ANSWER messages are acknowledged end to end with an ANSWER or OK however any retransmission need to be handled by the JS or whatever is providing the transport of the ROAP messages. The combination of the sessionID and seq allow the browser to detect and discard duplicate requests and to detect glare.  </p>
<p></p>

<dl>
<dt>NOTE:</dt>
<dd style="margin-left: 8">The split of the reliability model between the JS and browser is something where implementations are playing around with and trying to get some experience with what works best. This is an area that is highly likely to change as understanding of the implications evolves.</dd>
</dl>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Common Fields</h1>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#sec.session-id" id="sec.session-id">Session IDs</a>
</h1>
<p id="rfc.section.5.2.1.p.1">Each call is identified by a pair of session identifiers:</p>
<p></p>

<dl>
<dt>offererSessionId</dt>
<dd style="margin-left: 8">The offerer's half of the session ID (supplied in the OFFER)</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>answererSessionId</dt>
<dd style="margin-left: 8">The answerer's half of the session ID (supplied in the response to an OFFER)</dd>
</dl>
<p id="rfc.section.5.2.1.p.3">The session ID values MUST be generated so that they are globally unique. Thus, the combination of both sessionIds is itself globally unique. Session IDs never change for the duration of an media session.</p>
<p id="rfc.section.5.2.1.p.4">All messages MUST contain the "offererSessionId", and all messages other than OFFER or an error in response to an OFFER MUST contain both "offererSessionId" and "answererSessionId".</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> Seq</h1>
<p id="rfc.section.5.2.2.p.1">This is a sequence counter for the key requests that helps correlate responses to the correct request.</p>
<p id="rfc.section.5.2.2.p.2">This is a 32-bit unsigned integer. On each new OFFER (from either browser) it is incremented by one. The Seq of an OK or ANSWER is set to the same Seq that was used in the OFFER which caused it. When a PeerConnection objects originates a new session by sending an OFFER type message, it starts the Seq at 1.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">If browser A starts an OFFER/ANSWER/OK transaction with a seq of 1 to browser B, then later B initiates a second OFFER/ANSWER?/OK transaction, it will have a seq of 2.</dd>
</dl>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> Session Tokens</h1>
<p id="rfc.section.5.2.3.p.1">While session IDs serve to uniquely identify a session, it may be useful to allow one or another sides to offload state onto the other side (for instance to enable a stateless gateway). The "setSessionToken" and "sessionToken" fields are used for this purpose. When an implementation receives a message with a "setSessionToken" field, it MUST associate the field value with the session. For all future messages in the session MUST send the associated value in the "sessionToken" field (unless the session token is reset by another "setSessionToken" value). If no session token has yet been received, the "sessionToken" field MUST be omitted.</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> Response Tokens</h1>
<p id="rfc.section.5.2.4.p.1">In addition to tokens which persist for the life of a session, it is also possible to have tokens which are only valid for the lifetime of a given request/response pair. The "setResponseToken" and "responseToken" fields are used for this purpose.</p>
<p id="rfc.section.5.2.4.p.2">When an implementation responds to a message from the other side (e.g., supplies an answer to an offer, or replies to an answer with an OK), it MUST copy into the "responseToken" field any value found in a "setResponseToken" field in the message being responded to. If no "setResponseToken" field is present, then the "responseToken" field MUST be omitted.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> Media Setup</h1>
<p id="rfc.section.5.3.p.1">In order to initiate sending media between the browsers, the offerer sends an OFFER message. In order to accept the media, the answerer responds with an ANSWER message. A sample message flow for this is shown below:</p>
<div id="#rfc.figure.4"></div>
<pre>
participant OffererUA
participant OffererJS
participant AnswererJS
participant AnswererUA
OffererJS-&gt;OffererUA: peer=new PeerConnection();

OffererJS-&gt;OffererUA: peer-&gt;addStream();
OffererUA-&gt;OffererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: {"type":"OFFER", "sdp":"..."}
AnswererJS-&gt;AnswererUA: peer=new PeerConnection();
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
AnswererUA-&gt;AnswererJS: onconnecting();

AnswererUA-&gt;OffererUA: ICE starts checking 

note right of AnswererUA: User decides it is OK to send video 
AnswererJS-&gt;AnswererUA: peer-&gt;addStream();
AnswererUA-&gt;OffererUA: Media

AnswererUA-&gt;AnswererJS: sendSignalingChannel();
AnswererJS-&gt;OffererJS: {"type":"ANSWER","sdp":"..."}
OffererJS-&gt;OffererUA: peer-&gt;processSignalingMessage();
OffererUA-&gt;OffererJS: onaddstream();
OffererUA-&gt;AnswererUA: Media

AnswererUA-&gt;OffererUA: ICE Completes
AnswererUA-&gt;AnswererJS: onopen();
OffererUA-&gt;OffererJS: onopen();

OffererUA-&gt;OffererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: {"type":"OK" }
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
AnswererUA-&gt;AnswererJS: onaddstream();
            </pre>
<p id="rfc.section.5.3.p.2">The above figure shows a simple message flow for negotiating media:</p>
<p></p>

<ul>
<li>The offerer sends an OFFER to initiate the call;</li>
<li>At this point, ICE negotiation starts;</li>
<li>Once the browser authorizes sending media to the far side, the answerer sends an ANSWER containing the media parameters; and finally,</li>
<li>Once ICE is completed and an OK to the ANSWER is received, both sides know that media can flow.</li>
</ul>
<p id="rfc.section.5.3.p.4">The contents of each of these messages is detailed below.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> OFFER Message</h1>
<p id="rfc.section.5.3.1.p.1">The first OFFER message with a given offererSessionId is used to indicate the desire to start a media session.</p>
<h1 id="rfc.section.5.3.1.1">
<a href="#rfc.section.5.3.1.1">5.3.1.1.</a> Offerer Behavior</h1>
<p id="rfc.section.5.3.1.1.p.1">In order to start a new media session, a offerer constructs a new OFFER message with a fresh offererSessionId. The answererSessionId field MUST be empty. Like all SDP offers, the message MUST contain an "sdp" field with the offerer's offer.  It MUST also contain the tieBreaker field, containing a 32 bit random integer used for glare resolution as described in <a href="#sec.offer-glare">Section 5.4.1</a>.  </p>
<h1 id="rfc.section.5.3.1.2">
<a href="#rfc.section.5.3.1.2">5.3.1.2.</a> Answerer Behavior</h1>
<p id="rfc.section.5.3.1.2.p.1">A answerer can receive an OFFER in three cases:</p>
<p></p>

<ul>
<li>A new session (this is detected by seeing a new offererSessionId value);</li>
<li>A retransmit of a new OFFER (known offererSessionId, empty answererSessionId); or</li>
<li>A request to change media parameters (known offererSessionId, known answererSessionId, new seq value).</li>
</ul>
<p id="rfc.section.5.3.1.2.p.3">The first two situations are described in this section. The third case is described in <a href="#sec.change-media">Section 5.4</a>. Any other condition represents an alien packet and SHOULD be rejected with Error:NOMATCH</p>
<p id="rfc.section.5.3.1.2.p.4">If no media session exists with the given "offererSessionId" value, then this is a new media session. The answerer has three primary options:</p>
<p></p>

<ul>
<li>Reject the request, either silently with no response or with an Error:REFUSED message;</li>
<li>Reply to the OFFER message with a final ANSWER message; or <a href="#sec.ANSWER">Section 5.3.2</a>
</li>
<li>Send back a non final ANSWER message and then later respond with an final ANSWER.</li>
</ul>
<p id="rfc.section.5.3.1.2.p.6">In either of the latter two cases, the answerer performs the following steps:</p>
<p></p>

<ol>
<li>Generate a "answererSessionId" value;</li>
<li>Create some local call state (i.e., a PeerConnection object) and bind it to the "offererSessionId"/"answererSessionId" pair. All future messages on this session MUST then be delivered to that PeerConnection object;</li>
<li>Start ICE handshaking with the offerer; and finally,</li>
<li>Respond with a message containing an SDP answer in the "sdp" field. This will contain the answerer's (potentially with moreComing=true) media information and the ICE parameters.</li>
</ol>
<p id="rfc.section.5.3.1.2.p.8">If an OFFER is received that has already been received and responded to and the media session still exists, then the answerer MUST respond with the same message as before. If the session has been terminated in the meantime, then an Error:NOMATCH message SHOULD be sent.</p>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#sec.ANSWER" id="sec.ANSWER">ANSWER</a>
</h1>
<p id="rfc.section.5.3.2.p.1">The ANSWER message is used by the receiver of an OFFER message to indicate that the offer has been accepted. The ANSWER message MUST contain the answererSessionId for this media session and an sdp parameter containing ICE candidates and the final media parameters for the session (although of course these can be adjusted by a new OFFER/ANSWER exchange. See <a href="#sec.change-media">Section 5.4</a>). In addition, ANSWERs MAY contain the moreComing flag, as described below.  </p>
<h1 id="rfc.section.5.3.2.1">
<a href="#rfc.section.5.3.2.1">5.3.2.1.</a> moreComing Flag</h1>
<p id="rfc.section.5.3.2.1.p.1">This is a boolean flag that can only appear in an ANSWER and, if set to true, indicates that this answer is not the final answer that will be sent for the associated OFFER. If this flag is not present, it is assumed to be false.</p>
<p id="rfc.section.5.3.2.1.p.2">One motivating use case for moreComing is where an Agent wishes to respond immediately to an OFFER in order to start ICE checking before the user has provided authorization to send media. The Agent cannot send an ANSWER containing media information but can send ICE candidate. In this case, the Agent could send an ANSWER that had moreComing=true but that allowed ICE to start. Then later, when the user had authorized the media, the Agent could send an ANSWER with the moreComing flag=false that indicated this was the final media selection.</p>
<p id="rfc.section.5.3.2.1.p.3">To see why simply having multiple independent offers (as opposed to multiple answers for a single offer), consider the case where browser A requests video with B. When the A side that sent the initial OFFER gets an ANSWER that rejects the video, it may very well present a UI indication that there is no media. Five seconds later when browser B sends an OFFER requesting video, browser A may present a UI element that asks is OK to do the video that was just rejected. This results in a bad user experience and in the extreme can result in both sides always rejecting the other side's OFFER of video, then waiting for the user to authorize video that results in a new OFFER that is always rejected.</p>
<p id="rfc.section.5.3.2.1.p.4">It easier to be able to indicate that OFFER resulted in one valid ANSWER, but that the OFFER needs to be held open as other valid ANSWERS which would replace the current one. This stops the other side from generating new a new OFFER while this is taking place.  This is also needed to support a SIP gateway doing early media.</p>
<h1 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#sec.OK" id="sec.OK">OK</a>
</h1>
<p id="rfc.section.5.3.3.p.1">The OK message is used by the receiver of an ANSWER message to indicate that it has received the ANSWER message. It has no contents itself and is merely used to stop the retransmissions of the ANSWER.</p>
<h1 id="rfc.section.5.3.4">
<a href="#rfc.section.5.3.4">5.3.4.</a> <a href="#sec.ERROR" id="sec.ERROR">ERROR</a>
</h1>
<p id="rfc.section.5.3.4.p.1">The ERROR message is used to indicate that there has been an error. The contents and semantics of this message are defined in <a href="#sec.err">Section 5.6</a>.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#sec.change-media" id="sec.change-media">Changing Media Parameters</a>
</h1>
<p id="rfc.section.5.4.p.1">Once a call has been set up, it is common to want to adjust the media parameters, e.g., to add video to an audio-only call. This is also done with the OFFER/ANSWER/OK sequence of messages, though the details are slightly different.</p>
<p id="rfc.section.5.4.p.2">Either side may initiate a new OFFER/ANSWER exchange by sending an OFFER message. However, implementations MUST NOT attempt this for sessions which are still in active negotiation. Specifically, the offerer MUST NOT send a new OFFER until it has received the ANSWER, and the answerer MUST NOT send a new OFFER until it has received the OK indicating receipt of the ANSWER.</p>
<p id="rfc.section.5.4.p.3">A new OFFER MUST contain a complete set of media parameters describing the proposed new media configuration as well as a full set of ICE parameters. The recipient of a new OFFER on a valid connection MUST respond with an appropriate ANSWER message. However that message MAY refuse to accept the proposed new configuration. If the session has been terminated in the meantime, then an Error:NOMATCH message SHOULD be sent.</p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#sec.offer-glare" id="sec.offer-glare">Conflicting OFFERS (glare)</a>
</h1>
<p id="rfc.section.5.4.1.p.1">Because a change of media parameters may be initiated by either side, there is a potential for the change requests to occur simultaneously (i.e., "glare"). This document defines a glare handling procedure that results in immediate resolution of the glare condition allowing one OFFER message to continue to be processed while the other is terminated. It is defined in such a way that it can interwork with SIP's glare handling mechanism. However SIP's timer based mechanism aren't suitable for the ROAP as strict requirements on ROAP message transport between end-points are not possible and thus easily could result in an repeated glare situation.</p>
<p id="rfc.section.5.4.1.p.2">To achieve immediate resolution each OFFER message includes a 32 unsigned integer value, the tie breaker, that is randomly generated for each new OFFER message an end-point issues. Whenever a end-point receives an OFFER message that has the same sequence number as an outstanding OFFER the end-point itself sent, a glare condition has arisen. In a glare condition the end-point compares the received OFFER's tiebreaker value with the tiebreaker value of the tiebreaker in the OFFER outstanding. The OFFER with the greatest numerical value wins and that OFFER is allowed to continue being processed. IF the received OFFER lost the tie breaking an Error:CONFLICT message is sent. If it is the outstanding OFFER that lost, the end-point can expect an Error:CONFLICT message to be eventually received. However, that OFFER can immediately be considered as terminated.</p>
<p id="rfc.section.5.4.1.p.3">Some special considerations has been made in this glare handling for interworking well with SIP glare handling as currently specified. Thus it has the notion of a gateway that converts the ROAP message into SIP message. This process is discussed in more detail below after the basic rules are defined normatively.</p>
<p id="rfc.section.5.4.1.p.4">A regular end-point SHALL generate a random 32-bit unsigned numerical value for each OFFER message. In the case the random value becomes 0 or 4,294,967,295 a new random value SHALL be generated until it is neither values. The values 0 and 4,294,967,295 MAY be assigned to ROAP messages generated by gateways to ensure efficient glare handling towards other systems.</p>
<p id="rfc.section.5.4.1.p.5">An ROAP message end-point that has an outstanding OFFER, i.e. an OFFER where it has not yet received an ANSWER SHALL upon receiving an OFFER perform the following processing:</p>
<p></p>

<dl>
<dt>1</dt>
<dd style="margin-left: 8">Check if the incomming OFFER has a answererSessionId, if not it is an initial offer. If the outstanding OFFER also is an intial OFFER there is an Error. If the outstanding OFFER is not an initial OFFER and the outstanding OFFER do have answererSessionId equal to the offererSessionId in the received message then the sequence numbers are checked. In case the incomming OFFER's sequence number is equal to the sequence number of the outstanding OFFER there is glare. If the sequence number is not the same and the sequence number of the incomming is larger than the outstanding OFFER's sequence number, then this message is out of order with an ANSWER to the out-standing message. If the sequence number of the incomming is lower than the outstanding, then this is a old request.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>2</dt>
<dd style="margin-left: 8">In case of glare, compare the tie-breaker values for each OFFER. The tie-breaker value that is greater than the other wins. The OFFER with the winning value is processed as if there was no glare. The OFFER with the losing value is terminated, see 3A or 3B. In case the tie-breaker values are equal the double-glare case in 3C is invoked.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>3A</dt>
<dd style="margin-left: 8">The OFFER being terminated is the received one: The end-point SHALL send a Error:CONFLICT response message.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>3B</dt>
<dd style="margin-left: 8">The OFFER being terminated is this end-points outstanding OFFER: The end-point knows the OFFER will be terminated and can expect an Error:CONFLICT response. The end-point can assume this termination and MAY issue a new OFFER as soon as possible after having concluded the transactions for the winning OFFER.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>3C</dt>
<dd style="margin-left: 8">The two tie-breaker values where equal, in this case both OFFERs are terminated and a Error:DOUBLCONFLICT message is sent. Both of the Offerer SHOULD re-attempt their offers by generating new OFFER messages, these messages SHALL have new tie-breaker values and incremented sequence number.  Also gateways SHOULD generate random values, as one reason for this double conflict is that two gateways have become interconnected and both selects either 0 or 4,294,967,295.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
</dl>
<p id="rfc.section.5.4.1.p.7">The following figure assumes the previous message flow has happened and media is flowing.</p>
<div id="#rfc.figure.5"></div>
<pre>participant OffererUA
participant OffererJS
participant AnswererJS
participant AnswererUA

note left of OffererJS: "Hi, Let's do video"
note right of AnswererJS: "Sounds great"
OffererJS-&gt;OffererUA: peer-&gt;addStream( new MediaStream() );
OffererUA-&gt;OffererJS: sendSignalingChannel();
AnswererJS-&gt;AnswererUA: peer-&gt;addStream( new MediaStream() );
AnswererUA-&gt;AnswererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: {"type":"OFFER", tiebreaker="123", "sdp":"..."}
AnswererJS-&gt;OffererJS: {"type":"OFFER", tiebreaker="456", "sdp":"..."}
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
OffererJS-&gt;OffererUA: peer-&gt;processSignalingMessage();


OffererUA-&gt;OffererJS: sendSignalingChannel();
AnswererUA-&gt;AnswererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: {"type":"ERROR",error="conflict","sdp":"..."}
AnswererJS-&gt;OffererJS: {"type":"ANSWER", "sdp":"..."}
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
OffererJS-&gt;OffererUA:  peer-&gt;processSignalingMessage();

OffererUA-&gt;OffererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: {"type":"OK"}
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
AnswererUA-&gt;AnswererJS: onaddstream();


AnswererUA-&gt;AnswererJS: sendSignalingChannel();
AnswererJS-&gt;OffererJS: {"type":"OFFER", tiebreaker="789", "sdp":"..."}
OffererJS-&gt;OffererUA: peer-&gt;processSignalingMessage();
OffererUA-&gt;OffererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: {"type":"ANSWER", "sdp":"..."}
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
AnswererUA-&gt;OffererUA: Both way Video    
AnswererUA-&gt;AnswererJS: sendSignalingChannel();
AnswererJS-&gt;OffererJS: {"type":"OK"}
OffererJS-&gt;OffererUA: peer-&gt;processSignalingMessage();
OffererUA-&gt;OffererJS: onaddstream();

            </pre>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#sec.premature-offer" id="sec.premature-offer">Premature OFFER</a>
</h1>
<p id="rfc.section.5.4.2.p.1">It is an error, though technically possible, for an agent to generate a second OFFER while it already has an unanswered OFFER pending. An agent which receives such an offer MUST respond with an Error:FAILED message containing a "RetryAfter" attribute generated as a random value from 0 to 10 seconds.</p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> Notification of Media Termination</h1>
<p id="rfc.section.5.5.p.1">The SHUTDOWN message is used to indicate the termination of an existing session. Either side may initiate a SHUTDOWN at any time during the session, including while the initial OFFER is outstanding (i.e., before an ANSWER has been sent/received.)</p>
<div id="#rfc.figure.6"></div>
<pre>TODO - FIX NAMES 

participant OffererUA
participant OffererJS
participant AnswererJS
participant AnswererUA

OffererJS-&gt;OffererUA: peer-&gt;close();
OffererUA-&gt;OffererJS: sendSignalingChannel();
OffererJS-&gt;AnswererJS: { "type":"SHUTDOWN" }
AnswererJS-&gt;AnswererUA: peer-&gt;processSignalingMessage();
AnswererUA-&gt;AnswererJS: onclose();

AnswererUA-&gt;AnswererJS: sendSignalingChannel();
AnswererJS-&gt;OffererJS: {"type":"OK"}
OffererJS-&gt;OffererUA: peer-&gt;processSignalingMessage();
OffererUA-&gt;OffererJS: onclose();
            </pre>
<p id="rfc.section.5.5.p.2">Upon receipt of a SHUTDOWN which corresponds to an existing session, an agent MUST immediately terminate the session and send an OK message. Subsequent messages directed to this session MUST result in an Error:NOMATCH message. Similarly, on receipt of the OK, the agent which sent the SHUTDOWN MUST terminate the session and SHOULD respond to future messages with Error:NOMATCH.</p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#sec.err" id="sec.err">Errors</a>
</h1>
<p id="rfc.section.5.6.p.1">Errors are indicated by the messageType "ERROR". All errors MUST contain an "errorType" field indicating the type of error which occurred and echo the "seq" value (if any) and the session id values of the message which generated the error. The following sections describe each error type.</p>
<h1 id="rfc.section.5.6.1">
<a href="#rfc.section.5.6.1">5.6.1.</a> <a href="#err.nomatch" id="err.nomatch">NOMATCH</a>
</h1>
<p id="rfc.section.5.6.1.p.1">An implementation which receives a message with either an unknown offererSessionId (for an OFFER) or an unknown offererSessionId/answererSessionId pair SHOULD respond with a NOMATCH error.</p>
<h1 id="rfc.section.5.6.2">
<a href="#rfc.section.5.6.2">5.6.2.</a> <a href="#err.timeout" id="err.timeout">TIMEOUT</a>
</h1>
<p id="rfc.section.5.6.2.p.1">The TIMEOUT error is used to indicate that the corresponding message required some processing which timed out. For instance, an agent which is a SIP gateway translates ROAP signaling messages into SIP messages. If those SIP messages time out, the gateway would generate a TIMEOUT error.</p>
<h1 id="rfc.section.5.6.3">
<a href="#rfc.section.5.6.3">5.6.3.</a> <a href="#err.refused" id="err.refused">REFUSED</a>
</h1>
<p id="rfc.section.5.6.3.p.1">An agent which has received an initial OFFER MAY indicate its refusal of the media session by sending a REFUSED error. Note that this error is not required; an agent MAY simply drop the OFFER with no acknowledgement at all. However, agents which do not wish to accept subsequent OFFERS SHOULD [OPEN ISSUE: MUST?] send a REFUSED in order to avoid timeouts and confusion on the offerer side.</p>
<h1 id="rfc.section.5.6.4">
<a href="#rfc.section.5.6.4">5.6.4.</a> <a href="#err.conflict" id="err.conflict">CONFLICT</a>
</h1>
<p id="rfc.section.5.6.4.p.1">The CONFLICT error is used to indicate that an agent has received an OFFER while it has its own OFFER outstanding. The offerer's behavior in response to this error is defined in <a href="#sec.offer-glare">Section 5.4.1</a>.</p>
<h1 id="rfc.section.5.6.5">
<a href="#rfc.section.5.6.5">5.6.5.</a> <a href="#err.doubleconflict" id="err.doubleconflict">DOUBLECONFLICT</a>
</h1>
<p id="rfc.section.5.6.5.p.1">The DOUBLECONFLICT error is used to indicate the tiebreaker values in CONFLICT were the same. See <a href="#sec.offer-glare">Section 5.4.1</a>.</p>
<h1 id="rfc.section.5.6.6">
<a href="#rfc.section.5.6.6">5.6.6.</a> <a href="#err.failed" id="err.failed">FAILED</a>
</h1>
<p id="rfc.section.5.6.6.p.1">FAILED is a catch-all error indicating that something went wrong while processing a message. A FAILED error MAY contain a "retryAfter" field, which indicates the time (in seconds) after which the message MAY be retried (though retries are OPTIONAL).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec-sec" id="sec-sec">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">TBD</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Companion APIs</h1>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">This section may need to move to the requirements draft<a href="#I-D.ietf-rtcweb-use-cases-and-requirements">[I-D.ietf-rtcweb-use-cases-and-requirements]</a> but for now it is convenient to put it here just to help see how all the pieces fit together.</dd>
</dl>
<p id="rfc.section.7.p.2">The offer / answer concepts in this draft are not enough to meet all the use cases of RTCWeb. They need to be combined with some additional functionality that the browser exposes to the JavaScript applications.  This additional functionality loosely falls into three categories: capabilities, hints, and stats. The capabilities allow the JS application to find out what video codecs and capabilities a given browser supports before initiating a media session. The hints provide a way for the JS application to provide useful information to the browser about how the media will be used so that the browser can negotiate appropriate codecs and modes. Stats provides statistics about what the current media sessions. The capabilities, hints, and stats do not need to be communicated between the two browsers, so they are not specified in this draft. However, this drafts assumes the existence of API so that these three can be used to build complete systems. Some of the assumptions about these APIs are described in the following sections.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Capabilities</h1>
<p id="rfc.section.7.1.p.1">The APIs need to provide a way to find out the capabilities as defined in section 9 of RFC 3264. This allows the JS to find out the codecs that the browser supports.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Hints</h1>
<p id="rfc.section.7.2.p.1">When creating a new PeerConenction in a browser, the application needs to be able to provide optional hints to the browser about preferences for the media to be negotiated. These include:</p>
<p></p>

<ol>
<li>Whether the session has audio, video, or both;</li>
<li>Whether the audio is spoken voice or music;</li>
<li>Preferred video resolution and frame rate (perhaps these just come from the MediaTrack objects);</li>
<li>Whether the video should prefer temporal or spatial fidelity;</li>
<li>&lt;add more here&gt;</li>
</ol>
<p id="rfc.section.7.2.p.3">The JS applications should also be able to update and change these hints mid-session. Some types of hint changes may simply impact the parameter on various codecs and require no signalling to the other end of the media stream. Other types of hint changes may cause a new offer answer exchange.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Stats</h1>
<p id="rfc.section.7.3.p.1">Several parts of the media session create statistics that are important to some applications. APIs should provide the JS applications with information on the following statistics:</p>
<p></p>

<ol>
<li>Total IP data rate for the session;</li>
<li>ICE statistics including current candidates, active pairs, RTT;</li>
<li>RTP statistics including codecs selected, parameters, and bit rates;</li>
<li>RTCP statistics including packet loss rate; and</li>
<li>SRTP statistics.</li>
</ol>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Relationship with SIP &amp; Jingle</h1>
<p id="rfc.section.8.p.1">The SIP <a href="#RFC3261">[RFC3261]</a> specifies an application protocol that provides a complete solution for setting up and managing communications on the Internet. It combines both "call processing" functions - identity and name spaces, call routing, user search, call features, authentication, and so on - as well as media processing through its transport of SDP and support for the offer/answer model.</p>
<p id="rfc.section.8.p.2">In a web context, application processing can be done through proprietary logic implemented in Javascript/HTML, along with proprietary logic implemented in the web server, and proprietary messaging transported through HTTP and WebSockets. One of the advantages of the web is to allow a rich set of applications to be built without changing the browser. Although application processing and be done in JavaScript and the web servers, we do require raw media control in the browser.  ROAP basically extracts the offer/answer media control processing used in SIP, and puts it into an protocol that can operate independently of SIP itself.</p>
<p id="rfc.section.8.p.3">The information contained in ROAP messages corresponds closely to the offer/answer information carried by complete solutions such as SIP and Jingle, so it is straightforward to build gateways to and from ROAP.  These gateways need only translate the signaling, while allowing end-to-end media without the need for media relays (except, of course, for NAT traversal.) In the case of SIP, which uses SDP directly, such gateways would translate between SIP and ROAP, while transporting SDP end-to-end. In the case of Jingle <a href="#XEP-0166">[XEP-0166]</a>, it would also be necessary to translate between SDP and the Jingle offer/answer format; <a href="#XEP-0167">[XEP-0167]</a> describes such a mapping.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> IANA Considerations</h1>
<p id="rfc.section.9.p.1">This document requires no actions from IANA.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> Acknowledgments</h1>
<p id="rfc.section.10.p.1">The text for the glare resoltuion section was provided by Magnus Westerlund. Many thanks for comment, ideas, and text from Eric Rescorla, Harald Alvestrand, Magnus Westerlund, Ted Hardie, and Stefan Hakansson.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> Open Issues</h1>
<p id="rfc.section.11.p.1">How to negotiate support for enhancements to this JSON message.  (consider supported / required )</p>
<p id="rfc.section.11.p.2">Common way to indicate destination in offer going to a signalling gateway.</p>
<p id="rfc.section.11.p.3">Need to generate proper ASCII art version of message flows.</p>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC4627">[RFC4627]</b></td>
<td class="top">
<a>Crockford, D.</a>, "<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>", RFC 4627, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3264">[RFC3264]</b></td>
<td class="top">
<a>Rosenberg, J.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>", RFC 3264, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4566">[RFC4566]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, July 2006.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3261">[RFC3261]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="XEP-0166">[XEP-0166]</b></td>
<td class="top">
<a href="mailto:scottlu@google.com">Ludwig, S.</a>, <a href="mailto:jbeda@google.com">Beda, J.</a>, <a href="mailto:stpeter@jabber.org">Saint-Andre, P.</a>, <a href="mailto:robert.mcqueen@collabora.co.uk">McQueen, R.</a>, <a href="mailto:seanegan@google.com">Egan, S.</a> and <a href="mailto:jhildebr@cisco.com">J. Hildebrand</a>, "<a>Jingle</a>", XSF XEP 0166, December 2009.</td>
</tr>
<tr>
<td class="reference"><b id="XEP-0167">[XEP-0167]</b></td>
<td class="top">
<a href="mailto:scottlu@google.com">Ludwig, S.</a>, <a>Saint-Andre, P.</a>, <a href="mailto:seanegan@google.com">Egan, S.</a>, <a href="mailto:robert.mcqueen@collabora.co.uk">McQueen, R.</a> and <a href="mailto:diana@null.ro">D. Cionoiu</a>, "<a>Jingle RTP Sessions</a>", XSF XEP 0167, December 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="http://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="webrtc-api">[webrtc-api]</b></td>
<td class="top">
<a title="W3C">Bergkvist, Burnett, Jennings, Narayanan, </a>, "<a>WebRTC 1.0: Real-time Communication Between Browsers</a>", October 2011.<p>Available at http://dev.w3.org/2011/webrtc/editor/webrtc.html</p>
</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-use-cases-and-requirements">[I-D.ietf-rtcweb-use-cases-and-requirements]</b></td>
<td class="top">
<a>Holmberg, C</a>, <a>Hakansson, S</a> and <a>G Eriksson</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-06">Web Real-Time Communication Use-cases and Requirements</a>", Internet-Draft draft-ietf-rtcweb-use-cases-and-requirements-06, October 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Cullen Jennings</span> 
	  <span class="n hidden">
		<span class="family-name">Jennings</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  <span>170 West Tasman Drive</span>

	  <span class="vcardline">
		<span class="locality">San Jose</span>,  
		<span class="region">CA</span> 
		<span class="code">95134</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 408 421-9990</span>

<span class="vcardline">EMail: <a href="mailto:fluffy@cisco.com">fluffy@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jonathan Rosenberg</span> 
	  <span class="n hidden">
		<span class="family-name">Rosenberg</span>
	  </span>
	</span>
	<span class="org vcardline">jdrosen.net</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jdrosen@jdrosen.net">jdrosen@jdrosen.net</a></span>

<span class="vcardline">URI: <a href="http://www.jdrosen.net">http://www.jdrosen.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Justin Uberti</span> 
	  <span class="n hidden">
		<span class="family-name">Uberti</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	
  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Randell Jesup</span> 
	  <span class="n hidden">
		<span class="family-name">Jesup</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:randell-ietf@jesup.org">randell-ietf@jesup.org</a></span>

  </address>
</div>

</body>
</html>