<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Generic UDP Tunnelling (GUT)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Generic UDP Tunnelling (GUT)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">J. Manner</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">N. Varis</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">Aalto University</td></tr>
<tr><td class="header">Expires: January 13, 2011</td><td class="header">B. Briscoe</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">BT</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 12, 2010</td></tr>
</table></td></tr></table>
<h1><br />Generic UDP Tunnelling (GUT)<br />draft-manner-tsvwg-gut-02.txt</h1>

<h3>Abstract</h3>

<p>

Deploying new transport protocols on the Internet is a well-known problem, as 
NATs and firewall drop packets with e.g. new protocol types or unidentified TCP 
options. Tunnelling over UDP is one way to make IP packets hide the actual 
payload and enable end-to-end delivery. This document proposes a simple UDP 
tunnelling encapsulation and end-host operation to enable new (and old) IP 
payloads, e.g., new transport protocols, to be deployed on the Internet.

	
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on January 13, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Terminology<br />
<a href="#anchor2">2.</a>&nbsp;
Introduction<br />
<a href="#anchor3">3.</a>&nbsp;
Basic operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Extension headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Sender operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.3.</a>&nbsp;
Receiver operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.4.</a>&nbsp;
Example with one NAT-PT between the initiator and responder<br />
<a href="#anchor8">4.</a>&nbsp;
Deployment Considerations<br />
<a href="#anchor9">5.</a>&nbsp;
Encapsulation of protocols without port numbers<br />
<a href="#anchor10">6.</a>&nbsp;
Security Considerations<br />
<a href="#anchor11">7.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor12">8.</a>&nbsp;
Summary<br />
<a href="#anchor13">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Terminology</h3>

<p> 

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document 
are to be interpreted as described in BCP 14, RFC 2119 <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>. 


</p>
<p> In addition, we use the following terms:
</p>
<p>Native: the IP protocol that will, or has been, encapsulated by GUT, e.g., 
DCCP, SCTP, etc., even protocols like ICMP or RSVP. We also refer to native IP 
packet as the IP packet that carries the native IP protocol.
</p>
<p>Initiator: the node that has sent the first packet belonging to an exchange by 
the native protocol.
</p>
<p>Responder: the node that received the first packet of the native 
protocol.
</p>
<p>Data packet (D-packet): a GUT packet that carries an encapsulated 
native protocol.
</p>
<p>Control packet (C-packet): a GUT packet that carries only extension 
header(s).
</p>
<p>Data-Control packet (DC-packet): a GUT packet that carries an 
encapsulated native protocol and an extension header.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>

New IP paylods, e.g., transport layer technologies, such as SCTP <a class='info' href='#RFC4960'>[RFC4960]<span> (</span><span class='info'>Stewart, R., &ldquo;Stream Control Transmission Protocol,&rdquo; September&nbsp;2007.</span><span>)</span></a> and DCCP <a class='info' href='#RFC4340'>[RFC4340]<span> (</span><span class='info'>Kohler, E., Handley, M., and S. Floyd, &ldquo;Datagram Congestion Control Protocol (DCCP),&rdquo; March&nbsp;2006.</span><span>)</span></a>, have well-known 
problems with deployment on the Internet. Firewalls drop IP packets with 
unknown (too new) transport protocol types or protocol extensions, e.g., TCP 
options, and NAT boxes do not know how to translate these protocols.


</p>
<p>

Tunnelling over UDP has often been mentioned as a means to traverse 
middleboxes. Mostly the solutions are ad-hoc and protocol-specific. In order to 
make deployment of UDP tunnelling at least somewhat consistent, this document 
proposes a simple mechanism to realise the goal. The benefit is that with a 
generic solution we avoid the need to define tunneling specifications for each 
IP protocol separately. The fundamental goal of GUT is to mitigate the problem 
of existing NATs and firewalls, while still allowing middleboxes that 
deliberately want to block to do so.


</p>
<p>

The basic idea of GUT is to encapsulate the native transport protocol 
and its payload (in general the whole IP payload) within a UDP packet 
destined to the well-known port GUT_P. Between the outer UDP header 
and the inner transport header, we have a 4-byte GUT header that 
carries information about the encapsulated protocol to help 
decapsulation on the receiving side. GUT also introduces extension headers.


</p>
<p>

GUT does not specify, nor need, a specific tunnel setup protocol. It 
just encapsulates the native protocol and its payload - to any 
middlebox on the way this looks like a normal UDP flow to port GUT_P.


</p>
<p>
In other words, this specification, i.e, GUT, only defines


</p>
<p>

</p>
<ol class="text">
<li>The encapsulation of the native IP payload,
</li>
<li>The GUT header structure and content, and 
</li>
<li>The state machine on the initiator and responder sides.
</li>
</ol><p>


</p>
<p>

If the native protocol has a handshake or any back-and-forth 
messaging, these are run automatically within the UDP-tunnel created 
by GUT: GUT is meant to be fully transparent to the native protocol. 
Note that GUT can also tunnel protocol types which do not have any 
port informations, such as RSVP or ICMP. The GUT encapsulation is 
agnostic to the IP protocol version being used (IPv4 or IPv6).


</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Basic operation</h3>

<p>

The basic idea of the protocol is to encapsulate the problematic 
native IP payload within a UDP header and send the packet to a 
well-known UDP port GUT_P - any return packets from the responder will 
be tunneled to the UDP source port used by the initiator. The 
responder will get the UDP packets, check the encapsulated payload and 
evaluate if it wants to receive the packet, reconstruct the native IP 
packet, and forward it for further processing within the network 
stack; GUT is not meant to bypass explicit firewall rules and 
configuration. <a class='info' href='#f:stack'>Figure&nbsp;1<span> (</span><span class='info'>GUT encapsulation</span><span>)</span></a> shows the encapsulation.


</p><br /><hr class="insert" />
<a name="f:stack"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

        +------------------+           +------------------+
        |                  |  ------&gt;  |                  |
        |                  |           |                  |
        |   Payload data   |  ------&gt;  |   Payload data   |
        |                  |           |                  |
        |                  |  ------&gt;  |                  |
        +------------------+           +------------------+
        |                  |  ------&gt;  |                  |
        | Nat. payload hdr |           | Nat. payload hdr |
        | (DCCP, SCTP,...) |           | (DCCP, SCTP,...) |
        |                  |  ------&gt;  |                  |
        +------------------+           +------------------+ &lt;--|
        |                  |           |   GUT header     |    |
        |    IP header     | \         | Next header|IHL  |    N
        |                  |  \        +------------------+    E
        +------------------+   \       |                  |    W
                                \      |    UDP header    |    |
                                 \     +------------------+ &lt;--|
                                  \    |                  |
                                   \-&gt; |    IP header     |
                                       |                  |
                                       +------------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: GUT encapsulation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>

The GUT header is 32 bits and carries three pieces of information that 
enable reconstructing the native IP packet and perform checksum 
calculations.


</p>
<p>1. The GUT Header Length (12 bits) gives the length in bytes of the 
headers after the 4-byte GUT header and before the encapsulated 
payload. Any IP option headers encapsulated from the native IP packet 
are included. The GUT header itself is not included. Thus, a value of 
0 indicates straight encapsulation, no headers between the GUT header 
and the encapsulated protocol. 
</p>
<p>2. The IPv4 Header Length (IHL, 4 bits) field from the native IPv4 
packet.
</p>
<p>3. The IP protocol number (next header, 8 bits) of the native IP 
packet (v4 and v6). The value 255 is used to indicate a GUT extension 
header (this value is Reserved in the IP protocol numbers registry). 
Thus, all extension headers carry the same Next header value but a 
different internal type. 
</p>
<p>

The first 8-bit field is currently unused.


</p><br /><hr class="insert" />
<a name="f:header"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Reserved      |    GUT Header Length    |  IHL   |  Next header   |
+--------------------------------+--------+--------+----------------+


</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: GUT header&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Extension headers</h3>

<p> In addition to the GUT main header, we define extendion headers, 
objects. An extension header can be added into a GUT packet carrying 
an encapsulated native protocol frame, or it can be sent standalone, 
without an actual native protocol, i.e., below the GUT header we have 
one or more extension headers but no further payload. Any extension 
headers MUST be appended straight after the GUT main header and before 
any encapsulated native protocol.
</p>
<p> Each extendion header begins with a fixed 32-bit part giving the 
object Type and object Length and Next header. This is followed by the 
object Value, which is a whole number of 32-bit words long. 
</p><br /><hr class="insert" />
<a name="f:extheader"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|E|r|r|r|     Type      |      Length           | Next header   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                             Value                           //
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Extension header structure&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p> E flag (extensibility): A value of "0" indicates that if the 
object is not understood, the whole GUT packet must be silently 
discarded. A value of "1" indicates that the unknown object can simply 
be ignored and the rest of the packet processed as usual. 
</p>
<p>   Type (12 bits):  An IANA-assigned identifier for the type of object.

</p>
<p> Length (12 bits): Length has units of 32-bit words, and 
measures the length of Value.  If there is no Value, Length equals 0. 
If the Length is not consistent with the contents of the object, the 
message MUST be discarded. 
</p>
<p> Value (variable): Value is (therefore) a whole number of 32 bit 
words.  If there is any padding required, the length and location are 
be defined by the object-specific format information; objects which 
contain variable length (e.g. string) types may need to include 
additional length subfields to do so. 
</p>
<p> This specification introduces three extension headers. All these 
extension headers are sent as Control packets, i.e., without an 
encapsulated native protocol. 
</p>
<p>
</p>
<ul class="text">
<li>TEST: to test if the responder supports GUT.
</li>
<li>TEST-REPLY: a reply to a TEST.
</li>
</ul><p>

</p>
<p>

A TEST object can be sent to check whether the receiving host supports 
GUT. The Responder SHOULD reply with a TEST-REPLY if it supports GUT. 
A TEST object MAY carry a Value field giving a nonce that should be 
send back in the TEST-REPLY. A nonce MUST be copied to the TEST-REPLY 
if the Responder is going to answer the TEST. The Responder MUST NOT 
store a flow state when receiving a TEST message. The TEST handshake 
is a similar function than the ICMP ECHO, i.e., both can be used to 
test if the other end point is alive (without assurance, though, since 
replying is voluntary).


</p>
<p>
</p>
<ul class="text">
<li>KEEPALIVE: to maintain a flow state on a middlebox.
</li>
</ul><p>

</p>
<p>

A native protocol, e.g., a TCP flow, may be using keepalive messages 
to maintain middlebox states for a flow. Since GUT makes the native 
flow appear to be UDP, the timeouts of the native flow may be longer 
than what the middlebox is configured to use for a UDP flow. A GUT 
node MAY send KEEPALIVE headers in Control packets to maintain the 
state in middleboxes on the path. A GUT node that receives KEEPALIVE 
Control packets MUST discard them. The keepalives are always 
associated to a certain unique GUT flow. Therefore, the receiver MAY 
use the keepalives as an indication that the native protocol flow is 
still active and thus maintain it's own states for the flow.


</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Sender operation</h3>

<p>

In implementation terms, the GUT process running on a host or router 
(proxy) receives the native IP packet, the whole packet including the 
IP header, grabs the bytes immediately after the native IP static 
header, adds a UDP and GUT header, and sends the packet to the 
destination indicated in the received IP packet. Header checksums are 
recalculated and IP options are encapsulated. 
</p>
<p>

The sender MAY limit the UDP checksum coverage to just the octets 
outside the native transport header, i.e., not include the 
encapsulated payload. This is purely for efficiency - to avoid running 
the whole payload through the checksum calculation twice - with all 
the memory shifts that will entail.


</p>
<p>

The source port in the UDP header MAY be chosen freely, although if 
the native encapsulated protocol had a notion of port numbers, the 
sender SHOULD choose the same source port (note that the source port 
may already be used by another process, thus the processing may have 
to choose another port number). The IP header indicates a UDP 
transport, the GUT header is the first 4 bytes of the UDP payload. The 
Total Length field in the IP header gives the length of the whole 
datagram including the encapsulated transport protocol packet. The GUT 
IP header length gives the length of any encapsulated IPv4 Options; 
this value is actually copied directly from the native IP packet.


</p>
<p>

The current value of GUT_P is 4887 (rule of thumb 1-800-GUTP)


</p>
<p>

The GUT daemon is not considered as an IP hop, thus, when the sender 
builds the IP header, it MUST use the TTL from the native IP packet. 
Similarly any ECN and DSCP bits are copied from the native IP packet 
to the outgoing IP packet.


</p>
<p>

GUT adds 12 octets of headers (UDP+GUT) which may cause fragmentation 
to happen. GUT is meant as transparent a functionality as possible. 
Thus, in principle GUT relies on the network stack to do IP packet 
fragmentation and reassembly.


</p>
<p>

If the native IP packet had IP options, those are preserved within the 
GUT encapsulation. Here the processing must store the original 
IHL-field from the native IPv4 packet to be used on the responder side 
for building the native IP packet properly.


</p>
<p>

It is possible, that the sender gets fragmented IP packets from the 
network stack to be GUT-encapsulated. In such case, the GUT process 
MUST reassemble the whole IP packet before adding the UDP and GUT 
header. The subsequent packet is given back to the network stack for 
transmission, and may be fragmented at that point to fit the MTU of 
the link. The initiator may decide to use Path MTU Discovery when the 
first packet of a flow is received for encapsulation, yet, this will 
add a delay to the transmission of the first packet and may result in 
the native protocol to react accordingly.



</p>
<p>

</p>
<p>

The initiator has to store state, the 5-tuple or 3-tuple (or any 
information that enables tracking a particular flow), for each initiated 
GUT encapsulation. This state is needed for properly catching potential 
return packets of the native IP protocol from the responder (e.g. DCCP, 
SCTP). This state can be made to expire after a certain timeout, or an 
implementation can decide to monitor open sockets in the operating 
system, and remove state of encapsulated native protocols that have 
their socket closed.


</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Receiver operation</h3>

<p>

On the receiver side (responder and initiator), the GUT service 
receives UDP packets, verifies the checksums, does further analysis 
about whether it wants to process the packet further, and either drops 
the packet or continues processing.


</p>
<p>

GUT must be able to receive packets with two distinct destination port ranges:


</p>
<p>

</p>
<blockquote class="text">
<p>GUT_P port: this port number is seen when the packet was sent by a flow 
initiator.
</p>
<p>Any other UDP port: the flow initiator has chosen a source port number and if 
the encapsulated IP protocol included two-way messaging (e.g. a handshake, 
acknowledgement packets, etc.), it will receive return packets to this UDP port.
</p>
</blockquote><p>


</p>
<p>

When the host receives packets to port GUT_P, i.e., it is the 
destination of the flow, the responder, it MUST store the 5-tuple or 
3-tuple (or any information that enables tracking a particular flow) of 
the encapsulated IP packet flow. This state information is needed to 
send back packets belonging to the same flow. An implementation may 
optimize the overall resource consumption of the state in GUT by 
omitting state information for flows where the source ports of the 
native- and UDP transport protocols match.


</p>
<p>

After decapsulation of the 32-bit GUT header and the UDP header, the 
GUT processing reconstructs the native IP packet by using the received 
IP header fields but exchanges the encapsulated next header and IHL 
fields found in the GUT header. Then the rebuilt packet is injected 
into the network stack for further processing. Any checksums are 
recalculated. Any IP options will now be visible to the network stack.


</p>
<p>

A responder should never receive fragmented IP packets since the operating 
system IP stack will take care of rebuilding the fragments into a full IP 
packet.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Example with one NAT-PT between the initiator and responder</h3>

<p>

The following figure describes how various protocol fields are mapped on
a two-way IP packet flow. The example shows a DCCP-transfer going
from A to B. The figure presents the content of IP packets as they are
sent out from a component on the path. Note that if the encapsulated
protocol does not have port numbers, the GUT processing is even simpler.


</p><br /><hr class="insert" />
<a name="f:example"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

[Source, IP A]  [GUT@A] [NAT, ext IP C] [GUT@B] [Dest, IP B]

------------- Source A to destination B -------------------
1. [IP: A-&gt;B, DCCP]
2. [DCCP: E-&gt;F]

3.              [IP: A-&gt;B, UDP]
4.              [UDP: E-&gt;GUT]
5.              [GUT-hdr, DCCP]
6.              [DCCP: E-&gt;F]

7.                      [IP: C-&gt;B, UDP]
8.                      [UDP: P-&gt;GUT]
                        [GUT-hdr, DCCP]
                        ...

9.                                      [IP: C-&gt;B, DCCP]
10.                                     [DCCP: E-&gt;F]

------------- Destination B to source A -------------------
11.                                             [IP: B-&gt;C,DCCP]
12.                                             [DCCP: F-&gt;E]

13.                                     [IP: B-&gt;C, UDP]
14.                                     [UDP: GUT-&gt;P ]
15.                                     [GUT-hdr, DCCP]
16.                                     [DCCP: F-&gt;E]

17.                     [IP: B-&gt;A, UDP]
18.                     [UDP: GUT-&gt;E]
                        ...

19.             [IP: B-&gt;A, DCCP]
20.             [DCCP: F-&gt;E]
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: GUT encapsulation example&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>

A few details from the figure above:


</p>
<p>

</p>
<ul class="text">
<li>

Line 4: the GUT process takes GUT_P as the destination port, and chooses 
a source port based on the DCCP header.


</li>
<li>

Line 8: the NAT may choose a new source port P, instead of E, and rewrite 
the UDP header.


</li>
<li>

Line 10: before giving the packet to the local IP stack, the GUT process takes 
note of the source IP and port numbers, and the encapsulated protocol.


</li>
<li>

Line 11-12: the tunneled protocol has not seen the GUT encapsulation, thus, 
it will use the native port numbers in the reverse traffic.


</li>
<li>

- Lines 13-16: the GUT process has earlier stored state about the flow, knows 
now that the packet is for an existing stream, and can direct the flow to the 
right destination port "P", instead of sending it to GUT_P, as if the packet 
belonged to a new stream.

</li>
</ul><p>


</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Deployment Considerations</h3>

<p>

The basic goal of GUT is to look like generic UDP messaging to any middlebox 
on the path. If the native transport protocol has support for congestion 
control, GUT encapsulated packets that are lost will trigger the native
transport to react.


</p>
<p>

As GUT-encapsulated traffic looks like an ordinary stream of UDP 
packets, existing NAT traversal protocols and techniques work out of 
the box. For example, a responder GUT-daemon can, when needed, 
maintain the GUT_P open at the NAT using any suitable NAT-traversal 
protocol. The KEEPALIVE extension header in Control packets may also 
be used to maintain the state on middleboxes.


</p>
<p>

GUT was originally designed to be used for host-to-host communication. 
Yet, nothing actually prohibits to have a network node that takes the 
IP packets coming from a host, and tunnels them through GUT. 
Similarly, a network node on the receiving side of the connection can 
decapsulate the packets before they actually hit the receiving 
end-host, so essentially making a GUT-proxy service.


</p>
<p>

There is yet one critical issue to consider, namely when to 
encapsulate a transport protocol in GUT, and when not. GUT introduces 
the TEST/TEST-REPLY handshake that can be used to verify if the 
receiver has support for GUT; the TEST extension header could be sent 
at the same time as the initial packet of a native protocol. When 
using a TEST Control packet, the Initiator may get back an ICMP port 
unreachable ICMP message. This is a clear indication that GUT is not 
supported by the receiver.

</p>
<p>

A further option is to trigger GUT when replies to a transport 
protocol Y's connection initiation are not received within a given 
timeout. Using GUT can also be a configuration parameter, say, e.g., 
the host always encapsulates DCCP packets into GUT; this operation is 
fully transparent to the inner transport protocol.


</p>
<p>

This document does not try to define all potential cases and triggers that 
might result in an initiator to employ GUT for a certain flow. The actual 
triggers will emerge as GUT is experimented with.


</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Encapsulation of protocols without port numbers</h3>

<p>

GUT is originally designed to counter the problems of deploying relatively 
new transport protocols on existing Internet. Yet, GUT can also be used to 
encapsulate any other protocol, e.g., RSVP or HIP.


</p>
<p>

Note that some protocols may not involve port numbers, e.g., RSVP. In such 
cases, GUT is free to choose a random port for the initiator's port number; the 
responder's port is always GUT_P.


</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>

In general GUT has the same security concerns as the IP protocol it 
encapsulates. For example, if the encapsulated protocol can be harmed 
by injecting false packets into the stream, GUT can not prohibit this.


</p>
<p>

The main additional concern GUT introduces is the increased state 
needed to properly tunnel packets back-and-forth. Yet, here an 
implementation SHOULD analyze the encapsulated IP protocol and drop 
the packet, without storing state, if it does not match the 
expectations. For example, if the host does not have a transport port 
open at the indicated destination port, GUT SHOULD drop the packet 
silently. Also, in case the native IP packet flow does not have a 
notion of port numbers to enable more accurate matching of pakcets, an 
implementation may consider storing more information about the flow 
that just the 3-tuple. This has the downside that GUT must be more 
aware of each individual native IP protocol - currently GUT basically 
only needs to know if the native protocol has a notion of port numbers 
or not; thus, a GUT implementation only needs special treatment of 
native UDP, TCP, SCTP and DCCP packet flows.


</p>
<p>

Packets belonging to a GUT encapsulated flow will go through a 
firewall processing twice, (1) once when the IP packet arrives, either 
locally or from the network, and before it is given to GUT, and (2) 
when GUT sends out the encapsulated IP protocol inside UDP.


</p>
<p>

GUT itself does not employ any security functions for content 
protection. Yet, one could use any one-way mechanism, or purely rely 
on the security functions of the inner payload. If security measures 
are used on GUT, it should be a one-way scheme, which does not rely on 
back-and-forth signalling; we don't want to force two-way signaling 
within GUT, this may or may not happen due to the inner protocol being 
tunneled.


</p>
<p>

The TEST/TEST-REPLY hanshake can be used for DoS attacks. Therefore, 
the Responder SHOULD employ rate limitation when answering TEST 
Control packets.


</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>

This document requests IANA to


</p>
<p> 1. Allocate a new UDP port number GUT_P as referred to in the document. 
</p>
<p> 2. Create a GUT extension headers repository and allocate three 
values for TEST, TEST-REPLY and KEEPALIVE. The values are 8 bits long.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Summary</h3>

<p>

Essentially this document define a generic mechanism for
tunneling any IP payload over a UDP tunnel. The benefits are:


</p>
<p>

</p>
<ol class="text">
<li>Existing IP protocols, with or without port information, work without
changes. 
</li>
<li>Deployment can be done on the end-host or a network proxy.
</li>
<li>No changes are required for existing NAT and firewall devices.
</li>
</ol><p>


</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>This work was partly performed and funded by Trilogy, a research 
project supported by the European Commission under its Seventh 
Framework Program (INFSOICT-216372). 
</p>
<p>The authors thank Robert Hancock for various ideas behind the 
generic UDP tunneling concepts.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC4340">[RFC4340]</a></td>
<td class="author-text">Kohler, E., Handley, M., and S. Floyd, &ldquo;<a href="http://tools.ietf.org/html/rfc4340">Datagram Congestion Control Protocol (DCCP)</a>,&rdquo; RFC&nbsp;4340, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4340.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4960">[RFC4960]</a></td>
<td class="author-text">Stewart, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4960">Stream Control Transmission Protocol</a>,&rdquo; RFC&nbsp;4960, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4960.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jukka Manner</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Aalto University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Department of Communications and Networking (Comnet)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 13000</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">FIN-00076 Aalto</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358 9 470 22481</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jukka.manner@tkk.fi">jukka.manner@tkk.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.netlab.tkk.fi/~jmanner/">http://www.netlab.tkk.fi/~jmanner/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nuutti Varis</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Aalto University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 13000</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Espoo  FIN-00076 Aalto</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nvaris@cc.hut.fi">nvaris@cc.hut.fi</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bob Briscoe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BT</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">B54/77, Adastral Park</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Martlesham Heath</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ipswich  IP5 3RE</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+44 1473 645196</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:bob.briscoe@bt.com">bob.briscoe@bt.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://bobbriscoe.net/">http://bobbriscoe.net/</a></td></tr>
</table>
</body></html>
