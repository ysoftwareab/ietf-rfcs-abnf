NFS Version 4 Working Group                                  S. Shepler
INTERNET-DRAFT                                             B. Callaghan
Document: draft-ietf-nfsv4-00.txt                             M. Eisler
                                                            D. Robinson
                                                             R. Thurlow
                                                       Sun Microsystems
                                                              June 1999

                             NFS version 4

Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

Abstract

   NFS version 4 is a distributed file system protocol which owes
   heritage to NFS versions 2 [RFC1094] and 3 [RFC1813].  Unlike earlier
   versions, NFS version 4 supports traditional file access while
   integrating support for file locking and the mount protocol.  In
   addition, support for strong security (and its negotiation), compound
   operations, and internationlization have been added.  Of course,
   attention has been applied to making NFS version 4 operate well in an
   Internet environment.

Expires: December 1999                                          [Page 1]

Draft Protocol Specification  NFS version 4                    June 1999

Copyright

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Key Words

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119.

Expires: December 1999                                          [Page 2]

Draft Protocol Specification  NFS version 4                    June 1999

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . 6
   2.  RPC and Security Flavor  . . . . . . . . . . . . . . . . . . 7
   2.1.  Ports and Transports . . . . . . . . . . . . . . . . . . . 7
   2.2.  Security Flavors . . . . . . . . . . . . . . . . . . . . . 7
   2.2.1.  Security mechanisms for NFS version 4  . . . . . . . . . 7
   2.2.1.1.  Kerberos V5 as security triple . . . . . . . . . . . . 7
   2.2.1.2.  <another security triple>  . . . . . . . . . . . . . . 8
   2.3.  Security Negotiation . . . . . . . . . . . . . . . . . . . 8
   2.3.1.  Security Error . . . . . . . . . . . . . . . . . . . . . 8
   2.3.2.  SECINFO  . . . . . . . . . . . . . . . . . . . . . . . . 9
   3.  File handles . . . . . . . . . . . . . . . . . . . . . . .  10
   3.1.  Obtaining the First File Handle  . . . . . . . . . . . .  10
   3.1.1.  Root File Handle . . . . . . . . . . . . . . . . . . .  10
   3.1.2.  Public File Handle . . . . . . . . . . . . . . . . . .  11
   3.2.  File Handle Types  . . . . . . . . . . . . . . . . . . .  11
   3.2.1.  General Properties of a File Handle  . . . . . . . . .  12
   3.2.2.  Persistent File Handle . . . . . . . . . . . . . . . .  12
   3.2.3.  Volatile File Handle . . . . . . . . . . . . . . . . .  13
   3.2.4.  One Method of Constructing a Volatile File Handle  . .  14
   3.3.  Client Recovery from File Handle Expiration  . . . . . .  15
   4.  Basic Data Types . . . . . . . . . . . . . . . . . . . . .  16
   5.  File Attributes  . . . . . . . . . . . . . . . . . . . . .  18
   5.1.  Mandatory Attributes . . . . . . . . . . . . . . . . . .  19
   5.2.  Recommended Attributes . . . . . . . . . . . . . . . . .  19
   5.3.  Named Attributes . . . . . . . . . . . . . . . . . . . .  20
   5.4.  Mandatory Attributes - Definitions . . . . . . . . . . .  20
   5.5.  Recommended Attributes - Definitions . . . . . . . . . .  22
   6.  NFS Server Namespace . . . . . . . . . . . . . . . . . . .  28
   6.1.  Server Exports . . . . . . . . . . . . . . . . . . . . .  28
   6.2.  Browsing Exports . . . . . . . . . . . . . . . . . . . .  28
   6.3.  Server Pseudo File-System  . . . . . . . . . . . . . . .  29
   6.4.  Multiple Roots . . . . . . . . . . . . . . . . . . . . .  29
   6.5.  Filehandle Volatility  . . . . . . . . . . . . . . . . .  29
   6.6.  Exported Root  . . . . . . . . . . . . . . . . . . . . .  29
   6.7.  Mount Point Crossing . . . . . . . . . . . . . . . . . .  30
   6.8.  Summary  . . . . . . . . . . . . . . . . . . . . . . . .  30
   7.  File Locking . . . . . . . . . . . . . . . . . . . . . . .  31
   7.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . .  31
   7.2.  Locking  . . . . . . . . . . . . . . . . . . . . . . . .  32
   7.2.1.  Client ID  . . . . . . . . . . . . . . . . . . . . . .  32
   7.2.2.  nfs_lockowner and stateid definition . . . . . . . . .  34
   7.2.3.  Use of the stateid . . . . . . . . . . . . . . . . . .  34
   7.2.4.  Sequencing of lock requests  . . . . . . . . . . . . .  35
   7.3.  Blocking locks . . . . . . . . . . . . . . . . . . . . .  35
   7.4.  Lease renewal  . . . . . . . . . . . . . . . . . . . . .  36
   7.5.  Crash recovery . . . . . . . . . . . . . . . . . . . . .  36

Expires: December 1999                                          [Page 3]

Draft Protocol Specification  NFS version 4                    June 1999

   7.6.  Server revocation of locks . . . . . . . . . . . . . . .  37
   7.7.  Share Reservations . . . . . . . . . . . . . . . . . . .  38
   7.8.  OPEN/CLOSE procedures  . . . . . . . . . . . . . . . . .  38
   8.  Defined Error Numbers  . . . . . . . . . . . . . . . . . .  40
   9.  NFS Version 4 Requests . . . . . . . . . . . . . . . . . .  45
   9.1.  Compound Procedure . . . . . . . . . . . . . . . . . . .  45
   9.2.  Evaluation of a Compound Request . . . . . . . . . . . .  45
   10.  NFS Version 4 Procedures  . . . . . . . . . . . . . . . .  47
   10.1.  Procedure 0: NULL - No Operation  . . . . . . . . . . .  47
   10.2.  Procedure 1: COMPOUND - Compound Operations . . . . . .  48
   10.3.  Procedure 2: ACCESS - Check Access Permission . . . . .  50
   10.4.  Procedure 3: CLOSE - Close File . . . . . . . . . . . .  53
   10.5.  Procedure 4: COMMIT - Commit Cached Data  . . . . . . .  55
   10.6.  Procedure 5: CREATE - Create a Non-Regular File Object   58
   10.7.  Procedure 6: GETATTR - Get Attributes . . . . . . . . .  62
   10.8.  Procedure 7: GETFH - Get Current Filehandle . . . . . .  64
   10.9.  Procedure 8: LINK - Create Link to a File . . . . . . .  66
   10.10.  Procedure 9: LOCK - Create Lock  . . . . . . . . . . .  68
   10.11.  Procedure 10: LOCKT - Test For Lock  . . . . . . . . .  70
   10.12.  Procedure 11: LOCKU - Unlock File  . . . . . . . . . .  72
   10.13.  Procedure 12: LOOKUP - Lookup Filename . . . . . . . .  74
   10.14.  Procedure 13: LOOKUPP - Lookup Parent Directory  . . .  77
   10.15.  Procedure 14: NVERIFY - Verify Difference in Attributes 79
   10.16.  Procedure 15: OPEN - Open a Regular File . . . . . . .  81
   10.17.  Procedure 16: OPENATTR - Open Named Attribute Directory 86
   10.18.  Procedure 17: PUTFH - Set Current Filehandle . . . . .  88
   10.19.  Procedure 18: PUTPUBFH - Set Public Filehandle . . . .  89
   10.20.  Procedure 19: PUTROOTFH - Set Root Filehandle  . . . .  90
   10.21.  Procedure 20: READ - Read from File  . . . . . . . . .  91
   10.22.  Procedure 21: READDIR - Read Directory . . . . . . . .  94
   10.23.  Procedure 22: READLINK - Read Symbolic Link  . . . . .  98
   10.24.  Procedure 23: REMOVE - Remove Filesystem Object  . . .  100
   10.25.  Procedure 24: RENAME - Rename Directory Entry  . . . .  102
   10.26.  Procedure 25: RENEW - Renew a Lease  . . . . . . . . .  105
   10.27.  Procedure 25: RESTOREFH - Restore Saved Filehandle . .  106
   10.28.  Procedure 27: SAVEFH - Save Current Filehandle . . . .  108
   10.29.  Procedure 28: SECINFO - Obtain Available Security  . .  109
   10.30.  Procedure 29: SETATTR - Set Attributes . . . . . . . .  111
   10.31.  Procedure 30: SETCLIENTID - Negotiated Clientid  . . .  114
   10.32.  Procedure 31: VERIFY - Verify Same Attributes  . . . .  116
   10.33.  Procedure 32: WRITE - Write to File  . . . . . . . . .  118
   11.  Locking notes . . . . . . . . . . . . . . . . . . . . . .  123
   11.1.  Short and long leases . . . . . . . . . . . . . . . . .  123
   11.2.  Clocks and leases . . . . . . . . . . . . . . . . . . .  123
   11.3.  Locks and lease times . . . . . . . . . . . . . . . . .  123
   11.4.  Locking of directories and other meta-files . . . . . .  124
   11.5.  Proxy servers and leases  . . . . . . . . . . . . . . .  124
   11.6.  Locking and the new latency . . . . . . . . . . . . . .  124

Expires: December 1999                                          [Page 4]

Draft Protocol Specification  NFS version 4                    June 1999

   12.  Internationalization  . . . . . . . . . . . . . . . . . .  125
   12.1.  Universal Versus Local Character Sets . . . . . . . . .  125
   12.2.  Overview of Universal Character Set Standards . . . . .  126
   12.3.  Difficulties with UCS-4, UCS-2, Unicode . . . . . . . .  127
   12.4.  UTF-8 and its solutions . . . . . . . . . . . . . . . .  128
   13.  Security Considerations . . . . . . . . . . . . . . . . .  129
   14.  NFS Version 4 RPC definition file . . . . . . . . . . . .  130
   15.  Bibliography  . . . . . . . . . . . . . . . . . . . . . .  151
   16.  Authors and Contributors  . . . . . . . . . . . . . . . .  155
   16.1.  Contributors  . . . . . . . . . . . . . . . . . . . . .  155
   16.2.  Editor's Address  . . . . . . . . . . . . . . . . . . .  155
   16.3.  Authors' Addresses  . . . . . . . . . . . . . . . . . .  155
   17.  Full Copyright Statement  . . . . . . . . . . . . . . . .  157

Expires: December 1999                                          [Page 5]

Draft Protocol Specification  NFS version 4                    June 1999

1.  Introduction

   NFS version 4 is a further revision of the NFS protocol defined
   already by versions 2 [RFC1094] and 3 [RFC1813].  It retains the
   essential characteristics of previous versions: stateless design for
   easy recovery, independent of transport protocols, operating systems
   and filesystems, simplicity, and good performance.  The NFS version 4
   revision has the following goals:

   o    Improved access and good performance on the Internet.

        The protocol is designed to transit firewalls easily, perform
        well where latency is high and bandwidth is low, and scale to
        very large numbers of clients per server.

   o    Strong security with negotiation built into the protocol.

        The protocol builds on the work of the ONCRPC working group in
        supporting the RPCSEC_GSS protocol.  Additionally NFS version 4
        provides a mechanism to allow clients and servers to negotiate
        security and require clients and servers to support a minimal
        set of security schemes.

   o    Good cross-platform interoperability.

        The protocol features a filesystem model that provides a useful,
        common set of features that does not unduly favor one filesystem
        or operating system over another.

   o    Designed for protocol extensions.

        The protocol is designed to accept standard extensions that do
        not compromise backward compatibility.

Expires: December 1999                                          [Page 6]

Draft Protocol Specification  NFS version 4                    June 1999

2.  RPC and Security Flavor

   The NFS version 4 protocol is a Remote Procedure Call (RPC)
   application that uses RPC version 2 and the corresponding eXternal
   Data Representation (XDR) as defined in [RFC1831] and [RFC1832].  The
   RPCSEC_GSS security flavor as defined in [RFC2203] MUST be used as
   the mechanism to deliver stronger security to NFS version 4.

2.1.  Ports and Transports

   Historically, NFS version 2 and version 3 servers have resided on
   UDP/TCP port 2049. Port 2049 is a IANA registered port number for NFS
   and therefore will continue to be used for NFS version 4.  Using the
   well known port for NFS services means the NFS client will not need
   to use the RPC binding protocols as described in [RFC1833]; this will
   allow NFS to transit firewalls.

   The NFS server SHOULD offer its RPC service via TCP as the primary
   transport. The server SHOULD also provide UDP for RPC service.  The
   NFS client SHOULD also have a preference for TCP usage but may supply
   a mechanism to override TCP in favor of UDP as the RPC transport.

2.2.  Security Flavors

   Traditional RPC implementations have included AUTH_NONE, AUTH_SYS,
   AUTH_DH, and AUTH_KRB4 as security flavors.  With [RFC2203] an
   additional security flavor of RPCSEC_GSS has been introduced which
   uses the functionality of GSS-API [RFC2078].  This allows for the use
   of varying security mechanisms by the RPC layer without the
   additional implementation overhead of adding RPC security flavors.
   For NFS version 4, the RPCSEC_GSS security flavor MUST be used to
   enable the mandatory security mechanism.  The flavors AUTH_NONE,
   AUTH_SYS, and AUTH_DH MAY be implemented as well.

2.2.1.  Security mechanisms for NFS version 4

   The use of RPCSEC_GSS requires selection of: mechanism, quality of
   protection, and service (authentication, integrity, privacy).  The
   remainder of this document will refer to these three parameters of
   the RPCSEC_GSS security as the security triple.

2.2.1.1.  Kerberos V5 as security triple

   The Kerberos V5 GSS-API mechanism as described in [RFC1964] MUST be
   implemented and provide the following security triples.

 columns:

Expires: December 1999                                          [Page 7]

Draft Protocol Specification  NFS version 4                    June 1999

 1 == number of pseudo flavor
 2 == name of pseudo flavor
 3 == mechanism's OID
 4 == mechanism's algorithm(s)
 5 == RPCSEC_GSS service

 1      2     3                    4              5
 -----------------------------------------------------------------------
 390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_none
 390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_integrity
 390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_privacy
                                   for integrity,
                                   and 56 bit DES
                                   for privacy.

        This section will be expanded to include the pertinent
        details from draft-ietf-nfsv4-nfssec-00.txt.

2.2.1.2.  <another security triple>

        Another GSS-API mechanism will need to be specified here
        along with the corresponding security triple(s).

2.3.  Security Negotiation

   With the NFS version 4 server potentially offering multiple security
   mechanisms, the client will need a way to determine or negotiate
   which mechanism is to be used for its communication with the server.
   The NFS server may have multiple points within its file system name
   space that are available for use by NFS clients.  In turn the NFS
   server may be configured such that each of these entry points may
   have different or multiple security mechanisms in use.

   The security negotiation between client and server must be done with
   a secure channel to eliminate the possibility of a third party
   intercepting the negotiation sequence and forcing the client and
   server to choose a lower level of security than required/desired.

2.3.1.  Security Error

   Based on the assumption that each NFS version 4 client and server
   must support a minimum set of security (i.e. Kerberos-V5 under
   RPCSEC_GSS, <ed: add other>), the NFS client will start its
   communication with the server with one of the minimal security

Expires: December 1999                                          [Page 8]

Draft Protocol Specification  NFS version 4                    June 1999

   triples.  During communication with the server, the client may
   receive an NFS error of NFS4ERR_WRONGSEC.  This error allows the
   server to notify the client that the security triple currently being
   used is not appropriate for access to the server's file system
   resources.  The client is then responsible for determining what
   security triples are available at the server and choose one which is
   appropriate for the client.

2.3.2.  SECINFO

   The new procedure SECINFO (see SECINFO procedure definition) will
   allow the client to determine, on a per filehandle basis, what
   security triple is to be used for server access.  In general, the
   client will not have to use the SECINFO procedure except during
   initial communication with the server or when the client crosses
   policy boundaries at the server.  It could happen that the server's
   policies change during the client's interaction therefore forcing the
   client to negotiate a new security triple.

Expires: December 1999                                          [Page 9]

Draft Protocol Specification  NFS version 4                    June 1999

3.  File handles

   The file handle in the NFS protocol is a per server unique identifier
   for a file system object.  The contents of the file handle are opaque
   to the client.  Therefore, the server is responsible for translating
   the file handle to an internal representation of the file system
   object.  Since the file handle is the client's reference to an object
   and the client may cache this reference, the server should not reuse
   a file handle for another file system object.  If the server needs to
   reuse a file handle value, the time elapsed before reuse SHOULD be
   large enough that it is likely the client no longer has a cached copy
   of the reused file handle value.

3.1.  Obtaining the First File Handle

   The procedures of the NFS protocol are defined in terms of one or
   more file handles.  Therefore, the client needs a file handle to
   initiate communication with the server.  With NFS version 2 [RFC1094]
   and NFS version 3 [RFC1813], there exists an ancillary protocol to
   obtain this first file handle.  The MOUNT protocol, RPC program
   number 100005, provides the mechanism of translating a string based
   file system path name to a file handle which can then be used by the
   NFS protocols.

   The MOUNT protocol has deficiencies in the area of security and use
   via firewalls.  This is one reason that the use of the public file
   handle was introduced [RFC2054] [RFC2055].  With the use of public
   file handle in combination with the LOOKUP procedure in NFS version 2
   and 3, it has been demonstrated that the MOUNT protocol is
   unnecessary for viable interaction between NFS client and server.

   Therefore, NFS version 4 will not use an ancillary protocol for
   translation from string based path names to a file handle.  Two
   special file handles will be used as starting points for the NFS
   client.

3.1.1.  Root File Handle

   The first of the special file handles is the ROOT file handle.  The
   ROOT file handle does not have a special file handle value as does
   the public file handle.  The ROOT file handle is the "conceptual"
   root of the file system name space at the NFS server.  The client
   uses or starts with the ROOT file handle by employing the PUTROOTFH
   procedure.  The PUTROOTFH procedure instructs the server to set the
   "current" file handle to the ROOT of the server's file tree.  Once
   this PUTROOTFH procedure is used, the client can then traverse the
   entirety of the server's file tree with the LOOKUP procedure.  A

Expires: December 1999                                         [Page 10]

Draft Protocol Specification  NFS version 4                    June 1999

   complete discussion of the server name space is in section 6, "NFS
   Server Name Space".

3.1.2.  Public File Handle

   Unlike the root file handle, the public file handle is represented by
   a reserved or special value of the file handle.  NFS version 4
   defines the file handle as a variable length array of bytes (see
   section 4, "Basic Data Types").  The public file handle is the 'zero'
   file handle or in other words a file handle with a array length of
   zero.

   Again unlike the root file handle, the public file handle may be
   bound or represent an arbitrary file system object at the server.
   The server is responsible for this binding.  It may be that the
   public file handle and the root file handle refer to the same file
   system object.  However, it is up to the administrative software at
   the server and the policies of the server administrator to define the
   binding of public file handle and server file system object.  The
   client may not make any assumptions about this binding.

3.2.  File Handle Types

   In NFS version 2 and 3, there was one type of file handle with a
   single set of semantics.  NFS version 4 introduces a new type of file
   handle in an attempt to accommodate certain server environments.  The
   first type of file handle is 'persistent'.  The semantics of a
   persistent file handle are the same as the file handles of NFS
   version 2 and 3.  The second or new type of file handle is the
   'volatile' file handle.

   The volatile file handle type is being introduced to address server
   functionality or implementation issues which prevent correct or
   feasible implementation of a persistent file handle.  Some server
   environments do not provide a file system level invariant that can be
   used to construct a persistent file handle.  The underlying server
   file system may not provide the invariant or the server's file system
   APIs may not provide access to the needed invariant.  Volatile file
   handles may ease the implementation of server functionality such as
   hierarchical storage management or file system reorganization or
   migration.  However, the volatile file handle increases the
   implementation burden for the client but this increased burden is
   deemed acceptable based on the overall gains achieved by the
   protocol.

   Since the client will have different paths of logic to handle
   persistent and volatile file handles, a file attribute is defined

Expires: December 1999                                         [Page 11]

Draft Protocol Specification  NFS version 4                    June 1999

   which may be used by the client to determine the file handle types
   being returned by the server.

3.2.1.  General Properties of a File Handle

   The file handle contains all the information the server needs to
   distinguish an individual file.  To the client, the file handle is
   opaque. The client stores file handles for use in a later request and
   can compare two file handles from the same server for equality by
   doing a byte-by-byte comparison, but MUST NOT otherwise interpret the
   contents of file handles. If two file handles from the same server
   are equal, they MUST refer to the same file, but if they are not
   equal, no conclusions can be drawn. Servers SHOULD try to maintain a
   one-to-one correspondence between file handles and files but this is
   not required. Clients MUST only use file handle comparisons only to
   improve performance, not for correct behavior.

   As an example, in the case that two different path names when
   traversed at the server terminate at the same file system object, the
   server SHOULD return the same file handle for each path.  This can
   occur if a hard link is used to create two file names which refer to
   the same underlying file object and associated data.  For example, if
   paths /a/b/c and /a/d/c refer to the same file, the server SHOULD
   return the same file handle for both path names traversals.

3.2.2.  Persistent File Handle

   A persistent file handle is defined as having a persistent value for
   the lifetime of the file system object to which it refers.  Once the
   server creates the file handle for a file system object, the server
   MUST return the same file handle for the object for the lifetime of
   the object.  If the server restarts or reboots, the NFS server must
   honor and present the same file handle value as it did in the
   server's previous instantiation.

   The persistent file handle will be become stale or invalid when the
   file system object is removed.  When the server is presented with a
   persistent file handle that refers to a deleted object, it MUST
   return an error of NFS4ERR_STALE.  A file handle may become stale
   when the file system containing the object is no longer available.
   The file system may become unavailable if it exists on removable
   media and the media is no longer available at the server or the file
   system in whole has been destroyed or the file system has simply been
   removed from the server's name space (i.e. unmounted in a Unix
   environment).

Expires: December 1999                                         [Page 12]

Draft Protocol Specification  NFS version 4                    June 1999

3.2.3.  Volatile File Handle

   A volatile file handle does not share the same longevity attributes
   of the persistent file handle.  The server may determine that a
   volatile file handle is no longer valid at many different points in
   time.  If the server can definitively determine that a volatile file
   handle refers to an object that has been removed, the server should
   return NFS4ERR_STALE to the client (as is the case for persistent
   file handles).  In all other cases where the server determines that a
   volatile file handle can no longer be used, it should return an error
   of NFS4ERR_EXPIRED.

   The following table shows the most common points at which a volatile
   file handle may expire.  This table represents the view from the
   client's perspective and as such provides columns for when the file
   may be open or closed by the client.

           Server Provides Persistent or Volatile File Handle
                                         File Open        File Closed
   ___________________________________________________________________
   Restart of Server (note 4)            P / V            P / V
   Fileset Migration (note 5)            P / V            P / V
   SHARE/LOCK recovery                   P / V            N/A (note 1)
   Client RENAMEs object                 P / V            P / V
   Client RENAMEs path to object         P / V            P / V
   Other client RENAMEs object           P / V            P / V
   Other client RENAMEs path to object   P / V            P / V
   Client REMOVEs object                 P / V (note 2)   P / V
   Other client REMOVEs object           P / V            N/A (note 3)

   Note 1
     If the file is not open, persistence of the file handle is not
     applicable for the recovery of SHARE/LOCK.

   Note 2
     With NFS version 2 and 3, when the client removes a file it has
     open it follows the convention of RENAMEing the file to '.nfsXXXX'
     until the file is closed.  At this point the REMOVE is done at the
     server.

        If this same model is used for v4 then this entry will be
        'N/A'.

   Note 3
     If the file is not open by the client, then it should not expect
     any cached file handle to be valid.

Expires: December 1999                                         [Page 13]

Draft Protocol Specification  NFS version 4                    June 1999

   Note 4
     The restart of the NFS server signifies when the operating system
     or NFS software is (re)started.  This also includes High
     Availability configurations where a separate operating system
     instantiation acquires ownership of the file system resources and
     network resources (i.e. disks and IP addresses).

   Note 5
     Fileset migration occurs when a the ownership of file system
     resources are transfered from one server to another without a
     transfer of ownership of the network resources.  So this differs
     from the High Availability scenario.  This also includes the move
     of a file system resources within the same server such that the
     fsid value is different.

        The fileset migration entry is a place holder until a file
        set migration proposal has been fully evaluated and decided
        upon.

3.2.4.  One Method of Constructing a Volatile File Handle

   As mentioned, in some instances a file handle is stale (no longer
   valid, perhaps because the file was removed from the server), or it
   is expired (the underlying file is valid, but since the file handle
   is volatile, it may have expired).  Thus the server needs to be able
   to return NFS4ERR_STALE in the former case, and NFS4ERR_EXPIRED in
   the latter case. This can be done by careful construction of the
   volatile file handle.  One possible implementation follows.

   A volatile file handle, while opaque to the client could contain:

   [volatile bit = 1 | server boot time | slot | generation number]

   o    slot is an index in the server volatile file handle table

   o    generation number is the generation number for the table
        entry/slot

   If the server boot time is less than the current server boot time,
   return NFS4ERR_EXPIRED. If slot is out of range, return
   NFS4ERR_EXPIRED.  If the generation number does not match, return
   NFS4ERR_EXPIRED.

   When the server reboots, the table is gone (it is volatile).

Expires: December 1999                                         [Page 14]

Draft Protocol Specification  NFS version 4                    June 1999

   If volatile bit is 0, then it is a persistent file handle with a
   different structure following it.

3.3.  Client Recovery from File Handle Expiration

   With the introduction of the volatile file handle, the client must
   take on additional responsibility so that it may prepare itself to
   recover from the expiration of a volatile file handle.  If the server
   is return persistent file handles, the client does not need these
   additional steps.

   For volatile file handles, most commonly the client will need to
   store the component names leading up to and including the file system
   object in question.  With these names, the client should be able to
   recover by finding a file handle in the name space that is still
   available or by starting at the root of the server's file system name
   space.

   If the expired file handle refers to an object that has been removed
   from the file system, obviously the client will not be able to
   recover from the expired file handle.

   It is also possible that the expired file handle, refers to a file
   that has been renamed.  If the file was renamed by another client,
   again it is possible that the original client will not be able to
   recover.  However, in the case that the client itself is renaming the
   file and the file is open, it is possible that the client may be able
   to recover.  The client can determine the new path name based on the
   processing of the rename request.  The client can then regenerate the
   new file handle based on the new path name.  The client could also
   use the compound operation mechanism to construct a set of operations
   like:
           RENAME A B
           LOOKUP B
           GETFH

Expires: December 1999                                         [Page 15]

Draft Protocol Specification  NFS version 4                    June 1999

4.  Basic Data Types

   Arguments and results from operations will be described in terms of
   basic XDR types defined in [RFC1832].  The following data types will
   be defined in terms of basic XDR types:

   filehandle: opaque <128>

        An NFS version 4 filehandle.  A filehandle with zero length is
        recognized as a "public" filehandle.

   utf8string:  opaque <>

        A counted array of octets that contains a UTF-8 string.

        Note: Section 11, Internationalization, covers the rational of
        using UTF-8.

   bitmap: uint32 <>

        A counted array of 32 bit integers used to contain bit values.
        The position of the integer in the array that contains bit n can
        be computed from the expression (n / 32) and its bit within that
        integer is (n mod 32).

                                      0            1
                    +-----------+-----------+-----------+--
                    |  count    | 31  ..  0 | 63  .. 32 |
                    +-----------+-----------+-----------+--

   createverf: opaque<8>

        Verify used for exclusive create semantics

   nfstime4
         struct nfstime4 {
             int64_t seconds;
             uint32_t nseconds;
         }

        The nfstime4 structure gives the number of seconds and
        nanoseconds since midnight or 0 hour January 1, 1970 Coordinated
        Universal Time (UTC).  Values greater than zero for the seconds
        field denote dates after the 0 hour January 1, 1970.  Values
        less than zero for the seconds field denote dates before the 0
        hour January 1, 1970.  In both cases, the nseconds field is to
        be added to the seconds field for the final time representation.
        For example, if the time to be represented is one-half second

Expires: December 1999                                         [Page 16]

Draft Protocol Specification  NFS version 4                    June 1999

        before 0 hour January 1, 1970, the seconds field would have a
        value of negative one (-1) and the nseconds fields would have a
        value of one-half second (500000000).  Values greater than
        999,999,999 for nseconds are considered invalid.

        This data type is used to pass time and date information.  A
        server converts to and from local time when processing time
        values, preserving as much accuracy as possible. If the
        precision of timestamps stored for a file system object is less
        than defined, loss of precision can occur.  An adjunct time
        maintenance protocol is recommended to reduce client and server
        time skew.

   specdata4
         struct specdata4 {
             uint32_t specdata1;
             uint32_t specdata2;
         }

        This data type represents additional information for the device
        file types NFCHR and NFBLK.

Expires: December 1999                                         [Page 17]

Draft Protocol Specification  NFS version 4                    June 1999

5.  File Attributes

   To meet the NFS Version 4 requirements of extensibility and increased
   interoperability with non-Unix platforms, attributes must be handled
   in a more flexible manner.  The NFS Version 3 fattr3 structure
   contained a fixed list of attributes that not all clients and servers
   are able to support or care about, which cannot be extended as new
   needs crop up, and which provides no way to indicate non-support.
   With NFS Version 4, the client will be able to ask what attributes
   the server supports, and will be able to request only those
   attributes in which it is interested.

   To this end, attributes will be divided into three groups: mandatory,
   recommended and named.  Both mandatory and recommended attributes are
   supported in the NFS V4 protocol by a specific and well-defined
   encoding, and are identified by number.  They are requested by
   setting a bit in the bit vector sent in the GETATTR request; the
   server response includes a bit vector to list what attributes were
   returned in response.  New mandatory or recommended attributes may be
   added to the NFS protocol between revisions by publishing a
   standards-track RFC which allocates a new attribute number value and
   defines the encoding for the attribute.

   Named attributes are accessed by the new OPENATTR operation, which
   accesses a hidden directory of attributes associated with a
   filesystem object.  OPENATTR takes a filehandle for the object and
   returns the filehandle for the attribute hierarchy, which is a
   directory object accessible by LOOKUP or READDIR, and which contains
   files whose names represent the named attributes and whose data bytes
   are the value of the attribute.  For example:

          LOOKUP     "foo"       ; look up file
          GETATTR    attrbits
          OPENATTR               ; access foo's named attributes
          LOOKUP     "x11icon"   ; look up specific attribute
          READ       0,4096      ; read stream of bytes

   Named attributes are intended primarily for data needed by
   applications rather than by an NFS client implementation per se; NFS
   implementors are strongly encouraged to define their new attributes
   as recommended attributes by bringing them to the working group.

   The set of attributes which are classified as mandatory is
   deliberately small, since servers must do whatever it takes to
   support them.  The recommended attributes may be unsupported, though
   a server should support as many as it can.  Attributes are deemed

Expires: December 1999                                         [Page 18]

Draft Protocol Specification  NFS version 4                    June 1999

   mandatory if the data is both needed by a large number of clients and
   is not otherwise reasonably computable by the client when support is
   not provided on the server.

5.1.  Mandatory Attributes

   These MUST be supported by every NFS Version 4 client and server in
   order to ensure a minimum level of interoperability.  The server must
   store and return these attributes, and the client must be able to
   function with an attribute set limited to these attributes, though
   some operations may be impaired or limited in some ways in this case.
   A client may ask for any of these attributes to be returned by
   setting a bit in the GETATTR request, and the server must return
   their value.

5.2.  Recommended Attributes

   These attributes are understood well enough to warrant support in the
   NFS Version 4 protocol, though they may not be supported on all
   clients and servers.  A client may ask for any of these attributes to
   be returned by setting a bit in the GETATTR request, but must be able
   to deal with not receiving them.  A client may ask for the set of
   attributes the server supports and should not request attributes the
   server does not support.  A server should be tolerant of requests for
   unsupported attributes, and simply not return them, rather than
   considering the request an error.  It is expected that servers will
   support all attributes they comfortably can, and only fail to support
   attributes which are difficult to support in their operating
   environments.  A server should provide attributes whenever they don't
   have to "tell lies" to the client.  For example, a file modification
   time should be either an accurate time or should not be supported by
   the server.  This will not always be comfortable to clients but it
   seems that the client has a better ability to fabricate or construct
   an attribute or do without.

   Most attributes from NFS V3's FSINFO, FSSTAT and PATHCONF procedures
   have been added as recommended attributes, so that filesystem info
   may be collected via the filehandle of any object the filesystem.
   This renders those procedures unnecessary in NFS V4.  If a server
   supports any per-filesystem attributes, it must support the fsid
   attribute so that the client may always determine when filesystems
   are crossed so that it can work correctly with these attributes.

Expires: December 1999                                         [Page 19]

Draft Protocol Specification  NFS version 4                    June 1999

5.3.  Named Attributes

   These attributes are not supported by direct encoding in the NFS
   Version 4 protocol but are accessed by string names rather than
   numbers and correspond to an uninterpreted stream of bytes which are
   stored with the filesystem object.  The namespace for these
   attributes may be accessed by using the OPENATTR operation to get a
   filehandle for a virtual "attribute directory" and using READDIR and
   LOOKUP operations on this filehandle.  Named attributes may then be
   examined or changed by normal READ and WRITE and CREATE operations on
   the filehandles returned from READDIR and LOOKUP.  Named attributes
   may have attributes, for example, a security label may have access
   control information in its own right.

   It is recommended that servers support arbitrary named attributes.  A
   client should not depend on the ability to store any named attributes
   in the server's filesystem.  If a server does support named
   attributes, a client which is also able to handle them should be able
   to copy a file's data and meta-data with complete transparency from
   one location to another; this would imply that there should be no
   attribute names which will be considered illegal by the server.

   Names of attributes will not be controlled by a standards body.
   However, vendors and application writers are encouraged to register
   attribute names and the interpretation and semantics of the stream of
   bytes via informational RFC so that vendors may interoperate where
   common interests exist.

5.4.  Mandatory Attributes - Definitions

   Name              #   DataType     Access   Description
   __________________________________________________________________
   supp_attr         0   bitmap       READ
                                               The bit vector which
                                               would retrieve all
                                               mandatory and
                                               recommended attributes
                                               which may be requested
                                               for this object.

                                               The client must ask
                                               this question to
                                               request correct
                                               attributes.

Expires: December 1999                                         [Page 20]

Draft Protocol Specification  NFS version 4                    June 1999

   object_type       1   nfs4_ftype   READ
                                               The type of the object
                                               (file, directory,
                                               symlink)

                                               The client cannot
                                               handle object
                                               correctly without
                                               type.

   persistent_fh     2   boolean      READ
                                               Is the filehandle for
                                               this object
                                               persistent?

                                               Server should know if
                                               the file handles being
                                               provided are
                                               persistent or not.  If
                                               the server is not able
                                               to make this
                                               determination, then it
                                               can choose volatile or
                                               non-persistent.

   change            3   uint64       READ
                                               A value created by the
                                               server that the client
                                               can use to determine
                                               if a file data,
                                               directory contents or
                                               attributes have been
                                               modified.  The server
                                               can just return the
                                               file mtime in this
                                               field though if a more
                                               precise value exists
                                               then it can be
                                               substituted, for
                                               instance, a sequence
                                               number.

                                               Necessary for any
                                               useful caching, likely
                                               to be available.

   object_size       4   uint64       R/W
                                               The size of the object
                                               in bytes.

                                               Could be very
                                               expensive to derive,
                                               likely to be
                                               available.

Expires: December 1999                                         [Page 21]

Draft Protocol Specification  NFS version 4                    June 1999

   link_support      5   boolean      READ
                                               Does the object's
                                               filesystem supports
                                               hard links?

                                               Server can easily
                                               determine if links are
                                               supported.

   symlink_support   6   boolean      READ
                                               Does the object's
                                               filesystem supports
                                               symbolic links?

                                               Server can easily
                                               determine if links are
                                               supported.

   named_attr        7   boolean      READ
                                               Does this object have
                                               named attributes?

   fsid.major        8   uint64       READ
                                               Unique filesystem
                                               identifier for the
                                               filesystem holding
                                               this object.

   fsid.minor        9   uint64       READ
                                               Unique filesystem
                                               identifier within the
                                               fsid.major filesystem
                                               identifier for the
                                               filesystem holding
                                               this object.

5.5.  Recommended Attributes - Definitions

   Name               #    Data Type   Access   Description
   ___________________________________________________________________
   ACL                10   nfsacl4     R/W
                                                The access control
                                                list for the object.
                                                [The nature and format
                                                of ACLs is still to be
                                                determined.]

Expires: December 1999                                         [Page 22]

Draft Protocol Specification  NFS version 4                    June 1999

   archive            11   boolean     R/W
                                                Whether or not this
                                                file has been archived
                                                since the time of last
                                                modification
                                                (deprecated in favor
                                                of backup_time).

   cansettime         12   boolean     READ
                                                Whether or not this
                                                object's filesystem
                                                can fill in the times
                                                on a SETATTR request
                                                without an explicit
                                                time.

   case_insensitive   13   boolean     READ
                                                Are filename
                                                comparisons on this
                                                filesystem case
                                                insensitive?

   case_preserving    14   boolean     READ
                                                Is filename case on
                                                this filesystem
                                                preserved?

   chown_restricted   15   boolean     READ
                                                Will a request to
                                                change ownership be
                                                honored?

   filehandle         16   nfs4_fh     READ
                                                The filehandle of this
                                                object (primarily for
                                                readdir requests).

   fileid             17   uint64      READ
                                                A number uniquely
                                                identifying the file
                                                within the filesystem.

   files_avail        18   uint64      READ
                                                File slots available
                                                to this user on the
                                                filesystem containing
                                                this object - this
                                                should be the smallest
                                                relevant limit.

   files_free         19   uint64      READ
                                                Free file slots on the
                                                filesystem containing
                                                this object - this
                                                should be the smallest
                                                relevant limit.

Expires: December 1999                                         [Page 23]

Draft Protocol Specification  NFS version 4                    June 1999

   files_total        20   uint64      READ
                                                Total file slots on
                                                the filesystem
                                                containing this
                                                object.

   hidden             21   boolean     R/W
                                                Is file considered
                                                hidden?

   homogeneous        22   boolean     READ
                                                Whether or not this
                                                object's filesystem is
                                                homogeneous, i.e.
                                                whether pathconf is
                                                the same for all
                                                filesystem objects.

   maxfilesize        23   uint64      READ
                                                Maximum supported file
                                                size for the
                                                filesystem of this
                                                object.

   maxlink            24   uint32      READ
                                                Maximum number of
                                                links for this object.

   maxname            25   uint32      READ
                                                Maximum filename size
                                                supported for this
                                                object.

   maxread            26   uint64      READ
                                                Maximum read size
                                                supported for this
                                                object.

   maxwrite           27   uint64      READ
                                                Maximum write size
                                                supported for this
                                                object.  This
                                                attribute SHOULD be
                                                supported if the file
                                                is writable.  Lack of
                                                this attribute can
                                                lead to the client
                                                either wasting
                                                bandwidth or not
                                                receiving the best
                                                performance.

   mime_type          28   utf8<>      R/W
                                                MIME body type/subtype
                                                of this object.

Expires: December 1999                                         [Page 24]

Draft Protocol Specification  NFS version 4                    June 1999

   mode               29   uint32      R/W
                                                Unix-style permission
                                                bits for this object
                                                (deprecated in favor
                                                of ACLs)

   no_trunc           30   boolean     READ
                                                If a name longer than
                                                name_max is used, will
                                                an error be returned
                                                or will the name be
                                                truncated?

   numlinks           31   uint32      READ
                                                Number of links to
                                                this object.

   owner              32   utf8<>      R/W
                                                The string name of the
                                                owner of this object.

   owner_group        33   utf8<>      R/W
                                                The string name of the
                                                group of the owner of
                                                this object.

   quota_hard         34   uint64      READ
                                                Number of bytes of
                                                disk space beyond
                                                which the server will
                                                decline to allocate
                                                new space.

   quota_soft         35   uint64      READ
                                                Number of bytes of
                                                disk space at which
                                                the client may choose
                                                to warn the user about
                                                limited space.

   quota_used         36   uint64      READ
                                                Number of bytes of
                                                disk space occupied by
                                                the owner of this
                                                object on this
                                                filesystem.

   rawdev             37   specdata4   READ
                                                Raw device identifier.

Expires: December 1999                                         [Page 25]

Draft Protocol Specification  NFS version 4                    June 1999

   space_avail        38   uint64      READ
                                                Disk space in bytes
                                                available to this user
                                                on the filesystem
                                                containing this object
                                                - this should be the
                                                smallest relevant
                                                limit.

   space_free         39   uint64      READ
                                                Free disk space in
                                                bytes on the
                                                filesystem containing
                                                this object - this
                                                should be the smallest
                                                relevant limit.

   space_total        40   uint64      READ
                                                Total disk space in
                                                bytes on the
                                                filesystem containing
                                                this object.

   space_used         41   uint64      READ
                                                Number of filesystem
                                                bytes allocated to
                                                this object.

   system             42   boolean     R/W
                                                Whether or not this
                                                file is a system file.

   time_access        43   nfstime4    R/W
                                                The time of last
                                                access to the object.

   time_backup        44   nfstime4    R/W
                                                The time of last
                                                backup of the object.

   time_create        45   nfstime4    R/W
                                                The time of creation
                                                of the object. This
                                                attribute does not
                                                have any relation to
                                                the traditional Unix
                                                file attribute 'ctime'
                                                or 'change time'.

   time_delta         46   nfstime4    READ
                                                Smallest useful server
                                                time granularity.

   time_metadata      47   nfstime4    R/W
                                                The time of last
                                                meta-data modification
                                                of the object.

Expires: December 1999                                         [Page 26]

Draft Protocol Specification  NFS version 4                    June 1999

   time_modify        48   nfstime4    R/W
                                                The time since the
                                                epoch of last
                                                modification to the
                                                object.

   version            49   utf8<>      R/W
                                                Version number of this
                                                document.

   volatility         50   nfstime4    READ
                                                Approximate time until
                                                next expected change
                                                on this filesystem, as
                                                a measure of
                                                volatility.

Expires: December 1999                                         [Page 27]

Draft Protocol Specification  NFS version 4                    June 1999

6.  NFS Server Namespace

6.1.  Server Exports

   On a UNIX server the name-space describes all the files reachable by
   pathnames under the root directory "/". On a Windows NT server the
   name-space constitutes all the files on disks named by mapped disk
   letters.  NFS server administrators rarely make the entire server's
   file-system name-space available to NFS clients.  Typically, pieces
   of the name-space are made available via an "export" feature.  The
   root filehandle for each export is obtained through the MOUNT
   protocol; the client sends a string that identifies the export of
   name-space and the server returns the root filehandle for it.  The
   MOUNT protocol supports an EXPORTS procedure that will enumerate the
   server's exports.

6.2.  Browsing Exports

   The NFS version 4 protocol provides a root filehandle that clients
   can use to obtain filehandles for these exports via a multi-component
   LOOKUP.  A common user experience is to use a graphical user
   interface (perhaps a file "Open" dialog window) to find a file via
   progressive browsing through a directory tree. The client must be
   able to move from one export to another export via single-component,
   progressive LOOKUP operations.

   This style of browsing is not well supported by NFS version 2 and 3
   protocols.  The client expects all LOOKUP operations to remain within
   a single server file-system, i.e. the device attribute will not
   change.  This prevents a client from taking name-space paths that
   span exports.

   An automounter on the client can obtain a snapshot of the server's
   name-space using the EXPORTS procedure of the MOUNT protocol. If it
   understands the server's pathname syntax, it can create an image of
   the server's name-space on the client.  The parts of the name-space
   that are not exported by the server are filled in with a "pseudo
   file-system" that allows the user to browse from one mounted file-
   system to another.  There is a drawback to this representation of the
   server's name-space on the client: it is static.  If the server
   administrator adds a new export the client will be unaware of it.

Expires: December 1999                                         [Page 28]

Draft Protocol Specification  NFS version 4                    June 1999

6.3.  Server Pseudo File-System

   NFS version 4 servers avoid this name-space inconsistency by
   presenting all the exports within the framework of a single server
   name-space.  An NFS version 4 client uses LOOKUP and READDIR
   operations to browse seamlessly from one export to another. Portions
   of the server name-space that are not exported are bridged via a
   "pseudo file-system" that provides a view only of exported
   directories. The pseudo file-system has a unique fsid and behaves
   like a normal, read-only file-system.

6.4.  Multiple Roots

   DOS, Windows 95, 98 and NT are sometimes described as having
   "multiple roots".  File-Systems are commonly represented as disk
   letters.  MacOS represents file-systems as top-level names.  NFS
   version 4 servers for these platforms can construct a pseudo file-
   system above these root names so that disk letters or volume names
   are simply directory names in the pseudo-root.

6.5.  Filehandle Volatility

   The nature of the server's pseudo file-system is that it is a logical
   representation of file-system(s) available from the server.
   Therefore, the pseudo file-system is most likely constructed
   dynamically when the NFS version 4 is first instantiated.  It is
   expected the pseudo file-system may not have an on-disk counterpart
   from which persistent filehandles could be constructed.  Even though
   it is preferable that the server provide persistent filehandles for
   the pseudo file-system, the NFS client should expect that pseudo
   file-system file-handles are volatile.  This can be confirmed by
   checking the associated "persistent_fh" attribute for those
   filehandles in question.  If the filehandles are volatile, the NFS
   client must be prepared to recover a filehandle value (i.e. with a v4
   multi-component LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.

6.6.  Exported Root

   If the server's root file-system is exported, it might be easy to
   conclude that a pseudo-file-system is not needed.  This would be
   wrong.  Assume the following file-systems on a server:

           /       disk1  (exported)
           /a      disk2  (not exported)

Expires: December 1999                                         [Page 29]

Draft Protocol Specification  NFS version 4                    June 1999

           /a/b    disk3  (exported)

   Because disk2 is not exported, disk3 cannot be reached with simple
   LOOKUPs.  The server must bridge the gap with a pseudo-file-system.

6.7.  Mount Point Crossing

   The server file-system environment may constructed in such a way that
   one file-system contains a directory which is 'covered' or mounted
   upon by a second file-system. For example:

           /a/b            (file system 1)
           /a/b/c/d        (file system 2)

   The pseudo file-system for this server may be constructed to look
   like:

           /               (place holder/not exported)
           /a/b            (file system 1)
           /a/b/c/d        (file system 2)

   It is the server's responsibility to present the pseudo file-system
   that is complete to the client.  If the client sends a lookup request
   for the path "/a/b/c/d", the server's response is the filehandle of
   the file system "/a/b/c/d".  In previous versions of NFS, the server
   would respond with the directory "/a/b/d/d" within the file-system
   "/a/b".

   The NFS client will be able to determine if it crosses a server mount
   point by a change in the value of the "fsid" attribute.

6.8.  Summary

   NFS version 4 provides LOOKUP and READDIR operations for browsing of
   NFS file-systems.  These operations are also used to browse server
   exports. A v4 server supports export browsing by including exported
   directories in a pseudo-file-system.  A browsing client can cross
   seamlessly between a pseudo-file-system and a real, exported file-
   system.  Clients must support volatile filehandles and recognize
   mount point crossing of server file-systems.

Expires: December 1999                                         [Page 30]

Draft Protocol Specification  NFS version 4                    June 1999

7.  File Locking

   Integrating locking into NFS necessarily causes it to be state-full,
   with the invasive nature of "share" file locks it becomes
   substantially more dependent on state than the traditional
   combination of NFS and NLM [XNFS].  There are three components to
   making this state manageable:

   o    Clear division between client and server

   o    Ability to reliably detect inconsistency in state between client
        and server

   o    Simple and robust recovery mechanisms

   In this model, the server owns the state information.  The client
   communicates its view of this state to the server as needed.  The
   client is also able to detect inconsistent state before modifying a
   file.

   To support Windows "share" locks, it is necessary to atomically open
   or create files.  Having a separate share/unshare operation will not
   allow correct implementation of the Windows OpenFile API.  In order
   to correctly implement share semantics, the existing mechanisms used
   when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be
   replaced.  NFS V4 will have an OPEN procedure that subsumes the
   functionality of LOOKUP, CREATE, and ACCESS.  However, because many
   operations require a file handle, the traditional LOOKUP is preserved
   to map a file name to file handle without establishing state on the
   server.  Policy of granting access or modifying files is managed by
   the server based on the client's state.  It is believed that these
   mechanisms can implement policy ranging from advisory only locking to
   full mandatory locking.  While ACCESS is just a subset of OPEN, the
   ACCESS procedure is maintained as a lighter weight mechanism.

7.1.  Definitions

   Lock      The term "lock" will be used to refer to both record
             (byte-range) locks as well as file (share) locks unless
             specifically stated otherwise.

   Client    Throughout this proposal the term "client" is used to
             indicate the entity that maintains a set of locks on behalf
             of one or more applications. The client is responsible for
             crash recovery of those locks it manages.  Multiple clients
             may share the same transport and multiple clients may exist

Expires: December 1999                                         [Page 31]

Draft Protocol Specification  NFS version 4                    June 1999

             on the same network node.

   Clientid  A 64-bit quantity returned by a server that uniquely
             corresponds to a client supplied Verifier and ID.

   Lease     An interval of time defined by the server for which the
             client is irrevokeably granted a lock.  At the end of a
             lease period the lock may be revoked if the lease has not
             been extended.  The lock must be revoked if a conflicting
             lock has been granted after the lease interval.  All leases
             granted by a server have the same fixed interval.

   Stateid   A 64-bit quantity returned by a server that uniquely
             defines the locking state granted by the server for a
             specific lock owner for a specific file.  A stateid
             composed of all bits 0 or all bits 1 have special meaning
             and are reserved.

   Verifier  A 32-bit quantity generated by the client that the server
             can use to determine if the client has restarted and lost
             all previous lock state.

7.2.  Locking

   It is assumed that manipulating a lock is rare when compared to I/O
   operations.  It is also assumed that crashes and network partitions
   are relatively rare.  Therefore it is important that I/O operations
   have a light weight mechanism to indicate if they possess a held
   lock.  A lock request contains the heavy weight information required
   to establish a lock and uniquely define the lock owner.

   The following sections describe the transition from the heavy weight
   information to the eventual stateid used for most client and server
   locking and lease interactions.

7.2.1.  Client ID

   For each LOCK request, the client must identify itself to the server.
   This is done in such a way as to allow for correct lock
   identification and crash recovery.  Client identification is
   accomplished with two values.

   o    A verifier that is used to detect client reboots.

   o    A variable length opaque array to uniquely define a client.

        For an operating system this may be a fully qualified host

Expires: December 1999                                         [Page 32]

Draft Protocol Specification  NFS version 4                    June 1999

        name or IP address, and for a user level NFS client it may
        additionally contain a process id or other unique sequence.

   The data structure for the Client ID would then appear as:
           struct nfs_client_id {
                   opaque verifier[4];
                   opaque id<>;
           }:

   It is possible through the mis-configuration of a client or the
   existence of a rogue client that two clients end up using the same
   nfs_client_id.  This situation is avoided by 'negotiating' the
   nfs_client_id between client and server with the use of the
   SETCLIENTID.  The following describes the two scenarios of
   negotiation.

   1    Client has never connected to the server

        In this case the client generates an nfs_client_id and
        unless another client has the same nfs_client_id.id field,
        the server accepts the request. The server also records the
        principal (or principal to uid mapping) from the credential
        in the RPC request that contains the nfs_client_id
        negotiation request.

        Two clients might still use the same nfs_client_id.id due
        to perhaps configuration error (say a High Availability
        configuration where the nfs_client_id.id is derived from
        the ethernet controller address and both systems have the
        same address).  In this case, nfs4err can be a switched
        union that returns in addition to NFS4ERR_CLID_IN_USE, the
        network address (the rpcbind netid and universal address)
        of the client that is using the id.

   2    Client is re-connecting to the server after a client reboot

        In this case, the client still generates an nfs_client_id
        but the nfs_client_id.id field will be the same as the
        nfs_client_id.id generated prior to reboot.  If the server
        finds that the principal/uid is equal to the previously
        "registered" nfs_client_id.id, then locks associated with
        the old nfs_client_id are immediately released.  If the
        principal/uid is not equal, then this is a rogue client and
        the request is returned in error.  For more discussion of
        crash recovery semantics, see the section on "Crash
        Recovery"

Expires: December 1999                                         [Page 33]

Draft Protocol Specification  NFS version 4                    June 1999

   In both cases, upon success, NFS4_OK is returned.  To help reduce the
   amount of data transferred on OPEN and LOCK, the server will also
   return a unique 64-bit clientid value that is a short hand reference
   to the nfs_client_id values presented by the client.  From this point
   forward, the client can use the clientid to refer to itself.

7.2.2.  nfs_lockowner and stateid definition

   When requesting a lock, the client must present to the server the
   clientid and an identifier for the owner of the requested lock.
   These two fields are referred to as the nfs_lockowner and the
   definition of those fields are:

   o    A clientid returned by the server as part of the clients use of
        the SETCLIENTID procedure

   o    A variable length opaque array used to uniquely define the owner
        of a lock managed by the client.

        This may be a thread id, process id, or other unique value.

   When the server grants the lock it responds with a unique 64-bit
   stateid.  The stateid is used as a short hand reference to the
   nfs_lockowner, since the server will be maintaining the
   correspondence between them.

7.2.3.  Use of the stateid

   All I/O requests contain a stateid.  If the nfs_lockowner performs
   I/O on a range of bytes within a locked range, the stateid returned
   by the server must be used to indicate the appropriate lock (record
   or share) is held. If no state is established by the client, either
   record lock or share lock, a stateid of all bits 0 is used.  If no
   conflicting locks are held on the file, the server may grant the I/O
   request.  If a conflict with an explicit lock occurs, the request is
   failed (NFS4ERR_LOCKED). This allows "mandatory locking" to be
   implemented.

   A stateid of all bits 1 allows read requests to bypass locking checks
   at the server.  However, write requests with stateid with bits all 1
   does not bypass file locking requirements.

   An explicit lock may not be granted while an I/O operation with
   conflicting implicit locking is being performed.

Expires: December 1999                                         [Page 34]

Draft Protocol Specification  NFS version 4                    June 1999

   The byte range of a lock is indivisible.  A range may be locked,
   unlocked, or changed between read and write but may not have
   subranges unlocked or changed between read and write.  This is the
   semantics provided by Win32 but only a subset of the semantics
   provided by Unix.  It is expected that Unix clients can more easily
   simulate modifying subranges than Win32 servers adding this feature.

7.2.4.  Sequencing of lock requests

   Locking is different than most NFS operations as it requires "at-
   most-one" semantics that are not provided by ONC RPC.  In the face of
   retransmission or reordering, lock or unlock requests must have a
   well defined and consistent behavior.  To accomplish this each lock
   request contains a sequence number that is a monotonically increasing
   integer.  Different nfs_lockowners have different sequences.  The
   server maintains the last sequence number (L) received and the
   response that was returned.  If a request with a previous sequence
   number (r < L) is received it is silently ignored as its response
   must have been received before the last request (L) was sent.  If a
   duplicate of last request (r == L) is received, the stored response
   is returned.  If a request beyond the next sequence (r == L + 2) is
   received it is silently ignored.  Sequences are reinitialized
   whenever the client verifier changes.

7.3.  Blocking locks

   Some clients require the support of blocking locks.  The current
   proposal lacks a call-back mechanism, similar to NLM, to notify a
   client when the lock has been granted.  Clients have no choice but to
   continually poll for the lock, which presents a fairness problem.
   Two new lock types are added, READW and WRITEW used to indicate to
   the server that the client is requesting a blocking lock.  The server
   should maintain an ordered list of pending blocking locks.  When the
   conflicting lock is released, the server may wait the lease period
   for the first client to re-request the lock.  After the lease period
   expires the next waiting client request is allowed the lock.  Clients
   are required to poll at an interval sufficiently small that it is
   likely to acquire the lock in a timely manner.  The server is not
   required to maintain a list of pending blocked locks as it is used to
   increase fairness and not correct operation.  Because of the
   unordered nature of crash recovery, storing of lock state to stable
   storage would be required to guarantee ordered granting of blocking
   locks.

Expires: December 1999                                         [Page 35]

Draft Protocol Specification  NFS version 4                    June 1999

7.4.  Lease renewal

   The purpose of a lease is to allow a server to remove stale locks
   that are held by a client that has crashed or is otherwise
   unreachable.  It is not a mechanism for cache consistency and lease
   renewals may not be denied if the lease interval has not expired.
   Any I/O request that has been made with a valid stateid is a positive
   indication that the client is still alive and locks are being
   maintained.  This becomes an implicit renewal of the lease.  In the
   case no I/O has been performed within the lease interval, a lease can
   be renewed by having the client issue a zero length READ.  Because
   the nfs_lockowner contains a unique client value, any stateid for a
   client will renew all leases for locks held with the same client
   field.  This will allow very low overhead lease renewal that scales
   extremely well.  In the typical case, no extra RPC calls are needed
   and in the worst case one RPC is required every lease period
   regardless of the number of locks held by the client.

7.5.  Crash recovery

   The important requirement in crash recovery is that both the client
   and the server know when the other has failed.  Additionally it is
   required that a client sees a consistent view of data across server
   reboots.  I/O operations that may have been queued within the client
   or network buffers, cannot complete until after the client has
   successfully recovered the lock protecting the I/O operation.

   If a client fails, the server only needs to wait the lease period to
   allow conflicting locks.  If the client reinitializes within the
   lease period, it may be forced to wait the remainder of the period
   before resuming service.  To minimize this delay, lock requests
   contain a verifier field in the lock_owner, if the server receives a
   verifier field that does not match the existing verifier, the server
   knows that the client has lost all lock state and locks held for that
   client that do not match the current verifier may be released.  In a
   secure environment, a change in the verifier must only cause the
   locks held by the authenticated requester to be released in order to
   prevent a rogue user from freeing otherwise valid locks.  The
   verifier must have the same uniqueness properties of the COMMIT
   verifier.

   If the server fails and loses locking state, the server must wait the
   lease period before granting any new locks or allowing any I/O.  An
   I/O request during the grace period with an invalid stateid will fail
   with NFS4ERR_GRACE, the client will reissue the lock request with
   reclaim set to TRUE, and upon receiving a successful reply, the I/O
   may be reissued with the new stateid.  Any time a client receives an

Expires: December 1999                                         [Page 36]

Draft Protocol Specification  NFS version 4                    June 1999

   NFS4ERR_GRACE error it should start recovering all outstanding locks.
   A lock request during the grace period without reclaim set will also
   result in a NFS4ERR_GRACE, triggering the client recovery processing.
   A lock request outside the grace period with reclaim set will succeed
   only if the server can guarantee that no conflicting lock or I/O
   request has been granted since reboot.

   In the case of a network partition longer than the lease period, the
   server will have not received an implicit lease renewal and may free
   all locks held for the client, thus invalidating any stateid held by
   the client.  Subsequent reconnection will cause I/O with invalid
   stateid to fail with NFS4ERR_EXPIRED, the client will suitably notify
   the application holding the lock.  After the lease period has expired
   the server may optionally continue to hold the locks for the client.
   In this case, if a conflicting lock or I/O request is received, the
   lock must be freed to allow the client to detect possible corruption.
   When there is a network partition and the lease expires, the server
   must record on stable storage the client information relating to
   those leases.  This is to prevent the case where another client
   obtains the conflicting lock, frees the lock, and the server reboots.
   After the server recovers the original client may recover the network
   partition and attempt to reclaim the lock.  Without any state to
   indicate that a conflicting may have occurred, the client could get
   in an inconsistent state.  Storing just the client information is the
   minimal state necessary to detect this condition, but could lead to
   losing locks unnecessarily.  However this is considered to be a very
   rare event, and a sophisticated server could store more state
   completely eliminate any unnecessary locks being lost.

7.6.  Server revocation of locks

   The server can revoke the locks held by a client at any time, when
   the client detects revocation it must ensure its state matches that
   of the server.  If locks are revoked due to a server reboot, the
   client will receive a NFS4ERR_GRACE and normal crash recovery
   described above will be performed.

   The server may revoke a lock within the lease period, this is
   considered a rare event likely to be initiated only by a human (as
   part of an administration task).  The client may assume that only the
   file that caused the NFS4ERR_EXPIRED to be returned has lost the
   lock_owner's locks and notifies the holder appropriately.  The client
   can not assume the lease period has been renewed.

   The client not being able to renew the lease period is a relatively
   rare and unusual state.  Both sides will detect this state and can
   recover without data corruption.  The client must mark all locks held

Expires: December 1999                                         [Page 37]

Draft Protocol Specification  NFS version 4                    June 1999

   as "invalidated" and then must issue an I/O request, either a pending
   I/O or zero length read to revalidate the lock. If the response is
   success the lock is upgraded to valid, otherwise it was revoked by
   the server and the owner is notified.

7.7.  Share Reservations

   A share reservation is a mechanism to control access to a file.  It
   is a separate and independent mechanism from record locking.  When a
   client opens a file, it issues an OPEN request to the server
   specifying the type of access required (READ, WRITE, or BOTH) and the
   type of access to deny others (deny NONE, READ, WRITE, or BOTH).  If
   the OPEN fails the client will fail the applications open request.

   Pseudo-code definition of the semantics:

                if ((request.access & file_state.deny)) ||
                      (request.deny & file_state.access))
                              return (NFS4ERR_DENIED)

   Old DOS applications specify shares in compatibility mode.  Microsoft
   has indicated in the Win32 specification that it will be deprecated
   in the future and recommends that deny NONE be used.  This
   specification does not support compatibility mode.

7.8.  OPEN/CLOSE procedures

   To provide correct share semantics, a client MUST use the OPEN
   procedure to obtain the initial file handle and indicate the desired
   access and what if any access to deny.  Even if the client intends to
   use a stateid of all 0's or all 1's, it must still obtain the
   filehandle for the regular file with the OPEN procedure.  For clients
   that do not have a deny mode built into their open API, deny equal to
   NONE should be used.

   The OPEN procedure with the CREATE flag, also subsumes the CREATE
   procedure for regular files as used in previous versions of NFS,
   allowing a create with a share to be done atomicly.

        Will expand on create semantics here.

   The CLOSE procedure removes all share locks held by the lock_owner on
   that file.  If record locks are held they should be explicitly

Expires: December 1999                                         [Page 38]

Draft Protocol Specification  NFS version 4                    June 1999

   unlocked.  Some servers may not support the CLOSE of a file that
   still has record locks held; if so, CLOSE will fail and return an
   error.

   The LOOKUP procedure is preserved and will return a file handle
   without establishing any lock state on the server. Without a valid
   stateid, the server will assume the client has the least access.  For
   example, a file opened with deny READ/WRITE cannot be accessed using
   a file handle obtained through LOOKUP.

Expires: December 1999                                         [Page 39]

Draft Protocol Specification  NFS version 4                    June 1999

8.  Defined Error Numbers

   NFS error numbers are assigned to failed operations within a compound
   request.  A compound request contains a number of NFS operations that
   have their results encoded in sequence in a compound reply.  The
   results of successful operations will consist of an NFS4_OK status
   followed by the encoded results of the operation.  If an NFS
   operation fails, an error status will be entered in the reply and the
   compound request will be terminated.

   A description of each defined error follows:

   NFS4_OK               Indicates the operation completed successfully.

   NFS4ERR_PERM          Not owner. The operation was not allowed
                         because the caller is either not a privileged
                         user (root) or not the owner of the target of
                         the operation.

   NFS4ERR_NOENT         No such file or directory. The file or
                         directory name specified does not exist.

   NFS4ERR_IO            I/O error. A hard error (for example, a disk
                         error) occurred while processing the requested
                         operation.

   NFS4ERR_NXIO          I/O error. No such device or address.

   NFS4ERR_ACCES         Permission denied. The caller does not have the
                         correct permission to perform the requested
                         operation. Contrast this with NFS4ERR_PERM,
                         which restricts itself to owner or privileged
                         user permission failures.

   NFS4ERR_EXIST         File exists. The file specified already exists.

   NFS4ERR_XDEV          Attempt to do a cross-device hard link.

   NFS4ERR_NODEV         No such device.

Expires: December 1999                                         [Page 40]

Draft Protocol Specification  NFS version 4                    June 1999

   NFS4ERR_NOTDIR        Not a directory. The caller specified a non-
                         directory in a directory operation.

   NFS4ERR_ISDIR         Is a directory. The caller specified a
                         directory in a non-directory operation.

   NFS4ERR_INVAL         Invalid argument or unsupported argument for an
                         operation. Two examples are attempting a
                         READLINK on an object other than a symbolic
                         link or attempting to SETATTR a time field on a
                         server that does not support this operation.

   NFS4ERR_FBIG          File too large. The operation would have caused
                         a file to grow beyond the server's limit.

   NFS4ERR_NOSPC         No space left on device. The operation would
                         have caused the server's file system to exceed
                         its limit.

   NFS4ERR_ROFS          Read-only file system. A modifying operation
                         was attempted on a read-only file system.

   NFS4ERR_MLINK         Too many hard links.

   NFS4ERR_NAMETOOLONG   The filename in an operation was too long.

   NFS4ERR_NOTEMPTY      An attempt was made to remove a directory that
                         was not empty.

   NFS4ERR_DQUOT         Resource (quota) hard limit exceeded. The
                         user's resource limit on the server has been
                         exceeded.

   NFS4ERR_STALE         Invalid file handle. The file handle given in
                         the arguments was invalid. The file referred to
                         by that file handle no longer exists or access
                         to it has been revoked.

Expires: December 1999                                         [Page 41]

Draft Protocol Specification  NFS version 4                    June 1999

   NFS4ERR_BADHANDLE     Illegal NFS file handle. The file handle failed
                         internal consistency checks.

   NFS4ERR_NOT_SYNC      Update synchronization mismatch was detected
                         during a SETATTR operation.

   NFS4ERR_BAD_COOKIE    READDIR cookie is stale.

   NFS4ERR_NOTSUPP       Operation is not supported.

   NFS4ERR_TOOSMALL      Buffer or request is too small.

   NFS4ERR_SERVERFAULT   An error occurred on the server which does not
                         map to any of the legal NFS version 4 protocol
                         error values.  The client should translate this
                         into an appropriate error.  UNIX clients may
                         choose to translate this to EIO.

   NFS4ERR_BADTYPE       An attempt was made to create an object of a
                         type not supported by the server.

   NFS4ERR_JUKEBOX       The server initiated the request, but was not
                         able to complete it in a timely fashion. The
                         client should wait and then try the request
                         with a new RPC transaction ID.  For example,
                         this error should be returned from a server
                         that supports hierarchical storage and receives
                         a request to process a file that has been
                         migrated. In this case, the server should start
                         the immigration process and respond to client
                         with this error.

   NFS4ERR_SAME          Returned if an NVERIFY operation shows that no
                         attributes have changed.

   NFS4ERR_DENIED        An attempt to lock a file is denied.  Since
                         this may be a temporary condition, the client
                         is encouraged to retry the lock request (with
                         exponential backoff of timeout) until the lock

Expires: December 1999                                         [Page 42]

Draft Protocol Specification  NFS version 4                    June 1999

                         is accepted.

   NFS4ERR_EXPIRED       A lease has expired that is being used in the
                         current procedure.

   NFS4ERR_LOCKED        A read or write operation was attempted on a
                         locked file.

   NFS4ERR_GRACE         The server is in its recovery or grace period
                         which should match the lease period of the
                         server.

   NFS4ERR_FHEXPIRED     The file handle provided is volatile and has
                         expired at the server.  The client should
                         attempt to recover the new file handle by
                         traversing the server's file system name space.
                         The file handle may have expired because the
                         server has restarted, the file system object
                         has been removed, or the file handle has been
                         flushed from the server's internal mappings.

        NOTE: This error definition will need to be crisp and match
        the section describing the volatile file handles.

   NFS4ERR_SHARE_DENIED  An attempt to OPEN a file with a share
                         reservation has failed because of a share
                         conflict.

   NFS4ERR_SAME          This error is returned by the NVERIFY operation
                         to signify that the attributes compared were
                         the same as provided in the client's request.

   NFS4ERR_WRONGSEC      The security mechanism being used by the client
                         for the procedure does not match the server's
                         security policy.  The client should change the
                         security mechanism being used and retry the
                         operation.

   NFS4ERR_CLID_INUSE    The SETCLIENTID procedure has found that a

Expires: December 1999                                         [Page 43]

Draft Protocol Specification  NFS version 4                    June 1999

                         client id is already in use by another client.

   NFS4ERR_RESOURCE      For the processing of the COMPOUND procedure,
                         the server may exhaust available resources and
                         can not continue processing procedures within
                         the COMPOUND operation.  This error will be
                         returned from the server in those instances of
                         resource exhaustion related to the processing
                         of the COMPOUND procedure.

Expires: December 1999                                         [Page 44]

Draft Protocol Specification  NFS version 4                    June 1999

9.  NFS Version 4 Requests

   For the NFS program, version 4, there are two traditional RPC
   procedures: NULL and COMPOUND.  All other procedures for NFS version
   4 are defined in normal XDR/RPC syntax and semantics except that
   these procedures are encapsulated within the COMPOUND request.  This
   requires that the client combine one or more NFSv4 procedures into a
   single request.

9.1.  Compound Procedure

   These compound requests provide the opportunity for better
   performance on high latency networks.  The client can avoid
   cumulative latency of multiple RPCs by combining multiple dependent
   operations into a single compound request.  A compound op may provide
   for protocol simplification by allowing the client to combine basic
   procedures into a single request that is customized for the client's
   environment.

   The basics of the COMPOUND procedures construction is:

                  +-----------+-----------+-----------+--
                  | op + args | op + args | op + args |
                  +-----------+-----------+-----------+--

   and the reply looks like this:

          +----------------+----------------+----------------+--
          | code + results | code + results | code + results |
          +----------------+----------------+----------------+--

   Where "code" is an indication of the success or failure of the
   operation including the opcode itself.

9.2.  Evaluation of a Compound Request

   The server will process the COMPOUND procedure by evaluating each of
   the procedures within the COMPOUND request in order.  Each component
   procedure or operation consists of a 32 bit operation code, followed
   by the argument of length determined by the type of operation. The
   results of each operation are encoded in sequence into a reply
   buffer.  The results of each operation are preceded by the opcode and
   a status code (normally zero).  If an operation results in a non-zero
   status code, the status will be encoded and evaluation of the
   compound sequence will halt and the reply will be returned.

Expires: December 1999                                         [Page 45]

Draft Protocol Specification  NFS version 4                    June 1999

   There are no atomicity requirements for the procedures contained
   within the COMPOUND procedure.  The procedures being evaluated as
   part of a COMPOUND request may and more than likely will be evaluated
   simultaneously with other COMPOUND requests that the server receives.

   It is the client's responsibility for recovering from any partially
   completed compound request.

   Each operation assumes a "current" filehandle that is available as
   part of the execution context of the compound request.  Operations
   may set, change, or return this filehandle.

Expires: December 1999                                         [Page 46]

Draft Protocol Specification  NFS version 4                    June 1999

10.  NFS Version 4 Procedures

10.1.  Procedure 0: NULL - No Operation

   SYNOPSIS

     <null>

   ARGUMENT

     void;

   RESULT

     void;

   DESCRIPTION

     Standard ONCRPC NULL procedure.  Void argument, void response.

   ERRORS

     None.

Expires: December 1999                                         [Page 47]

Draft Protocol Specification  NFS version 4                    June 1999

10.2.  Procedure 1: COMPOUND - Compound Operations

   SYNOPSIS

     compoundargs -> compoundres

   ARGUMENT

     union opunion switch (unsigned opcode) {
       case <OPCODE>: <argument>;
       ...
     };

     struct op {
       opunion ops;
     };

     struct COMPOUND4args {
       utf8string tag;
       op oplist<>;
     };

   RESULT

     struct COMPOUND4resok {
       utf8string tag;
       resultdata data<>;
     };

     union COMPOUND4res switch (nfsstat4 status){
      case NFS4_OK:
        COMPOUND4resok resok4;
      default:
        void;
     };

   DESCRIPTION

     The COMPOUND procedure is used to combine one or more of the NFS
     procedures into a single RPC request.  The main NFS RPC program has
     two main procedures: NULL and COMPOUND.  All other procedures use
     the COMPOUND procedure as a wrapper.

Expires: December 1999                                         [Page 48]

Draft Protocol Specification  NFS version 4                    June 1999

     In the processing of the COMPOUND procedure, the server may find
     that it does not have the available resources to execute any or all
     of the procedures within the COMPOUND sequence.  In this case, the
     error NFS4ERR_RESOURCE will be returned for the particular
     procedure within the COMPOUND operation where the resource
     exhaustion occurred.  This assume that all previous procedures
     within the COMPOUND sequence have been evaluated successfully.

   IMPLEMENTATION

     The COMPOUND procedure is used to combine individual procedures
     into a single RPC request.  The server interprets each of the
     procedures in turn.  If a procedure is executed by the server and
     the status of that procedure is NFS4_OK, then the next procedure in
     the COMPOUND procedure is executed.  The server continues this
     process until there are no more procedures to be executed or one of
     the procedures has a status value other than NFS4_OK.

   ERRORS

     NFS4ERR_RESOURCE

Expires: December 1999                                         [Page 49]

Draft Protocol Specification  NFS version 4                    June 1999

10.3.  Procedure 2: ACCESS - Check Access Permission

   SYNOPSIS

     (cfh), permbits -> permbits

   ARGUMENT

     const ACCESS4_READ= 0x0001;
     const ACCESS4_LOOKUP= 0x0002;
     const ACCESS4_MODIFY= 0x0004;
     const ACCESS4_EXTEND= 0x0008;
     const ACCESS4_DELETE= 0x0010;
     const ACCESS4_EXECUTE= 0x0020;

     struct ACCESS4args {
       /* CURRENT_FH: object */
       uint32_taccess;
     };

   RESULT

     struct ACCESS4resok {
       uint32_taccess;
     };

     union ACCESS4res switch (nfsstat4 status) {
      case NFS4_OK:
        ACCESS4resokresok;
      default:
        void;
     };

   DESCRIPTION

     ACCESS determines the access rights that a user, as identified by
     the credentials in the request, has with respect to a file system
     object. The client encodes the set of permissions that are to be
     checked in a bit mask.  The server checks the permissions encoded
     in the bit mask.  A status of NFS4_OK is returned along with a bit
     mask encoded with the permissions that the client is allowed.

Expires: December 1999                                         [Page 50]

Draft Protocol Specification  NFS version 4                    June 1999

     The results of this procedure are necessarily advisory in nature.
     That is, a return status of NFS4_OK and the appropriate bit set in
     the bit mask does not imply that such access will be allowed to the
     file system object in the future, as access rights can be revoked
     by the server at any time.

     The following access permissions may be requested:

          ACCESS_READ:   bit 1   Read data from file or read
                                 a directory.
        ACCESS_MODIFY:   bit 2   Rewrite existing file data or modify
                                 existing directory entries.
        ACCESS_LOOKUP:   bit 3   Look up a name in a
                                 directory (no meaning for
                                 non-directory objects).
        ACCESS_EXTEND:   bit 4   Write new data or add
                                 directory entries.
        ACCESS_DELETE:   bit 5   Delete an existing
                                 directory entry.
       ACCESS_EXECUTE:   bit 6   Execute file (no meaning
                                 for a directory).

     The server must return an error if the any access permission cannot
     be determined.

   IMPLEMENTATION

     In general, it is not sufficient for the client to attempt to
     deduce access permissions by inspecting the uid, gid, and mode
     fields in the file attributes, since the server may perform uid or
     gid mapping or enforce additional access control restrictions. It
     is also possible that the NFS version 4 protocol server may not be
     in the same ID space as the NFS version 4 protocol client. In these
     cases (and perhaps others), the NFS version 4 protocol client can
     not reliably perform an access check with only current file
     attributes.

     In the NFS version 2 protocol, the only reliable way to determine
     whether an operation was allowed was to try it and see if it
     succeeded or failed. Using the ACCESS procedure in the NFS version
     4 protocol, the client can ask the server to indicate whether or
     not one or more classes of operations are permitted.  The ACCESS
     operation is provided to allow clients to check before doing a

Expires: December 1999                                         [Page 51]

Draft Protocol Specification  NFS version 4                    June 1999

     series of operations. This is useful in operating systems (such as
     UNIX) where permission checking is done only when a directory is
     opened. This procedure is also invoked by NFS client access
     procedure (called possibly through access(2)). The intent is to
     make the behavior of opening a remote file more consistent with the
     behavior of opening a local file.

     For NFS version 4, the use of the ACCESS procedure when opening a
     regular file is deprecated in favor of using OPEN.

     The information returned by the server in response to an ACCESS
     call is not permanent. It was correct at the exact time that the
     server performed the checks, but not necessarily afterwards. The
     server can revoke access permission at any time.

     The NFS version 4 protocol client should use the effective
     credentials of the user to build the authentication information in
     the ACCESS request used to determine access rights. It is the
     effective user and group credentials that are used in subsequent
     read and write operations.

     Many implementations do not directly support the ACCESS_DELETE
     permission. Operating systems like UNIX will ignore the
     ACCESS_DELETE bit if set on an access request on a non-directory
     object. In these systems, delete permission on a file is determined
     by the access permissions on the directory in which the file
     resides, instead of being determined by the permissions of the file
     itself.  Thus, the bit mask returned for such a request will have
     the ACCESS_DELETE bit set to 0, indicating that the client does not
     have this permission.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_SERVERFAULT

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 52]

Draft Protocol Specification  NFS version 4                    June 1999

10.4.  Procedure 3: CLOSE - Close File

   SYNOPSIS

     (cfh), stateid -> stateid

   ARGUMENT

     struct CLOSE4args {
       stateid4stateid;
     };

   RESULT

     union CLOSE4res switch (nfsstat4 status) {
      case NFS4_OK:
        stateid4stateid;
      default:
        void;
     };

   DESCRIPTION

     The CLOSE procedure notifies the server that all share reservations
     corresponding to the client supplied stateid should be released.

   IMPLEMENTATION

     Share reservations for the matching stateid will be released on
     successful completion of the CLOSE procedure.

   ERRORS

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

Expires: December 1999                                         [Page 53]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_SERVERFAULT

     NFS4ERR_EXPIRED

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 54]

Draft Protocol Specification  NFS version 4                    June 1999

10.5.  Procedure 4: COMMIT - Commit Cached Data

   SYNOPSIS

     (cfh), offset, count -> verifier

   ARGUMENT

     struct COMMIT4args {
       /* CURRENT_FH: file */
       offset4offset;
       count4count;
     };

   RESULT

     struct COMMIT4resok {
       writeverf4verf;
     };

     union COMMIT4res switch (nfsstat4 status) {
      case NFS4_OK:
        COMMIT4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     The COMMIT procedure forces or flushes data to stable storage that
     was previously written with a WRITE operation which had the stable
     field set to UNSTABLE4.

     The offset provided by the client represents the position within
     the file at which the flush is to begin.  An offset value of 0
     (zero) means to flush data starting at the beginning of the file.
     The count as provided by the client is the number of bytes of data
     to flush. If count is 0 (zero), a flush from offset to the end of
     file is done.

     The server returns a write verifier upon successful completion of
     the COMMIT.  The write verifier is used by the client to determine
     if the server has restarted or rebooted between the initial

Expires: December 1999                                         [Page 55]

Draft Protocol Specification  NFS version 4                    June 1999

     WRITE(s) and the COMMIT.  The client does this by comparing the
     write verifier returned from the initial writes and the verifier
     returned by the COMMIT procedure.  The server must vary the value
     of the write verifier at each server event that may lead to a loss
     of uncommitted data.  Most commonly this occurs when the server is
     rebooted; however, other events at the server may result in
     uncommitted data loss as well.

   IMPLEMENTATION

     The COMMIT procedure is similar in operation and semantics to the
     POSIX fsync(2) system call that synchronizes a file's state with
     the disk (file data and metadata is flushed to disk or stable
     storage). COMMIT performs the same operation for a client, flushing
     any unsynchronized data and metadata on the server to the server's
     disk or stable storage for the specified file.  Like fsync(2), it
     may be that there is some modified data or no modified data to
     synchronize. The data may have been synchronized by the server's
     normal periodic buffer synchronization activity. COMMIT should
     return NFS4_OK, unless there has been an unexpected error.

     COMMIT differs from fsync(2) in that it is possible for the client
     to flush a range of the file (most likely triggered by a buffer-
     reclamation scheme on the client before file has been completely
     written).

     The server implementation of COMMIT is reasonably simple.  If the
     server receives a full file COMMIT request, that is starting at
     offset 0 and count 0, it should do the equivalent of fsync()'ing
     the file. Otherwise, it should arrange to have the cached data in
     the range specified by offset and count to be flushed to stable
     storage.  In both cases, any metadata associated with the file must
     be flushed to stable storage before returning. It is not an error
     for there to be nothing to flush on the server.  This means that
     the data and metadata that needed to be flushed have already been
     flushed or lost during the last server failure.

     The client implementation of COMMIT is a little more complex.
     There are two reasons for wanting to commit a client buffer to
     stable storage. The first is that the client wants to reuse a
     buffer. In this case, the offset and count of the buffer are sent
     to the server in the COMMIT request. The server then flushes any
     cached data based on the offset and count, and flushes any metadata
     associated with the file. It then returns the status of the flush
     and the write verifier.  The other reason for the client to
     generate a COMMIT is for a full file flush, such as may be done at

Expires: December 1999                                         [Page 56]

Draft Protocol Specification  NFS version 4                    June 1999

     close.  In this case, the client would gather all of the buffers
     for this file that contain uncommitted data, do the COMMIT
     operation with an offset of 0 and count of 0, and then free all of
     those buffers.  Any other dirty buffers would be sent to the server
     in the normal fashion.

     After a buffer is written by the client with stable parameter set
     to UNSTABLE, the buffer must be considered as modified by the
     client until the buffer has either been flushed via a COMMIT
     operation or written via a WRITE operation with stable parameter
     set to FILE_SYNC or DATA_SYNC. This is done to prevent the buffer
     from being freed and reused before the data can be flushed to
     stable storage on the server.

     When a response comes back from either a WRITE or a COMMIT
     operation and it contains a write verifier that is different than
     previously returned by the server, the client will need to
     retransmit all of the buffers containing uncommitted cached data to
     the server.  How this is to be done is up to the implementor.  If
     there is only one buffer of interest, then it should probably be
     sent back over in a WRITE request with the appropriate stable
     parameter. If there is more than one buffer, it might be worthwhile
     retransmitting all of the buffers in WRITE requests with the stable
     parameter set to UNSTABLE and then retransmitting the COMMIT
     operation to flush all of the data on the server to stable storage.
     The timing of these retransmissions is left to the implementor.

     The above description applies to page-cache-based systems as well
     as buffer-cache-based systems. In those systems, the virtual memory
     system will need to be modified instead of the buffer cache.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_LOCKED

     NFS4ERR_SERVERFAULT

Expires: December 1999                                         [Page 57]

Draft Protocol Specification  NFS version 4                    June 1999

10.6.  Procedure 5: CREATE - Create a Non-Regular File Object

   SYNOPSIS

     (cfh), name, type, how -> (cfh)

   ARGUMENT

     struct CREATE4args {
       /* CURRENT_FH: directory for creation */
       filename4objname;
       fattr4_typetype;
       createhow4createhow;
     };

   RESULT

     struct CREATE4res {
       nfsstat4status;
     };

   DESCRIPTION

     The CREATE procedure creates an non-regular file object in a
     directory with a given name.  The OPEN procedure MUST be used to
     create a regular file.

        The need for exclusive create semantics for non-regular
        files needs to be decided upon and decisions about storage
        location of the verifier will need to be determined as
        well.

   The objtype determines the type of object to be created: directory,
   symlink, etc.  The how union may have a value of UNCHECKED, GUARDED,
   and EXCLUSIVE. UNCHECKED means that the object should be created
   without checking for the existence of a duplicate object in the same
   directory. In this case, attrbits and attrvals describe the initial
   attributes for the file object. GUARDED specifies that the server
   should check for the presence of a duplicate object before performing
   the create and should fail the request with NFS4ERR_EXIST if a
   duplicate object exists. If the object does not exist, the request is

Expires: December 1999                                         [Page 58]

Draft Protocol Specification  NFS version 4                    June 1999

   performed as described for UNCHECKED.  EXCLUSIVE specifies that the
   server is to follow exclusive creation semantics, using the verifier
   to ensure exclusive creation of the target. No attributes may be
   provided in this case, since the server may use the target object
   meta-data to store the verifier.

   The current filehandle is replaced by that of the new object.

   IMPLEMENTATION
      The CREATE procedure carries support for EXCLUSIVE create forward
      from NFS version 3.  As in NFS version 3, this mechanism provides
      reliable exclusive creation.  Exclusive create is invoked when the
      how parameter is EXCLUSIVE.  In this case, the client provides a
      verifier that can reasonably be expected to be unique.  A
      combination of a client identifier, perhaps the client network
      address, and a unique number generated by the client, perhaps the
      RPC transaction identifier, may be appropriate.

      If the object does not exist, the server creates the object and
      stores the verifier in stable storage. For file systems that do
      not provide a mechanism for the storage of arbitrary file
      attributes, the server may use one or more elements of the object
      meta-data to store the verifier. The verifier must be stored in
      stable storage to prevent erroneous failure on retransmission of
      the request. It is assumed that an exclusive create is being
      performed because exclusive semantics are critical to the
      application. Because of the expected usage, exclusive CREATE does
      not rely solely on the normally volatile duplicate request cache
      for storage of the verifier. The duplicate request cache in
      volatile storage does not survive a crash and may actually flush
      on a long network partition, opening failure windows.  In the UNIX
      local file system environment, the expected storage location for
      the verifier on creation is the meta-data (time stamps) of the
      object. For this reason, an exclusive object create may not
      include initial attributes because the server would have nowhere
      to store the verifier.

      If the server can not support these exclusive create semantics,
      possibly because of the requirement to commit the verifier to
      stable storage, it should fail the CREATE request with the error,
      NFS4ERR_NOTSUPP.

      During an exclusive CREATE request, if the object already exists,
      the server reconstructs the object's verifier and compares it with
      the verifier in the request. If they match, the server treats the
      request as a success. The request is presumed to be a duplicate of
      an earlier, successful request for which the reply was lost and
      that the server duplicate request cache mechanism did not detect.

Expires: December 1999                                         [Page 59]

Draft Protocol Specification  NFS version 4                    June 1999

      If the verifiers do not match, the request is rejected with the
      status, NFS4ERR_EXIST.

      Once the client has performed a successful exclusive create, it
      must issue a SETATTR to set the correct object attributes.  Until
      it does so, it should not rely upon any of the object attributes,
      since the server implementation may need to overload object meta-
      data to store the verifier.

      Use of the GUARDED attribute does not provide exactly-once
      semantics.  In particular, if a reply is lost and the server does
      not detect the retransmission of the request, the procedure can
      fail with NFS4ERR_EXIST, even though the create was performed
      successfully.

        Note:

        1. Need to determine an initial set of attributes
           that must be set, and a set of attributes that
           can optionally be set, on a per-filetype basis.
           For instance, if the filetype is a NF4BLK then
           the device attributes must be set.

        2. Need to consider the symbolic link path as
           an "attribute".  No need for a READLINK op
           if this is so. Similarly, a filehandle could
           be defined as an attribute for LINK.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_EXIST

     NFS4ERR_NOTDIR

     NFS4ERR_INVAL

     NFS4ERR_NOSPC

     NFS4ERR_ROFS

Expires: December 1999                                         [Page 60]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_NAMETOOLONG

     NFS4ERR_DQUOT

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 61]

Draft Protocol Specification  NFS version 4                    June 1999

10.7.  Procedure 6: GETATTR - Get Attributes

   SYNOPSIS

     (cfh), attrbits -> attrbits, attrvals

   ARGUMENT

     struct GETATTR4args {
       /* CURRENT_FH: directory or file */
       bitmap4 attr_request;
     };

   RESULT

     struct GETATTR4resok {
       fattr4 obj_attributes;
     };

     union GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
        GETATTR4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     The GETATTR procedure will obtain attributes from the server.  The
     client sets a bit in the bitmap argument for each attribute value
     that it would like the server to return.  The server returns an
     attribute bitmap that indicates the attribute values for which it
     was able to return, followed by the attribute values ordered lowest
     attribute number first.

     The server must return a value for each attribute that the client
     requests if the attribute is supported by the server.  If the
     server does not support an attribute or cannot approximate a useful
     value then it must not return the attribute value and must not set
     the attribute bit in the result bitmap.  The server must return an
     error if it supports an attribute but cannot obtain its value.  In
     that case no attribute values will be returned.

Expires: December 1999                                         [Page 62]

Draft Protocol Specification  NFS version 4                    June 1999

     All servers must support attribute 0 (zero) which is a bitmap of
     all supported attributes for the filesystem object.

   IMPLEMENTATION

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 63]

Draft Protocol Specification  NFS version 4                    June 1999

10.8.  Procedure 7: GETFH - Get Current Filehandle

   SYNOPSIS

     (cfh) -> filehandle

   ARGUMENT

     /* CURRENT_FH: */
     void;

   RESULT

     struct GETFH4resok {
       nfs4_fh object;
     };

     union GETFH4res switch (nfsstat4 status) {
      case NFS4_OK:
        GETFH4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     Returns the current filehandle.  Operations that change the current
     filehandle like LOOKUP or CREATE to not automatically return the
     new filehandle as a result.  For instance, if a client needs to
     lookup a directory entry and obtain its filehandle then the
     following request is needed.

             1: PUTFH  (directory filehandle)
             2: LOOKUP (entry name)
             3: GETFH

   IMPLEMENTATION

Expires: December 1999                                         [Page 64]

Draft Protocol Specification  NFS version 4                    June 1999

   ERRORS

     NFS4ERR_SERVERFAULT

Expires: December 1999                                         [Page 65]

Draft Protocol Specification  NFS version 4                    June 1999

10.9.  Procedure 8: LINK - Create Link to a File

   SYNOPSIS

     (cfh), directory, newname -> (cfh)

   ARGUMENT

     struct LINK4args {
       /* CURRENT_FH: file */
       nfs4_fh dir;
       filename4 newname;
     };

   RESULT

     struct LINK4res {
       nfsstat4status;
     };

   DESCRIPTION

     The LINK procedure creates an additional newname for the file with
     the current filehandle in the new directory dir file and link.dir
     must reside on the same file system and server.

   IMPLEMENTATION

     Changes to any property of the hard-linked files are reflected in
     all of the linked files.  When a hard link is made to a file, the
     attributes for the file should have a value for nlink that is one
     greater than the value before the LINK.

     The comments under RENAME regarding object and target residing on
     the same file system apply here as well. The comments regarding the
     target name applies as well.

   ERRORS

     NFS4ERR_IO

Expires: December 1999                                         [Page 66]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_ACCES

     NFS4ERR_EXIST

     NFS4ERR_XDEV

     NFS4ERR_NOTDIR

     NFS4ERR_INVAL

     NFS4ERR_NOSPC

     NFS4ERR_ROFS

     NFS4ERR_MLINK

     NFS4ERR_NAMETOOLONG

     NFS4ERR_DQUOT

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 67]

Draft Protocol Specification  NFS version 4                    June 1999

10.10.  Procedure 9: LOCK - Create Lock

   SYNOPSIS

     (cfh) type, seqid, reclaim, owner, offset, length -> stateid,
     access

   ARGUMENT

     struct lockown {
       clientid4clientid;
       opaqueowner<>;
     };

     union nfs_lockowner switch (stateid4 stateid) {
      case 0:
        lockownident;
      default:
        void;
     };

     enum nfs4_lock_type {
       READ_LT = 1,
       WRITE_LT = 2,
       READW_LT = 3,/* blocking read */
       WRITEW_LT = 4/* blocking write */
     };

     struct LOCK4args {
       /* CURRENT_FH: file */
       nfs4_lock_typetype;
       seqid4seqid;
       boolreclaim;
       nfs_lockownerowner;
       offset4offset;
       length4length;
     };

   RESULT

     struct lockres {
       stateid4stateid;
       int32_taccess;
     };

Expires: December 1999                                         [Page 68]

Draft Protocol Specification  NFS version 4                    June 1999

     union LOCK4res switch (nfsstat4 status) {
      case NFS4_OK:
        lockresresult;
      default:
        void;
     };

   DESCRIPTION

     The LOCK procedure requests a record lock for the byte range
     specified by the offset and length parameters.  The lock type is
     also specified to be one of the nfs4_lock_types.  If this is a
     reclaim request, the reclaim parameter will be TRUE;

   IMPLEMENTATION

     The File Locking section contains a full description of this and
     the other file locking procedures.

   ERRORS

     NFS4ERR_ACCES

     NFS4ERR_ISDIR

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 69]

Draft Protocol Specification  NFS version 4                    June 1999

10.11.  Procedure 10: LOCKT - Test For Lock

   SYNOPSIS

     (cfh) type, seqid, reclaim, owner, offset, length -> {void,
     NFS4ERR_DENIED -> owner}

   ARGUMENT

     struct LOCK4args {
       /* CURRENT_FH: file */
       nfs4_lock_typetype;
       seqid4seqid;
       boolreclaim;
       nfs_lockownerowner;
       offset4offset;
       length4length;
     };

   RESULT

     union LOCKT4res switch (nfsstat4 status) {
      case NFS4ERR_DENIED:
        nfs_lockownerowner;
      case NFS4_OK:
        void;
      default:
        void;
     };

   DESCRIPTION

     The LOCKT procedure tests the lock as specified in the argument.
     The owner of the lock is returned in the event it is currently
     being held; if no lock is held, nothing other than NFS4_OK is
     returned.

   IMPLEMENTATION

     The File Locking section contains a full description of this and
     the other file locking procedures.

Expires: December 1999                                         [Page 70]

Draft Protocol Specification  NFS version 4                    June 1999

   ERRORS

     NFS4ERR_ACCES

     NFS4ERR_ISDIR

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_DENIED

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 71]

Draft Protocol Specification  NFS version 4                    June 1999

10.12.  Procedure 11: LOCKU - Unlock File

   SYNOPSIS

     (cfh) type, seqid, reclaim, owner, offset, length -> stateid

   ARGUMENT

     struct LOCK4args {
       /* CURRENT_FH: file */
       nfs4_lock_typetype;
       seqid4seqid;
       boolreclaim;
       nfs_lockownerowner;
       offset4offset;
       length4length;
     };

   RESULT

     union LOCKU4res switch (nfsstat4 status) {
      caseNFS4_OK:
        stateid4stateid_ok;
      default:
        stateid4stateid_oth;
     };

   DESCRIPTION

     The LOCKU procedure unlocks the record lock specified by the
     parameters.

   IMPLEMENTATION

     The File Locking section contains a full description of this and
     the other file locking procedures.

   ERRORS

     NFS4ERR_ACCES

Expires: December 1999                                         [Page 72]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_ISDIR

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 73]

Draft Protocol Specification  NFS version 4                    June 1999

10.13.  Procedure 12: LOOKUP - Lookup Filename

   SYNOPSIS

     (cfh), filenames -> (cfh)

   ARGUMENT

     struct LOOKUP4args {
       /* CURRENT_FH: directory */
       filename4 filenames<>;
     };

   RESULT

     struct LOOKUP4res {
       /* CURRENT_FH: object */
       nfsstat4status;
     };

   DESCRIPTION

     The current filehandle is assumed to refer to a directory.  LOOKUP
     evaluates the pathname contained in the array of names and obtains
     a new current filehandle from the final name. All but the final
     name in the list must be the names of directories.

     If the pathname cannot be evaluated either because a component
     doesn't exist or because the client doesn't have permission to
     evaluate a component of the path, then an error will be returned
     and the current filehandle will be unchanged.

   IMPLEMENTATION

     If the client prefers a partial evaluation of the path then a
     sequence of LOOKUP operations can be substituted e.g.

             1. PUTFH  (directory filehandle)
             2. LOOKUP "pub" "foo" "bar"
             3. GETFH

Expires: December 1999                                         [Page 74]

Draft Protocol Specification  NFS version 4                    June 1999

     or

             1. PUTFH  (directory filehandle)
             2. LOOKUP "pub"
             3. GETFH
             4. LOOKUP "foo"
             5. GETFH
             6. LOOKUP "bar"
             7. GETFH

     NFS version 4 servers depart from the semantics of previous NFS
     versions in allowing LOOKUP requests to cross mountpoints on the
     server. The client can detect a mountpoint crossing by comparing
     the fsid attribute of the directory with the fsid attribute of the
     directory looked up.  If the fsids are different then the new
     directory is a server mountpoint.  Unix clients that detect a
     mountpoint crossing will need to mount the server's filesystem.

     Servers that limit NFS access to "shares" or "exported" filesystems
     should provide a pseudo-filesystem into which the exported
     filesystems can be integrated, so that clients can browse the
     server's namespace.  The clients view of a pseudo filesystem will
     be limited to paths that lead to exported filesystems.

     Note: previous versions of the protocol assigned special semantics
     to the names "." and "..".  NFS version 4 assigns no special
     semantics to these names.  The LOOKUPP operator must be used to
     lookup a parent directory.

     Note that this procedure does not follow symbolic links.  The
     client is responsible for all parsing of filenames including
     filenames that are modified by symbolic links encountered during
     the lookup process.

   ERRORS

     NFS4ERR_NOENT

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_NOTDIR

     NFS4ERR_INVAL

     NFS4ERR_NAMETOOLONG

Expires: December 1999                                         [Page 75]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_STALE

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 76]

Draft Protocol Specification  NFS version 4                    June 1999

10.14.  Procedure 13: LOOKUPP - Lookup Parent Directory

   SYNOPSIS

     (cfh) -> (cfh)

   ARGUMENT

     /* CURRENT_FH: object */
     void;

   RESULT

     struct LOOKUPP4res {
       /* CURRENT_FH: directory */
       nfsstat4status;
     };

   DESCRIPTION

     The current filehandle is assumed to refer to a directory.  LOOKUPP
     assigns the filehandle for its parent directory to be the current
     filehandle.  If there is no parent directory an ENOENT error must
     be returned.

   IMPLEMENTATION

     As for LOOKUP, LOOKUPP will also cross mountpoints.

   ERRORS

     NFS4ERR_NOENT

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_STALE

Expires: December 1999                                         [Page 77]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

Expires: December 1999                                         [Page 78]

Draft Protocol Specification  NFS version 4                    June 1999

10.15.  Procedure 14: NVERIFY - Verify Difference in Attributes

   SYNOPSIS

     (cfh), attrbits, attrvals -> -

   ARGUMENT

     struct NVERIFY4args {
       /* CURRENT_FH: object */
       bitmap4 attr_request;
       fattr4 obj_attributes;
     };

   RESULT

     struct NVERIFY4res {
       nfsstat4status;
     };

   DESCRIPTION

     This operation is used to prefix a sequence of operations to be
     performed if one or more attributes have changed on some filesystem
     object.  If all the attributes match then the error NFS4ERR_SAME
     must be returned.

   IMPLEMENTATION

     This operation is useful as a cache validation operator.  If the
     object to which the attributes belong has changed then the
     following operations may obtain new data associated with that
     object.  For instance, to check if a file has been changed and
     obtain new data if it has:

             1. PUTFH  (public)
             2. LOOKUP "pub" "foo" "bar"
             3. NVERIFY attrbits attrs
             4. READ 0 32767

Expires: December 1999                                         [Page 79]

Draft Protocol Specification  NFS version 4                    June 1999

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

     NFS4ERR_SAME

Expires: December 1999                                         [Page 80]

Draft Protocol Specification  NFS version 4                    June 1999

10.16.  Procedure 15: OPEN - Open a Regular File

   SYNOPSIS

     (cfh), file, openhow, owner, seqid, reclaim, access, deny -> (cfh),
     stateid, access

   ARGUMENT

     struct OPEN4args {
       open_nameorfh   file;
             openflag        openhow;
             nfs_lockowner   owner;
             seqid4          seqid;
             bool            reclaim;
             int32_t         access;
             int32_t         deny;
     };

     union open_nameoffh switch (bool reclaim_fh) {
             case FALSE:
                     /* CURRENT_FH: directory */
                     filename4       filenames<>;
             case TRUE:
                     /* CURRENT_FH: file on reclaim */
                     void;
     };

     enum createmode4 {
             UNCHECKED       = 0,
             GUARDED         = 1,
             EXCLUSIVE       = 2
     };

     union createhow4 switch (createmode4 mode) {
             case UNCHECKED:
             case GUARDED:
                     fattr4          createattrs;
             case EXCLUSIVE:
                     createverf4     verf;
     };

     enum opentype4 {
       OPEN4_NOCREATE0,
       OPEN4_CREATE1
     };

Expires: December 1999                                         [Page 81]

Draft Protocol Specification  NFS version 4                    June 1999

     union openflag switch (opentype4 opentype) {
      case OPEN4_CREATE:
        createhow4how;
      default:
        void;
     };

     /*
      * Access and Deny constants for open argument
      */
     const OPEN4_ACCESS_READ = 0x0001;
     const OPEN4_ACCESS_WRITE= 0x0002;
     const OPEN4_ACCESS_BOTH = 0x0003;

     const OPEN4_DENY_NONE   = 0x0000;
     const OPEN4_DENY_READ   = 0x0001;
     const OPEN4_DENY_WRITE  = 0x0002;
     const OPEN4_DENY_BOTH   = 0x0003;

   RESULT

     union OPEN4res switch (nfsstat4 status) {
       case NFS4_OK:
       /* CURRENT_FH: opened file */
       LOCK4resresok;
       default:
       void;
     };

   DESCRIPTION

     The OPEN procedure creates and/or opens a regular file in a
     directory with the provided name.  If the file does not exist at
     the server and creation is desired, specification of the method of
     creation is provided by the openhow parameter.  The client has the
     choice of three creation methods: UNCHECKED, GUARDED, or EXCLUSIVE.

     UNCHECKED means that the file should be created without checking
     for the existence of a duplicate object in the same directory.  For
     this type of create, createattrs specifies the initial set of
     attributes for the file (NOTE: need to define exactly which
     attributes should be set and if the file exists, should the
     attributes be modified if the file exists).  If GUARDED is
     specified, the server checks for the presence of a duplicate object

Expires: December 1999                                         [Page 82]

Draft Protocol Specification  NFS version 4                    June 1999

     by name before performing the create.  If a duplicate exists, an
     error of NFS4ERR_EXIST is returned as the status.  If the object
     does not exist, the request is performed as described for
     UNCHECKED.

     EXCLUSIVE specifies that the server is to follow exclusive creation
     semantics, using the verifier to ensure exclusive creation of the
     target.  The server should check for the presence of a duplicate
     object by name.  If the object does not exist, the server creates
     the object and stores the verifier with the object.  If the object
     does exist and the stored verifier matches the client provided
     verifier, the server uses the existing object as the newly created
     object.  If the stored verifier does not match, then an error of
     NFS4ERR_EXIST is returned.  No attributes may be provided in this
     case, since the server may use an attribute of the target object to
     store the verifier.  (NOTE: does a specific attribute need to be
     specified for storage of verifier )

     Upon successful creation, the current filehandle is replaced by
     that of the new object.

     The OPEN procedure provides for DOS SHARE capability with the use
     of the access and deny fields of the OPEN arguments.  The client
     specifies at OPEN the required access and deny modes.  For clients
     that do not directly support SHAREs (i.e. Unix), the expected deny
     value is DENY_NONE.  In the case that there is a existing SHARE
     reservation that conflicts with the OPEN request, the server
     returns the error NFS4ERR_DENIED.  For a complete SHARE request,
     the client must provide values for the owner and seqid fields for
     the OPEN argument.  For additional discussion of SHARE semantics
     see the section on 'Share Reservations'.

     In the case that the client is recovering state from a server
     failure, the reclaim field of the OPEN argument is use to signify
     that the request is meant to reclaim state previously held.

     The file field of the OPEN argument allows the client to specify an
     open by name or by filehandle.  The filehandle MAY only be
     specified in the case that the OPEN is a reclaim request.  It is
     expected that if the server is providing persistent filehandles,
     the client will not have file names saved to request a reclaim OPEN
     by name.

     For non-reclaim OPEN requests that reach the server during its
     grace or lease expiration period, the server returns an error of
     NFS4ERR_GRACE.

Expires: December 1999                                         [Page 83]

Draft Protocol Specification  NFS version 4                    June 1999

   IMPLEMENTATION

     The OPEN procedure contains support for EXCLUSIVE create.  The
     mechanism is similar to the support in NFS version 3 [RFC1813].  As
     in NFS version 3, this mechanism provides reliable exclusive
     creation.  Exclusive create is invoked when the how parameter is
     EXCLUSIVE.  In this case, the client provides a verifier that can
     reasonably be expected to be unique.  A combination of a client
     identifier, perhaps the client network address, and a unique number
     generated by the client, perhaps the RPC transaction identifier,
     may be appropriate.

     If the object does not exist, the server creates the object and
     stores the verifier in stable storage. For file systems that do not
     provide a mechanism for the storage of arbitrary file attributes,
     the server may use one or more elements of the object meta-data to
     store the verifier. The verifier must be stored in stable storage
     to prevent erroneous failure on retransmission of the request. It
     is assumed that an exclusive create is being performed because
     exclusive semantics are critical to the application. Because of the
     expected usage, exclusive CREATE does not rely solely on the
     normally volatile duplicate request cache for storage of the
     verifier. The duplicate request cache in volatile storage does not
     survive a crash and may actually flush on a long network partition,
     opening failure windows.  In the UNIX local file system
     environment, the expected storage location for the verifier on
     creation is the meta-data (time stamps) of the object. For this
     reason, an exclusive object create may not include initial
     attributes because the server would have nowhere to store the
     verifier.

     If the server can not support these exclusive create semantics,
     possibly because of the requirement to commit the verifier to
     stable storage, it should fail the OPEN request with the error,
     NFS4ERR_NOTSUPP.

     During an exclusive CREATE request, if the object already exists,
     the server reconstructs the object's verifier and compares it with
     the verifier in the request. If they match, the server treats the
     request as a success. The request is presumed to be a duplicate of
     an earlier, successful request for which the reply was lost and
     that the server duplicate request cache mechanism did not detect.
     If the verifiers do not match, the request is rejected with the
     status, NFS4ERR_EXIST.

     Once the client has performed a successful exclusive create, it
     must issue a SETATTR to set the correct object attributes.  Until
     it does so, it should not rely upon any of the object attributes,

Expires: December 1999                                         [Page 84]

Draft Protocol Specification  NFS version 4                    June 1999

     since the server implementation may need to overload object meta-
     data to store the verifier.  The subsequent SETATTR must not occur
     in the same COMPOUND request as the OPEN.  This separation will
     guarantee that the exclusive create mechanism will continue to
     function properly in the face of retransmission of the request.

     Use of the GUARDED attribute does not provide exactly-once
     semantics.  In particular, if a reply is lost and the server does
     not detect the retransmission of the request, the procedure can
     fail with NFS4ERR_EXIST, even though the create was performed
     successfully.

     For SHARE reservations, the client must specify a value for access
     that is one of READ, WRITE, or BOTH.  For deny, the client must
     specify one of NONE, READ, WRITE, or BOTH.  If the client fails to
     do this, the server must return NFS4ERR_INVAL.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_EXIST

     NFS4ERR_NOTDIR

     NFS4ERR_NOSPC

     NFS4ERR_ROFS

     NFS4ERR_NAMETOOLONG

     NFS4ERR_DQUOT

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_SHARE_DENIED

     NFS4ERR_GRACE

Expires: December 1999                                         [Page 85]

Draft Protocol Specification  NFS version 4                    June 1999

10.17.  Procedure 16: OPENATTR - Open Named Attribute Directory

   SYNOPSIS

     (cfh) -> (cfh)

   ARGUMENT

     /* CURRENT_FH: file or directory */
     void;

   RESULT

     struct OPENATTR4res {
       /* CURRENT_FH: name attr directory*/
       nfsstat4status;
     };

   DESCRIPTION

     The OPENATTR procedure is used to obtain the filehandle of the
     named attribute directory associated with the current filehandle.
     The result of the OPENATTR will be a filehandle of type NF4ATTRDIR.
     From this filehandle, READDIR and LOOKUP procedures can be used to
     obtain filehandles for the various named attributes associated with
     the original file system object.  Filehandles returned within the
     named attribute directory will have a type of NF4NAMEDATTR.

   IMPLEMENTATION

     If the server does not support named attributes for the current
     filehandle, an error of NFS4ERR_NOTSUPP will be returned to the
     client.

   ERRORS

     NFS4ERR_NOENT

     NFS4ERR_IO

Expires: December 1999                                         [Page 86]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 87]

Draft Protocol Specification  NFS version 4                    June 1999

10.18.  Procedure 17: PUTFH - Set Current Filehandle

   SYNOPSIS

     filehandle -> (cfh)

   ARGUMENT

     struct PUTFH4args {
       nfs4_fh object;
     };

   RESULT

     struct PUTFH4res {
       /* CURRENT_FH: */
       nfsstat4status;
     };

   DESCRIPTION

     Replaces the current filehandle with the filehandle provided as an
     argument.

   IMPLEMENTATION

     Commonly used as the first operator in any NFS request to set the
     context for following operations.

   ERRORS

     NFS4ERR_SERVERFAULT

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 88]

Draft Protocol Specification  NFS version 4                    June 1999

10.19.  Procedure 18: PUTPUBFH - Set Public Filehandle

   SYNOPSIS

     - -> (cfh)

   ARGUMENT

     void;

   RESULT

     struct PUTPUBFH4res {
       /* CURRENT_FH: root fh */
       nfsstat4status;
     };

   DESCRIPTION

     Replaces the current filehandle with the filehandle that represents
     the public filehandle of the server's namespace.  This filehandle
     may be different from the "root" filehandle which may be associated
     with some other directory on the server.

   IMPLEMENTATION

     Used as the first operator in any NFS request to set the context
     for following operations.

   ERRORS

     NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 89]

Draft Protocol Specification  NFS version 4                    June 1999

10.20.  Procedure 19: PUTROOTFH - Set Root Filehandle

   SYNOPSIS

     - -> (cfh)

   ARGUMENT

     void;

   RESULT

     struct PUTROOTFH4res {
       /* CURRENT_FH: root fh */
       nfsstat4status;
     };

   DESCRIPTION

     Replaces the current filehandle with the filehandle that represents
     the root of the server's namespace.  From this filehandle a LOOKUP
     operation can locate any other filehandle on the server. This
     filehandle may be different from the "public" filehandle which may
     be associated with some other directory on the server.

   IMPLEMENTATION

     Commonly used as the first operator in any NFS request to set the
     context for following operations.

   ERRORS

     NFS4ERR_SERVERFAULT

     NFS4ERR_WRONTSEC

Expires: December 1999                                         [Page 90]

Draft Protocol Specification  NFS version 4                    June 1999

10.21.  Procedure 20: READ - Read from File

   SYNOPSIS

     (cfh), offset, count, stateid -> eof, data

   ARGUMENT

     struct READ4args {
       /* CURRENT_FH: file */
       stateid4stateid;
       offset4offset;
       count4count;
     };

   RESULT

     struct READ4resok {
       booleof;
       opaquedata<>;
     };

     union READ4res switch (nfsstat4 status) {
      case NFS4_OK:
        READ4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     The READ procedure reads data from the regular file identified by
     the current filehandle.

     The client provides an offset of where the READ is to start and a
     count of how many bytes are to be read.  An offset of 0 (zero)
     means to read data starting at the beginning of the file. If offset
     is greater than or equal to the size of the file, the status,
     NFS4_OK, is returned with a data length set to 0 (zero) and eof set
     to TRUE.  The READ is subject to access permissions checking.

     If the client specifies a count value of 0 (zero), the READ

Expires: December 1999                                         [Page 91]

Draft Protocol Specification  NFS version 4                    June 1999

     succeeds and returns 0 (zero) bytes of data again subject to access
     permissions checking.  The server may choose to return fewer bytes
     than specified by the client.  The client needs to check for this
     condition and handle the condition appropriately.

     The stateid value for a READ request represents a value returned
     from a previous record lock or share reservation request.  Used by
     the server to verify that the associated lock is still valid and to
     update lease timeouts for the client.

     If the read ended at the end-of-file (formally, in a correctly
     formed READ request, if offset + count is equal to the size of the
     file), eof is returned as TRUE; otherwise it is FALSE. A successful
     READ of an empty file will always return eof as TRUE.

   IMPLEMENTATION

     It is possible for the server to return fewer than count bytes of
     data. If the server returns less than the count requested and eof
     set to FALSE, the client should issue another READ to get the
     remaining data. A server may return less data than requested under
     several circumstances. The file may have been truncated by another
     client or perhaps on the server itself, changing the file size from
     what the requesting client believes to be the case. This would
     reduce the actual amount of data available to the client. It is
     possible that the server may back off the transfer size and reduce
     the read request return. Server resource exhaustion may also occur
     necessitating a smaller read return.

     If the file is locked the server will return an NFS4ERR_LOCKED
     error.  Since the lock may be of short duration, the client may
     choose to retransmit the READ request (with exponential backoff)
     until the operation succeeds.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_NXIO

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_STALE

Expires: December 1999                                         [Page 92]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_DENIED

     NFS4ERR_JUKEBOX

     NFS4ERR_EXPIRED

     NFS4ERR_LOCKED

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 93]

Draft Protocol Specification  NFS version 4                    June 1999

10.22.  Procedure 21: READDIR - Read Directory

   SYNOPSIS
      (cfh), cookie, dircount, maxcount, attrbits -> { cookie, filename,
      attrbits, attributes }

   ARGUMENT

     struct READDIR4args {
       /* CURRENT_FH: directory */
       nfs_cookie4cookie;
       count4dircount;
       count4maxcount;
       bitmap4attr_request;

     };

   RESULT

     struct entry4 {
       nfs_cookie4cookie;
       filename4name;
       fattr4attrs;
       entry4*nextentry;
     };

     struct dirlist4 {
       entry4*entries;
       booleof;
     };

     struct READDIR4resok {
       dirlist4reply;
     };

     union READDIR4res switch (nfsstat4 status) {
      case NFS4_OK:
        READDIR4resokresok4;
      default:
        void;
     };

Expires: December 1999                                         [Page 94]

Draft Protocol Specification  NFS version 4                    June 1999

   DESCRIPTION

     The READDIR procedure retrieves a variable number of entries from a
     file system directory and returns complete information about each
     entry along with information to allow the client to request
     additional directory entries in a subsequent READDIR.

     The arguments contain a cookie value that represents where the
     READDIR should start within the directory.  A value of 0 (zero) for
     the cookie is used to start reading at the beginning of the
     directory.  For subsequent READDIR requests, the client specifies a
     cookie value that is provided by the server on a previous READDIR
     request.

     The dircount portion of the argument is the maximum number of bytes
     of directory information that should be returned.  This value does
     not include the size of attributes or filehandle values that may be
     returned in the result.

     The maxcount value of the argument specifies the maximum number of
     bytes for the result.  This maximum size represents all of the data
     being returned and includes the XDR overhead.  The server may
     return less data.

     Finally, attrbits represents the list of attributes the client
     wants returned for each directory entry supplied by the server.

     On successful return, the server's response will provide a list of
     directory entries.  Each of these entries contains the name of the
     directory entry, a cookie value for that entry and the associated
     attributes as requested.  The cookie value is only meaningful to
     the server and is used as a "bookmark" for the directory entry.  As
     mentioned, this cookie is used by the client for subsequent READDIR
     operations so that it may continue reading a directory.  The cookie
     is similar in concept to a READ offset but should not be
     interpreted as such by the client.  Ideally, the cookie value
     should not change if the directory is modified.

   IMPLEMENTATION

     Issues that need to be understood for this procedure include
     increased cache flushing activity on the client (as new file
     handles are returned with names which are entered into caches) and
     over-the-wire overhead versus expected subsequent LOOKUP and
     GETATTR elimination.

     The dircount and maxcount fields are included as an optimization.

Expires: December 1999                                         [Page 95]

Draft Protocol Specification  NFS version 4                    June 1999

     Consider a READDIR call on a UNIX operating system implementation
     for 1048 bytes; the reply does not contain many entries because of
     the overhead due to attributes and file handles. An alternative is
     to issue a READDIR call for 8192 bytes and then only use the first
     1048 bytes of directory information. However, the server doesn't
     know that all that is needed is 1048 bytes of directory information
     (as would be returned by READDIR). It sees the 8192 byte request
     and issues a VOP_READDIR for 8192 bytes. It then steps through all
     of those directory entries, obtaining attributes and file handles
     for each entry.  When it encodes the result, the server only
     encodes until it gets 8192 bytes of results which include the
     attributes and file handles. Thus, it has done a larger VOP_READDIR
     and many more attribute fetches than it needed to. The ratio of the
     directory entry size to the size of the attributes plus the size of
     the file handle is usually at least 8 to 1. The server has done
     much more work than it needed to.

     The solution to this problem is for the client to provide two
     counts to the server. The first is the number of bytes of directory
     information that the client really wants, dircount.  The second is
     the maximum number of bytes in the result, including the attributes
     and file handles, maxcount. Thus, the server will issue a
     VOP_READDIR for only the number of bytes that the client really
     wants to get, not an inflated number.  This should help to reduce
     the size of VOP_READDIR requests on the server, thus reducing the
     amount of work done there, and to reduce the number of VOP_LOOKUP,
     VOP_GETATTR, and other calls done by the server to construct
     attributes and file handles.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_NOTDIR

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_BAD_COOKIE

     NFS4ERR_TOOSMALL

Expires: December 1999                                         [Page 96]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 97]

Draft Protocol Specification  NFS version 4                    June 1999

10.23.  Procedure 22: READLINK - Read Symbolic Link

   SYNOPSIS

     (cfh) -> linktext

   ARGUMENT

     /* CURRENT_FH: symlink */
     void;

   RESULT

     struct READLINK4resok {
       linktext4link;
     };

     union READLINK4res switch (nfsstat4 status) {
      case NFS4_OK:
        READLINK4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     READLINK reads the data associated with a symbolic link.  The data
     is a UTF-8 string that is opaque to the server.  That is, whether
     created by an NFS client or created locally on the server, the data
     in a symbolic link is not interpreted when created, but is simply
     stored.

   IMPLEMENTATION

     A symbolic link is nominally a pointer to another file.  The data
     is not necessarily interpreted by the server, just stored in the
     file.  It is possible for a client implementation to store a path
     name that is not meaningful to the server operating system in a
     symbolic link.  A READLINK operation returns the data to the client
     for interpretation. If different implementations want to share
     access to symbolic links, then they must agree on the

Expires: December 1999                                         [Page 98]

Draft Protocol Specification  NFS version 4                    June 1999

     interpretation of the data in the symbolic link.

     The READLINK operation is only allowed on objects of type, NF4LNK.
     The server should return the error, NFS4ERR_INVAL, if the object is
     not of type, NF4LNK.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_INVAL

     NFS4ERR_ACCES

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                         [Page 99]

Draft Protocol Specification  NFS version 4                    June 1999

10.24.  Procedure 23: REMOVE - Remove Filesystem Object

   SYNOPSIS

     (cfh), filename -> -

   ARGUMENT

     struct REMOVE4args {
       /* CURRENT_FH: directory */
       filename4target;
     };

   RESULT

     struct REMOVE4res {
       nfsstat4status;
     };

   DESCRIPTION

     The REMOVE procecure removes (deletes) a directory entry named by
     filename from the directory corresponding to the current
     filehandle.  If the entry in the directory was the last reference
     to the corresponding file system object, the object may be
     destroyed.

   IMPLEMENTATION

     NFS versions 2 and 3 required a different operator RMDIR for
     directory removal.  NFS version 4 REMOVE can be used to delete any
     directory entry independent of its filetype.

     The concept of last reference is server specific. However, if the
     nlink field in the previous attributes of the object had the value
     1, the client should not rely on referring to the object via a file
     handle. Likewise, the client should not rely on the resources (disk
     space, directory entry, and so on.) formerly associated with the
     object becoming immediately available. Thus, if a client needs to
     be able to continue to access a file after using REMOVE to remove
     it, the client should take steps to make sure that the file will

Expires: December 1999                                        [Page 100]

Draft Protocol Specification  NFS version 4                    June 1999

     still be accessible. The usual mechanism used is to use RENAME to
     rename the file from its old name to a new hidden name.

   ERRORS

     NFS4ERR_NOENT

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_NOTDIR

     NFS4ERR_ROFS

     NFS4ERR_NAMETOOLONG

     NFS4ERR_NOTEMPTY

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 101]

Draft Protocol Specification  NFS version 4                    June 1999

10.25.  Procedure 24: RENAME - Rename Directory Entry

   SYNOPSIS

     (cfh), oldname, newdir, newname -> -

   ARGUMENT

     struct RENAME4args {
       /* CURRENT_FH: source directory */
       filename4oldname;
       nfs4_fhnewdir;
       filename4newname;
     };

   RESULT

     struct RENAME4res {
       nfsstat4status;
     };

   DESCRIPTION

     RENAME renames the object identified by oldname in the directory
     corresponding to the current filehandle to newname in directory
     newdir. The operation is required to be atomic to the client.
     Source and target directories must reside on the same file system
     on the server.

     If the directory, newdir, already contains an entry with the name,
     newname, the source object must be compatible with the target:
     either both are non-directories or both are directories and the
     target must be empty. If compatible, the existing target is removed
     before the rename occurs. If they are not compatible or if the
     target is a directory but not empty, the server should return the
     error, NFS4ERR_EXIST.

   IMPLEMENTATION

     The RENAME operation must be atomic to the client. The statement
     "source and target directories must reside on the same file system

Expires: December 1999                                        [Page 102]

Draft Protocol Specification  NFS version 4                    June 1999

     on the server" means that the fsid fields in the attributes for the
     directories are the same. If they reside on different file systems,
     the error, NFS4ERR_XDEV, is returned.  Even though the operation is
     atomic, the status, NFS4ERR_MLINK, may be returned if the server
     used a "unlink/link/unlink" sequence internally.

     A file handle may or may not become stale on a rename.  However,
     server implementors are strongly encouraged to attempt to keep file
     handles from becoming stale in this fashion.

     On some servers, the filenames, "." and "..", are illegal as either
     oldname or newname. In addition, neither oldname nor newname can be
     an alias for the source directory.  These servers will return the
     error, NFS4ERR_INVAL, in these cases.

     If oldname and newname both refer to the same file (they might be
     hard links of each other), then RENAME should perform no action and
     return success.

   ERRORS

     NFS4ERR_NOENT

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_EXIST

     NFS4ERR_XDEV

     NFS4ERR_NOTDIR

     NFS4ERR_ISDIR

     NFS4ERR_INVAL

     NFS4ERR_NOSPC

     NFS4ERR_ROFS

     NFS4ERR_MLINK

     NFS4ERR_NAMETOOLONG

     NFS4ERR_NOTEMPTY

Expires: December 1999                                        [Page 103]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_DQUOT

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 104]

Draft Protocol Specification  NFS version 4                    June 1999

10.26.  Procedure 25: RENEW - Renew a Lease

   SYNOPSIS

     stateid -> ()

   ARGUMENT

     struct RENEW4args {
       stateid4stateid;
     };

   RESULT

     struct RENEW4res {
       nfsstat4status;
     };

   DESCRIPTION

     The RENEW procedure is used by the client to renew leases which it
     currently holds at a server.  The processing the RENEW request, the
     server renews all leases associated with the client.  The
     associated leases are determined by the client id provided via the
     SETCLIENTID procedure.

   IMPLEMENTATION

   ERRORS

     NFS4ERR_SERVERFAULT

     NFS4ERR_EXPIRED

     NFS4ERR_GRACE

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 105]

Draft Protocol Specification  NFS version 4                    June 1999

10.27.  Procedure 25: RESTOREFH - Restore Saved Filehandle

   SYNOPSIS

     (sfh) -> (cfh)

   ARGUMENT

     /* SAVED_FH: */
     void;

   RESULT

     struct RESTOREFH4res {
       /* CURRENT_FH: value of saved fh */
       nfsstat4status;
     };

   DESCRIPTION

     Set the current filehandle to the value in the saved filehandle.
     If there is no saved filehandle then return an error NFS4ERR_INVAL.

   IMPLEMENTATION

     Procedures like OPEN and LOOKUP use the current filehandle to
     represent a directory and replace it with a new filehandle.
     Assuming the previous filehandle was saved with a SAVEFH operator,
     the previous filehandle can be restored as the current filehandle.
     This is commonly used to obtain post-operation attributes for the
     directory, e.g.

             1. PUTFH (directory filehandle)
             2. SAVEFH
             3. GETATTR attrbits     (pre-op dir attrs)
             4. CREATE optbits "foo" attrs
             5. GETATTR attrbits     (file attributes)
             6. RESTOREFH
             7. GETATTR attrbits     (post-op dir attrs)

Expires: December 1999                                        [Page 106]

Draft Protocol Specification  NFS version 4                    June 1999

   ERRORS

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 107]

Draft Protocol Specification  NFS version 4                    June 1999

10.28.  Procedure 27: SAVEFH - Save Current Filehandle

   SYNOPSIS

     (cfh) -> (sfh)

   ARGUMENT

     /* CURRENT_FH: */
     void;

   RESULT

     struct SAVEFH4res {
       /* SAVED_FH: value of current fh */
       nfsstat4status;
     };

   DESCRIPTION

     Save the current filehandle.  If a previous filehandle was saved
     then it is no longer accessible.  The saved filehandle can be
     restored as the current filehandle with the RESTOREFH operator.

   IMPLEMENTATION

   ERRORS

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 108]

Draft Protocol Specification  NFS version 4                    June 1999

10.29.  Procedure 28: SECINFO - Obtain Available Security

   SYNOPSIS

     (cfh), filename -> { secinfo }

   ARGUMENT

     struct SECINFO4args {
       /* CURRENT_FH: */
       filename4name;
     };

   RESULT

     struct rpc_flavor_info {
       sec_oid4oid;
       qop4qop;
       rpc_gss_svc_t service;
     };

     struct secinfo4 {
       rpc_flavor4flavor;
       rpc_flavor_info *flavor_info;
       secinfo4*nextentry;
     };

     struct SECINFO4resok {
       secinfo4reply;
     };

     union SECINFO4res switch (nfsstat4 status) {
      case NFS4_OK:
        SECINFO4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     The SECINFO procedure is used by the client to obtain a list of

Expires: December 1999                                        [Page 109]

Draft Protocol Specification  NFS version 4                    June 1999

     valid RPC authentication flavors for a specific file handle, file
     name pair.  For the flavors, AUTH_NONE, AUTH_SYS, AUTH_DH, and
     AUTH_KRB4 no additional security information is returned.  For a
     return value of AUTH_RPCSEC_GSS, a security triple is returned that
     contains the mechanism object id (as defined in [RFC2078]), the
     quality of protection (as defined in [RFC 2078]) and the service
     type (as defined in [RFC2203]).  It is possible for SECINFO to
     return multiple entries with flavor equal to AUTH_RPCSEC_GSS with
     different security triple values.

   IMPLEMENTATION

     The SECINFO procedure is expected to be used by the NFS client when
     the error value of NFS4ERR_WRONGSEC is returned from another NFS
     procedure.  This signifies to the client that the server's security
     policy is different from what the client is currently using.  At
     this point, the client is expected to obtain a list of possible
     security flavors and choose what best suits its policies.

   ERRORS

     NFS4ERR_SERVERFAULT

Expires: December 1999                                        [Page 110]

Draft Protocol Specification  NFS version 4                    June 1999

10.30.  Procedure 29: SETATTR - Set Attributes

   SYNOPSIS

     (cfh), attrbits, attrvals -> -

   ARGUMENT

     struct SETATTR4args {
       /* CURRENT_FH: target object */
       fattr4 obj_attributes;
     };

   RESULT

     struct SETATTR4res {
       nfsstat4status;
     };

   DESCRIPTION

     The SETATTR Procedure changes one or more of the attributes of a
     file system object. The new attributes are specified with a bitmap
     and the attributes that follow the bitmap in bit order.

   IMPLEMENTATION

     The file size attribute is used to request changes to the size of a
     file. A value of 0 (zero) causes the file to be truncated, a value
     less than the current size of the file causes data from new size to
     the end of the file to be discarded, and a size greater than the
     current size of the file causes logically zeroed data bytes to be
     added to the end of the file.  Servers are free to implement this
     using holes or actual zero data bytes. Clients should not make any
     assumptions regarding a server's implementation of this feature,
     beyond that the bytes returned will be zeroed. Servers must support
     extending the file size via SETATTR.

     SETATTR is not guaranteed atomic. A failed SETATTR may partially
     change a file's attributes.

Expires: December 1999                                        [Page 111]

Draft Protocol Specification  NFS version 4                    June 1999

     Changing the size of a file with SETATTR indirectly changes the
     time_modify. A client must account for this as size changes can
     result in data deletion.

     If server and client times differ, programs that compare client
     time to file times can break. A time maintenance protocol should be
     used to limit client/server time skew.

     If the server cannot successfully set all the attributes it must
     return an NFS4ERR_INVAL error. If the server can only support 32
     bit offsets and sizes, a SETATTR request to set the size of a file
     to larger than can be represented in 32 bits will be rejected with
     this same error.

   ERRORS

     NFS4ERR_PERM

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_FBIG

     NFS4ERR_NOSPC

     NFS4ERR_ROFS

     NFS4ERR_DQUOT

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_DENIED

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

Expires: December 1999                                        [Page 112]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 113]

Draft Protocol Specification  NFS version 4                    June 1999

10.31.  Procedure 30: SETCLIENTID - Negotiated Clientid

   SYNOPSIS

     verifier, client -> clientid

   ARGUMENT

     struct cid {
       opaque verifier<4>;
       opaque id<>;
     };

     union nfs_client_id switch (clientid4 clientid) {
      case 0:
        cidident;
      default:
        void;
     };

     struct SETCLIENTID4args {
       seqid4seqid;
       nfs_client_idclient;
     };

   RESULT

     union SETCLIENTID4res switch (nfsstat4 status) {
      case NFS4_OK:
        clientid4clientid;
      default:
        void;
     };

   DESCRIPTION

     The SETCLIENTID procedure introduces the ability of the client to
     notify the server of its intention to use a particular client
     identifier and verifier pair.  Upon successful completion the
     server will return a clientid which is used in subsequent file
     locking requests.

Expires: December 1999                                        [Page 114]

Draft Protocol Specification  NFS version 4                    June 1999

   IMPLEMENTATION

     The server takes the verifier and client identification supplied
     and search for a match of the client identification.  If no match
     is found the server saves the principal/uid information along with
     the verifier and client identification and returns a unique
     clientid that is used as a short hand reference to the supplied
     information.

     If the server find matching client identification and a
     corresponding match in principal/uid, the server releases all
     locking state for the client and returns a new clientid.

   ERRORS

     NFS4ERR_INVAL

     NFS4ERR_SERVERFAULT

     NFS4ERR_CLID_INUSE

Expires: December 1999                                        [Page 115]

Draft Protocol Specification  NFS version 4                    June 1999

10.32.  Procedure 31: VERIFY - Verify Same Attributes

   SYNOPSIS

     (cfh), attrbits, attrvals -> -

   ARGUMENT

     struct VERIFY4args {
       /* CURRENT_FH: object */
       bitmap4 attr_request;
       fattr4 obj_attributes;
     };

   RESULT

     struct VERIFY4res {
       nfsstat4status;
     };

   DESCRIPTION

     The VERIFY procedure is used to verify that attributes have a value
     assumed by the client before proceeding with following operations
     in the compound request.  For instance, a VERIFY can be used to
     make sure that the file size has not changed for an append-mode
     write:

             1. PUTFH 0x0123456
             2. VERIFY attrbits attrs
             3. WRITE 450328 4096

     If the attributes are not as expected, then the request fails and
     the data is not appended to the file.

   IMPLEMENTATION

   ERRORS

Expires: December 1999                                        [Page 116]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_STALE

     NFS4ERR_BADHANDLE

     NFS4ERR_NOTSUPP

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_FHEXPIRED

Expires: December 1999                                        [Page 117]

Draft Protocol Specification  NFS version 4                    June 1999

10.33.  Procedure 32: WRITE - Write to File

   SYNOPSIS

     (cfh), offset, count, stability, stateid, data -> count, committed,
     verifier

   ARGUMENT

     enum stable_how4 {
       UNSTABLE4  = 0,
       DATA_SYNC4 = 1,
       FILE_SYNC4 = 2
     };

     struct WRITE4args {
       /* CURRENT_FH: file */
       stateid4stateid;
       offset4offset;
       count4count;
       stable_how4stable;
       opaquedata<>;
     };

   RESULT

     struct WRITE4resok {
       count4count;
       stable_how4committed;
       writeverf4verf;
     };

     union WRITE4res switch (nfsstat4 status) {
      case NFS4_OK:
        WRITE4resokresok4;
      default:
        void;
     };

   DESCRIPTION

     The WRITE procedure is used to write data to a regular file.  The

Expires: December 1999                                        [Page 118]

Draft Protocol Specification  NFS version 4                    June 1999

     target file is specified by the current filehandle.  The offset
     specifies the offset where the data should be written.  An offset
     of 0 (zero) specifies that the write should start at the beginning
     of the file.  The count represents the number of bytes of data that
     are to be written.  If the count is 0 (zero), the WRITE will
     succeed and return a count of 0 (zero) subject to permissions
     checking.  The server may choose to write fewer bytes than
     requested by the client.

     Part of the write request is a specification of how the write is to
     be performed.  The client specifies with the stable parameter the
     method of how the data is to be processed by the server.  If stable
     is FILE_SYNC, the server must commit the data written plus all file
     system metadata to stable storage before returning results. This
     corresponds to the NFS version 2 protocol semantics. Any other
     behavior constitutes a protocol violation. If stable is DATA_SYNC,
     then the server must commit all of the data to stable storage and
     enough of the metadata to retrieve the data before returning.  The
     server implementor is free to implement DATA_SYNC in the same
     fashion as FILE_SYNC, but with a possible performance drop.  If
     stable is UNSTABLE, the server is free to commit any part of the
     data and the metadata to stable storage, including all or none,
     before returning a reply to the client. There is no guarantee
     whether or when any uncommitted data will subsequently be committed
     to stable storage. The only guarantees made by the server are that
     it will not destroy any data without changing the value of verf and
     that it will not commit the data and metadata at a level less than
     that requested by the client.

     The stateid returned from a previous record lock or share
     reservation request is provided as part of the argument.  The
     stateid is used by the server to verify that the associated lock is
     still valid and to update lease timeouts for the client.

     Upon successful completion, the following results are returned.
     The count result is the number of bytes of data written to the
     file. The server may write fewer bytes than requested. If so, the
     actual number of bytes written starting at location, offset, is
     returned.

     The server also returns an indication of the level of commitment of
     the data and metadata via committed. If the server committed all
     data and metadata to stable storage, committed should be set to
     FILE_SYNC. If the level of commitment was at least as strong as
     DATA_SYNC, then committed should be set to DATA_SYNC.  Otherwise,
     committed must be returned as UNSTABLE. If stable was FILE_SYNC,
     then committed must also be FILE_SYNC: anything else constitutes a
     protocol violation. If stable was DATA_SYNC, then committed may be

Expires: December 1999                                        [Page 119]

Draft Protocol Specification  NFS version 4                    June 1999

     FILE_SYNC or DATA_SYNC: anything else constitutes a protocol
     violation. If stable was UNSTABLE, then committed may be either
     FILE_SYNC, DATA_SYNC, or UNSTABLE.

     The final portion of the result is the write verifier, verf.  The
     write verifier is a cookie that the client can use to determine
     whether the server has changed state between a call to WRITE and a
     subsequent call to either WRITE or COMMIT.  This cookie must be
     consistent during a single instance of the NFS version 4 protocol
     service and must be unique between instances of the NFS version 4
     protocol server, where uncommitted data may be lost.

     If a client writes data to the server with the stable argument set
     to UNSTABLE and the reply yields a committed response of DATA_SYNC
     or UNSTABLE, the client will follow up some time in the future with
     a COMMIT operation to synchronize outstanding asynchronous data and
     metadata with the server's stable storage, barring client error. It
     is possible that due to client crash or other error that a
     subsequent COMMIT will not be received by the server.

   IMPLEMENTATION

     It is possible for the server to write fewer than count bytes of
     data. In this case, the server should not return an error unless no
     data was written at all. If the server writes less than count
     bytes, the client should issue another WRITE to write the remaining
     data.

     It is assumed that the act of writing data to a file will cause the
     time_modified of the file to be updated. However, the time_modified
     of the file should not be changed unless the contents of the file
     are changed.  Thus, a WRITE request with count set to 0 should not
     cause the time_modified of the file to be updated.

     The definition of stable storage has been historically a point of
     contention. The following expected properties of stable storage may
     help in resolving design issues in the implementation. Stable
     storage is persistent storage that survives:

             1. Repeated power failures.
             2. Hardware failures (of any board, power supply, etc.).
             3. Repeated software crashes, including reboot cycle.

     This definition does not address failure of the stable storage
     module itself.

Expires: December 1999                                        [Page 120]

Draft Protocol Specification  NFS version 4                    June 1999

     The verifier, is defined to allow a client to detect different
     instances of an NFS version 4 protocol server over which cached,
     uncommitted data may be lost. In the most likely case, the verifier
     allows the client to detect server reboots. This information is
     required so that the client can safely determine whether the server
     could have lost cached data. If the server fails unexpectedly and
     the client has uncommitted data from previous WRITE requests (done
     with the stable argument set to UNSTABLE and in which the result
     committed was returned as UNSTABLE as well) it may not have flushed
     cached data to stable storage. The burden of recovery is on the
     client and the client will need to retransmit the data to the
     server.

     A suggested verifier would be to use the time that the server was
     booted or the time the server was last started (if restarting the
     server without a reboot results in lost buffers).

     The committed field in the results allows the client to do more
     effective caching. If the server is committing all WRITE requests
     to stable storage, then it should return with committed set to
     FILE_SYNC, regardless of the value of the stable field in the
     arguments. A server that uses an NVRAM accelerator may choose to
     implement this policy.  The client can use this to increase the
     effectiveness of the cache by discarding cached data that has
     already been committed on the server.

     Some implementations may return NFS4ERR_NOSPC instead of
     NFS4ERR_DQUOT when a user's quota is exceeded.

   ERRORS

     NFS4ERR_IO

     NFS4ERR_ACCES

     NFS4ERR_INVAL

     NFS4ERR_FBIG

     NFS4ERR_NOSPC

     NFS4ERR_ROFS

     NFS4ERR_DQUOT

     NFS4ERR_STALE

Expires: December 1999                                        [Page 121]

Draft Protocol Specification  NFS version 4                    June 1999

     NFS4ERR_BADHANDLE

     NFS4ERR_SERVERFAULT

     NFS4ERR_JUKEBOX

     NFS4ERR_LOCKED

     NFS4ERR_GRACE

     NFS4ERR_FHEXPIRED

     NFS4ERR_WRONGSEC

Expires: December 1999                                        [Page 122]

Draft Protocol Specification  NFS version 4                    June 1999

11.  Locking notes

11.1.  Short and long leases

   The usual lease trade-offs apply: short leases are good for fast
   server recovery at a cost of increased RENEW or READ (with zero
   length) requests.

   Longer leases are certainly kinder and gentler to large internet
   servers trying to handle huge numbers of clients. RENEW requests drop
   in direct proportion to the lease time.  The disadvantages of long
   leases are slower server recover after crash (server must wait for
   leases to expire and grace period before granting new lock requests)
   and increased file contention (if client fails to transmit an unlock
   request then server must wait for lease expiration before granting
   new locks).

   Long leases are usable if the server is to store lease state in non-
   volatile memory.  Upon recovery, the server can reconstruct the lease
   state from its non-volatile memory and continue operation with its
   clients and therefore long leases are not an issue.

11.2.  Clocks and leases

   To avoid the need for synchronized clocks, lease times are granted by
   the server as a time delta, though there is a requirement that the
   client and server clocks do not drift excessively over the duration
   of the lock.  There is also the issue of propagation delay across the
   network which could easily be several hundred milliseconds across the
   Internet as well as the possibility that requests will be lost and
   need to be retransmitted.

   To take propagation delay into account, the client should subtract a
   it from lease times, e.g. if the client estimates the one-way
   propagation delay as 200 msec, then it can assume that the lease is
   already 200 msec old when it gets it.  In addition, it'll take
   another 200 msec to get a response back to the server.  So the client
   must send a lock renewal or write data back to the server 400 msec
   before the lease would expire.

   The client could measure propagation delay with reasonable accuracy
   by measuring the round-trip time for lock extensions assuming that
   there's not much server processing overhead in an extension.

11.3.  Locks and lease times

   Lock requests do not contain desired lease times.  The server

Expires: December 1999                                        [Page 123]

Draft Protocol Specification  NFS version 4                    June 1999

   allocates leases with no information from the client.  The assumption
   here is that the client really has no idea of just how long the lock
   will be required. If a scenario can be found where a hint from the
   client as to the maximum lease time desired would be useful, then
   this feature could be added to lock requests.

11.4.  Locking of directories and other meta-files

   A question: should directories and/or other file-system objects like
   symbolic links be lockable ?  Clients will want to cache whole
   directories. It would be nice to have consistent directory caches,
   but it would require that any client creating a new file get a write
   lock on the directory and be prepared to handle lock denial.  Is the
   weak cache consistency that we currently have for directories
   acceptable ?  I think perhaps it is - given the expense of doing full
   consistency on an Internet scale.

11.5.  Proxy servers and leases

   Proxy servers.  There is some interest in having NFS V4 support
   caching proxies.  Support for proxy caching is a requirement if
   servers are to handle large numbers of clients - clients that may
   have little or no ability to cache on their own.  How could proxy
   servers use lease-based locking ?

11.6.  Locking and the new latency

   Latency caused by locking.  If a client wants to update a file then
   it will have to wait until the leases on read locks have expired.  If
   the leases are of the order of 60 seconds or several minutes then the
   client (and end-user) may be blocked for a while.  This is unfamiliar
   for current NFS users who are not bothered by mandatory locking - but
   it could be an issue if we decide we like the caching benefits.  A
   similar problem exists for clients that wish to read a file that is
   write locked.  The read-lock case is likely to be more common if
   read-locking is used to protect cached data on the client.

Expires: December 1999                                        [Page 124]

Draft Protocol Specification  NFS version 4                    June 1999

12.  Internationalization

   The primary issue in which NFS needs to deal with
   internationalization, or i18n, is with respect to file names and
   other strings as used within the protocol.  NFS' choice of string
   representation must allow reasonable name/string access to clients
   which use various languages.  The UTF-8 encoding allows for this type
   of access and this choice is explained in the following.

12.1.  Universal Versus Local Character Sets

   [RFC1345] describes a table of 16 bit characters for many different
   languages (the bit encodings match Unicode, though of course RFC1345
   is somewhat out of date with respect to current Unicode assignments).
   Each character from each language has a unique 16 bit value in the 16
   bit character set. Thus this table can be thought of as a universal
   character set. [RFC1345] then talks about groupings of subsets of the
   entire 16 bit character set into "Charset Tables". For example one
   might take all the Greek characters from the 16 bit table (which are
   are consecutively allocated), and normalize their offsets to a table
   that fits in 7 bits.  Thus we find that "lower case alpha" is in the
   same position as "upper case a" in the US-ASCII table, and "upper
   case alpha" is in the same position as "lower case a" in the US-ASCII
   table.

   These normalized subset character sets can be thought of as "local
   character sets", suitable for an operating system locale.

   Local character sets are not suitable for the NFS protocol.  Consider
   someone who creates a file with a name in a Swedish character set. If
   someone else later goes to access the file with their locale set to
   the Swedish language, then there are no problems. But if someone in
   say the US-ASCII locale goes to access the file, the file name will
   look very different, because the Swedish characters in the 7 bit
   table will now be represented in US-ASCII characters on the display.
   It would be preferable to give the US-ASCII user a way to display the
   file name using Swedish glyphs. In order to do that, the NFS protocol
   would have to include the locale with the file name on each operation
   to create a file.

   But then what of the situation when we have a path name on the server
   like:

           /component-1/component-2/component-3

   Each component could have been created with a different locale. If
   one issues CREATE with multi-component path name, and if some of the
   leading components already exist, what is to be done with the

Expires: December 1999                                        [Page 125]

Draft Protocol Specification  NFS version 4                    June 1999

   existing components?  Is the current locale attribute replaced with
   the user's current one?  These types of situations quickly become too
   complex when there is an alternate solution.

   If NFS V4 used a universal 16 bit or 32 bit character set (or a
   encoding of a 16 bit or 32 bit character set into octets), then
   server and client need not care if the locale of the user accessing
   the file is different than the locale of the user who created the
   file.  The unique 16 bit or 32 bit encoding of the character allows
   for determination of what language the character is from and also how
   to display that character on the client.  The server need not know
   what locales are used.

12.2.  Overview of Universal Character Set Standards

   The previous section makes a case for using a universal character set
   in NFS version 4.  This section makes the case for using UTF-8 as the
   specific universal character set for NFS version 4.

   [RFC2279] discusses UTF-* (UTF-8 and other UTF-XXX encodings),
   Unicode, and UCS-*. There are two standards bodies managing universal
   code sets:

   o    ISO/IEC which has the standard 10646-1

   o    Unicode which has the Unicode standard

   Both standards bodies have pledged to track each other's assignments
   of character codes.

   The following is a brief analysis of the various standards.

   UCS       Universal Character Set. This is ISO/IEC 10646-1: "a
             multi-octet character set called the Universal Character
             Set (UCS), which encompasses most of the world's writing
             systems."

   UCS-2     a two octet per character encoding that addresses the first
             2^16 characters of UCS. Currently there are no UCS
             characters beyond that range.

   UCS-4     a four octet per character encoding that permits the
             encoding of up to 2^31 characters.

Expires: December 1999                                        [Page 126]

Draft Protocol Specification  NFS version 4                    June 1999

   UTF       UCS transformation format.

   UTF-1     Only historical interest; it has been removed from 10646-1

   UTF-7     Encodes the entire "repertoire" of UCS "characters using
             only octets with the higher order bit clear".  [RFC2152]
             describes UTF-7. UTF-7 accomplishes this by reserving one
             of the 7bit US-ASCII characters as a "shift" character to
             indicate non-US-ASCII characters.

   UTF-8     Unlike UTF-7, uses all 8 bits of the octets. US-ASCII
             characters are encoded as before unchanged. Any octet with
             the high bit cleared can only mean a US-ASCII character.
             The high bit set means that a UCS character is being
             encoded.

   UTF-16    Encodes UCS-4 characters into UCS-2 characters using a
             reserved range in UCS-2.

   Unicode   Unicode and UCS-2 are the same; [RFC2279] states:

        Up to the present time, changes in Unicode and amendments
        to ISO/IEC 10646 have tracked each other, so that the
        character repertoires and code point assignments have
        remained in sync.  The relevant standardization committees
        have committed to maintain this very useful synchronism.

12.3.  Difficulties with UCS-4, UCS-2, Unicode

   Adapting existing applications, and file systems to multi-octet
   schemes like UCS and Unicode can be difficult. A significant amount
   of code has been written to process streams of bytes. Also there are
   many existing stored objects described with 7 bit or 8 bit
   characters. Doubling or quadrupling the bandwidth and storage
   requirements seems like an expensive way to accomplish I18N.

   UCS-2 and Unicode are "only" 16 bits long. That might seem to be
   enough but, according to [Unicode1], 38,887 Unicode characters are
   already assigned. And according to [Unicode2] there are still more
   languages that need to be added.

Expires: December 1999                                        [Page 127]

Draft Protocol Specification  NFS version 4                    June 1999

12.4.  UTF-8 and its solutions

   UTF-8 solves problems for NFS that exist with the use of UCS and
   Unicode.  UTF-8 will encode 16 bit and 32 bit characters in a way
   that will be compact for most users. The encoding table from UCS-4 to
   UTF-8, as copied from [RFC2279]:

      UCS-4 range (hex.)           UTF-8 octet sequence (binary)
    0000 0000-0000 007F   0xxxxxxx
    0000 0080-0000 07FF   110xxxxx 10xxxxxx
    0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx

    0001 0000-001F FFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    0020 0000-03FF FFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
    0400 0000-7FFF FFFF   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
   10xxxxxx

   See [RFC2279] for precise encoding and decoding rules. Note because
   of UTF-16, the algorithm from Unicode/UCS-2 to UTF-8 needs to account
   for the reserved range between D800 and DFFF.

   Note that the 16 bit UCS or Unicode characters require no more than 3
   octets to encode into UTF-8

   Interestingly, UTF-8 has room to handle characters larger than 31
   bits, because the leading octet of form:

           1111111x

   is not defined. If needed, ISO could either use that octet to
   indicate a sequence of an encoded 8 octet character, or perhaps use
   11111110 to permit the next octet to indicate an even more expandable
   character set.

   So using UTF-8 to represent character encodings means never having to
   run out of room.

Expires: December 1999                                        [Page 128]

Draft Protocol Specification  NFS version 4                    June 1999

13.  Security Considerations

   The major security feature to consider is the authentication of the
   user making the request of NFS service.  Consideration should also be
   given to the integrity and privacy of this NFS request.  These
   specific issues are discussed as part of the section on "RPC and
   Security Flavor".

   As this document progresses, other issues of denial of service and
   other typical security issues will be addressed here along with those
   issues specific to NFS service.

Expires: December 1999                                        [Page 129]

Draft Protocol Specification  NFS version 4                    June 1999

14.  NFS Version 4 RPC definition file

   /*
    *      nfs_prot.x
    *
    */

   %#pragma ident  "@(#)nfs4_prot.x        1.32    99/06/25"

   /*
    * Sizes
    */
   const NFS4_FHSIZE         = 128;
   const NFS4_CREATEVERFSIZE = 8;

   /*
    * Timeval
    */
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };

   struct specdata4 {
           uint32_t        specdata1;
           uint32_t        specdata2;
   };

   struct bitmap4 {
           uint32_t        bits<>;
   };

   /*
    * Basic data types
    */
   typedef opaque          utf8string<>;
   typedef uint64_t        offset4;
   typedef uint32_t        count4;
   typedef uint32_t        length4;
   typedef uint64_t        clientid4;
   typedef uint64_t        stateid4;
   typedef uint32_t        seqid4;
   typedef uint32_t        writeverf4;
   typedef opaque          createverf4[NFS4_CREATEVERFSIZE];
   typedef utf8string      filename4;
   typedef uint64_t        nfs_lockid4;
   typedef uint32_t        nfs_lease4;
   typedef uint32_t        nfs_lockstate4;

Expires: December 1999                                        [Page 130]

Draft Protocol Specification  NFS version 4                    June 1999

   typedef uint64_t        nfs_cookie4;
   typedef utf8string      linktext4;
   typedef opaque          sec_oid4<>;
   typedef uint32_t        qop4;

   typedef uint32_t        fattr4_type;
   typedef bool            fattr4_persistent_fh;
   typedef uint64_t        fattr4_change;
   typedef uint64_t        fattr4_size;
   typedef bool            fattr4_link_support;
   typedef bool            fattr4_symlink_support;
   typedef bool            fattr4_named_attr;
   typedef uint64_t        fattr4_fsid_major;
   typedef uint64_t        fattr4_fsid_minor;

   typedef bool            fattr4_archive;
   typedef bool            fattr4_cansettime;
   typedef bool            fattr4_case_insensitive;
   typedef bool            fattr4_case_preserving;
   typedef bool            fattr4_chown_restricted;
   typedef uint64_t        fattr4_fileid;
   typedef uint64_t        fattr4_files_avail;
   typedef uint64_t        fattr4_files_free;
   typedef uint64_t        fattr4_files_total;
   typedef bool            fattr4_hidden;
   typedef bool            fattr4_homogenous;
   typedef uint64_t        fattr4_maxfilesize;
   typedef uint32_t        fattr4_maxlink;
   typedef uint32_t        fattr4_maxname;
   typedef uint64_t        fattr4_maxread;
   typedef uint64_t        fattr4_maxwrite;
   typedef utf8string      fattr4_mimetype;
   typedef uint32_t        fattr4_mode;
   typedef bool            fattr4_no_trunc;
   typedef uint32_t        fattr4_numlinks;
   typedef utf8string      fattr4_owner;
   typedef utf8string      fattr4_owner_group;
   typedef uint64_t        fattr4_quota_hard;
   typedef uint64_t        fattr4_quota_soft;
   typedef uint64_t        fattr4_quota_used;
   typedef specdata4       fattr4_rawdev;
   typedef uint64_t        fattr4_space_avail;
   typedef uint64_t        fattr4_space_free;
   typedef uint64_t        fattr4_space_total;
   typedef uint64_t        fattr4_space_used;
   typedef bool            fattr4_system;
   typedef nfstime4        fattr4_time_access;
   typedef nfstime4        fattr4_time_backup;

Expires: December 1999                                        [Page 131]

Draft Protocol Specification  NFS version 4                    June 1999

   typedef nfstime4        fattr4_time_create;
   typedef nfstime4        fattr4_time_delta;
   typedef nfstime4        fattr4_time_metadata;
   typedef nfstime4        fattr4_time_modify;
   typedef utf8string      fattr4_version;
   typedef nfstime4        fattr4_volatility;

   /*
    * Error status
    */
   enum nfsstat4 {
           NFS4_OK                 = 0,
           NFS4ERR_PERM            = 1,
           NFS4ERR_NOENT           = 2,
           NFS4ERR_IO              = 5,
           NFS4ERR_NXIO            = 6,
           NFS4ERR_ACCES           = 13,
           NFS4ERR_EXIST           = 17,
           NFS4ERR_XDEV            = 18,
           NFS4ERR_NODEV           = 19,
           NFS4ERR_NOTDIR          = 20,
           NFS4ERR_ISDIR           = 21,
           NFS4ERR_INVAL           = 22,
           NFS4ERR_FBIG            = 27,
           NFS4ERR_NOSPC           = 28,
           NFS4ERR_ROFS            = 30,
           NFS4ERR_MLINK           = 31,
           NFS4ERR_NAMETOOLONG     = 63,
           NFS4ERR_NOTEMPTY        = 66,
           NFS4ERR_DQUOT           = 69,
           NFS4ERR_STALE           = 70,
           NFS4ERR_BADHANDLE       = 10001,
           NFS4ERR_NOT_SYNC        = 10002,
           NFS4ERR_BAD_COOKIE      = 10003,
           NFS4ERR_NOTSUPP         = 10004,
           NFS4ERR_TOOSMALL        = 10005,
           NFS4ERR_SERVERFAULT     = 10006,
           NFS4ERR_BADTYPE         = 10007,
           NFS4ERR_JUKEBOX         = 10008,
           NFS4ERR_SAME            = 10009,/* nverify says attrs same */
           NFS4ERR_DENIED          = 10010,/* lock unavailable */
           NFS4ERR_EXPIRED         = 10011,/* lock lease expired */
           NFS4ERR_LOCKED          = 10012,/* I/O failed due to lock */
           NFS4ERR_GRACE           = 10013,/* in grace period */
           NFS4ERR_FHEXPIRED       = 10014,/* file handle expired */
           NFS4ERR_SHARE_DENIED    = 10015,/* share reserve denied */
           NFS4ERR_WRONGSEC        = 10016,/* wrong security flavor */
           NFS4ERR_CLID_INUSE      = 10017,/* clientid in use */

Expires: December 1999                                        [Page 132]

Draft Protocol Specification  NFS version 4                    June 1999

           NFS4ERR_RESOURCE        = 10018 /* resource exhaustion */
   };

   enum rpc_flavor4 {
           AUTH4_NONE              = 0,
           AUTH4_SYS               = 1,
           AUTH4_DH                = 2,
           AUTH4_KRB4              = 3,
           AUTH4_RPCSEC_GSS        = 4
   };

   /*
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };

   /*
    * File access handle
    */
   struct nfs4_fh {
           opaque           data<NFS4_FHSIZE>;
   };

   /*
    * File types
    */
   enum nfs4_ftype {
           NF4REG          = 1,    /* Regular File */
           NF4DIR          = 2,    /* Directory */
           NF4BLK          = 3,    /* Special File - block device */
           NF4CHR          = 4,    /* Special File - character device */
           NF4LNK          = 5,    /* Symbolic Link */
           NF4SOCK         = 6,    /* Special File - socket */
           NF4FIFO         = 7,    /* Special File - fifo */
           NF4ATTRDIR      = 8,    /* Attribute Directory */
           NF4NAMEDATTR    = 9     /* Named Attribute */
   };

   /*
    * Mandatory Attributes
    */
   const FATTR4_SUPPORTED_ATTRS    = 0;
   const FATTR4_TYPE               = 1;
   const FATTR4_PERSISTENT_FH      = 2;

Expires: December 1999                                        [Page 133]

Draft Protocol Specification  NFS version 4                    June 1999

   const FATTR4_CHANGE             = 3;
   const FATTR4_SIZE               = 4;
   const FATTR4_LINK_SUPPORT       = 5;
   const FATTR4_SYMLINK_SUPPORT    = 6;
   const FATTR4_NAMED_ATTR         = 7;
   const FATTR4_FSID_MAJOR         = 8;
   const FATTR4_FSID_MINOR         = 9;

   /*
    * Recommended Attributes
    */
   const FATTR4_ACL                = 10;
   const FATTR4_ARCHIVE            = 11;
   const FATTR4_CANSETTIME         = 12;
   const FATTR4_CASE_INSENSITIVE   = 13;
   const FATTR4_CASE_PRESERVING    = 14;
   const FATTR4_CHOWN_RESTRICTED   = 15;
   const FATTR4_FILEHANDLE         = 16;
   const FATTR4_FILEID             = 17;
   const FATTR4_FILES_AVAIL        = 18;
   const FATTR4_FILES_FREE         = 19;
   const FATTR4_FILES_TOTAL        = 20;
   const FATTR4_HIDDEN             = 21;
   const FATTR4_HOMOGENEOUS        = 22;
   const FATTR4_MAXFILESIZE        = 23;
   const FATTR4_MAXLINK            = 24;
   const FATTR4_MAXNAME            = 25;
   const FATTR4_MAXREAD            = 26;
   const FATTR4_MAXWRITE           = 27;
   const FATTR4_MIME_TYPE          = 28;
   const FATTR4_MODE               = 29;
   const FATTR4_NO_TRUNC           = 30;
   const FATTR4_NUMLINKS           = 31;
   const FATTR4_OWNER              = 32;
   const FATTR4_OWNER_GROUP        = 33;
   const FATTR4_QUOTA_HARD         = 34;
   const FATTR4_QUOTA_SOFT         = 35;
   const FATTR4_QUOTA_USED         = 36;
   const FATTR4_RAWDEV             = 37;
   const FATTR4_SPACE_AVAIL        = 38;
   const FATTR4_SPACE_FREE         = 39;
   const FATTR4_SPACE_TOTAL        = 40;
   const FATTR4_SPACE_USED         = 41;
   const FATTR4_SYSTEM             = 42;
   const FATTR4_TIME_ACCESS        = 43;
   const FATTR4_TIME_BACKUP        = 44;
   const FATTR4_TIME_CREATE        = 45;
   const FATTR4_TIME_DELTA         = 46;

Expires: December 1999                                        [Page 134]

Draft Protocol Specification  NFS version 4                    June 1999

   const FATTR4_TIME_METADATA      = 47;
   const FATTR4_TIME_MODIFY        = 48;
   const FATTR4_VERSION            = 49;
   const FATTR4_VOLATILITY         = 50;

   struct attrlist {
           opaque          attrs<>;
   };

   struct fattr4 {
           bitmap4         attrmask;
           attrlist        attr_vals;
   };

   struct cid {
           opaque          verifier<4>;
           opaque          id<>;
   };

   union nfs_client_id switch (clientid4 clientid) {
    case 0:
            cid            ident;
    default:
            void;
   };

   struct lockown {
           clientid4       clientid;
           opaque          owner<>;
   };

   union nfs_lockowner switch (stateid4 stateid) {
    case 0:
            lockown        ident;
    default:
            void;
   };

   enum nfs4_lock_type {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };

   /*
    * ACCESS: Check access permission

Expires: December 1999                                        [Page 135]

Draft Protocol Specification  NFS version 4                    June 1999

    */
   const ACCESS4_READ      = 0x0001;
   const ACCESS4_LOOKUP    = 0x0002;
   const ACCESS4_MODIFY    = 0x0004;
   const ACCESS4_EXTEND    = 0x0008;
   const ACCESS4_DELETE    = 0x0010;
   const ACCESS4_EXECUTE   = 0x0020;

   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };

   struct ACCESS4resok {
           uint32_t        access;
   };

   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };

   /*
    * COMMIT: Commit cached data on server to stable storage
    */
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };

   struct COMMIT4resok {
           writeverf4      verf;
   };

   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };

   /*
    * CREATE: Create a file
    */

Expires: December 1999                                        [Page 136]

Draft Protocol Specification  NFS version 4                    June 1999

   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };

   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            createverf4    verf;
   };

   const ACCESS4_READ      = 0x0001;
   const ACCESS4_MODIFY    = 0x0002;
   const ACCESS4_LOOKUP    = 0x0004;
   const ACCESS4_EXTEND    = 0x0008;
   const ACCESS4_DELETE    = 0x0010;
   const ACCESS4_EXECUTE   = 0x0020;

   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };

   union openflag switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };

   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs4_lock_type  type;
           seqid4          seqid;
           bool            reclaim;
           nfs_lockowner   owner;
           offset4         offset;
           length4         length;
   };

   struct lockres {
           stateid4        stateid;

Expires: December 1999                                        [Page 137]

Draft Protocol Specification  NFS version 4                    June 1999

           int32_t         access;
   };

   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            lockres        result;
    default:
            void;
   };

   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            nfs_lockowner  owner;
    case NFS4_OK:
            void;
    default:
            void;
   };

   union LOCKU4res switch (nfsstat4 status) {
    case   NFS4_OK:
            stateid4       stateid_ok;
    default:
            stateid4       stateid_oth;
   };

   /*
    * SETCLIENTID
    */
   struct SETCLIENTID4args {
           seqid4          seqid;
           nfs_client_id   client;
   };

   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            clientid4      clientid;
    default:
            void;
   };

   /*
    * Access and Deny constants for open argument
    */
   const OPEN4_ACCESS_READ = 0x0001;
   const OPEN4_ACCESS_WRITE= 0x0002;
   const OPEN4_ACCESS_BOTH = 0x0003;

Expires: December 1999                                        [Page 138]

Draft Protocol Specification  NFS version 4                    June 1999

   const OPEN4_DENY_NONE   = 0x0000;
   const OPEN4_DENY_READ   = 0x0001;
   const OPEN4_DENY_WRITE  = 0x0002;
   const OPEN4_DENY_BOTH   = 0x0003;

   union open_nameoffh switch (bool reclaim_fh) {
    case FALSE:
            /* CURRENT_FH: directory */
            filename4       filenames<>;
    case TRUE:
            /* CURRENT_FH: file on reclaim */
            void;
   };

   /*
    * OPEN: Open a file, potentially with a share lock
    */
   struct OPEN4args {
           open_nameorfh   file;
           openflag        openhow;
           nfs_lockowner   owner;
           seqid4          seqid;
           bool            reclaim;
           int32_t         access;
           int32_t         deny;
   };

   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
            /* CURRENT_FH: opened file */
            LOCK4res       resok4;
    default:
            void;
   };

   /*
    * CREATE: Create special file
    */
   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           filename4       objname;
           fattr4_type     type;
           createhow4      createhow;
   };

   struct CREATE4res {
           nfsstat4        status;

Expires: December 1999                                        [Page 139]

Draft Protocol Specification  NFS version 4                    June 1999

   };

   /*
    * CLOSE: Close a file and release share locks
    */
   struct CLOSE4args {
           stateid4        stateid;
   };

   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       stateid;
    default:
            void;
   };

   /*
    * GETATTR: Get file attributes
    */
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };

   struct GETATTR4resok {
           fattr4          obj_attributes;
   };

   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };

   /*
    * OPENATTR: open named attributes directory
    */
   struct OPENATTR4res {
           /* CURRENT_FH: name attr directory*/
           nfsstat4        status;
   };

   /*
    * GETFH: Get current filehandle
    */
   struct GETFH4resok {

Expires: December 1999                                        [Page 140]

Draft Protocol Specification  NFS version 4                    June 1999

           nfs4_fh         object;
   };

   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETFH4resok    resok4;
    default:
            void;
   };

   /*
    * LINK: Create link to an object
    */
   struct LINK4args {
           /* CURRENT_FH: file */
           nfs4_fh         dir;
           filename4       newname;
   };

   struct LINK4res {
           nfsstat4        status;
   };

   /*
    * LOOKUP: Lookup filename
    */
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           filename4       filenames<>;
   };

   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };

   /*
    * LOOKUPP: Lookup parent directory
    */
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };

   /*
    * NVERIFY: Verify attributes different
    */
   struct NVERIFY4args {

Expires: December 1999                                        [Page 141]

Draft Protocol Specification  NFS version 4                    June 1999

           /* CURRENT_FH: object */
           bitmap4         attr_request;
           fattr4          obj_attributes;
   };

   struct NVERIFY4res {
           nfsstat4        status;
   };

   /*
    * RESTOREFH: Restore saved filehandle
    */

   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };

   /*
    * SAVEFH: Save current filehandle
    */
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;
   };

   /*
    * PUTFH: Set current filehandle
    */
   struct PUTFH4args {
           nfs4_fh         object;
   };

   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };

   /*
    * PUTROOTFH: Set root filehandle
    */
   struct PUTROOTFH4res {
           /* CURRENT_FH: root fh */
           nfsstat4        status;
   };

   /*
    * PUTPUBFH: Set public filehandle

Expires: December 1999                                        [Page 142]

Draft Protocol Specification  NFS version 4                    June 1999

    */
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };

   /*
    * READ: Read from file
    */
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };

   struct READ4resok {
           bool            eof;
           opaque          data<>;
   };

   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };

   /*
    * READDIR: Read directory
    */
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;

   };

   struct entry4 {
           nfs_cookie4     cookie;
           filename4       name;
           fattr4          attrs;
           entry4          *nextentry;
   };

   struct dirlist4 {

Expires: December 1999                                        [Page 143]

Draft Protocol Specification  NFS version 4                    June 1999

           entry4          *entries;
           bool            eof;
   };

   struct READDIR4resok {
           dirlist4        reply;
   };

   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };

   /*
    * READLINK: Read symbolic link
    */
   struct READLINK4resok {
           linktext4       link;
   };

   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };

   /*
    * REMOVE: Remove filesystem object
    */
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           filename4       target;
   };

   struct REMOVE4res {
           nfsstat4        status;
   };

   /*
    * RENAME: Rename directory entry
    */
   struct RENAME4args {
           /* CURRENT_FH: source directory */

Expires: December 1999                                        [Page 144]

Draft Protocol Specification  NFS version 4                    June 1999

           filename4       oldname;
           nfs4_fh         newdir;
           filename4       newname;
   };

   struct RENAME4res {
           nfsstat4        status;
   };

   /*
    * RENEW: Renew a Lease
    */
   struct RENEW4args {
           stateid4        stateid;
   };

   struct RENEW4res {
           nfsstat4        status;
   };

   /*
    * SETATTR: Set attributes
    */
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           fattr4          obj_attributes;
   };

   struct SETATTR4res {
           nfsstat4        status;
   };

   /*
    * VERIFY: Verify attributes same
    */
   struct VERIFY4args {
           /* CURRENT_FH: object */
           bitmap4         attr_request;
           fattr4          obj_attributes;
   };

   struct VERIFY4res {
           nfsstat4        status;
   };

   /*
    * WRITE: Write to file
    */

Expires: December 1999                                        [Page 145]

Draft Protocol Specification  NFS version 4                    June 1999

   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };

   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
           stable_how4     stable;
           opaque          data<>;
   };

   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           writeverf4      verf;
   };

   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };

   /*
    * SECINFO: Obtain Available Security Mechanisms
    */
   struct SECINFO4args {
           /* CURRENT_FH: */
           filename4       name;
   };

   struct rpc_flavor_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };

   struct secinfo4 {
           rpc_flavor4     flavor;
           rpc_flavor_info *flavor_info;
           secinfo4        *nextentry;
   };

Expires: December 1999                                        [Page 146]

Draft Protocol Specification  NFS version 4                    June 1999

   struct SECINFO4resok {
           secinfo4        reply;
   };

   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok  resok4;
    default:
            void;
   };

   enum opcode {
           OP_ACCESS               = 2,
           OP_CLOSE                = 3,
           OP_COMMIT               = 4,
           OP_CREATE               = 5,
           OP_GETATTR              = 6,
           OP_GETFH                = 7,
           OP_LINK                 = 8,
           OP_LOCK                 = 9,
           OP_LOCKT                = 10,
           OP_LOCKU                = 11,
           OP_LOOKUP               = 12,
           OP_LOOKUPP              = 13,
           OP_NVERIFY              = 14,
           OP_OPEN                 = 15,
           OP_OPENATTR             = 16,
           OP_PUTFH                = 17,
           OP_PUTPUBFH             = 18,
           OP_PUTROOTFH            = 19,
           OP_READ                 = 20,
           OP_READDIR              = 21,
           OP_READLINK             = 22,
           OP_REMOVE               = 23,
           OP_RENAME               = 24,
           OP_RENEW                = 25,
           OP_RESTOREFH            = 26,
           OP_SAVEFH               = 27,
           OP_SECINFO              = 28,
           OP_SETATTR              = 29,
           OP_SETCLIENTID          = 30,
           OP_VERIFY               = 31,
           OP_WRITE                = 32
   };

   union opunion switch (unsigned opcode) {
    case OP_ACCESS:        ACCESS4args opaccess;

Expires: December 1999                                        [Page 147]

Draft Protocol Specification  NFS version 4                    June 1999

    case OP_CLOSE:         CLOSE4args opclose;
    case OP_COMMIT:        COMMIT4args opcommit;
    case OP_CREATE:        CREATE4args opcreate;
    case OP_GETATTR:       GETATTR4args opgettattr;
    case OP_GETFH:         void;
    case OP_LINK:          LINK4args oplink;
    case OP_LOCK:          LOCK4args oplock;
    case OP_LOCKT:         LOCK4args oplockt;
    case OP_LOCKU:         LOCK4args oplocku;
    case OP_LOOKUP:        LOOKUP4args oplookup;
    case OP_LOOKUPP:       void;
    case OP_NVERIFY:       NVERIFY4args opnverify;
    case OP_OPEN:          OPEN4args opopen;
    case OP_OPENATTR:      void;
    case OP_PUTFH:         PUTFH4args opputfh;
    case OP_PUTPUBFH:      void;
    case OP_PUTROOTFH:     void;
    case OP_READ:          READ4args opread;
    case OP_READDIR:       READDIR4args opreaddir;
    case OP_READLINK:      void;
    case OP_REMOVE:        REMOVE4args opremove;
    case OP_RENAME:        RENAME4args oprename;
    case OP_RENEW:         RENEW4args oprenew;
    case OP_RESTOREFH:     void;
    case OP_SAVEFH:        void;
    case OP_SECINFO:       SECINFO4args opsecinfo;
    case OP_SETATTR:       SETATTR4args opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;
    case OP_VERIFY:        VERIFY4args opverify;
    case OP_WRITE:         WRITE4args opwrite;
   };

   struct op {
           opunion         ops;
   };

   union resultdata switch (unsigned resop){
    case OP_ACCESS:        ACCESS4res op;
    case OP_CLOSE:         CLOSE4res opclose;
    case OP_COMMIT:        COMMIT4res opcommit;
    case OP_CREATE:        CREATE4res opcreate;
    case OP_GETATTR:       GETATTR4res opgetattr;
    case OP_GETFH:         GETFH4res opgetfh;
    case OP_LINK:          LINK4res oplink;
    case OP_LOCK:          LOCK4res oplock;
    case OP_LOCKT:         LOCKT4res oplockt;
    case OP_LOCKU:         LOCKU4res oplocku;
    case OP_LOOKUP:        LOOKUP4res oplookup;

Expires: December 1999                                        [Page 148]

Draft Protocol Specification  NFS version 4                    June 1999

    case OP_LOOKUPP:       LOOKUPP4res oplookupp;
    case OP_NVERIFY:       NVERIFY4res opnverify;
    case OP_OPEN:          OPEN4res opopen;
    case OP_OPENATTR:      OPENATTR4res opopenattr;
    case OP_PUTFH:         PUTFH4res opputfh;
    case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;
    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;
    case OP_READ:          READ4res opread;
    case OP_READDIR:       READDIR4res opreaddir;
    case OP_READLINK:      READLINK4res opreadlink;
    case OP_REMOVE:        REMOVE4res opremove;
    case OP_RENAME:        RENAME4res oprename;
    case OP_RENEW:         RENEW4res oprenew;
    case OP_RESTOREFH:     RESTOREFH4res oprestorefh;
    case OP_SAVEFH:        SAVEFH4res opsavefh;
    case OP_SECINFO:       SECINFO4res opsecinfo;
    case OP_SETATTR:       SETATTR4res opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;
    case OP_VERIFY:        VERIFY4res opverify;
    case OP_WRITE:         WRITE4res opwrite;
   };

   struct COMPOUND4args {
           utf8string      tag;
           op              oplist<>;
   };

   struct COMPOUND4resok {
           utf8string      tag;
           resultdata      data<>;
   };

   union COMPOUND4res switch (nfsstat4 status){
    case NFS4_OK:
            COMPOUND4resok resok4;
    default:
            void;
   };

   /*
    * Remote file service routines
    */
   program NFS4_PROGRAM {
           version NFS_V4 {
                   void
                           NFSPROC4_NULL(void) = 0;

Expires: December 1999                                        [Page 149]

Draft Protocol Specification  NFS version 4                    June 1999

                   COMPOUND4res
                           NFSPROC4_COMPOUND(COMPOUND4args) = 1;

           } = 4;
   } = 100003;

Expires: December 1999                                        [Page 150]

Draft Protocol Specification  NFS version 4                    June 1999

15.  Bibliography

   [Gray]
   C. Gray, D. Cheriton, "Leases: An Efficient Fault-Tolerant Mechanism
   for Distributed File Cache Consistency," Proceedings of the Twelfth
   Symposium on Operating Systems Principles, p. 202-210, December 1989.

   [Juszczak]
   Juszczak, Chet, "Improving the Performance and Correctness of an NFS
   Server," USENIX Conference Proceedings, USENIX Association, Berkeley,
   CA, June 1990, pages 53-63.  Describes reply cache implementation
   that avoids work in the server by handling duplicate requests. More
   important, though listed as a side-effect, the reply cache aids in
   the avoidance of destructive non-idempotent operation re-application
   -- improving correctness.

   [Kazar]
   Kazar, Michael Leon, "Synchronization and Caching Issues in the
   Andrew File System," USENIX Conference Proceedings, USENIX
   Association, Berkeley, CA, Dallas Winter 1988, pages 27-36.  A
   description of the cache consistency scheme in AFS.  Contrasted with
   other distributed file systems.

   [Macklem]
   Macklem, Rick, "Lessons Learned Tuning the 4.3BSD Reno Implementation
   of the NFS Protocol," Winter USENIX Conference Proceedings, USENIX
   Association, Berkeley, CA, January 1991.  Describes performance work
   in tuning the 4.3BSD Reno NFS implementation. Describes performance
   improvement (reduced CPU loading) through elimination of data copies.

   [Mogul]
   Mogul, Jeffrey C., "A Recovery Protocol for Spritely NFS," USENIX
   File System Workshop Proceedings, Ann Arbor, MI, USENIX Association,
   Berkeley, CA, May 1992.  Second paper on Spritely NFS proposes a
   lease-based scheme for recovering state of consistency protocol.

   [Nowicki]
   Nowicki, Bill, "Transport Issues in the Network File System," ACM
   SIGCOMM newsletter Computer Communication Review, April 1989.  A
   brief description of the basis for the dynamic retransmission work.

Expires: December 1999                                        [Page 151]

Draft Protocol Specification  NFS version 4                    June 1999

   [Pawlowski]
   Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, "Network
   Computing in the UNIX and IBM Mainframe Environment," Uniforum `89
   Conf.  Proc., (1989) Description of an NFS server implementation for
   IBM's MVS operating system.

   [RFC1094]
   Sun Microsystems, Inc., "NFS: Network File System Protocol
   Specification", RFC1094, March 1989.

   http://www.ietf.org/rfc/rfc1094.txt

   [RFC1345]
   Simonsen, K., "Character Mnemonics & Character Sets", RFC1345,
   Rationel Almen Planlaegning, June 1992.

   http://www.ietf.org/rfc/rfc1345.txt

   [RFC1813]
   Callaghan, B., Pawlowski, B., Staubach, P., "NFS Version 3 Protocol
   Specification", RFC1813, Sun Microsystems, Inc., June 1995.

   http://www.ietf.org/rfc/rfc1813.txt

   [RFC1831]
   Srinivasan, R., "RPC: Remote Procedure Call Protocol Specification
   Version 2", RFC1831, Sun Microsystems, Inc., August 1995.

   http://www.ietf.org/rfc/rfc1831.txt

   [RFC1832]
   Srinivasan, R., "XDR: External Data Representation Standard",
   RFC1832, Sun Microsystems, Inc., August 1995.

   http://www.ietf.org/rfc/rfc1832.txt

   [RFC1833]
   Srinivasan, R., "Binding Protocols for ONC RPC Version 2", RFC1833,
   Sun Microsystems, Inc., August 1995.

   http://www.ietf.org/rfc/rfc1833.txt

Expires: December 1999                                        [Page 152]

Draft Protocol Specification  NFS version 4                    June 1999

   [RFC2054]
   Callaghan, B., "WebNFS Client Specification", RFC2054, Sun
   Microsystems, Inc., October 1996

   http://www.ietf.org/rfc/rfc2054.txt

   [RFC2055]
   Callaghan, B., "WebNFS Server Specification", RFC2054, Sun
   Microsystems, Inc., October 1996

   http://www.ietf.org/rfc/rfc2055.txt

   [RFC2078]
   Linn, J., "Generic Security Service Application Program Interface,
   Version 2", RFC2078, OpenVision Technologies, January 1997.

   http://www.ietf.org/rfc/rfc2078.txt

   [RFC2152]
   Goldsmith, D., "UTF-7 A Mail-Safe Transformation Format of Unicode",
   RFC2152, Apple Computer, Inc., May 1997

   http://www.ietf.org/rfc/rfc2152.txt

   [RFC2203]
   Eisler, M., Chiu, A., Ling, L., "RPCSEC_GSS Protocol Specification",
   RFC2203, Sun Microsystems, Inc., August 1995.

   http://www.ietf.org/rfc/rfc2203.txt

   [RFC2279]
   Yergeau, F., "UTF-8, a transformation format of ISO 10646", RFC2279,
   Alis Technologies, January 1998.

   http://www.ietf.org/rfc/rfc2279.txt

   [Sandberg]
   Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B.  Lyon, "Design
   and Implementation of the Sun Network Filesystem," USENIX Conference
   Proceedings, USENIX Association, Berkeley, CA, Summer 1985.  The
   basic paper describing the SunOS implementation of the NFS version 2
   protocol, and discusses the goals, protocol specification and trade-

Expires: December 1999                                        [Page 153]

Draft Protocol Specification  NFS version 4                    June 1999

   offs.

   [SPNEGO]
   Baize, E., Pinkas, D., "The Simple and Protected GSS-API Negotiation
   Mechanism", draft-ietf-cat-snego-09.txt, Bull, April 1998.

   ftp://ftp.isi.edu/internet-drafts/draft-ietf-cat-snego-09.txt

   [Srinivasan]
   Srinivasan, V., Jeffrey C. Mogul, "Spritely NFS: Implementation and
   Performance of Cache Consistency Protocols", WRL Research Report
   89/5, Digital Equipment Corporation Western Research Laboratory, 100
   Hamilton Ave., Palo Alto, CA, 94301, May 1989.  This paper analyzes
   the effect of applying a Sprite-like consistency protocol applied to
   standard NFS. The issues of recovery in a stateful environment are
   covered in [Mogul].

   [Unicode1]
   "Unicode Technical Report #8 - The Unicode Standard, Version 2.1",
   Unicode, Inc., The Unicode Consortium, P.O. Box 700519, San Jose, CA
   95710-0519 USA, September 1998

   http://www.unicode.org/unicode/reports/tr8.html

   [Unicode2]
   "Unsupported Scripts" Unicode, Inc., The Unicode Consortium, P.O. Box
   700519, San Jose, CA 95710-0519 USA, October 1998

   http://www.unicode.org/unicode/standard/unsupported.html

   [XNFS]
   The Open Group, Protocols for Interworking: XNFS, Version 3W, The
   Open Group, 1010 El Camino Real Suite 380, Menlo Park, CA 94025, ISBN
   1-85912-184-5, February 1998.

   HTML version available: http://www.opengroup.org

Expires: December 1999                                        [Page 154]

Draft Protocol Specification  NFS version 4                    June 1999

16.  Authors and Contributors

   General feedback related to this document should be directed to:

        nfsv4-wg@sunroof.eng.sun.com

   or the editor.

16.1.  Contributors

   The following individuals have contributed to the document:

   Carl Beame, beame@bws.com, of Hummingbird Communications Ltd.

16.2.  Editor's Address

   Spencer Shepler
   Sun Microsystems, Inc.
   7808 Moonflower Drive
   Austin, Texas 78750

   Phone: +1 512-349-9376
   E-mail: shepler@eng.sun.com

16.3.  Authors' Addresses

   Brent Callaghan
   Sun Microsystems, Inc.
   901 San Antonio Road
   Palo Alto, CA 94303

   Phone: +1 650-786-5067
   E-mail: brent.callaghan@eng.sun.com

   Mike Eisler
   Sun Microsystems, Inc.
   5565 Wilson Road
   Colorado Springs, CO 80919

   Phone: +1 719-599-9026
   E-mail: mre@eng.sun.com

   David Robinson
   Sun Microsystems, Inc.
   901 San Antonio Road
   Palo Alto, CA 94303

Expires: December 1999                                        [Page 155]

Draft Protocol Specification  NFS version 4                    June 1999

   Phone: +1 650-786-5088
   E-mail: david.robinson@eng.sun.com

   Robert Thurlow
   Sun Microsystems, Inc.
   901 San Antonio Road
   Palo Alto, CA 94303

   Phone: +1 650-786-5096
   E-mail: robert.thurlow@eng.sun.com

Expires: December 1999                                        [Page 156]

Draft Protocol Specification  NFS version 4                    June 1999

17.  Full Copyright Statement

   "Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE."

Expires: December 1999                                        [Page 157]
