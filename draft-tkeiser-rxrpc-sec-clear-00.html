<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Rx Security Object Providing Cleartext Peer Identity Assertions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Rx Security Object Providing Cleartext Peer Identity Assertions">
<meta name="keywords" content="rx">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">N/A</td><td class="header">T. Keiser</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Sine Nomine</td></tr>
<tr><td class="header">Intended status: BCP</td><td class="header">November 12, 2009</td></tr>
<tr><td class="header">Expires: May 16, 2010</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Rx Security Object Providing Cleartext Peer Identity Assertions<br />draft-tkeiser-rxrpc-sec-clear-00</h1>

<h3>Abstract</h3>

<p>
         There are a number of anonymous RxRPC applications which require
         identity assertions in order to ensure that the desired peer receives 
         and processes the procedure call.  This memo defines a replacement for
         the rxnull security class which provides a means for mutually agreeing
         upon who is communicating, without incurring cryptographic overhead.
         It should be noted that, much like rxnull, this security object is not
         suitable for use in a distributed environment due to its inability to
         provide integrity protection.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 16, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
<a href="#anchor3">2.</a>&nbsp;
Overview of Rx RPC<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.1.</a>&nbsp;
Packet Mux<br />
<a href="#anchor5">3.</a>&nbsp;
Presenting Problems<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.1.</a>&nbsp;
Node Renumbering<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.2.</a>&nbsp;
Epoch ID Multi-Homing Bit<br />
<a href="#anchor8">4.</a>&nbsp;
Rx Clear Security Class<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.1.</a>&nbsp;
Constants<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.2.</a>&nbsp;
Security Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.3.</a>&nbsp;
Data Packet Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.4.</a>&nbsp;
Abort Packet Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.4.1.</a>&nbsp;
RXCL_ERR_UNKNOWN_VERS<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.4.2.</a>&nbsp;
RXCL_ERR_UNKNOWN_ID_TYPE<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.4.3.</a>&nbsp;
RXCL_ERR_WRONG_PEER<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.4.4.</a>&nbsp;
RXCL_ERR_XCID_UNUSPP<br />
<a href="#anchor17">5.</a>&nbsp;
Multi-Home Behavior<br />
<a href="#Acknowledgements">6.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">7.</a>&nbsp;
IANA Considerations<br />
<a href="#GCO_registrar">8.</a>&nbsp;
GCO Registrar Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">8.1.</a>&nbsp;
RxClear security index<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">8.2.</a>&nbsp;
Rx error codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">8.3.</a>&nbsp;
Rx Clear Security Header Version<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">8.4.</a>&nbsp;
Endpoint Identifier Type<br />
<a href="#Security">9.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
         Many high-performance applications based upon Rx RPC cannot tolerate 
         cryptographic overhead.  In order to ensure correctness in the face of
         transport-layer address renumbering, some form of context needs to be 
         established between client and server to permit upper-layer applications 
         to reject processing of remote procedure calls which were misdirected.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview of Rx RPC</h3>

<p>
        Rx RPC is a remote procedure call mechanism built on top of UDP.  In order to establish
        a stateful call context on top of a stateless datagram protocol, Rx relies upon
        a number of client-asserted header fields to establish a flow-controlled 
        communications channel between peers.  To eliminate the need for context-establishment 
        round-trips, Rx relies upon client assertions to establish a stateful context.
      
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Packet Mux</h3>

<p>
          Rx connection objects are identified by a tuple of packet header fields.  The most
          important control field is the most-significant bit of the epoch header field.  When
          this bit is asserted, the connection object is operating in multi-homing mode, as
          specified in <a class='info' href='#rx_spec'>RXRPC<span> (</span><span class='info'>Zeldovich, N., &ldquo;Rx protocol specification draft,&rdquo; 2002.</span><span>)</span></a> [rx_spec].
          In the normal Rx operating mode (with the multi-homing bit set to zero), Rx 
          connections are identified by the following tuple: (host, port, epoch, cid), where
          these elemenets are defined as:

          </p>
<blockquote class="text"><dl>
<dt>host:</dt>
<dd>IPv4 address of peer
</dd>
<dt>port:</dt>
<dd>UDP port of peer
</dd>
<dt>epoch:</dt>
<dd>Rx header epoch field
</dd>
<dt>cid:</dt>
<dd>Rx header cid field (channel ID bits masked to zero)
</dd>
</dl></blockquote><p>

          However, when the multi-homing bit is asserted, the connection identifier tuple becomes:
          (epoch, cid).  Thus, multi-homed Rx connection objects have a shared (epoch, cid) namespace,
          independent of peer address.
        
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Presenting Problems</h3>

<p>
        The design of this Rx security class is motivated by server and client renumbering
        incidents at large AFS-3 deployments.  When a file server is renumbered, there is a several
        hour window until the next VL_GetAddrsU RPC is performed to refresh the file server UUID
        to IPv4 address mappings in the client.  Due to the TTL-based invalidation of stale cached
        mappings, there is a substantial time interval during which RPCs can be delivered to the
        wrong file server, potentially leading to incorrect behavior.
      
</p>
<p>
        Similarly, client renumbering can lead to incorrect behavior due to a loss of cache
        coherence.  The AFS-3 callback mechanism relies upon correct knowledge of client UUID to
        IPv4 address mappings in order to deliver cache invalidation messages to clients.  When
        these mappings become stale due to intervening address renumbering events, advertisement of
        incorrect addresses, NATs, etc. these "call back" remote procedure calls may be delivered to
        the wrong client node.  In some circumstances this can lead to false state of success on the
        file server because an unintended client received, processed, and sent a response of success 
        to the file server.  Due to the success return code, the file server will no longer attempt 
        to deliver the invalidation, and the client to which the call back was supposed to be delivered 
        will continue to operate on stale cached data because it never received the cache invalidation 
        message.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Node Renumbering</h3>

<p>
          When servers are renumbered, one potential outcome is that two or more
          machines running the same service will swap addresses.  In this case, there
          is a possibility for the wrong machine to correctly interpret, and attempt to
          execute, a procedure call.
        
</p>
<p>
          In some cases, execution of an RPC by the wrong endpoint will still result in correct 
          behavior.  However, this is not generally true, where execution by an unintended 
          target could result in undefined, or even dangerous, behavior.  For example, in 
          afs3, existence of shadow clones could result in a situation where the RW shadow 
          is updated by an afsint RPC, instead of the canonical RW site.
        
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Epoch ID Multi-Homing Bit</h3>

<p>
          When the multi-homing bit is asserted, (connection,epoch) tuples become
          globally unique.  This mode of operation permits clients to contact the
          server on multiple addresses, thus allowing client operating systems to route
          datagrams as desired.  Current implementations of Rx bind the connection to
          the first peer address on which a datagram was received.  Since all reply
          datagrams are sent to the bound peer, connection hijacking becomes impossible.
          Unfortunately, this comes at the expense of handling client renumbering
          events.
        
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Rx Clear Security Class</h3>

<p>
        In order to overcome the dangers inherent in assuming stability of transport
        addresses, the Rx Clear security class embeds a security header in all data packets.
        This security header contains application-specific endpoint identifier assertions 
        for both the source and destination.
      
</p>
<p>
        When a datagram is received by the wrong peer, 
        an Rx abort packet will be dispatched notifying the peer of the need to re-bind 
        transport addresses for this connection object.  When such an abort packet is received
        by a client connection, the error will be immediately propagated back to the caller so
        that application-specific logic may be invoked to refresh transport-layer address mappings
        for the intended destination endpoint.  In the server case, this memo standardizes new
        multi-homing Rx connection peer binding semantics which allow for graceful handling of
        client renumbering events.
      
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Constants</h3>

<p>
          </p>
<blockquote class="text"><dl>
<dt>RX_SEC_ID_CLEAR:</dt>
<dd>
              An Rx security index will be allocated by the Grand Central Registrar.  As with
              all Rx security indices, this 8 bit integer will uniquely identify the security
              class bound to a given Rx datagram.
            
</dd>
<dt>RXCL_HDR_VERS_1:</dt>
<dd>
              Rx Clear security header version 1 will be allocated by the Grand Central
              Registrar.  This version number will correspond to the XDR-encoded data
              structure RxClear_Header, as specified below.
            
</dd>
<dt>RXCL_ERR_UNKNOWN_VERS:</dt>
<dd>
              An Rx error code will be allocated which communicates that this version of
              the Rx Clear security header is unsupported by the peer.  This error code will
              be sent as the user payload of an Rx abort packet.
            
</dd>
<dt>RXCL_ERR_UNKNOWN_ID_TYPE:</dt>
<dd>
              An Rx error code will be allocated which communicates that this endpoint
              identifier type is not supported by the peer.  This error code will be sent
              as the user payload of an Rx abort packet.
            
</dd>
<dt>RXCL_ERR_WRONG_PEER:</dt>
<dd>
              An Rx error code will be allocated which communicates mis-delivery of an
              Rx Clear-protected datagram to the wrong peer.  This error code will be sent 
              as the user payload of an Rx abort packet.
            
</dd>
<dt>RXCL_ERR_XCID_UNSUPP:</dt>
<dd>
              An Rx error code will be allocated which communicates to the peer that this
              node is incapable of supporting the extended connection id field.  This error
              code will be sent as the user payload of an Rx abort packet upon receipt of
              an RxClear header containing a non-zero clh_xcid field by a node which cannot
              support extended connection identifiers.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Security Header</h3>

<p>
          In order to communicate expectations to the peer, all data packets travelling over
          an RxClear-protected connection will include an XDR-encoded security header which carries
          identity assertions.  The RxClear mechanism uses a header rather than a challenge-
          response mechanism because the additional round-trips required by the Rx challenge-
          response mechanism were deemed too costly for the typical unauthenticated Rx call 
          workload.
        
</p>
<p>
          The proposed security header is an XDR-encoded structure defined as follows:
        
</p><br /><hr class="insert" />
<a name="rxclear_authenticator"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
struct rxClear_Header {
    u_char clh_version;          /* authenticator version number */
    u_char reserved;
    u_short clh_data_off;        /* data payload offset */
    afs_uint32 clh_xcid;         /* extended CID field */
    afs_uint32 clh_data_len;     /* data payload length */
    afs_uint32 clh_trl_off;      /* security trailer offset */
    afs_uint32 clh_flags;        /* miscellaneous control flags */
    afs_uint32 clh_id_type;      /* how to interpret opaque peer
                                    identifier payloads */
    opaque clh_src_id;           /* assertion of client identity */
    opaque clh_dst_id;           /* assertion of server identity */
};
</pre></div>
<p style='text-align: center'>Rx Clear Security Header
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          This security header will be an XDR-encoded data structure, which will occupy the first octets of the 
          data offset in an Rx packet -- it will start at the offset directly following the Rx packet header.
          The normal packet data will begin at the data offset specified in the clh_data_off field of the security
          header.  All implementations MUST obey an upper limit of 256 octets on the size of the XDR encoded security 
          header.  Implementors SHOULD safely handle packets with oversize security headers.
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>clh_version:</dt>
<dd>
              This is the version of the Rx Clear security object header.  If this
              version is unknown by the peer, then the connection must be aborted.
            
</dd>
<dt>clh_data_off:</dt>
<dd>
              This value specifies the beginning of the data payload, in units of octets from the
              beginning of the Rx packet payload.  This field is used by receivers to determine where to
              begin reading the data payload.
            
</dd>
<dt>clh_xcid:</dt>
<dd>
              This field is reserved for future use as an extended connection identifier.  This field is included
              because it is known that there are drafts in-progress which steal bits from the Rx header connection 
              id field in order to provide for additional channel identifiers.  Implementations MUST set this 
              field to zero until extended cid protocol behavior is standardized.
            
</dd>
<dt>clh_trl_off:</dt>
<dd>
              This value specifies the offset in octets of the clear security class packet trailer.  A value
              of zero indicates the absence of a security trailer.
            
</dd>
<dt>clh_flags:</dt>
<dd>
              These bits are reserved for future allocation by the Grand Central Registrar.
            
</dd>
<dt>clh_id_type:</dt>
<dd>
              This field identifies the contents of the src_id and dst_id opaque fields.  Values within
              this namespace are allocated by the Grand Central Registrar.
            
</dd>
<dt>clh_src_id:</dt>
<dd>
              This field contains an application-specific source endpoint identifier.  For example, in the
              case of afs3, this will likely be a node UUID.
            
</dd>
<dt>clh_dst_id:</dt>
<dd>
              This field contains an application-specific destination endpoint identifier.  For example, in the
              case of afs3, this will likely be a node UUID.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Data Packet Validation</h3>

<p>
          Upon receipt of a data packet with the security index set to RX_SEC_ID_CLEAR, the node will XDR decode the
          security header, and subsequently validate the security header.  Following XDR decode, the node shall
          first verify that the clh_version field contains a supported version number.  In the event that the node
          does not support this RxClear version, the node will send an Rx abort packet to the peer with error code
          RXCL_ERR_UNKNOWN_VERS.
        
</p>
<p>
          The second step in validation involves the extended connection identifier field, clh_xcid.  If this node
          does not support extended cid, and the clh_xcid field is non-zero, then an abort packet with user payload
          RXCL_ERR_XCID_UNSUPP should be sent to the peer, and the connection should transition to an error state.
        
</p>
<p>
          Next, the application-specific endpoint identifier type specified in clh_id_type field is validated to ensure
          that the application layer can handle this identifier type.  If this endpoint identifier type is not 
          supported by the application layer, then the node will send an Rx abort packet with user payload of 
          RXCL_ERR_UNKNOWN_ID_TYPE, and the connection should transition to an error state.
        
</p>
<p>
          The application layer will then be asked to validate the clh_dst_id field.  If there is a mismatch, an
          abort packet will be sent to the peer with user payload RXCL_ERR_WRONG_PEER, and the Rx connection will then 
          transition into an error state.
        
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Abort Packet Handling</h3>

<p>
          Processing of received Rx Abort packets must be updated to handle the new RXCL_ERR_ error codes.  If such an error
          code is received on a connection with security index other than RX_SEC_ID_CLEAR, then behavior is undefined.
        
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
RXCL_ERR_UNKNOWN_VERS</h3>

<p>
            This error code indicates that the peer is unable to support the version of the RxClear security header sent in
            a packet.  The connection is transitioned into an error state.
          
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
RXCL_ERR_UNKNOWN_ID_TYPE</h3>

<p>
            This error code indicates that the peer is unable to support this application-specific endpoint identifier type.
            The connection is transitioned into an error state.
          
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
RXCL_ERR_WRONG_PEER</h3>

<p>
            This error code indicates that the packet was delivered to the wrong peer.  Behavior in this situation depends on
            several factors.  First, for connections where the epoch multi-homing bit is zero, the connection must be 
            transitioned to an error state.  For multi-homed connections, behavior further depends upon whether this is a
            client connection, or a server connection.  For client connections, the easiest course of action is to set the
            connection to an error state, and allow the client to re-resolve the application-specific endpoint-identifier to
            transport identifier mapping, allocate a new Rx connection, and re-try the call.

            In the case of a multi-homed server connection, the implementation SHOULD make a best-effort try to deliver the 
            call reply data to the correct destination, as this may be a non-idempotent procedure call.  This memo outlines 
            in detail new peer binding semantics for multi-homed Rx connections in another section.  Hence, whenever it is
            possible, the server will not transition a server connection into an error state upon receipt of this message.
            Instead, it SHOULD invalidate the peer currently bound to the connection so that future replies go to a different,
            hopefully correct, transport address.
          
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.4"></a><h3>4.4.4.&nbsp;
RXCL_ERR_XCID_UNUSPP</h3>

<p>
            This error code indicates that the peer is unable to support the extended connection identifier field in the
            RxClear security header.  The connection is transitioned to error state, and the implementation SHOULD mark the
            peer as being incapable of supporting extended connection identifiers so that connections allocated to this peer
            in the future contain a clh_xcid field with value zero.
          
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Multi-Home Behavior</h3>

<p>
        Rx supports multi-homed clients through the assertion of the most-significant bit in the Rx header epoch field.
        When this bit is asserted, a server will accept datagrams into a connection regardless of the source host address
        and port.  However, reply packets are always sent to the first peer address which contacted the server on any given
        (epoch, cid) tuple.  This behavior prevents connection hijacking, at the expense of robust multi-homing support.
      
</p>
<p>
        In order to properly support multi-homing this memo specifies relaxation of the peer binding policies.
        Most importantly, upon receipt of an RXCL_ERR_WRONG_PEER abort packet, an Rx server should
        not transition a server-mode connection to an error state.  Rather, it SHOULD mark the peer currently bound to the Rx
        connection as being incorrect so that responses may be sent to a different peer, as determined upon receipt of the next 
        ping packet.  Although this does open up room for connection hijacking, it does so only for anonymous connections, which
        are otherwise exposed to denial of service attacks.
      
</p>
<p>
        To address the issue of lack of response, new Rx server implementations SHOULD permit re-binding of the peer
        on server-mode connections.  To this end, servers should track liveness of peer addresses on a server connection
        in order to remove a dead peer from a connection.  If an Rx ping comes from an address other than the currently bound
        peer transport address, the Rx implementation MAY try to re-send unacknowledged packets to this other address.  If 
        these re-transmits are correctly aknowledged, the connection may be re-bound to the new peer.
      
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>
        I would like to thank all of the participants at the 2009 Edinburgh AFS hackathon for their input into
        the design of this security mechanism.  Specifically, I would like to thank Jeffrey Altman for suggesting that it
        would be architecturally cleaner to place peer identity assertions into a security header, rather than modifying 
        AFS-3 RPCs to explicitly include application-layer identity assertions as IN parameters.
      
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<a name="GCO_registrar"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
GCO Registrar Considerations</h3>

<p>
        This memo includes several assigned numbers requests which must
        be considered by the Grand Central Registrar.
      
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
RxClear security index</h3>

<p>
          A new Rx security index must be allocated.  It is anticipated that given
          the small size of the security index namepsace, the allocation will
          only be satisfied after rough consensus is established on the 
          afs3-standardization@openafs.org mailing list.
        
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Rx error codes</h3>

<p>
          The Rx Clear security class allocates several new Rx error codes for use
          in Rx abort packet payloads.  Given that there are multiple Rx implementations,
          it is assumed that the GCO Registrar will be responsible for allocating new
          error table values.
        
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Rx Clear Security Header Version</h3>

<p>
          The Rx Clear security class includes a version number in its packet header.  This
          memo requests that the GCO Registrar control allocation of all version numbers for
          this protocol field.  Specifically, this memo requests allocation of version 1
          within this new namespace.
        
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
Endpoint Identifier Type</h3>

<p>
          The Rx Clear security class provides a means of sending opaque application data,
          which is intended to provide a means of transmitting application-specific 
          transport-independent endpoint identifiers.  This memo requests that the GCO 
          Registrar control allocation of endpoint identifier type codes.
        
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>
         This protocol explicitly provides no means of encrypting nor integrity
         checking the contents of Rx headers or payloads.  It SHOULD NOT be used, except 
         in physically secured and isolated high-performance computing environments where
         cryptographic overhead is deemed to be unacceptable.
      
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="rx_spec">[rx_spec]</a></td>
<td class="author-text">Zeldovich, N., &ldquo;Rx protocol specification draft,&rdquo; 2002.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomas Keiser</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sine Nomine Associates</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">43596 Blacksmith Square</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ashburn, VA  20147</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 703 723 6673</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:tkeiser@sinenomine.net">tkeiser@sinenomine.net</a></td></tr>
</table>
</body></html>
