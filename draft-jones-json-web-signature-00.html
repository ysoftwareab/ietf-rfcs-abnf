<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>JSON Web Signature (JWS)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 JSON Web Signature (JWS) Overview">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Example JWS">
<link href="#rfc.section.4" rel="Chapter" title="4 JWS Header">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Reserved Header Parameter Names">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Public Header Parameter Names">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Private Header Parameter Names">
<link href="#rfc.section.5" rel="Chapter" title="5 Rules for Creating and Validating a JWS">
<link href="#rfc.section.6" rel="Chapter" title="6 Base64url encoding as used by JWSs">
<link href="#rfc.section.7" rel="Chapter" title="7 Signing JWSs with Cryptographic Algorithms">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Creating a JWS with HMAC SHA-256">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Creating a JWS with RSA SHA-256">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Creating a JWS with ECDSA P-256 SHA-256">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Additional Algorithms">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Unicode Comparison Security Issues">
<link href="#rfc.section.10" rel="Chapter" title="10 Open Issues and Things To Be Done (TBD)">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A JWS Examples">
<link href="#rfc.appendix.Appendix%20A.1" rel="Chapter" title="Appendix A.1 JWS using HMAC SHA-256">
<link href="#rfc.appendix.Appendix%20A.1.1" rel="Chapter" title="Appendix A.1.1 Encoding">
<link href="#rfc.appendix.Appendix%20A.1.2" rel="Chapter" title="Appendix A.1.2 Decoding">
<link href="#rfc.appendix.Appendix%20A.1.3" rel="Chapter" title="Appendix A.1.3 Validating">
<link href="#rfc.appendix.Appendix%20A.2" rel="Chapter" title="Appendix A.2 JWS using RSA SHA-256">
<link href="#rfc.appendix.Appendix%20A.2.1" rel="Chapter" title="Appendix A.2.1 Encoding">
<link href="#rfc.appendix.Appendix%20A.2.2" rel="Chapter" title="Appendix A.2.2 Decoding">
<link href="#rfc.appendix.Appendix%20A.2.3" rel="Chapter" title="Appendix A.2.3 Validating">
<link href="#rfc.appendix.Appendix%20A.3" rel="Chapter" title="Appendix A.3 JWS using ECDSA P-256 SHA-256">
<link href="#rfc.appendix.Appendix%20A.3.1" rel="Chapter" title="Appendix A.3.1 Encoding">
<link href="#rfc.appendix.Appendix%20A.3.2" rel="Chapter" title="Appendix A.3.2 Decoding">
<link href="#rfc.appendix.Appendix%20A.3.3" rel="Chapter" title="Appendix A.3.3 Validating">
<link href="#rfc.appendix.Appendix%20B" rel="Chapter" title="Appendix B Notes on implementing base64url encoding without padding">
<link href="#rfc.appendix.Appendix%20C" rel="Chapter" title="Appendix C Acknowledgements">
<link href="#rfc.appendix.Appendix%20D" rel="Chapter" title="Appendix D Document History">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="JSON Web Signature (JWS) is a means of representing signed content using JSON data structures.  Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification.  " />
  <meta name="description" content="JSON Web Signature (JWS) is a means of representing signed content using JSON data structures.  Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification.  " />
  <meta name="keywords" content="RFC, Request for Comments, I-D, Internet-Draft, Assertion, Simple Web Token, Security Token, SWT, JavaScript Object Notation, JSON, JSON Web Token, JWT, JSON Web Signature, JWS, JSON Web Encryption, JWE" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">M.B. Jones</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Microsoft</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">D. Balfanz</td>
</tr>
<tr>
<td class="left">Expires: September 29, 2011</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Bradley</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">independent</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Y.Y. Goland</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Microsoft</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Panzer</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">N. Sakimura</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Nomura Research Institute</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tarjan</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Facebook</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 28, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JSON Web Signature (JWS)<br />
  <span class="filename">draft-jones-json-web-signature-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>JSON Web Signature (JWS) is a means of representing signed content using JSON data structures.  Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification.  </p>
<h1><a>Requirements Language</a></h1>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 29, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">JSON Web Signature (JWS) Overview</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Example JWS</a>
</li>
<li>4.   <a href="#rfc.section.4">JWS Header</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Reserved Header Parameter Names</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Public Header Parameter Names</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Private Header Parameter Names</a>
</li>
<li>5.   <a href="#rfc.section.5">Rules for Creating and Validating a JWS</a>
</li>
<li>6.   <a href="#rfc.section.6">Base64url encoding as used by JWSs</a>
</li>
<li>7.   <a href="#rfc.section.7">Signing JWSs with Cryptographic Algorithms</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Creating a JWS with HMAC SHA-256</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Creating a JWS with RSA SHA-256</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Creating a JWS with ECDSA P-256 SHA-256</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Additional Algorithms</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">Unicode Comparison Security Issues</a>
</li>
<li>10.   <a href="#rfc.section.10">Open Issues and Things To Be Done (TBD)</a>
</li>
<li>11.   <a href="#rfc.references">References</a>
</li>
<li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">JWS Examples</a>
</li>
<li>Appendix A.1.   <a href="#rfc.appendix.Appendix%20A.1">JWS using HMAC SHA-256</a>
</li>
<li>Appendix A.1.1.   <a href="#rfc.appendix.Appendix%20A.1.1">Encoding</a>
</li>
<li>Appendix A.1.2.   <a href="#rfc.appendix.Appendix%20A.1.2">Decoding</a>
</li>
<li>Appendix A.1.3.   <a href="#rfc.appendix.Appendix%20A.1.3">Validating</a>
</li>
<li>Appendix A.2.   <a href="#rfc.appendix.Appendix%20A.2">JWS using RSA SHA-256</a>
</li>
<li>Appendix A.2.1.   <a href="#rfc.appendix.Appendix%20A.2.1">Encoding</a>
</li>
<li>Appendix A.2.2.   <a href="#rfc.appendix.Appendix%20A.2.2">Decoding</a>
</li>
<li>Appendix A.2.3.   <a href="#rfc.appendix.Appendix%20A.2.3">Validating</a>
</li>
<li>Appendix A.3.   <a href="#rfc.appendix.Appendix%20A.3">JWS using ECDSA P-256 SHA-256</a>
</li>
<li>Appendix A.3.1.   <a href="#rfc.appendix.Appendix%20A.3.1">Encoding</a>
</li>
<li>Appendix A.3.2.   <a href="#rfc.appendix.Appendix%20A.3.2">Decoding</a>
</li>
<li>Appendix A.3.3.   <a href="#rfc.appendix.Appendix%20A.3.3">Validating</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.Appendix%20B">Notes on implementing base64url encoding without padding</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.Appendix%20C">Acknowledgements</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.Appendix%20D">Document History</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">JSON Web Signature (JWS) is a compact signature format intended for space constrained environments such as HTTP Authorization headers and URI query parameters.  The JWS signature mechanisms are independent of the type of content being signed, allowing arbitrary content to be signed.  A related encryption capability is described in a separate JSON Web Encryption (JWE) <a href="#JWE">[JWE]</a> specification.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology</h1>
<p></p>

<dl>
<dt>JSON Web Signature (JWS)</dt>
<dd style="margin-left: 8">A data structure cryptographically securing a JWS Header Input and a JWS Payload Input with a JWS Crypto Output.  </dd>
<dt>JWS Header Input</dt>
<dd style="margin-left: 8">A string containing a base64url encoded JSON object that describes the cryptographic operations applied to the JWS Header Input and the JWS Payload Input.  </dd>
<dt>JWS Payload Input</dt>
<dd style="margin-left: 8">A string containing base64url encoded content.  </dd>
<dt>JWS Crypto Output</dt>
<dd style="margin-left: 8">A string containing base64url encoded cryptographic material that secures the contents of the JWS Header Input and the JWS Payload Input.  </dd>
<dt>Decoded JWS Header Input</dt>
<dd style="margin-left: 8">JWS Header Input that has been base64url decoded back into a JSON object.  </dd>
<dt>Decoded JWS Payload Input</dt>
<dd style="margin-left: 8">JWS Payload Input that has been base64url decoded.  </dd>
<dt>Decoded JWS Crypto Output</dt>
<dd style="margin-left: 8">JWS Crypto Output that has been base64url decoded back into cryptographic material.  </dd>
<dt>JWS Signing Input</dt>
<dd style="margin-left: 8">The concatenation of the JWS Header Input, a period ('.') character, and the JWS Payload Input.  </dd>
<dt>Header Parameter Names</dt>
<dd style="margin-left: 8">The names of the members within the JSON object represented in a JWS Header Input.  </dd>
<dt>Header Parameter Values</dt>
<dd style="margin-left: 8">The values of the members within the JSON object represented in a JWS Header Input.  </dd>
<dt>Digital Signature</dt>
<dd style="margin-left: 8">For the purposes of this specification, we use this term to encompass both Hash-based Message Authentication Codes (HMACs), which can provide authenticity but not non-repudiation, and digital signatures using public key algorithms, which can provide both.  Readers should be aware of this distinction, despite the decision to use a single term for both concepts to improve readability of the specification.  </dd>
<dt>Base64url Encoding</dt>
<dd style="margin-left: 8">For the purposes of this specification, this term always refers to the he URL- and filename-safe Base64 encoding described in <a href="#RFC4648">RFC 4648</a> <cite title="NONE">[RFC4648]</cite>, Section 5, with the '=' padding characters omitted, as permitted by Section 3.2.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> JSON Web Signature (JWS) Overview</h1>
<p id="rfc.section.3.p.1">JWSs represent content that is base64url encoded and digitally signed, and optionally encrypted, using JSON data structures.  A portion of the base64url encoded content that is signed is the JWS Payload Input.  </p>
<p id="rfc.section.3.p.2">An accompanying base64url encoded JSON object - the JWS Header Input - describes the signature method used.  </p>
<p id="rfc.section.3.p.3">The names within the header JSON object MUST be unique.  These names are referred to as Header Parameter Names.  The corresponding values are referred to as Header Parameter Values.  </p>
<p id="rfc.section.3.p.4">JWSs contain a signature that ensures the integrity of the contents of the JWS Header Input and the JWS Payload Input.  This signature value is the JWS Crypto Output.  The JSON Header object MUST contain an "alg" parameter, the value of which is a string that unambiguously identifies the algorithm used to sign the JWS Header Input and the JWS Payload Input to produce the JWS Crypto Output.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#ExampleJWS" id="ExampleJWS">Example JWS</a>
</h1>
<p id="rfc.section.3.1.p.1">The following example JSON header object declares that the encoded object is a JSON Web Token (JWT) <a href="#JWT">[JWT]</a> and the JWS Header Input and the JWS Payload Input are signed using the HMAC SHA-256 algorithm: </p>
<p id="rfc.section.3.1.p.2">Base64url encoding the UTF-8 representation of the JSON header object yields this JWS Header Input value: </p>
<p id="rfc.section.3.1.p.3">The following is an example of a JSON object that can be encoded to produce a JWS Payload Input.  (Note that the payload can be any base64url encoded content, and need not be a base64url encoded JSON object.) </p>
<p id="rfc.section.3.1.p.4">Base64url encoding the UTF-8 representation of the JSON object yields the following JWS Payload Input.  </p>
<p id="rfc.section.3.1.p.5">Signing the UTF-8 representation of the JWS Signing Input (the concatenation of the JWS Header Input, a period ('.') character, and the JWS Payload Input) with the HMAC SHA-256 algorithm and base64url encoding the result, as per <a href="#SigningWithHMACSHA256">Section 7.1</a>, yields this JWS Crypto Output value: </p>
<p id="rfc.section.3.1.p.6">This computation is illustrated in more detail in <a href="#HMACSHA256Example">Appendix Appendix A.1</a>.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> JWS Header</h1>
<p id="rfc.section.4.p.1">The members of the JSON object represented by the Decoded JWS Header Input describe the signature applied to the JWS Header Input and the JWS Payload Input and optionally additional properties of the JWS.  Implementations MUST understand the entire contents of the header; otherwise, the JWS MUST be rejected for processing.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#ReservedHeaderParameterName" id="ReservedHeaderParameterName">Reserved Header Parameter Names</a>
</h1>
<p id="rfc.section.4.1.p.1">The following header parameter names are reserved.  All the names are short because a core goal of JWSs is for the representations to be compact.  </p>
<div id="#rfc.table.1"></div>
<div id="#HeaderParameterTable"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Reserved Header Parameter Definitions</caption>
<thead><tr>
<th class="left">Header Parameter Name</th>
<th class="left">JSON Value Type</th>
<th class="left">Header Parameter Syntax</th>
<th class="left">Header Parameter Semantics</th>
</tr></thead>
<tbody>
<tr>
<td class="left">alg</td>
<td class="left">string</td>
<td class="left">StringAndURI</td>
<td class="left">The <samp>alg</samp> (algorithm) header parameter identifies the cryptographic algorithm used to secure the JWS.  A list of reserved alg values is in <a href="#AlgTable">Table 3</a>.  The processing of the <samp>alg</samp> (algorithm) header parameter, if present, requires that the value of the <samp>alg</samp> header parameter MUST be one that is both supported and for which there exists a key for use with that algorithm associated with the signer of the content.  This header parameter is REQUIRED.  </td>
</tr>
<tr>
<td class="left">typ</td>
<td class="left">string</td>
<td class="left">String</td>
<td class="left">The <samp>typ</samp> (type) header parameter is used to declare the type of the signed content.  This header parameter is OPTIONAL.  </td>
</tr>
<tr>
<td class="left">jku</td>
<td class="left">string</td>
<td class="left">URL</td>
<td class="left">The <samp>jku</samp> (JSON Key URL) header parameter is a URL that points to JSON-encoded public key certificates that can be used to validate the signature.  The specification for this encoding is TBD.  This header parameter is OPTIONAL.  </td>
</tr>
<tr>
<td class="left">kid</td>
<td class="left">string</td>
<td class="left">String</td>
<td class="left">The <samp>kid</samp> (key ID) header parameter is a hint indicating which specific key owned by the signer should be used to validate the signature.  This allows signers to explicitly signal a change of key to recipients. Omitting this parameter is equivalent to setting it to an empty string.  The interpretation of the contents of the <samp>kid</samp> parameter is unspecified.  This header parameter is OPTIONAL.  </td>
</tr>
<tr>
<td class="left">x5u</td>
<td class="left">string</td>
<td class="left">URL</td>
<td class="left">The <samp>x5u</samp> (X.509 URL) header parameter is a URL that points to an X.509 public key certificate that can be used to validate the signature.  This certificate MUST conform to <a href="#RFC5280">RFC 5280</a> <cite title="NONE">[RFC5280]</cite>.  This header parameter is OPTIONAL.  </td>
</tr>
<tr>
<td class="left">x5t</td>
<td class="left">string</td>
<td class="left">String</td>
<td class="left">The <samp>x5t</samp> (x.509 certificate thumbprint) header parameter provides a base64url encoded SHA-256 thumbprint (a.k.a. digest) of the DER encoding of an X.509 certificate that can be used to match a certificate.  This header parameter is OPTIONAL.  </td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.1.p.2">Additional reserved header parameter names MAY be defined via the IANA JSON Web Signature Header Parameters registry, as per <a href="#IANA">Section 8</a>.  The syntax values used above are defined as follows: </p>
<div id="#rfc.table.2"></div>
<div id="#SyntaxDefinitions"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Header Parameter Syntax Definitions</caption>
<thead><tr>
<th class="left">Syntax Name</th>
<th class="left">Syntax Definition</th>
</tr></thead>
<tbody>
<tr>
<td class="left">IntDate</td>
<td class="left">The number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the desired date/time. See <a href="#RFC3339">RFC 3339</a> <cite title="NONE">[RFC3339]</cite> for details regarding date/times in general and UTC in particular.  </td>
</tr>
<tr>
<td class="left">String</td>
<td class="left">Any string value MAY be used.  </td>
</tr>
<tr>
<td class="left">StringAndURI</td>
<td class="left">Any string value MAY be used but a value containing a ":" character MUST be a URI as defined in <a href="#RFC3986">RFC 3986</a> <cite title="NONE">[RFC3986]</cite>.  </td>
</tr>
<tr>
<td class="left">URL</td>
<td class="left">A URL as defined in <a href="#RFC1738">RFC 1738</a> <cite title="NONE">[RFC1738]</cite>.  </td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#PublicHeaderParameterName" id="PublicHeaderParameterName">Public Header Parameter Names</a>
</h1>
<p id="rfc.section.4.2.p.1">Additional header parameter names can be defined by those using JWSs. However, in order to prevent collisions, any new header parameter name or algorithm value SHOULD either be defined in the IANA JSON Web Signature Header Parameters registry or be defined as a URI that contains a collision resistant namespace.  In each case, the definer of the name or value MUST take reasonable precautions to make sure they are in control of the part of the namespace they use to define the header parameter name.  </p>
<p id="rfc.section.4.2.p.2">New header parameters should be introduced sparingly, as they can result in non-interoperable JWSs.  </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#PrivateHeaderParameterName" id="PrivateHeaderParameterName">Private Header Parameter Names</a>
</h1>
<p id="rfc.section.4.3.p.1">A producer and consumer of a JWS may agree to any header parameter name that is not a Reserved Name <a href="#ReservedHeaderParameterName">Section 4.1</a> or a Public Name <a href="#PublicHeaderParameterName">Section 4.2</a>. Unlike Public Names, these private names are subject to collision and should be used with caution.  </p>
<p id="rfc.section.4.3.p.2">New header parameters should be introduced sparingly, as they can result in non-interoperable JWSs.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Rules for Creating and Validating a JWS</h1>
<p id="rfc.section.5.p.1">To create a JWS, one MUST follow these steps: </p>

<ol>
<li>Create the payload content to be encoded as the Decoded JWS Payload Input.  </li>
<li>Base64url encode the Decoded JWS Payload Input.  This encoding becomes the JWS Payload Input.  </li>
<li>Create a JSON object containing a set of desired header parameters.  Note that white space is explicitly allowed in the representation and no canonicalization is performed before encoding.  </li>
<li>Translate this JSON object's Unicode code points into UTF-8, as defined in <a href="#RFC3629">RFC 3629</a> <cite title="NONE">[RFC3629]</cite>.  </li>
<li>Base64url encode the UTF-8 representation of this JSON object as defined in this specification (without padding). This encoding becomes the JWS Header Input.  </li>
<li>Compute the JWS Crypto Output in the manner defined for the particular algorithm being used.  The JWS Signing Input is always the concatenation of the JWS Header Input, a period ('.') character, and the JWS Payload Input.  The <samp>alg</samp> header parameter MUST be present in the JSON Header Input, with the algorithm value accurately representing the algorithm used to construct the JWS Crypto Input.  </li>
</ol>

<p> </p>
<p id="rfc.section.5.p.2">When validating a JWS, the following steps MUST be taken. If any of the listed steps fails, then the signed content MUST be rejected.  </p>
<p></p>

<ol>
<li>The JWS Payload Input MUST be successfully base64url decoded following the restriction given in this specification that no padding characters have been used.  </li>
<li>The JWS Header Input MUST be successfully base64url decoded following the restriction given in this specification that no padding characters have been used.  </li>
<li>The Decoded JWS Header Input MUST be completely valid JSON syntax conforming to <a href="#RFC4627">RFC 4627</a> <cite title="NONE">[RFC4627]</cite>.  </li>
<li>The JWS Crypto Output MUST be successfully base64url decoded following the restriction given in this specification that no padding characters have been used.  </li>
<li>The JWS Header Input MUST be validated to only include parameters and values whose syntax and semantics are both understood and supported.  </li>
<li>The JWS Crypto Output MUST be successfully validated against the JWS Header Input and JWS Payload Input in the manner defined for the algorithm being used, which MUST be accurately represented by the value of the <samp>alg</samp> header parameter, which MUST be present.  </li>
</ol>

<p> </p>
<p id="rfc.section.5.p.4">Processing a JWS inevitably requires comparing known strings to values in the header. For example, in checking what the algorithm is, the Unicode string encoding <samp>alg</samp> will be checked against the member names in the Decoded JWS Header Input to see if there is a matching header parameter name. A similar process occurs when determining if the value of the <samp>alg</samp> header parameter represents a supported algorithm. Comparing Unicode strings, however, has significant security implications, as per <a href="#Security">Section 9</a>.  </p>
<p id="rfc.section.5.p.5">Comparisons between JSON strings and other Unicode strings MUST be performed as specified below: </p>
<p></p>

<ol>
<li>Remove any JSON applied escaping to produce an array of Unicode code points.  </li>
<li>
<a href="#USA15">Unicode Normalization</a> <cite title="NONE">[USA15]</cite> MUST NOT be applied at any point to either the JSON string or to the string it is to be compared against.  </li>
<li>Comparisons between the two strings MUST be performed as a Unicode code point to code point equality comparison.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#base64urllogic" id="base64urllogic">Base64url encoding as used by JWSs</a>
</h1>
<p id="rfc.section.6.p.1">JWSs make use of the base64url encoding as defined in <a href="#RFC4648">RFC 4648</a> <cite title="NONE">[RFC4648]</cite>. As allowed by Section 3.2 of the RFC, this specification mandates that base64url encoding when used with JWSs MUST NOT use padding. The reason for this restriction is that the padding character ('=') is not URL safe.  </p>
<p id="rfc.section.6.p.2">For notes on implementing base64url encoding without padding, see <a href="#base64urlnotes">Appendix Appendix B</a>.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Signing" id="Signing">Signing JWSs with Cryptographic Algorithms</a>
</h1>
<p id="rfc.section.7.p.1">JWSs use specific cryptographic algorithms to sign the contents of the JWS Header Input and the JWS Payload Input.  The use of the following algorithms for producing JWSs is defined in this section.  The table below is the list of <samp>alg</samp> header parameter values reserved by this specification, each of which is explained in more detail in the following sections: </p>
<div id="#rfc.table.3"></div>
<div id="#AlgTable"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>JSON Web Signature Reserved Algorithm Values</caption>
<thead><tr>
<th class="left">Alg Parameter Value</th>
<th class="left">Algorithm</th>
</tr></thead>
<tbody>
<tr>
<td class="left">HS256</td>
<td class="left">HMAC using SHA-256 hash algorithm</td>
</tr>
<tr>
<td class="left">HS384</td>
<td class="left">HMAC using SHA-384 hash algorithm</td>
</tr>
<tr>
<td class="left">HS512</td>
<td class="left">HMAC using SHA-512 hash algorithm</td>
</tr>
<tr>
<td class="left">RS256</td>
<td class="left">RSA using SHA-256 hash algorithm</td>
</tr>
<tr>
<td class="left">RS384</td>
<td class="left">RSA using SHA-384 hash algorithm</td>
</tr>
<tr>
<td class="left">RS512</td>
<td class="left">RSA using SHA-512 hash algorithm</td>
</tr>
<tr>
<td class="left">ES256</td>
<td class="left">ECDSA using P-256 curve and SHA-256 hash algorithm</td>
</tr>
<tr>
<td class="left">ES384</td>
<td class="left">ECDSA using P-384 curve and SHA-384 hash algorithm</td>
</tr>
<tr>
<td class="left">ES512</td>
<td class="left">ECDSA using P-521 curve and SHA-512 hash algorithm</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.p.2">Of these algorithms, only HMAC SHA-256 and RSA SHA-256 MUST be implemented by conforming implementations.  It is RECOMMENDED that implementations also support the ECDSA P-256 SHA-256 algorithm.  Support for other algorithms is OPTIONAL.  </p>
<p id="rfc.section.7.p.3">The signed content for a JWS is the same for all algorithms: the concatenation of the JWS Header Input, a period ('.') character, and the JWS Payload Input.  This character sequence is referred to as the JWS Signing Input.  Note that if the JWS represents a JWT, this corresponds to the portion of the JWT representation preceding the second period character.  The UTF-8 representation of the JWS Signing Input is passed to the respective signing algorithms.  </p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#SigningWithHMACSHA256" id="SigningWithHMACSHA256">Creating a JWS with HMAC SHA-256</a>
</h1>
<p id="rfc.section.7.1.p.1">Hash based Message Authentication Codes (HMACs) enable one to use a secret plus a cryptographic hash function to generate a Message Authentication Code (MAC). This can be used to demonstrate that the MAC matches the hashed content, in this case the JWS Signing Input, which therefore demonstrates that whoever generated the MAC was in possession of the secret.  </p>
<p id="rfc.section.7.1.p.2">The algorithm for implementing and validating HMACs is provided in <a href="#RFC2104">RFC 2104</a> <cite title="NONE">[RFC2104]</cite>. Although any HMAC can be used with JWSs, this section defines the use of the SHA-256 cryptographic hash function as defined in <a href="#FIPS.180-3">FIPS 180-3</a> <cite title="NONE">[FIPS.180-3]</cite>. The reserved <samp>alg</samp> header parameter value <samp>HS256</samp> is used in the JWS Header Input to indicate that the JWS Crypto Output contains a base64url encoded HMAC SHA-256 HMAC value.  </p>
<p id="rfc.section.7.1.p.3">The HMAC SHA-256 MAC is generated as follows: </p>

<ol>
<li>Apply the HMAC SHA-256 algorithm to the UTF-8 representation of the JWS Signing Input using the shared key to produce an HMAC.  </li>
<li>Base64url encode the HMAC as defined in this document.  </li>
</ol>

<p> The output is the JWS Crypto Output for that JWS.  </p>
<p id="rfc.section.7.1.p.4">The HMAC SHA-256 MAC for a JWS is validated as follows: </p>

<ol>
<li>Apply the HMAC SHA-256 algorithm to the UTF-8 representation of the JWS Signing Input of the JWS using the shared key.  </li>
<li>Base64url encode the previously generated HMAC as defined in this document.  </li>
<li>If the JWS Crypto Output and the previously calculated value exactly match, then one has confirmation that the key was used to generate the HMAC on the JWS and that the contents of the JWS have not be tampered with.  </li>
<li>If the validation fails, the signed content MUST be rejected.  </li>
</ol>

<p> </p>
<p id="rfc.section.7.1.p.5">Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is performed identically to the procedure for HMAC SHA-256 - just with correspondingly longer key and result values.  </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#DefiningRSA" id="DefiningRSA">Creating a JWS with RSA SHA-256</a>
</h1>
<p id="rfc.section.7.2.p.1">This section defines the use of the RSASSA-PKCS1-v1_5 signature algorithm as defined in <a href="#RFC3447">RFC 3447</a> <cite title="NONE">[RFC3447]</cite>, Section 8.2 (commonly known as PKCS#1), using SHA-256 as the hash function.  Note that the use of the RSASSA-PKCS1-v1_5 algorithm is described in <a href="#FIPS.186-3">FIPS 186-3</a> <cite title="NONE">[FIPS.186-3]</cite>, Section 5.5, as is the SHA-256 cryptographic hash function, which is defined in <a href="#FIPS.180-3">FIPS 180-3</a> <cite title="NONE">[FIPS.180-3]</cite>.  The reserved <samp>alg</samp> header parameter value <samp>RS256</samp> is used in the JWS Header Input to indicate that the JWS Crypto Output contains an RSA SHA-256 signature.  </p>
<p id="rfc.section.7.2.p.2">A 2048-bit or longer key length MUST be used with this algorithm.  </p>
<p id="rfc.section.7.2.p.3">The RSA SHA-256 signature is generated as follows: </p>

<ol>
<li>Let K be the signer's RSA private key and let M be the UTF-8 representation of the JWS Signing Input.  </li>
<li>Compute the octet string S = RSASSA-PKCS1-V1_5-SIGN (K, M) using SHA-256 as the hash function.  </li>
<li>Base64url encode the octet string S, as defined in this document.  </li>
</ol>

<p> The output is the JWS Crypto Output for that JWS.  </p>
<p id="rfc.section.7.2.p.4">The RSA SHA-256 signature for a JWS is validated as follows: </p>

<ol>
<li>Take the JWS Crypto Output and base64url decode it into an octet string S. If decoding fails, then the signed content MUST be rejected.  </li>
<li>Let M be the UTF-8 representation of the JWS Signing Input and let (n, e) be the public key corresponding to the private key used by the signer.  </li>
<li>Validate the signature with RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S) using SHA-256 as the hash function.  </li>
<li>If the validation fails, the signed content MUST be rejected.  </li>
</ol>

<p> </p>
<p id="rfc.section.7.2.p.5">Signing with the RSA SHA-384 and RSA SHA-512 algorithms is performed identically to the procedure for RSA SHA-256 - just with correspondingly longer key and result values.  </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#DefiningECDSA" id="DefiningECDSA">Creating a JWS with ECDSA P-256 SHA-256</a>
</h1>
<p id="rfc.section.7.3.p.1">The Elliptic Curve Digital Signature Algorithm (ECDSA) is defined by <a href="#FIPS.186-3">FIPS 186-3</a> <cite title="NONE">[FIPS.186-3]</cite>. ECDSA provides for the use of Elliptic Curve cryptography, which is able to provide equivalent security to RSA cryptography but using shorter key lengths and with greater processing speed. This means that ECDSA signatures will be substantially smaller in terms of length than equivalently strong RSA Digital Signatures.  </p>
<p id="rfc.section.7.3.p.2">This specification defines the use of ECDSA with the P-256 curve and the SHA-256 cryptographic hash function. The P-256 curve is also defined in FIPS 186-3. The reserved <samp>alg</samp> header parameter value <samp>ES256</samp> is used in the JWS Header Input to indicate that the JWS Crypto Output contains an ECDSA P-256 SHA-256 signature.  </p>
<p id="rfc.section.7.3.p.3">A JWS is signed with an ECDSA P-256 SHA-256 signature as follows: </p>

<ol>
<li>Generate a digital signature of the UTF-8 representation of the JWS Signing Input using ECDSA P-256 SHA-256 with the desired private key. The output will be the EC point (R, S), where R and S are unsigned integers.  </li>
<li>Turn R and S into byte arrays in big endian order. Each array will be 32 bytes long.  </li>
<li>Concatenate the two byte arrays in the order R and then S.  </li>
<li>Base64url encode the 64 byte array as defined in this specification.  </li>
</ol>

<p> The output is the JWS Crypto Output for the JWS.  </p>
<p id="rfc.section.7.3.p.4">The ECDSA P-256 SHA-256 signature for a JWS is validated as follows: </p>

<ol>
<li>Take the JWS Crypto Output and base64url decode it into a byte array. If decoding fails, the signed content MUST be rejected.  </li>
<li>The output of the base64url decoding MUST be a 64 byte array.  </li>
<li>Split the 64 byte array into two 32 byte arrays. The first array will be R and the second S. Remember that the byte arrays are in big endian byte order; please check the ECDSA validator in use to see what byte order it requires.  </li>
<li>Submit the UTF-8 representation of the JWS Signing Input, R, S and the public key (x, y) to the ECDSA P-256 SHA-256 validator.  </li>
<li>If the validation fails, the signed content MUST be rejected.  </li>
</ol>

<p> The ECDSA validator will then determine if the digital signature is valid, given the inputs.  Note that ECDSA digital signature contains a value referred to as K, which is a random number generated for each digital signature instance. This means that two ECDSA digital signatures using exactly the same input parameters will output different signatures because their K values will be different. The consequence of this is that one must validate an ECDSA signature by submitting the previously specified inputs to an ECDSA validator.  </p>
<p id="rfc.section.7.3.p.5">Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512 algorithms is performed identically to the procedure for ECDSA P-256 SHA-256 - just with correspondingly longer key and result values.  </p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#MoreAlgs" id="MoreAlgs">Additional Algorithms</a>
</h1>
<p id="rfc.section.7.4.p.1">Additional algorithms MAY be used to protect JWSs with corresponding <samp>alg</samp> header parameter values being defined to refer to them. New <samp>alg</samp> header parameter values SHOULD either be defined in the IANA JSON Web Signature Algorithms registry or be a URI that contains a collision resistant namespace.  In particular, the use of algorithm identifiers defined in <a href="#RFC3275">XML DSIG</a> <cite title="NONE">[RFC3275]</cite> and related specifications is permitted.  </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This specification calls for: </p>

<ul>
<li>A new IANA registry entitled "JSON Web Signature Header Parameters" for reserved header parameter names is defined in <a href="#ReservedHeaderParameterName">Section 4.1</a>.  Inclusion in the registry is RFC Required in the <a href="#RFC5226">RFC 5226</a> <cite title="NONE">[RFC5226]</cite> sense for reserved JWS header parameter names that are intended to be interoperable between implementations.  The registry will just record the reserved header parameter name and a pointer to the RFC that defines it. This specification defines inclusion of the header parameter names defined in <a href="#HeaderParameterTable">Table 1</a>.  </li>
<li>A new IANA registry entitled "JSON Web Signature Algorithms" for reserved values used with the <samp>alg</samp> header parameter values is defined in <a href="#MoreAlgs">Section 7.4</a>. Inclusion in the registry is RFC Required in the <a href="#RFC5226">RFC 5226</a> <cite title="NONE">[RFC5226]</cite> sense. The registry will just record the <samp>alg</samp> value and a pointer to the RFC that defines it.  This specification defines inclusion of the algorithm values defined in <a href="#AlgTable">Table 3</a>.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">TBD: Lots of work to do here. We need to remember to look into any issues relating to security and JSON parsing. One wonders just how secure most JSON parsing libraries are. Were they ever hardened for security scenarios? If not, what kind of holes does that open up? Also, we need to walk through the JSON standard and see what kind of issues we have especially around comparison of names.  For instance, comparisons of header parameter names and other parameters must occur after they are unescaped. Need to also put in text about: Importance of keeping secrets secret. Rotating keys. Strengths and weaknesses of the different algorithms.  </p>
<p id="rfc.section.9.p.2">TBD: Need to put in text about why strict JSON validation is necessary.  Basically, that if malformed JSON is received then the intent of the sender is impossible to reliably discern.  </p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> Unicode Comparison Security Issues</h1>
<p id="rfc.section.9.1.p.1">Header parameter names in JWSs are Unicode strings.  For security reasons, the representations of these names must be compared verbatim after performing any escape processing (as per <a href="#RFC4627">RFC 4627</a> <cite title="NONE">[RFC4627]</cite>, Section 2.5).  </p>
<p id="rfc.section.9.1.p.2">This means, for instance, that these JSON strings must compare as being equal ("sig", "\u0073ig"), whereas these must all compare as being not equal to the first set or to each other ("SIG", "Sig", "si\u0047").  </p>
<p id="rfc.section.9.1.p.3">JSON strings MAY contain characters outside the Unicode Basic Multilingual Plane.  For instance, the G clef character (U+1D11E) may be represented in a JSON string as "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure that characters outside the Basic Multilingual Plane are preserved and compared correctly; alternatively, if this is not possible due to these characters exercising limitations present in the underlying JSON implementation, then input containing them MUST be rejected.  </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#TBD" id="TBD">Open Issues and Things To Be Done (TBD)</a>
</h1>
<p id="rfc.section.10.p.1">The following items remain to be done in this draft (and related drafts): </p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC1738">[RFC1738]</b></td>
<td class="top">
<a href="mailto:timbl@info.cern.ch" title="CERN, World-Wide Web project">Berners-Lee, T.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox PARC">Masinter, L.</a> and <a href="mailto:mpm@boombox.micro.umn.edu" title="University of Minnesota, Computer and Information Services">M. McCahill</a>, "<a href="http://tools.ietf.org/html/rfc1738">Uniform Resource Locators (URL)</a>", RFC 1738, December 1994.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2045">[RFC2045]</b></td>
<td class="top">
<a href="mailto:ned@innosoft.com" title="Innosoft International, Inc.">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com" title="First Virtual Holdings">N.S. Borenstein</a>, "<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>", RFC 2045, November 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2104">[RFC2104]</b></td>
<td class="top">
<a href="mailto:hugo@watson.ibm.com" title="IBM, T.J. Watson Research Center">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu" title="University of California at San Diego, Dept of Computer Science and Engineering">Bellare, M.</a> and <a href="mailto:canetti@watson.ibm.com" title="IBM T.J. Watson Research Center">R. Canetti</a>, "<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, February 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3339">[RFC3339]</b></td>
<td class="top">
<a href="mailto:GK@ACM.ORG" title="Clearswift Corporation">Klyne, G.</a> and <a href="mailto:chris.newman@sun.com" title="Sun Microsystems">C. Newman</a>, "<a href="http://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, July 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3447">[RFC3447]</b></td>
<td class="top">
<a>Jonsson, J.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>", RFC 3447, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4627">[RFC4627]</b></td>
<td class="top">
<a>Crockford, D.</a>, "<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>", RFC 4627, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS.180-3">[FIPS.180-3]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>Secure Hash Standard (SHS)</a>", FIPS PUB 180-3, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS.186-3">[FIPS.186-3]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>Digital Signature Standard (DSS)</a>", FIPS PUB 186-3, June 2009.</td>
</tr>
<tr>
<td class="reference"><b id="USA15">[USA15]</b></td>
<td class="top">
<a href="mailto:markdavis@google.com">Davis, M.</a>, <a href="mailto:ken@unicode.org">Whistler, K.</a> and <a>M. D&#252;rst</a>, "<a>Unicode Normalization Forms</a>", Unicode Standard Annex 15, 09 2009.</td>
</tr>
<tr>
<td class="reference"><b id="JWT">[JWT]</b></td>
<td class="top">
<a href="mailto:mbj@microsoft.com" title="Microsoft">Jones, M.B.</a>, <a href="mailto:balfanz@google.com" title="Google">Balfanz, D.</a>, <a href="mailto:ve7jtb@ve7jtb.com" title="independent">Bradley, J.</a>, <a href="mailto:yarong@microsoft.com" title="Microsoft">Goland, Y.Y.</a>, <a href="mailto:jpanzer@google.com" title="Google">Panzer, J.</a>, <a href="mailto:n-sakimura@nri.co.jp" title="Nomura Research Institute">Sakimura, N.</a> and <a href="mailto:pt@fb.com" title="Facebook">P. Tarjan</a>, "<a>JSON Web Token (JWT)</a>", March 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3275">[RFC3275]</b></td>
<td class="top">
<a>Eastlake, D.</a>, <a>Reagle, J.</a> and <a>D. Solo</a>, "<a href="http://tools.ietf.org/html/rfc3275">(Extensible Markup Language) XML-Signature Syntax and Processing</a>", RFC 3275, March 2002.</td>
</tr>
<tr>
<td class="reference"><b id="MagicSignatures">[MagicSignatures]</b></td>
<td class="top">
<a>Panzer (editor), J.</a>, <a>Laurie, B.</a> and <a>D. Balfanz</a>, "<a>Magic Signatures</a>", August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="JSS">[JSS]</b></td>
<td class="top">
<a title="independent">Bradley, J.</a> and <a title="Nomura Research Institute">N.  Sakimura (editor)</a>, "<a>JSON Simple Sign</a>", September 2010.</td>
</tr>
<tr>
<td class="reference"><b id="CanvasApp">[CanvasApp]</b></td>
<td class="top">
<a>Facebook, </a>, "<a>Canvas Applications</a>", 2010.</td>
</tr>
<tr>
<td class="reference"><b id="JWE">[JWE]</b></td>
<td class="top">
<a href="mailto:mbj@microsoft.com" title="Microsoft">Jones, M.B.</a>, <a href="mailto:ve7jtb@ve7jtb.com" title="independent">Bradley, J.</a> and <a href="mailto:n-sakimura@nri.co.jp" title="Nomura Research Institute">N. Sakimura</a>, "<a>JSON Web Encryption (JWE)</a>", March 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#JWSExamples" id="JWSExamples">JWS Examples</a>
</h1>
<p id="rfc.section.Appendix A.p.1">This section provides several examples of JWSs.  While these examples all represent JSON Web Tokens (JWTs) <a href="#JWT">[JWT]</a>, note that the payload can be any base64url encoded content.  </p>
<h1 id="rfc.appendix.Appendix A.1">
<a href="#rfc.appendix.Appendix%20A.1">Appendix A.1.</a> <a href="#HMACSHA256Example" id="HMACSHA256Example">JWS using HMAC SHA-256</a>
</h1>
<h1 id="rfc.appendix.Appendix A.1.1">
<a href="#rfc.appendix.Appendix%20A.1.1">Appendix A.1.1.</a> Encoding</h1>
<p id="rfc.section.Appendix A.1.1.p.1">The following example JSON header object declares that the data structure is a JSON Web Token (JWT) <a href="#JWT">[JWT]</a> and the JWS Signing Input is signed using the HMAC SHA-256 algorithm.  Note that white space is explicitly allowed in Decoded JWS Header Input strings and no canonicalization is performed before encoding.  </p>
<p id="rfc.section.Appendix A.1.1.p.2">The following byte array contains the UTF-8 characters for the Decoded JWS Header Input: </p>
<p id="rfc.section.Appendix A.1.1.p.3">[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125] </p>
<p id="rfc.section.Appendix A.1.1.p.4">Base64url encoding this UTF-8 representation yields this JWS Header Input value: </p>
<p id="rfc.section.Appendix A.1.1.p.5">The Decoded JWS Payload Input used in this example follows.  (Note that the payload can be any base64url encoded content, and need not be a base64url encoded JSON object.) </p>
<p id="rfc.section.Appendix A.1.1.p.6">The following byte array contains the UTF-8 characters for the Decoded JWS Payload Input: </p>
<p id="rfc.section.Appendix A.1.1.p.7">[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125] </p>
<p id="rfc.section.Appendix A.1.1.p.8">Base64url encoding the above yields the JWS Payload Input value: </p>
<p id="rfc.section.Appendix A.1.1.p.9">Concatenating the JWS Header Input, a period character, and the JWS Payload Input yields this JWS Signing Input value (with line breaks for display purposes only): </p>
<p id="rfc.section.Appendix A.1.1.p.10">The UTF-8 representation of the JWS Signing Input is the following byte array: </p>
<p id="rfc.section.Appendix A.1.1.p.11">[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81] </p>
<p id="rfc.section.Appendix A.1.1.p.12">HMACs are generated using keys. This example uses the key represented by the following byte array: </p>
<p id="rfc.section.Appendix A.1.1.p.13">[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163] </p>
<p id="rfc.section.Appendix A.1.1.p.14">Running the HMAC SHA-256 algorithm on the UTF-8 representation of the JWS Signing Input with this key yields the following byte array: </p>
<p id="rfc.section.Appendix A.1.1.p.15">[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121] </p>
<p id="rfc.section.Appendix A.1.1.p.16">Base64url encoding the above HMAC output yields the JWS Crypto Output value: </p>
<h1 id="rfc.appendix.Appendix A.1.2">
<a href="#rfc.appendix.Appendix%20A.1.2">Appendix A.1.2.</a> Decoding</h1>
<p id="rfc.section.Appendix A.1.2.p.1">Decoding the JWS first requires removing the base64url encoding from the JWS Header Input, the JWS Payload Input, and the JWS Crypto Output. We base64url decode the inputs per <a href="#base64urllogic">Section 6</a> and turn them into the corresponding byte arrays.  We translate the header input byte array containing UTF-8 encoded characters into the Decoded JWS Header Input string.  </p>
<h1 id="rfc.appendix.Appendix A.1.3">
<a href="#rfc.appendix.Appendix%20A.1.3">Appendix A.1.3.</a> Validating</h1>
<p id="rfc.section.Appendix A.1.3.p.1">Next we validate the decoded results.  Since the "alg" parameter in the header is "HS256", we validate the HMAC SHA-256 signature contained in the JWS Crypto Output.  If any of the validation steps fail, the signed content MUST be rejected.  </p>
<p id="rfc.section.Appendix A.1.3.p.2">First, we validate that the decoded JWS Header Input string is legal JSON.  </p>
<p id="rfc.section.Appendix A.1.3.p.3">To validate the signature, we repeat the previous process of using the correct key and the UTF-8 representation of the JWS Signing Input as input to a SHA-256 HMAC function and then taking the output and determining if it matches the Decoded JWS Crypto Output.  If it matches exactly, the signature has been validated.  </p>
<h1 id="rfc.appendix.Appendix A.2">
<a href="#rfc.appendix.Appendix%20A.2">Appendix A.2.</a> <a href="#RSASHA256Example" id="RSASHA256Example">JWS using RSA SHA-256</a>
</h1>
<h1 id="rfc.appendix.Appendix A.2.1">
<a href="#rfc.appendix.Appendix%20A.2.1">Appendix A.2.1.</a> Encoding</h1>
<p id="rfc.section.Appendix A.2.1.p.1">The Decoded JWS Header Input in this example is different from the previous example in two ways:  First, because a different algorithm is being used, the "alg" value is different.  Second, for illustration purposes only, the optional "typ" parameter is not used.  (This difference is not related to the signature algorithm employed.)  The Decoded JWS Header Input used is: </p>
<p id="rfc.section.Appendix A.2.1.p.2">The following byte array contains the UTF-8 characters for the Decoded JWS Header Input: </p>
<p id="rfc.section.Appendix A.2.1.p.3">[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125] </p>
<p id="rfc.section.Appendix A.2.1.p.4">Base64url encoding this UTF-8 representation yields this JWS Header Input value: </p>
<p id="rfc.section.Appendix A.2.1.p.5">The Decoded JWS Payload Input used in this example, which follows, is the same as in the previous example.  Since the JWS Payload Input will therefore be the same, its computation is not repeated here.  </p>
<p id="rfc.section.Appendix A.2.1.p.6">Concatenating the JWS Header Input, a period character, and the JWS Payload Input yields this JWS Signing Input value (with line breaks for display purposes only): </p>
<p id="rfc.section.Appendix A.2.1.p.7">The UTF-8 representation of the JWS Signing Input is the following byte array: </p>
<p id="rfc.section.Appendix A.2.1.p.8">[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81] </p>
<p id="rfc.section.Appendix A.2.1.p.9">The RSA key consists of a public part (n, e), and a private exponent d.  The values of the RSA key used in this example, presented as the byte arrays representing big endian integers are: </p>
<div id="#rfc.table.4"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Parameter Name</th>
<th class="left">Value</th>
</tr></thead>
<tbody>
<tr>
<td class="left">n</td>
<td class="left">[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161] </td>
</tr>
<tr>
<td class="left">e</td>
<td class="left">[1, 0, 1] </td>
</tr>
<tr>
<td class="left">d</td>
<td class="left">[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157] </td>
</tr>
</tbody>
</table>
<p id="rfc.section.Appendix A.2.1.p.10">The RSA private key (n, d) is then passed to the RSA signing function, which also takes the hash type, SHA-256, and the UTF-8 representation of the JWS Signing Input as inputs.  The result of the signature is a byte array S, which represents a big endian integer.  In this example, S is: </p>
<div id="#rfc.table.5"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Result Name</th>
<th class="left">Value</th>
</tr></thead>
<tbody><tr>
<td class="left">S</td>
<td class="left">[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71] </td>
</tr></tbody>
</table>
<p id="rfc.section.Appendix A.2.1.p.11">Base64url encoding the signature produces this value for the JWS Crypto Output: </p>
<h1 id="rfc.appendix.Appendix A.2.2">
<a href="#rfc.appendix.Appendix%20A.2.2">Appendix A.2.2.</a> Decoding</h1>
<p id="rfc.section.Appendix A.2.2.p.1">Decoding the JWS from this example requires processing the JWS Header Input and JWS Payload Input exactly as done in the first example.  </p>
<h1 id="rfc.appendix.Appendix A.2.3">
<a href="#rfc.appendix.Appendix%20A.2.3">Appendix A.2.3.</a> Validating</h1>
<p id="rfc.section.Appendix A.2.3.p.1">Since the "alg" parameter in the header is "RS256", we validate the RSA SHA-256 signature contained in the JWS Crypto Output.  If any of the validation steps fail, the signed content MUST be rejected.  </p>
<p id="rfc.section.Appendix A.2.3.p.2">First, we validate that the decoded JWS Header Input string is legal JSON.  </p>
<p id="rfc.section.Appendix A.2.3.p.3">Validating the JWS Crypto Output is a little different from the previous example. First, we base64url decode the JWS Crypto Output to produce a signature S to check.  We then pass (n, e), S and the UTF-8 representation of the JWS Signing Input to an RSA signature verifier that has been configured to use the SHA-256 hash function.  </p>
<h1 id="rfc.appendix.Appendix A.3">
<a href="#rfc.appendix.Appendix%20A.3">Appendix A.3.</a> <a href="#ECDSASHA256Example" id="ECDSASHA256Example">JWS using ECDSA P-256 SHA-256</a>
</h1>
<h1 id="rfc.appendix.Appendix A.3.1">
<a href="#rfc.appendix.Appendix%20A.3.1">Appendix A.3.1.</a> Encoding</h1>
<p id="rfc.section.Appendix A.3.1.p.1">The Decoded JWS Header Input for this example differs from the previous example because a different algorithm is being used.  The Decoded JWS Header Input used is: </p>
<p id="rfc.section.Appendix A.3.1.p.2">The following byte array contains the UTF-8 characters for the Decoded JWS Header Input: </p>
<p id="rfc.section.Appendix A.3.1.p.3">[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125] </p>
<p id="rfc.section.Appendix A.3.1.p.4">Base64url encoding this UTF-8 representation yields this JWS Header Input value: </p>
<p id="rfc.section.Appendix A.3.1.p.5">The Decoded JWS Payload Input used in this example, which follows, is the same as in the previous examples.  Since the JWS Payload Input will therefore be the same, its computation is not repeated here.  </p>
<p id="rfc.section.Appendix A.3.1.p.6">Concatenating the JWS Header Input, a period character, and the JWS Payload Input yields this JWS Signing Input value (with line breaks for display purposes only): </p>
<p id="rfc.section.Appendix A.3.1.p.7">The UTF-8 representation of the JWS Signing Input is the following byte array: </p>
<p id="rfc.section.Appendix A.3.1.p.8">[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81] </p>
<p id="rfc.section.Appendix A.3.1.p.9">The ECDSA key consists of a public part, the EC point (x, y), and a private part d.  The values of the ECDSA key used in this example, presented as the byte arrays representing big endian integers are: </p>
<div id="#rfc.table.6"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Parameter Name</th>
<th class="left">Value</th>
</tr></thead>
<tbody>
<tr>
<td class="left">x</td>
<td class="left">[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69] </td>
</tr>
<tr>
<td class="left">y</td>
<td class="left">[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173] </td>
</tr>
<tr>
<td class="left">d</td>
<td class="left">[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178] </td>
</tr>
</tbody>
</table>
<p id="rfc.section.Appendix A.3.1.p.10">The ECDSA private part d is then passed to an ECDSA signing function, which also takes the curve type, P-256, the hash type, SHA-256, and the UTF-8 representation of the JWS Signing Input as inputs.  The result of the signature is the EC point (R, S), where R and S are unsigned integers.  In this example, the R and S values, given as byte arrays representing big endian integers are: </p>
<div id="#rfc.table.7"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Result Name</th>
<th class="left">Value</th>
</tr></thead>
<tbody>
<tr>
<td class="left">R</td>
<td class="left">[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101] </td>
</tr>
<tr>
<td class="left">S</td>
<td class="left">[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213] </td>
</tr>
</tbody>
</table>
<p id="rfc.section.Appendix A.3.1.p.11">Concatenating the S array to the end of the R array and base64url encoding the result produces this value for the JWS Crypto Output: </p>
<h1 id="rfc.appendix.Appendix A.3.2">
<a href="#rfc.appendix.Appendix%20A.3.2">Appendix A.3.2.</a> Decoding</h1>
<p id="rfc.section.Appendix A.3.2.p.1">Decoding the JWS from this example requires processing the JWS Header Input and JWS Payload Input exactly as done in the first example.  </p>
<h1 id="rfc.appendix.Appendix A.3.3">
<a href="#rfc.appendix.Appendix%20A.3.3">Appendix A.3.3.</a> Validating</h1>
<p id="rfc.section.Appendix A.3.3.p.1">Since the "alg" parameter in the header is "ES256", we validate the ECDSA P-256 SHA-256 signature contained in the JWS Crypto Output.  If any of the validation steps fail, the signed content MUST be rejected.  </p>
<p id="rfc.section.Appendix A.3.3.p.2">First, we validate that the decoded JWS Header Input string is legal JSON.  </p>
<p id="rfc.section.Appendix A.3.3.p.3">Validating the JWS Crypto Output is a little different from the first example. First, we base64url decode the JWS Crypto Output as in the previous examples but we then need to split the 64 member byte array that must result into two 32 byte arrays, the first R and the second S. We then pass (x, y), (R, S) and the UTF-8 representation of the JWS Signing Input to an ECDSA signature verifier that has been configured to use the P-256 curve with the SHA-256 hash function.  </p>
<p id="rfc.section.Appendix A.3.3.p.4">As explained in <a href="#DefiningECDSA">Section 7.3</a>, the use of the k value in ECDSA means that we cannot validate the correctness of the signature in the same way we validated the correctness of the HMAC. Instead, implementations MUST use an ECDSA validator to validate the signature.  </p>
<h1 id="rfc.appendix.Appendix B">
<a href="#rfc.appendix.Appendix%20B">Appendix B.</a> <a href="#base64urlnotes" id="base64urlnotes">Notes on implementing base64url encoding without padding</a>
</h1>
<p id="rfc.section.Appendix B.p.1">This appendix describes how to implement base64url encoding and decoding functions without padding based upon standard base64 encoding and decoding functions that do use padding.  </p>
<p id="rfc.section.Appendix B.p.2">To be concrete, example C# code implementing these functions is shown below.  Similar code could be used in other languages.  </p>
<p id="rfc.section.Appendix B.p.3">As per the example code above, the number of '=' padding characters that needs to be added to the end of a base64url encoded string without padding to turn it into one with padding is a deterministic function of the length of the encoded string.  Specifically, if the length mod 4 is 0, no padding is added; if the length mod 4 is 2, two '=' padding characters are added; if the length mod 4 is 3, one '=' padding character is added; if the length mod 4 is 1, the input is malformed.  </p>
<p id="rfc.section.Appendix B.p.4">An example correspondence between unencoded and encoded values follows.  The byte sequence below encodes into the string below, which when decoded, reproduces the byte sequence.  </p>
<h1 id="rfc.appendix.Appendix C">
<a href="#rfc.appendix.Appendix%20C">Appendix C.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.Appendix C.p.1">Solutions for signing JSON content were previously explored by <a href="#MagicSignatures">Magic Signatures</a> <cite title="NONE">[MagicSignatures]</cite>, <a href="#JSS">JSON Simple Sign</a> <cite title="NONE">[JSS]</cite>, and <a href="#CanvasApp">Canvas Applications</a> <cite title="NONE">[CanvasApp]</cite>, all of which influenced this draft.  </p>
<h1 id="rfc.appendix.Appendix D">
<a href="#rfc.appendix.Appendix%20D">Appendix D.</a> Document History</h1>
<p id="rfc.section.Appendix D.p.1">-00 </p>

<ul><li>Created first signature draft using content split from draft-jones-json-web-token-01.  This split introduced no semantic changes.  </li></ul>

<p> </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael B. Jones</span> 
	  <span class="n hidden">
		<span class="family-name">Jones</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbj@microsoft.com">mbj@microsoft.com</a></span>

<span class="vcardline">URI: <a href="http://self-issued.info/">http://self-issued.info/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dirk Balfanz</span> 
	  <span class="n hidden">
		<span class="family-name">Balfanz</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:balfanz@google.com">balfanz@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Bradley</span> 
	  <span class="n hidden">
		<span class="family-name">Bradley</span>
	  </span>
	</span>
	<span class="org vcardline">independent</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ve7jtb@ve7jtb.com">ve7jtb@ve7jtb.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Yaron Y. Goland</span> 
	  <span class="n hidden">
		<span class="family-name">Goland</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:yarong@microsoft.com">yarong@microsoft.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Panzer</span> 
	  <span class="n hidden">
		<span class="family-name">Panzer</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jpanzer@google.com">jpanzer@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nat Sakimura</span> 
	  <span class="n hidden">
		<span class="family-name">Sakimura</span>
	  </span>
	</span>
	<span class="org vcardline">Nomura Research Institute</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:n-sakimura@nri.co.jp">n-sakimura@nri.co.jp</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Paul Tarjan</span> 
	  <span class="n hidden">
		<span class="family-name">Tarjan</span>
	  </span>
	</span>
	<span class="org vcardline">Facebook</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:pt@fb.com">pt@fb.com</a></span>

  </address>
</div>

</body>
</html>