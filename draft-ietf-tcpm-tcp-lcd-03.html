<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Making TCP more Robust to Long Connectivity Disruptions (TCP-LCD)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Making TCP more Robust to Long Connectivity Disruptions (TCP-LCD)">
<meta name="keywords" content="Transmission Control Protocol (TCP),
        Internet Control Message Protocol (ICMP), Long Connectivity
        Disruption (LCD)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">TCP Maintenance and Minor</td><td class="header">A. Zimmermann</td></tr>
<tr><td class="header">Extensions (TCPM) WG</td><td class="header">A. Hannemann</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">RWTH Aachen University</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">September 14, 2010</td></tr>
<tr><td class="header">Expires: March 18, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Making TCP more Robust to Long Connectivity Disruptions (TCP-LCD)<br />draft-ietf-tcpm-tcp-lcd-03</h1>

<h3>Abstract</h3>

<p>Disruptions in end-to-end path connectivity, which last longer
            than one retransmission timeout, cause suboptimal TCP performance.
            The reason for this performance degradation is that TCP interprets
            segment loss induced by long connectivity disruptions as a sign of
            congestion, resulting in repeated retransmission timer backoffs.
            This, in turn, leads to a delayed detection of the re-establishment
            of the connection since TCP waits for the next retransmission
            timeout before it attempts a retransmission.
</p>
<p>This document proposes an algorithm to make TCP more
            robust to long connectivity disruptions (TCP-LCD). It describes how
            standard ICMP messages can be exploited during timeout-based loss
            recovery to disambiguate true congestion loss from non-congestion
            loss caused by connectivity disruptions. Moreover, a reversion
            strategy of the retransmission timer is specified that enables a
            more prompt detection of whether or not the connectivity to a
            previously disconnected peer node has been restored. TCP-LCD is a
            TCP sender-only modification that effectively improves TCP
            performance in case of connectivity disruptions.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on March 18, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#terminology">1.</a>&nbsp;
Terminology<br />
<a href="#intro">2.</a>&nbsp;
Introduction<br />
<a href="#cdi">3.</a>&nbsp;
Connectivity Disruption Indication<br />
<a href="#cdr">4.</a>&nbsp;
Connectivity Disruption Reaction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#alg_idea">4.1.</a>&nbsp;
Basic Idea<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#alg">4.2.</a>&nbsp;
Algorithm Details<br />
<a href="#discussion">5.</a>&nbsp;
Discussion of TCP-LCD<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#discuss_retrans_ambiguity">5.1.</a>&nbsp;
Retransmission Ambiguity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#discuss_wrap_sequence_numbers">5.2.</a>&nbsp;
Wrapped Sequence Numbers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#discuss_packet_dup">5.3.</a>&nbsp;
Packet Duplication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#discuss_probing_frequency">5.4.</a>&nbsp;
Probing Frequency<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#discuss_syn">5.5.</a>&nbsp;
Reaction during Connection Establishment<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#discuss_steady-state">5.6.</a>&nbsp;
Reaction in Steady-State<br />
<a href="#algo_save">6.</a>&nbsp;
Dissolving Ambiguity Issues using the TCP Timestamps Option<br />
<a href="#interoperability">7.</a>&nbsp;
Interoperability Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#interaction_rfc1122">7.1.</a>&nbsp;
Detection of TCP Connection Failures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#interaction_ecn">7.2.</a>&nbsp;
Explicit Congestion Notification (ECN)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#interaction_tunnels">7.3.</a>&nbsp;
TCP-LCD and IP Tunnels<br />
<a href="#related_work">8.</a>&nbsp;
Related Work<br />
<a href="#iana">9.</a>&nbsp;
IANA Considerations<br />
<a href="#security">10.</a>&nbsp;
Security Considerations<br />
<a href="#acks">11.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#changes">Appendix&nbsp;A.</a>&nbsp;
Changes from previous versions of the draft<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changes_06">A.1.</a>&nbsp;
Changes from
                draft-ietf-tcpm-tcp-lcd-02<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changes_05">A.2.</a>&nbsp;
Changes from
                draft-ietf-tcpm-tcp-lcd-01<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changes_04">A.3.</a>&nbsp;
Changes from draft-ietf-tcpm-tcp-lcd-00<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changes_03">A.4.</a>&nbsp;
Changes from draft-zimmermann-tcp-lcd-02<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changes_02">A.5.</a>&nbsp;
Changes from draft-zimmermann-tcp-lcd-01<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changes_01">A.6.</a>&nbsp;
Changes from draft-zimmermann-tcp-lcd-00<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
            "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
            "OPTIONAL" in this document are to be interpreted as described in
            <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p>The reader should be familiar with the algorithm and terminology
            from <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>, which defines the standard
            algorithm Transmission Control Protocol (TCP) senders are required
            to use to compute and manage their retransmission timer. In this
            document, the terms "retransmission timer" and "retransmission
            timeout" are used as defined in <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>. The
            retransmission timer ensures data delivery in the absence of any
            feedback from the receiver.  The duration of this timer is referred
            to as retransmission timeout (RTO).
</p>
<p>As defined in <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, the term "acceptable
            acknowledgment (ACK)" refers to a TCP segment that acknowledges
            previously unacknowledged data. The TCP sender state variable
            "SND.UNA" and the current segment variable "SEG.SEQ" are used as
            defined in <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>. SND.UNA holds the segment
            sequence number of earliest segment that has not been acknowledged
            by the TCP receiver (the oldest outstanding segment). SEG.SEQ is
            the segment sequence number of a given segment.
</p>
<p>For the purposes of this specification, we define the term
            "timeout-based loss recovery" that refers to the state that a TCP
            sender enters upon the first timeout of the oldest outstanding
            segment (SND.UNA) and leaves upon the arrival of the *first*
            acceptable ACK. It is important to note that other documents use a
            different interpretation of the term "timeout-based loss recovery".
            For example, the NewReno modification to TCP's Fast Recovery
            algorithm <a class='info' href='#RFC3782'>[RFC3782]<span> (</span><span class='info'>Floyd, S., Henderson, T., and A. Gurtov, &ldquo;The NewReno Modification to TCP's Fast Recovery Algorithm,&rdquo; April&nbsp;2004.</span><span>)</span></a> extents the period a TCP sender
            remains in timeout-based loss recovery compared to the one defined
            in this document. This is because <a class='info' href='#RFC3782'>[RFC3782]<span> (</span><span class='info'>Floyd, S., Henderson, T., and A. Gurtov, &ldquo;The NewReno Modification to TCP's Fast Recovery Algorithm,&rdquo; April&nbsp;2004.</span><span>)</span></a>
            attempts to avoid unnecessary multiple Fast Retransmits that can
            occur after an RTO.
</p>
<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Introduction</h3>

<p>Connectivity disruptions can occur in many different situations.
            The frequency of connectivity disruptions depends on the properties
            of the end-to-end path between the communicating hosts. While
            connectivity disruptions can occur in traditional wired networks,
            e.g., caused by an unplugged network cable, the likelihood of
            their occurrence is significantly higher in wireless (multi-hop)
            networks. Especially, end-host mobility, network topology changes,
            and wireless interferences are crucial factors. In the case of the
            Transmission Control Protocol (TCP) <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, the
            performance of the connection can experience a significant
            reduction compared to a permanently connected path
            <a class='info' href='#SESB05'>[SESB05]<span> (</span><span class='info'>Schuetz, S., Eggert, L., Schmid, S., and M. Brunner, &ldquo;Protocol enhancements for intermittently connected                         hosts,&rdquo; December&nbsp;2005.</span><span>)</span></a>. This is because TCP, which was originally
            designed to operate in fixed and wired networks, generally assumes
            that the end-to-end path connectivity is relatively stable over the
            connection's lifetime.
</p>
<p>Depending on their duration, connectivity disruptions can be
            classified into two groups
            <a class='info' href='#I-D.schuetz-tcpm-tcp-rlci'>[I&#8209;D.schuetz&#8209;tcpm&#8209;tcp&#8209;rlci]<span> (</span><span class='info'>Schuetz, S., Koutsianas, N., Eggert, L., Eddy, W., Swami, Y., and K. Le, &ldquo;TCP Response to Lower-Layer Connectivity-Change Indications,&rdquo; February&nbsp;2008.</span><span>)</span></a>: "short" and "long". A
            connectivity disruption is "short" if connectivity returns before
            the retransmission timer fires for the first time. In this case,
            TCP recovers lost data segments through Fast Retransmit and lost
            acknowledgments (ACK) through successfully delivered later ACKs.
            Connectivity disruptions are declared as "long" for a given TCP
            connection if the retransmission timer fires at least once before
            connectivity is resumed. Whether or not path characteristics, like
            the round trip time (RTT) or the available bandwidth, have changed
            when connectivity resumes after a disruption is another important
            aspect for TCP's retransmission scheme
            <a class='info' href='#I-D.schuetz-tcpm-tcp-rlci'>[I&#8209;D.schuetz&#8209;tcpm&#8209;tcp&#8209;rlci]<span> (</span><span class='info'>Schuetz, S., Koutsianas, N., Eggert, L., Eddy, W., Swami, Y., and K. Le, &ldquo;TCP Response to Lower-Layer Connectivity-Change Indications,&rdquo; February&nbsp;2008.</span><span>)</span></a>.
</p>
<p>The algorithm specified in this document improves TCP's behavior
            in case of "long connectivity disruptions". In particular, it
            focuses on the period prior to the re-establishment of the
            connectivity to a previously disconnected peer node. The document
            does not describe any modifications to TCP's behavior and its
            congestion control mechanisms <a class='info' href='#RFC5681'>[RFC5681]<span> (</span><span class='info'>Allman, M., Paxson, V., and E. Blanton, &ldquo;TCP Congestion Control,&rdquo; September&nbsp;2009.</span><span>)</span></a> after
            connectivity has been restored.
</p>
<p>When a long connectivity disruption occurs on a TCP connection,
            the TCP sender eventually does not receive any more
            acknowledgments. After the retransmission timer expires, the TCP
            sender enters the timeout-based loss recovery and declares the
            oldest outstanding segment (SND.UNA) as lost. Since TCP tightly
            couples reliability and congestion control, the retransmission of
            SND.UNA is triggered together with the reduction of the
            transmission rate. This is based on the assumption that segment
            loss is an indication of congestion <a class='info' href='#RFC5681'>[RFC5681]<span> (</span><span class='info'>Allman, M., Paxson, V., and E. Blanton, &ldquo;TCP Congestion Control,&rdquo; September&nbsp;2009.</span><span>)</span></a>. As
            long as the connectivity disruption persists, TCP will repeat this
            procedure until the oldest outstanding segment has successfully
            been acknowledged, or until the connection has timed out. TCP
            implementations that follow the recommended retransmission timeout
            (RTO) management of <a class='info' href='#RFC2988'>RFC&nbsp;2988<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> [RFC2988]
            double the RTO after each retransmission attempt. However, the
            RTO growth may be bounded by an upper limit, the maximum RTO,
            which is at least 60s, but may be longer: Linux, for example, uses
            120s. If connectivity is restored between two retransmission
            attempts, TCP still has to wait until the retransmission timer
            expires before resuming transmission, since it simply does not have
            any means to know if the connectivity has been re-established.
            Therefore, depending on when connectivity becomes available again,
            this can waste up to a maximum RTO of possible transmission
            time.
</p>
<p>This retransmission behavior is not efficient, especially in
            scenarios with long connectivity disruptions. In the ideal case,
            TCP would attempt a retransmission as soon as connectivity to its
            peer has been re-established. In this document, we specify a TCP
            sender-only modification to provide robustness to long connectivity
            disruptions (TCP-LCD). The memo describes how the standard Internet
            Control Message Protocol (ICMP) can be exploited during
            timeout-based loss recovery to identify non-congestion loss caused
            by long connectivity disruptions. TCP-LCD's reversion strategy of
            the retransmission timer enables higher-frequency retransmissions
            and thereby a prompt detection when connectivity to a previously
            disconnected peer node has been restored. If no congestion is
            present, TCP-LCD approaches the ideal behavior.
</p>
<p>Experimental results of a Linux implementation of TCP-LCD have
            been presented in <a class='info' href='#ZimHan09'>[ZimHan09]<span> (</span><span class='info'>Zimmermann, A., &ldquo;Make TCP more Robust to Long Connectivity Disruptions,&rdquo; July&nbsp;2009.</span><span>)</span></a>. The implementation
            has been incorporated into mainline Linux, and is already used
            within the Internet. Thus far, no negative experiences have been
            reported that could be attributed to the algorithm. However, we
            consider TCP-LCD as experimental until more real-life results have
            been obtained.  Nevertheless, we encourage implementation of
            TCP-LCD under other operating systems to provide for broader
            testing and experimentation opportunities.
</p>
<a name="cdi"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Connectivity Disruption Indication</h3>

<p>If the queue of an intermediate router that is experiencing a link
            outage can buffer all incoming packets, a connectivity disruption
            will only cause a variation in delay, which is handled well by TCP
            implementations using either Eifel <a class='info' href='#RFC3522'>[RFC3522]<span> (</span><span class='info'>Ludwig, R. and M. Meyer, &ldquo;The Eifel Detection Algorithm for TCP,&rdquo; April&nbsp;2003.</span><span>)</span></a>,
            <a class='info' href='#RFC4015'>[RFC4015]<span> (</span><span class='info'>Ludwig, R. and A. Gurtov, &ldquo;The Eifel Response Algorithm for TCP,&rdquo; February&nbsp;2005.</span><span>)</span></a> or Forward RTO-Recovery (F-RTO)
            <a class='info' href='#RFC5682'>[RFC5682]<span> (</span><span class='info'>Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata, &ldquo;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP,&rdquo; September&nbsp;2009.</span><span>)</span></a>. However, if the link outage lasts for
            too long, the router experiencing the link outage is forced to drop
            packets, and finally to discard the according route. Means to
            detect such link outages include reacting on failed address
            resolution protocol (ARP) <a class='info' href='#RFC0826'>[RFC0826]<span> (</span><span class='info'>Plummer, D., &ldquo;Ethernet Address Resolution Protocol: Or converting network protocol addresses to 48.bit Ethernet address for transmission on Ethernet hardware,&rdquo; November&nbsp;1982.</span><span>)</span></a> queries,
            unsuccessful link sensing, and the like. However, this is solely in
            the responsibility of the respective router.

                </p>
<blockquote class="text">
<p>Note: The focus of this memo is on introducing a method
                    how ICMP messages may be exploited to improve TCP's
                    performance; how different physical and link layer
                    mechanisms below the network layer may trigger ICMP
                    destination unreachable messages are out of scope of this
                    memo.
</p>
</blockquote><p>
            
</p>
<p>Provided that no other route to the specific destination exists,
            an Internet Protocol version 4 (IPv4) <a class='info' href='#RFC0791'>[RFC0791]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>
            router will notify the corresponding sending host about the dropped
            packets via ICMP destination unreachable messages of code 0 (net
            unreachable) or code 1 (host unreachable) <a class='info' href='#RFC1812'>[RFC1812]<span> (</span><span class='info'>Baker, F., &ldquo;Requirements for IP Version 4 Routers,&rdquo; June&nbsp;1995.</span><span>)</span></a>.
            Therefore, the sending host can use the ICMP destination
            unreachable messages of these codes as an indication for a
            connectivity disruption, since the reception of these messages
            provide evidence that packets were dropped due to a link
            outage.
</p>
<p>For Internet Protocol version 6 (IPv6) <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>,
            the counterpart of the ICMP destination unreachable message of code
            0 (net unreachable) and of code 1 (host unreachable) is the ICMPv6
            destination unreachable message of code 0 (no route to destination)
            <a class='info' href='#RFC4443'>[RFC4443]<span> (</span><span class='info'>Conta, A., Deering, S., and M. Gupta, &ldquo;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification,&rdquo; March&nbsp;2006.</span><span>)</span></a>. As with IPv4, a router should generate
            an ICMPv6 destination unreachable message of code 0 in response to
            a packet that cannot be delivered to its destination address
            because it lacks a matching entry in its routing table.
</p>
<p>Note that there are also other ICMP and ICMPv6 destination
            unreachable messages with different codes. Some of them are
            candidates for connectivity disruption indications, too, but need
            further investigation. For example, ICMP destination unreachable
            messages with code 5 (source route failed), code 11 (net
            unreachable for TOS), or code 12 (host unreachable for TOS) <a class='info' href='#RFC1812'>[RFC1812]<span> (</span><span class='info'>Baker, F., &ldquo;Requirements for IP Version 4 Routers,&rdquo; June&nbsp;1995.</span><span>)</span></a>.
            On the other hand, codes that flag hard errors
            are of no use for this scheme, since TCP should abort the
            connection when those are received <a class='info' href='#RFC1122'>[RFC1122]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>.
</p>
<p>For the sake of simplicity, we will use, unless explicitly
            qualified with ICMPv4 or ICMPv6, the term "ICMP unreachable
            message" as synonym for ICMP destination unreachable messages of
            code 0 or code 1 and ICMPv6 destination unreachable of code 0. This
            implies that all keywords from <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> that deal
            with the handling of received ICMP messages apply in the same way
            to ICMPv6 messages.
</p>
<p>The accurate interpretation of ICMP unreachable messages as a
            connectivity disruption indication is complicated by the following
            two peculiarities of ICMP messages. First, they do not
            necessarily operate on the same timescale as the packets, i.e., TCP
            segments that elicited them. When a router drops a packet due to a
            missing route, it will not necessarily send an ICMP unreachable
            message immediately, but will rather queue it for later delivery.
            Second, ICMP messages are subject to rate limiting, e.g., when a
            router drops a whole window of data due to a link outage, it is
            unlikely to send as many ICMP unreachable messages as dropped TCP
            segments. Depending on the load of the router, it may not even send
            any ICMP unreachable messages at all. Both peculiarities originate
            from <a class='info' href='#RFC1812'>[RFC1812]<span> (</span><span class='info'>Baker, F., &ldquo;Requirements for IP Version 4 Routers,&rdquo; June&nbsp;1995.</span><span>)</span></a> for ICMPv4 and <a class='info' href='#RFC4443'>[RFC4443]<span> (</span><span class='info'>Conta, A., Deering, S., and M. Gupta, &ldquo;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification,&rdquo; March&nbsp;2006.</span><span>)</span></a>
            for ICMPv6.
</p>
<p>Fortunately, according to <a class='info' href='#RFC0792'>[RFC0792]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Control Message Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, ICMPv4
            unreachable messages have to contain in their body the entire
            IPv4 header <a class='info' href='#RFC0791'>[RFC0791]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> of the
            datagram eliciting the ICMPv4 unreachable message, plus the first 64
            bits of the payload of that datagram. This allows the sending host
            to match the ICMPv4 error message to the transport connection that
            elicited it. <a class='info' href='#RFC1812'>RFC 1812<span> (</span><span class='info'>Baker, F., &ldquo;Requirements for IP Version 4 Routers,&rdquo; June&nbsp;1995.</span><span>)</span></a> [RFC1812] augments these
            requirements and states that ICMPv4 messages should contain as much
            of the original datagram as possible without the length of the ICMPv4
            datagram exceeding 576 bytes. Therefore, in case of TCP, at least
            the source port number, the destination port number, and the 32-bit
            TCP sequence number are included. This allows the originating TCP
            to demultiplex the received ICMPv4 message and to identify the
            affected connection. Moreover, it can identify which segment of the
            respective connection triggered the ICMPv4 unreachable message,
            unless there are several segments in-flight with the same sequence
            number (see <a class='info' href='#discuss_retrans_ambiguity'>Section&nbsp;5.1<span> (</span><span class='info'>Retransmission Ambiguity</span><span>)</span></a>).
</p>
<p>For IPv6 <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>, the payload of an ICMPv6
            error messages has to include as many bytes as possible from the
            IPv6 datagram that elicited the ICMPv6 error message, without
            making the error message exceed the minimum IPv6 MTU (1280 bytes)
            <a class='info' href='#RFC4443'>[RFC4443]<span> (</span><span class='info'>Conta, A., Deering, S., and M. Gupta, &ldquo;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification,&rdquo; March&nbsp;2006.</span><span>)</span></a>. Thus, enough information is available
            to identify both, the affected connection and the corresponding
            segment that triggered the ICMPv6 error message.
</p>
<p>A connectivity disruption indication in form of an ICMP
            unreachable message associated with a presumably lost TCP segment
            provides strong evidence that the segment was not dropped due to
            congestion, but was successfully delivered as far as the reporting
            router. It therefore did not witness any congestion at least on
            that part of the path that was traversed by both the TCP segment
            eliciting the ICMP unreachable message as well as the ICMP
            unreachable message itself.
</p>
<a name="cdr"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Connectivity Disruption Reaction</h3>

<p><a class='info' href='#alg_idea'>Section&nbsp;4.1<span> (</span><span class='info'>Basic Idea</span><span>)</span></a> introduces the basic idea of TCP-LCD. The
            complete algorithm is specified in <a class='info' href='#alg'>Section&nbsp;4.2<span> (</span><span class='info'>Algorithm Details</span><span>)</span></a>.
</p>
<a name="alg_idea"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Basic Idea</h3>

<p>The goal of the algorithm is to promptly detect when
                connectivity to a previously disconnected peer node has been
                restored after a long connectivity disruption, while retaining
                appropriate behavior in case of congestion. TCP-LCD exploits
                standard ICMP unreachable messages during timeout-based loss
                recovery. This increases TCP's retransmission frequency by
                undoing one retransmission timer backoff whenever an ICMP
                unreachable message is received that contains a segment with
                a sequence number of a presumably lost retransmission.
</p>
<p>This approach has the advantage of appropriately reducing the
                probing rate in case of congestion. If either the
                retransmission itself or the corresponding ICMP message is
                dropped the previously performed retransmission timer backoff
                is not undone, which effectively halves the probing rate.
</p>
<a name="alg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Algorithm Details</h3>

<p>A TCP sender that uses <a class='info' href='#RFC2988'>RFC&nbsp;2988<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> [RFC2988] to compute TCP's retransmission timer MAY
                employ the following scheme to avoid over-conservative
                retransmission timer backoffs in case of long connectivity
                disruptions. If a TCP sender does implement the following
                steps, the algorithm MUST be initiated upon the first timeout
                of the oldest outstanding segment (SND.UNA) and MUST be stopped
                upon the arrival of the first acceptable ACK. The algorithm
                MUST NOT be re-initiated upon subsequent timeouts for the same
                segment. The scheme SHOULD NOT be used in SYN-SENT or
                SYN-RECEIVED states <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> (see
                <a class='info' href='#discuss_syn'>Section&nbsp;5.5<span> (</span><span class='info'>Reaction during Connection Establishment</span><span>)</span></a>).
</p>
<p>A TCP sender that does not employ
                <a class='info' href='#RFC2988'>RFC&nbsp;2988<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> [RFC2988] to compute TCP's
                retransmission timer MUST NOT use TCP-LCD. We envision that
                the scheme could be easily adapted to algorithms others than
                RFC&nbsp;2988. However, we leave this as future work.
</p>
<p>In rule (2.5), <a class='info' href='#RFC2988'>RFC&nbsp;2988<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> [RFC2988]
                provides the option to place a maximum value on the RTO. When a
                TCP implements this rule to provide an upper bound for the RTO,
                it MUST also be used in the following algorithm. In
                particular, if the RTO is bounded by an upper limit (maximum
                RTO), the "MAX_RTO" variable used in this scheme MUST be
                initialized with this upper limit. Otherwise, if the RTO is
                unbounded, the "MAX_RTO" variable MUST be set to
                infinity.
</p>
<p>The scheme specified in this document uses the "BACKOFF_CNT"
                variable, whose initial value is zero. The variable is used to
                count the number of performed retransmission timer backoffs
                during one timeout-based loss recovery. Moreover, the
                "RTO_BASE" variable is used to recover the previous RTO if the
                retransmission timer backoff was unnecessary. The variable is
                initialized with the RTO upon initiation of timeout-based loss
                recovery.
</p>
<p>
                    </p>
<blockquote class="text"><dl>
<dt>(1)</dt>
<dd>Before TCP updates the variable "RTO" when it
                        initiates timeout-based loss recovery, set the variables
                        "BACKOFF_CNT" and "RTO_BASE" as follows:
                            
<blockquote class="text">
<p>BACKOFF_CNT := 0;
</p>
<p>RTO_BASE := RTO.
</p>
</blockquote>
                        Proceed to step (R).
</dd>
</dl></blockquote><p>

                    </p>
<blockquote class="text"><dl>
<dt>(R)</dt>
<dd>This is a placeholder for standard TCP's
                        behavior in case the retransmission timer has expired.
                        In particular, if
                        <a class='info' href='#RFC2988'>RFC&nbsp;2988<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> [RFC2988] is used,
                        steps (5.4) - (5.6) of that algorithm go here. Proceed
                        to step (2).
</dd>
</dl></blockquote><p>

                    </p>
<blockquote class="text"><dl>
<dt>(2)</dt>
<dd>To account for the expiration of the retransmission
                        timer in the previous step (R), increment the
                        "BACKOFF_CNT" variable by one:
                            
<blockquote class="text">
<p>BACKOFF_CNT := BACKOFF_CNT + 1.
</p>
</blockquote>
                        
</dd>
<dt>(3)</dt>
<dd>Wait either
                            
<blockquote class="text">
<p>for the expiration of the retransmission
                                timer. When the retransmission timer expires,
                                proceed to step (R);
</p>
<p>or for the arrival of an acceptable ACK. When
                                an acceptable ACK arrives, proceed to step (A);
                                
</p>
<p>or for the arrival of an ICMP unreachable
                                message. When the ICMP unreachable message
                                "ICMP_DU" arrives, proceed to step (4).
</p>
</blockquote>
                        
</dd>
</dl></blockquote><p>

                    </p>
<blockquote class="text"><dl>
<dt>(4)</dt>
<dd>If "BACKOFF_CNT > 0", i.e., if at least one
                        retransmission timer backoff can be undone, then
                            
<blockquote class="text">
<p>proceed to step (5);
</p>
</blockquote>
                        else
                            
<blockquote class="text">
<p>proceed to step (3).
</p>
</blockquote>
                        
</dd>
<dt>(5)</dt>
<dd>Extract the TCP segment header included in the ICMP
                        unreachable message "ICMP_DU":
                            
<blockquote class="text">
<p>SEG := Extract(ICMP_DU).
</p>
</blockquote>
                        
</dd>
<dt>(6)</dt>
<dd>If "SEG.SEQ == SND.UNA", i.e., if the TCP segment
                        "SEG" eliciting the ICMP unreachable message "ICMP_DU"
                        contains the sequence number of a retransmission, then
                            
<blockquote class="text">
<p>proceed to step (7);
</p>
</blockquote>
                        else
                            
<blockquote class="text">
<p>proceed to step (3).
</p>
</blockquote>
                        
</dd>
<dt>(7)</dt>
<dd>Undo the last retransmission timer backoff:
                            
<blockquote class="text">
<p>BACKOFF_CNT := BACKOFF_CNT - 1;
</p>
<p>RTO := min(RTO_BASE * 2^(BACKOFF_CNT), MAX_RTO).
</p>
</blockquote>
                        
</dd>
<dt>(8)</dt>
<dd>If the retransmission timer expires due to the undoing
                        in the previous step (7), then
                            
<blockquote class="text">
<p>proceed to step (R);
</p>
</blockquote>
                        else
                            
<blockquote class="text">
<p>proceed to step (3).
</p>
</blockquote>
                        
</dd>
</dl></blockquote><p>

                    </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>This is a placeholder for standard
                        TCP's behavior in case an acceptable ACK has arrived.
                        No further processing.
</dd>
</dl></blockquote><p>
                
</p>
<p>When a TCP in steady-state detects a segment loss using the
                retransmission timer, it enters the timeout-based loss recovery
                and initiates the algorithm (step 1). It adjusts the slow start
                threshold (ssthresh), sets the congestion window (CWND) to one
                segment, backs off the retransmission timer, and retransmits
                the first unacknowledged segment (step R)
                <a class='info' href='#RFC5681'>[RFC5681]<span> (</span><span class='info'>Allman, M., Paxson, V., and E. Blanton, &ldquo;TCP Congestion Control,&rdquo; September&nbsp;2009.</span><span>)</span></a>, <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>. To account
                for the expiration of the retransmission timer, the TCP sender
                increments the "BACKOFF_CNT" variable by one (step 2).
</p>
<p>In case the retransmission timer expires again (step 3a), a
                TCP will repeat the retransmission of the first unacknowledged
                segment and back off the retransmission timer once more (step
                R) <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>, as well as increment the
                "BACKOFF_CNT" variable by one (step 2). Note that a TCP may
                implement <a class='info' href='#RFC2988'>RFC&nbsp;2988's<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a> [RFC2988] option
                to place a maximum value on the RTO that may result in not
                performing the retransmission timer backoff. However, step (2)
                MUST always and unconditionally be applied, no matter whether
                or not the retransmission timer is actually backed off. In
                other words, each time the retransmission timer expires, the
                "BACKOFF_CNT" variable MUST be incremented by one.
</p>
<p>If the first received packet after the retransmission(s) is
                an acceptable ACK (step 3b), a TCP will proceed as normal,
                i.e., slow start the connection and terminate the algorithm
                (step A). Later ICMP unreachable messages from the just
                terminated timeout-based loss recovery are ignored, since the
                ACK clock is already restarting due to the successful
                retransmission.
</p>
<p>On the other hand, if the first received packet after the
                retransmission(s) is an ICMP unreachable message (step 3c), and
                if step (4) permits it, TCP SHOULD undo one backoff for each
                ICMP unreachable message reporting an error on a
                retransmission. To decide if an ICMP unreachable message was
                elicited by a retransmission, the sequence number it contains
                is inspected (step 5, step 6). The undo is performed by
                re-calculating the RTO with the decremented "BACKOFF_CNT"
                variable (step 7). This calculation explicitly matches the
                (bounded) exponential backoff specified in rule (5.5) of
                <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>.
</p>
<p>Upon receipt of an ICMP unreachable message that legitimately
                undoes one backoff, there is the possibility that the shortened
                retransmission timer has already expired (step 8). Then, TCP
                SHOULD retransmit immediately. In case the shortened
                retransmission timer has not yet expired, TCP MUST wait
                accordingly.
</p>
<a name="discussion"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Discussion of TCP-LCD</h3>

<p>TCP-LCD takes caution to only react to connectivity disruption
            indications in the form of ICMP unreachable messages during
            timeout-based loss recovery. Therefore, TCP's behavior is not
            altered when either no ICMP unreachable messages are received, or
            the retransmission timer of the TCP sender did not expire since the
            last received acceptable ACK. Thus, by definition, the algorithm
            triggers only in the case of long connectivity disruptions.
</p>
<p>Only such ICMP unreachable messages that contain a TCP segment
            with the sequence number of a retransmission, i.e., contain
            SND.UNA, are evaluated by TCP-LCD. All other ICMP unreachable
            messages are ignored. The arrival of those ICMP unreachable
            messages provides strong evidence that the retransmissions were not
            dropped due to congestion, but were successfully delivered to the
            reporting router. In other words, there is no evidence for any
            congestion at least on that very part of the path that was
            traversed by both the TCP segment eliciting the ICMP unreachable
            message as well as the ICMP unreachable message itself.
</p>
<p>However, there are some situations where TCP-LCD makes a false
            decision and incorrectly undoes a retransmission timer backoff. This
            can happen, even when the received ICMP unreachable message contains
            the segment number of a retransmission (SND.UNA), because the TCP
            segment that elicited the ICMP unreachable message may either not
            be a retransmission (<a class='info' href='#discuss_retrans_ambiguity'>Section&nbsp;5.1<span> (</span><span class='info'>Retransmission Ambiguity</span><span>)</span></a>),
            or does not belong to the current timeout-based loss recovery
            (<a class='info' href='#discuss_wrap_sequence_numbers'>Section&nbsp;5.2<span> (</span><span class='info'>Wrapped Sequence Numbers</span><span>)</span></a>). Finally, packet
            duplication (<a class='info' href='#discuss_packet_dup'>Section&nbsp;5.3<span> (</span><span class='info'>Packet Duplication</span><span>)</span></a>) can also
            spuriously trigger the algorithm.
</p>
<p><a class='info' href='#discuss_probing_frequency'>Section&nbsp;5.4<span> (</span><span class='info'>Probing Frequency</span><span>)</span></a> discusses possible
            probing frequencies, while <a class='info' href='#discuss_steady-state'>Section&nbsp;5.6<span> (</span><span class='info'>Reaction in Steady-State</span><span>)</span></a>
            describes the motivation for not reacting to ICMP unreachable
            messages while TCP is in steady-state.
</p>
<a name="discuss_retrans_ambiguity"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Retransmission Ambiguity</h3>

<p>Historically, the retransmission ambiguity problem
                <a class='info' href='#Zh86'>[Zh86]<span> (</span><span class='info'>Zhang, L., &ldquo;Why TCP Timers Don't Work Well,&rdquo; August&nbsp;1986.</span><span>)</span></a>, <a class='info' href='#KP87'>[KP87]<span> (</span><span class='info'>Karn, P. and C. Partridge, &ldquo;Improving Round-Trip Time Estimates in Reliable                         Transport Protocols,&rdquo; August&nbsp;1987.</span><span>)</span></a> is the TCP sender's
                inability to distinguish whether the first acceptable ACK after
                a retransmission refers to the original transmission or to the
                retransmission. This problem occurs after both a Fast
                Retransmit and a timeout-based retransmit. However, modern TCP
                implementations can eliminate the retransmission ambiguity with
                either the help of Eifel <a class='info' href='#RFC3522'>[RFC3522]<span> (</span><span class='info'>Ludwig, R. and M. Meyer, &ldquo;The Eifel Detection Algorithm for TCP,&rdquo; April&nbsp;2003.</span><span>)</span></a>,
                <a class='info' href='#RFC4015'>[RFC4015]<span> (</span><span class='info'>Ludwig, R. and A. Gurtov, &ldquo;The Eifel Response Algorithm for TCP,&rdquo; February&nbsp;2005.</span><span>)</span></a> or Forward RTO-Recovery (F-RTO)
                <a class='info' href='#RFC5682'>[RFC5682]<span> (</span><span class='info'>Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata, &ldquo;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP,&rdquo; September&nbsp;2009.</span><span>)</span></a>.
</p>
<p>The reversion strategy of the given algorithm suffers from a
                form of retransmission ambiguity, too. In contrast to the above
                case, TCP suffers from ambiguity regarding ICMP unreachable
                messages received during timeout-based loss recovery. With the
                TCP segment number included in the ICMP unreachable message, a
                TCP sender is not able to determine if the ICMP unreachable
                message refers to the original transmission or to any of the
                timeout-based retransmissions. That is, there is an ambiguity
                with regards to which TCP segment an ICMP unreachable message
                reports on.
</p>
<p>However, this ambiguity is not considered to be a problem
                for the algorithm. The assumption that a received ICMP unreachable message
                provides evidence that a non-congestion loss caused by the
                connectivity disruption was wrongly considered a congestion
                loss still holds, regardless to which TCP segment, transmission
                or retransmission, the message refers.
</p>
<a name="discuss_wrap_sequence_numbers"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Wrapped Sequence Numbers</h3>

<p>Besides the ambiguity whether a received ICMP unreachable
                message refers to the original transmission or to any of the
                retransmissions, there is another source of ambiguity related
                to the TCP sequence numbers contained in ICMP unreachable
                messages. For high bandwidth paths, the sequence space may wrap
                quickly. This might cause that delayed ICMP unreachable
                messages may coincidentally fit as valid input in the proposed
                scheme. As a result, the scheme may incorrectly undo
                retransmission timer backoffs. Chances for this to happen are
                minuscule, since a particular ICMP unreachable message would need to
                contain the exact sequence number of the current
                oldest outstanding segment (SND.UNA), while at the same time
                TCP is in timeout-based loss recovery. However, two "worst
                case" scenarios for the algorithm are possible:
</p>
<p>For instance, consider a steady state TCP connection, which
                will be disrupted at an intermediate router due to a link
                outage. Upon the expiration of the RTO, the TCP sender enters
                the timeout-based loss recovery and starts to retransmit the
                earliest segment that has not been acknowledged (SND.UNA). For
                some reason, the router delays all corresponding ICMP unreachable
                messages so that the TCP sender backs the retransmission timer
                off normally without any undoing. At the end of the
                connectivity disruption, the TCP sender eventually detects the
                re-establishment, leaves the scheme and finally the
                timeout-based loss recovery, too. A sequence number wrap-around
                later, the connectivity between the two peers is disrupted
                again, but this time due to congestion and exactly at the time
                at which the current SND.UNA matches the SND.UNA from the
                previous cycle. If the router emits the delayed ICMP unreachable
                messages now, the TCP sender would incorrectly undo
                retransmission timer backoffs. As the TCP sequence number
                contains 32 bits, the probability of this scenario is at most
                1/2^32. Given sufficiently many retransmissions in the first
                timeout-based loss recovery, the corresponding ICMP unreachable
                messages could reduce the RTO in the second recovery at most to
                "RTO_BASE". However, once the ICMP unreachable messages are
                depleted, the standard exponential backoff will be performed.
                Thus, the congestion response will only be delayed by some
                false retransmissions.
</p>
<p>Similar to the above, consider the case where a steady state
                TCP connection with n segments in flight will be disrupted at
                some point due to a link outage at an intermediate router.
                For each segment in flight, the router may generate an ICMP
                unreachable message. However, due to some reason it delays
                them.  Once the link outage is over and the connection has been
                re-established, the TCP sender leaves the scheme and
                slow-starts the connection. Following a sequence number
                wrap-around, a retransmission timeout occurs, just at the
                moment the TCP sender's current window of data reaches the
                previous range of the sequence number space again.  In case
                the router emits the delayed ICMP unreachable messages now,
                spurious undoing of the retransmission timer backoff is
                possible once, if the TCP segment number contained in ICMP
                unreachable messages matches the current SND.UNA, and the
                timeout was a result of congestion. In the case of another
                connectivity disruption, the additional undoing of the
                retransmission timer backoff has no impact. The probability of
                this scenario is at most n/2^32.
</p>
<a name="discuss_packet_dup"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Packet Duplication</h3>

<p>In case an intermediate router duplicates packets, a TCP
                sender may receive more ICMP unreachable messages during
                timeout-based loss recovery than sent timeout-based
                retransmissions. However, since TCP-LCD keeps track of the
                number of performed retransmission timer backoffs in the
                "BACKOFF_CNT" variable, it will not undo more retransmission
                timer backoffs than were actually performed.  Nevertheless, if
                packet duplication and congestion coincide on the path between
                the two communicating hosts, duplicated ICMP unreachable messages could
                hide the congestion loss of some retransmissions or ICMP unreachable
                messages, and the algorithm may incorrectly undo retransmission
                timer backoffs. Considering the overall impact of a router that
                duplicates packets, the additional load induced by some
                spurious timeout-based retransmits can probably be
                neglected.
</p>
<a name="discuss_probing_frequency"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Probing Frequency</h3>

<p>One might argue that if an ICMP unreachable message arrives
                for a timeout-based retransmission, the RTO shall be reset or
                recalculated, similar to what is done when an ACK arrives
                during timeout-based loss recovery (see Karn's algorithm
                <a class='info' href='#KP87'>[KP87]<span> (</span><span class='info'>Karn, P. and C. Partridge, &ldquo;Improving Round-Trip Time Estimates in Reliable                         Transport Protocols,&rdquo; August&nbsp;1987.</span><span>)</span></a>, <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>), and a new
                retransmission should be sent immediately. Generally, this
                would result in a much higher probing frequency based on the
                round trip time to the router where connectivity has been
                disrupted. However, we believe the current scheme provides a
                good trade-off between conservative behavior and fast detection
                of connectivity re-establishment. TCP-LCD focuses on
                long-connectivity disruptions, i.e., on disruptions that last
                for several RTOs. Thus, a much higher probing frequency (less
                then once per RTO) would not significantly increase the
                available transmission time compared to the duration of the
                connectivity disruption.
</p>
<a name="discuss_syn"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Reaction during Connection Establishment</h3>

<p>It is possible that a TCP sender enters timeout-based loss
                recovery while the connection is in SYN-SENT or SYN-RECEIVED
                states <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>. The algorithm described in
                this document could also be used for faster connection
                establishment in networks with connectivity disruptions.
                However, because existing TCP implementations
                <a class='info' href='#RFC5461'>[RFC5461]<span> (</span><span class='info'>Gont, F., &ldquo;TCP's Reaction to Soft Errors,&rdquo; February&nbsp;2009.</span><span>)</span></a> already interpret ICMP unreachable
                messages during connection establishment and abort the
                corresponding connection, we refrain from suggesting this.
</p>
<a name="discuss_steady-state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
Reaction in Steady-State</h3>

<p>Another exploitation of ICMP unreachable messages in the
                context of TCP congestion control might seem appropriate,
                while TCP is in steady-state. As the RTT up to the router that
                generated the ICMP unreachable message is likely to be
                substantially shorter than the overall RTT to the destination,
                the ICMP unreachable message may very well reach the
                originating TCP while it is transmitting the current window of
                data. In case the remaining window is large, it might seem
                appropriate to refrain from transmitting the remaining window
                as there is timely evidence that it will only trigger further
                ICMP unreachable messages at the very router. Although this
                promises improvement from a wastage perspective, it may be
                counterproductive from a security perspective. An attacker
                could forge such ICMP messages, thereby forcing the originating
                TCP to stop sending data, very similar to the blind
                throughput-reduction attack mentioned in
                <a class='info' href='#RFC5927'>[RFC5927]<span> (</span><span class='info'>Gont, F., &ldquo;ICMP Attacks against TCP,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</p>
<p>An additional consideration is the following: in the presence
                of multi-path routing, even the receipt of a legitimate ICMP
                unreachable message cannot be exploited accurately, because
                there is the possibility that only one of the multiple paths to the
                destination is suffering from a connectivity disruption, which
                causes ICMP unreachable messages to be sent. Then, however,
                there is the possibility that the path along which the
                connectivity disruption occurred contributed considerably to
                the overall bandwidth, such that a congestion response is very
                well reasonable. However, this is not necessarily the case.
                Therefore, a TCP has no means except for its inherent
                congestion control to decide on this matter. All in all, it
                seems that for a connection in steady-state, i.e., not in
                timeout-based loss recovery, reacting on ICMP unreachable
                messages in regard to congestion control is not appropriate.
                For the case of timeout-based retransmissions, however, there
                is a reasonable congestion response, which is skipping further
                retransmission timer backoffs because there is no congestion
                indication - as described above.
</p>
<a name="algo_save"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Dissolving Ambiguity Issues using the TCP Timestamps Option</h3>

<p>If the TCP Timestamps option <a class='info' href='#RFC1323'>[RFC1323]<span> (</span><span class='info'>Jacobson, V., Braden, B., and D. Borman, &ldquo;TCP Extensions for High Performance,&rdquo; May&nbsp;1992.</span><span>)</span></a>
            is enabled for a connection, a TCP sender SHOULD use the following
            algorithm to dissolve the ambiguity issues mentioned in Sections
            <a class='info' href='#discuss_retrans_ambiguity'>5.1<span> (</span><span class='info'>Retransmission Ambiguity</span><span>)</span></a>,
            <a class='info' href='#discuss_wrap_sequence_numbers'>5.2<span> (</span><span class='info'>Wrapped Sequence Numbers</span><span>)</span></a>,
            and <a class='info' href='#discuss_packet_dup'>5.3<span> (</span><span class='info'>Packet Duplication</span><span>)</span></a>. In
            particular, both the retransmission ambiguity and the packet
            duplication problems are prevented by the following TCP-LCD
            variant. On the other hand, the false positives caused by wrapped
            sequence numbers cannot be completely avoided, but the likelihood
            is further reduced by a factor of 1/2^32 since the Timestamp Value
            field (TSval) of the TCP Timestamps Option contains 32 bits.
</p>
<p>Hence, implementers may choose to implement the TCP-LCD with the
            following modifications.
</p>
<p>Step (1) is replaced by step (1'):
                </p>
<blockquote class="text"><dl>
<dt>(1')</dt>
<dd>Before TCP updates the variable "RTO" when it initiates
                    timeout-based loss recovery, set the variables "BACKOFF_CNT"
                    and "RTO_BASE" and the data structure "RETRANS_TS" as follows:
                        
<blockquote class="text">
<p>BACKOFF_CNT := 0;
</p>
<p>RTO_BASE := RTO;
</p>
<p>RETRANS_TS := [].
</p>
</blockquote>
                    Proceed to step (R).
</dd>
</dl></blockquote><p>
            
</p>
<p>Step (2) is extended by step (2b):
                </p>
<blockquote class="text"><dl>
<dt>(2b)</dt>
<dd>Store the value of the Timestamp Value field (TSval) of
                    the TCP Timestamps option included in the retransmission
                    "RET" sent in step (R) into the "RETRANS_TS" data structure:
                        
<blockquote class="text">
<p>RETRANS_TS.add(RET.TSval)
</p>
</blockquote>
                    
</dd>
</dl></blockquote><p>
            
</p>
<p>Step (6) is replaced by step (6'):
                </p>
<blockquote class="text"><dl>
<dt>(6')</dt>
<dd> If "SEG.SEQ == SND.UNA &&
                    RETRANS_TS.exists(SEQ.TSval)", i.e., if the TCP segment
                    "SEG" eliciting the ICMP unreachable message "ICMP_DU"
                    contains the sequence number of a retransmission, and the
                    value in its Timestamp Value field (TSval) is valid, then
                        
<blockquote class="text">
<p>proceed to step (7');
</p>
</blockquote>
                    else
                        
<blockquote class="text">
<p>proceed to step (3).
</p>
</blockquote>
                    
</dd>
</dl></blockquote><p>
            
</p>
<p>Step (7) is replaced by step (7'):
                </p>
<blockquote class="text"><dl>
<dt>(7')</dt>
<dd>Undo the last retransmission timer backoff:
                        
<blockquote class="text">
<p>RETRANS_TS.remove(SEQ.TSval);
</p>
<p>BACKOFF_CNT := BACKOFF_CNT - 1;
</p>
<p>RTO := min(RTO_BASE * 2^(BACKOFF_CNT), MAX_RTO).
</p>
</blockquote>
                    
</dd>
</dl></blockquote><p>
            
</p>
<p>The downside of the this variant is twofold. First, the
            modifications come at a cost: the TCP sender is required to store
            the timestamps of all retransmissions sent during one timeout-based
            loss recovery. Second, this variant can only undo a retransmission
            timer backoff if the intermediate router experiencing the link
            outage implements <a class='info' href='#RFC1812'>[RFC1812]<span> (</span><span class='info'>Baker, F., &ldquo;Requirements for IP Version 4 Routers,&rdquo; June&nbsp;1995.</span><span>)</span></a> and chooses to include
            as many more than the first 64 bits of the payload of the
            triggering datagram, as are needed to include the TCP Timestamps
            option in the ICMP unreachable message.
</p>
<a name="interoperability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Interoperability Issues</h3>

<p>This section discusses interoperability issues related to
            introducing TCP-LCD.
</p>
<a name="interaction_rfc1122"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Detection of TCP Connection Failures</h3>

<p>TCP-LCD may have side-effects on TCP implementations that
                attempt to detect TCP connection failures by counting
                timeout-based retransmissions. <a class='info' href='#RFC1122'>[RFC1122]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>
                states in Section 4.2.3.5 that a TCP host must handle excessive
                retransmissions of data segments with two thresholds R1 and R2
                that measure the number of retransmissions that have occurred for
                the same segment. Both thresholds might either be measured in
                time units or as a count of retransmissions.
</p>
<p>Due to TCP-LCD's reversion strategy of the retransmission
                timer, the assumption that a certain number of retransmissions
                corresponds to a specific time interval no longer holds, as
                additional retransmissions may be performed during
                timeout-based-loss recovery to detect the end of the
                connectivity disruption. Therefore, a TCP employing TCP-LCD
                either MUST measure the thresholds R1 and R2 in time units
                or, in case R1 and R2 are counters of retransmissions, MUST
                convert them into time intervals, which correspond to the time
                an unmodified TCP would need to reach the specified number of
                retransmissions.
</p>
<a name="interaction_ecn"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Explicit Congestion Notification (ECN)</h3>

<p>With Explicit Congestion Notification (ECN)
                <a class='info' href='#RFC3168'>[RFC3168]<span> (</span><span class='info'>Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;The Addition of Explicit Congestion Notification (ECN) to IP,&rdquo; September&nbsp;2001.</span><span>)</span></a>, ECN-capable routers are no longer
                limited to dropping packets to indicate congestion. Instead,
                they can set the Congestion Experienced (CE) codepoint in the
                IP header to indicate congestion. With TCP-LCD, it may happen
                that during a connectivity disruption, a received ICMP
                unreachable message has been elicited by a timeout-based
                retransmission that was marked with the CE codepoint before
                reaching the router experiencing the link outage. In such a
                case, a TCP sender MUST, corresponding to
                <a class='info' href='#RFC3168'>[RFC3168]<span> (</span><span class='info'>Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;The Addition of Explicit Congestion Notification (ECN) to IP,&rdquo; September&nbsp;2001.</span><span>)</span></a> (Section 6.1.2), additionally reset
                the retransmission timer in case the algorithm undoes a
                retransmission timer backoff.
</p>
<a name="interaction_tunnels"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
TCP-LCD and IP Tunnels</h3>

<p>It is worth noting that IP tunnels, including IPsec
                <a class='info' href='#RFC4301'>[RFC4301]<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a>, IP in IP <a class='info' href='#RFC2003'>[RFC2003]<span> (</span><span class='info'>Perkins, C., &ldquo;IP Encapsulation within IP,&rdquo; October&nbsp;1996.</span><span>)</span></a>,
                Generic Routing Encapsulation (GRE) <a class='info' href='#RFC2784'>[RFC2784]<span> (</span><span class='info'>Farinacci, D., Li, T., Hanks, S., Meyer, D., and P. Traina, &ldquo;Generic Routing Encapsulation (GRE),&rdquo; March&nbsp;2000.</span><span>)</span></a>,
                and others are compatible with TCP-LCD, as long as the received
                ICMP unreachable messages can be demultiplexed and extracted
                appropriately by the TCP sender during timeout-based loss
                recovery.
</p>
<p>If, for example, end-to-end tunnels like IPsec in transport
                mode <a class='info' href='#RFC4301'>[RFC4301]<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> are employed, a TCP sender may
                receive ICMP unreachable messages where additional steps, e.g.,
                decrypting in step (5) of the algorithm, are needed to extract
                the TCP header from these ICMP messages. Provided that the
                received ICMP unreachable message contains enough information,
                i.e., SEQ.SEG is extractable, this information can still be
                used as a valid input for the proposed algorithm.
</p>
<p>Likewise, if IP encapsulation like <a class='info' href='#RFC2003'>[RFC2003]<span> (</span><span class='info'>Perkins, C., &ldquo;IP Encapsulation within IP,&rdquo; October&nbsp;1996.</span><span>)</span></a>
                is used in some part of the path between the communicating
                hosts, the tunnel ingress node may receive the ICMP unreachable
                messages from an intermediate router experiencing the link
                outage. Nevertheless, the tunnel ingress node may replay the
                ICMP unreachable messages in order to inform the TCP sender. If
                enough information is preserved to extract SEQ.SEG, the
                replayed ICMP unreachable messages can still be used in
                TCP-LCD.
</p>
<a name="related_work"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Related Work</h3>

<p>Several methods that address TCP's problems in the presence of
            connectivity disruptions have been proposed in literature. Some of
            them try to improve TCP's performance by modifying lower layers.
            For example, <a class='info' href='#SM03'>[SM03]<span> (</span><span class='info'>Scott, J. and G. Mapp, &ldquo;Link layer-based TCP optimisation for disconnecting                         networks,&rdquo; October&nbsp;2003.</span><span>)</span></a> introduces a "smart link layer",
            which buffers one segment for each active connection and replays
            these segments upon connectivity re-establishment. This approach
            has a serious drawback: previously stateless intermediate routers
            have to be modified in order to inspect TCP headers, to track the
            end-to-end connection, and to provide additional buffer space. This
            leads to an additional need of memory and processing power.
</p>
<p>On the other hand, stateless link layer schemes, as proposed in
            <a class='info' href='#RFC3819'>[RFC3819]<span> (</span><span class='info'>Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &ldquo;Advice for Internet Subnetwork Designers,&rdquo; July&nbsp;2004.</span><span>)</span></a>, which unconditionally buffer some small
            number of packets may have another problem: if a packet is buffered
            longer than the maximum segment lifetime (MSL) of 2 min
            <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, i.e., the disconnection lasts longer than
            MSL, TCP's assumption that such segments will never be received
            will no longer be true, violating TCP's semantics
            <a class='info' href='#I-D.eggert-tcpm-tcp-retransmit-now'>[I&#8209;D.eggert&#8209;tcpm&#8209;tcp&#8209;retransmit&#8209;now]<span> (</span><span class='info'>Eggert, L., &ldquo;TCP Extensions for Immediate Retransmissions,&rdquo; June&nbsp;2005.</span><span>)</span></a>.
</p>
<p>Other approaches, like TCP-F <a class='info' href='#CRVP01'>[CRVP01]<span> (</span><span class='info'>Chandran, K., Raghunathan, S., Venkatesan, S., and R. Prakash, &ldquo;A feedback-based scheme for improving TCP performance                         in ad hoc wireless networks,&rdquo; February&nbsp;2001.</span><span>)</span></a> or the
            Explicit Link Failure Notification (ELFN) <a class='info' href='#HV02'>[HV02]<span> (</span><span class='info'>Holland, G. and N. Vaidya, &ldquo;Analysis of TCP performance over mobile ad hoc                         networks,&rdquo; March&nbsp;2002.</span><span>)</span></a>
            inform a TCP sender about a disrupted path by special messages
            generated and sent from intermediate routers. In the case of a link
            failure, the TCP sender stops sending segments and freezes its
            retransmission timers. TCP-F stays in this state and remains silent
            until either a "route establishment notification" is received or an
            internal timer expires. In contrast, ELFN periodically probes the
            network to detect connectivity re-establishment. Both proposals
            rely on changes to intermediate routers, whereas the scheme
            proposed in this document is a sender-only modification. Moreover,
            ELFN does not consider congestion and may impose serious additional
            load on the network, depending on the probe interval.
</p>
<p>The authors of ATCP <a class='info' href='#LS01'>[LS01]<span> (</span><span class='info'>Liu, J. and S. Singh, &ldquo;ATCP: TCP for mobile ad hoc networks,&rdquo; 2001&nbsp;July.</span><span>)</span></a> propose enhancements
            to identify different types of packet loss by introducing a layer
            between TCP and IP. They utilize ICMP destination unreachable
            messages to set TCP's receiver advertised window to zero, thus
            forcing the TCP sender to perform zero window probing with an
            exponential backoff. ICMP destination unreachable messages that
            arrive during this probing period are ignored. This approach is
            nearly orthogonal to this document, which exploits ICMP messages to
            undo a retransmission timer backoff when TCP is already probing. In
            principle, both mechanisms could be combined. However, due to
            security considerations, it does not seem appropriate to adopt
            ATCP's reaction, as discussed in
            <a class='info' href='#discuss_steady-state'>Section&nbsp;5.6<span> (</span><span class='info'>Reaction in Steady-State</span><span>)</span></a>.
</p>
<p>Schuetz et al. <a class='info' href='#I-D.schuetz-tcpm-tcp-rlci'>[I&#8209;D.schuetz&#8209;tcpm&#8209;tcp&#8209;rlci]<span> (</span><span class='info'>Schuetz, S., Koutsianas, N., Eggert, L., Eddy, W., Swami, Y., and K. Le, &ldquo;TCP Response to Lower-Layer Connectivity-Change Indications,&rdquo; February&nbsp;2008.</span><span>)</span></a>
            describe a set of TCP extensions that improve TCP's behavior when
            transmitting over paths whose characteristics can change rapidly.
            Their proposed extensions modify the local behavior of TCP and
            introduce a new TCP option to signal locally received
            connectivity-change indications (CCIs) to remote peers. Upon
            receipt of a CCI, they re-probe the path characteristics either by
            performing a speculative retransmission or by sending a single
            segment of new data, depending on whether the connection is
            currently stalled in exponential backoff or transmitting in
            steady-state, respectively. The authors focus on specifying TCP
            response mechanisms, nevertheless underlying layers would have to
            be modified to explicitly send CCIs to make these immediate
            responses possible.
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>This memo includes no request to IANA.
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<p>Generally, an attacker has only two attack alternatives:
            to generate ICMP unreachable messages to try to
            make a TCP modified with TCP-LCD to flood the network,
            or to suppress legitimate ICMP unreachable messages to try
            to slow down the transmission rate of a TCP sender.
</p>
<p>In order to generate ICMP unreachable messages that fit as an
            input for TCP-LCD, an attacker would need to guess the correct
            four-tuple (i.e., Source IP Address, Source TCP port, Destination
            IP Address, and Destination TCP port) and the exact segment
            sequence number of the current timeout-based retransmission. Yet,
            the correct sequence number is generally hard to guess as; with a
            probability of 1/2^32.  Even if an attacker has information about
            that sequence number (i.e., the attacker can eavesdrop on the
            retransmissions) the impact on the network load the attacker may be
            considered low, since the retransmission frequency is limited by
            the RTO that was computed before TCP had entered the timeout-based
            loss recovery. Hence, the highest probing frequency is expected to
            be even lower than once per minimum RTO, i.e., 1s as specified by
            <a class='info' href='#RFC2988'>[RFC2988]<span> (</span><span class='info'>Paxson, V. and M. Allman, &ldquo;Computing TCP's Retransmission Timer,&rdquo; November&nbsp;2000.</span><span>)</span></a>. It is important to note, that an
            attacker, who can correctly guess the four-tuple and the segment
            sequence number, can easily launch more serious attacks (i.e.,
            hijack the connection), whether or not TCP-LCD is used.
</p>
<p>There may be means by which an attacker can cause the
            suppression of legitimate ICMP unreachable messages (e.g., by
            flooding the router experiencing the link outage to trigger ICMP
            rate-limiting). However, even if the attacker could suppress every
            legitimate ICMP unreachable message, the security impact of
            such an attack is negligible, since the TCP sender using TCP-LCD
            will behave like a regular TCP would. Note
            that this kind of attack is indistinguishable from
            a router experiencing a link outage is not sending ICMP unreachable
            messages at all (e.g., because of local policy).
</p>
<p>In summary, the algorithm proposed in this document is
            considered to be secure.
</p>
<a name="acks"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgments</h3>

<p>We would like to thank Lars Eggert, Adrian Farrel, Mark Handley,
            Kai Jakobs, Ilpo Jarvinen, Enrico Marocco, Catherine Meadows,
            J&uuml;rgen Quittek, Pasi Sarolahti, Tim Shepard, Joe Touch and Carsten
            Wolff for feedback on earlier versions of this document. We also
            thank Michael Faber, Daniel Schaffrath, and Damian Lukowski for
            implementing and testing the algorithm in Linux. Special thanks go
            to Ilpo Jarvinen for giving valuable feedback regarding the Linux
            implementation.
</p>
<p>This work has been supported by the German National Science
            Foundation (DFG) within the research excellence cluster Ultra
            High-Speed Mobile Information and Communication (UMIC), RWTH Aachen
            University.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC0792">[RFC0792]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc792">Internet Control Message Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;792, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc792.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1323">[RFC1323]</a></td>
<td class="author-text"><a href="mailto:van@CSAM.LBL.GOV">Jacobson, V.</a>, <a href="mailto:Braden@ISI.EDU">Braden, B.</a>, and <a href="mailto:dab@cray.com">D. Borman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>,&rdquo; RFC&nbsp;1323, May&nbsp;1992 (<a href="http://www.rfc-editor.org/rfc/rfc1323.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1812">[RFC1812]</a></td>
<td class="author-text"><a href="mailto:fred@cisco.com">Baker, F.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1812">Requirements for IP Version 4 Routers</a>,&rdquo; RFC&nbsp;1812, June&nbsp;1995 (<a href="http://www.rfc-editor.org/rfc/rfc1812.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2988">[RFC2988]</a></td>
<td class="author-text">Paxson, V. and M. Allman, &ldquo;<a href="http://tools.ietf.org/html/rfc2988">Computing TCP's Retransmission Timer</a>,&rdquo; RFC&nbsp;2988, November&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2988.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4443">[RFC4443]</a></td>
<td class="author-text">Conta, A., Deering, S., and M. Gupta, &ldquo;<a href="http://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;4443, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4443.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5681">[RFC5681]</a></td>
<td class="author-text">Allman, M., Paxson, V., and E. Blanton, &ldquo;<a href="http://tools.ietf.org/html/rfc5681">TCP Congestion Control</a>,&rdquo; RFC&nbsp;5681, September&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5681.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CRVP01">[CRVP01]</a></td>
<td class="author-text">Chandran, K., Raghunathan, S., Venkatesan, S., and R. Prakash, &ldquo;A feedback-based scheme for improving TCP performance
                        in ad hoc wireless networks,&rdquo; IEEE Personal Communications&nbsp;vol. 8, no. 1, pp. 34-39, February&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="HV02">[HV02]</a></td>
<td class="author-text">Holland, G. and N. Vaidya, &ldquo;Analysis of TCP performance over mobile ad hoc
                        networks,&rdquo; Wireless Networks&nbsp;vol. 8, no. 2-3, pp. 275-288, March&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.eggert-tcpm-tcp-retransmit-now">[I-D.eggert-tcpm-tcp-retransmit-now]</a></td>
<td class="author-text">Eggert, L., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-eggert-tcpm-tcp-retransmit-now-02.txt">TCP Extensions for Immediate Retransmissions</a>,&rdquo; draft-eggert-tcpm-tcp-retransmit-now-02 (work in progress), June&nbsp;2005 (<a href="http://www.ietf.org/internet-drafts/draft-eggert-tcpm-tcp-retransmit-now-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.schuetz-tcpm-tcp-rlci">[I-D.schuetz-tcpm-tcp-rlci]</a></td>
<td class="author-text">Schuetz, S., Koutsianas, N., Eggert, L., Eddy, W., Swami, Y., and K. Le, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-schuetz-tcpm-tcp-rlci-03.txt">TCP Response to Lower-Layer Connectivity-Change Indications</a>,&rdquo; draft-schuetz-tcpm-tcp-rlci-03 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-schuetz-tcpm-tcp-rlci-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="KP87">[KP87]</a></td>
<td class="author-text">Karn, P. and C. Partridge, &ldquo;Improving Round-Trip Time Estimates in Reliable
                        Transport Protocols,&rdquo; Proceedings of the Conference on Applications,
                    Technologies, Architectures, and Protocols for Computer
                    Communication (SIGCOMM'87)&nbsp;pp. 2-7, August&nbsp;1987.</td></tr>
<tr><td class="author-text" valign="top"><a name="LS01">[LS01]</a></td>
<td class="author-text">Liu, J. and S. Singh, &ldquo;ATCP: TCP for mobile ad hoc networks,&rdquo; IEEE Journal on Selected Areas in
                    Communications&nbsp;vol. 19, no. 7, pp. 1300-1315, 2001&nbsp;July.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0791">[RFC0791]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;791, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc791.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0826">[RFC0826]</a></td>
<td class="author-text"><a href="mailto:DCP@MIT-MC">Plummer, D.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc826">Ethernet Address Resolution Protocol: Or converting network protocol addresses to 48.bit Ethernet address for transmission on Ethernet hardware</a>,&rdquo; STD&nbsp;37, RFC&nbsp;826, November&nbsp;1982 (<a href="http://www.rfc-editor.org/rfc/rfc826.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1122">[RFC1122]</a></td>
<td class="author-text"><a href="mailto:Braden@ISI.EDU">Braden, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1122">Requirements for Internet Hosts - Communication Layers</a>,&rdquo; STD&nbsp;3, RFC&nbsp;1122, October&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1122.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2003">[RFC2003]</a></td>
<td class="author-text"><a href="mailto:perk@watson.ibm.com">Perkins, C.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2003">IP Encapsulation within IP</a>,&rdquo; RFC&nbsp;2003, October&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2003.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2003.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2003.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2784">[RFC2784]</a></td>
<td class="author-text"><a href="mailto:dino@procket.com">Farinacci, D.</a>, <a href="mailto:tony1@home.net">Li, T.</a>, <a href="mailto:stan_hanks@enron.net">Hanks, S.</a>, <a href="mailto:dmm@cisco.com">Meyer, D.</a>, and <a href="mailto:pst@juniper.net">P. Traina</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2784">Generic Routing Encapsulation (GRE)</a>,&rdquo; RFC&nbsp;2784, March&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2784.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3168">[RFC3168]</a></td>
<td class="author-text">Ramakrishnan, K., Floyd, S., and D. Black, &ldquo;<a href="http://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>,&rdquo; RFC&nbsp;3168, September&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3522">[RFC3522]</a></td>
<td class="author-text">Ludwig, R. and M. Meyer, &ldquo;<a href="http://tools.ietf.org/html/rfc3522">The Eifel Detection Algorithm for TCP</a>,&rdquo; RFC&nbsp;3522, April&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3522.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3782">[RFC3782]</a></td>
<td class="author-text">Floyd, S., Henderson, T., and A. Gurtov, &ldquo;<a href="http://tools.ietf.org/html/rfc3782">The NewReno Modification to TCP's Fast Recovery Algorithm</a>,&rdquo; RFC&nbsp;3782, April&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3782.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3819">[RFC3819]</a></td>
<td class="author-text">Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &ldquo;<a href="http://tools.ietf.org/html/rfc3819">Advice for Internet Subnetwork Designers</a>,&rdquo; BCP&nbsp;89, RFC&nbsp;3819, July&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3819.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4015">[RFC4015]</a></td>
<td class="author-text">Ludwig, R. and A. Gurtov, &ldquo;<a href="http://tools.ietf.org/html/rfc4015">The Eifel Response Algorithm for TCP</a>,&rdquo; RFC&nbsp;4015, February&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4015.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5461">[RFC5461]</a></td>
<td class="author-text">Gont, F., &ldquo;<a href="http://tools.ietf.org/html/rfc5461">TCP's Reaction to Soft Errors</a>,&rdquo; RFC&nbsp;5461, February&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5461.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5682">[RFC5682]</a></td>
<td class="author-text">Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata, &ldquo;<a href="http://tools.ietf.org/html/rfc5682">Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</a>,&rdquo; RFC&nbsp;5682, September&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5682.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5927">[RFC5927]</a></td>
<td class="author-text">Gont, F., &ldquo;<a href="http://tools.ietf.org/html/rfc5927">ICMP Attacks against TCP</a>,&rdquo; RFC&nbsp;5927, July&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5927.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="SESB05">[SESB05]</a></td>
<td class="author-text">Schuetz, S., Eggert, L., Schmid, S., and M. Brunner, &ldquo;Protocol enhancements for intermittently connected
                        hosts,&rdquo; SIGCOMM Computer Communication Review&nbsp;vol. 35, no. 3, pp. 5-18, December&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="SM03">[SM03]</a></td>
<td class="author-text">Scott, J. and G. Mapp, &ldquo;Link layer-based TCP optimisation for disconnecting
                        networks,&rdquo; SIGCOMM Computer Communication Review&nbsp;vol. 33, no. 5, pp. 31-42, October&nbsp;2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="Zh86">[Zh86]</a></td>
<td class="author-text">Zhang, L., &ldquo;Why TCP Timers Don't Work Well,&rdquo; Proceedings of the Conference on Applications,
                    Technologies, Architectures, and Protocols for Computer
                    Communication (SIGCOMM'86)&nbsp;pp. 397-405, August&nbsp;1986.</td></tr>
<tr><td class="author-text" valign="top"><a name="ZimHan09">[ZimHan09]</a></td>
<td class="author-text">Zimmermann, A., &ldquo;<a href="http://www.ietf.org/proceedings/75/slides/tcpm-0.pdf">Make TCP more Robust to Long Connectivity Disruptions</a>,&rdquo; Proceedings of the 75th IETF Meeting&nbsp;slides, July&nbsp;2009 (<a href="http://www.ietf.org/proceedings/75/slides/tcpm-0.pdf">PDF</a>).</td></tr>
</table>

<a name="changes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Changes from previous versions of the draft</h3>

<p>This appendix should be removed by the RFC Editor before
            publishing this document as an RFC.
</p>
<a name="changes_06"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Changes from
                draft-ietf-tcpm-tcp-lcd-02</h3>

<p>
                    </p>
<ul class="text">
<li>Incorporated feedback submitted by Enrico Marocco (Gen-ART Review)
</li>
<li>Incorporated feedback submitted by J&uuml;rgen Quittek (OpsDir Review)
</li>
<li>Incorporated feedback submitted by Catherine Meadows (SecDir Review)
</li>
<li>Incorporated feedback submitted by Adrian Farrel (IESG Review)
</li>
</ul><p>
                
</p>
<a name="changes_05"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Changes from
                draft-ietf-tcpm-tcp-lcd-01</h3>

<p>
                    </p>
<ul class="text">
<li>Incorporated feedback submitted by Lars Eggert (AD Review)
</li>
</ul><p>
                
</p>
<a name="changes_04"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
Changes from draft-ietf-tcpm-tcp-lcd-00</h3>

<p>
                    </p>
<ul class="text">
<li>Editorial changes.
</li>
<li>Clarified TCP-LCD's behaviour during connection
                        establishment (Thanks to Mark Handley).
</li>
</ul><p>
                
</p>
<a name="changes_03"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.4"></a><h3>A.4.&nbsp;
Changes from draft-zimmermann-tcp-lcd-02</h3>

<p>
                    </p>
<ul class="text">
<li>Incorporated feedback submitted by Ilpo Jarvinen.
                            <a href='http://www.ietf.org/mail-archive/web/tcpm/current/msg04841.html'>http://www.ietf.org/mail-archive/web/tcpm/current/msg04841.html</a>
                        
</li>
<li>Incorporated feedback submitted by Pasi Sarolahti.
                            <a href='http://www.ietf.org/mail-archive/web/tcpm/current/msg04870.html'>http://www.ietf.org/mail-archive/web/tcpm/current/msg04870.html</a>
                        
</li>
<li>Incorporated feedback submitted by Joe Touch.
                            <a href='http://www.ietf.org/mail-archive/web/tcpm/current/msg04895.html'>http://www.ietf.org/mail-archive/web/tcpm/current/msg04895.html</a>
                            <a href='http://www.ietf.org/mail-archive/web/tcpm/current/msg04900.html'>http://www.ietf.org/mail-archive/web/tcpm/current/msg04900.html</a>
                        
</li>
<li>Extended and reorganized the discussion
                        (<a class='info' href='#discussion'>Section&nbsp;5<span> (</span><span class='info'>Discussion of TCP-LCD</span><span>)</span></a>):
                            
<ul class="text">
<li>Every discussion item got its own title, so
                                that we have a better overview.
</li>
<li>Extended Retransmission Ambiguity section. Added
                                also some references to the historical
                                retransmission ambiguity problem.
</li>
<li>Heavily extended discussion about wrapped
                                sequence numbers (see Joe's comments).
</li>
<li>Described the influence of packet duplication
                                on the algorithm (Thanks to Ilpo).
</li>
<li>The section "Protecting Against Misbehaving
                                Routers" is not a subsection anymore. Moreover,
                                the section was renamed to "Dissolving Ambiguity
                                Issues" and has now real content.
</li>
</ul>
                        
</li>
<li>An interoperability issues section
                        (<a class='info' href='#interoperability'>Section&nbsp;7<span> (</span><span class='info'>Interoperability Issues</span><span>)</span></a>) was added. In
                        particular comments to ECN, ICMPv6, and to the two
                        thresholds R1 and R2  of <a class='info' href='#RFC1122'>[RFC1122]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Communication Layers,&rdquo; October&nbsp;1989.</span><span>)</span></a>
                        (Section 4.2.3.5) were added.
</li>
<li>Miscellaneous editorial changes. In particular, the
                        algorithm has a name now: TCP-LCD.
</li>
</ul><p>
                
</p>
<a name="changes_02"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.5"></a><h3>A.5.&nbsp;
Changes from draft-zimmermann-tcp-lcd-01</h3>

<p>
                    </p>
<ul class="text">
<li>The algorithm in <a class='info' href='#alg'>Section&nbsp;4.2<span> (</span><span class='info'>Algorithm Details</span><span>)</span></a> was
                        slightly changed. Instead of reverting the last
                        retransmission timer backoff by halving the RTO, the
                        RTO is recalculated with help of the "BACKOFF_CNT"
                        variable. This fixes an issue that occurred when the
                        retransmission timer was backed off but bounded by a
                        maximum value. The algorithm in the previous version of
                        the draft, would have "reverted" to half of that
                        maximum value, instead of using the value, before the
                        RTO was doubled (and then bounded).
</li>
<li>Miscellaneous editorial changes.
</li>
</ul><p>
                
</p>
<a name="changes_01"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.6"></a><h3>A.6.&nbsp;
Changes from draft-zimmermann-tcp-lcd-00</h3>

<p>
                    </p>
<ul class="text">
<li>Miscellaneous editorial changes in Section
                        <a class='info' href='#terminology'>1<span> (</span><span class='info'>Terminology</span><span>)</span></a>,
                        <a class='info' href='#intro'>2<span> (</span><span class='info'>Introduction</span><span>)</span></a> and
                        <a class='info' href='#cdi'>3<span> (</span><span class='info'>Connectivity Disruption Indication</span><span>)</span></a>.
</li>
<li>The document was restructured in Section
                        <a class='info' href='#terminology'>1<span> (</span><span class='info'>Terminology</span><span>)</span></a>,
                        <a class='info' href='#intro'>2<span> (</span><span class='info'>Introduction</span><span>)</span></a> and
                        <a class='info' href='#cdi'>3<span> (</span><span class='info'>Connectivity Disruption Indication</span><span>)</span></a> for easier
                        reading. The motivation for the algorithm is changed
                        according TCP's problem to disambiguate congestion from
                        non-congestion loss.
</li>
<li>Added <a class='info' href='#alg_idea'>Section&nbsp;4.1<span> (</span><span class='info'>Basic Idea</span><span>)</span></a>.
</li>
<li>The algorithm in <a class='info' href='#alg'>Section&nbsp;4.2<span> (</span><span class='info'>Algorithm Details</span><span>)</span></a> was
                        restructured and simplified:
                            
<ul class="text">
<li>The special case of the first received ICMP
                                destination unreachable message after an RTO was
                                removed.
</li>
<li>The "BACKOFF_CNT" variable was introduced so
                                it is no longer possible to perform more reverts
                                than backoffs.
</li>
</ul>
                        
</li>
<li>The discussion in <a class='info' href='#discussion'>Section&nbsp;5<span> (</span><span class='info'>Discussion of TCP-LCD</span><span>)</span></a> was
                        improved and expanded according to the algorithm
                        changes.
</li>
</ul><p>
                
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alexander Zimmermann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RWTH Aachen University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ahornstrasse 55</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Aachen,   52074</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49 241 80 21422</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:zimmermann@cs.rwth-aachen.de">zimmermann@cs.rwth-aachen.de</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Arnd Hannemann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">RWTH Aachen University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ahornstrasse 55</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Aachen,   52074</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49 241 80 21423</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hannemann@nets.rwth-aachen.de">hannemann@nets.rwth-aachen.de</a></td></tr>
</table>
</body></html>
