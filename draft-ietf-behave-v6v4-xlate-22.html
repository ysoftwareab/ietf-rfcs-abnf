<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>IP/ICMP Translation
    Algorithm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="IP/ICMP Translation
    Algorithm">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">behave</td><td class="header">X. Li</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">C. Bao</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc2765'>2765</a> (if&nbsp;approved)</td><td class="header">CERNET Center/Tsinghua University</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">F. Baker</td></tr>
<tr><td class="header">Expires: February 24, 2011</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">August 23, 2010</td></tr>
</table></td></tr></table>
<h1><br />IP/ICMP Translation
    Algorithm<br />draft-ietf-behave-v6v4-xlate-22</h1>

<h3>Abstract</h3>

<p>
      
      
      This document describes the Stateless IP/ICMP
      Translation Algorithm (SIIT), which translates 
      between IPv4 and IPv6 packet headers (including ICMP
      headers). This document obsoletes RFC2765.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on February 24, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#section1">1.</a>&nbsp;
Introduction and Motivation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section1.0">1.1.</a>&nbsp;
IPv4-IPv6 Translation Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section1.12">1.2.</a>&nbsp;
Applicability and Limitations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#prefix-stateless">1.3.</a>&nbsp;
Stateless vs. Stateful Mode<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.4.</a>&nbsp;
Path MTU Discovery and Fragmentation<br />
<a href="#anchor2">2.</a>&nbsp;
Changes from RFC2765<br />
<a href="#anchor3">3.</a>&nbsp;
Conventions<br />
<a href="#section3">4.</a>&nbsp;
Translating from IPv4 to IPv6<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.1">4.1.</a>&nbsp;
Translating IPv4 Headers into IPv6 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.3">4.2.</a>&nbsp;
Translating ICMPv4 Headers into ICMPv6 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.4">4.3.</a>&nbsp;
Translating ICMPv4 Error Messages into ICMPv6<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sending-icmp1">4.4.</a>&nbsp;
Generation of ICMPv4 Error Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#transport">4.5.</a>&nbsp;
Transport-layer Header Translation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section3.5">4.6.</a>&nbsp;
Knowing When to Translate<br />
<a href="#section4">5.</a>&nbsp;
Translating from IPv6 to IPv4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.1">5.1.</a>&nbsp;
Translating IPv6 Headers into IPv4 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">5.1.1.</a>&nbsp;
IPv6 Fragment Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.2">5.2.</a>&nbsp;
Translating ICMPv6 Headers into ICMPv4 Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.3">5.3.</a>&nbsp;
Translating ICMPv6 Error Messages into ICMPv4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sending-icmp2">5.4.</a>&nbsp;
Generation of ICMPv6 Error Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#transport2">5.5.</a>&nbsp;
Transport-layer Header Translation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section4.4">5.6.</a>&nbsp;
Knowing When to Translate<br />
<a href="#anchor5">6.</a>&nbsp;
Special Considerations for ICMPv6 Packet Too Big<br />
<a href="#IANA">7.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">8.</a>&nbsp;
Security Considerations<br />
<a href="#Acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<a href="#Appendix">10.</a>&nbsp;
Appendix: Stateless translation workflow example<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">10.1.</a>&nbsp;
H6 establishes communication with H4<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">10.2.</a>&nbsp;
H4 establishes communication with H6<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="section1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction and Motivation</h3>

<p>This document is a product of the 2008-2010 effort to define a
      replacement for NAT-PT <a class='info' href='#RFC2766'>[RFC2766]<span> (</span><span class='info'>Tsirtsis, G. and P. Srisuresh, &ldquo;Network Address Translation - Protocol Translation (NAT-PT),&rdquo; February&nbsp;2000.</span><span>)</span></a>. 
      It is directly derivative from
      Erik Nordmark's 
"Stateless IP/ICMP Translation Algorithm (SIIT)"
<a class='info' href='#RFC2765'>[RFC2765]<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a>, which provides
      stateless translation between IPv4 <a class='info' href='#RFC0791'>[RFC0791]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> and IPv6 <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>, and
      between ICMPv4 <a class='info' href='#RFC0792'>[RFC0792]<span> (</span><span class='info'>Postel, J., &ldquo;Internet Control Message Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> and ICMPv6 <a class='info' href='#RFC4443'>[RFC4443]<span> (</span><span class='info'>Conta, A., Deering, S., and M. Gupta, &ldquo;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification,&rdquo; March&nbsp;2006.</span><span>)</span></a>. 
      This document obsoletes RFC2765 <a class='info' href='#RFC2765'>[RFC2765]<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a>. 
      The changes from RFC2765 <a class='info' href='#RFC2765'>[RFC2765]<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a>
      are listed in Section 2.
      
</p>
<p>
Readers of this document are expected to have read and understood the
framework described in 
<a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; August&nbsp;2010.</span><span>)</span></a>.
Implementations of this IPv4/IPv6 translation specification MUST also
support the address translation algorithms in
<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>.
Implementations MAY also support
stateful translation 
<a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>.

</p>
<a name="section1.0"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
IPv4-IPv6 Translation Model</h3>

<p>The translation model consists of two or more network domains
        connected by one or more IP/ICMP translators (XLATs) as shown in Figure 1. 
	
</p><br /><hr class="insert" />
<a name="cloud1"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

     ---------          ---------
   //        \\       //         \\
 /             +----+              \
|              |XLAT|               | XLAT: IP/ICMP
|   IPv4       +----+   IPv6        |       Translator
|   Domain     |    |   Domain      |
|              |    |               |
 \             |    |              /
  \\         //      \\          //
     --------          ---------

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: IPv4-IPv6 Translation Model&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	 The scenarios of the translation model are discussed in
        <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; August&nbsp;2010.</span><span>)</span></a>.

</p>
<a name="section1.12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Applicability and Limitations</h3>

<p>
       This document specifies the
       translation algorithms between IPv4 packets and IPv6 packets.  	
       
</p>
<p>

	As with 
	<a class='info' href='#RFC2765'>[RFC2765]<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a>,
	the translating function specified in this document does not 
	translate any IPv4 options and it does not translate IPv6 extension headers 
	except fragmentation header. 

	
</p>
<p>
       The issues and algorithms in the translation of datagrams
       containing
       TCP segments are described in 
	<a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>. 
	 
</p>
<p>
        

   Fragmented IPv4 UDP packets that do not contain a UDP checksum (i.e.,
   the UDP checksum field is zero) are not of significant use in the
   Internet and in general will not be translated by the IP/ICMP translator. 
   However, when the translator is configured to forward the packet 
   without a UDP checksum, the fragmented IPv4 UDP packets will be translated. 

	 
</p>
<p>
Fragmented ICMP/ICMPv6 packets will not be translated by the IP/ICMP translator.

</p>
<p>
The IP/ICMP header translation
specified in this document is consistent with requirements of
multicast IP/ICMP headers.  
However IPv4 multicast
addresses 
<a class='info' href='#RFC5771'>[RFC5771]<span> (</span><span class='info'>Cotton, M., Vegoda, L., and D. Meyer, &ldquo;IANA Guidelines for IPv4 Multicast Address Assignments,&rdquo; March&nbsp;2010.</span><span>)</span></a> 
cannot be mapped to IPv6 multicast addresses
<a class='info' href='#RFC3307'>[RFC3307]<span> (</span><span class='info'>Haberman, B., &ldquo;Allocation Guidelines for IPv6 Multicast Addresses,&rdquo; August&nbsp;2002.</span><span>)</span></a> 
based on the unicast mapping rule 
<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>.
       
</p>
<a name="prefix-stateless"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Stateless vs. Stateful Mode</h3>

<p>An IP/ICMP translator has two possible modes of operation:
        stateless and stateful
        <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; August&nbsp;2010.</span><span>)</span></a>.


        In both cases, we assume that a system (a node or an application) that
        has an IPv4 address but not an IPv6 address is communicating with a
        system that has an IPv6 address but no IPv4 address, or that the two
        systems do not have contiguous routing connectivity
        and hence are forced to have their communications translated.
</p>
<p>In the stateless mode, a specific IPv6 address range will represent IPv4 systems (IPv4-converted addresses), 
	 and the IPv6 systems have addresses (IPv4-translatable addresses) that can be algorithmically 
        mapped to a subset of the service provider's IPv4 addresses. 
	 Note that
        IPv4-translatable addresses  is a subset of IPv4-converted addresses.

	 In general, there is no need to concern
        oneself with translation tables, as the IPv4 and
        IPv6 counterparts are algorithmically related.
	
</p>
<p>In the stateful mode, a specific IPv6 address range will represent IPv4 systems (IPv4-converted addresses), 
	 but the IPv6 systems may use any IPv6
	addresses <a class='info' href='#RFC4291'>[RFC4291]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;IP Version 6 Addressing Architecture,&rdquo; February&nbsp;2006.</span><span>)</span></a> except in that range. 
	 In this case, a translation table is required to bind the IPv6 systems' addresses to the IPv4 addresses maintained in the translator.
	
</p>
<p>
	The address translation mechanisms for the stateless and the stateful translations are defined in
       <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>.
	
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Path MTU Discovery and Fragmentation</h3>

<p>
Due to the different sizes of the IPv4 and IPv6 header, which are 20+ octets and 40
octets respectively, handling the maximum packet size is critical for the operation 
of the IPv4/IPv6 translator. There are three mechanisms to handle this issue: 
path MTU discovery (PMTUD), fragmentation, and transport-layer negotiation such as 
the TCP MSS option
<a class='info' href='#RFC0879'>[RFC0879]<span> (</span><span class='info'>Postel, J., &ldquo;TCP maximum segment size and related topics,&rdquo; November&nbsp;1983.</span><span>)</span></a>.

Note that the translator MUST behave as a router, i.e. 
the translator MUST send a "Packet Too Big" error message or fragment the packet when the packet size exceeds 
the MTU of the next hop interface. 

</p>
<p>
"Don't Fragment", ICMP "Packet Too Big", and packet fragmentation are discussed
in sections 3 and 4 of this document.  

The reassembling of fragmented packets   in the stateful translator is discussed in
<a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>,
since it requires state maintenance in the translator.

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Changes from RFC2765</h3>

<p>
	The changes from RFC2765 are the following:
	
</p>
<ol class="text">
<li>
Redescribing the network model to map to present and projected usage. 
The scenarios, applicability and limitations originally presented in RFC2765 
<a class='info' href='#RFC2765'>[RFC2765]<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a>
are moved to 
framework document
<a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; August&nbsp;2010.</span><span>)</span></a>.

</li>
<li>
Moving the address format to the address format document
<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>,
to coordinate with other documents on the topic.

</li>
<li>
Describing the header translation for the stateless and stateful operations. 
The details of the session database and mapping table
handling of the stateful translation is in stateful translation document
<a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>.

</li>
<li>
Having refined the header translation, fragmentation handling, 
ICMP translation and ICMP error translation in IPv4 to IPv6 direction, 
as well as in IPv6 to IPv4 direction.

</li>
<li>
Adding more discussion on transport-layer header translation.

</li>
<li> 
Adding a section for "IPv6 Fragment Processing".

</li>
<li>
Adding a section for "Special Considerations for ICMPv6 Packet Too Big".

</li>
<li>
Having updated the section for "Security Considerations".

</li>
<li>
Adding appendix "Stateless translation workflow example".

</li>
</ol><p>

</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Conventions</h3>

<p>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>. 
	
</p>
<a name="section3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Translating from IPv4 to IPv6</h3>

<p>
   When an IP/ICMP translator receives an IPv4 datagram addressed to a
   destination towards the IPv6 domain, it translates the IPv4 header of
   that packet into an IPv6 header.  The original IPv4 header on the
   packet is removed and replaced by an IPv6 header and the transport
   checksum updated as needed, if that transport is supported by the
   translator.  The data portion of the packet is left
   unchanged.  The IP/ICMP translator then forwards the packet based on
   the IPv6 destination address.

</p><br /><hr class="insert" />
<a name="v4v6xlat"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+-------------+                 +-------------+
|    IPv4     |                 |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|  Transport  |                 |  Fragment   |
|   Layer     |      ===&gt;       |   Header    |
|   Header    |                 | (if needed) |
+-------------+                 +-------------+
|             |                 |  Transport  |
~    Data     ~                 |   Layer     |
|             |                 |   Header    |
+-------------+                 +-------------+
                                |             |
                                ~    Data     ~
                                |             |
                                +-------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: IPv4-to-IPv6 Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   Path MTU discovery is mandatory in IPv6 but it is optional in IPv4.
IPv6 routers never fragment a packet - only the sender can do
fragmentation.

     
</p>
<p>When an IPv4 node performs path MTU discovery (by setting the Don't Fragment (DF) bit
      in the header), path MTU discovery can operate end-to-end, i.e., across
      the translator. In this case either IPv4 or IPv6 routers (including the translator) might send back
      ICMP "Packet Too Big" messages to the sender. When the IPv6 routers send
      these ICMPv6 errors they will pass through a translator that will
      translate the ICMPv6 error to a form that the IPv4 sender can understand.
      As a result, an IPv6 fragment header is only included if the IPv4 packet
      is already fragmented.
</p>
<p>However, when the IPv4 sender does not set the Don't Fragment (DF) bit, the
      translator MUST ensure that the packet does not exceed the path MTU on
      the IPv6 side. This is done by fragmenting the IPv4 packet so that it
      fits in 1280-byte IPv6 packets, since that is the
      minimum IPv6 MTU. Also, when the IPv4 sender does not set the DF bit 
      the translator MUST always include an IPv6 fragment
      header to indicate that the sender allows fragmentation. 
	
</p>
<p>The rules in section 3.1 ensure that when packets are fragmented, either by
      the sender or by IPv4 routers, the low-order 16 bits of the fragment
      identification are carried end-to-end, ensuring that packets are correctly
      reassembled. In addition, the rules in section 3.1 use the presence of an IPv6 fragment
      header to indicate that the sender might not be using path MTU discovery 
      (i.e., the packet should not have the DF flag set should it later be
      translated back to IPv4).
</p>
<p>Other than the special rules for handling fragments and path MTU
      discovery, the actual translation of the packet header consists of a
      simple translation as defined below. Note that ICMPv4 packets require special
      handling in order to translate the content of ICMPv4 error messages and
      also to add the ICMPv6 pseudo-header checksum.
</p>
<p>
   The translator SHOULD make sure that the packets belonging to the 
   same flow leave the translator in the same order in which they 
   arrived.

</p>
<a name="section3.1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Translating IPv4 Headers into IPv6 Headers</h3>

<p>
        If the DF flag is not set and the IPv4 packet will result in an IPv6
        packet larger than 1280 bytes, the packet MUST be fragmented so the
        resulting IPv6 packet (with Fragment header added to each fragment)
        will be less than or equal to 1280 bytes. For example, if the packet
        is fragmented prior to the translation, the IPv4 packets must be
        fragmented so that their length, excluding the IPv4 header, is at
        most 1232 bytes (1280 minus 40 for the IPv6 header and 8 for the
        Fragment header).  The resulting fragments are then translated
        independently using the logic described below.
       
</p>
<p>
If the DF bit is set and the MTU of the next-hop interface is less than the
total length value of the IPv4 packet plus 20, the translator MUST send an ICMPv4 "Fragmentation Needed" error message
to the IPv4 source address. 

</p>
<p>If the DF bit is set and the packet is not a fragment (i.e., the MF
        flag is not set and the Fragment Offset is equal to zero) then the translator SHOULD NOT 
        add a Fragment header to the resulting packet. The IPv6 header fields are set
        as follows: </p>
<blockquote class="text"><dl>
<dt>Version:</dt>
<dd>6
</dd>
<dt>Traffic Class:</dt>
<dd>By default, copied from IP Type Of
            Service (TOS) octet. According to <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a> the
            semantics of the bits are identical in IPv4 and IPv6. However, in
            some IPv4 environments these fields might be used with the old
            semantics of "Type Of Service and Precedence". 


An implementation of a translator SHOULD support an
administratively-configurable option to ignore the IPv4 TOS and always
set the IPv6 traffic class (TC) to zero.

		In addition,
            if the translator is at an administrative boundary, the filtering
            and update considerations of <a class='info' href='#RFC2475'>[RFC2475]<span> (</span><span class='info'>Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, &ldquo;An Architecture for Differentiated Services,&rdquo; December&nbsp;1998.</span><span>)</span></a> may be
            applicable.


		
</dd>
<dt>Flow Label:</dt>
<dd>0 (all zero bits)
</dd>
<dt>Payload Length:</dt>
<dd>Total length value from IPv4 header,
            minus the size of the IPv4 header and IPv4 options, if
            present.
</dd>
<dt>Next Header:</dt>
<dd>
		For ICMPv4 (1) changed to ICMPv6 (58), otherwise protocol field MUST be copied from IPv4 header. 
		
</dd>
<dt>Hop Limit:</dt>
<dd>The hop limit is derived from the TTL value in the IPv4 header.  Since
            the translator is a router, as part of forwarding the packet it
            needs to decrement either the IPv4 TTL (before the translation) or
            the IPv6 Hop Limit (after the translation). As part of
            decrementing the TTL or Hop Limit the translator (as any router)
            MUST check for zero and send the ICMPv4 "TTL Exceeded" or ICMPv6 "Hop Limit
            Exceeded" error.
</dd>
<dt>Source Address:</dt>
<dd>
		The IPv4-converted address derived from the IPv4 source address per 
		<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>
		section 2.1. 

 		<br />
 If the translator gets an illegal source address (e.g. 0.0.0.0, 127.0.0.1, etc.), the translator SHOULD silently drop the packet
(as discussed in Section 5.3.7 of 
<a class='info' href='#RFC1812'>[RFC1812]<span> (</span><span class='info'>Baker, F., &ldquo;Requirements for IP Version 4 Routers,&rdquo; June&nbsp;1995.</span><span>)</span></a>).
		<br />
<br />
 


</dd>
<dt>Destination Address:</dt>
<dd>In the stateless mode, which is to
            say that if the IPv4 destination address is within a range of configured
            IPv4 stateless translation prefix, the IPv6 destination address is
            the IPv4-translatable address derived from the IPv4 destination address
		per <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a> section 2.1. 
		A workflow example of stateless translation is shown in the Appendix of this document.

                     <br />
 In the stateful mode, which is to say that if the
            IPv4 destination address is not within the range of any configured IPv4 stateless
            translation prefix, the IPv6 destination address and
            corresponding transport-layer destination port are derived from
            the Binding Information Bases (BIBs) reflecting current session state in the
            translator as described in <a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
<br />
<br />
 

</dd>
</dl></blockquote>

<p>

   If any IPv4 options are present in the IPv4 packet, the IPv4 options
   MUST be ignored and the packet translated normally; there is no
attempt to translate the options.



        However, if an unexpired
        source route option is present then the packet MUST instead be
        discarded, and an ICMPv4 "Destination Unreachable/Source Route Failed"
        (Type 3/Code 5) error message SHOULD be returned to the sender.

	
</p>
<p>If there is a need to add a Fragment header (the DF bit is not set or
        the packet is a fragment) the header fields are set as above with the
        following exceptions: </p>
<blockquote class="text"><dl>
<dt>IPv6 fields:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Payload Length:</dt>
<dd>Total length value from IPv4
                header, plus 8 for the fragment header, minus the size of the
                IPv4 header and IPv4 options, if present.
</dd>
<dt>Next Header:</dt>
<dd>Fragment header (44).
</dd>
</dl></blockquote>
</dd>
<dt>Fragment header fields:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Next Header:</dt>
<dd>

For ICMPv4 (1) changed to ICMPv6 (58), otherwise protocol field MUST be copied from IPv4 header. 


</dd>
<dt>Fragment Offset:</dt>
<dd>Fragment Offset copied from the
                IPv4 header.
</dd>
<dt>M flag:</dt>
<dd>More Fragments bit copied from the IPv4
                header.
</dd>
<dt>Identification:</dt>
<dd>The low-order 16 bits copied from
                the Identification field in the IPv4 header. The high-order 16
                bits set to zero.
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="section3.3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Translating ICMPv4 Headers into ICMPv6 Headers</h3>

<p>All ICMPv4 messages that are to be translated require that the ICMPv6
        checksum field be calculated as part of the translation since ICMPv6,
        unlike ICMPv4, has a pseudo-header checksum just like UDP and TCP.
</p>
<p>In addition, all ICMPv4 packets MUST have the Type value translated
        and, for ICMPv4 error messages, the included IP header also MUST be
        translated.
</p>
<p>The actions needed to translate various ICMPv4 messages are as follows: </p>
<blockquote class="text"><dl>
<dt>ICMPv4 query messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Echo and Echo Reply (Type 8 and Type 0):</dt>
<dd>Adjust
                the Type values to 128 and 129, respectively, and adjust the ICMP
                checksum both to take the type change into account and to
                include the ICMPv6 pseudo-header.
</dd>
<dt>Information Request/Reply (Type 15 and Type 16):</dt>
<dd>Obsoleted
                in ICMPv6. Silently drop.
</dd>
<dt>Timestamp and Timestamp Reply (Type 13 and Type 14):</dt>
<dd>Obsoleted
                in ICMPv6. Silently drop.
</dd>
<dt>Address Mask Request/Reply (Type 17 and Type 18):</dt>
<dd>Obsoleted
                in ICMPv6. Silently drop.
</dd>
<dt>ICMP Router Advertisement (Type 9):</dt>
<dd>Single hop
                message. Silently drop.
</dd>
<dt>ICMP Router Solicitation (Type 10):</dt>
<dd>Single hop
                message. Silently drop.
</dd>
<dt>Unknown ICMPv4 types:</dt>
<dd>Silently drop.
</dd>
<dt>IGMP messages:</dt>
<dd>While the MLD messages <a class='info' href='#RFC2710'>[RFC2710]<span> (</span><span class='info'>Deering, S., Fenner, W., and B. Haberman, &ldquo;Multicast Listener Discovery (MLD) for IPv6,&rdquo; October&nbsp;1999.</span><span>)</span></a><a class='info' href='#RFC3590'>[RFC3590]<span> (</span><span class='info'>Haberman, B., &ldquo;Source Address Selection for the Multicast Listener Discovery (MLD) Protocol,&rdquo; September&nbsp;2003.</span><span>)</span></a><a class='info' href='#RFC3810'>[RFC3810]<span> (</span><span class='info'>Vida, R. and L. Costa, &ldquo;Multicast Listener Discovery Version 2 (MLDv2) for IPv6,&rdquo; June&nbsp;2004.</span><span>)</span></a> are the logical IPv6 counterparts for
                the IPv4 IGMP messages all the "normal" IGMP messages are
                single-hop messages and SHOULD be silently dropped by the
                translator.

		  Other IGMP messages might be used by multicast
                routing protocols and, since it would be a configuration error
                to try to have router adjacencies across IP/ICMP translators
                those packets SHOULD also be silently dropped.
</dd>
<dt> ICMPv4 error messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Destination Unreachable (Type 3):</dt>
<dd>
			Translate the Code field as 
            		described below, set the Type field to 1, and adjust
            		the ICMP checksum both to take the type/code change into account
            		and to include the ICMPv6 pseudo-header.
                    <br />
 Translate the Code field as
                    follows: 

			
<blockquote class="text"><dl>
<dt>Code 0, 1 (Net, host unreachable):</dt>
<dd>Set
                        Code value to 0 (no route to destination).
</dd>
<dt>Code 2 (Protocol unreachable):</dt>
<dd>Translate
                        to an ICMPv6 Parameter Problem (Type 4, Code value 1) and
                        make the Pointer point to the IPv6 Next Header
                        field.
</dd>
<dt>Code 3 (Port unreachable):</dt>
<dd>Set Code value to 4
                        (port unreachable).
</dd>
<dt>Code 4 (Fragmentation needed and DF set):</dt>
<dd>Translate
                        to an ICMPv6 Packet Too Big message (Type 2) with Code value
                        set to 0. The MTU field MUST be adjusted for the
                        difference between the IPv4 and IPv6 header sizes, 
				i.e. minimum(advertised
				MTU+20, MTU_of_IPv6_nexthop, (MTU_of_IPv4_nexthop)+20).

                        Note that if the IPv4 router set the MTU field to zero,
                        i.e., the router does not implement <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a>, then the translator MUST use
                        the plateau values specified in <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a> to determine a likely path
                        MTU and include that path MTU in the ICMPv6 packet.
                        (Use the greatest plateau value that is less than the
                        returned Total Length field.)

			
</dd>
<dt></dt>
<dd>
			See also the requirements in Section 5.

			


                       


                       
</dd>
<dt>Code 5 (Source route failed):</dt>
<dd>Set Code value
                        to 0 (No route to destination). Note that this error
                        is unlikely since source routes are not
                        translated.
</dd>
<dt>Code 6, 7, 8:</dt>
<dd>Set Code value to 0 (No route to
                        destination).
</dd>
<dt>Code 9, 10 (Communication with destination host administratively prohibited):</dt>
<dd>Set
                        	Code value to 1 (Communication with destination
                        administratively prohibited)
				
</dd>
<dt>Code 11, 12:</dt>
<dd>Set Code value to 0 (no route to
                        destination).
</dd>
<dt>Code 13 (Communication Administratively Prohibited):</dt>
<dd>Set Code value to 1 (Communication with destination administratively prohibited).
                        
</dd>
<dt>Code 14 (Host Precedence Violation):</dt>
<dd>Silently drop.
                        
</dd>
<dt>Code 15 (Precedence cutoff in effect):</dt>
<dd>Set Code value to 1 (Communication with destination administratively prohibited).
                        
</dd>
<dt>Other Code values:</dt>
<dd>Silently drop.
</dd>
</dl></blockquote>
</dd>
<dt>Redirect (Type 5):</dt>
<dd>Single hop message.
                    Silently drop.
</dd>
<dt>Alternative Host Address (Type 6):</dt>
<dd>
                    Silently drop.
</dd>
<dt>Source Quench (Type 4):</dt>
<dd>Obsoleted in ICMPv6.
                    Silently drop.
</dd>
<dt>Time Exceeded (Type 11):</dt>
<dd>Set the Type field
                    to 3, and adjust the ICMP checksum both to
         		take the type change into account and to include the ICMPv6
         		pseudo-header. The Code field is unchanged.
</dd>
<dt>Parameter Problem (Type 12):</dt>
<dd>Set the Type
                    field to 4, and adjust the ICMP checksum both to
         		take the type/code change into account and to include the ICMPv6
        		 pseudo-header. 
			<br />
 Translate the Code field as
                    follows: 

			
<blockquote class="text"><dl>
<dt>Code 0 (Pointer indicates the error):</dt>
<dd>
				Set the Code value to 0 (Erroneous header field encountered) and update the pointer as defined in Figure 3 
				(If the Original IPv4 Pointer Value is not listed or the Translated IPv6 Pointer 
				Value is listed as "n/a", silently drop the packet).
			
</dd>
<dt>Code 1 (Missing a required option):</dt>
<dd>
				Silently drop				
				
</dd>
<dt>Code 2 (Bad length):</dt>
<dd>
				Set the Code value to 0 (Erroneous header field encountered) and update the pointer as defined in Figure 3
				(If the Original IPv4 Pointer Value is not listed or the Translated IPv6 Pointer 
				Value is listed as "n/a", silently drop the packet).
				
</dd>
<dt>Other Code values:</dt>
<dd>
				Silently drop				
				
</dd>
</dl></blockquote>

			
</dd>
<dt>Unknown ICMPv4 types:</dt>
<dd>Silently drop.
			
</dd>
<dt></dt>
<dd>
        <br /><hr class="insert" />
<a name="appendix-461"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

 |   Original IPv4 Pointer Value  | Translated IPv6 Pointer Value  |
 +--------------------------------+--------------------------------+
 |  0  | Version/IHL              |  0  | Version/Traffic Class    |
 |  1  | Type Of Service          |  1  | Traffic Class/Flow Label |
 | 2,3 | Total Length             |  4  | Payload Length           |
 | 4,5 | Identification           | n/a |                          |
 |  6  | Flags/Fragment Offset    | n/a |                          |
 |  7  | Fragment Offset          | n/a |                          |
 |  8  | Time to Live             |  7  | Hop Limit                |
 |  9  | Protocol                 |  6  | Next Header              |
 |10,11| Header Checksum          | n/a |                          |
 |12-15| Source Address           |  8  | Source Address           |
 |16-19| Destination Address      | 24  | Destination Address      |
 +--------------------------------+--------------------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Pointer value for translating from IPv4 to IPv6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



</dd>
<dt>ICMP Error Payload:</dt>
<dd>

If the received ICMPv4 packet contains an ICMPv4 Extension 
<a class='info' href='#RFC4884'>[RFC4884]<span> (</span><span class='info'>Bonica, R., Gan, D., Tappan, D., and C. Pignataro, &ldquo;Extended ICMP to Support Multi-Part Messages,&rdquo; April&nbsp;2007.</span><span>)</span></a>, 
the translation of the ICMPv4 packet will cause the ICMPv6 packet to change length. 
When this occurs, the ICMPv6 Extension length attribute MUST be adjusted accordingly 
(e.g., longer due to the translation from IPv4 to IPv6). 
If the ICMPv4 Extension exceeds the maximum size of an ICMPv6 message on the outgoing 
interface, the ICMPv4 extension SHOULD be simply truncated. 
For extensions not defined in 
<a class='info' href='#RFC4884'>[RFC4884]<span> (</span><span class='info'>Bonica, R., Gan, D., Tappan, D., and C. Pignataro, &ldquo;Extended ICMP to Support Multi-Part Messages,&rdquo; April&nbsp;2007.</span><span>)</span></a>,
the translator passes the extensions 
as opaque bit strings and  those containing IPv4 address literals will not have 
those addresses translated to IPv6 address literals; this may cause problems 
with processing of those ICMP extensions.

				
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="section3.4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Translating ICMPv4 Error Messages into ICMPv6</h3>

<p>There are some differences between the ICMPv4 and the ICMPv6 error
        message formats as detailed above. The ICMP error
        messages containing the packet in error MUST
        be translated just like a normal IP packet. 


If the translation of this "packet in error" changes the length of
the datagram, the Total
   Length field in the outer IPv6 header MUST be updated.

       
</p><br /><hr class="insert" />
<a name="v4v6icmp"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+-------------+                 +-------------+
|    IPv4     |                 |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   ICMPv4    |                 |   ICMPv6    |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|    IPv4     |      ===&gt;       |    IPv6     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   Partial   |                 |   Partial   |
|  Transport  |                 |  Transport  |
|   Layer     |                 |   Layer     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: IPv4-to-IPv6 ICMP Error Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   The translation of the inner IP header can be done by invoking the function 
that translated the outer IP headers. This process MUST stop at the first embedded 
header and drop the packet if it contains more.

</p>
<a name="sending-icmp1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Generation of ICMPv4 Error Message</h3>

<p>
		If the IPv4 packet is discarded, then the translator SHOULD be able to send back an ICMPv4 error message to the original sender of the packet, 
		unless the discarded packet is itself an ICMPv4 message. 
		The ICMPv4 message, if sent, has a Type value of 3 (Destination Unreachable) and a Code value of 13 (Communication Administratively Prohibited),
		unless otherwise specified in this document or in 
		<a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
		The translator SHOULD allow an administrator to configure whether the ICMPv4 error messages are sent, rate-limited, or not sent. 
	
</p>
<a name="transport"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Transport-layer Header Translation</h3>

<p>
   If the address translation algorithm is not checksum neutral
   (Section 3 of 
   <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>),
   the recalculation
   and updating of the transport-layer headers which contain pseudo
   headers needs to be performed.  Translators MUST do this for TCP 
   and ICMP packets and for UDP packets that contain a UDP checksum 
   (i.e. the UDP checksum field is not zero).

</p>
<p>
  For UDP packets that do not contain a UDP checksum 
(i.e. the UDP checksum field is zero), the translator 
SHOULD provide a configuration function to
   allow:
</p>
<ol class="text">
<li>
Dropping the packet and generating a system management
   event specifying at least the IP addresses and port numbers of the
   packet. 

</li>
<li>
Calculating an IPv6 checksum and forward the packet
   (which has performance implications).
	<br />
<br />
 
A stateless translator cannot compute the
   UDP checksum of fragmented packets, so when a stateless translator
   receives the first fragment of a fragmented UDP IPv4 packet and the
   checksum field is zero, the translator SHOULD drop the packet and
   generate a system management event specifying at least the IP
   addresses and port numbers in the packet. 
	<br />
<br />
 
 For stateful translator,
   the handling of fragmented UDP IPv4 packets with a zero checksum is
   discussed in 
   <a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>),
  section 3.1.


</li>
<li>
Forwarding the packet
   without a UDP checksum.  
	<br />
<br />
 
A stateless translator can translate fragmented UDP IPv4 packet under this condition.

</li>
</ol><p>

</p>
<p>
   Other transport protocols (e.g., DCCP) are OPTIONAL to support.  In
   order to ease debugging and troubleshooting, translators MUST forward
   all transport protocols as described in the "Next Header" step of
   Section 3.1.

</p>
<a name="section3.5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Knowing When to Translate</h3>

<p>

   If the IP/ICMP translator also provides normal forwarding function, and the destination IPv4 address is reachable by a
   more specific route without translation, the translator MUST forward it
   without translating it.  Otherwise, when an IP/ICMP translator
   receives an IPv4 datagram addressed to an IPv4 destination representing a host in the IPv6
   domain, the packet MUST be translated to IPv6.

</p>
<a name="section4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Translating from IPv6 to IPv4</h3>

<p>When an IP/ICMP translator receives an IPv6 datagram addressed to a
      destination towards the IPv4 domain, it translates the IPv6 header of
      the received IPv6 packet into an IPv4 header. 
	The
      original IPv6 header on the packet is removed and replaced by an IPv4
      header. 
	Since the ICMPv6      <a class='info' href='#RFC4443'>[RFC4443]<span> (</span><span class='info'>Conta, A., Deering, S., and M. Gupta, &ldquo;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification,&rdquo; March&nbsp;2006.</span><span>)</span></a>, 
      TCP <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, 
      UDP <a class='info' href='#RFC0768'>[RFC0768]<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a> and
	DCCP <a class='info' href='#RFC4340'>[RFC4340]<span> (</span><span class='info'>Kohler, E., Handley, M., and S. Floyd, &ldquo;Datagram Congestion Control Protocol (DCCP),&rdquo; March&nbsp;2006.</span><span>)</span></a> 
      headers
      contain checksums that cover the IP header, 
      if the address mapping algorithm is not checksum-neutral, 
      the checksum MUST be evaluated before translation and the ICMP and transport-layer headers MUST be updated. 
      
	The
      data portion of the packet is left unchanged. The IP/ICMP translator
      then forwards the packet based on the IPv4 destination address. 
</p><br /><hr class="insert" />
<a name="v6v4xlat"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+-------------+                 +-------------+
|    IPv6     |                 |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|  Fragment   |                 |  Transport  |
|   Header    |      ===&gt;       |   Layer     |
|(if present) |                 |   Header    |
+-------------+                 +-------------+
|  Transport  |                 |             |
|   Layer     |                 ~    Data     ~
|   Header    |                 |             |
+-------------+                 +-------------+
|             |
~    Data     ~
|             |
+-------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: IPv6-to-IPv4 Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>There are some differences between IPv6 and IPv4 in the area of
      fragmentation and the minimum link MTU that affect the translation. An
      IPv6 link has to have an MTU of 1280 bytes or greater. The corresponding
      limit for IPv4 is 68 bytes. 


   Path MTU Discovery across a translator relies on ICMP 
   Packet Too Big messages being received and processed by IPv6
   hosts, including an ICMP Packet Too Big that indicates the MTU
   is less than the IPv6 minimum MTU.  This requirement is 
   described in Section 5 of 
<a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>
(for IPv6's 1280 octet 
   minimum MTU) and Section 5 of 
<a class='info' href='#RFC1883'>[RFC1883]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1995.</span><span>)</span></a>
(for IPv6's previous
   576 octet minimum MTU).


</p>
<p>
   In an environment where an ICMPv4 Packet Too Big message is
   translated to an ICMPv6 Packet Too Big messages, and the ICMPv6
   Packet Too Big message is successfully delivered to and correctly
   processed by the IPv6 hosts (e.g., a network owned/operated by 
   the same entity that owns/operates the translator), the translator 
   can rely on IPv6 hosts sending subsequent packets to the same
   IPv6 destination with IPv6 fragment headers.  In such an 
   environment, when the translator receives an IPv6 packet with a
   fragmentation header, the translator SHOULD generate the IPv4
   packet with a cleared Don't Fragment bit, and with its 
   identification value from the IPv6 fragment header, for 
   all of the IPv6 fragments (MF=0 or MF=1).


</p>
<p>
In an environment where an ICMPv4 Packet Too Big message
are filtered (by a network firewall or 
   by the host itself) or not correctly processed by the IPv6 hosts, 
   the IPv6 host will never generate an IPv6 packet with the IPv6 
   fragment header.  In such an environment, the translator SHOULD 
   set the IPv4 Don't Fragment bit.  While setting the Don't Fragment 
   bit may create PMTUD black holes 
<a class='info' href='#RFC2923'>[RFC2923]<span> (</span><span class='info'>Lahey, K., &ldquo;TCP Problems with Path MTU Discovery,&rdquo; September&nbsp;2000.</span><span>)</span></a>
if there are IPv4 links
   smaller than 1260 octets, this is considered safer than 
   causing IPv4 reassembly errors 
<a class='info' href='#RFC4963'>[RFC4963]<span> (</span><span class='info'>Heffner, J., Mathis, M., and B. Chandler, &ldquo;IPv4 Reassembly Errors at High Data Rates,&rdquo; July&nbsp;2007.</span><span>)</span></a>.

</p>
<p>Other than the special rules for handling fragments and path MTU
      discovery, the actual translation of the packet header consists of a
      simple translation as defined below. Note that ICMPv6 packets require special
      handling in order to translate the contents of ICMPv6 error messages and
      also to remove the ICMPv6 pseudo-header checksum.
</p>
<p>
	   The translator SHOULD make sure that the packets belonging to the 
   	same flow leave the translator in the same order in which they 
   	arrived.
	
</p>
<a name="section4.1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Translating IPv6 Headers into IPv4 Headers</h3>

<p>If there is no IPv6 Fragment header, the IPv4 header fields are set
        as follows: </p>
<blockquote class="text"><dl>
<dt>Version:</dt>
<dd>4
</dd>
<dt>Internet Header Length:</dt>
<dd>5 (no IPv4 options)
</dd>
<dt>Type of Service (TOS) Octet:</dt>
<dd>By default, copied from
            the IPv6 Traffic Class (all 8 bits). According to <a class='info' href='#RFC2474'>[RFC2474]<span> (</span><span class='info'>Nichols, K., Blake, S., Baker, F., and D. Black, &ldquo;Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers,&rdquo; December&nbsp;1998.</span><span>)</span></a> the semantics of the bits are identical
            in IPv4 and IPv6. However, in some IPv4 environments, these bits
            might be used with the old semantics of "Type Of Service and
            Precedence". An implementation of a translator SHOULD provide the
            ability to ignore the IPv6 traffic class and always set the IPv4
            TOS Octet to a specified value. In addition, if the translator is
            at an administrative boundary, the filtering and update
            considerations of <a class='info' href='#RFC2475'>[RFC2475]<span> (</span><span class='info'>Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, &ldquo;An Architecture for Differentiated Services,&rdquo; December&nbsp;1998.</span><span>)</span></a> may be
            applicable.
</dd>
<dt>Total Length:</dt>
<dd>Payload length value from IPv6 header,
            plus the size of the IPv4 header.
</dd>
<dt>Identification:</dt>
<dd>

                 All zero. 
In order to avoid black holes caused by ICMPv4 filtering or non 
<a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>
compatible IPv6 hosts (a workaround discussed in Section 4), 
the translator MAY provide a function such as if the packet size 
is equal to or smaller than 1280 bytes and greater than 88 bytes, 
generate the identification value. The translator SHOULD provide 
a method for operators to enable or disable this function.

            
</dd>
<dt>Flags:</dt>
<dd>
                 The More Fragments flag is set to zero.  The Don't
                 Fragments flag is set to one.
In order to avoid black holes caused by ICMPv4 filtering or non 
<a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>
compatible IPv6 hosts (a workaround discussed in Section 5), the translator 
MAY provide a function such as if the packet size is equal to or smaller than 
1280 bytes and greater than 88 bytes, the Don't Fragments (DF) flag 
is set to zero, otherwise the Don't Fragments (DF) flag is set to one.  
The translator SHOULD provide a method for operators to enable or 
disable this function.
            
</dd>
<dt>Fragment Offset:</dt>
<dd>All zeros.
</dd>
<dt>Time to Live:</dt>
<dd>

 Time to Live is derived from Hop Limit value in IPv6 header.  
Since the translator is a router, as part of forwarding
            the packet it needs to decrement either the IPv6 Hop Limit (before
            the translation) or the IPv4 TTL (after the translation). As part
            of decrementing the TTL or Hop Limit the translator (as any
            router) MUST check for zero and send the ICMPv4 "TTL Exceeded" or ICMPv6 "Hop Limit
            Exceeded" error.
</dd>
<dt>Protocol:</dt>
<dd>

	The IPv6-Frag (44) header is handled as discussed in
      Section 4.1.1.  ICMPv6 (58) is changed to ICMPv4 (1), and the
      payload is translated as discussed in Section 4.2.  The IPv6
      headers HOPOPT (0), IPv6-Route (43), and IPv6-Opts (60) are skipped
      over during processing as they have no meaning in IPv4.  For the
      first 'next header' that does not match one of the cases above, its
      next header value (which contains the transport protocol number) is
      copied to the protocol field in the IPv4 header.  This means that
      all transport protocols are translated.


<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>
                Some translated protocols will fail at the receiver
                for various reasons:  some are known to fail when
                translated (e.g., IPsec AH (51)), and others will fail 
                checksum validation if the address translation is not
                checksum neutral 
                <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>
                and the translator does not update the transport
                protocol's checksum (because the translator doesn't
                support recalculating the checksum for that
                transport protocol, see Section 4.5).
		
</dd>
</dl></blockquote>

</dd>
<dt>Header Checksum:</dt>
<dd>Computed once the IPv4 header has
            been created.
</dd>
<dt>Source Address:</dt>
<dd>In the stateless mode, which is to say
            that if the IPv6 source address is within the range of a configured
            IPv6 translation prefix, the IPv4 source address is derived from the
     		 IPv6 source address
		per <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a> section 2.1.
		Note that the original IPv6 source address is an IPv4-translatable address. 
A workflow example of stateless translation is shown in Appendix of this document.

 If the translator only supports stateless mode and 		
 if the IPv6 source address is not within the range of configured IPv6
 prefix(es), 
  the translator SHOULD drop the packet and respond with an ICMPv6 Type=1, Code=5 (Destination 
  Unreachable, Source address failed ingress/egress policy).

		

		<br />
 In the 
            stateful mode, which is to say that if the IPv6 source address is
            not within the range of any configured IPv6 stateless translation prefix, the IPv4
            source address and transport-layer source port corresponding to
            the IPv4-related IPv6 source address and source port are derived
            from the Binding
      Information Bases (BIBs)  as described in <a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>.


		<br />
<br />
 

      In stateless and stateful modes, if the translator gets an illegal source address (e.g. ::1,
      etc.), the translator SHOULD silently drop the packet.


</dd>
<dt>Destination Address:</dt>
<dd>
		The IPv4 destination address is derived from the
            IPv6 destination address of the datagram being translated 
		per <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a> section 2.1.
		Note that the original IPv6 destination address is an IPv4-converted address.

</dd>
</dl></blockquote>

<p>If a Routing header with a non-zero Segments Left field is present
        then the packet MUST NOT be translated, and an ICMPv6 "parameter
        problem/erroneous header field encountered" (Type 4/Code 0) error
        message, with the Pointer field indicating the first byte of the
        Segments Left field, SHOULD be returned to the sender.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
IPv6 Fragment Processing</h3>

<p>If the IPv6 packet contains a Fragment header, the header fields are
        set as above with the following exceptions: </p>
<blockquote class="text"><dl>
<dt>Total Length:</dt>
<dd>Payload length value from IPv6 header,
            minus 8 for the Fragment header, plus the size of the IPv4
            header.
</dd>
<dt>Identification:</dt>
<dd>Copied from the low-order 16-bits in
            the Identification field in the Fragment header.
</dd>
<dt>Flags:</dt>
<dd>
	The IPv4 More Fragments (MF) flag is copied from the M 
      flag in the IPv6 Fragment header.  The IPv4 Don't Fragments (DF) 
      flag is cleared (set to zero) allowing this packet to be further 
      fragmented by IPv4 routers.
		
</dd>
<dt>Fragment Offset:</dt>
<dd>
Copied from the Fragment Offset field of the
      IPv6 Fragment header.		

</dd>
<dt>Protocol:</dt>
<dd>
 		For ICMPv6 (58) changed to ICMPv4 (1), otherwise 
		skip extension headers, Next Header field copied from the last IPv6 header.
		
</dd>
</dl></blockquote>

<p>
If a translated packet with DF set to 1 will be larger than the MTU of
the next-hop interface, then the translator MUST drop the packet and send
the ICMPv6 "Packet Too Big" (Type 2/Code 0) error message to the IPv6
host with an adjusted MTU in the ICMPv6 message.


</p>
<a name="section4.2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Translating ICMPv6 Headers into ICMPv4 Headers</h3>

<p>
   If a non-checksum neutral translation address is being used, 
   ICMPv6 messages MUST have their ICMPv4 checksum field be updated 
   as part of the translation since ICMPv6 (unlike ICMPv4) includes a 
   pseudo-header in the checksum just like UDP and TCP.
	
</p>
<p>In addition all ICMP packets MUST have the Type value translated
        and, for ICMP error messages, the included IP header also MUST be translated.

Note that the IPv6 addresses in the IPv6 header may not
   be IPv4-translatable addresses and there will be no corresponding
   IPv4 addresses representing this IPv6 address.     
   In this case, the translator can do stateful translation.
   A mechanism by which the translator can instead do 
   stateless translation of this address is left for future work.


</p>
<p>The actions needed to translate various ICMPv6 messages are: </p>
<blockquote class="text"><dl>
<dt>ICMPv6 informational messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Echo Request and Echo Reply (Type 128 and 129):</dt>
<dd>Adjust
                the Type values to 8 and 0, respectively, and adjust the ICMP
                checksum both to take the type change into account and to
                exclude the ICMPv6 pseudo-header.
</dd>
<dt>MLD Multicast Listener Query/Report/Done (Type 130, 131, 132):</dt>
<dd>Single
                hop message. Silently drop.
</dd>
<dt>Neighbor Discover messages (Type 133 through 137):</dt>
<dd>Single
                hop message. Silently drop.
</dd>
<dt>Unknown informational messages:</dt>
<dd>Silently
                drop.
</dd>
</dl></blockquote>
</dd>
<dt>ICMPv6 error messages:</dt>
<dd>
<blockquote class="text"><dl>
<dt>Destination Unreachable (Type 1)</dt>
<dd>Set the Type
                field to 3, and adjust the ICMP checksum both to
         	take the type/code change into account and to exclude the ICMPv6
         	pseudo-header. <br />
 Translate the Code field as follows: 

			
<blockquote class="text"><dl>
<dt>Code 0 (no route to destination):</dt>
<dd>Set Code value
                    to 1 (Host unreachable).
</dd>
<dt>Code 1 (Communication with destination administratively prohibited):</dt>
<dd>Set
                    Code value to 10 (Communication with destination host
                    administratively prohibited).
</dd>
<dt>Code 2 (Beyond scope of source address):</dt>
<dd>Set
                    Code value to 1 (Host unreachable). Note that this error is very
                    unlikely since an IPv4-translatable source address is typically
                    considered to have global scope.
</dd>
<dt>Code 3 (Address unreachable):</dt>
<dd>Set Code value to 1
                    (Host unreachable).
</dd>
<dt>Code 4 (Port unreachable):</dt>
<dd>Set Code value to 3
                    (Port unreachable).
</dd>
<dt>Other Code values:</dt>
<dd>
				Silently drop.
			
</dd>
</dl></blockquote>
</dd>
<dt>Packet Too Big (Type 2):</dt>
<dd>Translate to an ICMPv4
                Destination Unreachable (Type 3) with Code value equal to 4,
		and
         adjust the ICMPv4 checksum both to take the type change into
         account and to exclude the ICMPv6 pseudo-header. The MTU field MUST be
                adjusted for the difference between the IPv4 and IPv6 header
                sizes taking into account whether or not the packet in error
                includes a Fragment header, i.e. minimum(advertised MTU-20, MTU_of_IPv4_nexthop, (MTU_of_IPv6_nexthop)-20).
			
</dd>
<dt></dt>
<dd>
		See also the requirements in Section 5.
		
</dd>
<dt>Time Exceeded (Type 3):</dt>
<dd>Set the Type value to 11,
		and
         adjust the ICMPv4 checksum both to take the type change into
         account and to exclude the ICMPv6 pseudo-header.  
			The
                Code field is unchanged.
</dd>
<dt>Parameter Problem (Type 4):</dt>
<dd> Translate the Type and Code field as follows,
		and
         adjust the ICMPv4 checksum both to take the type/code change into
         account and to exclude the ICMPv6 pseudo-header.  

			<br />
 Translate the Code field as
                    follows: 

			
<blockquote class="text"><dl>
<dt>Code 0 (Erroneous header field encountered):</dt>
<dd>
 			Set Type 12, Code 0 and update the pointer as defined in Figure 6 (If the Original 
			IPv6 Pointer Value is not listed or the Translated 
			IPv4 Pointer Value is listed as "n/a", silently drop the packet).
			
</dd>
<dt>Code 1 (Unrecognized Next Header type encountered):</dt>
<dd>
				Translate this to an
         			ICMPv4 protocol unreachable (Type 3, Code 2).  
			
</dd>
<dt>Code 2 (Unrecognized IPv6 option encountered):</dt>
<dd>
 Silently drop. 
			
</dd>
</dl></blockquote>


</dd>
<dt>Unknown error messages:</dt>
<dd>Silently drop.
</dd>
<dt></dt>
<dd>

        <br /><hr class="insert" />
<a name="appendix-462"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

 |   Original IPv6 Pointer Value  | Translated IPv4 Pointer Value  |
 +--------------------------------+--------------------------------+
 |  0  | Version/Traffic Class    |  0  | Version/IHL, Type Of Ser |
 |  1  | Traffic Class/Flow Label |  1  | Type Of Service          |
 | 2,3 | Flow Label               | n/a |                          |
 | 4,5 | Payload Length           |  2  | Total Length             |
 |  6  | Next Header              |  9  | Protocol                 |
 |  7  | Hop Limit                |  8  | Time to Live             |
 | 8-23| Source Address           | 12  | Source Address           |
 |24-39| Destination Address      | 16  | Destination Address      |
 +--------------------------------+--------------------------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Pointer Value for translating from IPv6 to IPv4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



</dd>
<dt>ICMP Error Payload:</dt>
<dd>

If the received ICMPv6 packet contains an ICMPv6 Extension 
<a class='info' href='#RFC4884'>[RFC4884]<span> (</span><span class='info'>Bonica, R., Gan, D., Tappan, D., and C. Pignataro, &ldquo;Extended ICMP to Support Multi-Part Messages,&rdquo; April&nbsp;2007.</span><span>)</span></a>,
the translation of the ICMPv6 packet will cause the ICMPv4 packet 
to change length. When this occurs, the ICMPv6 Extension length 
attribute MUST be adjusted accordingly (e.g., shorter due to the 
translation from IPv6 to IPv4). 
For extensions not defined in 
<a class='info' href='#RFC4884'>[RFC4884]<span> (</span><span class='info'>Bonica, R., Gan, D., Tappan, D., and C. Pignataro, &ldquo;Extended ICMP to Support Multi-Part Messages,&rdquo; April&nbsp;2007.</span><span>)</span></a>,
the translator passes the extensions as opaque bit strings and  
those containing IPv6 address literals will not have those 
addresses translated to IPv4 address literals; this may
cause problems with processing of those ICMP extensions.
			
</dd>
</dl></blockquote>
</dd>
</dl></blockquote>

<a name="section4.3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Translating ICMPv6 Error Messages into ICMPv4</h3>

<p>There are some differences between the ICMPv4 and the ICMPv6 error
        message formats as detailed above. The ICMP error
        messages containing the packet in error MUST
        be translated just like a normal IP packet. The translation of this
        "packet in error" is likely to change the length of the datagram thus
        the Total Length field in the outer IPv4 header MUST be
        updated.
</p><br /><hr class="insert" />
<a name="v6v4icmp"></a>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+-------------+                 +-------------+
|    IPv6     |                 |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   ICMPv6    |                 |   ICMPv4    |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|    IPv6     |      ===&gt;       |    IPv4     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
|   Partial   |                 |   Partial   |
|  Transport  |                 |  Transport  |
|   Layer     |                 |   Layer     |
|   Header    |                 |   Header    |
+-------------+                 +-------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: IPv6-to-IPv4 ICMP Error Translation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   The translation of the inner IP header can be done by invoking 
the function that translated the outer IP headers. 
This process MUST stop at first embedded header and drop the packet 
if it contains more.


   Note that the IPv6 addresses in the IPv6 header may not
   be IPv4-translatable addresses and there will be no corresponding
   IPv4 addresses.  
   In this case, the translator can do stateful translation.
   A mechanism by which the translator can instead do 
   stateless translation is left for future work.


</p>
<a name="sending-icmp2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Generation of ICMPv6 Error Message</h3>

<p>
		If the IPv6 packet is discarded, then the translator SHOULD send back an ICMPv6 error message to the original sender of the packet, 
		unless the discarded packet is itself an ICMPv6 message. 
	
</p>
<p>If the ICMPv6 error message is being sent because the IPv6 source
       address is not an IPv4-translatable address and the translator is stateless, the ICMPv6
   	message, if sent, MUST have a Type value of 1 and Code value of 5 (Source 
	address failed ingress/egress policy). In other cases, 
		the ICMPv6 message MUST have a Type value of 1 (Destination Unreachable) and a Code value of 1 (Communication with destination administratively prohibited),
		 unless otherwise specified in this document or
		<a class='info' href='#I-D.ietf-behave-v6v4-xlate-stateful'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate&#8209;stateful]<span> (</span><span class='info'>Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
		The translator SHOULD allow an administrator to configure whether the ICMPv6 error messages are sent, rate-limited, or not sent. 
	
</p>
<a name="transport2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Transport-layer Header Translation</h3>

<p>
   If the address translation algorithm is not checksum neutral
   (Section 3 of 
	<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>),
   the
   recalculation and updating of the transport-layer headers which
   contain pseudo headers need to be performed.  Translators MUST do this for TCP 
   and ICMP.  

</p>
<p>
  For UDP, if an IPv6 UDP packet arrives with a 0 checksum, a UDP
   checksum SHOULD NOT be generated for that IPv4 packet.  Otherwise, 
 the translator SHOULD recalculate and update the transport-layer checksum.
 The translator MAY have a configuration option permitting it to zero 
 the UDP checksum in some or all traffic.

</p>
<p>
   Other transport protocols (e.g., DCCP) are OPTIONAL to support.
   In order to ease debugging and troubleshooting, translators MUST 
   forward all transport protocols as described in the "Protocol" step
   of Section 4.1.

</p>
<a name="section4.4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
Knowing When to Translate</h3>

<p>
  If the IP/ICMP translator also provides a normal forwarding function, 
and the destination address is reachable by a
   more specific route without translation, the router MUST forward it
   without translating it.  When an IP/ICMP translator receives an IPv6
   datagram addressed to an IPv6 address representing a host in the IPv4 domain, the
   IPv6 packet MUST be translated to IPv4.


</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Special Considerations for ICMPv6 Packet Too Big</h3>

<p>
 Two recent studies analyzed the behavior of IPv6-capable web
   servers on the Internet and found that approximately 95% responded
   as expected to an IPv6 Packet Too Big that indicated MTU=1280, but
   only 43% responded as expected to an IPv6 Packet Too Big that
   indicated an MTU < 1280.  It is believed firewalls violating Section
   4.3.1 of <a class='info' href='#RFC4890'>[RFC4890]<span> (</span><span class='info'>Davies, E. and J. Mohacsi, &ldquo;Recommendations for Filtering ICMPv6 Messages in Firewalls,&rdquo; May&nbsp;2007.</span><span>)</span></a>
    are at fault.  These failures will both cause 
   Path MTU Discovery (PMTUD) black holes 
   <a class='info' href='#RFC2923'>[RFC2923]<span> (</span><span class='info'>Lahey, K., &ldquo;TCP Problems with Path MTU Discovery,&rdquo; September&nbsp;2000.</span><span>)</span></a>.
   Unfortunately the 
   translator cannot improve the failure rate of the first case (MTU = 1280), 
   but the translator can improve the failure rate of the second case 
   (MTU < 1280).  There are two approaches to resolving the problem with
   sending ICMPv6 messages indicating an MTU < 1280.  It SHOULD 
   be possible to configure a translator for either of the two 
   approaches.

</p>
<p>
  The first approach is to constrain the deployment of the IPv6/IPv4
   translator by observing that four of the scenarios intended for
   stateless IPv6/IPv4 translators do not have IPv6 hosts on the
   Internet (Scenarios 1, 2, 5 and 6 described in
   <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; August&nbsp;2010.</span><span>)</span></a>,
	which refer to "An IPv6
   network"). In these scenarios IPv6 hosts, IPv6 host-based
   firewalls, and IPv6 network firewalls can be administered in
   compliance with Section 4.3.1 of 
   <a class='info' href='#RFC4890'>[RFC4890]<span> (</span><span class='info'>Davies, E. and J. Mohacsi, &ldquo;Recommendations for Filtering ICMPv6 Messages in Firewalls,&rdquo; May&nbsp;2007.</span><span>)</span></a>
   and therefore avoid the
   problem witnessed with IPv6 hosts on the Internet.

</p>
<p>
   The second approach is necessary if the translator has IPv6 hosts,
   IPv6 host-based firewalls, or IPv6 network firewalls that do not
   (or cannot) comply with Section 5 of 
   <a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a>
   -- such as IPv6
   hosts on the Internet. This approach requires the translator to
   do the following:

</p>
<ol class="text">
<li>
    	 in the IPv4 to IPv6 direction:  if the MTU value of
        ICMPv4 Packet Too Big messages is less than 1280, change it
        to 1280.  This is intended to cause the IPv6 host and IPv6
        firewall to process the ICMP PTB message and generate 
        subsequent packets to this destination with an IPv6 
        fragmentation header.

        <br />
<br />
 
        Note:  Based on recent studies, this is effective for 
        95% of IPv6 hosts on the Internet.
	 <br />
<br />
 

</li>
<li>
in the IPv6 to IPv4 direction: 

<blockquote class="text"><dl>
<dt>A.</dt>
<dd>
           if there is a Fragment header in the IPv6 packet,
           the last 16 bits of its value MUST be used for the 
           IPv4 identification value.

</dd>
<dt>B.</dt>
<dd>
	    if there is no Fragment header in the IPv6 packet:

<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
if the packet is less than or equal to 1280 bytes:

<ul class="text">
<li>
the translator SHOULD set DF to 0 and generate 
                an IPv4 identification value.

</li>
<li>
To avoid the problems described in [RFC4963], it 
                is RECOMMENDED the translator maintain 3-tuple 
                state for generating the IPv4 identification value.

</li>
</ul>

</dd>
<dt>b.</dt>
<dd>
if the packet is greater than 1280 bytes, the 
translator SHOULD set the IPv4 DF bit to 1.

</dd>
</dl></blockquote>

</dd>
</dl></blockquote>

</li>
</ol><p>

</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This memo adds no new IANA considerations.
</p>
<p>Note to RFC Editor: This section will have served its purpose if it
      correctly tells IANA that no new assignments or registries are required,
      or if those assignments or registries are created during the RFC
      publication process. From the author's perspective, it may therefore be
      removed upon publication as an RFC at the RFC Editor's discretion.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>The use of stateless IP/ICMP translators does not introduce any new
      security issues beyond the security issues that are already present in
      the IPv4 and IPv6 protocols and in the routing protocols that are used
      to make the packets reach the translator.
</p>
<p>
There are potential issues that might arise by deriving an IPv4 address from 
an IPv6 address - particularly addresses like broadcast or loopback addresses 
and the non IPv4-translatable IPv6 addresses, etc. The 
<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a> 
addresses these issues.
	
</p>
<p>
   As with network address translation of IPv4 to IPv4, the IPsec
   Authentication Header 
   <a class='info' href='#RFC4302'>[RFC4302]<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a>
   cannot be used across an IPv6
   to IPv4 translator.

</p>
<p>
   As with network address translation of IPv4 to IPv4, packets with 
   tunnel mode ESP can be translated since tunnel mode ESP does not 
   depend on header fields prior to the ESP header.  Similarly,
   transport mode ESP will fail with IPv6 to IPv4 translation 
   unless checksum neutral addresses are used.  In both cases, 
   the IPsec ESP endpoints will normally detect the presence of
   the translator and encapsulate ESP in UDP packets 
   <a class='info' href='#RFC3948'>[RFC3948]<span> (</span><span class='info'>Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;UDP Encapsulation of IPsec ESP Packets,&rdquo; January&nbsp;2005.</span><span>)</span></a>.

</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>This is under development by a large group of people. Those who have
      posted to the list during the discussion include Alexey Melnikov, Andrew Sullivan, Andrew
      Yourtchenko, Brian Carpenter, Dan Wing, Dave Thaler, David Harrington, Ed Jankiewicz, 
      Hiroshi Miyata, Iljitsch van Beijnum, Jari Arkko, Jerry Huang, 
      John Schnizlein, Jouni Korhonen, Kentaro Ebisawa, 
      Kevin Yin, Magnus Westerlund, Marcelo Bagnulo Braun, Margaret Wasserman, Masahito Endo,
      Phil Roberts, Philip Matthews, Reinaldo Penno, Remi Denis-Courmont, Remi Despres, 
	Sean Turner, Senthil Sivakumar, 
	Simon Perreault, Stewart Bryant, Tim Polk, Tero Kivinen and 
      Zen Cao.
</p>
<a name="Appendix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Appendix: Stateless translation workflow example</h3>

<p>

   A stateless translation workflow example is depicted in the following figure. The
documentation address blocks 2001:db8::/32 
<a class='info' href='#RFC3849'>[RFC3849]<span> (</span><span class='info'>Huston, G., Lord, A., and P. Smith, &ldquo;IPv6 Address Prefix Reserved for Documentation,&rdquo; July&nbsp;2004.</span><span>)</span></a>,
192.0.2.0/24 and 198.51.100.0/24 
<a class='info' href='#RFC5737'>[RFC5737]<span> (</span><span class='info'>Arkko, J., Cotton, M., and L. Vegoda, &ldquo;IPv4 Address Blocks Reserved for Documentation,&rdquo; January&nbsp;2010.</span><span>)</span></a>
are used in this example.


        <br /><hr class="insert" />
<a name="work-flow-example"></a>
</p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>

+--------------+                   +--------------+
| IPv4 network |                   | IPv6 network |
|              |     +-------+     |              |
|   +----+     |-----| XLAT  |---- |  +----+      |
|   | H4 |-----|     +-------+     |--| H6 |      |
|   +----+     |                   |  +----+      |
+--------------+                   +--------------+

</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8&nbsp;</b></font><br /></td></tr></table><hr class="insert" />


</p>
<p>
A translator (XLAT) connects the IPv6 network to the IPv4 network. 
This XLAT uses the Network Specific Prefix (NSP) 2001:db8:100::/40 
defined in
<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a> 
to represent IPv4 addresses 
in the IPv6 address space (IPv4-converted addresses) and to represent 
IPv6 addresses (IPv4-translatable addresses) in the IPv4 address space. 
In this example, 192.0.2.0/24 is the IPv4 block of the corresponding IPv4-translatable 
addresses.

</p>
<p>
Based on the address mapping rule, the IPv6 node H6 has an 
IPv4-translatable IPv6 address 2001:db8:1c0:2:21:: 
(address mapping from 192.0.2.33).  The IPv4 node H4 has 
IPv4 address 198.51.100.2.

</p>
<p>
The IPv6 routing is configured in such a way that the 
IPv6 packets addressed to a destination address in 
2001:db8:100::/40 are routed to the IPv6 interface of the XLAT. 

</p>
<p>
The IPv4 routing is configured in such a way that the 
IPv4 packets addressed to a destination address in 
192.0.2.0/24 are routed to the IPv4 interface of the XLAT. 

</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
H6 establishes communication with H4</h3>

<p>
The steps by which H6 establishes communication with H4 are:

</p>
<ol class="text">
<li>
H6 performs the destination address mapping, so the IPv4-converted 
address 2001:db8:1c6:3364:200:: is formed from 198.51.100.2 based on 
the address mapping algorithm 
<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>.

</li>
<li>
H6 sends a packet to H4. The packet is sent from a source address 
2001:db8:1c0:2:21:: to a destination address 2001:db8:1c6:3364:200::.

</li>
<li>
The packet is routed to the IPv6 interface of the XLAT 
(since IPv6 routing is configured that way).

</li>
<li>
The XLAT receives the packet and performs the following actions:

<ul class="text">
<li>
The XLAT translates the IPv6 header into an IPv4 header using 
the IP/ICMP Translation Algorithm defined in this document.

</li>
<li>
The XLAT includes 192.0.2.33 as source address in the packet 
and 198.51.100.2 as destination address in the packet.  
Note that 192.0.2.33 and 198.51.100.2 are extracted directly from 
the source IPv6 address 2001:db8:1c0:2:21:: (IPv4-translatable address) 
and destination IPv6 address 2001:db8:1c6:3364:200::
(IPv4-converted address) of the received IPv6 packet that is 
being translated.  

</li>
</ul>

</li>
<li>
The XLAT sends the translated packet out its IPv4 interface 
and the packet arrives at H4.

</li>
<li>
H4 node responds by sending a packet with destination 
address 192.0.2.33 and source address 198.51.100.2.

</li>
<li>
The packet is routed to the IPv4 interface of the XLAT 
(since IPv4 routing is configured that way). The XLAT 
performs the following operations:

<ul class="text">
<li>
The XLAT translates the IPv4 header into an IPv6 header 
using the IP/ICMP Translation Algorithm defined in this 
document.

</li>
<li>
The XLAT includes 2001:db8:1c0:2:21:: as destination 
address in the packet and 2001:db8:1c6:3364:200::
as source address in the packet.  Note that 2001:db8:1c0:2:21:: 
and 2001:db8:1c6:3364:200:: are formed directly from the destination 
IPv4 address 192.0.2.33 and source IPv4 address 198.51.100.2 of 
the received IPv4 packet that is being translated.

</li>
</ul>

</li>
<li>
The translated packet is sent out the IPv6 interface to H6.

</li>
</ol><p>


</p>
<p>
The packet exchange between H6 and H4 continues until 
the session is finished.

</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
H4 establishes communication with H6</h3>

<p>
The steps by which H4 establishes communication with H6 are:
</p>
<ol class="text">
<li>
H4 performs the destination address mapping, 
so 192.0.2.33 is formed from IPv4-translatable address 
2001:db8:1c0:2:21:: based on the address mapping algorithm <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; August&nbsp;2010.</span><span>)</span></a>.

</li>
<li>
H4 sends a packet to H6. The packet is sent from a source 
address 198.51.100.2 to a destination address 192.0.2.33.

</li>
<li>
The packet is routed to the IPv4 interface of the XLAT 
(since IPv4 routing is configured that way).

</li>
<li>
The XLAT receives the packet and performs the following actions:

<ul class="text">
<li>
The XLAT translates the IPv4 header into an IPv6 header using 
the IP/ICMP Translation Algorithm defined in this document.

</li>
<li>
The XLAT includes 2001:db8:1c6:3364:200:: as source address 
in the packet and 2001:db8:1c0:2:21:: as destination address 
in the packet.  Note that 2001:db8:1c6:3364:200:: 
(IPv4-converted address) and 2001:db8:1c0:2:21:: 
(IPv4-translatable address) are obtained directly from 
the source IPv4 address 198.51.100.2 and destination IPv4 
address 192.0.2.33 of the received IPv4 packet that 
is being translated.  

</li>
</ul>

</li>
<li>
The XLAT sends the translated packet out its IPv6 interface 
and the packet arrives at H6.

</li>
<li>
H6 node responds by sending a packet with destination 
address 2001:db8:1c6:3364:200:: and source 
address 2001:db8:1c0:2:21::.

</li>
<li>
The packet is routed to the IPv6 interface of the 
XLAT (since IPv6 routing is configured that way). 
The XLAT performs the following operations:

<ul class="text">
<li>
The XLAT translates the IPv6 header into an IPv4 
header using the IP/ICMP Translation Algorithm 
defined in this document.

</li>
<li>
The XLAT includes 198.51.100.2 as destination address in the packet 
and 192.0.2.33   as source address in the packet.  
Note that 198.51.100.2 and 192.0.2.33 are formed directly from 
the destination IPv6 address 2001:db8:1c6:3364:200:: and 
source IPv6 address 2001:db8:1c0:2:21:: of the received 
IPv6 packet that is being translated. 

</li>
</ul>

</li>
<li>
The translated packet is sent out the IPv4 interface to H4.

</li>
</ol><p>

</p>
<p>
The packet exchange between H4 and H6 continues until the session finished.

</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-address-format">[I-D.ietf-behave-address-format]</a></td>
<td class="author-text">Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-address-format-10.txt">IPv6 Addressing of IPv4/IPv6 Translators</a>,&rdquo; draft-ietf-behave-address-format-10 (work in progress), August&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-address-format-10.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-v6v4-xlate-stateful">[I-D.ietf-behave-v6v4-xlate-stateful]</a></td>
<td class="author-text">Bagnulo, M., Matthews, P., and I. Beijnum, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-xlate-stateful-12.txt">Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers</a>,&rdquo; draft-ietf-behave-v6v4-xlate-stateful-12 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-xlate-stateful-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0768">[RFC0768]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>,&rdquo; STD&nbsp;6, RFC&nbsp;768, August&nbsp;1980 (<a href="http://www.rfc-editor.org/rfc/rfc768.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0791">[RFC0791]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;791, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc791.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0792">[RFC0792]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc792">Internet Control Message Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;792, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc792.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1812">[RFC1812]</a></td>
<td class="author-text"><a href="mailto:fred@cisco.com">Baker, F.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1812">Requirements for IP Version 4 Routers</a>,&rdquo; RFC&nbsp;1812, June&nbsp;1995 (<a href="http://www.rfc-editor.org/rfc/rfc1812.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1883">[RFC1883]</a></td>
<td class="author-text"><a href="mailto:deering@parc.xerox.com">Deering, S.</a> and <a href="mailto:hinden@ipsilon.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1883">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;1883, December&nbsp;1995 (<a href="http://www.rfc-editor.org/rfc/rfc1883.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2765">[RFC2765]</a></td>
<td class="author-text"><a href="mailto:nordmark@sun.com">Nordmark, E.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2765">Stateless IP/ICMP Translation Algorithm (SIIT)</a>,&rdquo; RFC&nbsp;2765, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2765.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3948">[RFC3948]</a></td>
<td class="author-text">Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;<a href="http://tools.ietf.org/html/rfc3948">UDP Encapsulation of IPsec ESP Packets</a>,&rdquo; RFC&nbsp;3948, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3948.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4291">[RFC4291]</a></td>
<td class="author-text">Hinden, R. and S. Deering, &ldquo;<a href="http://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>,&rdquo; RFC&nbsp;4291, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4291.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4340">[RFC4340]</a></td>
<td class="author-text">Kohler, E., Handley, M., and S. Floyd, &ldquo;<a href="http://tools.ietf.org/html/rfc4340">Datagram Congestion Control Protocol (DCCP)</a>,&rdquo; RFC&nbsp;4340, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4340.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4443">[RFC4443]</a></td>
<td class="author-text">Conta, A., Deering, S., and M. Gupta, &ldquo;<a href="http://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;4443, March&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4443.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4884">[RFC4884]</a></td>
<td class="author-text">Bonica, R., Gan, D., Tappan, D., and C. Pignataro, &ldquo;<a href="http://tools.ietf.org/html/rfc4884">Extended ICMP to Support Multi-Part Messages</a>,&rdquo; RFC&nbsp;4884, April&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4884.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5382">[RFC5382]</a></td>
<td class="author-text">Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;<a href="http://tools.ietf.org/html/rfc5382">NAT Behavioral Requirements for TCP</a>,&rdquo; BCP&nbsp;142, RFC&nbsp;5382, October&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5382.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5771">[RFC5771]</a></td>
<td class="author-text">Cotton, M., Vegoda, L., and D. Meyer, &ldquo;<a href="http://tools.ietf.org/html/rfc5771">IANA Guidelines for IPv4 Multicast Address Assignments</a>,&rdquo; BCP&nbsp;51, RFC&nbsp;5771, March&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5771.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-v6v4-framework">[I-D.ietf-behave-v6v4-framework]</a></td>
<td class="author-text">Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-framework-10.txt">Framework for IPv4/IPv6 Translation</a>,&rdquo; draft-ietf-behave-v6v4-framework-10 (work in progress), August&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-framework-10.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0879">[RFC0879]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc879">TCP maximum segment size and related topics</a>,&rdquo; RFC&nbsp;879, November&nbsp;1983 (<a href="http://www.rfc-editor.org/rfc/rfc879.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1191">[RFC1191]</a></td>
<td class="author-text"><a href="mailto:mogul@decwrl.dec.com">Mogul, J.</a> and <a href="mailto:deering@xerox.com">S. Deering</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>,&rdquo; RFC&nbsp;1191, November&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1191.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2474">[RFC2474]</a></td>
<td class="author-text"><a href="mailto:kmn@cisco.com">Nichols, K.</a>, <a href="mailto:slblake@torrentnet.com">Blake, S.</a>, <a href="mailto:fred@cisco.com">Baker, F.</a>, and <a href="mailto:black_david@emc.com">D. Black</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2474">Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</a>,&rdquo; RFC&nbsp;2474, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2474.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2474.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2474.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2475">[RFC2475]</a></td>
<td class="author-text"><a href="mailto:slblake@torrentnet.com">Blake, S.</a>, <a href="mailto:black_david@emc.com">Black, D.</a>, <a href="mailto:mark.carlson@sun.com">Carlson, M.</a>, <a href="mailto:elwynd@nortel.co.uk">Davies, E.</a>, <a href="mailto:zhwang@bell-labs.com">Wang, Z.</a>, and <a href="mailto:wweiss@lucent.com">W. Weiss</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2475">An Architecture for Differentiated Services</a>,&rdquo; RFC&nbsp;2475, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2475.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2475.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2475.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2710">[RFC2710]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a>, <a href="mailto:fenner@research.att.com">Fenner, W.</a>, and <a href="mailto:haberman@raleigh.ibm.com">B. Haberman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2710">Multicast Listener Discovery (MLD) for IPv6</a>,&rdquo; RFC&nbsp;2710, October&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2710.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2766">[RFC2766]</a></td>
<td class="author-text"><a href="mailto:george.tsirtsis@bt.com">Tsirtsis, G.</a> and <a href="mailto:srisuresh@yahoo.com">P. Srisuresh</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2766">Network Address Translation - Protocol Translation (NAT-PT)</a>,&rdquo; RFC&nbsp;2766, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2766.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2923">[RFC2923]</a></td>
<td class="author-text">Lahey, K., &ldquo;<a href="http://tools.ietf.org/html/rfc2923">TCP Problems with Path MTU Discovery</a>,&rdquo; RFC&nbsp;2923, September&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2923.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3307">[RFC3307]</a></td>
<td class="author-text">Haberman, B., &ldquo;<a href="http://tools.ietf.org/html/rfc3307">Allocation Guidelines for IPv6 Multicast Addresses</a>,&rdquo; RFC&nbsp;3307, August&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3307.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3590">[RFC3590]</a></td>
<td class="author-text">Haberman, B., &ldquo;<a href="http://tools.ietf.org/html/rfc3590">Source Address Selection for the Multicast Listener Discovery (MLD) Protocol</a>,&rdquo; RFC&nbsp;3590, September&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3590.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3810">[RFC3810]</a></td>
<td class="author-text">Vida, R. and L. Costa, &ldquo;<a href="http://tools.ietf.org/html/rfc3810">Multicast Listener Discovery Version 2 (MLDv2) for IPv6</a>,&rdquo; RFC&nbsp;3810, June&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3810.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3849">[RFC3849]</a></td>
<td class="author-text">Huston, G., Lord, A., and P. Smith, &ldquo;<a href="http://tools.ietf.org/html/rfc3849">IPv6 Address Prefix Reserved for Documentation</a>,&rdquo; RFC&nbsp;3849, July&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3849.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4890">[RFC4890]</a></td>
<td class="author-text">Davies, E. and J. Mohacsi, &ldquo;<a href="http://tools.ietf.org/html/rfc4890">Recommendations for Filtering ICMPv6 Messages in Firewalls</a>,&rdquo; RFC&nbsp;4890, May&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4890.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4963">[RFC4963]</a></td>
<td class="author-text">Heffner, J., Mathis, M., and B. Chandler, &ldquo;<a href="http://tools.ietf.org/html/rfc4963">IPv4 Reassembly Errors at High Data Rates</a>,&rdquo; RFC&nbsp;4963, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4963.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5737">[RFC5737]</a></td>
<td class="author-text">Arkko, J., Cotton, M., and L. Vegoda, &ldquo;<a href="http://tools.ietf.org/html/rfc5737">IPv4 Address Blocks Reserved for Documentation</a>,&rdquo; RFC&nbsp;5737, January&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5737.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Xing Li</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">CERNET Center/Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Room 225, Main Building, Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Beijing,   100084</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">China</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+86 10-62785983</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:xing@cernet.edu.cn">xing@cernet.edu.cn</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Congxiao Bao</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">CERNET Center/Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Room 225, Main Building, Tsinghua University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Beijing,   100084</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">China</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+86 10-62785983</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:congxiao@cernet.edu.cn">congxiao@cernet.edu.cn</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Fred Baker</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Santa Barbara, California  93117</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-408-526-4257</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:fred@cisco.com">fred@cisco.com</a></td></tr>
</table>
</body></html>
