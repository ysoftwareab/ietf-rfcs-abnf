<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Using GSS-API Mechanisms in SASL:
The GS2 Mechanism Family</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Using GSS-API Mechanisms in SASL:
The GS2 Mechanism Family">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">S. Josefsson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">October 09, 2007</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">&nbsp;</td></tr>
<tr><td class="header">Expires: April 11, 2008</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Using GSS-API Mechanisms in SASL:
The GS2 Mechanism Family<br />draft-ietf-sasl-gs2-09</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on April 11, 2008.</p>

<h3>Abstract</h3>

<p>This document describes how to use a Generic Security Service
    Application Program Interface (GSS-API) mechanism in the the
    Simple Authentication and Security Layer (SASL) framework.  This
    is done by defining a new SASL mechanism family, called GS2.  This
    mechanism family offers a number of improvements over the previous
    SASL/GSS-API mechanism: it is more general, uses fewer messages
    for the authentication phase in some cases, and supports a
    SASL-specific notion of channel binding.
</p>
<p>See &lt;http://josefsson.org/sasl-gs2-*/&gt; for more
    information.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Conventions used in this document<br />
<a href="#anchor3">3.</a>&nbsp;
Mechanism name<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Generating SASL mechanism names from GSS-API OIDs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Computing mechanism names manually<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.3.</a>&nbsp;
Examples<br />
<a href="#anchor7">4.</a>&nbsp;
SASL Authentication Exchange Message Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">4.1.</a>&nbsp;
SASL Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">4.2.</a>&nbsp;
Context Token Field<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.2.1.</a>&nbsp;
Client side<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.2.2.</a>&nbsp;
Server side<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.3.</a>&nbsp;
Wrap Token Field<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.3.1.</a>&nbsp;
The GS2_Wrap function<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.3.2.</a>&nbsp;
Client first GS2_Wrap input<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.3.3.</a>&nbsp;
Server last GS2_Wrap input<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.3.4.</a>&nbsp;
Server first GS2_Wrap input<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.3.5.</a>&nbsp;
Client last GS2_Wrap input<br />
<a href="#anchor18">5.</a>&nbsp;
Channel Bindings<br />
<a href="#anchor19">6.</a>&nbsp;
Protocol Overview<br />
<a href="#anchor20">7.</a>&nbsp;
Authentication Conditions<br />
<a href="#anchor21">8.</a>&nbsp;
GSS-API Parameters<br />
<a href="#anchor22">9.</a>&nbsp;
Security Layer Bits<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">9.1.</a>&nbsp;
Examples<br />
<a href="#anchor24">10.</a>&nbsp;
Non-integrity capable GSS-API mechanisms<br />
<a href="#anchor25">11.</a>&nbsp;
Interoperability with the SASL "GSSAPI" mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">11.1.</a>&nbsp;
The interoperability problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">11.2.</a>&nbsp;
Resolving the problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">11.3.</a>&nbsp;
Additional recommendations<br />
<a href="#anchor29">12.</a>&nbsp;
Mechanisms that negotiate other mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">12.1.</a>&nbsp;
The interoperability problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">12.2.</a>&nbsp;
Security problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">12.3.</a>&nbsp;
Resolving the problems<br />
<a href="#anchor33">13.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor34">14.</a>&nbsp;
Security Considerations<br />
<a href="#anchor35">15.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">16.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">16.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">16.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p><a class='info' href='#RFC2743'>Generic Security Service Application
      Program Interface (GSS-API)<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> [RFC2743] is a framework that provide
    security services to
    applications.  <a class='info' href='#RFC4422'>Simple Authentication and
      Security Layer (SASL)<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a> [RFC4422] is a framework to provide
    authentication and security layers for connection based
    protocols.  This document describe how to use a GSS-API
    mechanism in a connection-based protocol using the SASL
    framework.
</p>
<p>All GSSAPI mechanisms are implicitly registered for use within
    SASL by this specification.  The SASL mechanism defined in this
    document is known as the GS2 family.
</p>
<p>The <a class='info' href='#RFC1964'>"Kerberos V5 GSS-API mechanism"<span> (</span><span class='info'>Linn, J., &ldquo;The Kerberos Version 5 GSS-API Mechanism,&rdquo; June&nbsp;1996.</span><span>)</span></a> [RFC1964]
    is also supported in SASL through <a class='info' href='#RFC4752'>"SASL
    GSSAPI mechanisms"<span> (</span><span class='info'>Melnikov, A., &ldquo;The Kerberos V5 (&quot;GSSAPI&quot;) Simple Authentication and Security Layer (SASL) Mechanism,&rdquo; November&nbsp;2006.</span><span>)</span></a> [RFC4752].  The difference between that protocol
    and the one described here, is that this protocol offer more
    features (i.e., channel bindings and round-trip optimizations)
    while the other protocol is more widely deployed.  There are
    interoperability concerns by having the same GSS-API mechanism
    available under more than one SASL mechanism name, see the section
    "Interoperability with the GSSAPI mechanism" below.
</p>
<p>There are interoperability and security concerns if this SASL
    mechanism is used together with a GSS-API mechanism that negotiate
    other GSS-API mechanisms (such
    as <a class='info' href='#RFC4178'>SPNEGO<span> (</span><span class='info'>Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism,&rdquo; October&nbsp;2005.</span><span>)</span></a> [RFC4178]), see the section
    "Mechanisms that negotiate other mechanisms" below.
</p>
<p>There are interoperability and security concerns with GSSAPI
    mechanism that do not provide integrity, see the section
    "Non-integrity capable GSS-API mechanisms" below.
</p>
<p>SASL mechanism names starting with "GS2-" are reserved for SASL
    mechanisms which conform to this document.
</p>
<p>The IESG is considered to be the owner of all SASL mechanisms
    which conform to this document.  This does not necessarily imply
    that the IESG is considered to be the owner of the underlying
    GSSAPI mechanism.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conventions used in this document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
    in this document are to be interpreted as described in
    <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Mechanism name</h3>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Generating SASL mechanism names from GSS-API OIDs</h3>

<p>The SASL mechanism name for a GSS-API mechanism is the
    concatenation of the string "GS2-" and
    the <a class='info' href='#RFC4648'>Base32 encoding<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648] (with an upper
    case alphabet) of the first ten bytes of the
    binary <a class='info' href='#FIPS.180-1.1995'>SHA-1 hash<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;Secure Hash Standard,&rdquo; April&nbsp;1995.</span><span>)</span></a> [FIPS.180&#8209;1.1995] string computed
    over the <a class='info' href='#ITU.X690.1994'>ASN.1 DER encoding<span> (</span><span class='info'>International Telecommunications Union, &ldquo;Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER),&rdquo; 1994.</span><span>)</span></a> [ITU.X690.1994],
    including the tag and length octets, of the GSS-API mechanism's
    Object Identifier.  The Base32 rules on padding characters and
    characters outside of the base32 alphabet are not relevant to this
    use of Base32.  If any padding or non-alphabet characters are
    encountered, the name is not a GS2 family mechanism name.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Computing mechanism names manually</h3>

<p>The SASL mechanism name may be computed manually.  This is useful
    when the set of supported GSS-API mechanisms is known in advance.
    It also obliterate the need to implement Base32, SHA-1 and DER in
    the SASL mechanism.  The computed mechanism name can be used
    directly in the implementation, and the implementation need not
    concern itself with that the mechanism is part of a mechanism
    family.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Examples</h3>

<p>The OID for the <a class='info' href='#RFC2025'>SPKM-1 mechanism<span> (</span><span class='info'>Adams, C., &ldquo;The Simple Public-Key GSS-API Mechanism (SPKM),&rdquo; October&nbsp;1996.</span><span>)</span></a> [RFC2025] is
    1.3.6.1.5.5.1.1.  The ASN.1 DER encoding of the OID, including the
    tag and length, is (in hex) 06 07 2b 06 01 05 05 01 01.  The SHA-1
    hash of the ASN.1 DER encoding is (in hex) 1c f8 f4 2b 5a 9f 80 fa
    e9 f8 31 22 6d 5d 9d 56 27 86 61 ad.  Convert the first ten octets
    to binary, and re-group them in groups of 5, and convert them back
    to decimal, which results in these computations:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
hex:
1c f8 f4 2b 5a 9f 80 fa e9 f8

binary:
00011100 11111000 11110100 00101011 01011010
10011111 10000000 11111010 11101001 11111000

binary in groups of 5:
00011 10011 11100 01111 01000 01010 11010 11010
10011 11110 00000 01111 10101 11010 01111 11000

decimal of each group:
3 19 28 15 8 10 26 26 19 30 0 15 21 26 15 24

base32 encoding:
D T 4 P I K 2 2 T 6 A P V 2 P Y
</pre></div>
<p>The last step translate each decimal value using table 3
      in <a class='info' href='#RFC4648'>Base32<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648].  Thus the SASL
      mechanism name for the SPKM-1 GSSAPI mechanism is
      "GS2-DT4PIK22T6APV2PY".
</p>
<p>The OID for the <a class='info' href='#RFC1964'>Kerberos V5 GSS-API
	mechanism<span> (</span><span class='info'>Linn, J., &ldquo;The Kerberos Version 5 GSS-API Mechanism,&rdquo; June&nbsp;1996.</span><span>)</span></a> [RFC1964] is 1.2.840.113554.1.2.2 and its DER encoding
	is (in hex) 06 09 2A 86 48 86 F7 12 01 02 02.  The SHA-1 hash
	is 82 d2 73 25 76 6b d6 c8 45 aa 93 25 51 6a fc ff 04 b0 43
	60.  Convert the first ten octets to binary, and re-group them
	in groups of 5, and convert them back to decimal, which
	results in these computations:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
hex:
82 d2 73 25 76 6b d6 c8 45 aa

binary:
10000010 11010010 01110011 00100101 01110110
01101011 11010110 11001000 01000101 10101010

binary in groups of 5:
10000 01011 01001 00111 00110 01001 01011 10110
01101 01111 01011 01100 10000 10001 01101 01010

decimal of each group:
16 11 9 7 6 9 11 22 13 15 11 12 16 17 13 10

base32 encoding:
Q L J H G J L W N P L M Q R N K
</pre></div>
<p>The last step translate each decimal value using table 3
      in <a class='info' href='#RFC4648'>Base32<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648].  Thus the SASL
      mechanism name for the Kerberos V5 GSSAPI mechanism is
      "GS2-QLJHGJLWNPLMQRNK".
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
SASL Authentication Exchange Message Format</h3>

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
SASL Messages</h3>

<p>During the SASL authentication exchange for GS2, a number of
      messages following the following format is sent between the
      client and server.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Context length                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Wrap token length                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               /
   /                        [Context token]                        /
   /                                           --------------------/
   /                     ---------------------/                    /
   /--------------------/                                          /
   /                          [Wrap token]                         /
   /                                                               /
   /                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The "Context length" and "Wrap token length" fields each
      contain a 4 octet (32 bit) integer encoded in network byte
      order, that indicate the length of the "Context token" and "Wrap
      token" fields, respectively.  A length of 0 means that a
      particular field is not present.
</p>
<p>The "Context token" field, if present, contain a GSS-API
      context establishment token generated by GSS_Init_sec_context or
      GSS_Accept_sec_context.
</p>
<p>The "Wrap token" field, if present, contain the output
      generated by the GS2_Wrap function.
</p>
<p>The fields need not be aligned to 32-bit a boundary.  There is
      no padding between fields.
</p>
<p>Messages shorter than or equal to 8 octets are invalid.  (The
      only exception is the initial empty challenge sent by the server
      which may be 0 octets.)  From that it follows that at least one
      of the "Context token length" and the "Wrap token length"
      integers MUST be non-zero in a particular message.  If the sum
      of the length integers is longer than the entire message size,
      minus 8 octets for the length fields, the message is
      invalid.
</p>
<p>During any successful authentication exchange, the client and
      server will each send exactly one (non-empty) "Wrap token".
</p>
<p>Conforming implementations MUST NOT send additional data after
      the above message syntax, and MUST ignore additional data.  To
      illustrate, implementations MUST NOT assume that the last "Wrap
      token length" octets of the packet correspond to the "Wrap
      token", because that would be incorrect if the packet contained
      additional data not described by this document.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Context Token Field</h3>

<p>The format of the "Context token" field inside the SASL token
	is defined by each GSS-API mechanism, and the data is computed
	by (for the client) GSS_Init_sec_context and (for the server)
	GSS_Accept_sec_context.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Client side</h3>

<p>The client calls GSS_Init_sec_context, passing in
	input_context_handle of GSS_C_NO_CONTEXT (initially),
	mech_type of the GSSAPI mechanism for which this SASL
	mechanism is registered, the chan_binding is set to NULL, and
	targ_name equal to output_name from GSS_Import_Name called
	with input_name_type of GSS_C_NT_HOSTBASED_SERVICE (*) and
	input_name_string of "service@hostname" where "service" is the
	service name specified in the protocol's profile, and
	"hostname" is the fully qualified host name of the server.
</p>
<p>(*) - Clients MAY use name types other than
	GSS_C_NT_HOSTBASED_SERVICE to import servers' acceptor names,
	but only when they have a priori knowledge that the servers
	support alternate name types.  Otherwise clients MUST use
	GSS_C_NT_HOSTBASED_SERVICE for importing acceptor names.
</p>
<p>When calling the GSS_Init_sec_context the client SHOULD pass
	the integ_req_flag of TRUE, but MAY set it to FALSE (see
	section 10 below).  If the client intends to request a
	security layer, it MUST also supply to the
	GSS_Init_sec_context a mutual_req_flag of TRUE, and a
	sequence_req_flag of TRUE.  If the client will be requesting a
	security layer providing confidentiality protection, it MUST
	also supply to the GSS_Init_sec_context a conf_req_flag of
	TRUE.
</p>
<p>The client then responds with any resulting output_token.
</p>
<p>If GSS_Init_sec_context returns GSS_S_CONTINUE_NEEDED, then
	the client expect the server to issue a token in a subsequent
	challenge or as additional information to the outcome of the
	authentication.  The client pass the context token to another
	call to GSS_Init_sec_context, repeating the procedure, until
	GSS_S_COMPLETE is returned or authentication is aborted.
</p>
<p>If the server sent a (non-empty) "Wrap token", the context
	token is processed before processing the other tokens.  This
	is required because GSS_Unwrap may need the context to be in
	the state it is after the "Context token" in the message has
	been processed.
</p>
<p>When GSS_Init_sec_context returns GSS_S_COMPLETE, the client
	MUST examine the context to ensure that it provides a level of
	protection permitted by the client's security policy.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Server side</h3>

<p>The server passes the first context token to
	GSS_Accept_sec_context as input_token, setting
	input_context_handle to GSS_C_NO_CONTEXT (initially), the
	chan_binding set to NULL, and a suitable acceptor_cred_handle
	(see below).
</p>
<p>Servers SHOULD use a credential obtained by calling
	GSS_Acquire_cred or GSS_Add_cred for the GSS_C_NO_NAME
	desired_name and the OID of the GSS-API mechanism for which
	this SASL mechanism is registered (*).  Servers MAY use
	GSS_C_NO_CREDENTIAL as an acceptor credential handle.  Servers
	MAY use a credential obtained by calling GSS_Acquire_cred or
	GSS_Add_cred for the server's principal name(s) (**) and the
	GSS-API mechanism for which this SASL mechanism is
	registered.
</p>
<p>(*) - Unlike GSS_Add_cred the GSS_Acquire_cred uses an OID
	set of GSS-API mechanism as an input parameter.  The OID set
	can be created by using GSS_Create_empty_OID_set and
	GSS_Add_OID_set_member.  It can be freed by calling the
	GSS_Release_oid_set.
</p>
<p>(**) - Use of server's principal names having
	GSS_C_NT_HOSTBASED_SERVICE name type and "service@hostname"
	format, where "service" is the service name specified in the
	protocol's profile, and "hostname" is the fully qualified host
	name of the server, is RECOMMENDED.  The server name can be
	generated by calling GSS_Import_name with input_name_type of
	GSS_C_NT_HOSTBASED_SERVICE and input_name_string of
	"service@hostname".
</p>
<p>The server then responds with any resulting output_token.
</p>
<p>The server pass any resulting challenge from the client to
	another call to GSS_Accept_sec_context, repeating the
	procedure, until GSS_S_COMPLETE is returned or authentication
	is aborted.
</p>
<p>If the client sent a (non-empty) "Wrap token", the context
	token is processed first.
</p>
<p>Upon successful establishment of the security context (i.e.
	GSS_Accept_sec_context returns GSS_S_COMPLETE) the server
	SHOULD verify that the negotiated GSS-API mechanism is indeed
	the registered one.  This is done by examining the value of
	the mech_type parameter returned from the
	GSS_Accept_sec_context call.  If the value differ, the SASL
	authentication MUST be aborted.
</p>
<p>Upon successful establishment of the security context and if
	the server used GSS_C_NO_NAME/GSS_C_NO_CREDENTIAL to create
	acceptor credential handle, the server SHOULD also check using
	the GSS_Inquire_context that the target_name used by the
	client matches:
</p>
<p>- the GSS_C_NT_HOSTBASED_SERVICE "service@hostname" name
	syntax, where "service" is the service name specified in the
	application protocol's profile, and "hostname" is the fully
	qualified host name of the server.
</p>
<p>When GSS_Accept_sec_context returns GSS_S_COMPLETE, the
	server MUST examine the context to ensure that it provides a
	level of protection permitted by the server's security
	policy.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Wrap Token Field</h3>

<p>The Wrap token field MUST NOT be sent or received before the
      PROT_READY flag is set locally (by GSS_Init_sec_context or
      Gss_Accept_sec_context), or if the PROT_READY flag is never set,
      before the context has been fully established.  The Wrap token
      field does not have to be present directly when the PROT_READY
      flag is set.  During any exchange, exactly one Wrap token field
      is sent in each direction.  The GS2_Wrap function is defined
      below, and its inputs MUST follow the format described below.
      If not exactly one Wrap token is received by the client and by
      the server, the authentication MUST fail.
</p>
<p>If PROT_READY is never set by GSS_Init_sec_context or
      GSS_Accept_sec_context, the flag is implied by successful
      context negotiation.  This is for GSS-API v1 mechanisms that do
      not support PROT_READY, or for GSS-API mechanism that do not
      provide per-message protection.  This may result in a SASL token
      consisting of a context token length of 0 and a Wrap token.
</p>
<p>The entity that sends the first Wrap token will have to specify
      a bitmap of supported and preferred quality of protection
      schemes.  The entity that replies to the Wrap tokens will pick a
      scheme, based on the bitmask and local policy.  The quality of
      protection values are defined in section 9.
</p>
<p>Two pairs of input formats to the GS2_Wrap function are
      defined.  The first pair is used when the client sends the Wrap
      token first and the server responds.  The other pair is used
      when the server sends the Wrap token first and the client
      responds.
</p>
<p>The inputs below are passed to GS2_Wrap, and the output is used
      as the Wrap token value.
</p>
<p>Some fields in the input formats are optional, indicated by
      brackets ("[" and "]") and explained by the text below.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
The GS2_Wrap function</h3>

<p>The GS2_Wrap function have two implementations, and which one
	is used depends on whether the negotiated GSS-API context
	supports per-message protection.  When a context is
	successfully negotiated (i.e., when GSS_S_COMPLETE is returned
	from, for clients, GSS_Init_sec_context, or, for servers,
	GSS_Accept_sec_context) and the output variable integ_avail is
	FALSE, then GSS_Wrap cannot be used and instead we define
	GS2_Wrap to be the identity function.  When integ_avail is
	negotiated TRUE, the GS2_Wrap is identical to calling the
	GSS_Wrap function with conf_flag set to FALSE and using the
	generated output_message as the output data.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Client first GS2_Wrap input</h3>

<p>The input to GS2_Wrap when the client sends a Wrap token
	field first is as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  client_qops  |               client_maxbuf                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   channel_binding_length                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |[client_cbqops]|          [channel_binding_data]               /
   /                                                               /
   /                         /      [authzid]                      /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The "client_qops" integer indicate the client's preferred
	quality of protection if channel bindings are absent or the
	negotiation of the channel binding fails.  The quality of
	protection values are defined in section 9.
</p>
<p>The "client_maxbuf" field indicate the maximum protected
	buffer size the client can receive in network byte order.  It
	MUST be 0 if the client doesn't advertise support for any
	security layer, the server MUST verify this.  Small values can
	make it impossible for the server to send any protected
	message to the client, due to the overhead added by GSS_Wrap,
	and the server MAY reject the authentication if it detects
	this situation.
</p>
<p>The "channel_binding_length" is a network byte order integer
	that indicate the length of the "channel_binding_data"
	field.
</p>
<p>The optional field "client_cbqops" is present only if
	"channel_binding_length" is non-zero, and indicate the
	client's preferred quality of protection if channel binding
	negotiation succeeds.  The quality of protection values are
	defined in section 9.
</p>
<p>The optional field "channel_binding_data" is present only if
	"channel_binding_length" is non-zero, and contain the actual
	channel binding data.
</p>
<p>The optional field "authzid" contain the authorization
	identity.  The authorization identity is encoded
	using <a class='info' href='#RFC3629'>UTF-8<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a> [RFC3629].  The authorization
	identity is not terminated with the NUL (U+0000) character.
	Servers MUST validate that the authorization identity is valid
	UTF-8.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Server last GS2_Wrap input</h3>

<p>The input to GS2_Wrap when the server sends a Wrap token
	field, after receiving the Wrap token in the previous section
	from the client, is as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  server_qop   |               server_maxbuf                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The "server_qop" field integer indicate the selected quality
	of protection.  The quality of protection values are defined
	in section 9.
</p>
<p>The "server_maxbuf" field indicate the maximum protected data
	buffer size the server can receive in network byte order.  It
	MUST be 0 if the server doesn't advertise support for any
	security layer, the client MUST verify this.  Small values can
	make it impossible for the client to send any protected
	message to the server, due to the overhead added by GSS_Wrap,
	and the client MAY reject the authentication if it detects
	this situation.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.4"></a><h3>4.3.4.&nbsp;
Server first GS2_Wrap input</h3>

<p>The input to GS2_Wrap when the server sends the Wrap token
	first is as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  server_qops  |               server_maxbuf                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |[server_cbqops]|          [channel_binding_data]               /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The "server_qops" field is an integer indicating the server's
	preferred quality of protection if channel bindings are absent
	or the negotiation of the channel binding fails.  The quality
	of protection values are defined in section 9.
</p>
<p>The "server_maxbuf" is the same as above.
</p>
<p>The optional field "server_cbqops" indicate the server's
	preferred quality of protection if channel binding negotiation
	succeeds.  The quality of protection values are defined in
	section 9.
</p>
<p>The optional field "channel_binding_data" contain the actual
	channel binding data.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.5"></a><h3>4.3.5.&nbsp;
Client last GS2_Wrap input</h3>

<p>The input to GS2_Wrap when the clients sends a Wrap token
	field, after receiving the Wrap token in the previous section
	from the server, is as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  client_qop   |               client_maxbuf                   |
   /             [authzid]                                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The "client_qop" field is the selected quality of protection.
	The quality of protection values are defined in section 9.
</p>
<p>The "client_maxbuf" and "authzid" fields are as above.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Channel Bindings</h3>

<p>The GS2 mechanism provide its own channel binding mechanism,
    instead of using the "chan_binding" parameter in the GSS-API
    context functions.  The reason for this is that the GS2 mechanism
    provide an option to proceed even if the channel bindings does not
    match.  The GSS-API framework specifies that authentication cannot
    proceed if channel bindings do not match.
</p>
<p>Client and servers MUST set the "chan_binding" parameter in the
    calls to GSS_Init_sec_context and GSS_Accept_sec_context,
    respectively, to NULL.
</p>
<p>Implementations SHOULD set the "client_cbqops" and
    "server_cbqops" to no security layer and instead depend on the
    session security afforded by the bound-in channel.
</p>
<p>In order to accomodate the requirement in
    <a class='info' href='#I-D.altman-tls-channel-bindings'>[I&#8209;D.altman&#8209;tls&#8209;channel&#8209;bindings]<span> (</span><span class='info'>Altman, J. and N. Williams, &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; December&nbsp;2006.</span><span>)</span></a> "Authentication
    frameworks and mechanisms that support channel binding MUST
    communicate channel binding failure to applications"
    implementations MUST provide a way to communicate channel binding
    failures to applications.
</p>
<p>Use of no SASL security layers in combination with channel
    binding should provide better performance than using SASL security
    layers over secure channels, and better security characteristics
    than using no SASL security layers over secure channels without
    channel binding.
</p>
<p>For more discussions of channel bindings, and the syntax of the
    channel binding data for various security protocols, see
    <a class='info' href='#I-D.williams-on-channel-binding'>[I&#8209;D.williams&#8209;on&#8209;channel&#8209;binding]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; August&nbsp;2007.</span><span>)</span></a>.  For easy
    reference, the channel binding format used
    for <a class='info' href='#RFC4346'>The Transport Layer Security (TLS)
    Protocol<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1,&rdquo; April&nbsp;2006.</span><span>)</span></a> [RFC4346] is specified in
    <a class='info' href='#I-D.altman-tls-channel-bindings'>[I&#8209;D.altman&#8209;tls&#8209;channel&#8209;bindings]<span> (</span><span class='info'>Altman, J. and N. Williams, &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; December&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Protocol Overview</h3>

<p>This section describe several high-level protocol exchanges.  The
    descriptions do not assume any properties of the actual GSS-API
    mechanism.  Protocol profiles, GSS-API mechanism specific
    behaviour, and to some extent implementation and policy choices,
    will dictate which packets are sent in what order.  The protocol
    exchanges are examples and other exchanges are permitted and will
    occur.
</p>
<p>An informal pseudo-language is used to describe the packets sent
    below.  GS2_Wrap refer to the operation of calling GS2_Wrap on the
    indicated fields, formatted in the structures described earlier.
    GSS_Init_sec_context and GSS_Accept_sec_context refer to the
    context token generated by calling the respective function.  The
    GS2 SASL Message is denoted as [Context_token, Wrap_token], and
    the length fields are not mentioned.
</p>
<p>An authentication exchange using GS2 may look like:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange
      S: Empty Challenge
      C: Send [GSS_Init_sec_context, ""] token
      ...
      S: After PROT_READY is set,
         send [GSS_Accept_sec_context,
               GS2_Wrap(server_qops | server_maxbuf]
      ...
      C: After PROT_READY is set,
         send [GSS_Init_sec_context,
               GS2_Wrap (client_qop | client_maxbuf | authzid)]
      S: Send [GSS_Accept_sec_context, ""] token
      C: Send [GSS_Init_sec_context, ""] token
      ...
      S: Outcome of authentication exchange
</pre></div>
<p>GSS-API authentication is always initiated by the client.  The
    SASL framework allows either the client and server to initiate
    authentication.  In GS2 the server will send an initial empty
    challenge (zero byte string) if it has not yet received a token
    from the client.  See section 3 of <a class='info' href='#RFC4422'>[RFC4422]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a>.
</p>
<p>The next example illustrate when the client sends its Wrap token
    first.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange
      S: Empty Challenge
      C: Send [GSS_Init_sec_context, ""] token
      ...
      C: After PROT_READY is set,
         send [GSS_Init_sec_context,
               GS2_Wrap(client_qops | client_maxbuf |
                        channel_binding_length=0 | authzid)]
      ...
      S: After PROT_READY is set,
         send [GSS_Accept_sec_context,
               GS2_Wrap (server_qop | server_maxbuf)]
      C: Send [GSS_Init_sec_context, ""] token
      S: Send [GSS_Accept_sec_context, ""] token
      ...
      S: Outcome of authentication exchange
</pre></div>
<p>If the protocol profile support the optional initial client
    response, the first empty message can be optimized away, and then
    the protocol exchange will look like:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange and
         send [GSS_Init_sec_context, ""] token
      S: Send [GSS_Accept_sec_context, ""] token
      ...
      S: Outcome of authentication exchange
</pre></div>
<p>If the protocol profile can also send additional information when
    indicating the outcome of the authentication, then the protocol
    exchange will look like:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange and
         send [GSS_Init_sec_context, ""] token
      S: Send [GSS_Accept_sec_context, ""] token
      ...
      C: Send [GSS_Init_sec_context, ""] token
      S: Indicate successful authentication and
         send [GSS_Accept_sec_context, ""] token
         as additional information.
</pre></div>
<p>If the PROT_READY flag is never set by the GSS-API mechanism, the
    GS2_Wrap message will be sent after the context has been
    established.  The protocol may look like:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange
      ...
      S: GSS_Accept_sec_context() returns GSS_S_COMPLETE and outputs
         a token, send ["", GS2_Wrap(server_qops | server_maxbuf)]
      C: GSS_Init_sec_context() returns GSS_S_COMPLETE and does not
         output a token, send
         ["", GS2_Wrap(client_qop | client_maxbuf |
                       channel_binding_length=0 | authzid)]
      S: Outcome of authentication exchange
</pre></div>
<p>Alternatively, if the client finishes first, it may look
    like:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange
      ...
      C: GSS_Init_sec_context() returns GSS_S_COMPLETE and outputs a
         token, send ["", GS2_Wrap(client_qops | client_maxbuf |
                          channel_binding_length=0 | authzid)]
      S: GSS_Accept_sec_context() returns GSS_S_COMPLETE and does not
         output a token, send ["", GS2_Wrap(server_qop | server_maxbuf |
                                            channel_binding_length=0)]
      S: Outcome of authentication exchange
</pre></div>
<p>Adding channel bindings to the last examples, gives the following
    complex situation.  Here the client request confidentiality for
    the application data if channel binding fails but no SASL security
    layer if channel binding negotiation succeeds:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange
      ...
      C: GSS_Init_sec_context() returns GSS_S_COMPLETE and outputs a
         token, send [GSS_Init_sec_context,
                 GS2_Wrap(client_qops=0x04 | client_maxbuf |
                          channel_binding_length=n |
                          client_cbqops=0x01 | channel_binding_data |
                          authzid)]
      S: GSS_Accept_sec_context() returns GSS_S_COMPLETE and does not
         output a token, send ["",
                               GS2_Wrap(server_qop | server_maxbuf |
                                        channel_binding_length=0)]
      S: Outcome of authentication exchange
</pre></div>
<p>If the protocol support initial data from the client, and the
    PROT_READY flag is set in the client after the first call to
    GSS_Init_sec_context, and the server can send additional data to
    the client when indicating successful authentication, the
    following protocol exchange will occur.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      C: Request authentication exchange and
         send [GSS_Init_sec_context,
               GS2_Wrap (client_qops | client_maxbuf |
                         channel_binding_length=0 | authzid)] token
      S: Indicate successful authentication and
         send [GSS_Accept_sec_context,
               GS2_Wrap(server_qop | server_maxbuf)] token
         as additional information.
</pre></div>
<p>The last example illustrate the optimal (round-trip wise)
    authentication possible using this protocol.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Authentication Conditions</h3>

<p>Authentication MUST NOT succeed if any one of the following
    conditions are true:
</p>
<ul class="text">
<li>An invalid SASL token is received (e.g., length field checks
      discussed in section 4.1 fail).
</li>
<li>GSS_Init/Accept_sec_context() return anything other than
      GSS_S_CONTINUE_NEEDED or GSS_S_COMPLETE.
</li>
<li>GSS_Wrap() returns anything other than GSS_S_COMPLETE.
</li>
<li>GSS_Unwrap() returns anything other than GSS_S_COMPLETE.
      (There can't be supplementary status codes in GS2 at this point,
      so any indications of out of order processing or replays is
      fatal.)
</li>
<li>The token returned from GSS_Unwrap fail to parse correctly
      (e.g., too short, invalid maximum buffer size) as the expected
      Wrap token.
</li>
<li>Local policy reject the attempt. For example, client and server
      can't agree on qop proposal.
</li>
<li>(server-side) Authorization of client principal (i.e., src_name
      in GSS_Acecpt_sec_context) to requested authzid failed.
</li>
</ul>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
GSS-API Parameters</h3>

<p>The implementation MAY set any GSSAPI flags or arguments not
    mentioned in this specification as is necessary for the
    implementation to enforce its security policy.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Layer Bits</h3>

<p>The fields "client_qops", "server_qops", "client_cbqops", and
    "server_cbqops" are bit-fields that encode a set of requested
    quality of protection.  The fields "client_qop" and "server_qop"
    encode a single quality of protection value.
</p>
<p>The "client_qop" and "server_qop" will contains the chosen
    security layer.
</p>
<p>Note that "client_qop" and "server_qop" MAY indicate a quality of
    protection that was not offered by the server and client,
    respectively.  This SHOULD only be used when the server or client
    (respectively) would otherwise fail the entire authentication
    exchange.  The server/client that receives a "client_qop"/
    "server_qop" MUST verify that it corresponds to an acceptable
    security level.
</p>
<p>The security layers and their corresponding bit-masks are as
    follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  1 No security layer
  2 Integrity protection.
    Sender calls GSS_Wrap with conf_flag set to FALSE
  4 Confidentiality protection.
    Sender calls GSS_Wrap with conf_flag set to TRUE
</pre></div>
<p>Other bit-masks may be defined in the future; bits which are not
    understood MUST be negotiated off.
</p>
<p>When decoding any received data with GSS_Unwrap the major_status
    other than the GSS_S_COMPLETE MUST be treated as a fatal
    error.
</p>
<p>For integrity and confidentiality protection, GS2 negotiates the
    maximum size of the output_message to send.  Implementations can
    use the GSS_Wrap_size_limit call to determine the corresponding
    maximum size input_message.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Examples</h3>

<p>When no security layer is negotiated the octet will encode an
      integer 1 as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|0|0|0|0|0|0|1|
   +-+-+-+-+-+-+-+-+
</pre></div>
<p>When integrity is negotiated the octet will encode an integer 2
      as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|0|0|0|0|0|1|0|
   +-+-+-+-+-+-+-+-+
</pre></div>
<p>When confidentiality is negotiated the octet will encode an
      integer 4 as follows.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|0|0|0|0|1|0|0|
   +-+-+-+-+-+-+-+-+
</pre></div>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Non-integrity capable GSS-API mechanisms</h3>

<p>Mechanisms that do not support integrity can be used with GS2,
    but some security features cannot be provided, in particular
    including channel bindings, security layers, and integrity
    protection of the authorization identity.
</p>
<p>Channel bindings and security layers MUST NOT be negotiated when
    the GSS-API mechanism do not support integrity.  It should also be
    understood that the authorization identity is not integrity
    protected.
</p>
<p>Whether a mechanism supports integrity or not, for the purpose of
    GS2, is decided by whether the integ_avail output variable from
    GSS_Init_sec_context (for clients) and GSS_Accept_sec_context (for
    servers).  If integ_avail is FALSE, integrity is not
    supported.
</p>
<p>There is a potential interoperability problem if a client call
    GSS_Init_sec_context with integ_req_flag of TRUE and the context
    negotiation fails because the mechanism (due to design, the
    capability of the credentials, or policy) cannot provide
    per-message protection.  Calling GSS_Init_sec_context with a FALSE
    integ_req_flag instead is not optimal, since a mechanism may then
    negotiate less security than it would have otherwise done.
</p>
<p>It is RECOMMENDED that implementations only ever call
    GSS_Init_sec_context with a integ_req_flag of FALSE when it knows
    that the particular GSS-API mechanism will not be able to
    negotiate per-message protection services.
</p>
<p>Implementations MAY have a policy to disallow non-integrity
    capable mechanisms, and always call GSS_Init_sec_context with the
    integ_req_flag set to TRUE.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Interoperability with the SASL "GSSAPI" mechanism</h3>

<p>The <a class='info' href='#RFC1964'>Kerberos V5 GSS-API<span> (</span><span class='info'>Linn, J., &ldquo;The Kerberos Version 5 GSS-API Mechanism,&rdquo; June&nbsp;1996.</span><span>)</span></a> [RFC1964] mechanism
    is currently used in SASL under the name "GSSAPI",
    see <a class='info' href='#RFC4752'>GSSAPI mechanism<span> (</span><span class='info'>Melnikov, A., &ldquo;The Kerberos V5 (&quot;GSSAPI&quot;) Simple Authentication and Security Layer (SASL) Mechanism,&rdquo; November&nbsp;2006.</span><span>)</span></a> [RFC4752].  The Kerberos
    V5 mechanism may also be used with the GS2 family.  This causes an
    interopability problem, which is discussed and resolved below.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
The interoperability problem</h3>

<p>If a client (or server) only support Kerberos V5 under the
      "GSSAPI" name and the server (or client) only support Kerberos V5
      under the GS2 family, the authentication negotiation will
      fail.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
Resolving the problem</h3>

<p>If the Kerberos V5 mechanism is supported under GS2 in a
      server, the server SHOULD also support Kerberos V5 through the
      "GSSAPI" mechanism, to avoid interoperability problems with
      older clients.
</p>
<p>Reasons for violating this recommendation may include security
      considerations regarding the absent features in the GS2
      mechanism.  The Kerberos V5 "GSSAPI" SASL mechanism lack channel
      bindings, which could enable certain <a class='info' href='#mitm'>tunnel
      attacks<span> (</span><span class='info'>Asokan, N., Niemi, V., and K. Nyberg, &ldquo;Man-in-the-Middle in Tunneled Authentication,&rdquo; .</span><span>)</span></a> [mitm].
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
Additional recommendations</h3>

<p>It is RECOMMENDED to negotiate Kerberos V5 through the GS2
      mechanism rather than through the "GSSAPI" mechanism, if both
      are available, because of the additional features in the GS2
      mechanism.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Mechanisms that negotiate other mechanisms</h3>

<p>A GSS-API mechanism that negotiate other mechanisms interact
    badly with the SASL mechanism negotiation.  There are two
    problems.  The first is an interoperability problem and the second
    is a security concern.  The problems are described and resolved
    below.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1"></a><h3>12.1.&nbsp;
The interoperability problem</h3>

<p>If a client implement GSS-API mechanism X, potentially
      negotiated through a GSS-API mechanism Y, and the server also
      implement GSS-API mechanism X negotiated through a GSS-API
      mechanism Z, the authentication negotiation will fail.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2"></a><h3>12.2.&nbsp;
Security problem</h3>

<p>If a client's policy is to first prefer GSSAPI mechanism X,
      then non-GSSAPI mechanism Y, then GSSAPI mechanism Z, and if a
      server supports mechanisms Y and Z but not X, then if the client
      attempts to negotiate mechanism X by using a GSS-API mechanism
      that negotiate other mechanisms (such as SPNEGO), it may end up
      using mechanism Z when it ideally should have used mechanism Y.
      For this reason, the use of GSS-API mechanisms that negotiate
      other mechanisms are disallowed under GS2.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.3"></a><h3>12.3.&nbsp;
Resolving the problems</h3>

<p>GSS-API mechanisms that negotiate other mechanisms MUST NOT be
      used with the GS2 SASL mechanism.  This specifically exclude
      negotiating <a class='info' href='#RFC4178'>SPNEGO<span> (</span><span class='info'>Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism,&rdquo; October&nbsp;2005.</span><span>)</span></a> [RFC4178] under GS2.
</p>
<p>The <a class='info' href='#I-D.ietf-kitten-extended-mech-inquiry'>GSS_C_MA_MECH_NEGO attribute of
	GSS_Inquire_attrs_for_mech()<span> (</span><span class='info'>Williams, N., &ldquo;Extended Generic Security Service Mechanism Inquiry APIs,&rdquo; April&nbsp;2009.</span><span>)</span></a> [I&#8209;D.ietf&#8209;kitten&#8209;extended&#8209;mech&#8209;inquiry] can be used to identify
	such mechanisms.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
IANA Considerations</h3>

<p>The IANA is advised that SASL mechanism names starting with
    "GS2-" are reserved for SASL mechanisms which conform to this
    document.  The IANA is directed to place a statement to that
    effect in the sasl-mechanisms registry.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  Subject: Registration of SASL mechanism GS2-*
  SASL mechanism prefix: GS2-
  Security considerations: RFC [THIS-DOC]
  Published specification: RFC [THIS-DOC]
  Person &amp; email address to contact for further information:
    Simon Josefsson &lt;simon@josefsson.org&gt;
  Intended usage: COMMON
  Owner/Change controller: iesg@ietf.org
  Note: Compare with the GSSAPI and GSS-SPNEGO mechanisms.
</pre></div>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Security Considerations</h3>

<p>The security provided by GS2 depends on the security provided by
     the GSS-API mechanism.  If the mechanism do not provide integrity
     protection, the authorization identity can be replaced by a man
     in the middle, and channel bindings and security layers cannot be
     negotiated.  Therefor, it is generally recommended against using
     any GSS-API mechanism widely on the Internet that do not support
     integrity.
</p>
<p>Because the negotiation of a particular GSS-API mechanism may be
     done in the clear, it is important for the GSS-API mechanisms to
     be designed such that an active attacker cannot obtain an
     authentication with weaker security properties by modifying the
     challenges and responses.  This is a generic design critera for
     the GSS-API mechanisms used under GS2.
</p>
<p>When a server or client supports multiple GSS-API mechanisms,
     each of which has a different security strength, it is possible
     for an active attacker to cause a party to use the least secure
     mechanism supported.  This problem and a solution is discussed in
     section 6.1.2 of <a class='info' href='#RFC4422'>[RFC4422]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a>, but some additional
     methods to mitigate the problem include:<br />
<br />

</p>
<ol class="text">
<li>Use of an integrity protected transport, such
       as <a class='info' href='#RFC4346'>TLS<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1,&rdquo; April&nbsp;2006.</span><span>)</span></a> [RFC4346].  To protect against
       certain <a class='info' href='#mitm'>tunnel attacks<span> (</span><span class='info'>Asokan, N., Niemi, V., and K. Nyberg, &ldquo;Man-in-the-Middle in Tunneled Authentication,&rdquo; .</span><span>)</span></a> [mitm], channel
       bindings need to be used.
</li>
<li>A client or server which supports mechanisms of different
       strengths should have a configurable minimum strength that it
       will use.  It is not sufficient for this minimum strength check
       to only be on the server, since an active attacker can change
       which mechanisms the client sees as being supported, causing
       the client to send authentication credentials for its weakest
       supported mechanism.  This solution, however, is not guaranteed
       to lead to the most secure mechanism supported by both parties,
       and is therefor only recommended as an additional
       precaution.
</li>
</ol>
<p>The channel binding is sent without privacy protection and
     knowledge of it is assumed to provide no advantage to an
     attacker.  This is a property that has to be considered when
     specifying channel bindings for a security protocol that will be
     used with GS2.
</p>
<p>When constructing the input_name_string, the client should not
     canonicalize the server's fully qualified domain name using an
     insecure or untrusted directory service, such as
     the <a class='info' href='#RFC1034'>Domain Name System<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - concepts and facilities,&rdquo; November&nbsp;1987.</span><span>)</span></a> [RFC1034]
     without <a class='info' href='#RFC4033'>DNSSEC<span> (</span><span class='info'>Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;DNS Security Introduction and Requirements,&rdquo; March&nbsp;2005.</span><span>)</span></a> [RFC4033].
</p>
<p>The GS2 protocol hard code the SHA-1 algorithm for computing the
     mechanism names.  It is not possible to negotiate another hash
     algorithm.  However, no traditional cryptographic hash properties
     (such as collision resistance or pre-image resistance) are
     required nor assumed.  The required and assumed property is that
     it is statistically unlikely that two different DER-encoded OID's
     share the same first 10 octets of the SHA-1 value.  It is
     possible to practically confirm that the SHA-1 algorithm has the
     necessary property, by testing many different inputs.
</p>
<p>Additional security considerations are in the SASL and GSSAPI
     specifications.  Additional security considerations for the
     Kerberos V5 GSSAPI mechanism can be found in
     <a class='info' href='#RFC1964'>[RFC1964]<span> (</span><span class='info'>Linn, J., &ldquo;The Kerberos Version 5 GSS-API Mechanism,&rdquo; June&nbsp;1996.</span><span>)</span></a>.  We stress that service names should
     not be canonicalized using an unsecured directory service such as
     the DNS without DNSSEC.  Security issues are also discussed
     throughout this memo.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Acknowledgements</h3>

<p>The history of GS2 can be traced to the GSSAPI mechanism
    described in RFC 2222.  The GSSAPI mechanism had some drawbacks,
    which created a need for an improved version.  This document was
    derived from draft-ietf-sasl-gssapi-02 which was prepared by
    Alexey Melnikov with significant contributions from John G. Myers,
    although the majority of this document has been rewritten by the
    current author.
</p>
<p>Contributions of many members of the SASL mailing list are
    gratefully acknowledged.  In particular, ideas and feedback from
    Sam Hartman, Jeffrey Hutzelman, Alexey Melnikov, Nicolas Williams,
    and Tom Yu improved the document and the protocol.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>16.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4422">[RFC4422]</a></td>
<td class="author-text">Melnikov, A. and K. Zeilenga, &ldquo;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>,&rdquo; RFC&nbsp;4422, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4422.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS.180-1.1995">[FIPS.180-1.1995]</a></td>
<td class="author-text">National Institute of Standards and Technology, &ldquo;<a href="http://www.itl.nist.gov/fipspubs/fip180-1.htm">Secure Hash Standard</a>,&rdquo; FIPS&nbsp;PUB 180-1, April&nbsp;1995.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4648">[RFC4648]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>,&rdquo; RFC&nbsp;4648, October&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4648.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="ITU.X690.1994">[ITU.X690.1994]</a></td>
<td class="author-text">International Telecommunications Union, &ldquo;Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER),&rdquo; ITU-T&nbsp;Recommendation X.690, 1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.williams-on-channel-binding">[I-D.williams-on-channel-binding]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-williams-on-channel-binding-04.txt">On the Use of Channel Bindings to Secure Channels</a>,&rdquo; draft-williams-on-channel-binding-04 (work in progress), August&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-williams-on-channel-binding-04.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>16.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1034">[RFC1034]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1034, November&nbsp;1987 (<a href="http://www.rfc-editor.org/rfc/rfc1034.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1964">[RFC1964]</a></td>
<td class="author-text"><a href="mailto:John.Linn@ov.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1964">The Kerberos Version 5 GSS-API Mechanism</a>,&rdquo; RFC&nbsp;1964, June&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1964.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4178">[RFC4178]</a></td>
<td class="author-text">Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;<a href="http://tools.ietf.org/html/rfc4178">The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism</a>,&rdquo; RFC&nbsp;4178, October&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4178.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4752">[RFC4752]</a></td>
<td class="author-text">Melnikov, A., &ldquo;<a href="http://tools.ietf.org/html/rfc4752">The Kerberos V5 ("GSSAPI") Simple Authentication and Security Layer (SASL) Mechanism</a>,&rdquo; RFC&nbsp;4752, November&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4752.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2025">[RFC2025]</a></td>
<td class="author-text"><a href="mailto:cadams@bnr.ca">Adams, C.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2025">The Simple Public-Key GSS-API Mechanism (SPKM)</a>,&rdquo; RFC&nbsp;2025, October&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2025.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4346">[RFC4346]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>,&rdquo; RFC&nbsp;4346, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4346.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4033">[RFC4033]</a></td>
<td class="author-text">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>,&rdquo; RFC&nbsp;4033, March&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4033.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.altman-tls-channel-bindings">[I-D.altman-tls-channel-bindings]</a></td>
<td class="author-text">Altman, J. and N. Williams, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-altman-tls-channel-bindings-01.txt">On the Use of Channel Bindings to Secure Channels</a>,&rdquo; draft-altman-tls-channel-bindings-01 (work in progress), December&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-altman-tls-channel-bindings-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-kitten-extended-mech-inquiry">[I-D.ietf-kitten-extended-mech-inquiry]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-kitten-extended-mech-inquiry-06.txt">Extended Generic Security Service Mechanism Inquiry APIs</a>,&rdquo; draft-ietf-kitten-extended-mech-inquiry-06 (work in progress), April&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-kitten-extended-mech-inquiry-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="mitm">[mitm]</a></td>
<td class="author-text">Asokan, N., Niemi, V., and K. Nyberg, &ldquo;Man-in-the-Middle in Tunneled Authentication,&rdquo; WWW&nbsp;http://www.saunalahti.fi/~asokan/research/mitm.html.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Simon Josefsson</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:simon@josefsson.org">simon@josefsson.org</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
