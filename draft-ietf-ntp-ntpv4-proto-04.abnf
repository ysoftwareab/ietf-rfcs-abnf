T_c=2^tau.  A server responds with messages at an update interval of
era = s / 2^(32) and timestamp = s - era*2^(32)

s = era*2^(32) + timestamp

theta = T(B) - T(A) = 1/2*(T2-T1)+(T4-T3)

delta = T(ABA)- = (T4-T1)-(T3-T2)

cappsi=15 PPM, this amounts to about 1.3 s per day.  With this
i=n-1
capepsilon =    \     ----------
                   /        (i+1)
                  ---     2
i=0

psi   =    | -------- * |  /    (theta_0-theta_j)   |     |
              |  (n-1)     |  ---                      |     |
              |            |  j=1                      |     |
              |            +-----                 -----+     |
              |                                              |
              +-----                                    -----+

lambda = (del ' / 2) + epsilon

Lambda=stratum*MAXDIST+rootdist().

psi_s  =   | -------- * |  /    (theta_s-theta_j)   |     |
              |  (n-1)     |  ---                      |     |
              |            |  j=1                      |     |
              |            +-----                 -----+     |
              |                                              |
              +-----                                    -----+

psi_min=min(psi).  If psi_max<psi_min or n<NMIN, no further reduction
vartheta = sqrt((vartheta_p)^2+(vartheta_s)^2)

caplambda = capdelta/2 + capepsilon

rval=IGNOR
rval=STEP
captheta_B=off-captheta_R
captheta_R=off
p = mobilize(IPADDR, IPADDR, VERSION, MODE, KEYID,
r = recv_packet(); r->dst = get_time(); receive(r);
p = malloc(sizeof(struct p));
ntp_time = D2LFP(offset); gettimeofday(&unix_time, NULL);
ntp_time = D2LFP(offset);
has_mac = /* length of MAC field */ 0; if (has_mac == 0) {
auth = A_NONE;   /* not required */
auth == A_CRYPTO;   /* crypto-NAK */
auth = A_ERROR;   /* auth error */
auth = A_OK;   /* auth OK */
p = find_assoc(r);
p = mobilize(r->srcaddr, r->dstaddr, r->version, M_PASV,
      r->keyid, P_EPHEM);
p = mobilize(r->srcaddr, r->dstaddr, r->version, M_BCLN,
      r->keyid, P_EPHEM);
synch = TRUE;
synch = FALSE;/* unsynchronized */

synch = FALSE;/* bogus packet */
offset = LFP2D(r->xmt - r->dst); delay = BDELAY;
disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *
      2 * BDELAY;
offset = (LFP2D(r->rec - r->org) + LFP2D(r->dst
      r->xmt)) / 2;
delay = max(LFP2D(r->dst - r->org) - LFP2D(r->rec
      r->xmt), LOG2D(s.precision));
disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *
      LFP2D(r->dst - r->org);
dtemp = p->offset;
osys = s.p;
n = 0;
low = 2e9; high = -2e9;
found = 0;
chime = 0;
low = s.m[i].edge;
chime = 0;
high = s.m[i].edge;
n = 0;
p = s.m[i].p;
max = -2e9; min = 2e9; for (i = 0; i < n; i++) {
p = s.v[i].p;
min = p->jitter;
dtemp = 0;
q = s.v[j].p;
dtemp = SQRT(dtemp); if (dtemp > max) {
max = dtemp;
qmax = q;
dtemp = SQRT(SQUARE(p->jitter) + SQUARE(s.jitter));
y = z = w = 0;
p = s.v[i].p;
x = root_dist(p);
rval = SLEW;
mu = p->t - s.t;
freq = 0;
state = SPIK;
freq = (offset - c.base - c.offset) / mu;
rval = STEP;
etemp = SQUARE(c.jitter);
dtemp = SQUARE(max(fabs(offset - c.last),
     LOG2D(s.precision)));
freq = (offset - c.base - c.offset) / mu;
etemp = FLL - s.poll;
etemp = AVG;
etemp = min(mu, LOG2D(s.poll));
dtemp = 4 * PLL * LOG2D(s.poll);
etemp = SQUARE(c.wander);
dtemp = SQUARE(freq);
dtemp = c.offset / (PLL * min(LOG2D(s.poll), ALLAN));
hpoll = p->hpoll;
oreach = p->reach;
poll = min(p->hpoll, max(MINPOLL, ppoll));
