Network Working Group                                   Ross Finlayson
Internet-Draft                                          LIVE.COM
Expire in six months                                    1999.10.21
Category: Informational

           A More Loss-Tolerant RTP Payload Format for MP3 Audio

                   <draft-ietf-avt-rtp-mp3-00.txt>

1. Status of this Memo

     This document is an Internet-Draft and is in full conformance
     with all provisions of Section 10 of RFC2026.

     Internet-Drafts are working documents of the Internet Engineering
     Task Force (IETF), its areas, and its working groups.  Note that
     other groups may also distribute working documents as
     Internet-Drafts.

     Internet-Drafts are draft documents valid for a maximum of six
     months and may be updated, replaced, or obsoleted by other
     documents at any time.  It is inappropriate to use Internet-
     Drafts as reference material or to cite them other than as
     "work in progress."

     The list of current Internet-Drafts can be accessed at
     http://www.ietf.org/ietf/1id-abstracts.txt

     The list of Internet-Draft Shadow Directories can be accessed at
     http://www.ietf.org/shadow.html.

2. Abstract

While the RTP payload format defined in RFC 2250 is generally applicable
to all forms of MPEG audio or video, it is less suitable for MPEG 1 or 2,
layer III audio (commonly known as "MP3").  The reason for this is that
an MP3 frame is not a true "Application Data Unit" - it contains a
back-pointer to data in earlier frames, and so cannot be decoded
independently of these earlier frames.  Because RFC 2250 defines that
packet boundaries coincide with frame boundaries, it handles packet loss
inefficiently when carrying MP3 data.  The loss of an MP3 frame will
render some data in previous (or future) frames useless, even if they are
received without loss.

In this document we define a new RTP payload format for MP3 audio.
The new format is essentially the same as that defined in RFC 2250, except
for a data-preserving rearrangement of the original MPEG frames, so that
packet boundaries now coincide with true MP3 "Application Data Units".
This new format is therefore more data efficient in the face of packet
loss.

3. The Structure of MP3 Frames

In this section we give a brief overview of the structure of a MP3 frame.
(For more detailed description, see the official MPEG 1 audio [2] and
MPEG 2 audio [3] specifications.)

Each MPEG audio frame begins with a 4-byte header.  Information defined by
this header includes:
- Whether the audio is MPEG 1 or MPEG 2.
- Whether the audio is layer I, II, or III.
      (The remainder of this document assumes layer III, i.e., "MP3")
- Whether the audio is mono or stereo.
- Whether or not there is a 2-byte CRC field following the header.
- (indirectly) The size of the frame.

The following structures appear after the header:
- (optionally) A 2-byte CRC field
- A "side info" structure.  This has the following length:
        - 32 bytes for MPEG 1 stereo
        - 17 bytes for MPEG 1 mono, or for MPEG 2 stereo
        - 9 bytes for MPEG 2 mono
- Encoded audio data (filling out the rest of the frame)

For the purpose of this document, the "side info" structure is the most
important, because it defines the location and size of the "Application
Data Unit" (ADU) that an MP3 decoder will process.  In particular, the
"side info" structure defines:
- "main_data_begin": This is a back-pointer (in bytes) to the start of the
        ADU.  The back-pointer is counted from the beginning of the frame,
        and counts only encoded audio data (i.e., ignoring any header, CRC,
        or "side info" fields).
- Several "part2_3_length" fields.  These fields - each of which counts
        bits - are added together to form the length (in bits) of the ADU.
        Like the back-pointer, this length counts only encoded audio data
        - not header, CRC, or "side info" fields.

An MP3 decoder processes each ADU independently.  The ADUs will generally
vary in length, but their average length will, of course, be that of the
of the MP3 frames (minus the length of the header, CRC, and "side info"
fields).

4. A New Payload Format

As noted in [4], a payload format should be designed so that packet
boundaries coincide with "codec frame boundaries" - i.e., with ADUs.
The new payload format for MP3 is exactly the same as that defined by
RFC 2250 for MPEG audio [1], EXCEPT:
1/ Instead of containing MP3 frames, each packet contains "ADU frames",
        where an "ADU frame" is defined as:
        - The 4-byte MPEG header
        - The optional 2-byte CRC field
        - The "side info" structure
        - The complete sequence of encoded data for the ADU (padded at the
                end by zero-bits to fill out a byte boundary)
2/ The (static) payload type 14 that was defined for MPEG audio [5]
MUST NOT be used.  Instead, a different, dynamic payload type MUST be
used - i.e., one in the range [96,127].

Apart from using a different payload type, the use of the RTP header
(and the MPEG audio-specific header for fragmentation) is exactly the same
as defined in RFC 2250.

Note that no information is lost by converting a sequence of MP3 frames to
a corresponding sequence of "ADU frames", so a receiving RTP implementation
can either feed the ADU frames directly to an appropriately modified MP3
decoder, or convert them back into a sequence of MP3 frames, as described
in Appendix A below.

5. Handling Multiple MPEG Audio Layers

The RTP payload format described here is intended only for MPEG 1 or 2,
layer III audio ("MP3").  In contrast, layer I and layer II frames are
self-contained, without a back-pointer to earlier frames.  However, it is
possible (although unusual) for a sequence of audio frames to consist of
a mixture of layer III frames and layer I or II frames.  When such a
sequence is transmitted, only layer III frames are converted to ADUs;
layer I or II frames are sent 'as is'.  Similarly, the receiver of a
sequence of frames - using this payload format - leaves layer I and II
frames untouched, but converts layer III frames from "ADU frames" to
regular MP3 frames.  (Recall that each frame's layer is identified from
its 4-byte MPEG header.)

6. SDP Payload Format Description

Pending any future standardization of this payload format, SDP "rtpmap"
attributes [6] use the name "X-MP3" to denote this format.

7. Security Considerations

The security considerations for this payload format are identical to
those noted for RFC 2250 [1].

8. References

[1] Hoffman, D., Fernando, G., Goyal, V., and Civanlar, M.
    "RTP Payload Format for MPEG1/MPEG2 Video", RFC 2250, January 1998.
[2] ISO/IEC International Standard 11172-3; "Coding of moving pictures
    and associated audio for digital storage media up to about 1,5
    Mbits/s - Part 3: Audio", 1993.
[3] ISO/IEC International Standard 13818-3; "Generic coding of moving
    pictures and associated audio information - Part 3: Audio", 1998.
[4] Handley, M.
    "Guidelines for Writers of RTP Payload Format Specifications"
    Work-in-Progress, Internet-Draft
    "draft-ietf-avt-rtp-format-guidelines-04.txt", October 1999.
[5] Schulzrinne, H.
    "RTP Profile for Audio and Video Conferences with Minimal Control"
    RFC 1890, January 1996.
[6] Handley, M., Jacobson, V.,
    "SDP: Session Description Protocol",
    RFC 2327, April 1998.

9. Author's Address

        Ross Finlayson,
        Live Networks, Inc. (LIVE.COM)
        email: finlayson@live.com
        WWW: http://www.live.com/

Appendix A. Translating Between "MP3 Frames" and "ADU Frames"

The following 'pseudo code' describes how a sender using this payload
format can translate a sequence of regular "MP3 Frames" to "ADU Frames",
and how a receiver can perform the reverse translation: from "ADU Frames"
to "MP3 Frames".

We first define the following abstract data structures:

- "Segment": A record that represents either a "MP3 Frame" or an
  "ADU Frame".  It consists of the following fields:
        - "header": the 4-byte MPEG header
        - "headerSize": a constant (== 4)
        - "sideInfo": the 'side info' structure, *including* the optional
                2-byte CRC field, if present
        - "sideInfoSize": the size (in bytes) of the above structure
        - "frameData": the remaining data in this frame
        - "frameDataSize": the size (in bytes) of the above data
        - "backpointer": the size (in bytes) of the backpointer for
                this frame
        - "aduSize": the size (in bytes) of the ADU associated with
                this frame.  (If the frame is already an "ADU Frame", then
                aduSize == frameDataSize)
        - "mp3FrameSize": the total size (in bytes) that this frame would
                have if it were a regular "MP3 Frame".
                (If it is already a "MP3 Frame", then
                mp3FrameSize == headerSize + sideInfoSize + frameDataSize)
                Note that this size can be derived completely from "header".

- "SegmentQueue": A FIFO queue of "Segment"s, with operations
        - void enqueue(Segment)
        - Segment dequeue()
        - Boolean isEmpty()
        - Segment head()
        - Segment tail()
        - Segment previous(Segment):
                returns the segment prior to a given one
        - Segment next(Segment): returns the segment after a given one
        - unsigned totalDataSize(): returns the sum of the "frameDataSize"
          fields of each entry in the queue

A.1 Converting a sequence of "MP3 Frames" to a sequence of "ADU Frames":

SegmentQueue pendingMP3Frames; // initially empty
while (1) {
        // Enqueue new MP3 Frames, until we have enough data to generate
        // the ADU for a frame:
        do {
                int totalDataSizeBefore
                        = pendingMP3Frames.totalDataSize();

                Segment newFrame = 'the next MP3 Frame';
                pendingMP3Frames.enqueue(newFrame);

                int totalDataSizeAfter
                        = pendingMP3Frames.totalDataSize();
        } while (totalDataSizeBefore < newFrame.backpointer ||
                  totalDataSizeAfter < newFrame.aduSize);

        // We now have enough data to generate the ADU for the most
        // recently enqueued frame (i.e., the tail of the queue).
        // (The earlier frames in the queue - if any - must be discarded,
        // as we don't have enough data to generate their ADUs.)
        Segment tailFrame = pendingMP3Frames.tail();

        // Output the header and side info:
        output(tailFrame.header);
        output(tailFrame.sideInfo);

        // Go back to the frame that contains the start of our ADU data:
        int offset = 0;
        Segment curFrame = tailFrame;
        int prevBytes = tailFrame.backpointer;
        while (prevBytes > 0) {
                curFrame = pendingMP3Frames.previous(curFrame);
                int dataHere = curFrame.frameDataSize;
                if (dataHere < prevBytes) {
                        prevBytes -= dataHere;
                } else {
                        offset = dataHere - prevBytes;
                        break;
                }
        }

        // Dequeue any frames that we no longer need:
        while (pendingMP3Frames.head() != curFrame) {
                pendingMP3Frames.dequeue();
        }

        // Output, from the remaining frames, the ADU data that we want:
        int bytesToUse = tailFrame.aduSize;
        while (bytesToUse > 0) {
                int dataHere = curFrame.frameDataSize - offset;
                int bytesUsedHere
                        = dataHere < bytesToUse ? dataHere : bytesToUse;

                output("bytesUsedHere" bytes from curFrame.frameData,
                        starting from "offset");

                bytesToUse -= bytesUsedHere;
                offset = 0;
                curFrame = pendingMP3Frames.next(curFrame);
        }
}

A.2 Converting a sequence of "ADU Frames" to a sequence of "MP3 Frames":

SegmentQueue pendingADUFrames; // initially empty
while (1) {
        while (needToGetAnADU()) {
                Segment newADU = 'the next ADU Frame';
                pendingADUFrames.enqueue(newADU);

                insertDummyADUsIfNecessary();
        }

        generateFrameFromHeadADU();
}

Boolean needToGetAnADU() {
        // Checks whether we need to enqueue one or more new ADUs before
        // we have enough data to generate a frame for the head ADU.
        Boolean needToEnqueue = True;

        if (!pendingADUFrames.isEmpty()) {
                Segment curADU = pendingADUFrames.head();
                int endOfHeadFrame = curADU.mp3FrameSize
                        - curADU.headerSize - curADU.sideInfoSize;
                int frameOffset = 0;

                while (1) {
                        int endOfData = frameOffset
                                - curADU.backpointer + curADU.aduSize;
                        if (endOfData >= endOfHeadFrame) {
                                // We have enough data to generate a frame.
                                needToEnqueue = False;
                                break;
                        }

                        frameOffset += curADU.mp3FrameSize
                                - curADU.headerSize - curADU.sideInfoSize;
                        if (curADU == pendingADUFrames.tail()) break;
                        curADU = pendingADUFrames.next(curADU);
                }
        }

  return needToEnqueue;
}

void generateFrameFromHeadADU() {
        Segment curADU = pendingADUFrames.head();

        // Output the header and side info:
        output(curADU.header);
        output(curADU.sideInfo);

        // Begin by zeroing out the rest of the frame, in case the ADU
        // data doesn't fill it in completely:
        int endOfHeadFrame = curADU.mp3FrameSize
                - curADU.headerSize - curADU.sideInfoSize;
        output("endOfHeadFrame" zero bytes);

        // Fill in the frame with appropriate ADU data from this and
        // subsequent ADUs:
        int frameOffset = 0;
        int toOffset = 0;

        while (toOffset < endOfHeadFrame) {
                int startOfData = frameOffset - curADU.backpointer;
                if (startOfData > endOfHeadFrame) {
                        break; // no more ADUs are needed
                }
                int endOfData = startOfData + curADU.aduSize;
                if (endOfData > endOfHeadFrame) {
                        endOfData = endOfHeadFrame;
                }

                int fromOffset;
                if (startOfData <= toOffset) {
                        fromOffset = toOffset - startOfData;
                        startOfData = toOffset;
                        if (endOfData < startOfData) {
                                endOfData = startOfData;
                        }
                } else {
                        fromOffset = 0;

                        // leave some zero bytes beforehand:
                        toOffset = startOfData;
                }

                int bytesUsedHere = endOfData - startOfData;
                output(starting at offset "toOffset, "bytesUsedHere" bytes
                        from "&curADU.frameData[fromOffset]");
                toOffset += bytesUsedHere;

                frameOffset += curADU.mp3FrameSize
                        - curADU.headerSize - curADU.sideInfoSize;
                curADU = pendingADUFrames.next(curADU);
        }

        pendingADUFrames.dequeue();
}

void insertDummyADUsIfNecessary() {
        // The tail segment (ADU) is assumed to have been recently
        // enqueued.  If its backpointer would overlap the data
        // of the previous ADU, then we need to insert one or more empty,
        // 'dummy' ADUs ahead of it.  (This situation should occur only if
        // an intermediate ADU was missing - e.g., due to packet loss.)
        while (1) {
                Segment tailADU = pendingADUFrames.tail();
                int prevADUend; // relative to the start of the tail ADU

                if (pendingADUFrames.head() != tailADU) {
                        // there is a previous ADU
                        Segment prevADU
                                = pendingADUFrames.previous(tailADU);
                        prevADUend
                                = prevADU.mp3FrameSize + prevADU.backpointer
                                  - prevADU.headerSize -
curADU.sideInfoSize;
                        if (prevADU.aduSize > prevADUend) {
                                // this shouldn't happen if the previous ADU
                                // was well-formed
                                prevADUend = 0;
                        } else {
                                prevADUend -= prevADU.aduSize;
                        }
                } else {
                        prevADUend = 0;
                }

                if (tailADU.backpointer > prevADUend) {
                        // Insert a 'dummy' ADU in front of the tail.
                        // This ADU can have the same "header" (and thus
                        // "mp3FrameSize") as the tail ADU, but should have
                        // an "aduSize" of zero.  The simplest way to do
                        // this is to copy the "sideInfo" from the tail ADU,
                        // and zero out the "main_data_begin" and all of the
                        // "part2_3_length" fields.
                } else {
                        break; // no more dummy ADUs need to be inserted
                }
        }
}
