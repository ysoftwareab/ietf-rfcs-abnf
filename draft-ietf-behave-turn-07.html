<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)">
<meta name="keywords" content="NAT, TURN, STUN, ICE">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">BEHAVE WG</td><td class="header">J. Rosenberg</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">R. Mahy</td></tr>
<tr><td class="header">Expires: August 28, 2008</td><td class="header">Plantronics</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Matthews</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Avaya</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">February 25, 2008</td></tr>
</table></td></tr></table>
<h1><br />Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)<br />draft-ietf-behave-turn-07</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on August 28, 2008.</p>

<h3>Abstract</h3>

<p>If a host is located behind a NAT, then in certain situations it can
      be impossible for that host to communicate directly with other hosts
      (peers) located behind other NATs. In these situations, it is necessary
      for the host to use the services of an intermediate node that acts as a
      communication relay. This specification defines a protocol, called TURN
      (Traversal Using Relays around NAT), that allows the host to control the
      operation of the relay and to exchange packets with its peers using the
      relay.
</p>
<p>The TURN protocol can be used in isolation, but is more properly used
      as part of the ICE (Interactive Connectivity Establishment) approach to
      NAT traversal.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Overview of Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-transports">2.1.</a>&nbsp;
Transports<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.2.</a>&nbsp;
Allocations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.3.</a>&nbsp;
Exchanging Data with Peers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.4.</a>&nbsp;
Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#perms">2.5.</a>&nbsp;
Permissions<br />
<a href="#anchor6">3.</a>&nbsp;
Terminology<br />
<a href="#sec-general-behavior">4.</a>&nbsp;
General Behavior<br />
<a href="#sec-allocations">5.</a>&nbsp;
Allocations<br />
<a href="#sec-create-allocation">6.</a>&nbsp;
Creating an Allocation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">6.1.</a>&nbsp;
Sending an Allocate Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-rcv-allocate">6.2.</a>&nbsp;
Receiving an Allocate Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.3.</a>&nbsp;
Receiving an Allocate Response<br />
<a href="#sec-refreshing-allocation">7.</a>&nbsp;
Refreshing an Allocation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">7.1.</a>&nbsp;
Sending a Refresh Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">7.2.</a>&nbsp;
Receiving a Refresh Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.3.</a>&nbsp;
Receiving a Refresh Response<br />
<a href="#sec-permissions">8.</a>&nbsp;
Permissions<br />
<a href="#sec-sendanddata">9.</a>&nbsp;
Send and Data Indications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-forming-indication">9.1.</a>&nbsp;
Sending a Send Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">9.2.</a>&nbsp;
Receiving a Send Indication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-sending-data-indication">9.3.</a>&nbsp;
Receiving a UDP Datagram<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">9.4.</a>&nbsp;
Receiving a Data Indication<br />
<a href="#sec-channels">10.</a>&nbsp;
Channels<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">10.1.</a>&nbsp;
Sending a ChannelBind Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-receiving-ChannelBind">10.2.</a>&nbsp;
Receiving a ChannelBind Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">10.3.</a>&nbsp;
Receiving a ChannelBind Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-channeldata-msg">10.4.</a>&nbsp;
The ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-sending-channeldata-msg">10.5.</a>&nbsp;
Sending a ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">10.6.</a>&nbsp;
Receiving a ChannelData Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">10.7.</a>&nbsp;
Relaying<br />
<a href="#anchor18">11.</a>&nbsp;
IP Header Fields and Path MTU<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">11.1.</a>&nbsp;
DiffServ Code Point (DSCP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">11.2.</a>&nbsp;
Don't Fragment (DF) bit<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">11.3.</a>&nbsp;
Other IP Header Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">11.4.</a>&nbsp;
Path MTU<br />
<a href="#sec-stun-methods">12.</a>&nbsp;
New STUN Methods<br />
<a href="#sec-stun-attributes">13.</a>&nbsp;
New STUN Attributes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#channelnums">13.1.</a>&nbsp;
CHANNEL-NUMBER<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">13.2.</a>&nbsp;
LIFETIME<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">13.3.</a>&nbsp;
BANDWIDTH<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">13.4.</a>&nbsp;
PEER-ADDRESS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">13.5.</a>&nbsp;
DATA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">13.6.</a>&nbsp;
RELAY-ADDRESS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">13.7.</a>&nbsp;
REQUESTED-PROPS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-requested-transport">13.8.</a>&nbsp;
REQUESTED-TRANSPORT<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">13.9.</a>&nbsp;
RESERVATION-TOKEN<br />
<a href="#sec-stun-errors">14.</a>&nbsp;
New STUN Error Response Codes<br />
<a href="#sec-security">15.</a>&nbsp;
Security Considerations<br />
<a href="#anchor30">16.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor31">17.</a>&nbsp;
IAB Considerations<br />
<a href="#anchor32">18.</a>&nbsp;
Example<br />
<a href="#anchor33">19.</a>&nbsp;
Changes from Previous Versions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">19.1.</a>&nbsp;
Changes from -06 to -07<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">19.2.</a>&nbsp;
Changes from -05 to -06<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">19.3.</a>&nbsp;
Changes from -04 to -05<br />
<a href="#sec-open-issues">20.</a>&nbsp;
Open Issues<br />
<a href="#anchor37">21.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">22.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">22.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">22.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Session Traversal Utilities for NAT (STUN) <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> provides a suite of tools
      for facilitating the traversal of NAT. Specifically, it defines the
      Binding method, which is used by a client to determine its reflexive
      transport address towards the STUN server. The reflexive transport
      address can be used by the client for receiving packets from peers, but
      only when the client is behind "good" NATs. In particular, if a client
      is behind a NAT whose mapping behavior <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> is
      address or address and port dependent (sometimes called "bad" NATs), the
      reflexive transport address will not be usable for communicating with a
      peer.
</p>
<p>The only reliable way to obtain a UDP transport address that can be
      used for corresponding with a peer through such a NAT is to make use of
      a relay. The relay sits on the public side of the NAT, and allocates
      transport addresses to clients reaching it from behind the private side
      of the NAT. These allocated transport addresses, called relayed
      transport address, are IP addresses and ports on the relay. When the
      relay receives a packet on one of these allocated addresses, the relay
      forwards it toward the client.
</p>
<p>This specification defines an extension to STUN, called TURN, that
      allows a client to request a relayed transport address on a TURN
      server.
</p>
<p>Though a relayed transport address is highly likely to work when
      corresponding with a peer, it comes at high cost to the provider of the
      relay service. As a consequence, relayed transport addresses should only
      be used as a last resort. Protocols using relayed transport addresses
      should make use of mechanisms to dynamically determine whether such an
      address is actually needed. One such mechanism, defined for multimedia
      session establishment protocols based on the offer/answer protocol in
      <a class='info' href='#RFC3264'>RFC 3264<span> (</span><span class='info'>Rosenberg, J. and H. Schulzrinne, &ldquo;An Offer/Answer Model with Session Description Protocol (SDP),&rdquo; June&nbsp;2002.</span><span>)</span></a> [RFC3264], is Interactive Connectivity
      Establishment (ICE) <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>.
</p>
<p>TURN was originally invented to support multimedia sessions signaled
      using SIP. Since SIP supports forking, TURN supports multiple peers per
      client; a feature not supported by other approaches (e.g., SOCKS <a class='info' href='#RFC1928'>[RFC1928]<span> (</span><span class='info'>Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &ldquo;SOCKS Protocol Version 5,&rdquo; March&nbsp;1996.</span><span>)</span></a>). However, care has been taken in the later
      stages of its development to make sure that TURN is suitable for other
      types of applications.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Overview of Operation</h3>

<p>This section gives an overview of the operation of TURN. It is
      non-normative.
</p>
<p>In a typical configuration, a TURN client is connected to a <a class='info' href='#RFC1918'>private network<span> (</span><span class='info'>Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, &ldquo;Address Allocation for Private Internets,&rdquo; February&nbsp;1996.</span><span>)</span></a> [RFC1918] and through one or more NATs to
      the public Internet. On the public Internet is a TURN server. Elsewhere
      in the Internet are one or more peers that the TURN client wishes to
      communicate with. These peers may or may not be behind one or more
      NATs.
</p><br /><hr class="insert" />
<a name="fig-turn-model"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                                          +---------+
                                                          |         |
                                                          |         |
                                                        / |  Peer A |
    Client's              TURN                        //  |         |
    Host Transport        Server                     /    |         |
    Address               Address              +-+ //     +---------+
 10.1.1.2:17240       192.0.2.15:3478          |N|/  192.168.100.2:16400
       |                    |                  |A|
       |        +-+         |                 /|T|
       |        | |         |                / +-+
       v        | |         |               /       192.0.2.210:18200
 +---------+    | |         |+---------+   /              +---------+
 |         |    |N|         ||         | //               |         |
 | TURN    |    | |         v|  TURN   |/                 |         |
 | Client  |----|A|----------|  Server |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:9000     192.0.2.210:18200
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
</p>
<p><a class='info' href='#fig-turn-model'>Figure&nbsp;1</a> shows a typical deployment. In
      this figure, the TURN client and the TURN server are separated by a NAT,
      with the client on the private side and the server on the public side of
      the NAT. This NAT is assumed to be a &ldquo;bad&rdquo; NAT; for example,
      it might have a mapping property of address-and-port-dependent mapping
      (see <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>) for a description of what this
      means).
</p>
<p>The client has allocated a local port on one of its addresses for use
      in communicating with the server. The combination of an IP address and a
      port is called a TRANSPORT ADDRESS and since this (IP address, port)
      combination is located on the client and not on the NAT, it is called
      the client&rsquo;s HOST transport address.
</p>
<p>The client sends TURN messages from its host transport address to a
      transport address on the TURN server which is known as the TURN SERVER
      ADDRESS. The client learns the server&rsquo;s address through some
      unspecified means (e.g., configuration), and this address is typically
      used by many clients simultaneously. The TURN server address is used by
      the client to send both commands and data to the server; the commands
      are processed by the TURN server, while the data is relayed on to the
      peers.
</p>
<p>Since the client is behind a NAT, the server sees these packets as
      coming from a transport address on the NAT itself. This address is known
      as the client&rsquo;s SERVER-REFLEXIVE transport address; packets sent
      by the server to the client&rsquo;s server-reflexive transport address
      will be forwarded by the NAT to the client&rsquo;s host transport
      address.
</p>
<p>The client uses TURN commands to allocate a RELAYED TRANSPORT
      ADDRESS, which is an transport address located on the TURN server. The
      server ensures that there is a one-to-one relationship between the
      client&rsquo;s server-reflexive transport address and the relayed
      transport address; thus a packet received at the relayed transport
      address can be unambiguously relayed by the server to the client.
</p>
<p>The client will typically communicate this relayed transport address
      to one or more peers through some mechanism not specified here (e.g., an
      ICE offer or answer <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>). Once
      this is done, the client can send data to the server to relay towards
      its peers. In the reverse direction, peers can send data to the the
      relayed transport address of the client. The server will relay this data
      to the client as long as the client explicitly created a permission (see
      <a class='info' href='#perms'>Section&nbsp;2.5<span> (</span><span class='info'>Permissions</span><span>)</span></a>) for the IP address of the peer.
</p>
<a name="sec-transports"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Transports</h3>

<p>TURN as defined in this specification only allows the use of UDP
        between the server and the peer. However, this specification allows
        the use of any one of UDP, TCP, or TLS over TCP to carry the TURN
        messages between the client and the server.
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">TURN client to TURN server</th><th align="center">TURN server to peer</th></tr>
<tr>
<td align="center">UDP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">TLS over TCP</td>
<td align="center">UDP</td>
</tr>
</table>
<br clear="all" />

<p>If TCP or TLS over TCP is used between the client and the server,
        then the server will convert between stream transport and UDP
        transport when relaying data. TURN allows both TCP and TLS over TCP as
        transports in part because many firewalls are configured to not pass
        any UDP traffic.
</p>
<p>For TURN clients, using TLS over TCP to communicate with the TURN
        server provides two benefits. First, the client can be assured that
        the addresses of its peers are not visible to any attackers between it
        and the server. Second, the client may be able to communicate with
        TURN servers using TLS when it would not be able to communicate with
        the same server using TCP or UDP, due to the policy of a firewall
        between the TURN client and its server. In this second case, TLS
        between the client and TURN server facilitates traversal.
</p>
<p>There is a planned extension to TURN to add support for TCP between
        the server and the peers <a class='info' href='#I-D.ietf-behave-turn-tcp'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;tcp]<span> (</span><span class='info'>Perreault, S. and J. Rosenberg, &ldquo;Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations,&rdquo; March&nbsp;2010.</span><span>)</span></a>. For this reason,
        allocations that use UDP between the server and the peers are known as
        UDP allocations, while allocations that use TCP between the server and
        the peers are known as TCP allocations. This specification describes
        only UDP allocations.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Allocations</h3>

<p>To allocate a relayed transport address, the client uses an
        Allocate transaction. The client sends a Allocate Request to the
        server, and the server replies with an Allocate Response containing
        the allocated relayed transport address. The client can include
        attributes in the Allocate Request that describe the type of
        allocation it desires (e.g., the lifetime of the allocation). And
        since relaying data can require lots of bandwidth, the server
        typically requires that the client authenticate itself using
        STUN&rsquo;s long-term credential mechanism, to show that it is
        authorized to use the server.
</p>
<p>Once a relayed transport address is allocated, a client must keep
        the allocation alive. To do this, the client periodically sends a
        Refresh Request to the server with the allocated related transport
        address. TURN deliberately uses a different method (Refresh rather
        than Allocate) for refreshes to ensure that the client is informed if
        the allocation vanishes for some reason.
</p>
<p>The frequency of the Refresh transaction is determined by the
        lifetime of the allocation. The client can request a lifetime in the
        Allocate Request and may modify its request in a Refresh Request, and
        the server always indicates the actual lifetime in the response. The
        client must issue a new Refresh transaction within 'lifetime' seconds
        of the previous Allocate or Refresh transaction. If a client no longer
        wishes to use an Allocation, it should do a Refresh transaction with a
        requested lifetime of 0.
</p>
<p>Note that sending or receiving data from a peer DOES NOT refresh
        the allocation.
</p>
<p>The server keeps track of the client reflexive transport address
        and port, the server transport address and port, and the protocol used
        by the client to communicate with the server. (Together known as a
        5-tuple. The server remembers the 5-tuple used in the Allocate
        Request. Subsequent transactions between the client and the server use
        this same 5-tuple. In this way, the server knows which client owns the
        allocated relayed transport address. If the client wishes to allocate
        a second relayed transport address, it must use a different 5-tuple
        for this allocation (e.g., by using a different client host
        address).,
</p>
<p></p>
<blockquote class="text">
<p>While the terminology used in this document refers to 5-tuples,
            the TURN server can store whatever identifier it likes that yields
            identical results. Specifically, many implementations use a
            file-descriptor in place of a 5-tuple to represent a TCP
            connection.
</p>
</blockquote>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Exchanging Data with Peers</h3>

<p>There are two ways for the client and peers to exchange data using
        the TURN server. The first way uses Send and Data indications, the
        second way uses channels. Common to both ways is the ability of the
        client to communicate with multiple peers using a single allocated
        relayed transport address; thus both ways include a means for the
        client to indicate to the server which peer to forward the data to,
        and for the server to indicate which peer sent the data.
</p>
<p>When using the first way, the client sends a Send indication to the
        TURN server containing, in attributes inside the indication, the
        transport address of the peer and the data to be sent to that peer.
        When the TURN server receives the Send Indication, it extracts the
        data from the Send Indication and sends it in a UDP datagram to the
        peer, using the allocated relay address as the source address. In the
        reverse direction, UDP datagrams arriving at the relay address on the
        TURN server are converted into Data Indications and sent to the
        client, with the transport address of the peer included in an
        attribute in the Data Indication.
</p><br /><hr class="insert" />
<a name="fig-send-data"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                   TURN          Peer          Peer
client                 server         A             B
  |--- Allocate Req  --&gt;|             |             |
  |&lt;-- Allocate Resp ---|             |             |
  |                     |             |             |
  |--- Send (Peer A)---&gt;|             |             |
  |                     |=== data ===&gt;|             |
  |                     |             |             |
  |                     |&lt;== data ====|             |
  |&lt;-- Data (Peer A)----|             |             |
  |                     |             |             |
  |--- Send (Peer B)---&gt;|             |             |
  |                     |=== data =================&gt;|
  |                     |             |             |
  |                     |&lt;== data ==================|
  |&lt;-- Data (Peer B)----|             |             |
</pre></div>
<p>
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In the figure above, the client first allocates a relayed transport
        address. It then sends data to Peer A using a Send Indication; at the
        server, the data is extracted and forwarded in a UDP datagram to Peer
        A, using the relayed transport address as the source transport
        address. When a UDP datagram from Peer A is received at the relayed
        transport address, the contents are placed into a Data Indication and
        forwarded to the client. A similar exchange happens with Peer B.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Channels</h3>

<p>For some applications (e.g. Voice over IP), the 36 bytes of
        overhead that a Send or Data indication adds to the application data
        can substantially increase the bandwidth required between the client
        and the server. To remedy this, TURN offers a second way for the
        client and server to associate data with a specific peer.
</p>
<p>This second way uses an alternate packet format known as the
        ChannelData message. The ChannelData message does not use the STUN
        header used by other TURN messages, but instead has a 4-byte header
        that includes a number known as a channel number. Each channel number
        in use is bound to a specific peer and thus serves as a shorthand for
        the peer's address.
</p>
<p>To bind a channel to a peer, the client sends a ChannelBind request
        to the server, and includes an unbound channel number and the
        transport address of the peer. Once the channel is bound, the client
        can use a ChannelData message to send the server data destined for the
        peer. Similarly, the server can relay data from that peer towards the
        client using a ChannelData message.
</p>
<p>Channel bindings last for 10 minutes unless refreshed. Channel
        bindings are refreshed by sending ChannelData messages from the client
        to the server, or by rebinding the channel to the peer.
</p>
<p>
</p><br /><hr class="insert" />
<a name="fig-channels"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>TURN                   TURN          Peer          Peer
client                 server         A             B
  |--- Allocate Req  --&gt;|             |             |
  |&lt;-- Allocate Resp ---|             |             |
  |                     |             |             |
  |--- Send (Peer A)---&gt;|             |             |
  |                     |=== data ===&gt;|             |
  |                     |             |             |
  |                     |&lt;== data ====|             |
  |&lt;-- Data (Peer A)----|             |             |
  |                     |             |             |
  |- ChannelBind Req --&gt;|             |             |
  | (Peer A to 0x4001)  |             |             |
  |                     |             |             |
  |&lt;- ChannelBind Resp -|             |             |
  |                     |             |             |
  |-- [0x4001] data ---&gt;|             |             |
  |                     |=== data ===&gt;|             |
  |                     |             |             |
  |                     |&lt;== data ====|             |
  |&lt;- [0x4001] data ---&gt;|             |             |
  |                     |             |             |
  |--- Send (Peer B)---&gt;|             |             |
  |                     |=== data =================&gt;|
  |                     |             |             |
  |                     |&lt;== data ==================|
  |&lt;-- Data (Peer B)----|             |             |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The figure above shows the channel mechanism in use. The client
        begins by allocating a relayed transport address, and then uses that
        address to exchange data with Peer A. After a bit, the client decides
        to bind a channel to Peer A. To do this, it sends a ChannelBind
        request to the server, specifying the transport address of Peer A and
        a channel number (0x4001). After that, the client can send application
        data encapsulated inside ChannelData messages to Peer A: this is shown
        as "[0x4001] data" where 0x4001 is the channel number.
</p>
<p>Note that ChannelData messages can only be used for peers to which
        the client has bound a channel. In the example above, Peer A has been
        bound to a channel, but Peer B has not, so application data to and
        from Peer B uses Send and Data indications.
</p>
<p>Channel bindings are always initiated by the client.
</p>
<a name="perms"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Permissions</h3>

<p>To ease concerns amongst enterprise IT administrators that TURN
        could be used to bypass corporate firewall security, TURN includes the
        notion of permissions. TURN permissions mimic the address-restricted
        filtering mechanism of NATs that comply with <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The client can install a permission by sending data to a peer (or
        by doing certain other things). Once a permission is installed, any
        peer with the same IP address (the ports numbers can differ) is
        permitted to send data to the client. After 5 minutes, the permission
        times out and the server drops any UDP datagrams arriving at the
        relayed transport from that IP address. Note that permissions are
        within the context of an allocation, so adding or expiring a
        permission in one allocation does not affect other allocations.
</p>
<p>Data received from the peer DOES NOT refresh the permission.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<p>Readers are expected to be familar with <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> and the terms defined
      there.
</p>
<p>The following terms are used in this document:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>TURN:</dt>
<dd>A protocol spoken between a TURN client and a
          TURN server. It is an extension to the STUN protocol <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>. The protocol allows a
          client to allocate and use a relayed transport address.
</dd>
<dt>TURN client:</dt>
<dd>A STUN client that implements this
          specification.
</dd>
<dt>TURN server:</dt>
<dd>A STUN server that implements this
          specification. It relays data between a TURN client and its
          peer(s).
</dd>
<dt>Peer:</dt>
<dd>A host with which the TURN client wishes to
          communicate. The TURN server relays traffic between the TURN client
          and its peer(s). The peer does not interact with the TURN server
          using the protocol defined in this document; rather, the peer
          receives data sent by the TURN server and the peer sends data
          towards the TURN server.
</dd>
<dt>Host Transport Address:</dt>
<dd>A transport address allocated
          on a host.
</dd>
<dt>Server-Reflexive Transport Address:</dt>
<dd>A transport
          address on the "public side" of a NAT. This address is allocated by
          the NAT to correspond to a specific host transport address.
</dd>
<dt>Relayed Transport Address:</dt>
<dd>A transport address that
          exists on a TURN server. If a permission exists, packets that arrive
          at this address are relayed towards the TURN client.
</dd>
<dt>Allocation:</dt>
<dd>The relayed transport address granted to a
          client through an Allocate request, along with related state, such
          as permissions and expiration timers.
</dd>
<dt>5-tuple:</dt>
<dd>The combination (client IP address and port,
          server IP address and port, and transport protocol (UDP or TCP))
          used to communicate between the client and the server . The 5-tuple
          uniquely identifies this communication stream. The 5-tuple also
          uniquely identifies the Allocation on the server.
</dd>
<dt>Permission:</dt>
<dd>The IP address and transport protocol (but
          not the port) of a peer that is permitted to send traffic to the
          TURN server and have that traffic relayed to the TURN client. The
          TURN server will only forward traffic to its client from peers that
          match an existing permission.
</dd>
</dl></blockquote>

<a name="sec-general-behavior"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
General Behavior</h3>

<p>This section contains general TURN processing rules that apply to all
      TURN messages.
</p>
<p>TURN is an extension to STUN. All TURN messages, with the exception
      of the ChannelData message, are STUN-formatted messages. All the base
      processing rules described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> apply to STUN-formatted
      messages. This means that all the message-forming and -processing
      descriptions in this document are implicitly prefixed with the rules of
      <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</p>
<p>In addition, the server SHOULD require that all TURN requests use the
      Long-Term Credential mechanism described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>, and the client MUST be
      prepared to authenticate requests if required. The server's
      administrator MUST choose a realm value that will uniquely identify the
      username and password combination that the client must use, even if the
      client uses multiple servers under different administrations. The
      server's administrator MAY choose to allocate a unique username to each
      client, or MAY choose to allocate the same username to more than one
      client (for example, to all clients from the same department or
      company).
</p>
<p>The client and/or the server MAY include the FINGERPRINT attribute in
      any of the methods defined in this document. However, TURN does not use
      the backwards-compatibility mechanism described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</p>
<p>By default, TURN runs on the same port as STUN. However, either the
      SRV procedures or the ALTERNATE-SERVER procedures described in <a class='info' href='#sec-create-allocation'>Section&nbsp;6<span> (</span><span class='info'>Creating an Allocation</span><span>)</span></a> may be used to run TURN on a
      different port.
</p>
<a name="sec-allocations"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Allocations</h3>

<p>All TURN operations revolve around allocations, and all TURN messages
      are associated with an allocation. An allocation conceptually consists
      of the following state data:</p>
<ul class="text">
<li>Relayed transport address
</li>
<li>The 5-tuple: client IP address, client port, server IP address,
          server port, transport protocol
</li>
<li>Username
</li>
<li>Transaction ID of the Allocate request
</li>
<li>Bandwidth
</li>
<li>Time-to-expiry
</li>
<li>List of permissions
</li>
<li>List of channel to peer bindings
</li>
</ul><p>The relayed transport address is the transport address
      allocated by the server for communicating with peers, while the 5-tuple
      describes the communication path between the client and the server. Both
      of these MUST be unique across all allocations, so either one can be
      used to uniquely identify the allocation.
</p>
<p>When a TURN message arrives at the server from the client, the server
      uses the 5-tuple in the message to identify the associated allocation.
      For all TURN messages (including ChannelData) EXCEPT an Allocate
      request, if the 5-tuple does not identify an existing allocation, then
      the message MUST either be rejected with a 437 Allocation Mismatch error
      (if it is a request), or silently ignored (if it is an indication or a
      ChannelData message). A client receiving a 437 error response to a
      request other than Allocate MUST assume the allocation no longer
      exists.
</p>
<p>The username and password of the allocation is the username and
      password of the authenticated Allocate request that creates the
      allocation. Subsequent requests on an allocation use the same username
      and password as those used to create the allocation, to prevent
      attackers from hijacking the client's allocation. Specifically, if the
      server requires the use of the Long-Term Credential mechanism, and if a
      non-Allocate request passes authentication under this mechanism, and if
      the 5-tuple identifies an existing allocation, but the request does not
      use the same username as used to create the allocation, then the request
      MUST be rejected with a 438 (Wrong Credentials) error.
</p>
<p>The transaction ID of the allocation is the transaction ID used in
      the Allocate request. This is used to detect retransmissions of the
      Allocate request over UDP (see <a class='info' href='#sec-rcv-allocate'>Section&nbsp;6.2<span> (</span><span class='info'>Receiving an Allocate Request</span><span>)</span></a>
      for details).
</p>
<p>The bandwidth is the maximum bandwidth between the client and the
      server that the client expects to need (in either direction). The server
      MAY choose to police this value and refuse allocations to ensure that
      the total bandwidth across all allocations does not exceed the server's
      capacity. Servers that do so SHOULD require that an allocation's
      bandwidth lie within two values: the minimum per-allocation bandwidth
      and the maximum per-allocation bandwidth.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Readers should be aware that the details around bandwidth
          are still preliminary. The present description is likely to change,
          perhaps significantly, before the specification is finalized.
</p>
</blockquote>

<p>The time-to-expiry is the time in seconds left until the allocation
      expires. Each Allocate or Refresh transaction sets this timer, which
      then ticks down towards 0. By default, each Allocate or Refresh
      transaction resets this timer to 600 seconds (10 minutes), but the
      client can request a different value in the Allocate and Refresh
      request. Allocations can only be refreshed using the Refresh request;
      sending data to a peer does not refresh an allocation. When an
      allocation expires, the state data associated with the allocation is
      freed. However the server MUST ensure that neither the relayed transport
      address nor the client reflexive transport address from the 5-tuple are
      re-used in other allocations until 2 minutes after the allocation
      expires; this ensures that any messages that are in transit when the
      allocation expires are gone before either of these transport addresses
      are re-used.
</p>
<p>The list of permissions is described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a> and the list of channels is described
      in <a class='info' href='#sec-channels'>Section&nbsp;10<span> (</span><span class='info'>Channels</span><span>)</span></a>.
</p>
<a name="sec-create-allocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Creating an Allocation</h3>

<p>An allocation on the server is created using an Allocate
      transaction.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Sending an Allocate Request</h3>

<p>The client forms an Allocate request as follows.
</p>
<p>The client first needs to pick a host transport address that the
        server does not think is currently in use, or was recently in use. The
        client SHOULD pick a currently-unused transport address on the
        client's host (typically by allowing its OS to pick a currently-unused
        port for a new socket).
</p>
<p>The client needs to pick a transport protocol to use between the
        client and the server. The transport protocol MUST be one of UDP, TCP,
        or TLS over TCP. Since this specification only allows UDP between the
        server and the peers, it is RECOMMENDED that the client pick UDP
        unless it has a reason to use a different transport. One reason to
        pick a different transport would be that the client believes, either
        through configuration or by experiment, that it is unable to contact
        any TURN server using UDP. See <a class='info' href='#sec-transports'>Section&nbsp;2.1<span> (</span><span class='info'>Transports</span><span>)</span></a>
        for more discussion.
</p>
<p>The client must also pick a server transport address. Typically,
        this is done by the client learning (perhaps through configuration)
        one or more domain names for TURN servers. In this case, the client
        uses the DNS procedures described in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>, but using an SRV service
        name of "turn" (or "turns" for TURN over TLS) instead of "stun" (or
        "stuns"). For example, to find servers in the example.com domain, the
        client performs a lookup for '_turn._udp.example.com',
        '_turn._tcp.example.com', and '_turns._tcp.example.com' if the client
        wants to communicate with the server using UDP, TCP, or TLS over TCP,
        respectively.
</p>
<p>The client MUST include a REQUESTED-TRANSPORT attribute in the
        request. This attribute specifies the transport protocol between the
        server and the peers (note: NOT the one in the 5-tuple). In this
        specification, the REQUESTED-TRANSPORT type is always UDP. This
        attribute is included to allow future extensions specify other
        protocols (e.g., <a class='info' href='#I-D.ietf-behave-turn-tcp'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;tcp]<span> (</span><span class='info'>Perreault, S. and J. Rosenberg, &ldquo;Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations,&rdquo; March&nbsp;2010.</span><span>)</span></a>).
</p>
<p>The client MAY include a BANDWIDTH attribute, describing the
        maximum bandwidth that the client expects to exchange between it and
        the server over this allocation. This is just a request, and the
        server may elect to use a different value. If the client omits this
        attribute, the server will pick a bandwidth for the allocation.
</p>
<p>If the client wishes the server to initialize the time-to-expire
        field of the allocation to some value other the default lifetime, then
        it MAY include a LIFETIME attribute specifying its desired value. This
        is just a request, and the server may elect to use a different value.
        Note that the server will ignore requests to initialize the field to
        less than the default value.
</p>
<p>If the client wishes to communicate with older peers that make
        certain assumptions about the port numbers that an endpoint uses, then
        it MAY include either a REQUESTED-PROPS attribute or a
        RESERVATION-TOKEN attribute (but not both). Using the REQUESTED-PROPS
        attribute, the client can request:</p>
<ul class="text">
<li>That the server allocate a relayed transport address with an
            even port number, OR
</li>
<li>That the server reserve a pair of relayed transport addresses
            with adjacent port numbers N and N+1, where N is even and N+1 is
            odd, and then use port N for the current allocation. In this case,
            the server returns a RESERVATION-TOKEN attribute in the response
            which the client can then include in a subsequent Allocate request
            to create an allocation with port number N+1.
</li>
</ul>

<p>The client then sends the allocation on the 5-tuple.
</p>
<a name="sec-rcv-allocate"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Receiving an Allocate Request</h3>

<p>When the server receives an Allocate request, it performs the
        following checks:</p>
<ol class="text">
<li>The server checks the credentials of the request, as per the
            Long-Term Credential mechanism of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</li>
<li>The server checks if the 5-tuple is currently in use by an
            existing allocation, or was it in use by another allocation within
            the last 2 minutes. If yes, then there are two sub-cases:
<ul class="text">
<li>If the transport protocol in the 5-tuple is UDP, and if the
                5-tuple is currently in use by an existing allocation, and if
                the transaction id of the request matches the transaction id
                stored with the allocation, then the request is a
                retransmission of the original request. The server replies
                either with a stored copy of the original response, or with a
                response rebuilt from the stored state data. If the server
                chooses to rebuild the response, then (a) it need not parse
                the request further, but can immediately start building a
                success response, (b) the value of the LIFETIME attribute can
                be set to the current value of the time-to-expire timer, and
                (c) the server may need to include an extra field in the
                allocation to store the token returned in a RESERVATION-TOKEN
                attribute.
</li>
<li>Otherwise, the server rejects the request with a 437
                (Allocation Mismatch) error.
</li>
</ul>NOTE: If the request includes credentials that are
            acceptable to server, but the 5-tuple is already in use, then it
            is important that the server reject the request with a 437
            (Allocation Mismatch) error rather than a 401 (Unauthorized)
            error. This ensures that the client knows that the problem is with
            the 5-tuple, rather than (wrongly) believing that the problem lies
            with its credentials.
</li>
<li>The server checks if the request contain a REQUESTED-TRANPORT
            attribute. If the REQUESTED-TRANSPORT attribute is not included or
            is malformed, the server rejects the request with a 400 (Bad
            Request) error. Otherwise, if the attribute is included but
            specifies a protocol other that UDP, the server rejects the
            request with a 422 (Unsupported Transport Protocol) error.
</li>
<li>The server checks if the request contains a BANDWIDTH
            attribute. If yes, but the attribute is malformed or is out of
            range, the server rejects the request with a 400 (Bad Request)
            error. Otherwise, the server checks if it is willing to grant the
            bandwidth request. The details of this check are described below.
            If the server is not willing, it rejects the request with a 507
            (Insufficient Bandwidth Capacity) error.
</li>
<li>The server checks if the request contains a REQUESTED-PROPS
            attribute. If yes, then the server checks if it understands the
            prop-type and can satisfy the request. If the prop-type is not
            understood, or if the server cannot satisfy the request, then the
            server rejects the request with a 508 (Insufficient Port Capacity)
            error.
</li>
<li>The server checks if the request contains a RESERVATION-TOKEN
            attribute. If yes, and the request also contains a REQUESTED-PROPS
            attribute, then the server rejectes the request with a 400 (Bad
            Request) error. Otherwise it checks to see if the token is valid
            (i.e., the token is in range and has not expired, and the
            corresponding relayed transport address is still available). If
            the token is not valid for some reason, the server rejects the
            request with a 508 (Insufficient Port Capacity) error.
</li>
<li>At any point, the server MAY also choose to reject the request
            with a 486 (Allocation Quota Reached) error if it feels the client
            is trying to exceed some locally-defined allocation quota. The
            server is free to define this allocation quota any way it wishes,
            but SHOULD define it based on the username used to authenticate
            the request, and not on the client's transport address.
</li>
</ol>

<p>If the server rejects the request with one of the error codes 422
        (Unsupported Transport Protocol), 486 (Allocation Quota Reached), 507
        (Insufficient Bandwidth Capacity) or 508 (Insufficient Port Capacity),
        it MAY include an ALTERNATE-SERVER attribute in the error response
        redirecting the client to another server that it believes will accept
        the request. If the attribute is included, the address MUST be from
        the same address family as the server's transport address. Note that,
        if the attribute is included, the client will try this alternate
        server before trying the other servers given by the SRV
        procedures.
</p>
<p>If all the checks pass, the server creates the allocation. The
        5-tuple is set to the 5-tuple from the Allocate request, while the
        list of permissions and the list of channels are initially empty.
</p>
<p>When allocating a relayed transport address for the allocation, the
        server MUST allocate an IP address of the same family (e.g, IPv4 vs.
        IPv6) as the server's transport address. </p>
<blockquote class="text">
<p>NOTE: An extension to TURN to allow an address from a different
            address family is currently in progress <a class='info' href='#I-D.ietf-behave-turn-ipv6'>[I&#8209;D.ietf&#8209;behave&#8209;turn&#8209;ipv6]<span> (</span><span class='info'>Camarillo, G., Novo, O., and S. Perreault, &ldquo;Traversal Using Relays around NAT (TURN) Extension for IPv6,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
</p>
</blockquote><p>In addition, the server SHOULD only allocate ports from the
        range 49152 &ndash; 65535 (the Dynamic and/or Private Port range <a class='info' href='#Port-Numbers'>[Port&#8209;Numbers]<span> (</span><span class='info'>, &ldquo;IANA Port Numbers Registry,&rdquo; .</span><span>)</span></a>), unless the TURN server application
        knows, through some means not specified here, that other applications
        running on the same host as the TURN server application will not be
        impacted by allocating ports outside this range. This condition can
        often be satisfied by running the TURN server application on a
        dedicated machine and/or by arranging that any other applications on
        the machine allocate ports before the TURN server application starts.
        In any case, the TURN server SHOULD NOT allocate ports in the range 0
        - 1023 (the Well-Known Port range) to discourage clients from using
        TURN to run standard services.
</p>
<p>If the request contains a REQUESTED-PROPS attribute requesting a
        pair of ports, then the server looks for a pair of port numbers N and
        N+1 on the same IP address, where N is even. Port N is used in the
        current allocation, while the relayed transport address with port N+1
        is assigned a token and reserved for a future allocation. The server
        MUST hold this reservation for at least 30 seconds, and MAY choose to
        hold longer (e.g. until the allocation with port N expires). The
        server then includes the token in a RESERVATION-TOKEN attribute in the
        success response.
</p>
<p>If the request contains a RESERVATION-TOKEN, the server uses the
        previously-reserved transport address corresponding to the included
        token (if it is still available).
</p>
<p>The server determines the initial value of the allocation's
        bandwidth as follows. If the BANDWIDTH attribute was not included, or
        if the requested bandwidth is less than the minimum per-allocation
        bandwidth, then the server behaves as if the minimum per-allocation
        bandwidth was requested. Otherwise, if the request bandwidth is
        greater than the maximum per-allocation bandwidth, then the server
        behaves as if the maximum per-allocation bandwidth was requested.
</p>
<p>The server then check if the (updated) requested bandwidth is
        available, and if necessary reduces the requested bandwidth to the
        amount that is willing to grant. If the result less than the minimum
        per-allocation bandwidth, then the server considers the request to be
        unsatisfiable, and rejects the request with a 507 (Insufficient
        Bandwidth Capacity) error. Otherwise, the requested bandwidth becomes
        the bandwidth of the allocation.
</p>
<p>The server determines the initial value of the time-to-expire field
        as follows. If the request contains a LIFETIME attribute, and the
        proposed lifetime value is greater than the default lifetime, and the
        proposed lifetime value is otherwise acceptable to the server, then
        the server uses that value. Otherwise, the server uses the default
        value. It is RECOMMENDED that the server impose a maximum lifetime of
        no more than 3600 seconds (1 hour).
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Both the bandwidth and the time-to-expire are recomputed
            with each successful Refresh request. Thus the values computed
            here apply only until the first refresh.
</p>
</blockquote>

<p>Once the allocation is created, the server replies with a success
        response. The success response contains:</p>
<ul class="text">
<li>A RELAYED-ADDRESS attribute containing the relayed transport
            address;
</li>
<li>A LIFETIME attribute containing the current value of the
            time-to-expire timer;
</li>
<li>A BANDWIDTH attribute containing the actual bandwidth of the
            allocation; and
</li>
<li>A RESERVATION-TOKEN attribute (if a second relayed transport
            address was reserved).
</li>
<li>An XOR-MAPPED-ADDRESS attribute containing the client's IP
            address and port (from the 5-tuple);
</li>
</ul>

<p></p>
<blockquote class="text">
<p>NOTE: The XOR-MAPPED-ADDRESS attribute is included in the
            response as a convenience to the client. TURN itself does not make
            use of this value, but clients running ICE can often need this
            value and can thus avoid having to do an extra Binding transaction
            with some STUN server to learn it.
</p>
</blockquote>

<p>The response (either success or error) is sent back to the client
        on the 5-tuple.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Receiving an Allocate Response</h3>

<p>If the client receives a success response, then it MUST check that
        the relayed transport address is in an address family that the client
        understands and is prepared to deal with. This specification only
        covers the case where the relayed transport address is of the same
        address family as the client's transport address. If the relayed
        transport address is not in an address family that the client is
        prepared to deal with, then the client MUST delete the allocation
        (<a class='info' href='#sec-refreshing-allocation'>Section&nbsp;7<span> (</span><span class='info'>Refreshing an Allocation</span><span>)</span></a>) and MUST NOT
        attempt to create another allocation on that server until it believes
        the mismatch has been fixed.
</p>
<p>Otherwise, the client creates its own copy of the allocation data
        structure to track what is happening on the server. In particular, the
        client needs to remember the actual lifetime and the actual bandwith
        received back from the server, rather than the values sent to the
        server in the request. The client must also remember the 5-tuple used
        for the request and the username and password it used to authenticate
        the request to ensure that it reuses them for subsequent messages. The
        client also needs to track the channels and permissions it establishes
        on the server.
</p>
<p>The client will probably wish to send the relayed transport address
        to peers (using some method not specified here) so the peers can
        communicate with it. The client may also wish to use the
        server-reflexive address it receives in the XOR-MAPPED-ADDRESS
        attribute in its ICE processing.
</p>
<p>If the client receives an error response, then the processing
        depends on the actual error code returned:</p>
<ul class="text">
<li>(Request timed out): There is either a problem with the server,
            or a problem reaching the server with the chosen transport. The
            client MAY choose to try again using a different transport (e.g.,
            TCP instead of UDP), or the client MAY try a different server.
</li>
<li>400 (Bad Request): The server believes the client's request is
            malformed for some reason. The client MAY notify the user or
            operator and SHOULD NOT retry the same request with this server
            until it believes the problem has been fixed. The client MAY try a
            different server.
</li>
<li>401 (Unauthorized): If the client has followed the procedures
            of the Long-Term Credential mechanism and still gets this error,
            then the server is not accepting the client's credentials. The
            client SHOULD notify the user or operator and SHOULD NOT send any
            further requests to this server until it believes the problem has
            been fixed. The client MAY try a different server.
</li>
<li>437 (Allocation Mismatch): This indicates that the client has
            picked a 5-tuple which the server sees as already in use or which
            was recently in use. One way this could happen is if an
            intervening NAT assigned a mapped transport address that was
            recently used by another allocation. The client SHOULD pick
            another client transport address and retry the Allocate request
            (using a different transaction id). The client SHOULD try three
            different client transport addresses before giving up on this
            server. Once the client gives up on the server, it SHOULD NOT try
            to create another allocation on the server for 2 minutes.
</li>
<li>438 (Wrong Credentials): The client should not receive this
            error in response to a Allocate request. The client MAY notify the
            user or operator and SHOULD NOT retry the same request with this
            server until it believes the problem has been fixed. The client
            MAY try a different server.
</li>
<li>442 (Unsupported Transport Address): The client should not
            receive this error in response to a request for a UDP allocation.
            The client MAY notify the user or operator and SHOULD NOT retry
            the same request with this server until it believes the problem
            has been fixed. The client MAY try a different server.
</li>
<li>486 (Allocation Quota Reached): The server is currently unable
            to create any more allocations with this username. The client
            SHOULD wait at least 1 minute before trying to create any more
            allocations on the server. The client MAY try a different
            server.
</li>
<li>507 (Insufficient Bandwidth Capacity): The server is currently
            unable to allocate any bandwidth to this allocation. The client
            SHOULD wait at least 1 minute before trying to create any more
            allocations on the server. The client MAY try a different
            server.
</li>
<li>508 (Insufficient Port Capacity): The server has no more
            relayed transport addresses avaiable, or has none with the
            requested properties, or the one that was reserved is no longer
            available. If the client is using either the REQUESTED-PROPS or
            the RESERVATION-TOKEN attribute, then the client MAY choose to
            remove this attribute and try again immediately. Otherwise, the
            client SHOULD wait at least 1 minute before trying to create any
            more allocations on this server. The client MAY try a different
            server.
</li>
</ul><p>If the error response contains an ALTERNATE-SERVER attribute,
        and the client elects to try a different server, the the client SHOULD
        try the alternate server specified in that attribute (while obeying
        the rules in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> for
        avoiding redirection loops) before trying any other servers found
        using the SRV procedures of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>.
</p>
<a name="sec-refreshing-allocation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Refreshing an Allocation</h3>

<p>A Refresh transaction can be used to either (a) refresh an existing
      allocation and update its time-to-expire and bandwidth, or (b) delete an
      existing allocation.
</p>
<p>If a client wishes to continue using an allocation, then the client
      MUST refresh it before it expires. It is suggested that the client
      refresh the allocation roughly 1 minute before it expires. If a client
      no longer wishes to use an allocation, then it SHOULD explicitly delete
      the allocation. A client MAY also change the bandwidth and/or the
      time-to-expire of an allocation at any time for other reasons.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Sending a Refresh Request</h3>

<p>If the client wishes to immediately delete an existing allocation,
        it includes a LIFETIME attribute with a value of 0. All other forms of
        the request refresh the allocation.
</p>
<p>The Refresh transaction updates the time-to-expire timer of an
        allocation. If the client wishes the server to set the time-to-expire
        timer to something other than the default lifetime, it includes a
        LIFETIME attribute with the requested value. The server then computes
        a new time-to-expire value in the same way as it does for an Allocate
        transaction, with the exception that a requested lifetime of 0 causes
        the server to immediately delete the allocation.
</p>
<p>The Refresh transaction also updates the bandwidth of an
        allocation. If the client wishes the server to update the bandwidth to
        something other than the mimimum per-allocation bandwidth, it includes
        the BANDWIDTH attribute with the requested value.
</p>
<p>The Refresh transaction is sent on the 5-tuple for the
        allocation.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Receiving a Refresh Request</h3>

<p>When the server receives a Refresh request, it processes it as
        follows. If, during processing, an error in the request is detected
        (for example, a syntax error in the request which causes a 400 error),
        then the request is rejected with an error response but the allocation
        is NOT deleted (but note that a 437 error will indicate that the
        allocation was not found).
</p>
<p>The server determines the new value for the time-to-expire field as
        follows. If the request contains a LIFETIME attribute, and the
        attribute value is 0, then the server uses a value of 0, which causes
        the allocation to expire. Otherwise, if the request contains a
        LIFETIME attribute and the attribute value is greater than the default
        lifetime, and the attribute value is otherwise acceptable to the
        server, then the server uses the attribute value. Otherwise, the
        server uses the default value. It is RECOMMENDED that the server
        impose a maximum lifetime of no more than 3600 seconds (1 hour).
</p>
<p>Assuming the allocation is not now expired, the server then
        determines a new value for the bandwidth as follows. If the request
        contains a BANDWIDTH attribute, or if the requested bandwidth is less
        than the minimum per-allocation bandwidth, then the server behaves as
        if the minimum per-allocation bandwidth was requested. Otherwise, if
        the request bandwidth is greater than the maximum per-allocation
        bandwidth, then the server behaves as if the maximum per-allocation
        bandwidth was requested.
</p>
<p>The server then compares the requested allocation bandwidth with
        the current allocation bandwidth. If the requested bandwidth is
        smaller, the current allocation bandwidth is updated. If the requested
        bandwidth is larger, then the current allocation bandwidth is
        increased to either the requested bandwidth or to the maximum
        currently available, whichever is smaller.
</p>
<p>The server then constructs a success response containing:</p>
<ul class="text">
<li>A LIFETIME attribute containing the current value of the
            time-to-expire timer; and
</li>
<li>A BANDWIDTH attribute containing the actual bandwidth of the
            allocation.
</li>
</ul><p>The response is then sent on the 5-tuple.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Receiving a Refresh Response</h3>

<p>If the client receives a success response to its Refresh request,
        it updates its copy of the allocation data structure with the
        bandwidth and time-to-expire values contained in the response.
</p>
<p>If the client receives an 437 (Allocation Mismatch) error response
        to its Refresh request, then it must consider the allocation as having
        expired, as described in <a class='info' href='#sec-general-behavior'>Section&nbsp;4<span> (</span><span class='info'>General Behavior</span><span>)</span></a>.
        All other errors indicate a software error on the part of either the
        client or the server.
</p>
<a name="sec-permissions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Permissions</h3>

<p>For each allocation, the server keeps a list of zero or more
      permissions. Each permission consists an IP address which uniquely
      identifies the permission, and an associated time-to-expiry. The IP
      address describes a peer that is allowed to send data to the client, and
      the time-to-expiry is the number of seconds until the permission
      expires.
</p>
<p>Various events, as described in subsequent sections, can cause a
      permission for a given IP address to be installed or refreshed. This
      causes one of two things to happen:</p>
<ul class="text">
<li>If no permission for that IP address exists, then a permission is
          created with the given IP address and a time-to-expiry equal to the
          default permission lifetime.
</li>
<li>If a permission for that IP address already exists, then the
          lifetime for that permission is reset to the default permission
          lifetime.
</li>
</ul><p>The default permission lifetime MUST be 300 seconds (= 5
      minutes).
</p>
<p>Each permission&rsquo;s time-to-expire decreases down once per second
      until it reaches 0, at which point the permission expires and is
      deleted.
</p>
<p>When a UDP datagram arrives at the relayed transport address for the
      allocation, the server checks the list of permissions for that
      allocation. If there is a permission with an IP address that is equal to
      the source IP address of the UDP datagram, then the UDP datagram can be
      relayed to the client. Otherwise, the UDP datagram is silently
      discarded. Note that only IP addresses are compared; port numbers are
      irrelevant.
</p>
<p>The permissions for one allocation are totally unrelated to the
      permissions for a different allocation. If an allocation expires, all
      its permissions expire with it.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Though TURN permissions expire after 5 minutes, many NATs
          deployed at the time of publication expire their UDP bindings
          considerably faster. Thus an application using TURN will probably
          wish to send some sort of keep-alive traffic at a much faster rate.
          Applications using ICE should follow the keep-alive guidelines of
          ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>, and applications not
          using ICE are advised to do something similar.
</p>
</blockquote>

<a name="sec-sendanddata"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Send and Data Indications</h3>

<p>TURN supports two ways to send and receive data from peers. This
      section describes the use of Send and Data indications, while <a class='info' href='#sec-channels'>Section&nbsp;10<span> (</span><span class='info'>Channels</span><span>)</span></a> describes the use of the Channel
      Mechanism.
</p>
<a name="sec-forming-indication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Sending a Send Indication</h3>

<p>A client can use a Send Indication to pass data to the server for
        relaying to a peer. A client can also use a Send Indication without a
        DATA attribute to install or refresh a permission for the specified IP
        address. A client may use a Send indication to send data to a peer
        even if a channel is bound to that peer.
</p>
<p>When forming a Send Indication, the client MUST include a
        PEER-ADDRESS attribute and MAY include a DATA attribute. If the DATA
        attribute is included, then the DATA attribute contains the actual
        application data to be sent to the peer, and the PEER-ADDRESS
        attribute contains the transport address of the peer to which the data
        is to be sent. If the DATA attribute is not present, then the
        PEER-ADDRESS attribute contains the IP address for which a permission
        is to be installed or refreshed; in this case the port specified in
        the attribute is ignored.
</p>
<p>Note that no authentication attributes are included, since
        indications cannot be authenticated using the Long-Term Credential
        mechanism.
</p>
<p>The Send Indication MUST be sent using the same 5-tuple used for
        the original allocation.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Receiving a Send Indication</h3>

<p>When the server receives a Send indication, it processes it as
        follows.
</p>
<p>If the received Send indication contains a DATA attribute, then it
        forms a UDP datagram as follows:</p>
<ul class="text">
<li>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the Send Indication arrived;
</li>
<li>the destination transport address is taken from the
            PEER-ADDRESS attribute;
</li>
<li>the data following the UDP header is the contents of the value
            field of the DATA attribute.
</li>
</ul><p>The resulting UDP datagram is then sent to the peer. If any
        errors are detected during this process (e.g., the Send indication
        does not contain a PEER-ADDRESS attribute), the received indication is
        silently discarded and no UDP datagram is sent.
</p>
<p>When the server receives a valid Send Indication, either with or
        without a DATA attribute, it also installs or refreshes a permission
        for the IP address contained in the PEER-ADDRESS attribute (see <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>).
</p>
<a name="sec-sending-data-indication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
Receiving a UDP Datagram</h3>

<p>When the server receives a UDP datagram at a currently allocated
        relayed transport address, the server looks up the allocation
        associated with the relayed transport address. It then checks to see
        if relaying is permitted, as described in section <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>).
</p>
<p>If relaying is permitted, and there is no channel bound to the peer
        that sent the UDP datagram (see I<a class='info' href='#sec-channels'>Section&nbsp;10<span> (</span><span class='info'>Channels</span><span>)</span></a>),
        then the server forms and sends a Data indication. The Data indication
        MUST contain both a PEER-ADDRESS and a DATA attribute. The DATA
        attribute is set to the value of the &lsquo;data octets&rsquo; field
        from the datagram, and the PEER-ADDRESS attribute is set to the source
        transport address of the received UDP datagram. The Data indication is
        then sent on the 5-tuple associated with the allocation.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.4"></a><h3>9.4.&nbsp;
Receiving a Data Indication</h3>

<p>When the client receives a Data indication, it checks that the Data
        indication contains both a PEER-ADDRESS and a DATA attribute. It then
        delivers the data octets inside the DATA attribute to the application,
        along with an indication that they were received from the peer whose
        transport address is given by the PEER-ADDRESS attribute.
</p>
<a name="sec-channels"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Channels</h3>

<p>Channels provide a way for the client and server to send application
      data using ChannelData messages, which have less overhead than Send and
      Data indications.
</p>
<p>Channel bindings are always initiated by the client. The client can
      bind a channel to a peer at any time during the lifetime of the
      allocation. The client may bind a channel to a peer before exchanging
      data with it, or after exchanging data with it (using Send and Data
      indications) for some time, or may choose never to bind a channel it.
      The client can also bind channels to some peers while not binding
      channels to other peers.
</p>
<p>Channel bindings are specific to an allocation, so that a binding in
      one allocation has no relationship to a binding in any other allocation.
      If an allocation expires, all its channel bindings expire with it.
</p>
<p>A channel binding consists of:</p>
<ul class="text">
<li>A channel number;
</li>
<li>A transport address (of the peer);
</li>
<li>A time-to-expiry timer.
</li>
</ul><p>Within the context of an allocation, a channel binding is
      uniquely identified either by the channel number or by the transport
      address. Thus the same channel cannot be bound to two different
      transport addresses, nor can the same transport address be bound to two
      different channels.
</p>
<p>A channel binding last for 10 minutes unless refreshed. Refreshing
      the binding (by the server receiving either a ChannelBind request
      rebinding the channel to the same peer, or by the server receiving a
      ChannelData message on that channel) resets the time-to-expire timer
      back to 10 minutes. When the channel binding expires, the channel
      becomes unbound and available for binding to a different transport
      address.
</p>
<p>When binding a channel to a peer, the client SHOULD be prepared to
      receive ChannelData messages on the channel from the server as soon as
      it has sent the ChannelBind request. Over UDP, it is possible for the
      client to receive ChannelData messages from the server before it
      receives a ChannelBind success response.
</p>
<p>In the other direction, the client MAY elect to send ChannelData
      messages before receiving the ChannelBind success response. Doing so,
      however, runs the risk of having the ChannelData messages dropped by the
      server if the ChannelBind request does not succeed for some reason
      (e.g., packet lost if the request is sent over UDP, or the server being
      unable to fulfill the request). A client that wishes to be safe should
      either queue the data, or use Send indications until the channel binding
      is confirmed.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Sending a ChannelBind Request</h3>

<p>A channel binding is created using a ChannelBind transaction. A
        channel binding can also be refreshed using a ChannelBind
        transaction.
</p>
<p>To initiate the ChannelBind transaction, the client forms a
        ChannelBind request. The channel to be bound is specified in a
        CHANNEL-NUMBER attribute, and the peer's transport address is
        specified in a PEER-ADDRESS attribute. <a class='info' href='#sec-receiving-ChannelBind'>Section&nbsp;10.2<span> (</span><span class='info'>Receiving a ChannelBind Request</span><span>)</span></a> describes the restrictions
        on these attributes.
</p>
<p>Note that rebinding a channel to the same transport address that it
        is already bound to provides a way to refresh a channel binding
        without sending data to the peer.
</p>
<p>Once formed, the ChannelBind Request is sent using the 5-tuple for
        the allocation.
</p>
<a name="sec-receiving-ChannelBind"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Receiving a ChannelBind Request</h3>

<p>When the server receives a ChannelBind request, it checks the
        following:</p>
<ul class="text">
<li>The request contains both a CHANNEL-NUMBER and a PEER-ADDRESS
            attribute;
</li>
<li>The channel number is in the range 0x4000 to 0xFFFE
            (inclusive);
</li>
<li>The channel number is not currently bound to a different
            transport address (same transport address is OK);
</li>
<li>The transport address is not currently bound to a different
            channel number.
</li>
</ul><p>If any of these tests fail, the server replies with an error
        response with error code 400 "Bad Request". Otherwise, the ChannelBind
        request is valid and the server replies with a ChannelBind success
        response.
</p>
<p>If ChannelBind request is valid, then the server creates or
        refreshes the channel binding using the channel number in the
        CHANNEL-ADDRESS attribute and the transport address in the
        PEER-ADDRESS attribute. The server also installs or refreshes a
        permission for the IP address in the PEER-ADDRESS attribute.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Receiving a ChannelBind Response</h3>

<p>When the client receives a successful ChannelBind response, it
        updates its data structures to record that the channel binding is now
        active.
</p>
<a name="sec-channeldata-msg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
The ChannelData Message</h3>

<p>The ChannelData message is used to carry application data between
        the client and the server. It has the following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Channel Number        |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                       Application Data                        /
/                                                               /
|                                                               |
|                               +-------------------------------+
|                               |
+-------------------------------+</pre></div>
<p>The Channel Number field specifies the number of the channel on
        which the data is traveling, and thus the address of the peer that is
        sending or is to receive the data. The channel number MUST be in the
        range 0x4000 &ndash; 0xFFFF, with channel number 0xFFFF being reserved
        for possible future extensions.
</p>
<p>Channel numbers 0x0000 &ndash; 0x3FFF cannot be used because bits 0
        and 1 are used to distinguish ChannelData messages from STUN-formatted
        messages (i.e., Allocate, Send, Data, ChannelBind, etc).
        STUN-formatted messages always have bits 0 and 1 as &ldquo;00&rdquo;,
        while ChannelData messages use combinations &ldquo;01&rdquo;,
        &ldquo;10&rdquo;, and &ldquo;11&rdquo;.
</p>
<p>The Length field specifies the length in bytes of the application
        data field (i.e., it does not include the size of the ChannelData
        header). Note that 0 is a valid length.
</p>
<p>The Application Data field carries the data the client is trying to
        send to the peer, or that the peer is sending to the client.
</p>
<a name="sec-sending-channeldata-msg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
Sending a ChannelData Message</h3>

<p>Once a client has bound a channel to a peer, then when the client
        has data to send to that peer it may use either a ChannelData message
        or a Send Indication; that is, the client is not obligated to use the
        channel when it exists and may freely intermix the two message types
        when sending data to the peer. The server, on the other hand, MUST use
        the ChannelData message if a channel has been bound to the peer.
</p>
<p>The fields of the ChannelData message are filled in as described in
        <a class='info' href='#sec-channeldata-msg'>Section&nbsp;10.4<span> (</span><span class='info'>The ChannelData Message</span><span>)</span></a>.
</p>
<p>Over stream transports, the ChannelData message MUST be padded to a
        multiple of four bytes in order to ensure the alignment of subsequent
        messages. The padding is not reflected in the length field of the
        ChannelData message, so the actual size of a ChannelData message
        (including padding) is (4 + Length) rounded up to the nearest multiple
        of 4. Over UDP, the padding is not required but MAY be included.
</p>
<p>The ChannelData message is then sent on the 5-tuple associated with
        the allocation.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6"></a><h3>10.6.&nbsp;
Receiving a ChannelData Message</h3>

<p>The receiver of the ChannelData message uses bits 0 and 1 to
        distinguish it from STUN-formatted messages, as described in <a class='info' href='#sec-channeldata-msg'>Section&nbsp;10.4<span> (</span><span class='info'>The ChannelData Message</span><span>)</span></a>.
</p>
<p>If the ChannelData message is received in a UDP datagram, and if
        the UDP datagram is too short to contain the claimed length of the
        ChannelData message (i.e., the UDP header length field value is less
        than the ChannelData header length field value + 4 + 8), then the
        message is silently discarded.
</p>
<p>If the ChannelData message is received over TCP or over TLS over
        TCP, then the actual length of the ChannelData message is as described
        in <a class='info' href='#sec-sending-channeldata-msg'>Section&nbsp;10.5<span> (</span><span class='info'>Sending a ChannelData Message</span><span>)</span></a>.
</p>
<p>If the ChannelData message is received on a channel which is not
        bound to any peer, then the message is silently discarded.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.7"></a><h3>10.7.&nbsp;
Relaying</h3>

<p>When a server receives a ChannelData message, it first processes it
        as described in the previous section. If no errors are detected, it
        relays the application data to the peer by forming a UDP datagram as
        follows:</p>
<ul class="text">
<li>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the ChannelData message arrived;
</li>
<li>the destination transport address is the transport address to
            which the channel is bound;
</li>
<li>the data following the UDP header is the contents of the data
            field of the ChannelData message.
</li>
</ul><p>The resulting UDP datagram is then sent to the peer.
</p>
<p>If the ChannelData message is valid, then the server refreshes the
        channel binding, and also installs or refreshes a permission for the
        IP address part of the transport address to which the UDP datagram is
        sent (see <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>).
</p>
<p>In the other direction, when the server receives a UDP datagram on
        the relayed transport address associated with an allocation, then it
        first checks to see if it is permitted to relay the datagram. This
        check is done as described in <a class='info' href='#sec-permissions'>Section&nbsp;8<span> (</span><span class='info'>Permissions</span><span>)</span></a>.
        If relaying is permitted, then the server checks to see if there is a
        channel bound to the peer that sent the UDP datagram. If there is,
        then it SHOULD form and send a ChannelData message as described in
        <a class='info' href='#sec-sending-channeldata-msg'>Section&nbsp;10.5<span> (</span><span class='info'>Sending a ChannelData Message</span><span>)</span></a>. If no channel is
        bound to the peer, then it MUST form and send a Data indication as
        described in <a class='info' href='#sec-sending-data-indication'>Section&nbsp;9.3<span> (</span><span class='info'>Receiving a UDP Datagram</span><span>)</span></a>.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IP Header Fields and Path MTU</h3>

<p>This section describes how the server should set various fields in
      the IP header when relaying application data. The requirements here
      document the desired behavior of the server, but it is recognized that
      some of these requirements may be impossible to implement in certain
      environments.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: The recommendations in this section are the result of much
          discussion, and are a compromise between the perfect relaying
          solution and one that can be implemented easily. In particular,
          these recommendations takes into account the following:
</p>
<p></p>
<ul class="text">
<li>TURN allows a TCP, or a TLS over TCP, connection between the
              client and the server, while using a UDP connection between the
              server and a peer. For this reason, the notion of a single
              end-to-end connection does not always exist.
</li>
<li>Many people want to run a TURN server as a process in
              user-space under common operating systems, without requiring the
              server process to have special privileges (such as those
              required to use RAW sockets). One motivation for this is the
              desire to implement a TURN server in a peer application in a
              peer-to-peer overlay to provide relaying functions to other
              peers which reside behind 'bad' NATs; such applications are
              often downloaded by users with very little knowledge of
              computers and networking.
</li>
<li>A process in user-space under many common operating systems
              is rather restricted in which fields in the IP header it can set
              and (even worse) read.
</li>
<li>TURN is the relay solution of last resort. It is intended to
              be used only when a direct connection between the TURN client
              and the peer cannot be established.
</li>
</ul>

</blockquote>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
DiffServ Code Point (DSCP)</h3>

<p>If the client-server connection uses UDP, then the server SHOULD
        read the DSCP from the IP header of the received Data indication or
        ChannelData message and use that DSCP for the corresponding outgoing
        UDP datagram. In the reverse direction, the server SHOULD read the
        DSCP from the arriving UDP datagram and use that DSCP for the
        corresponding outgoing Data indication or ChannelData message.
</p>
<p>If the client-server connection uses TCP (or TLS over TCP), then to
        the extent possible, the server SHOULD read the DSCP from the TCP
        connection whenever it reads a Data indication or a ChannelData
        message from the TCP socket, and use that DSCP for the corresponding
        outgoing UDP datagram. In the reverse direction, the server SHOULD
        read the DSCP from the IP header of the received UDP datagram, and set
        the DSCP of the TCP connection to the same value.
</p>
<p>If, for efficiency or other reasons, the server is unable to read
        the DSCP for every message, then it SHOULD read these values at
        frequent intervals and use the DSCP learned for all outgoing packets
        (in the appropriate direction and on this allocation) until the next
        time it reads the DSCP.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: By copying the DSCP, the server ensures that the
            application data gets consistent QoS treatment along the entire
            path from the client to the peer.
</p>
</blockquote>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
Don't Fragment (DF) bit</h3>

<p>When the client sends a Data indication or ChannelData message to
        the server using UDP IPv4, it SHOULD NOT set the DF (Don't Fragment)
        bit unless the application explicitly requests the bit to be set.
</p>
<p>When the server sends a UDP datagram to a peer over IPv4, or when
        sends a Data indication or a ChannelData message to the client using
        UDP over IPv4, the server SHOULD NOT set the DF bit.
</p>
<p>When using TCP or TLS over TCP, the client and the server MAY let
        the setting of the DF bit be determined by the TCP/IP stack.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: By not setting the DF bit over UDP, the server maximizes
            the chances that the UDP datagram, Data indication, or ChannelData
            message will be delivered. This is consistent with the view that
            TURN is a relay solution of last resort.
</p>
</blockquote>

<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
Other IP Header Fields</h3>

<p>The server SHOULD NOT preserve the ECN (Explicit Congestion
        Notification) field, and MAY preserve thee TTL (Time-To-Live) fields
        when relaying application data.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: The ECN field is not preserved because the view is that
            there are two connections here: one between the client and the
            server, and a second between the server and a peer. For example,
            if the client-server connection uses TCP, then the ECN field
            conveys useful information between the two TCP stacks, but is
            meaningless outside that TCP connection.
</p>
<p>The TTL field need not be preserved because there seems to be
            little chance of a forwarding loop, and because reading the TTL
            field is impossible without using RAW sockets in most
            situations.
</p>
</blockquote>

<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4"></a><h3>11.4.&nbsp;
Path MTU</h3>

<p>Applications using TURN SHOULD follow the guidelines in <a class='info' href='#I-D.ietf-tsvwg-udp-guidelines'>[I&#8209;D.ietf&#8209;tsvwg&#8209;udp&#8209;guidelines]<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; October&nbsp;2008.</span><span>)</span></a>, but use the algorithm
        of <a class='info' href='#RFC4821'>[RFC4821]<span> (</span><span class='info'>Mathis, M. and J. Heffner, &ldquo;Packetization Layer Path MTU Discovery,&rdquo; March&nbsp;2007.</span><span>)</span></a> rather than the algorithm of <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a> to determine the Path MTU. This algorithm
        should be run at the application level (and not at the TURN layer or
        below) and used to discovery the maximum size of a application PDU
        that can be successfully delivered to the far end application.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: According to <a class='info' href='#I-D.ietf-tsvwg-udp-guidelines'>[I&#8209;D.ietf&#8209;tsvwg&#8209;udp&#8209;guidelines]<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; October&nbsp;2008.</span><span>)</span></a>, applications using
            UDP should do Path MTU Discovery. If they do not do Path MTU
            Discovery, then they must restrict their packet size to 576 (over
            IPv4) or 1280 (over IPv6).
</p>
<p>The original Path MTU Discovery algorithm <a class='info' href='#RFC1191'>[RFC1191]<span> (</span><span class='info'>Mogul, J. and S. Deering, &ldquo;Path MTU discovery,&rdquo; November&nbsp;1990.</span><span>)</span></a> will not work because a TURN server does
            not relay ICMP packets.
</p>
<p>The Path MTU Discover algorithm described in <a class='info' href='#RFC4821'>[RFC4821]<span> (</span><span class='info'>Mathis, M. and J. Heffner, &ldquo;Packetization Layer Path MTU Discovery,&rdquo; March&nbsp;2007.</span><span>)</span></a> will work. However, when run over a path
            that goes through a TURN server, it will not discover the Path MTU
            (because the DF bit is not set by the server), but intead will
            discover the maximum size of an application PDU that can be
            delivered between the client and the peer. Applications that limit
            themselves to this discovered size WILL be able to communicate
            effectively, though the application PDU may end up being
            fragmented on the section of the path after the server.
</p>
<p>Applications that instead restrict their packet size to 576 or
            1280 may suffer from the fact that TURN adds some overhead between
            the client and the server. Thus in some situations, these
            applications will see their maximum-sized packets dropped.
            However, this overhead is only 4 bytes when channels are used, so
            the chances of this happening are small.
</p>
</blockquote>

<a name="sec-stun-methods"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
New STUN Methods</h3>

<p>This section lists the codepoints for the new STUN methods defined in
      this specification. See elsewhere in this document for the semantics of
      these new methods.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>  Request/Response Transactions
    0x003  :  Allocate
    0x004  :  Refresh
    0x009  :  ChannelBind

  Indications
    0x006  :  Send
    0x007  :  Data
</pre></div>
<a name="sec-stun-attributes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
New STUN Attributes</h3>

<p>This STUN extension defines the following new
        attributes:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0x000C: CHANNEL-NUMBER
  0x000D: LIFETIME
  0x0010: BANDWIDTH
  0x0012: PEER-ADDRESS
  0x0013: DATA
  0x0016: RELAY-ADDRESS
  0x0018: REQUESTED-PROPS
  0x0019: REQUESTED-TRANSPORT
  0x0022: RESERVATION-TOKEN

</pre></div>
<a name="channelnums"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
CHANNEL-NUMBER</h3>

<p>The CHANNEL-NUMBER attribute contains the number of the channel. It
        is a 16-bit unsigned integer, followed by a two-octet RFFU (Reserved
        For Future Use) field which MUST be set to 0 on transmission and
        ignored on reception.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Channel Number         |         Reserved = 0          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2"></a><h3>13.2.&nbsp;
LIFETIME</h3>

<p>The lifetime attribute represents the duration for which the server
        will maintain an allocation in the absence of a refresh. It is a
        32-bit unsigned integral value representing the number of seconds
        remaining until expiration.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3"></a><h3>13.3.&nbsp;
BANDWIDTH</h3>

<p>The bandwidth attribute represents the peak bandwidth that the
        client expects to use on the client to server connection. It is a
        32-bit unsigned integral value and is measured in kilobits per
        second.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.4"></a><h3>13.4.&nbsp;
PEER-ADDRESS</h3>

<p>The PEER-ADDRESS specifies the address and port of the peer as seen
        from the TURN server. It is encoded in the same way as
        XOR-MAPPED-ADDRESS.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.5"></a><h3>13.5.&nbsp;
DATA</h3>

<p>The DATA attribute is present in all Data Indications and most Send
        Indications. It contains raw payload data that is to be sent (in the
        case of a Send Request) or was received (in the case of a Data
        Indication).
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.6"></a><h3>13.6.&nbsp;
RELAY-ADDRESS</h3>

<p>The RELAY-ADDRESS is present in Allocate responses. It specifies
        the address and port that the server allocated to the client. It is
        encoded in the same way as XOR-MAPPED-ADDRESS.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.7"></a><h3>13.7.&nbsp;
REQUESTED-PROPS</h3>

<p>This attribute allows the client to request certain properties for
        the relayed transport address that is allocated by the server. The
        attribute is 32 bits long. Its format is:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Prop-type   |                  Reserved = 0                 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The field labeled "Prop-type" is an 8-bit field specifying the
        desired property. The rest of the attribute is RFFU (Reserved For
        Future Use) and MUST be set to 0 on transmission and ignored on
        reception. The values of the "Prop-type" field are:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0x00  (Reserved)
  0x01  Even port number
  0x02  Pair of ports

</pre></div>
<p>If the value of the "Prop-type" field is 0x01, then the client is
        requesting the server allocate an even-numbered port for the relayed
        transport address.
</p>
<p>If the value of the "Prop-type" field is 0x02, then client is
        requesting the server allocate an even-numbered port for the relayed
        transport address, and in addition reserve the next-highest port for a
        subsequent allocation.
</p>
<p>All other values of the "Prop-type" field are reserved.
</p>
<a name="sec-requested-transport"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.8"></a><h3>13.8.&nbsp;
REQUESTED-TRANSPORT</h3>

<p>This attribute is used by the client to request a specific
        transport protocol for the allocated transport address. It has the
        following format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Protocol   |                  Reserved = 0                 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>The Protocol field specifies the desired protocol. The codepoints
        used in this field are taken from those allowed in the Protocol field
        in the IPv4 header and the NextHeader field in the IPv6 header <a class='info' href='#Protocol-Numbers'>[Protocol&#8209;Numbers]<span> (</span><span class='info'>, &ldquo;IANA Protocol Numbers Registry,&rdquo; 2005.</span><span>)</span></a>. This specification only allows the
        use of codepoint 17 (User Datagram Protocol).
</p>
<p>The RFFU field is set to zero on transmission and ignored on
        receiption. It is reserved for future uses.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.9"></a><h3>13.9.&nbsp;
RESERVATION-TOKEN</h3>

<p>The RESERVATION-TOKEN attribute contains a token that uniquely
        identifies a relayed transport address being held in reserve by the
        server. The server includes this attribute in a success response to
        tell the client about the token, and the client includes this
        attribute in a subsequent Allocate request to request the server use
        that relayed transport address for the allocation.
</p>
<p>The attribute value is a 64-bit-long field containing the token
        value.
</p>
<a name="sec-stun-errors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
New STUN Error Response Codes</h3>

<p>This document defines the following new error response codes:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>437</dt>
<dd>(Allocation Mismatch): A request was received by
          the server that requires an allocation to be in place, but there is
          none, or a request was received which requires no allocation, but
          there is one.
</dd>
<dt>438</dt>
<dd>(Wrong Credentials): The credentials in the
          (non-Allocate) request, though otherwise acceptable to the server,
          do not match those used to create the allocation.
</dd>
<dt>442</dt>
<dd>(Unsupported Transport Protocol): The Allocate
          request asked the server to use a transport protocol between the
          server and the peer that the server does not support. NOTE: This
          does NOT refer to the transport protocol used in the 5-tuple.
</dd>
<dt>486</dt>
<dd>(Allocation Quota Reached): No more allocations
          using this username can be created at the present time.
</dd>
<dt>507</dt>
<dd>(Insufficient Bandwidth Capacity): The server
          cannot create an allocation with the requested bandwidth right now
          as it has exhausted its capacity.
</dd>
<dt>508</dt>
<dd>(Insufficient Port Capacity): The server has no
          more relayed transport addresses available right now, or has none
          with the requested properties, or the one that corresponds to the
          specified token is not available.
</dd>
</dl></blockquote>

<a name="sec-security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Security Considerations</h3>

<p>TURN servers allocate bandwidth and port resources to clients, in
      contrast to the Binding method defined in <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>. Therefore, a TURN server
      may require the authentication and authorization of STUN requests. This
      authentication is provided by mechanisms defined in the STUN
      specification itself, in particular digest authentication.
</p>
<p>Because TURN servers allocate resources, they can be susceptible to
      denial-of-service attacks. All Allocate transactions are authenticated,
      so that an unknown attacker cannot launch an attack. An authenticated
      attacker can generate multiple Allocate Requests, however. To prevent a
      single malicious user from allocating all of the resources on the
      server, it is RECOMMENDED that a server implement a modest per user
      limit on the amount of bandwidth that can be allocated. Such a mechanism
      does not prevent a large number of malicious users from each requesting
      a small number of allocations. Attacks such as these are possible using
      botnets, and are difficult to detect and prevent. Implementors of TURN
      should keep up with best practices around detection of anomalous botnet
      attacks.
</p>
<p>A client will use the transport address learned from the
      RELAY-ADDRESS attribute of the Allocate Response to tell other users how
      to reach them. Therefore, a client needs to be certain that this address
      is valid, and will actually route to them. Such validation occurs
      through the message integrity checks provided in the Allocate response.
      They can guarantee the authenticity and integrity of the allocated
      addresses. Note that TURN is not susceptible to the attacks described in
      Section 12.2.3, 12.2.4, 12.2.5 or 12.2.6 of <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a> [[TODO: Update section
      number references to 3489bis]]. These attacks are based on the fact that
      a STUN server mirrors the source IP address, which cannot be
      authenticated. STUN does not use the source address of the Allocate
      Request in providing the RELAY-ADDRESS, and therefore, those attacks do
      not apply.
</p>
<p>TURN attempts to adhere as closely as possible to common firewall
      policies, consistent with allowing data to flow. TURN has fairly limited
      applicability, requiring a user to explicitly authorize permission to
      receive data from a peer, one IP address at a time. Thus, it does not
      provide a general technique for externalizing sockets. Rather, it has
      similar security properties to the placement of an address-restricted
      NAT in the network, allowing messaging in from a peer only if the
      internal client has sent a packet out towards the IP address of that
      peer. This limitation means that TURN cannot be used to run, for
      example, SIP servers, NTP servers, FTP servers or other network servers
      that service a large number of clients. Rather, it facilitates
      rendezvous of NATted clients that use some other protocol, such as SIP,
      to communicate IP addresses and ports for communications.
</p>
<p>Confidentiality of the transport addresses learned through Allocate
      transactions does not appear to be that important. If required, it can
      be provided by running TURN over TLS.
</p>
<p>TURN does not and cannot guarantee that UDP data is delivered in
      sequence or to the correct address. As most TURN clients will only
      communicate with a single peer, the use of a single channel number will
      be very common. Consider an enterprise where Alice and Bob are involved
      in separate calls through the enterprise NAT to their corporate TURN
      server. If the corporate NAT reboots, it is possible that Bob will
      obtain the exact NAT binding originally used by Alice. If Alice and Bob
      were using identical channel numbers, Bob will receive unencapsulated
      data intended for Alice and will send data accidentally to Alice's peer.
      This is not a problem with TURN. This is precisely what would happen if
      there was no TURN server and Bob and Alice instead provided a (STUN)
      reflexive transport address to their peers. If detecting this
      misdelivery is a problem, the client and its peer need to use message
      integrity on their data.
</p>
<p>Relay servers are useful even for users not behind a NAT. They can
      provide a way for truly anonymous communications. A user can cause a
      call to have its media routed through a TURN server, so that the user's
      IP addresses are never revealed.
</p>
<p>Any relay addresses learned through an Allocate request will not
      operate properly with <a class='info' href='#RFC4302'>IPSec Authentication Header
      (AH)<span> (</span><span class='info'>Kent, S., &ldquo;IP Authentication Header,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4302] in transport or tunnel mode. However, tunnel-mode <a class='info' href='#RFC4303'>IPSec ESP<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4303] should still operate.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
IANA Considerations</h3>

<p>Since TURN is an extension to STUN <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; July&nbsp;2008.</span><span>)</span></a>, the methods, attributes and
      error codes defined in this specification are new method, attributes,
      and error codes for STUN. This section directs IANA to add these new
      protocol elements to the IANA registry of STUN protocol elements.
</p>
<p>The codepoints for the new STUN methods defined in this specification
      are listed in <a class='info' href='#sec-stun-methods'>Section&nbsp;12<span> (</span><span class='info'>New STUN Methods</span><span>)</span></a>.
</p>
<p>The codepoints for the new STUN attributes defined in this
      specification are listed in <a class='info' href='#sec-stun-attributes'>Section&nbsp;13<span> (</span><span class='info'>New STUN Attributes</span><span>)</span></a>.
</p>
<p>The codepoints for the new STUN error codes defined in this
      specification are listed in <a class='info' href='#sec-stun-errors'>Section&nbsp;14<span> (</span><span class='info'>New STUN Error Response Codes</span><span>)</span></a>.
</p>
<p>Extensions to TURN can be made through IETF consensus.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
IAB Considerations</h3>

<p>The IAB has studied the problem of "Unilateral Self Address Fixing",
      which is the general process by which a client attempts to determine its
      address in another realm on the other side of a NAT through a
      collaborative protocol reflection mechanism <a class='info' href='#RFC3424'>[RFC3424]<span> (</span><span class='info'>Daigle, L. and IAB, &ldquo;IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation,&rdquo; November&nbsp;2002.</span><span>)</span></a>. The TURN extension is an example of a protocol
      that performs this type of function. The IAB has mandated that any
      protocols developed for this purpose document a specific set of
      considerations.
</p>
<p>TURN is an extension of the STUN protocol. As such, the specific
      usages of STUN that use the TURN extensions need to specifically address
      these considerations. Currently the only STUN usage that uses TURN is
      <a class='info' href='#I-D.ietf-mmusic-ice'>ICE<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a> [I&#8209;D.ietf&#8209;mmusic&#8209;ice].
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18"></a><h3>18.&nbsp;
Example</h3>

<p>TBD
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19"></a><h3>19.&nbsp;
Changes from Previous Versions</h3>

<p>Note to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.
</p>
<p>This section lists the changes between the various versions of this
      specification.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.1"></a><h3>19.1.&nbsp;
Changes from -06 to -07</h3>

<p></p>
<ul class="text">
<li>Rewrote the General Behavior section, making various changes in
            the process.
</li>
<li>Changed the usage of authentication from MUST to SHOULD.
</li>
<li>Changed the requirement that subsequent requests use the same
            username and password from MUST to SHOULD to allow for the
            possibility of changing the credentials using some unspecified
            mechanism.
</li>
<li>Introduced a 438 (Wrong Credentials) error which is used when a
            non-Allocate request authenticates but does not use the same
            username and password as the Allocate request. Having a separate
            error code for this case avoids the client being confused over
            what the error actually is.
</li>
<li>The server must now prevent the relayed transport address and
            the 5-tuple from being reused in different allocations for 2
            minutes after the allocation expires.
</li>
<li>Changed the usage of FINGERPRINT from MUST NOT to MAY, to allow
            for the possible multiplexing of TURN with some other
            protocol.
</li>
<li>Rewrote much of the section on Allocations, splitting it into
            three new sections (one on allocations in general, one on creating
            an allocation, and one on refreshing an allocation).
</li>
<li>Replaced the mechanism for requesting relayed transport
            addresses with specific properties. The new mechanism is less
            powerful: a client can request an even port, or a pair of ports,
            but cannot request a single odd port or a specific port as was
            possible under the old mechanism. Nor can the client request a
            specific IP address.
</li>
<li>Changed the rules for handling ALTERNATE-SERVER, removing the
            requirement that the referring server have "positive knowledge"
            about the state of the alternate server. The new rules instead
            rely on text in STUN to prevent referral loops.
</li>
<li>Changed the rules for allocation lifetimes. Allocations
            lifetimes are now a minimum of 10 minutes; the client can ask for
            longer values, but requests for shorter values are ignored. The
            text now recommends that the client refresh an allocation one
            minute before it expires.
</li>
<li>Put in temporary procedures for handling the BANDWIDTH
            attribute, modelled on the LIFETIME attribute. These procedures
            are mostly placeholders and likely to change in the next
            revision.
</li>
<li>Added a detailed description of how a client reacts to the
            various errors it can receive in reply to an Allocate request.
            This replaces the various descriptions that were previously
            scattered throughout the document, which were inconsistent and
            sometimes contradictory.
</li>
<li>Added a new section that gives the normative rules for
            permissions.
</li>
<li>Changed the rules around permission lifetimes. The text used to
            recommend a value of one minute; it MUST now be 5 minutes.
</li>
<li>Removed the errors "Channel Missing or Invalid", "Peer Address
            Missing or Invalid" and "Lifetime Malformed or Invalid" and used
            400 "Bad Request" instead.
</li>
<li>Rewrote portions of the section on Send and Data indications
            and the section on Channels to try to make the client vs. server
            behavior clearer.
</li>
<li>Channel bindings now expire after 10 minutes, and must be
            refreshed to keep them alive.
</li>
<li>Binding a channel now installs or refreshes a permission for
            the IP address of corresponding peer.
</li>
<li>Changed the wording describing the situation when the client
            sends a ChannelData message before receiving the ChannelBind
            success response. -06 said that client SHOULD NOT do this; -07 now
            says that a client MAY, but describes the consequences of doing
            it.
</li>
<li>Added a section discussing the setting of fields in the IP
            header.
</li>
<li>Replaced the REQUESTED-PORT-PROPS attribute with the
            REQUESTED-PROPS attribute that has a different format and
            semantics, but reuses the same code point.
</li>
<li>Replaced the REQUESTED-IP attribute with the RESERVATION-TOKEN
            attribute, which has a different format and semantics, but reuses
            the same code point.
</li>
<li>Removed error codes 443 and 444, and replaced them with 508
            (Insufficient Port Capacity). Also changed the error text for code
            507 from "Insufficient Capacity" to "Insufficient Bandwidth
            Capacity".
</li>
</ul>

<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.2"></a><h3>19.2.&nbsp;
Changes from -05 to -06</h3>

<p></p>
<ul class="text">
<li>Changed the mechanism for allocating channels to the one
            proposed by Eric Rescorla at the Dec 2007 IETF meeting.
</li>
<li>Removed the framing mechanism (which was used to frame all
            messages) and replaced it with the ChannelData message. As part of
            this change, noted that the demux of ChannelData messages from
            TURN messages can be done using the first two bits of the
            message.
</li>
<li>Rewrote the sections on transmitted and receiving data as a
            result of the above to changes, splitting it into a section on
            Send and Data Indications and a separate section on channels.
</li>
<li>Clarified the handling of Allocate Request messages. In
            particular, subsequent Allocate Request messages over UDP with the
            same transaction id are not an error but a retransmission.
</li>
<li>Restricted the range of ports available for allocation to the
            Dynamic and/or Private Port range, and noted when ports outside
            this range can be used.
</li>
<li>Changed the format of the REQUESTED-TRANSPORT attribute. The
            previous version used 00 for UDP and 01 for TCP; the new version
            uses protocol numbers from the IANA protocol number registry. The
            format of the attribute also changed.
</li>
<li>Made a large number of changes to the non-normative portion of
            the document to reflect technical changes and improve the
            presentation.
</li>
<li>Added the Issues section.
</li>
</ul>

<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.19.3"></a><h3>19.3.&nbsp;
Changes from -04 to -05</h3>

<p></p>
<ul class="text">
<li>Removed the ability to allocate addresses for TCP relaying.
            This is now covered in a separate document. However, communication
            between the client and the server can still run over TCP or
            TLS/TCP. This resulted in the removal of the Connect method and
            the TIMER-VAL and CONNECT-STAT attributes.
</li>
<li>Added the concept of channels. All communication between the
            client and the server flows on a channel. Channels are numbered
            0..65535. Channel 0 is used for TURN messages, while the remaining
            channels are used for sending unencapsulated data to/from a remote
            peer. This concept adds a new Channel Confirmation method and a
            new CHANNEL-NUMBER attribute. The new attribute is also used in
            the Send and Data methods.
</li>
<li>The framing mechanism formally used just for stream-oriented
            transports is now also used for UDP, and the former Type and
            Reserved fields in the header have been replaced by a Channel
            Number field. The length field is zero when running over UDP.
</li>
<li>TURN now runs on its own port, rather than using the STUN port.
            The use of channels requires this.
</li>
<li>Removed the SetActiveDestination concept. This has been
            replaced by the concept of channels.
</li>
<li>Changed the allocation refresh mechanism. The new mechanism
            uses a new Refresh method, rather than repeating the Allocation
            transaction.
</li>
<li>Changed the syntax of SRV requests for secure transport. The
            new syntax is "_turns._tcp" rather than the old "_turn._tls". This
            change mirrors the corresponding change in STUN SRV syntax.
</li>
<li>Renamed the old REMOTE-ADDRESS attribute to PEER-ADDRESS, and
            changed it to use the XOR-MAPPED-ADDRESS format.
</li>
<li>Changed the RELAY-ADDRESS attribute to use the
            XOR-MAPPED-ADDRESS format (instead of the MAPPED-ADDRESS
            format)).
</li>
<li>Renamed the 437 error code from "No Binding" to "Allocation
            Mismatch".
</li>
<li>Added a discussion of what happens if a client's public binding
            on its outermost NAT changes.
</li>
<li>The document now consistently uses the term "peer" as the name
            of a remote endpoint with which the client wishes to
            communicate.
</li>
<li>Rewrote much of the document to describe the new concepts. At
            the same time, tried to make the presentation clearer and less
            repetitive.
</li>
</ul>

<a name="sec-open-issues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.20"></a><h3>20.&nbsp;
Open Issues</h3>

<p>NOTE to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.
</p>
<p>Bandwidth: How should bandwidth be specified? What are the right
      rules around bandwidth?
</p>
<p>Alternate Server: Do we still want this mechanism? Is the current
      proposal acceptable? Note that the usage of the ALTERNATE-SERVER
      attribute in this document is inconsistent with its usage in STUN. In
      STUN, if the ALTERNATE-SERVER attribute is used, then the error that the
      server would otherwise generate is replaced by a 300 (Try Alternate)
      code. In this document, the 300 error code is not used, and the server
      returns an appropriate error code and then includes the ALTERNATE-SERVER
      attribute in the response. In this way, the client can see the actual
      error code, rather than always seeing error code 300, and can thus make
      a more intelligent decision on whether it wishes to try the alternate
      server.
</p>
<p>Public TURN servers: The text currently says that a server "SHOULD"
      use the Long-Term Credential mechanism, with the unstated idea that a
      public TURN server would not use it. But this really weakens the
      security of TURN. Is there a better way to allow public servers? Or
      should we just drop the notion of a public server entirely?
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.21"></a><h3>21.&nbsp;
Acknowledgements</h3>

<p>The authors would like to thank the various participants in the
      BEHAVE working group for their many comments on this draft. Marc
      Petit-Huguenin, Remi Denis-Courmont, Derek MacDonald, Cullen Jennings,
      Lars Eggert, Magnus Westerlund, and Eric Rescorla have been particularly
      helpful, with Eric also suggesting the channel allocation mechanism, and
      Cullen suggesting the REQUESTED-PROPS mechanism. Christian Huitema was
      an early contributor to this document and was a co-author on the first
      few drafts. Finally, the authors would like to thank Dan Wing for both
      his contributions to the text and his huge help in restarting progress
      on this draft after work had stalled.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.22"></a><h3>22.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>22.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-rfc3489bis">[I-D.ietf-behave-rfc3489bis]</a></td>
<td class="author-text">Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-18.txt">Session Traversal Utilities for (NAT) (STUN)</a>,&rdquo; draft-ietf-behave-rfc3489bis-18 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-18.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>22.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1918">[RFC1918]</a></td>
<td class="author-text"><a href="mailto:yakov@cisco.com">Rekhter, Y.</a>, <a href="mailto:rgm3@is.chrysler.com">Moskowitz, R.</a>, <a href="mailto:Daniel.Karrenberg@ripe.net">Karrenberg, D.</a>, <a href="mailto:GeertJan.deGroot@ripe.net">Groot, G.</a>, and <a href="mailto:lear@sgi.com">E. Lear</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1918">Address Allocation for Private Internets</a>,&rdquo; BCP&nbsp;5, RFC&nbsp;1918, February&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1918.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3264">[RFC3264]</a></td>
<td class="author-text">Rosenberg, J. and H. Schulzrinne, &ldquo;<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>,&rdquo; RFC&nbsp;3264, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3264.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3424">[RFC3424]</a></td>
<td class="author-text">Daigle, L. and IAB, &ldquo;<a href="http://tools.ietf.org/html/rfc3424">IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation</a>,&rdquo; RFC&nbsp;3424, November&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3424.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[I-D.ietf-mmusic-ice]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>,&rdquo; draft-ietf-mmusic-ice-19 (work in progress), October&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4787">[RFC4787]</a></td>
<td class="author-text">Audet, F. and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>,&rdquo; BCP&nbsp;127, RFC&nbsp;4787, January&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4787.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn-tcp">[I-D.ietf-behave-turn-tcp]</a></td>
<td class="author-text">Perreault, S. and J. Rosenberg, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-tcp-06.txt">Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations</a>,&rdquo; draft-ietf-behave-turn-tcp-06 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-tcp-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn-ipv6">[I-D.ietf-behave-turn-ipv6]</a></td>
<td class="author-text">Camarillo, G., Novo, O., and S. Perreault, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-ipv6-09.txt">Traversal Using Relays around NAT (TURN) Extension for IPv6</a>,&rdquo; draft-ietf-behave-turn-ipv6-09 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-ipv6-09.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tsvwg-udp-guidelines">[I-D.ietf-tsvwg-udp-guidelines]</a></td>
<td class="author-text">Eggert, L. and G. Fairhurst, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-udp-guidelines-11.txt">Unicast UDP Usage Guidelines for Application Designers</a>,&rdquo; draft-ietf-tsvwg-udp-guidelines-11 (work in progress), October&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-udp-guidelines-11.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1191">[RFC1191]</a></td>
<td class="author-text"><a href="mailto:mogul@decwrl.dec.com">Mogul, J.</a> and <a href="mailto:deering@xerox.com">S. Deering</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>,&rdquo; RFC&nbsp;1191, November&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1191.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4821">[RFC4821]</a></td>
<td class="author-text">Mathis, M. and J. Heffner, &ldquo;<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>,&rdquo; RFC&nbsp;4821, March&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4821.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1928">[RFC1928]</a></td>
<td class="author-text"><a href="mailto:mleech@bnr.ca">Leech, M.</a>, Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &ldquo;<a href="http://tools.ietf.org/html/rfc1928">SOCKS Protocol Version 5</a>,&rdquo; RFC&nbsp;1928, March&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1928.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Port-Numbers">[Port-Numbers]</a></td>
<td class="author-text">&ldquo;<a href="http://www.iana.org/assignments/port-numbers">IANA Port Numbers Registry</a>.&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="Protocol-Numbers">[Protocol-Numbers]</a></td>
<td class="author-text">&ldquo;<a href="http://www.iana.org/assignments/protocol-numbers">IANA Protocol Numbers Registry</a>,&rdquo; 2005.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jonathan Rosenberg</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Edison, NJ</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jdrosen@cisco.com">jdrosen@cisco.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.jdrosen.net">http://www.jdrosen.net</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rohan Mahy</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Plantronics, Inc.</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rohan@ekabal.com">rohan@ekabal.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Philip Matthews</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Avaya, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1135 Innovation Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ottawa, Ontario  K2K 3G7</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Canada</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 613-592-4343 x224</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:philip_matthews@magma.ca">philip_matthews@magma.ca</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
