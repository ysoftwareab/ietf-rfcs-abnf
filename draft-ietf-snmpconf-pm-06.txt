



Internet Draft    Policy-Based Management MIB    June 11, 2001


                 Policy Based Management MIB
                draft-ietf-snmpconf-pm-06.txt
                        June 11, 2001


                       Steve Waldbusser
                         Jon Saperia
                       Thippanna Hongal





Status of this Memo

This document is an Internet-Draft and is in full conformance
with all provisions of Section 10 of RFC2026.

Internet-Drafts are working documents of the Internet
Engineering Task Force (IETF), its areas, and its working
groups.  Note that other groups may also distribute working
documents as Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six
months and may be updated, replaced, or obsoleted by other
documents at any time.  It is inappropriate to use Internet-
Drafts as reference material or to cite them other than as
"work in progress."

The list of current Internet-Drafts can be accessed at
http://www.ietf.org/ietf/1id-abstracts.txt

The list of Internet-Draft Shadow Directories can be accessed
at http://www.ietf.org/shadow.html.

Copyright Notice

   Copyright (C) The Internet Society (2001).  All Rights Reserved.

1.  Abstract

This memo defines a portion of the Management Information Base
(MIB) for use with network management protocols in TCP/IP-
based internets.  In particular, this MIB defines objects that
enable policy-based configuration management of SNMP





Various Authors    Expires December 11, 2001          [Page 1]





Internet Draft    Policy-Based Management MIB    June 11, 2001


infrastructures.

2.  The SNMP Management Framework

   The SNMP Management Framework presently consists of five
   major components:

    o   An overall architecture, described in RFC 2571 [1].

    o   Mechanisms for describing and naming objects and
        events for the purpose of management. The first
        version of this Structure of Management Information
        (SMI) is called SMIv1 and described in STD 16, RFC
        1155 [2], STD 16, RFC 1212 [3] and RFC 1215 [4]. The
        second version, called SMIv2, is described in STD 58,
        RFC 2578 [5], RFC 2579 [6] and RFC 2580 [7].

    o   Message protocols for transferring management
        information. The first version of the SNMP message
        protocol is called SNMPv1 and described in STD 15, RFC
        1157 [8]. A second version of the SNMP message
        protocol, which is not an Internet standards track
        protocol, is called SNMPv2c and described in RFC 1901
        [9] and RFC 1906 [10]. The third version of the
        message protocol is called SNMPv3 and described in RFC
        1906 [10], RFC 2572 [11] and RFC 2574 [12].

    o   Protocol operations for accessing management
        information. The first set of protocol operations and
        associated PDU formats is described in STD 15, RFC
        1157 [8]. A second set of protocol operations and
        associated PDU formats is described in RFC 1905 [13].

    o   A set of fundamental applications described in RFC
        2573 [14] and the view-based access control mechanism
        described in RFC 2575 [15].

   A more detailed introduction to the current SNMP Management
   Framework can be found in RFC 2570 [18].

   Managed objects are accessed via a virtual information
   store, termed the Management Information Base or MIB.
   Objects in the MIB are defined using the mechanisms defined
   in the SMI.






Various Authors    Expires December 11, 2001          [Page 2]





Internet Draft    Policy-Based Management MIB    June 11, 2001


   This memo specifies a MIB module that is compliant to the
   SMIv2. A MIB conforming to the SMIv1 can be produced
   through the appropriate translations. The resulting
   translated MIB must be semantically equivalent, except
   where objects or events are omitted because no translation
   is possible (use of Counter64). Some machine readable
   information in SMIv2 will be converted into textual
   descriptions in SMIv1 during the translation process.
   However, this loss of machine readable information is not
   considered to change the semantics of the MIB.








































Various Authors    Expires December 11, 2001          [Page 3]





Internet Draft    Policy-Based Management MIB    June 11, 2001


3.  Overview

Large IT organizations have developed management strategies to cope
with the extraordinarily large scale and complexity inherent in
today's networks. In particular, they try to configure the network as
a whole by describing and implementing high-level business policies,
rather than managing device by device, where orders of magnitude more
decisions (and mistakes) may be made.

Following this management practice results in the following benefits:
  - Reduced training needs (fewer details to learn)
  - Reduced documentation costs (fewer details to document)
  - Reduced impact of turnover (less ad-hoc knowledge goes out the door)
  - Greater testability (a greater percentage of fielded
    configurations may be tested in the lab)
  - Higher reliability (combination of factors above)
  - Lower cost of changes (changes can be simpler and operate over a
    wider extent)
  - Lower cost of corporate mergers (less knowledge to transfer; fewer
    policies to integrate)
  - Lower cost of ownership (combination of factors above)

To illustrate the concept of "business policies", some examples are:
  - All routers will run code version 6.2
  - On-site contractors will all have special security restrictions on
    their ports
  - All voice over cable ports in California must provide free local
    calling
  - Apply special forwarding to all ports whose customers have paid
    for premium service.

Each of these policies could represent an action applied to hundreds
of thousands of configuration variables.

In order to automate this practice, customers need software tools that
will implement business policies across their network, as well as
a standard protocol that will ensure that it can be applied to all of
their devices, regardless of the vendor.

This practice is called Policy-Based Management. This document
defines standard managed objects for the Simple Network Management
Protocol that are used to distribute policies in a standard form
throughout the network.







Various Authors    Expires December 11, 2001          [Page 4]





Internet Draft    Policy-Based Management MIB    June 11, 2001


4.  Policy-Based Management Architecture

Policy-based management is the practice of applying management
operations globally on all managed elements that share certain
attributes.

Policies are intended to express a notion of:
  if (an element has certain characteristics) then (apply operation to
  that element)

Policies take the following normal form:

  if (policyCondition) then (policyAction)

A policyCondition is program code which results in a boolean
to determine whether or not an element is a member of a set of
elements upon which an action is to be performed.

A policyAction is an operation performed on an element or a set of
elements.

These policies are most often executed on or near managed devices,
where the elements live (and thus their characteristics may be easily
inspected), and where operations on those elements will be performed.

A management station is responsible for distributing an organization's
policies to all of the managed devices in the infrastructure. The
pmPolicyTable provides managed objects for representing a policy on a
managed device.

An element is an instance of a physical or logical entity and is
embodied by a group of related MIB variables such as all the variables
for interface #7. This enables policies to be expressed more
efficiently and concisely. Elements can also model circuits, CPUs,
queues, processes, systems, etc.

Conceptually, policies are executed in the following manner:

  foreach element for which policyCondition returns true
      execute policyAction on that element

For example:

  If (interface is fast ethernet)       then (apply full-duplex mode)
  If (interface is access)              then (apply security filters)





Various Authors    Expires December 11, 2001          [Page 5]





Internet Draft    Policy-Based Management MIB    June 11, 2001


  If (circuit w/gold service paid for)  then (apply special queuing)

Each unique combination of policy and element is called an execution
context. Within a particular execution context, the phrase "this
element" is often used to refer to the associated element, as most
policy operations will be applied to "this element". The address of
"this element" contains the index of the element, the context the
element was discovered in, and the address of the system on which the
element was discovered.

PolicyConditions have the capability of performing comparison operations
on SNMP variables, logical expressions, and other functions. Many
device characteristics are already defined in MIBs and are
easy to include in policyCondition expressions (ifType == ethernet,
frCircuitCommittedBurst < 128K, etc). However, there are
important characteristics that aren't currently in MIB objects, and
worse, it is not current practice to store this information on managed
devices. Therefore, this document defines MIB objects for this
information. To meet today's needs there are three missing areas:
roles, capabilities and time.

Roles

A role is an administratively specified characteristic of a managed
element. It is a selector for policies, to determine the applicability
of the policy to a particular managed element.

Some examples of roles are political, financial, legal,
geographical, or architectural characteristics, typically not directly
derivable from information stored on the managed system. For example,
"paid for premium service" or "is plugged into a UPS" are examples of
roles, whereas the "percent utilization of a link" would not be.

Some types of information one would put into a role include:

  political - describes the role of a person or group of people, or of
              a service that a group of people use. Examples:
              executive, sales, outside-contractor, customer.
        If (attached user is executive) then (apply higher bandwidth)
        If (attached user is outside-contractor) then (restrict access)

  financial/legal - describes what financial consideration was
                    received. Could also include contractual or legal
                    considerations. Examples:
                    paid, gold, free, trial, demo, lifeline





Various Authors    Expires December 11, 2001          [Page 6]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        If (gold service paid for) then (apply special queuing)

  geographical - describes the location of an element. Examples:
                 California, Headquarters, insecure conduit.
        If (interface leaves the building) then (apply special security)

  architectural - describes the network architects "intent" for an
                  element. For example: backup, trunk.
         If (interface is backup) then (set ifAdminStatus = down)

  Roles in this model are human defined strings that can be referenced
  by policy code. Roles may be assigned to elements by the role group
  in this MIB as well as through implementation-dependent
  means. Multiple roles may be assigned to each element. Because
  policy code has access to data in MIB objects that represent the
  current state of the system and (in contrast) role strings are more
  static, it is recommended that role strings not duplicate
  information that is available in MIB objects. Role strings generally
  should be used to describe information not accessible in MIB objects.

  The roleMatch accessor function allows policy code to make
  decisions based on whether or not an element has a particular role
  assigned to it.

  The role group allows a management station to learn what roles exist
  on a managed system. The management station may choose not to
  install policies that depend on a role that does not exist on any
  elements in the system. The management station can then register for
  notifications of new roles. Upon receipt of a pmNewRoleNotification,
  it may choose to install new policies that make use of that new
  role.

Capabilities

  Some actions are inappropriate for certain elements or are simply
  unsupported because a capability doesn't exist or because it is
  restricted. One must be able to define policy conditions so that a
  policy can be applied only to elements that have the proper
  capability. The capabilities table provides MIB objects that
  describe the capabilities of the system.

  The capMatch accessor function allows policy code to make
  decisions based on whether or not an element has certain
  capabilities.






Various Authors    Expires December 11, 2001          [Page 7]





Internet Draft    Policy-Based Management MIB    June 11, 2001


  The capabilities table allows a management station to learn what
  capabilities exist on a managed system. The management station may
  choose not to install policies that depend on a capability that
  does not exist on any elements in the system. The management station
  can then register for notifications of new capabilities. Upon
  receipt of a pmNewCapabilityNotification, it may choose to install
  new policies that make use of that new capability.

Time

  Managers may wish to define policies that are intended to apply for
  certain periods of time. This might mean that a policy is installed
  and is dormant for a period of time, becomes active, and then later
  becomes inactive. Sometimes these time periods will be regular (M-F
  9-5) and sometimes ad-hoc. This MIB provides MIB objects that allow
  policies to be dependent on time.


5.  Policy Based Management Execution Environment


5.1.  Terminology

Run-Time Exception (RTE) - A run-time exception is a fatal
error caused in PolicyScript language processing or in the
processing of accessor functions. If, during the invocation of
a script, a run-time exception occurs, execution of that
script is immediately terminated. If a policyCondition
experiences a run-time exception while processing an element,
the element is not matched by the condition and the associated
action will not be run on that element. A run-time exception
can cause an entry to be added to the pmDebuggingTable and
will be reflected in the pmTrackingPEInfo object. The phrase
run-time exception will be commonly abbreviated to RTE.


There are several steps performed in order to execute policies
in this environment:

    - Element Discovery
    - Element Filtering
    - Policy Enforcement








Various Authors    Expires December 11, 2001          [Page 8]





Internet Draft    Policy-Based Management MIB    June 11, 2001


5.2.  Element Discovery

An element is an instance of a physical or logical entity.
Examples of elements include interfaces, circuits, queues,
CPUs, and processes. Sometimes various attributes of an entity
will be described through tables in several standard and
proprietary MIBs - as long as the indexing is consistent
between these tables, the entity can be modeled as 1 element.
For example, the ifTable and the dot3Stats table both contain
attributes of interfaces and share the same index (ifIndex),
therefore they can be modeled in this model as one element
type.

The Element Type Registration table is used by the manager to
learn what element types are being managed by the system and
to register new types if necessary. An element type is
registered by providing the OID of an SNMP object (i.e.,
without the instance). Each SNMP instance that exists under
that object is a distinct element. The index part of the
discovered OID will be supplied to policy conditions and
actions so that this code can inspect and configure the
element.

For each element that is discovered, the policy condition is
called with the element's index as an argument to see if the
element is a member of the set that the policy acts upon.

Note that agents may automatically configure entries in this
table for frequently used element types (interfaces, circuits,
etc.). In particular, it may configure elements for whom
discovery is optimized in one or both of the following ways:

1. The agent may discover elements by scanning internal data
   structures as opposed to issuing local SNMP requests. It is
   possible to recreate the exact semantics described in this
   table even if local SNMP requests are not issued.

2. The agent may receive asynchronous notification of new
   elements (for example, "card inserted") and use that
   information to instantly create elements rather than
   through polling. A similar feature might be available for
   the deletion of elements.

Note that the disposition of agent-installed entries is
described by the pmPolicyStorageType object.





Various Authors    Expires December 11, 2001          [Page 9]





Internet Draft    Policy-Based Management MIB    June 11, 2001


A special element type "0.0" exists. "0.0" represents the
single instance of the system itself and provides an execution
context for policies to operate on "the system" as well as on
MIB objects modeled as scalars. For example, "0.0" gives an
execution context for policy-based selection of the operating
system code version (likely modeled as a scalar MIB object).
The element type "0.0" always exists - as a consequence, no
actual discovery will take place and the
pmElementTypeRegMaxLatency object will have no effect for the
"0.0" element type. However, if the "0.0" element type is not
registered in the table, policies will not be executed on the
"0.0" element.

If the agent is discovering elements by polling, it should
check for new elements no less frequently than
pmElementTypeRegMaxLatency would dictate. When an element is
first discovered all policyConditions are run immediately and
policyConditions that match will have the associated
policyAction run immediately. Subsequently, the
policyCondition will be run regularly for the element with no
more than pmPolicyConditionMaxLatency milliseconds elapsing
between each invocation. Note that if an implementation has
the ability to be alerted immediately when a particular type
of element is created, it is urged to discover that type of
element in this fashion rather than through polling, resulting
in immediate configuration of the discovered element.



5.2.1.  Implementation Notes

Note that while the external behavior of this registration
process is defined in terms of the walking of MIB tables,
implementation strategies may differ. For example, commonly-
used element types (like interface) may have purpose-built
element discovery capability built-in and advertised to
managers through an entry in the pmElementTypeRegTable.

Before registering an element type, it is the responsibility
of a manager to inspect the table and see if it is already
registered (by the agent or another manager). Note that
entries that differ only in the last subid (which specifies
which object in an entry) are effectively duplicates and
should be treated as such by the manager.






Various Authors    Expires December 11, 2001         [Page 10]





Internet Draft    Policy-Based Management MIB    June 11, 2001


The system which implements the Policy-Based Management MIB
may not have knowledge of the format of object identifiers in
other MIBs. Therefore it is inappropriate for it to check
these OIDs for errors. It is the responsibility of the
management station to register well-formed object-identifiers.
For example, if an extra sub-identifier is supplied when
registering the ifTable, no elements will be discovered.
Similarly, if a sub-identifier is missing, every element will
be discovered numerous times (once per column) and none of the
element addresses will be well-formed.



5.3.  Element Filtering

The first step in executing a policy is to see which elements
match the policy condition. To evaluate a policy, the policy
condition is called once for each element and runs to
completion. The element's index is the only argument that is
passed to the condition code for each invocation. Except for
state accessible through accessor functions, no state is
remembered from the previous invocation of this element nor
from the previous invocation of the policy condition. If any
run-time exception occurs, the condition will terminate
immediately for this element. If the condition returns non-
zero, the corresponding policy action will be executed for
this element.

If an element matches a condition and it had not matched that
condition the last time it was checked (or it is a newly-
discovered element), the associated policyAction will be
executed immediately. If the element had matched the condition
at the last check, it will remain in the set of elements whose
policyAction will be run within the policyActionMaxLatency.


5.3.1.  Implementation Notes

It is an implementation-dependent matter as to how policy
conditions are scheduled. Each condition/element combination
is conceptually its own process and can be scheduled
sequentially or two or more could be run simultaneously.








Various Authors    Expires December 11, 2001         [Page 11]





Internet Draft    Policy-Based Management MIB    June 11, 2001


5.4.  Policy Enforcement

For each element that has returned non-zero from the policy
condition, the corresponding policy action is called. The
element's index is the only argument that is passed to the
policy action for each invocation.  Except for state
accessible from accessor functions, no state is remembered
from the policy condition evaluation, nor from the previous
condition/action invocation of this element nor from the
previous invocation of the policy condition or action on any
other element. If any run-time exception occurs, the action
will terminate immediately for this element.


5.4.1.  Implementation Notes

It is an implementation-dependent matter as to how policy
actions are scheduled. Each condition/element combination is
conceptually its own process and can be scheduled sequentially
or two or more could be run simultaneously.






























Various Authors    Expires December 11, 2001         [Page 12]





Internet Draft    Policy-Based Management MIB    June 11, 2001


6.  The PolicyScript Language

Policy conditions and policy actions are expressed with the
PolicyScript language. The PolicyScript language is designed
to be a small interpreted language that is simple to
understand and implement; it is designed to be appropriate for
writing small scripts that make up policy conditions and
actions.

PolicyScript is intended to be familiar to programmers in a
variety of languages, including Perl and C. PolicyScript is
nominally a subset of the C language - however it was
desirable to have access to C++'s operator overloading (solely
to aid in documenting the language - operator overloading is
not a feature of PolicyScript). Therefore, PolicyScript is
defined formally as a subset of the C++ language. A subset was
used to provide for easy development of low-cost interpreters
of PolicyScript and to take away language constructs that are
peculiar to the C/C++ languages.  For example, it is expected
that both C and Perl programmers will understand the
constructs allowed in PolicyScript.

Some examples of the features that have been removed from the
C/C++ language are: function definitions, pointer variables,
structures, enums, typedefs, floating point and pre-processor
functions (except for comments).

This language is formally defined as a subset of ISO C++ [19],
but only allows those constructs that may be expressed in the
Extended Backus-Naur Form (EBNF) documented here. This is done
because while EBNF doesn't fully specify syntactical rules (it
allows constructs that are invalid) and doesn't specify
semantic rules, it can successfully be used to define the
subset of the language that is required for conformance to
this specification. Unless explicitly described herein, the
meaning of any construct expressed in the EBNF can be found by
reference to the ISO C++ standard.

The use of comments and newlines are allowed and encouraged in
order to promote readability of PolicyScript code. Comments
begin with '/*' and end with '*/' or begin with '//' and go
until the end of the line.

One subset is not expressible in the EBNF syntax: all
variables within a PolicyScript program are within the same





Various Authors    Expires December 11, 2001         [Page 13]





Internet Draft    Policy-Based Management MIB    June 11, 2001


scope.

PolicyScript code must be expressed in the UTF8 character set.

In the EBNF used here, terminals are character set members
(singly or in a sequence) that are enclosed between two
single-quote characters or described as a phrase between '<'
and '>' characters.  Nonterminals are a sequence of letters
and underscore characters.  A colon (:) following a
nonterminal introduces its definition, a production.  In a
production, a '|' character separates alternatives. The '('
and ')' symbols group the enclosed items. The '[' and ']'
symbols indicate that the enclosed items are optional. The '?'
symbol following an item indicates that the item is optional.
The '*' symbol following an item indicates that the item is
repeated zero, one, or more times. The '+' symbol following an
item indicates that the item is repeated one or more times.
The symbol '--' begins a comment that ends at the end of the
line.


6.1.  Formal Definition

The PolicyScript language follows the syntax and semantics of
ISO C++ [19], but is limited to that which can be expressed in
the EBNF below.

The following keywords are reserved words and cannot be used
in any policy script. This prevents someone from using a word
that is a common keyword in other languages as an identifier
in a program and thus make the meaning of the program
confusing. The reserved words are:
    auto, case, char, const, default, do, double, enum,
    extern, float, goto, inline, int, long, register, short,
    signed, sizeof, static, struct, switch, typedef, union,
    unsigned, void, and volatile.

Any syntax error, use of a reserved keyword, reference of an
unknown identifier, improper number of function arguments,
error in coercing an argument to the proper type, exceeding
local limitations on string length or exceeding local
limitations on the total amount of storage used by local
variables will cause a RTE.

PolicyScript permits comments using the comment delimiters,





Various Authors    Expires December 11, 2001         [Page 14]





Internet Draft    Policy-Based Management MIB    June 11, 2001


'/*' to '*/' or the start of comment symbol '//'.

-- Lexical Grammar

    letter:       '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
                | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm'
                | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
                | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
                | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'
                | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M'
                | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
                | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'

    digit:        '0' | '1' | '2' | '3' | '4'
                | '5' | '6' | '7' | '8' | '9'

    non_zero:   '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

    oct_digit:  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'

    hex_digit:    digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
                        | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'

    escape_seq:    '\''   |   '\"'   |   '\?'   |   '\\'
                 | '\a'   |   '\b'   |   '\f'   |   '\n'
                 | '\r'   |  '\t'    |   '\v'
                 | '\' oct_digit+    | '\x' hex_digit+

    non_quote:  Any character in the UTF-8 character set
                except single quote ('), double quote ("),
                backslash ('\') or newline.

    c_char:            non_quote | '"' | escape_seq

    string_literal:    '"' s_char* '"'

    s_char:            non_quote | ''' | escape_seq

    char_constant:     ''' c_char '''

    decimal_constant:  non_zero digit*

    octal_constant:    '0' oct_digit*

    hex_constant:      ( '0x' | '0X' ) hex_digit+





Various Authors    Expires December 11, 2001         [Page 15]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    integer_constant:  decimal_constant | octal_constant | hex_constant

    identifier:        letter ( letter | digit )*

-- Phrase Structure Grammar

    -- Expressions

    primary_expr:      identifier | integer_constant | char_constant
                     | string_literal  |  '(' expression ')'

    postfix_expr:      primary_expr
                     | postfix_expr '(' argument_expression_list? ')'
                     | postfix_expr '++'
                     | postfix_expr '--'
                     | postfix_expr '[' expression ']'

    argument_expression_list:
                       assignment_expr
                     | argument_expression_list ',' assignment_expr

    unary_expr:        postfix_expr  |  unary_op unary_expr

    unary_op:          '+' | '-' | '~' | '!' | '++' | '--'

    binary_expr:  unary_expr | binary_expr binary_op unary_expr

    binary_op:       '||' | '&&' | '|'  | '^'  | '&'  | '!='
                   | '==' | '>=' | '<=' | '>'  | '<'  | '>>'
                   | '<<' |  '-' | '+'  | '%'  | '/'  |  '*'

    assignment_expr:      binary_expr
                        | unary_expr assignment_op assignment_expr

    assignment_op:     '=' | '*='  | '/=' | '%=' | '+=' | '-='
                   | '<<=' | '>>=' | '&=' | '^=' | '|='

    expression:    assignment_expr | expression ',' assignment_expr

    -- Declarations

    declaration:       'var' declarator_list ';'

    declarator_list:   init_declarator
                     | declarator_list ',' init_declarator





Various Authors    Expires December 11, 2001         [Page 16]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    init_declarator:   identifier [ '=' assignment_expr ]

    -- Statements

    statement:   declaration
               | compound_statement
               | expression_statement
               | selection_statement
               | iteration_statement
               | jump_statement

    compound_statement:    '{' statement* '}'

    expression_statement:  expression? ';'

    selection_statement:
            'if' '(' expression ')' statement
          | 'if' '(' expression ')' statement 'else' statement

    iteration_statement:
            'while' '(' expression ')' statement
          | 'for' '(' expression? ';' expression? ';' expression? ')'
                statement

    jump_statement:    'continue' ';'
                     | 'break' ';'
                     | 'return' expression? ';'

    -- Root production

    PolicyScript:     statement*


6.2.  Variables

To promote shorter scripts and ease in writing scripts,
PolicyScript provides a loosely-typed data class, "var", that
can store both integer and string values.  The native C++
types (char, int, etc.) are thus unnecessary and have not been
carried into the subset that comprises this language. The
semantics of the "var" type are modeled after those of
ECMAScript[20].

  For example:






Various Authors    Expires December 11, 2001         [Page 17]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    var number = 0, name = "IETF";

This language will be executed in an environment where the
following typedef is declared. (Note that this typedef will
not be visible in the policyCondition or policyAction code.)

  typedef ... var;

While this declaration is expressed here as a typedef, the
'typedef' keyword itself is not available to be used inside of
PolicyScript code.


6.2.1.  The var class

A value is an entity that takes on one of two types: string or
integer.

The String type is the set of all finite ordered sequences of
zero or more 8-bit unsigned integer values ("elements"). The
string type can store textual data as well as binary data
sequences. Each element is regarded as occupying a position
within the sequence. These positions are indexed with
nonnegative integers. The first element (if any) is at
position 0, the next element (if any) at position 1, and so
on. The length of a string is the number of elements (i.e.,
8-bit values) within it. The empty string has length zero and
therefore contains no elements.

The integer type is the set of all integer values in the range
-9223372036854775808 (-2^63) to 18446744073709551615 (2^64-1).
If an integer operation would cause a (positive) overflow,
then the result is returned modulo 2^64. If an integer
operation would cause a (negative) underflow, then the result
is undefined.

Prior to initialization, a var object has type String and a
length of zero.

The policy script runtime system performs automatic type
conversion as needed. To clarify the semantics of certain
constructs it is useful to define a set of conversion
operators. These operators are not a part of the language;
they are defined here to aid the specification of the
semantics of the language. The conversion operators are





Various Authors    Expires December 11, 2001         [Page 18]





Internet Draft    Policy-Based Management MIB    June 11, 2001


polymorphic; that is, they can accept a value of any standard
type.

ToInteger

The operator ToInteger converts its argument to a value of
type Integer according to the following table:

    Integer            The result equals the input argument
                       (no conversion).
    String             See grammar and note below
    integer_constant   The result equals the input argument
                       (no conversion).
    string_literal     See grammar and note below
    char_constant      See grammar and note below

ToInteger Applied to strings

ToInteger applied to the String Type, string_literal and
char_constants applies the following grammar to the input. If
the grammar cannot interpret the string as an expansion of
numeric_string, then an RTE is generated. Note that a
numeric_string that is empty or contains only white space is
converted to 0.

-- EBNF for numeric_string

  numeric_string : white_space* numeric white_space*

  white_space :      <TAB> |  <SP> |  <NBSP> |  <FF> |  <VT>
                   | <CR>  |  <LF> |  <LS>   |  <PS> |  <USP>

  numeric :        signed_decimal |  hex_constant | octal_constant

  signed_decimal:  [ '-' | '+' ] decimal_constant

  -- decimal_constant, hex_constant, octal_constant are defined in the
  -- PolicyScript EBNF described earlier

ToString

The operator ToString converts its argument to a value of type String
according to the following table:

    Integer           Return the string containing the decimal





Various Authors    Expires December 11, 2001         [Page 19]





Internet Draft    Policy-Based Management MIB    June 11, 2001


                      representation of the input argument in
                      the form of signed_decimal except that
                      no leading '+' will be used.
    String            Return the input argument (no conversion)
    integer_constant  Return the string containing the decimal
                      representation of the input argument in the
                      form of signed_decimal except that no
                      leading '+' will be used.
    string_literal    Return the input argument (no conversion)
    char_constant     Return the string of length one containing
                      the value of the input argument.

ToBoolean

The operator ToBoolean converts its argument to a value of type
Integer according to the following table:

    Integer            The result is 0 if the argument is 0.
                       Otherwise the result is 1.
    String             The results is 0 if the argument is the
                       empty string. Otherwise the result is 1.
    integer_constant   The result is 0 if the argument is 0.
                       Otherwise the result is 1.
    string_literal     The result is 0 if the argument is the
                       empty string. Otherwise the result is 1.
    char_constant      The result is 1.

Operators


    A++, A--, ++A, --A:
           A = ToInteger(A); OP;
    +A:    ToInteger(A);
    -A:     -1 * ToInteger(A);
    ~A:    ~ToInteger(A);
    !A:    !ToBoolean(A);
    A * B, A - B, A & B, A ^ B , A | B, A << B, A >> B:
           ToInteger(A) OP ToInteger(B)
    A / B, A % B:
           if (ToInteger(B) == 0)
             RTE, terminate;
           else
             ToInteger(A) OP ToInteger(B)
    A + B:
           if (Type(A) == String || Type(B) == String)





Various Authors    Expires December 11, 2001         [Page 20]





Internet Draft    Policy-Based Management MIB    June 11, 2001


             ToString(A) concatenated with ToString(B)
           else
             A + B
    Compound Assignment (op=):
            Simply follow rules above. Note that type of LHS may be
            changed as a result.

    A < B, A > B, A <= B, A >= B, A == B, A != B:
           if (Type(A) == String && Type(B) == String)
               lexically compare strings with strcmp() logic
           else
               ToInteger(A) OP ToInteger(B)
     A && B:
            if (ToBoolean(A))
                ToBoolean(B);
            else
                false;
     A || B:
            if (ToBoolean(A))
                true;
            else
                ToBoolean(B);

     if(A):
            if (ToBoolean(A))
     while(A):
            while(ToBoolean(A)
     for(...; A; ...):
           for(...; ToBoolean(A); ...)

     A[B] as a RHS value:
           if (Type(A) != String
                || ToInteger(B) >= strlen(A))
              RTE, terminate;
           A[ ToInteger(B) ]
           The contents are returned as a string of length one

      A[B] = C as a LHS value:
           if (Type(A) != String
                || ToInteger(B) >= strlen(A))
              RTE, terminate;
           if (strlen(ToString(C)) == 0)
              RTE, terminate
           A[ ToInteger(B) ] = First octet of ToString(C)






Various Authors    Expires December 11, 2001         [Page 21]





Internet Draft    Policy-Based Management MIB    June 11, 2001


           Note that this is only applicable in a simple assignment.


6.3.  PolicyScript QuickStart Guide

PolicyScript is designed so that programmers fluent in other
languages can quickly begin to write scripts.

One way to become familiar with a language is to see it in
action.  The following nonsensical program exercises most of
the PolicyScript constructs (though it skips some usage
options and many arithmetic operators).

    var x, index = 7, str = "Hello World", oid = "ifSpeed.";

    x = 0;
    while(x < 10){
        if (str < "Goodbye") /* string comparison */
            continue;
        else
            break;
        x++;
    }
    if (oidlen(oid) == 10)
        oid += "." + index; // append index to oid
    for(x = 0; x < 7; x++){
          str += "a";

          var y = 12;
          index = ((x * 7) + y) % 3;
          if (str[6] == 'W')
              return index;
    }
    return;

A few examples that are more practical are:

For a condition:
    // Return 1 if this is an interface and it is tagged
    // with the role "gold"
    return (inSubtree(elementName(), "ifEntry")
        && roleMatch("gold"))

A condition/action pair:
First, register the Host Resources MIB hrSWRunEntry as a new element





Various Authors    Expires December 11, 2001         [Page 22]





Internet Draft    Policy-Based Management MIB    June 11, 2001


in the pmElementTypeRegTable. This will cause the policy to run for
every process on the system and $0 will be the process index.

The condition:
    // if it's a process and it's an application and it's
    // consumed more than 5 minutes of CPU time
    return (inSubtree(elementName(), "hrSWRunEntry")
            && getVar("hrSWRunType.$0") == 4  // app, not OS or driver
            && getVar("hrSWRunPerfCPU.$0") > 30000) // 300 seconds

The action:
    // Kill it
    setVar("hrSWRunStatus.$0", 4, Integer); // invalid(4) kills it


A more substantial action to start an RMON2 host table on interfaces
that match the condition:

    var index, pdu;

    pdu = newPDU();
    // setRowStatus finds an empty row and creates it
    if (!(index = setRowStatus("hlHostControlStatus.*", 20)))
        return; /* couldn't find a free row */

    writeVar(pdu, 0, "hlHostControlDataSource." + index,
             "ifIndex." + ev(0), Oid);

    writeVar(pdu, 1, "hlHostControlNlMaxDesiredEntries." + index,
             1000, Integer);

    writeVar(pdu, 2, "hlHostControlAlMaxDesiredEntries." + index,
             1000, Integer);

    writeVar(pdu, 3, "hlHostControlOwner." + index, "policy", String);
    writeVar(pdu, 4, "hlHostControlStatus." + index, 1, Integer);
    snmpSend(pdu, 5, OP_SET);



Because PolicyScript is a least common denominator, it
contains nothing that would astonish programmers familiar with
C, C++, Perl, Tcl, JavaScript or Python.  While a new
programmer may attempt to use language constructs that aren't
available in PolicyScript, they should be able to understand





Various Authors    Expires December 11, 2001         [Page 23]





Internet Draft    Policy-Based Management MIB    June 11, 2001


any existing PolicyScript and will likely know how to use
anything that is valid in PolicyScript. The lists below
quickly enumerate the changes of note for programmers coming
some particular languages. These lists won't describe the
unavailable constructs but it is easy to see from the
definition above what is available.


6.3.1.  Quickstart for C Programmers

  - Character constants (i.e. 'c') are treated as one-character
    strings, not integers. So operations like ('M' - 'A') or (x + 'A')
    will not perform as expected.
  - Accessor functions can change the value of arguments even though
    they are not pointers (or called like '&arg').
  - All variables are in the same scope


6.3.2.  Quickstart for Perl Programmers

  - Comments are '/* comment */' and '// till end of line', not '#'
  - No need to put a '$' in front of variables
  - Strings are compared with ==, <=, < etc. (Details in Sec. 6.2.1)
  - Strings are concatenated with '+'. (Details in Sec. 6.2.1)
  - No variable substitution in "" strings. '' strings are 1 char only.
  - Variables must be declared before use (but no type is necessary)
  - All variables are in the same scope


6.3.3.  Quickstart for TCL Programmers

  - Comments are '/* comment */' and '// till end of line', not '#'
  - No need to put a '$' in front of variables
  - Function calls are func-name(arg1, arg2, ...)
  - Square braces [] don't interpret their contents
  - Double quotes "" surround a string but no substitutions are
    performed ("" is like { } in TCL )
  - Statements are terminated by a semicolon;
  - Instead of "Set a b", use "b = a;"
  - Strings are concatenated with '+'. (Details in Sec. 6.2.1)
  - All variables are in the same scope









Various Authors    Expires December 11, 2001         [Page 24]





Internet Draft    Policy-Based Management MIB    June 11, 2001


6.3.4.  Quickstart for Python Programmers

  - Comments are '/* comment */' and '// till end of line', not '#'
  - Single quotes can be used only for single-character strings ('a')
  - Indentation doesn't matter. Braces {} define blocks.
  - Variables must be declared before use (but no type is necessary)
  - The expression for if and while is always surrounded by
    parenthesis, like "if (x < 5)".
  - 'for' syntax is "for(expression; expression; expression)" (see EBNF).
  - All variables are in the same scope


6.3.5.  Quickstart for JavaScript/ECMAScript/JScript
Programmers

  - Variables must be declared before use.
  - Accessor functions can change the value of arguments
  - All variables are in the same scope


7.  Index information for `this element'

PolicyScript code needs a convenient way to get the components
of the index for "this element" so that they can perform SNMP
operations on it or on related elements.

Two mechanisms are provided.

1. For all oid input parameters to all SNMP Accessor Functions (but
   not oid utility functions), the token "$n" ('$' followed by an
   integer between 0 and 128) can be used in place of any decimal
   sub-identifier. This token is expanded by the agent at execution
   time to contain the n'th subid of the index for the current
   element. For example, if the element is interface #7, and the
   objectIdentifier is "1.3.6.1.2.1.2.2.1.3.$0", it will be expanded
   to "1.3.6.1.2.1.2.2.1.3.7". The special token "$*" is expanded to
   contain all of the subidentifiers of the index of the current
   element, separated by '.' characters.

   It is an RTE if a token is specified that is beyond the length of
   the index for the current element.

2. The ec() and ev() functions allow access to the components of the
   index for "this element". ec() takes no argument and returns the
   number of index components that exist. ev() takes an integer





Various Authors    Expires December 11, 2001         [Page 25]





Internet Draft    Policy-Based Management MIB    June 11, 2001


   argument specifying which component of the index (numbered starting
   at 0) and returns an integer containing the value of the n'th
   subidentifier. Refer to the accessor functions section for the
   complete definition of ec() and ev().

   For example, if "this element" is frCircuitDLCI.5.57
                                     (ifIndex = 5, DLCI = 57)
         then ec()  returns 2
              ev(0) returns 5
              ev(1) returns 57

   This is helpful when wishing to address a related element.
   Extending the previous example, to find the port speed of the port
   the circuit (above) runs over:

       portSpeed = getVar("ifSpeed." + ev(0));


8.  Accessor Functions

Accessor functions are built-in functions available primarily
to provide access to information on the local system or to
more efficiently manipulate this information. A group of
functions is organized into a library, the unit of conformance
for function implementation. In order to claim conformance to
a library, an implementation must implement all functions in a
library to the specifications of the library.

In order for a management station or a condition or action to
understand if a certain library of functions is implemented,
each library will have a registration OID that it registers in
this MIB's capabilities table. Thus, conformance to a library
can be tested with the capMatch library function (in the base
library) or by inspecting the pmCapabilitiesType objects in
the pmCapabilitiesTable.


9.  Base Accessor Function Library

A standard base library of accessor functions is available to
all systems that implement this specification. This library is
known by the capability OID of:

  pmBaseFunctionLibrary ::= { pmMib pmConformance pmGroups 4 }






Various Authors    Expires December 11, 2001         [Page 26]





Internet Draft    Policy-Based Management MIB    June 11, 2001


This library contains four types of functions:

  - SNMP Accessor functions
  - Policy Accessor functions
  - Utility functions
  - Library Functions

Note that in the descriptions of these functions below, the
function prototype describes the type of argument expected.
Even though variables are not declared with a particular type,
their contents must be as appropriate for each function
argument. If the type is variable, the keyword 'var' will be
used. If only a string is appropriate, the keyword 'string'
will be used. If only an integer is appropriate, the keyword
'integer' will be used. If the argument is declared as
'string' or 'integer' and a value of a different type is
passed, the argument will be coerced with ToInteger() or
ToString(). Any failure on this coercion will cause an RTE (in
particular for ToInteger(), which will fail if its string-
valued argument is not a well-formed integer).

In the function prototype, if the '&' character precedes the
identifier for an argument, that argument may be modified by
the function (e.g., "integer &result, ...)"). Arguments
without the '&' character cannot be modified by the function.

In the function prototype, the '[' and ']' characters surround
arguments that are optional. In PolicyScript code, the
optional argument may only be included if all optional
arguments to the left of it are included. The function may
place restrictions on when an optional argument must, or must
not, be included.


9.1.  SNMP Accessor Functions

Two sets of SNMP Accessor functions are available with
different situations in mind:

  - Convenience SNMP Functions

    In an effort to keep simple things simple, these functions are
    easy to use and promote easy to understand code. These functions
    will suffice for the majority of situations where a single
    variable is referenced and the desired error recovery is to simply





Various Authors    Expires December 11, 2001         [Page 27]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    (and immediately) give up (and move to the next policy-element
    combination). In more complex cases, the General SNMP Functions
    can be used at the cost of several times the code complexity.

    The convenience SNMP functions are getVar, exists,
    setVar, setRowStatus, and searchColumn.

  - General SNMP Functions

    The General SNMP functions allow nearly any legal SNMP Message to
    be generated, including those with multiple varbinds, getNext
    operations, notifications, and messages with explicit addressing
    or security specifications.

    The general SNMP functions are writeVar, readVar, and snmpSend.


9.1.1.  SNMP Operations on Non-Local Systems

From time to time, a script may need to perform an operation
on a different SNMP system than that which "this element"
resides on. Scripts may also need to specify the use of
alternate security parameters. In order to do this, the
following optional arguments are provided for the SNMP
accessor functions:

function(...[, integer mPModel,
               string tDomain, string tAddress,
               integer secModel, string secName,
               integer secLevel])

    'mPModel' is the integer value of the SnmpMessageProcessingModel
    to use for this operation.

    'tDomain' is a string containing an ASCII dotted-decimal
    object identifier representing the transport domain to use for
    this operation.

    'tAddress' is a string containing the transport address according
    formatted according to the 'tDomain' argument.

    'secModel' is the integer value of the SnmpSecurityModel to use
    for this operation.

    'secName' is a string value representing the SnmpSecurityName to





Various Authors    Expires December 11, 2001         [Page 28]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    use for this operation.

    'secLevel' is the integer value of the SnmpSecurityLevel to use
    for this operation.

    For convenience, constants for 'mPModel', 'secModel' and
    'secLevel' are defined in the "Constants" section below.

    In order for PolicyScript code to use any of these arguments, all
    optional arguments to the left must be included. These arguments
    must be used as a group - if one is specified, they must all be
    specified.

    The use of these arguments is denoted in the function definitions
    below by the keyword 'NonLocalArgs'.


9.1.2.  Form of SNMP Values

Many of the accessor functions have input or output parameters
that may be one of the many SMI data types. The actual type is
not encoded in the value, but rather is specified elsewhere,
possibly by nature of the context in which it is used. The
exact usage for input and output is:

Any Integer value
    (INTEGER, Integer32, Counter32, Counter64, Gauge32, Unsigned32,
    TimeTicks, Counter64):

    On input:
      An Integer or a String that can be successfully coerced to an
      Integer with the ToInteger() function. It is an RTE if
      a string argument in this context cannot be converted by
      ToInteger() into an integer.

    On output:
      An Integer containing the returned value.

Octet String
    On input:
      Either a String or an Integer. If an Integer, it will be coerced
      to a String with the ToString() function. This string will be
      used as an unencoded representation of the octet string value.

    On output:





Various Authors    Expires December 11, 2001         [Page 29]





Internet Draft    Policy-Based Management MIB    June 11, 2001


      A String containing the unencoded value of the octet string.

Object Identifier
    On input and on output:
      A String containing a decimal ascii encoded object identifier
      of the following form:

          oid:       subid [ '.' subid ]* [ '.' ]
          subid:     '0' | decimal_constant

    It is an RTE if an Object Identifier argument is not in the form
    above. Note that a trailing '.' is acceptable and will simply be
    ignored.

    Note that ascii descriptors (e.g. "ifIndex") are never used in
    these encodings "over the wire". They are never returned from
    accessor functions nor are they ever accepted by them. NMS user
    interfaces are encouraged to allow humans to view object
    identifiers with ascii descriptors, but they must translate those
    descriptors to dotted-decimal format before sending them in MIB
    objects to policy agents.



9.1.3.  Convenience SNMP Functions


9.1.3.1.  getVar()

The getVar() function is used to retrieve the value of an SNMP
MIB instance.

     string getVar(string oid [, string context, NonLocalArgs])

        'Oid' is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        The optional 'context' argument contains the context to
        operate on. If this argument is not present, the context of
        "this element" will be used. If this argument is the zero
        length string, the default context is used.

        The optional 'NonLocalArgs' provide addressing and security
        information to perform an SNMP operation on a different system





Various Authors    Expires December 11, 2001         [Page 30]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        than "this element".

        It is an RTE if the queried object identifier value does not
        exist.

        This function returns a string containing the returned value,
        encoded according to the returned type. Note that no actual
        SNMP PDU needs to be generated and parsed when the policy MIB
        agent resides on the same system as the managed elements.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7").

9.1.3.2.  exists()

The exists() function is used to verify the existence of an
SNMP MIB instance.

     integer exists(string oid [, string context, NonLocalArgs])

        'oid' is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        The optional 'context' argument contains the context to
        operate on. If this argument is not present, the context of
        "this element" will be used. If this argument is the zero
        length string, the default context is used.

        The optional 'NonLocalArgs' provide addressing and security
        information to perform an SNMP operation on a different system
        than "this element".

        This function returns the value 1 if the SNMP instance exists
        and 0 if it doesn't exist. Note that no actual SNMP PDU needs
        to be generated and parsed when the policy MIB agent resides
        on the same system as the managed elements.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7").








Various Authors    Expires December 11, 2001         [Page 31]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.1.3.3.  setVar()

The setVar() function is used to set a MIB instance to a
certain value. The setVar() function is only valid in
policyActions.

    integer setVar(string oid, var value, integer type
                   [, string context, NonLocalArgs] )

        'oid' is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        'value' is a string encoded in the format appropriate to
        the 'type' parameter. The agent will set the variable
        specified by 'oid' to the value specified by 'value'.

        'type' will be the type of the 'value'' parameter and will
        be set to one of the values for DataType Constants.

        The optional 'context' argument contains the context to
        operate on. If this argument is not present, the context of
        "this element" will be used. If this argument is the zero
        length string, the default context is used.

        The optional 'NonLocalArgs' provide addressing and security
        information to perform an SNMP operation on a different system
        than "this element". Note that no actual SNMP PDU needs
        to be generated and parsed when the policy MIB agent resides
        on the same system as the managed elements.

        If the set encounters any error, 0 is returned. If successful,
        1 is returned.

        It is recommended that NMS user interfaces display and allow
        input of MIB object names by their descriptor values followed
        by the index in dotted-decimal form (e.g., "ifType.7").

9.1.3.4.  searchColumn()

    integer searchColumn(string columnoid, string &oid,
                         string pattern, integer mode
                         [, string context, NonLocalArgs])

        searchColumn performs an SNMP walk on a portion of the MIB





Various Authors    Expires December 11, 2001         [Page 32]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        searching for objects with values equal to the `pattern'
        parameter.

        'columnoid' constrains the search to only those variables that
        share the same OID prefix (i.e. are beneath it in the OID
        tree).

        A getnext request will be sent requesting the object
        identifier 'oid'. If 'oid' is an empty string, the value of
        'columnoid' will be sent.

        The value returned in each response packet will be transformed
        to a string representation of the value of the returned
        variable. The string representation of the value will be
        formed by putting the value in the form dictated by the "Form
        of SNMP Values" rules, and then performing the ToString()
        function on this value, forming 'SearchString'.

        The 'mode' value controls what type of match to perform on
        this 'SearchString' value. There are 6 possibilities for mode:

            mode       Search Action
               0       Case sensitive exact match of 'pattern'
                       and 'SearchString'
               1       Case insensitive exact match of 'pattern'
                       and 'SearchString'
               2       Case sensitive substring match, finding
                       'pattern' in 'SearchString'
               3       Case insensitive substring match, finding
                       'pattern' in 'SearchString'
               4       Case sensitive regular expression match,
                       searching 'SearchString' for the regular
                       expression given in 'pattern'.
               5       Case insensitive regular expression match,
                       searching 'SearchString' for the regular
                       expression given in 'pattern'.


        searchColumn uses the POSIX extended regular expressions
        defined in POSIX 1003.2.

        The optional 'context' argument contains the context to
        operate on. If this argument is not present, the context of
        "this element" will be used. If this argument is the zero
        length string, the default context is used.





Various Authors    Expires December 11, 2001         [Page 33]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        The optional 'NonLocalArgs' provide addressing and security
        information to perform SNMP operations on a different system
        than "this element".

        If a match is found, 'oid' is set to the oid of the matched
        value and 1 is returned. If the search traverses beyond
        columnoid or returns an error without finding a match, zero is
        returned and 'oid' isn't modified.

        To find the first match, the caller should set 'oid' to the
        empty string. To find additional matches, subsequent calls to
        searchColumn should have 'oid' set to the oid of the last
        match, an operation than searchColumn performs automatically.

        For example:
            To find an ethernet interface
            oid = "";
            searchColumn("ifType", oid, "6", 0);

        This sends a getnext request for ifType and continues to walk
        the tree until a value matching 6 is found or a variable
        returns that is not in the 'ifType' subtree.

        To find the next ethernet interface, assuming interface #3
        was discovered to be the first:
            oid = "ifType.3";
            searchColumn("ifType", oid, "6", 0);

        In a loop, this looks simply like:
            oid = "";
            while(searchColumn("ifType", oid, "6", 0)){
              /* Do something with oid */
            }

        Note that in the preceding examples, "ifType" is used as a
        notational convenience and the actual code downloaded to the
        policy MIB agent must use the string "1.3.6.1.2.1.2.2.1.3" as
        there may be no MIB compiler (or MIB) available on the policy
        MIB agent.

        Note that if the value of 'columnoid' is too short and thus
        references too much of the object identifier tree
        (e.g. "1.3.6"), 'columnoid' could end up searching a huge
        number of variables (if it was "1.3.6", it would search ALL
        variables on the agent). It is the responsibility of the





Various Authors    Expires December 11, 2001         [Page 34]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        caller to make sure that 'columnoid' is set appropriately.


9.1.3.5.  setRowStatus()

    integer setRowStatus(string oid, integer maxTries
                         [, integer freeOnException , integer seed
                          , string context, NonLocalArgs])

        setRowStatus is used to automate the process of finding an
        unused row in a read-create table that uses RowStatus.

        'oid' is a string containing an ASCII dotted-decimal
        representation of an object identifier, with one of
        the subids replaced with a '*' character
        (e.g. "1.3.6.1.3.1.99.1.2.1.9.*"). 'oid' must reference an
        'instance' of the RowStatus object and the '*' must replace
        any integer index item that may be set to some random value.

        setRowStatus will come up with a number for the selected index
        item and will attempt to create the instance with the
        createAndWait state. If the attempt fails, it will retry with
        a different random index value. It will attempt this no more
        than 'maxTries' times.

        If the optional 'freeOnException' argument is present and
        equal to 1, the agent will free this row by setting RowStatus
        to 'destroy' if later in the same script invocation this
        script dies with a run-time exception or by a call to die().
        Note that this does not apply to subsequent invocations of
        the script.

        If the optional 'seed' argument is present, the initial index
        will be set to 'seed'. Otherwise it will be random. The 'seed'
        argument may not be present if the 'freeOnException' argument
        is not present.

        The optional 'context' argument contains the context to
        operate on. If this argument is not present, the context of
        "this element" will be used. If this argument is the zero
        length string, the default context is used.

        The optional 'NonLocalArgs' provide addressing and security
        information to perform an SNMP operation on a different system
        than "this element".





Various Authors    Expires December 11, 2001         [Page 35]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        setRowStatus returns the successful integer value for the
        index. If unsuccessful after 'maxTries' or if more than one
        '*' is in oid, -1 will be returned.















































Various Authors    Expires December 11, 2001         [Page 36]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.1.3.6.  counterRate()

When a policy wishes to make a decision based on the rate of a
counter, it faces a couple of problems:

1. It may need to run every X minutes, but need to make
   decisions on rates calculated over at least Y minutes
   where Y > X. This would require the complexity of managing
   a queue of old counter values.
2. The policy script has no control over exactly when it
   will run

The counterRate() function is designed to easily surmount
these problems.

    integer counterRate(string oid, integer minInterval [, integer 64bit])

        counterRate retrieves the variable specified by oid once per
        invocation. It keeps track of timestamped values retrieved on
        previous invocations by this execution context so that it can
        calculate a rate over a longer period than since the last
        invocation.

        'oid' is the object identifier that will be retrieved.
        A previously-saved value of the same object identifier that is
        older than 'minInterval' seconds old will be subtracted from
        the newly-retrieved value, yielding a delta. This delta will
        be divided by the number of seconds elapsed between the two
        retrievals and the integer-valued result will be returned.

        If there was no previously-saved retrieval older than
        'minInterval' seconds, then -1 will be returned.

        The delta calculation will allow for 32-bit counter semantics
        if it encounters rollover between the two retrievals unless
        the optional argument '64bit' is present and equal to 1,
        in which case it will allow for 64-bit counter semantics.

        The implementation will need to store a number of timestamped
        counter values. The implementation is free to throw away
        old values as long as it retains at least one value that is
        older than minInterval seconds.








Various Authors    Expires December 11, 2001         [Page 37]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.1.3.7.  counter32Delta()

If a (single) counter overflow occurs between successive
retrievals of a Counter32 object, the delta can still be
retrieved accurately but it has to be done consistent with 32
bit unsigned rollover semantics. This function is useful to
simplify that process in an environment where all counters are
64 bits.

    integer counter32Delta(integer old, integer new)

        counter32Delta returns the delta between 'new' and 'old'
        compensating for the potential 32-bit unsigned rollover of the
        counter between the sampling of 'new' and 'old'.

Example:
    var counter, lastcounter, delta;

    counter = getVar("ifInOctets.$0");
    if (getScratchpad(PolicyElement, "inOctets", lastcounter)){
       // if returns 0, no value was stored, so punt to next iteration
       delta = counter32Delta(lastcounter, counter);
    }
    setScratchpad(PolicyElement, "inOctets", counter);

    /*
     * delta now contains the 32bit delta of ifInOctets since the last
     * iteration.
     */


9.1.4.  General SNMP Functions

It is desirable for a general SNMP interface have the ability
to perform SNMP operations on multiple variables at once and
for it to allow multiple varbind lists to exist at once. The
newPdu, readVar and writeVar functions exist in order to
provide these facilities in a language without pointers,
arrays and memory allocators.

newPDU is called to allocate a PDU and return an integer
handle to it. Since PDUs are automatically freed when the
script exits and because they can be reused during execution,
there is no freePDU().






Various Authors    Expires December 11, 2001         [Page 38]





Internet Draft    Policy-Based Management MIB    June 11, 2001


readVar and writeVar access a variable length varbindlist for
a PDU. The PDU handle and the index of the variable within
that PDU are specified in every readVar and writeVar
operation. Once a PDU has been fully specified by one or more
calls to writeVar, it is passed to snmpSend (by referencing
the PDU handle) and the number of varbinds to be included in
the operation. When a response is returned, the contents of
the response are in the same PDU (i.e. the same PDU handle is
used) and may be read by one or more calls to readVar.

Varbinds in this data store are created automatically whenever
they are written by any writeVar, readVar, or snmpSend
operation. It is an RTE to read a varbind that has not been
previously written.

For example:
  var pdu = newPDU();

  writeVar(pdu, 0, "sysDescr.0", ...);
  writeVar(pdu, 1, "sysOID.0", ...);
  writeVar(pdu, 2, "ifNumber.0", ...);
  if (snmpSend(pdu, 3, Get, ...))
      return;
  readVar(pdu, 0, iKnowItsSysDescr, iKnowItsaString, value);
  readVar(pdu, 1, ...)
  readVar(pdu, 2, ...)
  ...

or,
  var pdu = newPDU();

  writeVar(pdu, 0, "ifIndex", ...);
  writeVar(pdu, 1, "ifType", ...);
  while(!done){
    if (snmpSend(pdu, 2, Getnext, ...))
        continue;
    readVar(pdu, 0, oid1, ...);
    readVar(pdu, 1, oid2, ...);
    /* leave OIDs alone, now PDU #0 is set up for next step
       in table walk. */
    if (oidncmp(oid1, "ifIndex", oidlen("ifIndex")))
      done = 0;
    ...
  }






Various Authors    Expires December 11, 2001         [Page 39]





Internet Draft    Policy-Based Management MIB    June 11, 2001


Note that in the preceding examples, descriptors such as
ifType and sysDescr are used in object identifiers solely as a
notational convenience and the actual code downloaded to the
policy MIB agent must use a dotted decimal notation only as
there may be no MIB compiler (or MIB) available on the policy
MIB agent.

It is suggested that implementations limit the total number of
PDUs per invocation to protect other script invocations from a
malfunctioning script (e.g. a script that calls newPDU() in a
loop). To be conformant to this specification, implementations
must allow each policy script invocation to allocate at least
5 PDUs with at least 32 varbinds per list.


9.1.4.1.  newPDU()

    integer newPDU()

        newPDU will allocate a new PDU and return a handle to the
        PDU. If no PDU could be allocated, -1 will be returned.


9.1.4.2.  writeVar()

    writeVar(integer pdu, integer varBindIndex,
                  string oid, var value, integer type)

        writeVar will store 'oid', 'value' and 'type' in
        the specified varbind.

        'pdu' is the handle to a PDU allocated by newPDU().

        'varBindIndex' is a non-negative integer that identifies the
        varbind within the specified PDU modified by this call. The
        first varbind is number 0.

        'oid' is a string containing an ASCII dotted-decimal
        representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        'value' is the value to be stored, of a type appropriate to the
        'type' parameter.

        'type' will be the type of the value parameter and will be set





Various Authors    Expires December 11, 2001         [Page 40]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        to one of the values for DataType Constants.




9.1.4.3.  readVar()

    readVar(integer pdu, integer varBindIndex,
                 string &oid, var &value, integer &type)

        readVar will retrieve the oid, the value and it's type
        from the specified varbind.

        'pdu' is the handle to a PDU allocated by newPDU().

        'varBindIndex' is a non-negative integer that identifies the
        varbind within the specified PDU read by this call. The
        first varbind is number 0.

        The object identifier value of the referenced varbind will be
        copied into the 'oid' parameter, formatted in an ASCII
        dotted-decimal representation (e.g. "1.3.6.1.2.1.1.1.0").

        'value' is the value retrieved, of a type appropriate to the
        'type' parameter.

        'type' is the type of the value parameter and will be set to
        one of the values for DataType Constants.

        If 'pdu' doesn't reference a valid PDU or 'varBindIndex'
        doesn't reference a valid varbind, the function returns
        without modifying 'oid', 'value' or 'type'.




9.1.4.4.  snmpSend()

    integer snmpSend(integer pdu, integer numVarbinds, integer opcode
                     [, string context , NonLocalArgs] )

        snmpSend will perform an SNMP operation using the specified
        PDU. Note that no actual SNMP PDU needs to be
        generated and parsed when the policy MIB agent
        resides on the same system as the managed elements.





Various Authors    Expires December 11, 2001         [Page 41]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        The optional 'context' argument contains the context to
        operate on. If this argument is not present, the context of
        "this element" will be used. If this argument is the zero
        length string, the default context is used.

        The optional 'NonLocalArgs' provide addressing and security
        information to perform an SNMP operation on a different system
        than "this element".

        The results of the operation will be placed in the same
        PDU. If an error occurred, the PDU will remain
        unmodified except for the following:

          1) If the response PDU had a nonzero error-index, the
             varbind specified by the error-index will have its type
             field replaced with associated error-status constant.
          2) If the response PDU contained varbinds with exceptions,
             the type field of those varbinds will be replaced with
             the appropriate exception (Nosuchobject,
             NosuchInstance, or Endofmibview).
          3) If the error-status was zero and there were no
             exceptions, the PDU will remain unmodified. (some
             examples of situations where this will apply are timeout
             and authentication failure).

        This function returns zero unless an error occurs in which
        case it returns the proper SNMP Error Constant.

        'pdu' is the handle to a PDU allocated by newPDU().

        'numVarbinds' is a integer greater than zero that specified
        which varbinds in the PDU will be used in this
        operation. The first N varbinds in the PDU are used.

        'opcode' is the type of SNMP operation to perform and must be
        one of the values for SNMP Operation Constants.


9.2.  Constants

The following constants are defined for use in all SNMP
Accessor Functions. Policy code will be executed in an
environment where the following constants are declared. (Note
that these constant declarations will not be visible in the
policyCondition or policyAction code.)





Various Authors    Expires December 11, 2001         [Page 42]





Internet Draft    Policy-Based Management MIB    June 11, 2001


While these declarations are expressed here as C 'const's, the
'const' construct itself is not available to be used inside of
policy code.

  // Datatype Constants

  const int Integer       = 1;
  const int String        = 2;
  const int Oid           = 3;
  const int Integer32     = 4;
  const int Ipaddress     = 5;
  const int Counter32     = 6;
  const int Gauge32       = 7;
  const int Unsigned32    = 8;
  const int Timeticks     = 9;
  const int Opaque        = 10;
  const int Counter64     = 11;

  // SNMP Error Constants

  const int Nosuchobject         = 21;
  const int Nosuchinstance       = 22;
  const int Endofmibview         = 23;
  const int Noerror              = 24;
  const int Toobig               = 25;
  const int Nosuchname           = 26;
  const int Badvalue             = 27;
  const int Readonly             = 28;
  const int Generr               = 29;
  const int Noaccess             = 30;
  const int Wrongtype            = 31;
  const int Wronglength          = 32;
  const int Wrongencoding        = 33;
  const int Wrongvalue           = 34;
  const int Nocreation           = 35;
  const int Inconsistentvalue    = 36;
  const int Resourceunavailable  = 37;
  const int Commitfailed         = 38;
  const int Undofailed           = 39;
  const int Authorizationerror   = 40;
  const int Notwritable          = 41;

  const int Badparameter         = 42;
  const int Toolong              = 43;
  const int Parseerror           = 44;





Various Authors    Expires December 11, 2001         [Page 43]





Internet Draft    Policy-Based Management MIB    June 11, 2001


  const int Authfailure          = 45;
  const int Timeout              = 46;

  // SNMP Operation Constants

  const int Get                  = 0;
  const int Getnext              = 1;
  const int Set                  = 3;
  const int Trap                 = 4;
  const int Inform               = 6;
  const int V2trap               = 7;

  // Constants for SnmpMessageProcessingModel and SnmpSecurityModel

  const int SNMPv1              = 0;
  const int SNMPv2c             = 1;
  const int SNMPv3              = 3;

  // SnmpSecurityLevel Constants

  const int noAuthNoPriv        = 1;
  const int authNoPriv          = 2;
  const int authPriv            = 3;



9.3.  Policy Accessor Functions

Policy Accessor Functions provide access to information
specifically related to the execution of policies.


9.3.1.  roleMatch()

The roleMatch() function is used to check to see if an element
has been assigned a particular role.

    integer roleMatch(string roleString [, string element,
                      string context, string contextEngineID])

        Argument 'roleString' is a string. The optional argument
        'element' contains the OID name of an element, defaulting
        to the current element if this argument is not supplied.
        If roleString exactly matches (content and length) any role
        assigned to the specified element, the function returns 1. If





Various Authors    Expires December 11, 2001         [Page 44]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        no roles match, the function returns 0.

        The 'context' argument contains the context of 'element'. If
        this argument is not present, the context of "this element"
        will be used. This argument may only be present if the
        'element' argument is present. If this argument is the zero
        length string, the default context is specified.

        The 'contextEngineID' argument contains the contextEngineID of
        the remote system that 'element' resides on. It is encoded as
        a pair of hex digits (upper and lower case are valid) for each
        octet of the contextEngineID. If this argument is not present,
        the local system will be used. This argument may only be
        present if the 'element' and 'context' arguments are present.


9.3.2.  capMatch()

The capMatch() function is used to check to see if an element
has a certain capability.

    integer capMatch(string capOid [, string element])

        Argument 'capOid' is a string containing a
        ASCII dotted-decimal representation of an object identifier
        that describes a capability as would be found in the
        pmCapabilitiesTable. The optional argument 'element'
        contains the OID name of an element, defaulting to the
        current element if this argument is not supplied.

        If the specified element has the capability described by
        capOid, this function returns 1, otherwise it returns 0.

9.3.3.  elementName()

The elementName() function is used to determine what the
current element is and can be used to provide information
about the type of element as well as how it is indexed.

    string elementName()

        elementName returns a string containing an ASCII
        dotted-decimal representation of an object identifier
        (e.g. 1.3.6.1.2.1.1.1.0). This object identifier identifies an
        instance of a MIB object that is an attribute of this element.





Various Authors    Expires December 11, 2001         [Page 45]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.3.4.  ec()

The ec() and ev() functions provide convenient access to the
components of the index for "this element". Typical uses will
be in creating the index to other, related elements.

    integer ec()

        ec() returns an integer count of the number index subidentifiers
        exist in the index for "this element".


9.3.5.  ev()

The ec() and ev() functions provide convenient access to the
components of the index for "this element". Typical uses will
be in creating the index to other, related elements.


    integer ev(integer n)

        ev() returns the value of the n'th subidentifier in the index
        for 'this element". The first subidentifier is indexed at
        0. It is an RTE if 'n' specifies a subidentifier beyond the
        last subidentifier.


9.3.6.  context()

    string elementContext()

        elementContext() returns a string containing the context of
        "this element".


9.3.7.  elementAddress()

    elementAddress(&tDomain, &tAddress)

        elementAddress modifies the 'tDomain' and 'tAddress' arguments
        to contain a domain/address pair that can be used to access
        "this element".








Various Authors    Expires December 11, 2001         [Page 46]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.3.8.  setScratchpad()

    setScratchpad(integer scope, string varName [, string value,
                  integer storageType])

        Every maxLatency time period, every policy runs once for each
        element. When the setScratchpad function executes, it stores a
        value that can be retrieved even after this policy execution
        code exits. This allows sharing of data between a condition and
        an action, two conditions executing on different elements, or
        even different policies altogether. The value of 'scope'
        controls which policy/element combinations can retrieve this
        'varName'/'value' pair. The options for 'scope' are:

        Global
            The 'varName'/'value' combination will be available in the
            condition or action of any policy while executing on any
            element.

        Policy
            The 'varName'/'value' combination will be available in any
            future execution of the condition or action of the current
            policy (regardless of what element the policy is executing
            on). If a policy is ever deleted or its condition or action
            code is modified, all values in its 'Policy' scope will be
            deleted.

        PolicyElement
            The 'varName'/'value' combination will be available in
            future executions of the condition or action of the current
            policy but only when the policy is executing on the
            current element. If a policy is ever deleted or its
            condition or action code is modified, all values in its
            'PolicyElement' scope will be deleted.


        'varName' is a string used to identify the value. Subsequent
        retrievals of the same 'varName' in the proper scope will
        return the value stored. Note that the namespace for 'varName'
        is distinct for each scope. 'varName' is case sensitive.

        'value' is a string containing the value to be stored.
        ToString(value) is called on this argument to convert it
        to a string before storage.






Various Authors    Expires December 11, 2001         [Page 47]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        If the 'value' argument this missing, the effect will be to
        delete 'varName' in scope 'scope' if it exists.

        If the optional 'storageType' argument is present and is equal
        to the constant 'volatile', then this variable must be deleted
        on a reboot. If it is equal to 'nonVolatile', then this
        variable should be stored in non-volatile storage where it
        will be available after a reboot. If it is equal to
        'freeOnException', the agent will free this variable if later
        in the same script invocation this script dies with a run-time
        exception or by a call to die() (note that this does not apply
        to subsequent invocations of the script). If the 'storageType'
        argument is not present, the variable will volatile and will
        be erased on reboot. The 'storageType'' argument may not be
        present if the 'value' argument is not present.

        Note that there may be implementation-specific limits on the
        number of scratchpad variables that can be allocated. The
        limit of unique scratchpad variables may be different for each
        scope or storageType.

        Contents of the scratchpad are erased on reboot.


9.3.9.  getScratchpad()

    integer getScratchpad(integer scope, string varName,
                          string &value)

        The getScratchpad function allows the retrieval of values that
        were stored previously in this execution context or in
        other execution contexts. The value of 'scope' controls which
        execution contexts can pass a value to this execution context.
        Refer to the definition of setScratchpad to see which values
        of 'scope' can pass a value to which execution contexts.

        'varName' is a string used to identify the value. Subsequent
        retrievals of the same 'varName' in the proper scope will return
        the value stored. Note that the namespace for varName is
        distinct for each scope. As a result, getScratchpad cannot
        force access to a variable in an inaccessible scope - it can
        only retrieve variables by referencing the proper scope in
        which they were set. 'varName' is case sensitive.

        On successful return, 'value' will be set to the value that was





Various Authors    Expires December 11, 2001         [Page 48]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        previously stored, otherwise 'value' will not be modified.

        This function returns 1 if a value was previously stored and 0
        otherwise.

Scratchpad Usage Examples

      Policy  Element    Action
      A       ifIndex.1  setScratchpad(Global, "foo", "55")
      A       ifIndex.1  getScratchpad(Global, "foo", val) == 55
      A       ifIndex.2  getScratchpad(Global, "foo", val) == 55
      B       ifIndex.2  getScratchpad(Global, "foo", val) == 55
      B       ifIndex.2  setScratchpad(Global, "foo", "16")
      A       ifIndex.1  getScratchpad(Global, "foo", val) == 16

      Policy  Element    Action
      A       ifIndex.1  setScratchpad(Policy, "bar", "75")
      A       ifIndex.1  getScratchpad(Policy, "bar", val) == 75
      A       ifIndex.2  getScratchpad(Policy, "bar", val) == 75
      B       ifIndex.1  getScratchpad(Policy, "bar", val) not found
      B       ifIndex.1  setScratchpad(Policy, "bar", "20")
      A       ifIndex.2  getScratchpad(Policy, "bar", val) == 75
      B       ifIndex.2  getScratchpad(Policy, "bar", val) == 20

      Policy  Element    Action
      A       ifIndex.1  setScratchpad(PolicyElement, "baz", "43")
      A       ifIndex.1  getScratchpad(PolicyElement, "baz", val) == 43
      A       ifIndex.2  getScratchpad(PolicyElement, "baz", val) not found
      B       ifIndex.1  getScratchpad(PolicyElement, "baz", val) not found
      A       ifIndex.2  setScratchpad(PolicyElement, "baz", "54")
      B       ifIndex.1  setScratchpad(PolicyElement, "baz", "65")
      A       ifIndex.1  getScratchpad(PolicyElement, "baz", val) == 43
      A       ifIndex.2  getScratchpad(PolicyElement, "baz", val) == 54
      B       ifIndex.1  getScratchpad(PolicyElement, "baz", val) == 65

      Policy  Element    Action
      A       ifIndex.1  setScratchpad(PolicyElement, "foo", "11")
      A       ifIndex.1  setScratchpad(Global,        "foo", "22")
      A       ifIndex.1  getScratchpad(PolicyElement, "foo", val) == 11
      A       ifIndex.1  getScratchpad(Global,        "foo", val) == 22










Various Authors    Expires December 11, 2001         [Page 49]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.3.10.  Constants

The following constants are defined for use for the scratchpad
functions. Policy code will be executed in an environment
where the following constants are declared. (Note that these
constant declarations will not be visible in the
policyCondition or policyAction MIB objects.)

While these declarations are expressed here as C 'const's, the
'const' construct itself is not available to be used inside of
policy code.

  // Scratchpad Constants

  // Values of scope
  const int Global           = 0;
  const int Policy           = 1;
  const int PolicyElement    = 2;

  // Values of storageType
  const int volatile         = 0;
  const int nonVolatile      = 1;
  const int freeOnException  = 2;


9.3.11.  signalError()

The signalError() function is used to by the script to
indicate to a management station that it is experiencing
abnormal behavior. signalError() turns on the
conditionUserSignal(3) or actionUserSignal(5) bit in the
associated pmTrackingPEInfo object (subsequent calls to
signalError() have no additional effect). This bit is
initially cleared at the beginning of each execution, so if
upon a subsequent execution, a script no longer calls this
function, the bit will be cleared.

    signalError()

        The signalException function takes no arguments and returns no
        value.









Various Authors    Expires December 11, 2001         [Page 50]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.3.12.  defer()

Policies can be associated in groups with the behavior that
for each element, of the policies that match the condition,
only the one the highest precedence value will be active. For
example if there is a default bronze policy that applies to
any interface and a special policy for gold interfaces, the
higher precedence of the gold policy will ensure that it is
run on gold ports and the bronze policy isn't.

Unfortunately, once the winning policy has been selected and
the action begins running, situations can occur where the code
determines that it cannot complete its task. In many such
cases, it is desirable that the next runner-up policy be
executed. In the previous example it would be desirable that
at least bronze behavior be configured if gold is appropriate
but isn't possible.

When a policy defers it exits and the condition-matching
policy with the next-highest precedence is immediately run.
Because it's possible that might defer as well, the execution
environment must remember where it is in the precedence chain
so that it can continue going down the chain until an action
completes without deferring or no policies are left in the
group. Once a policy completes successfully, the next
iteration will begin at the top of the precedence chain.

There are two ways to defer. A script can exit by calling
die() and specify that it should defer. Alternately, a script
can instruct the execution environment to cause it to defer if
it experiences a run-time exception.

   defer(integer defer)

       The defer function changes the run-time exception behavior of a
       script. By default, a script will not defer when it encounters
       an RTE. If defer(1) is called, the exit behavior is changed so
       the script will defer when it is terminated due to an RTE.
       won't defer when it is terminated due to an RTE.


9.3.13.  die()

   die(integer defer, integer free [, string message] )






Various Authors    Expires December 11, 2001         [Page 51]





Internet Draft    Policy-Based Management MIB    June 11, 2001


       The die function causes the script to optionally perform
       certain functions and then exit.

       If the 'defer' argument is 1, this script will defer to the
       next lower precedence policy in the same group who's condition
       matches. If the 'defer' argument isn't 1, it won't defer.
       Note that if a condition defers, it is functionally equivalent to
       the condition returning false.

       If the 'free' argument is 1, certain registered resources will
       be freed. If earlier in this script invocation any rows were
       created by createRow with the 'freeOnException' option, the
       execution environment will set the RowStatus of each row to
       'destroy' to delete the row. Further, if earlier in this script
       invocation any scratchpad variables were created or modified
       with the 'freeOnException' option, they will be deleted.

       If the optional 'message' argument is present, it will be
       logged to the debugging table if pmPolicyDebugging is turned on
       for this policy.

       Finally, the script will terminate.


9.3.14.  getParameters()

From time to time, policy scripts may desire one or more
parameters (e.g., site-specific constants). These parameters
may be installed with the script in this object and are
accessible to the script via the getParameters() accessor
function. If it is necessary for multiple parameters to be
passed to the script, the script can choose whatever
encoding/delimiting mechanism is most appropriate.

    string getParameters()

        The getParameters function takes no arguments. It returns a
        string containing the value of the pmPolicyParameters object
        for the running policy.


9.4.  Utility Accessor Functions

Utility Accessor Functions are provided to enable more
efficient use of the other accessor functions.





Various Authors    Expires December 11, 2001         [Page 52]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.4.1.  regexp()

    integer regexp(string pattern, string str,
                   integer case [, string &match])

        regexp searches 'str' for matches to the regular expression
        given in `pattern`. regexp uses the POSIX extended regular
        expressions defined in POSIX 1003.2.

        If the `case` argument is 0, the search will be case
        insensitive, otherwise it will be case sensitive.

        If a match is found, 1 is returned, otherwise 0 is returned.

        If the optional argument 'match' is provided and a match is
        found, the text of the first substring of 'str' that matches
        'pattern' will be copied to 'match'. If no match is found it
        will be unchanged.


9.4.2.  regexpReplace()

    string regexpReplace(string pattern, string replacement,
                          string str, integer case)

        regexpReplace searches 'str' for matches to the regular expression
        given in `pattern`, replacing the matched text with
        'replacement'. regexpReplace uses the POSIX extended regular
        expressions defined in POSIX 1003.2.

        If the `case` argument is 0, the search will be case
        insensitive, otherwise it will be case sensitive.

        The modified string is returned (which could be the same as
        the original string if no matches were found).


9.4.3.  oidlen()

    integer oidlen(string oid)

        oidlen returns the number of subidentifiers in 'oid'. 'oid' is
        a string containing an ASCII dotted-decimal representation of
        an object identifier (e.g. "1.3.6.1.2.1.1.1.0").






Various Authors    Expires December 11, 2001         [Page 53]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.4.4.  oidncmp()

    integer oidncmp(string oid1, string oid2, integer n)

        Arguments 'oid1' and 'oid2' are strings containing
        ASCII dotted-decimal representations of object identifiers
        (e.g. "1.3.6.1.2.1.1.1.0").

        oidcmp compares not more than 'n' subidentifiers of 'oid1' and
        'oid2' and returns -1 if 'oid1' is less than 'oid2', 0 if they
        are equal, and 1 if 'oid1' is greater than 'oid2'.


9.4.5.  inSubtree()

    integer inSubtree(string oid, string prefix)

        Arguments 'oid' and 'prefix' are strings containing
        ASCII dotted-decimal representations of object identifiers
        (e.g. "1.3.6.1.2.1.1.1.0").

        inSubtree returns 1 if every subidentifier in 'prefix' equals
        the corresponding subidentifier in 'oid', otherwise it returns
        0. The is equivalent to oidncmp(oid1, prefix, oidlen(prefix))
        is provided because this is an idiom and because it avoids
        evaluating 'prefix' twice if is an expression.


9.4.6.  subid()

    integer subid(string oid, integer n)

        subid returns the value of the 'n'th (starting at zero)
        subidentifier of 'oid'. 'oid' is a string containing an ASCII
        dotted-decimal representation of an object identifier
        (e.g. "1.3.6.1.2.1.1.1.0").

        If 'n' specifies a subidentifier beyond the length of 'oid', a
        value of -1 is returned.


9.4.7.  subidWrite()

    integer subidWrite(string oid, integer n, integer subid)






Various Authors    Expires December 11, 2001         [Page 54]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        subidWrite sets the value of the 'n'th (starting at zero)
        subidentifier of 'oid' to `subid'. 'oid' is a string
        containing an ASCII dotted-decimal representation of an object
        identifier (e.g. "1.3.6.1.2.1.1.1.0").

        If 'n' specifies a subidentifier beyond the length of 'oid',
        a value of -1 is returned. Note that appending subidentifiers
        can be accomplished with the string concatenation '+'
        operator.


9.4.8.  oidSplice()

    string oidSplice(string oid1, integer offset, integer len, string oid2)

        oidSplice replaces 'len' subidentifiers in 'oid1' with all of
        the subidentifiers from 'oid2', starting at 'offset' in 'oid1'
        (the first subidentifier is at offset 0). The oid length will
        be extended if necessary if 'offset' + 'len' extends beyond
        the end of 'oid1'.

        The resulting oid is returned.

        For example:
            oidSplice("1.3.6.1.2.1", 5, 1, "7")     => "1.3.6.1.2.7"
            oidSplice("1.3.6.1.2.1", 4, 2, "7.7")   => "1.3.6.1.7.7"
            oidSplice("1.3.6.1.2.1", 4, 3, "7.7.7") => "1.3.6.1.7.7.7"


9.4.9.  parseIndex()

ParseIndex is provided to make it easy to pull index values
from OIDs into variables.

    var parseIndex(string oid, integer &index, integer type,
                   integer len)

        parseIndex pulls values from the instance identification
        portion of 'oid', encoded as per Section 7.7 "Mapping of the
        INDEX clause" of the SMIv2[5].

        'oid' is the oid to be parsed.

        'index' describes which subid to begin parsing at. 'index'
        will be modified to indicate the subid after the last one





Various Authors    Expires December 11, 2001         [Page 55]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        parsed (even if this points past the last subid). The first
        subid is index 0. If any error occurs, 'index' will set to -1
        on return. If the input index refers past the end of the oid,
        'index' will be set to -1 on return.

        If 'type' is Integer, 'len' will not be consulted. The return
        value is the integer value of the next subid.

        If 'type' is String and 'len' is greater than zero, 'len'
        subids will be parsed. For each subid parsed, the chr() value
        of the subid will be appended to the returned string. If any
        subid is greater than 255, the 'index' argument will be set to
        -1 on return and an empty string will be returned. If there
        are fewer than 'len' subids left in 'oid', 'index' will be
        set to -1 on return but a string will be returned containing a
        character for each subid that was left.

        If 'type' is String and 'len' is zero, the next subid will be
        parsed to find 'N', the length of the string. Then this many
        subids will be parsed. For each subid parsed, the chr() value
        of the subid will be appended to the returned string. If any
        subid is greater than 255, the 'index' argument will be set to
        -1 on return and an empty string will be returned. If there
        are fewer than 'N' subids left in 'oid', 'index' will be set
        to -1 on return but a string will be returned containing a
        character for each subid that was left.

        If 'type' is String and 'len' is -1, subids will be parsed
        until the end of 'oid'. For each subid parsed, the chr()
        value of the subid will be appended to the returned string. If
        any subid is greater than 255, the 'index' argument will be
        set to -1 on return and an empty string will be returned.

        If 'type' is Oid and 'len' is greater than zero, 'len' subids
        will be parsed. For each subid parsed, the decimal-encoded
        value of the subid will be appended to the returned string,
        with a '.' character appended between each output subid but
        not after the last subid. If there are fewer than 'len' subids
        left in 'oid', 'index' will be set to -1 on return but a
        string will be returned containing an encoding for each subid
        that was left.

        If 'type' is Oid and 'len' is zero, the next subid will be
        parsed to find 'N', the number of subids to parse. For each
        subid parsed, the decimal-encoded value of the subid will be





Various Authors    Expires December 11, 2001         [Page 56]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        appended to the returned string, with a '.' character appended
        between each output subid but not after the last subid. If
        there are fewer than 'N' subids left in 'oid', 'index' will be
        set to -1 on return but a string will be returned containing
        an encoding for each subid that was left.

        If 'type' is Oid and 'len' is -1, subids will be parsed until
        the end of 'oid'. For each subid parsed, the decimal-encoded
        value of the subid will be appended to the returned string,
        with a '.' character appended between each output subid but
        not after the last subid.


9.4.10.  stringToDotted()

stringToDotted() is provided to encode strings suitable for
the index portion of an oid or to convert the binary encoding
of an ip address to a dotted-decimal encoding.

    string stringToDotted(string value)

        If 'value' is the zero length string, the zero length string
        is returned.

        The decimal encoding of the first byte of 'value' is appended
        to the output string. Then for each additional byte in
        'value', a '.' is appended to the output string followed by
        the decimal encoding of the additional byte.



9.4.11.  integer()

    integer integer(var input)

        integer converts 'input' into an integer by using the rules
        specified for ToInteger(), returning the integer-typed
        results.


9.4.12.  string()

    string string(var input)

        string converts 'input' into a string by using the rules





Various Authors    Expires December 11, 2001         [Page 57]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        specified for ToString(), returning the string-typed
        results.


9.4.13.  type()

    string type(var variable)

        type returns the type of its argument as either the string
        'String' or the string 'Integer'.


9.4.14.  chr()

    string chr(integer utf8)

        Returns a one-character string containing the character
        specified by the UTF8 code contained in 'utf8'. Note that a
        property of UTF8 is that 7-bit ASCII characters are
        represented by the same UTF8 code-points as their ascii
        equivalents.


9.4.15.  ord()

    integer ord(string str)

        Returns the UTF8 code-point value of the first character of
        'str'. This function complements chr(). Note that a property of
        UTF8 is that 7-bit ASCII characters are represented by the
        same UTF8 code-points as their ascii equivalents.


9.4.16.  substr()

    string substr(string &str, integer offset,
                  integer len [, string replacement])

        Extracts a substring out of 'str' and returns it. The first
        octet is at offset 0. If offset is negative, the returned
        string starts that far from the end of 'str'. If 'len' is
        positive, the returned string contains up to 'len' octets,
        up to the end of the string. If 'len' is omitted, the returned
        string includes everything to the end of 'str'. If 'len' is
        negative, abs(len) octets are left off the end of the





Various Authors    Expires December 11, 2001         [Page 58]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        string.

        If you specify a substring that is partly outside the string,
        the part within the string is returned. If the substring is
        totally outside the string, a zero-length string is produced.

        If the optional replacement argument is included, 'str' is
        modified. 'offset' and 'len' act as above to select a range of
        octets in 'str'. These octets are replaced with
        octets from 'replacement'. If the replacement string is
        shorter or longer than the number of octets selected,
        'str' will shrink or grow respectively.


9.5.  Library Accessor Functions

The following POSIX standard library accessor functions are
provided:

  strncmp()
  strncasecmp()
  strlen()
  random()
  sprintf()
  sscanf()



10.  Schedule Table

This table is an adapted form of the policyTimePeriodCondition
class defined in the Policy Core Information Model, RFC 3090
[21].

The policy schedule table allows control over when a policy
will be active based on the date and time. Note that the use
of the term active in this context does not refer to the
'active' state of the pmPolicyRowStatus object, although it is
necessary for a the RowStatus to be active for the policy to
run. It is also necessary for the pmPolicyAdminStatus to be in
an enabled mode.

A policy's pmPolicySchedule variable refers to a group of one
or more schedules in the schedule table. At any given point in
time, if any of these schedules are active, the policy will be





Various Authors    Expires December 11, 2001         [Page 59]





Internet Draft    Policy-Based Management MIB    June 11, 2001


active (assuming that it is enabled) and it's conditions and
actions will be executed as appropriate.  At times when none
of these schedules are active, the policy won't be active and
will have no effect. A policy will always be active if it's
pmPolicySchedule variable is 0 or doesn't refer to an existing
schedule group.

A policy that is controlled by a schedule group immediately
executes its policy condition (and conditionally the
policyAction) when the schedule group becomes active,
periodically re-executing these scripts as appropriate until
the schedule group becomes inactive (i.e. all schedules are
inactive).

An individual schedule item is active at those times that
match all of the variables that define the schedule:
pmSchedTimePeriod, pmSchedMonth, pmSchedDay, pmSchedWeekDay,
and pmSchedTimeOfDay.  It is possible to specify multiple
values for each schedule item.  This provides a mechanism for
defining complex schedules.  For example, a schedule could be
defined which is active the entire workday each weekday.

Months, days and weekdays are specified using the objects
pmSchedMonth, pmSchedDay and pmSchedWeekDay of type BITS.
Setting multiple bits in these objects causes an OR operation.
For example, setting the bits monday(1) and friday(5) in
pmSchedWeekDay restricts the schedule to Mondays and Fridays.

The matched times for pmSchedTimePeriod, pmSchedMonth,
pmSchedDay pmSchedWeekDay, and pmSchedTimeOfDay are ANDed
together to determine the time periods that the schedule will
be active; in other words, the schedule is only active for
those times that ALL of these schedule attributes match. For
example, a schedule with an overall validity range of January
1, 2000 through December 31, 2000; a month mask that selects
March and April; a day-of-the-week mask that selects Fridays;
and a time of day range of 0800 through 1600 would represent
the following time periods:

      Friday, March  5, 2000, from 0800 through 1600;
      Friday, March 12, 2000, from 0800 through 1600;
      Friday, March 19, 2000, from 0800 through 1600;
      Friday, March 26, 2000, from 0800 through 1600;
      Friday, April  2, 2000, from 0800 through 1600;
      Friday, April  9, 2000, from 0800 through 1600;





Various Authors    Expires December 11, 2001         [Page 60]





Internet Draft    Policy-Based Management MIB    June 11, 2001


      Friday, April 16, 2000, from 0800 through 1600;
      Friday, April 23, 2000, from 0800 through 1600;
      Friday, April 30, 2000, from 0800 through 1600.

Wildcarding of schedule attributes of type BITS is achieved by
setting all bits to one.


It is possible to define schedules that will never cause a
policy to be activated. For example, one can define a schedule
which should be active on February 31st.







































Various Authors    Expires December 11, 2001         [Page 61]





Internet Draft    Policy-Based Management MIB    June 11, 2001


11.  Definitions

POLICY-BASED-MANAGEMENT-MIB DEFINITIONS ::= BEGIN
IMPORTS
    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,
    Counter32, Integer32, Gauge32, Unsigned32,
    experimental                                 FROM SNMPv2-SMI
    RowStatus, RowPointer, TEXTUAL-CONVENTION,
    DateAndTime, StorageType                     FROM SNMPv2-TC
    MODULE-COMPLIANCE, OBJECT-GROUP,
    NOTIFICATION-GROUP                           FROM SNMPv2-CONF
    SnmpAdminString                              FROM SNMP-FRAMEWORK-MIB;

--  Policy-Based Management MIB

pmMib MODULE-IDENTITY
    LAST-UPDATED "200106110000Z"  -- June 11, 2001
    ORGANIZATION "IETF SNMP Configuration Working Group"
    CONTACT-INFO
        "


        Steve Waldbusser

        Phone: +1-650-948-6500
        Fax:   +1-650-745-0671
        Email: waldbusser@nextbeacon.com

        Jon Saperia (WG Co-chair)
        JDS Consulting, Inc.
        174 Chapman St.
        Watertown MA 02472-3063
        USA
        Phone: +1-617-744-1079
        Fax:   +1-617-249-0874
        Email: saperia@jdscons.com

        Thippanna Hongal
        Riverstone Networks, Inc.
        5200 Great America Parkway
        Santa Clara, CA, 95054
        USA

        Phone: +1-408-878-6562
        Fax:   +1-408-878-6501





Various Authors    Expires December 11, 2001         [Page 62]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        Email: hongal@riverstonenet.com


        David Partain (WG Co-chair)
        Postal: Ericsson Radio Systems
                P.O. Box 1248
                SE-581 12 Linkoping
                Sweden
        Tel: +46 13 28 41 44
        E-mail: David.Partain@ericsson.com

        Any questions or comments about this document can also be
        directed to the working group at snmpconf@snmp.com."
    DESCRIPTION
        "The MIB module for policy-based configuration of SNMP
        infrastructures."

    REVISION "200106110000Z"    -- June 11, 2001
    DESCRIPTION
        "The original version of this MIB, published as RFCXXXX."
    ::= { experimental 107 }

UTF8String ::= TEXTUAL-CONVENTION
    STATUS       current
    DESCRIPTION
        "An octet string containing information typically in
        human-readable form.

        To facilitate internationalization, this
        information is represented using the ISO/IEC
        IS 10646-1 character set, encoded as an octet
        string using the UTF-8 transformation format
        described in [RFC2279].

        Since additional code points are added by
        amendments to the 10646 standard from time
        to time, implementations must be prepared to
        encounter any code point from 0x00000000 to
        0x7fffffff.  Byte sequences that do not
        correspond to the valid UTF-8 encoding of a
        code point or are outside this range are
        prohibited.

        The use of control codes should be avoided.






Various Authors    Expires December 11, 2001         [Page 63]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        When it is necessary to represent a newline,
        the control code sequence CR LF should be used.

        For code points not directly supported by user
        interface hardware or software, an alternative
        means of entry and display, such as hexadecimal,
        may be provided.

        For information encoded in 7-bit US-ASCII,
        the UTF-8 encoding is identical to the
        US-ASCII encoding.

        UTF-8 may require multiple bytes to represent a
        single character / code point; thus the length
        of this object in octets may be different from
        the number of characters encoded.  Similarly,
        size constraints refer to the number of encoded
        octets, not the number of characters represented
        by an encoding.

        Note that when this TC is used for an object that
        is used or envisioned to be used as an index, then
        a SIZE restriction MUST be specified so that the
        number of sub-identifiers for any object instance
        does not exceed the limit of 128, as defined by
        [RFC1905].

        Note that the size of an UTF8String object is
        measured in octets, not characters."
       SYNTAX       OCTET STRING

-- The policy group

pmPolicyTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmPolicyEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "The policy table. A policy is a pairing of a
        policyCondition and a policyAction which is used to apply the
        action to a selected set of elements."
    ::= { pmMib 1 }

pmPolicyEntry OBJECT-TYPE
    SYNTAX      PmPolicyEntry





Various Authors    Expires December 11, 2001         [Page 64]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry in the policy table representing one policy."
    INDEX { pmPolicyIndex }
    ::= { pmPolicyTable 1 }

PmPolicyEntry ::= SEQUENCE {
    pmPolicyIndex                 Unsigned32,
    pmPolicyGroup                 UTF8String,
    pmPolicyPrecedence            Unsigned32,
    pmPolicySchedule              Unsigned32,
    pmPolicyElementTypeFilter     UTF8String,
    pmPolicyConditionProgramIndex Unsigned32,
    pmPolicyActionProgramIndex    Unsigned32,
    pmPolicyParameters            OCTET STRING,
    pmPolicyConditionMaxLatency   Unsigned32,
    pmPolicyActionMaxLatency      Unsigned32,
    pmPolicyMaxIterations         Unsigned32,
    pmPolicyDescription           UTF8String,
    pmPolicyMatches               Gauge32,
    pmPolicyAbnormalTerminations  Gauge32,
    pmPolicyExecutionErrors       Counter32,
    pmPolicyDebugging             INTEGER,
    pmPolicyAdminStatus           INTEGER,
    pmPolicyStorageType           StorageType,
    pmPolicyRowStatus             RowStatus
}

pmPolicyIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for this policy entry."
    ::= { pmPolicyEntry 1 }

pmPolicyGroup OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..32))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "An administratively assigned string that is used to group
        policies. For each element, only one policy in the same group
        may be active on that element. If multiple policies would be





Various Authors    Expires December 11, 2001         [Page 65]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        active on an element (because their conditions return non-zero),
        the execution environment will only allow the policy with the
        highest value of pmPolicyPrecedence to be active."
    ::= { pmPolicyEntry 2 }

pmPolicyPrecedence OBJECT-TYPE
    SYNTAX      Unsigned32 (0..65535)
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "If while checking to see which policy conditions match an
        element, 2 or more policies in the same group match the same
        element, the pmPolicyPrecedence object provides the rule to
        arbitrate which single policy action will be executed on this
        element. Of policies in the same group, only the matching
        policy with the highest precedence value (i.e. 2 is higher
        than 1) will have its policy action periodically executed on
        this element.

        When a policy condition no longer matches an element, the
        condition-matching policy with the next-highest precedence is
        immediately run. If a policy condition suddenly begins matching
        an element, it will immediately be run and any
        lower-precedence matching policies will not run anymore.

        In the case where multiple policies share the
        highest value, it is an implementation-dependent matter as to
        which single policy action will be chosen.

        Note that if it is necessary to take certain actions after a
        policy is no longer active on an element, these actions should
        be included in a lower-precedence policy that is in the same
        policy group."
    ::= { pmPolicyEntry 3 }

pmPolicySchedule OBJECT-TYPE
    SYNTAX      Unsigned32 (0..65535)
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "If this object refers to a valid pmSchedGroupIndex, this
         policy will be activated as specified by the associated
         schedule entries. Whenever any schedule in the group is
         active, this policy will be active.






Various Authors    Expires December 11, 2001         [Page 66]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         A valid pmSchedGroupIndex is one that refers to a
         pmSchedGroup that contains at least one running schedule with
         its RowStatus set to 'active'.

         If the value of this object is 0, this policy is always
         active."
    ::= { pmPolicyEntry 4 }

pmPolicyElementTypeFilter OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..128))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "This object specifies the element types for which this policy
        will be executed. When this policy is active, it will be
        executed on all elements of these types.

        The format of this object will be a sequence of
        pmElementTypeRegOIDPrefix values, encoded in the following
        form:

        elementTypeFilter:   oid [ ';' oid ]*
                      oid:   subid [ '.' subid ]*
                    subid:   '0' | decimal_constant

        For example, to register for the policy to be run on all
        interface elements, the 'ifEntry' element type will be
        registered as '1.3.6.1.2.1.2.2.1'.

        If a value is registered that does not represent a registered
        pmElementTypeRegOIDPrefix, then that value will be ignored."
    ::= { pmPolicyEntry 5 }


pmPolicyConditionProgramIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "A pointer to the row or rows in the pmPolicyCodeTable that
         contain the condition code for this policy. When a policy entry
         is created, an unused pmPolicyCodeIndex value will be
         assigned to this object.

         A policy condition is one or more PolicyScript statements





Various Authors    Expires December 11, 2001         [Page 67]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         which results in a boolean value that represents whether or
         not an element is a member of a set of elements upon which an
         action is to be performed.

         Condition evaluation stops immediately when any run-time
         exception is detected and the policyAction is not executed.

         The policyCondition is evaluated for various elements. Any
         element for which the policyCondition returns any nonzero value
         will match the condition and will have the associated
         policyAction executed on that element unless a
         higher-precedence policy in the same policy group also
         matches this element.

         If the condition object is empty (contains no code) or otherwise
         does not return a value, the element will not be matched.

         When executing this condition, if SNMP requests are made to the
         local system, access to objects is under the security
         credentials of the requester who modified the most
         recently modified pmPolicyCodeEntry associated with either
         the pmPolicyConditionProgramIndex value or
         pmPolicyActionProgramIndex value. In other words,
         modification of any part of a policy's condition or action will
         change the credentials stored for the policy.

         These credentials are the input parameters for
         isAccessAllowed from the Architecture for Describing SNMP
         Management Frameworks[1]."
    ::= { pmPolicyEntry 6 }

pmPolicyActionProgramIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "A pointer to the row or rows in the pmPolicyCodeTable that
         contain the action code for this policy. When a policy entry
         is created, an unused pmPolicyCodeIndex value will be
         assigned to this object.

         A pmPolicyAction is an operation performed on a
         set of elements.

         Action evaluation stops immediately when any run-time





Various Authors    Expires December 11, 2001         [Page 68]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         exception is detected.

         When executing this action, if SNMP requests are made to the
         local system, access to objects is under the security
         credentials of the requester who modified the most
         recently modified pmPolicyCodeEntry associated with either
         the pmPolicyConditionProgramIndex value or
         pmPolicyActionProgramIndex value. In other words,
         modification of any part of a policy's condition or action will
         change the credentials stored for the policy.

         These credentials are the input parameters for
         isAccessAllowed from the Architecture for Describing SNMP
         Management Frameworks[1]."
    ::= { pmPolicyEntry 7 }

pmPolicyParameters OBJECT-TYPE
    SYNTAX      OCTET STRING
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "From time to time, policy scripts may desire one or more
        parameters (e.g., site-specific constants). These parameters
        may be installed with the script in this object and are
        accessible to the script via the getParameters() accessor
        function. If it is necessary for multiple parameters to be
        passed to the script, the script can choose whatever
        encoding/delimiting mechanism is most appropriate."
    ::= { pmPolicyEntry 8 }

pmPolicyConditionMaxLatency OBJECT-TYPE
    SYNTAX      Unsigned32 (0..2147483647)
    UNITS       "milliseconds"
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Every element under the control of this agent is
        re-checked periodically to see if it is under control of this
        policy by re-running the condition for this policy.
        This object lets the manager control the maximum amount of
        time that may pass before an element is re-checked.

        In other words, in any given interval of this duration, all
        elements must be re-checked. Note that it is an
        implementation-dependent matter as to how the policy agent





Various Authors    Expires December 11, 2001         [Page 69]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        schedules the checking of various elements within this
        interval. Implementations may wish to re-run a condition more
        quickly if they note a change to the role strings for an
        element."
    ::= { pmPolicyEntry 9 }

pmPolicyActionMaxLatency OBJECT-TYPE
    SYNTAX      Unsigned32 (0..2147483647)
    UNITS       "milliseconds"
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Every element that matches this policy's condition and is
        therefore under control of this policy will have this policy's
        action executed periodically to ensure that the element
        remains in the state dictated by the policy.
        This object lets the manager control the maximum amount of
        time that may pass before an element has the action run on
        it.

        In other words, in any given interval of this duration, all
        elements under control of this policy must have the action run
        on them. Note that it is an implementation-dependent matter as
        to how the policy agent schedules the policy action on various
        elements within this interval."
    ::= { pmPolicyEntry 10 }

pmPolicyMaxIterations OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "If a condition or action script iterates in loops too many
        times in one invocation, it may be considered by the execution
        environment to be in an infinite loop or otherwise not acting
        as intended and may be terminated by the execution
        environment. The execution environment will count the
        cumulative number of times all 'for' or 'while' loops iterated
        and will apply a threshold to determine when to terminate the
        script. It is an implementation-dependent manner as to what
        threshold the execution environment uses, but the value of
        this object SHOULD be the basis for choosing the threshold for
        each script. The value of this object represents a
        policy-specific threshold and can be tuned for policies of
        varying workloads. If this value is zero, no





Various Authors    Expires December 11, 2001         [Page 70]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        threshold will be enforced except for any
        implementation-dependent maximum.

        Note that the condition and action invocations are tracked
        separately."
    ::= { pmPolicyEntry 11 }

pmPolicyDescription OBJECT-TYPE
    SYNTAX      UTF8String
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "A description of this rule and its significance, typically
         provided by a human."
    ::= { pmPolicyEntry 12 }

pmPolicyMatches OBJECT-TYPE
    SYNTAX      Gauge32
    UNITS       "elements"
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The number of elements that, in their most recent execution
         of the associated condition, were matched by the condition."
    ::= { pmPolicyEntry 13 }

pmPolicyAbnormalTerminations OBJECT-TYPE
    SYNTAX      Gauge32
    UNITS       "elements"
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The number of elements that, in their most recent execution
         of the associated condition or action, have experienced a
         run-time exception and terminated abnormally. Note that if a
         policy was experiencing a run-time exception while processing
         a particular element but on a subsequent invocation it runs
         normally, this number can decline."
    ::= { pmPolicyEntry 14 }

pmPolicyExecutionErrors OBJECT-TYPE
    SYNTAX      Counter32
    UNITS       "errors"
    MAX-ACCESS  read-only
    STATUS      current





Various Authors    Expires December 11, 2001         [Page 71]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    DESCRIPTION
         "The total number of times that execution of this policy's
         condition or action has been terminated due to run-time
         exceptions."
    ::= { pmPolicyEntry 15 }

pmPolicyDebugging OBJECT-TYPE
    SYNTAX      INTEGER {
                    off(0),
                    on(1)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of debugging for this policy. If this is turned
         on(1), log entries will be created in the pmDebuggingTable
         for each run-time exception that is experienced by this
         policy."
    DEFVAL { off }
    ::= { pmPolicyEntry 16 }

pmPolicyAdminStatus OBJECT-TYPE
    SYNTAX      INTEGER {
                    disabled(0),
                    enabled(1),
                    enabledAutoRemove(2)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The administrative status of this policy.

         The policy will be runnable only if the associated
         pmPolicyRowStatus is set to active(1) and this object is set
         to enabled(1) or enabledAutoRemove(2).

         If this object is set to enabledAutoRemove(2), the next time
         the associated schedule moves from the active state to the
         inactive state, this policy will immediately be deleted,
         including any associated entries in the pmPolicyCodeTable.

         [Note to reader: This object exists because a row cannot sit
         for extended periods of time with it's rowstatus set to
         inactive (it is subject to garbage collection). This object
         allows policies to be downloaded but not run except at the





Various Authors    Expires December 11, 2001         [Page 72]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         convenience of the management station.]"
    ::= { pmPolicyEntry 17 }

pmPolicyStorageType OBJECT-TYPE
    SYNTAX      StorageType
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "This object defines whether this policy and any associated
         entries in the pmPolicyCodeTable are kept in volatile storage
         and lost upon reboot or if this row is backed up by
         non-volatile or permanent storage."
    ::= { pmPolicyEntry 18 }

pmPolicyRowStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The row status of this pmPolicyEntry.

         The status may not be set to active if any of the related
         entries in the pmPolicyCode table do not have a status of
         active or if any of the objects in this row are not set to
         valid values.

         If this row is deleted, any associated entries in the
         pmPolicyCodeTable will be deleted as well."
    ::= { pmPolicyEntry 19 }


-- Policy Code Table

pmPolicyCodeTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmPolicyCodeEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "The pmPolicyCodeTable stores the code for policy conditions and
        actions."
    ::= { pmMib 2 }

pmPolicyCodeEntry OBJECT-TYPE
    SYNTAX      PmPolicyCodeEntry
    MAX-ACCESS  not-accessible





Various Authors    Expires December 11, 2001         [Page 73]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    STATUS      current
    DESCRIPTION
        "An entry in the policy code table representing one code
        segment. Entries that share a common ProgramIndex value make
        up a single script. Valid values of ProgramIndex are retrieved
        from pmPolicyConditionProgramIndex and pmPolicyActionProgramIndex
        after a pmPolicyEntry is created. Segments of code can then be
        written to this table using the learned ProgramIndex values."
    INDEX { pmPolicyCodeProgramIndex, pmPolicyCodeSegment }
    ::= { pmPolicyCodeTable 1 }

PmPolicyCodeEntry ::= SEQUENCE {
    pmPolicyCodeProgramIndex   Unsigned32,
    pmPolicyCodeSegment        Unsigned32,
    pmPolicyCodeText           UTF8String,
    pmPolicyCodeStatus         RowStatus
}

pmPolicyCodeProgramIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for each policy condition or action. The code
         for each such condition or action may be composed of multiple
         entries in this table if the code cannot fit in one entry.
         Values of pmPolicyCodeProgramIndex may not be used unless
         they have previously been assigned in the
         pmPolicyConditionProgramIndex or pmPolicyActionProgramIndex
         objects."
    ::= { pmPolicyCodeEntry 1 }

pmPolicyCodeSegment OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for each segment of a policy condition or
         action.

         When a policy condition or action spans multiple entries in this
         table, the code of that policy starts from the
         lowest-numbered segment and continues with increasing segment
         values until ending with the highest-numbered segment."
    ::= { pmPolicyCodeEntry 2 }





Various Authors    Expires December 11, 2001         [Page 74]





Internet Draft    Policy-Based Management MIB    June 11, 2001


pmPolicyCodeText OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (1..1024))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "A segment of policy code (condition or action). Lengthy Policy
         conditions or actions may be stored in multiple segments in this
         table that share the same value of pmPolicyCodeProgramIndex.
         When multiple segments are used, it is recommended that each
         segment be as large as practical.

         Entries in this table are associated with policies by values
         of the pmPolicyConditionProgramIndex and
         pmPolicyActionProgramIndex objects. If the status of the
         related policy is active, then this object may not be
         modified."
    ::= { pmPolicyCodeEntry 3 }

pmPolicyCodeStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of this code entry.

         Entries in this table are associated with policies by values
         of the pmPolicyConditionProgramIndex and
         pmPolicyActionProgramIndex objects. If the status of the
         related policy is active, then this object can not be
         modified (I.E., deleted or set to notInService) nor may new
         entries be created."
    ::= { pmPolicyCodeEntry 4 }

-- Element Type Registration Table

-- The Element Type Registration table is used by the manager to learn
-- what element types are being managed by the system and to register
-- new types if necessary. An element type is registered by providing
-- the OID of an SNMP entry (i.e., the xxxEntry object) Each row that
-- exists under that object is a distinct element. The index of the
-- element is the index part of the discovered OID. This index will be
-- supplied to policy conditions and actions so that this code can
-- inspect and configure the element.

pmElementTypeRegTable OBJECT-TYPE





Various Authors    Expires December 11, 2001         [Page 75]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    SYNTAX      SEQUENCE OF PmElementTypeRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A registration table for element types managed by this
        system.

        Note that agents may automatically configure elements in this
        table for frequently used element types (interfaces, circuits,
        etc.). In particular, it may configure elements for whom
        discovery is optimized in one or both of the following ways:

        1. The agent may discover elements by scanning internal data
           structures as opposed to issuing local SNMP requests. It is
           possible to recreate the exact semantics described in this
           table even if local SNMP requests are not issued.

        2. The agent may receive asynchronous notification of new
           elements (for example, 'card inserted') and use that
           information to instantly create elements rather than
           through polling. A similar feature might be available for
           the deletion of elements.

        Note that the disposition of agent-installed entries is
        described by the pmPolicyStorageType object."
    ::= { pmMib 3 }

pmElementTypeRegEntry OBJECT-TYPE
    SYNTAX      PmElementTypeRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A registration of an element type."
    INDEX       { pmElementTypeRegOIDPrefix }
    ::= { pmElementTypeRegTable 1 }

PmElementTypeRegEntry ::= SEQUENCE {
    pmElementTypeRegOIDPrefix     OBJECT IDENTIFIER,
    pmElementTypeRegMaxLatency    Unsigned32,
    pmElementTypeRegDescription   UTF8String,
    pmElementTypeRegStorageType   StorageType,
    pmElementTypeRegRowStatus     RowStatus
}

pmElementTypeRegOIDPrefix OBJECT-TYPE





Various Authors    Expires December 11, 2001         [Page 76]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "This OBJECT IDENTIFIER value identifies a table in which all
        elements of this type will be found. Every row in the
        referenced table will be treated as an element for the
        period of time that it remains in the table. The agent will
        then execute policy conditions and actions as appropriate on each
        of these elements.

        This object identifier value is specified down to the 'entry'
        component (i.e. ifEntry) of the identifier.

        The index of each discovered row will be passed to each
        invocation of the policy condition and policy action.

        The actual mechanism by which instances are discovered is
        implementation-dependent. Periodic walks of the table to
        discover the rows in the table is one such mechanism. This
        mechanism has the advantage that it can be performed by an
        agent with no knowledge of the names, syntax or semantics
        of the MIB objects in the table. This mechanism also serves as
        the reference design. Other implementation-dependent
        mechanisms may be implemented that are more efficient (perhaps
        because they are hard-coded) or that don't require polling.
        These mechanisms must discover the same elements as the
        table-walking reference design.

        A special OBJECT IDENTIFIER '0.0' can be written to this
        object. '0.0' represents the single instance of the system
        itself and provides an execution context for policies to
        operate on 'the system' as well as on MIB objects modeled as
        scalars. For example, '0.0' gives an execution context for
        policy-based selection of the operating system code version
        (likely modeled as a scalar MIB object). The element type
        '0.0' always exists - as a consequence, no actual discovery
        will take place and the pmElementTypeRegMaxLatency object will
        have no effect for the '0.0' element type. However, if the
        '0.0' element type is not registered in the table, policies
        will not be executed on the '0.0' element.

        When a policy is invoked on behalf of a '0.0' entry in this
        table, the element name will be '0.0' and there is no index
        of 'this element' (in other words it has zero length)."





Various Authors    Expires December 11, 2001         [Page 77]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmElementTypeRegEntry 2 }

pmElementTypeRegMaxLatency OBJECT-TYPE
    SYNTAX      Unsigned32
    UNITS       "milliseconds"
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The PM agent is responsible for discovering new elements of
        types that are registered. This object lets the manager
        control the maximum amount of time that may pass between the
        time an element is created and when it is discovered.

        In other words, in any given interval of this duration, all
        new elements must be discovered. Note that it is an
        implementation-dependent matter as to how the policy agent
        schedules the checking of various elements within this
        interval."
    ::= { pmElementTypeRegEntry 3 }

pmElementTypeRegDescription OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..32))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "A descriptive label for this registered type."
    ::= { pmElementTypeRegEntry 4 }

pmElementTypeRegStorageType OBJECT-TYPE
    SYNTAX      StorageType
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "This object defines whether this row is kept
         in volatile storage and lost upon reboot or if this row is
         backed up by non-volatile or permanent storage."
    ::= { pmElementTypeRegEntry 5 }

pmElementTypeRegRowStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The status of this registration entry."
    ::= { pmElementTypeRegEntry 6 }





Various Authors    Expires December 11, 2001         [Page 78]





Internet Draft    Policy-Based Management MIB    June 11, 2001


-- Role Table

-- The pmRoleTable is a read-create table that organizes role
-- strings sorted by element. This table is used to create and modify
-- role strings and their associations as well as to allow a
-- management station to learn about the existence of roles and their
-- associations.
--
-- It is the responsibility of the agent to keep track of any
-- re-indexing of the underlying SNMP elements and to continue to
-- associate role strings with the element with which they were
-- initially configured.
--
-- Policy MIB agents that have elements in multiple local contexts
-- need to allow some roles to be assigned to elements in particular
-- contexts. This is particularly true when some elements have the
-- same names in different contexts and the context is required to
-- disambiguate them. In those situations, a value for the
-- pmRoleContextName may be provided. When a pmRoleContextName value
-- is not provided, the assignment is to the element in the default
-- context.
--
-- Policy MIB agents that discover elements on other systems and
-- execute policies on their behalf need to have access to role
-- information for these remote elements. In such situations, role
-- assignments for other systems can be stored in this table by
-- providing values for the pmRoleContextEngineID parameters.
--
-- For example:
-- Example:
-- element       role    context ctxEngineID   #comment
-- ifindex.1     gold                          local, default context
-- ifindex.2     gold                          local, default context
-- repeaterid.1  foo     rptr1                 local, rptr1 context
-- repeaterid.1  bar     rptr2                 local, rptr2 context
-- ifindex.1     gold    ""      A             different system
-- ifindex.1     gold    ""      B             different system

pmRoleTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmRoleEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The role string table.






Various Authors    Expires December 11, 2001         [Page 79]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         The agent must store role string associations in nonvolatile
         storage."
    ::= { pmMib 4 }

pmRoleEntry OBJECT-TYPE
    SYNTAX      PmRoleEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A role string entry associates a role string with an
         individual element."
    INDEX       { pmRoleElement, pmRoleContextName,
                  pmRoleContextEngineID, pmRoleString }
    ::= { pmRoleTable 1 }

PmRoleEntry ::= SEQUENCE {
    pmRoleElement          RowPointer,
    pmRoleContextName      SnmpAdminString,
    pmRoleContextEngineID  OCTET STRING,
    pmRoleString           UTF8String,
    pmRoleStatus           RowStatus
}

pmRoleElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The element to which this role string is associated.

         If the agent assigns new indexes in the MIB table to
         represent the same underlying element (re-indexing), the
         agent will modify this value to contain the new index for the
         underlying element."
    ::= { pmRoleEntry 1 }

pmRoleContextName OBJECT-TYPE
    SYNTAX      SnmpAdminString
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is not in the default context for
        the target system, this object is used to identify the
        context. If the element is in the default context, this object
        is equal to the empty string."





Various Authors    Expires December 11, 2001         [Page 80]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmRoleEntry 2 }

pmRoleContextEngineID OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE (0..32))
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is on a remote system, this object
        is used to identify the remote system. This object contains
        the contextEngineID of the system that this role string
        assignment is valid for. If the element is on the local system
        this object will be the empty string."
    ::= { pmRoleEntry 3 }

pmRoleString OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..64))
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The role string that is associated with an element through
         this table.

         A role string is an administratively specified characteristic
         of a managed element (for example, an interface). It is a
         selector for policy rules, to determine the applicability of
         the rule to a particular managed element."
    ::= { pmRoleEntry 4 }

pmRoleStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of this role string."
    ::= { pmRoleEntry 5 }

-- Capabilities table

-- The pmCapabilitiesTable contains a description of
-- the inherent capabilities of the system so that scripts can
-- differentially apply code based on the capabilities and so that
-- management stations can learn of an agent's capabilities and
-- differentially install policies based on the capabilities.

pmCapabilitiesTable OBJECT-TYPE





Various Authors    Expires December 11, 2001         [Page 81]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    SYNTAX      SEQUENCE OF PmCapabilitiesEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmCapabilitiesTable contains a description of
         the inherent capabilities of the system.

         Note that it is not necessary to list all
         OIDs that a mechanism specific MIB Module supports, just the
         base OID if the implementation is a fully compliant one. If
         the implementation is not, then additional rows will exist in
         the table that list the limitations or enhancements."
    ::= { pmMib 6 }

pmCapabilitiesEntry OBJECT-TYPE
    SYNTAX      PmCapabilitiesEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The description of a capability or limitation of a
         capability of the system. An entry will exist for each
         domain and mechanism specific ability the system has. In
         the case of a domain specific capability with no mechanism
         specific parameters, the pmCapabilitiesSubType and all other
         columns may be null. Entries will exist that contain
         values for the pmCapabilitiesRestrictOID,
         pmCapabilitiesRestrictType, pmCapabilitiesRestrictValue
         and pmCapabilitiesRestrictString objects only when
         an implementation is reporting a mechanism specific
         restriction. Multiple entries are possible when more
         than one restriction for a type or subtype are needed."
    INDEX       { pmCapabilitiesIndex }
    ::= { pmCapabilitiesTable 1 }

PmCapabilitiesEntry ::= SEQUENCE {
    pmCapabilitiesIndex              Unsigned32,
    pmCapabilitiesType               OBJECT IDENTIFIER,
    pmCapabilitiesSubType            OBJECT IDENTIFIER,
    pmCapabilitiesModificationOID    OBJECT IDENTIFIER,
    pmCapabilitiesModificationType   INTEGER,
    pmCapabilitiesModificationValue  Integer32,
    pmCapabilitiesModificationString OCTET STRING
}

pmCapabilitiesIndex OBJECT-TYPE





Various Authors    Expires December 11, 2001         [Page 82]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for this entry."
    ::= { pmCapabilitiesEntry 1 }

pmCapabilitiesType OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The type of the capability represented by this entry.
         The IANA will publish the list of identifiers that are valid
         values for this object."
    ::= { pmCapabilitiesEntry 2 }

pmCapabilitiesSubType OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The sub type of capability is a pointer to a mechanism specific
          set of capabilities supporting a base technology. In the case of
          DIFFSERV, the OID value here would be the base OID of the
          Differentiated Services Policy MIB Module."
    ::= { pmCapabilitiesEntry 3 }

pmCapabilitiesModificationOID OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The OID of the object that is either not supported, supported
         with one or more limitations, or expanded by an implementation
         specific module. If this columnar object is other than null then
         there must be at least an entry in pmCapabilitiesModificationType.
         Note that this need not be a leaf node or scalar object. If
         an entire table is not supported, this value can be the base OID
         for the table."
     ::= { pmCapabilitiesEntry 4 }

pmCapabilitiesModificationType OBJECT-TYPE
    SYNTAX      INTEGER {
                    unsupported(0),





Various Authors    Expires December 11, 2001         [Page 83]





Internet Draft    Policy-Based Management MIB    June 11, 2001


                    restricted(1),
                    additional(2),
                    addvalue(3),
                    maxlimit(4),
                    minlimit(5)
                }
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "An unsupported value indicates that the OID in
          pmCapabilitiesModificationOID is not supported on
          this system. A value of 1 indicates that the OID
          is supported but with restricted values
          These constraints are described in the
          pmCapabilitiesModificationValue and
          pmCapabilitiesModificationString objects. A value of
          2 indicates a vendor specific extension to a standard.
          The OID of the new object is pmCapabilitiesModificationOID.
          For some implementations, additional functions may be
          provided. addvalue indicates that this row of the table
          describes an additional value that the object can take.
          The specific value is in the pmCapabilitiesModificationValue.
          The values of 4 and 5 indicate restrictions or the removal
          of restrictions for the object identified."
    ::= { pmCapabilitiesEntry 5 }

pmCapabilitiesModificationValue OBJECT-TYPE
    SYNTAX      Integer32 (0..2147483647)
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "If the value of pmCapabilitiesModificationType is 0, this
          object will be null since 0 indicates no support for the
          object at all. A value of 1 in the
          pmCapabilitiesModificationType will be further modified by a
          single integer value in this object that corresponds to
          enumerated integer values that are not supported by the
          system for the object that is identified in this row. This
          value can also represent the limit values in the
          pmCapabilitiesModificationType object."
    ::= { pmCapabilitiesEntry 6 }

pmCapabilitiesModificationString OBJECT-TYPE
    SYNTAX      OCTET STRING
    MAX-ACCESS  read-only





Various Authors    Expires December 11, 2001         [Page 84]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    STATUS      current
    DESCRIPTION
         "Any additional details or description or parameters needed."
    ::= { pmCapabilitiesEntry 7 }

-- The Schedule Group

pmSchedLocalTime OBJECT-TYPE
    SYNTAX      DateAndTime (SIZE (11))
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "The local time used by the scheduler. Schedules which
         refer to calendar time will use the local time indicated
         by this object. An implementation MUST return all 11 bytes
         of the DateAndTime textual-convention so that a manager
         may retrieve the offset from GMT time."
    ::= { pmMib 7 }

--
-- The schedule table which controls the scheduler.
--

pmSchedTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmSchedEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "This table defines schedules for policies."
    ::= { pmMib 8 }

pmSchedEntry OBJECT-TYPE
    SYNTAX      PmSchedEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry describing a particular schedule.

        Unless noted otherwise, writable objects of this row can be
        modified independent of the current value of pmSchedRowStatus,
        pmSchedAdminStatus and pmSchedOperStatus.  In particular, it
        is legal to modify pmSchedWeekDay, pmSchedMonth, pmSchedDay,
        pmSchedHour, and pmSchedMinute when pmSchedRowStatus is
        active."
    INDEX { pmSchedIndex }





Various Authors    Expires December 11, 2001         [Page 85]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmSchedTable 1 }

PmSchedEntry ::= SEQUENCE {
    pmSchedIndex          Unsigned32,
    pmSchedGroupIndex     Unsigned32,
    pmSchedDescr          UTF8String,
    pmSchedTimePeriod     UTF8String,
    pmSchedMonth          BITS,
    pmSchedDay            BITS,
    pmSchedWeekDay        BITS,
    pmSchedTimeOfDay      UTF8String,
    pmSchedLocalOrUtc     INTEGER,
    pmSchedStorageType    StorageType,
    pmSchedRowStatus      RowStatus
}

pmSchedIndex OBJECT-TYPE
    SYNTAX      Unsigned32 (1..65535)
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "The locally-unique, administratively assigned index for this
        scheduling entry."
    ::= { pmSchedEntry 1 }

pmSchedGroupIndex OBJECT-TYPE
    SYNTAX      Unsigned32 (1..65535)
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The locally-unique, administratively assigned index for the
        group that this scheduling entry belongs to.

        To assign multiple schedule entries to the same group, the
        pmSchedGroupIndex of each entry in the group will be set to
        the same value. This pmSchedGroupIndex value must be equal to
        the pmSchedIndex of one of the entries in the group. If the
        entry is deleted whose pmSchedIndex equals the
        pmSchedGroupIndex for the group, the agent will assign a new
        pmSchedGroupIndex to all remaining members of the group.

        If an entry is not a member of a group, its pmSchedGroupIndex
        must be assigned to the value of its pmSchedIndex.

        Policies that are controlled by a group of schedule entries





Various Authors    Expires December 11, 2001         [Page 86]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        are active when any schedule in the group is active."
    ::= { pmSchedEntry 2 }

pmSchedDescr OBJECT-TYPE
    SYNTAX      UTF8String
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The human readable description of the purpose of this
        scheduling entry."
    DEFVAL { ''H }
    ::= { pmSchedEntry 3 }

pmSchedTimePeriod OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..31))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The overall range of calendar dates and times over which this
        schedule is valid. It is stored in a slightly extended version
        of the format for a 'period-explicit' defined in RFC 2445
        [22]. This format is expressed as a string representing the
        starting date and time, in which the character 'T' indicates
        the beginning of the time portion, followed by the solidus
        character '/', followed by a similar string representing an
        end date and time. The start of the period MUST be before the
        end of the period. Date-Time values are expressed as
        substrings of the form 'yyyymmddThhmmss'. For example:

            20000101T080000/20000131T120000

              January 1, 2000, 0800 through January 31, 2000, noon

        The 'Date with UTC time' format defined in RFC 2445 in which
        the Date-Time string ends with the character 'Z' is not
        allowed.

        This 'period-explicit' format is also extended to allow two
        special cases in which one of the Date-Time strings is
        replaced with a special string defined in RFC 2445:

        1. If the first Date-Time value is replaced with the string
           'THISANDPRIOR', then the value indicates that the schedule
           is valid at any time prior to the Date-Time that appears
           after the '/'.





Various Authors    Expires December 11, 2001         [Page 87]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        2. If the second Date-Time is replaced with the string
           'THISANDFUTURE', then the value indicates that the schedule
           is valid at any time after the Date-Time that appears
           before the '/'.

        Note that while RFC 2445 defines these two strings, they are
        not specified for use in the 'period-explicit' format. The use
        of these strings represents an extension to the
        'period-explicit' format."
    ::= { pmSchedEntry 4 }

pmSchedMonth OBJECT-TYPE
    SYNTAX      BITS {
                    january(0),
                    february(1),
                    march(2),
                    april(3),
                    may(4),
                    june(5),
                    july(6),
                    august(7),
                    september(8),
                    october(9),
                    november(10),
                    december(11)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Within the overall time period specified in the
        pmSchedTimePeriod object, the value of this object specifies
        the specific months within that time period that the schedule
        is active. Setting all bits will cause the schedule to act
        independently of the month."
    DEFVAL { { january, february, march, april, may, june, july,
               august, september, october, november, december } }
    ::= { pmSchedEntry 5 }

pmSchedDay OBJECT-TYPE
    SYNTAX      BITS {
                    d1(0),   d2(1),   d3(2),   d4(3),   d5(4),
                    d6(5),   d7(6),   d8(7),   d9(8),   d10(9),
                    d11(10), d12(11), d13(12), d14(13), d15(14),
                    d16(15), d17(16), d18(17), d19(18), d20(19),
                    d21(20), d22(21), d23(22), d24(23), d25(24),





Various Authors    Expires December 11, 2001         [Page 88]





Internet Draft    Policy-Based Management MIB    June 11, 2001


                    d26(25), d27(26), d28(27), d29(28), d30(29),
                    d31(30),
                    r1(31),  r2(32),  r3(33),  r4(34),  r5(35),
                    r6(36),  r7(37),  r8(38),  r9(39),  r10(40),
                    r11(41), r12(42), r13(43), r14(44), r15(45),
                    r16(46), r17(47), r18(48), r19(49), r20(50),
                    r21(51), r22(52), r23(53), r24(54), r25(55),
                    r26(56), r27(57), r28(58), r29(59), r30(60),
                    r31(61)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Within the overall time period specified in the
        pmSchedTimePeriod object, the value of this object specifies
        the specific days of the month within that time period that
        the schedule is active.

        There are two sets of bits one can use to define the day
        within a month:

        Enumerations starting with the letter 'd' indicate a
        day in a month relative to the first day of a month.
        The first day of the month can therefore be specified
        by setting the bit d1(0) and d31(30) means the last
        day of a month with 31 days.

        Enumerations starting with the letter 'r' indicate a
        day in a month in reverse order, relative to the last
        day of a month. The last day in the month can therefore
        be specified by setting the bit r1(31), and r31(61) means
        the first day of a month with 31 days.

        Setting multiple bits will include several days in the set
        of possible days for this schedule.  Setting all bits starting
        with the letter 'd' or all bits starting with the letter 'r'
        will cause the schedule to act independently of the day of the
        month."
    DEFVAL { {  d1, d2, d3, d4, d5, d6, d7, d8, d9, d10,
                d11, d12, d13, d14, d15, d16, d17, d18, d19, d20,
                d21, d22, d23, d24, d25, d26, d27, d28, d29, d30,
                d31, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,
                r11, r12, r13, r14, r15, r16, r17, r18, r19, r20,
                r21, r22, r23, r24, r25, r26, r27, r28, r29, r30,
                r31 } }





Various Authors    Expires December 11, 2001         [Page 89]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmSchedEntry 6 }

pmSchedWeekDay OBJECT-TYPE
    SYNTAX      BITS {
                    sunday(0),
                    monday(1),
                    tuesday(2),
                    wednesday(3),
                    thursday(4),
                    friday(5),
                    saturday(6)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "Within the overall time period specified in the
        pmSchedTimePeriod object, the value of this object specifies
        the specific days of the week within that time period that
        the schedule is active. Setting all bits will cause the
        schedule to act independently of the day of the week."
    DEFVAL { { sunday, monday, tuesday, wednesday, thursday,
               friday, saturday } }
    ::= { pmSchedEntry 7 }

pmSchedTimeOfDay OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..15))
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION

        "Within the overall time period specified in the
        pmSchedTimePeriod object, the value of this object specifies
        the range of times in a day that the schedule is active.

        This value is stored in a format based on the RFC 2445 format
        for 'time': The character 'T' followed by a 'time' string ,
        followed by the solidus character '/', followed by the
        character 'T' followed by a second time string. The first time
        indicates the beginning of the range, while the second time
        indicates the end.  Thus, this value takes the form:
            'Thhmmss/Thhmmss'.

        The second substring always identifies a later time than the
        first substring.  To allow for ranges that span midnight,
        however, the value of the second string may be smaller than





Various Authors    Expires December 11, 2001         [Page 90]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        the value of the first substring.  Thus, 'T080000/T210000'
        identifies the range from 0800 until 2100, while
        'T210000/T080000' identifies the range from 2100 until 0800 of
        the following day.

        When a range spans midnight, it by definition includes parts
        of two successive days.  When one of these days is also
        selected by either the MonthOfYearMask, DayOfMonthMask, and/or
        DayOfWeekMask, but the other day is not, then the policy is
        active only during the portion of the range that falls on the
        selected day.  For example, if the range extends from 2100
        until 0800, and the day of week mask selects Monday and
        Tuesday, then the policy is active during the following three
        intervals:

            From midnight Sunday until 0800 Monday;
            From 2100 Monday until 0800 Tuesday;
            From 2100 Tuesday until 23:59:59 Tuesday.

         Setting this value to 'T000000/T235959' will cause the
         schedule to act independently of the time of day."
    DEFVAL { '543030303030302F54323335393539'H } -- T000000/T235959
    ::= { pmSchedEntry 8 }

pmSchedLocalOrUtc OBJECT-TYPE
    SYNTAX      INTEGER {
                    localTime(1),
                    utcTime(2)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "This object indicates whether the times represented in the
        TimePeriod object and in the various Mask objects represent
        local times or UTC times."
    DEFVAL { utcTime }
    ::= { pmSchedEntry 9 }

pmSchedStorageType OBJECT-TYPE
    SYNTAX      StorageType
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "This object defines whether this schedule entry is kept
         in volatile storage and lost upon reboot or if this row is





Various Authors    Expires December 11, 2001         [Page 91]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         backed up by non-volatile or permanent storage.

         Conceptual rows having the value `permanent' must allow write
         access to the columnar objects pmSchedDescr, pmSchedWeekDay,
         pmSchedMonth, pmSchedDay, pmSchedHour, and pmSchedMinute."
    DEFVAL { volatile }
    ::= { pmSchedEntry 10 }

pmSchedRowStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "The status of this schedule entry."
    ::= { pmSchedEntry 11 }

-- Policy Tracking

-- The "policy to element" (PE) table and the "element to policy" (EP)
-- table track the status of execution contexts grouped by policy and
-- element respectively.

pmTrackingPETable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmTrackingPEEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmTrackingPETable describes what elements
         are under control of a policy. This table is indexed in
         order to optimize retrieval of the entire status for a given
         policy."
    ::= { pmMib 9 }

pmTrackingPEEntry OBJECT-TYPE
    SYNTAX      PmTrackingPEEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "An entry in the pmTrackingPETable.  The pmPolicyIndex in
         the index specifies the policy tracked by this entry."
    INDEX       { pmPolicyIndex, pmTrackingPEElement,
                  pmTrackingPEContextName, pmTrackingPEContextEngineID }
    ::= { pmTrackingPETable 1 }

PmTrackingPEEntry ::= SEQUENCE {





Various Authors    Expires December 11, 2001         [Page 92]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    pmTrackingPEElement          RowPointer,
    pmTrackingPEContextName      SnmpAdminString,
    pmTrackingPEContextEngineID  OCTET STRING,
    pmTrackingPEInfo             BITS
}

pmTrackingPEElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The element that is acted upon by the associated policy."
    ::= { pmTrackingPEEntry 1 }

pmTrackingPEContextName OBJECT-TYPE
    SYNTAX      SnmpAdminString
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is not in the default context for
        the target system, this object is used to identify the
        context. If the element is in the default context, this object
        is equal to the empty string."
    ::= { pmTrackingPEEntry 2 }

pmTrackingPEContextEngineID OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE (0..32))
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is on a remote system, this object
        is used to identify the remote system. This object contains
        the contextEngineID of the system on which the associated
        element resides. If the element is on the local system
        this object will be the empty string."
    ::= { pmTrackingPEEntry 3 }

pmTrackingPEInfo OBJECT-TYPE
    SYNTAX      BITS {
                    conditionMatched(0),
                    actionSkippedDueToPrecedence(1),
                    conditionRunTimeException(2),
                    conditionUserSignal(3),
                    actionRunTimeException(4),
                    actionUserSignal(5)





Various Authors    Expires December 11, 2001         [Page 93]





Internet Draft    Policy-Based Management MIB    June 11, 2001


                }
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "This object returns information about the previous policy
         script executions.

         If the conditionMatched(0) bit is set, the last execution of the
         associated policy condition returned non-zero.

         If the actionSkippedDueToPrecedence(1) bit is set, the last
         execution of the associated policy condition returned non-zero
         but the action is not active because it was trumped by a
         matching policy condition in the same policy group with a higher
         precedence value.

         If the conditionRunTimeException(2) bit is set, the last
         execution of the associated policy condition encountered a
         run-time exception and aborted.

         If the conditionUserSignal(3) bit is set, the last
         execution of the associated policy condition called the
         signalError() function.

         If the actionRunTimeException(4) bit is set, the last
         execution of the associated policy action encountered a
         run-time exception and aborted.

         If the actionUserSignal(5) bit is set, the last
         execution of the associated policy action called the
         signalError() function.

         Entries will only exist in this table of one or more bits are
         set. In particular, if an entry does not exist for a
         particular policy/element combination, it can be assumed that
         the policy's condition did not match this element."
    ::= { pmTrackingPEEntry 4 }

-- Element to Policy Table

pmTrackingEPTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmTrackingEPEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION





Various Authors    Expires December 11, 2001         [Page 94]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         "The pmTrackingEPTable describes what policies
         are controlling an element. This table is indexed in
         order to optimize retrieval of the status of all policies
         active for a given element."
    ::= { pmMib 10 }

pmTrackingEPEntry OBJECT-TYPE
    SYNTAX      PmTrackingEPEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "An entry in the pmTrackingEPTable. Entries exist for all
         element/policy combinations for which the policy's condition
         matches and only if the schedule for the policy is active.

         The pmPolicyIndex in the index specifies the policy
         tracked by this entry."
    INDEX       { pmTrackingEPElement, pmTrackingEPContextName,
                  pmTrackingEPContextEngineID, pmPolicyIndex }
    ::= { pmTrackingEPTable 1 }

PmTrackingEPEntry ::= SEQUENCE {
    pmTrackingEPElement          RowPointer,
    pmTrackingEPContextName      SnmpAdminString,
    pmTrackingEPContextEngineID  OCTET STRING,
    pmTrackingEPStatus           INTEGER
}

pmTrackingEPElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The element acted upon by the associated policy."
    ::= { pmTrackingEPEntry 1 }

pmTrackingEPContextName OBJECT-TYPE
    SYNTAX      SnmpAdminString
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is not in the default context for
        the target system, this object is used to identify the
        context. If the element is in the default context, this object
        is equal to the empty string."





Various Authors    Expires December 11, 2001         [Page 95]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmTrackingEPEntry 2 }

pmTrackingEPContextEngineID OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE (0..32))
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is on a remote system, this object
        is used to identify the remote system. This object contains
        the contextEngineID of the system on which the associated
        element resides. If the element is on the local system
        this object will be the empty string."
    ::= { pmTrackingEPEntry 3 }

pmTrackingEPStatus OBJECT-TYPE
    SYNTAX      INTEGER {
                    on(0),
                    forceOff(1)
                }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "This entry will only exist if the calendar for the policy is
         active and if the associated policyCondition returned 1 for this
         element.

         A policy can be forcibly disabled on a particular element
         by setting this value to forceOff(1). The agent should then
         act as if the policyCondition failed for this element. The
         forceOff(1) state will persist (even across reboots) until
         this value is set to on(0) by a management request. The
         forceOff(1) state may be set even if the entry does not
         previously exist so that future policy invocations can be
         avoided.

         Unless forcibly disabled, if this value exists it's value
         will be on(0)."
    ::= { pmTrackingEPEntry 4 }

-- Policy Debugging Table

-- Policies that have debugging turned on will generate a log entry in
-- the policy debugging table for every runtime exception that occurs
-- in either the condition or action code.






Various Authors    Expires December 11, 2001         [Page 96]





Internet Draft    Policy-Based Management MIB    June 11, 2001


pmDebuggingTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmDebuggingEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "The pmDebuggingTable logs debugging messages when
         policies experience run-time exceptions in either the condition
         or action code and the associated pmPolicyDebugging object
         has been turned on.

         It is an implementation-dependent manner as to the maximum
         number of debugging entries that will be stored and the
         maximum length of time an entry will be kept. If entries must
         be discarded to make room for new entries, the oldest entries
         must be discarded first."
    ::= { pmMib 11 }

pmDebuggingEntry OBJECT-TYPE
    SYNTAX      PmDebuggingEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "An entry in the pmDebuggingTable. The pmPolicyIndex in the
         index specifies the policy that encountered the exception
         that led to this log entry."
    INDEX       { pmPolicyIndex, pmDebuggingElement,
                  pmDebuggingContextName, pmDebuggingContextEngineID,
                  pmDebuggingLogIndex }
    ::= { pmDebuggingTable 1 }

PmDebuggingEntry ::= SEQUENCE {
    pmDebuggingElement          RowPointer,
    pmDebuggingContextName      SnmpAdminString,
    pmDebuggingContextEngineID  OCTET STRING,
    pmDebuggingLogIndex         Unsigned32,
    pmDebuggingMessage          UTF8String
}

pmDebuggingElement OBJECT-TYPE
    SYNTAX      RowPointer
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "The element the policy was executing on when it encountered
         the error that led to this log entry."





Various Authors    Expires December 11, 2001         [Page 97]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmDebuggingEntry 1 }

pmDebuggingContextName OBJECT-TYPE
    SYNTAX      SnmpAdminString
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is not in the default context for
        the target system, this object is used to identify the
        context. If the element is in the default context, this object
        is equal to the empty string."
    ::= { pmDebuggingEntry 2 }

pmDebuggingContextEngineID OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE (0..32))
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "If the associated element is on a remote system, this object
        is used to identify the remote system. This object contains
        the contextEngineID of the system on which the associated
        element resides. If the element is on the local system
        this object will be the empty string."
    ::= { pmDebuggingEntry 3 }

pmDebuggingLogIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "A unique index for this log entry amongst other log entries
         for this policy/element combination."
    ::= { pmDebuggingEntry 4 }

pmDebuggingMessage OBJECT-TYPE
    SYNTAX      UTF8String (SIZE (0..128))
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
         "An error message generated by the policy execution
         environment. It's recommended that this message include the
         time of day that the message was generated, if known."
    ::= { pmDebuggingEntry 5 }

-- Notification Registration Table





Various Authors    Expires December 11, 2001         [Page 98]





Internet Draft    Policy-Based Management MIB    June 11, 2001


-- A management station may choose not to install policies to a
-- system that depend on roles or capabilities that don't exist on any
-- elements in the system. However, the management station must be able
-- to quickly learn if new roles or capabilities are added to the
-- system so that it can immediately install the policies that make
-- use of that new role or capability. This table allows a management
-- station to register itself so that it will receive
-- pmNewRoleNotifications and pmNewCapabilityNotifications whenever a
-- role or capability first appears on the system.
--
-- pmNewRoleNotifications and pmNewCapabilityNotifications are sent in
-- Inform PDU's so they are automatically retransmitted if they are
-- not acknowledged.
--
-- The procedure to guarantee accurate knowledge of roles and
-- capabilities is as follows:
--
--   Step 1: The NMS registers itself in the pmNotificationRegTable
--           Whenever it receives a notification, it adds the new role
--           or capability to its internal database for that system.
--           Followed immediately by:
--   Step 2: The NMS retrieves the roles and capabilities from the
--           system from the pmRoleTable and the
--           pmCapabilitiesTable, adding this information to its
--           internal database.
--           Followed immediately by:
--   Step 3: The NMS installs policies on the system, potentially
--           skipping policies that depend on roles or capabilities
--           that haven't been inserted into the internal database.
--           Followed immediately by:
--   Step 4: Whenever a notification indicates a new role or
--           capability that requires new policies to be installed,
--           it will immediately install such policies. The NMS will
--           continue this step indefinitely.
--
-- Note that using this algorithm to avoid installing "unnecessary"
-- policies may result in delays in having the policy available when
-- the policy becomes necessary. This delay could become extensive if
-- an interruption of communications prevents the notification from
-- being delivered and/or the policy from being installed, causing
-- the system to not be in compliance with policy for a period of
-- time. In particular, if the policy is enforcing security rules,
-- this could open up security vulnerabilities during this period of
-- time.






Various Authors    Expires December 11, 2001         [Page 99]





Internet Draft    Policy-Based Management MIB    June 11, 2001


pmNotificationRegTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF PmNotificationRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "A manager that wishes to receive notifications about new
        roles or capabilities on an agent places an entry in the
        notification registration table. pmNewRoleNotifications and
        pmNewCapabilityNotifications will then be sent to the target
        specified in the associated snmpTargetAddr entry. These
        notifications will be sent until the entry is removed from
        this table."
    ::= { pmMib 12 }

pmNotificationRegEntry OBJECT-TYPE
    SYNTAX      PmNotificationRegEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "An entry in the pmNotificationRegTable."
    INDEX { pmNotificationRegIndex }
    ::= { pmNotificationRegTable 1 }

PmNotificationRegEntry ::= SEQUENCE {
    pmNotificationRegIndex                Unsigned32,
    pmNotificationRegSnmpTargetAddrName   SnmpAdminString,
    pmNotificationRegStorageType          StorageType,
    pmNotificationRegStatus               RowStatus
}

pmNotificationRegIndex OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
         "A unique index for this entry."
    ::= { pmNotificationRegEntry 1 }

pmNotificationRegSnmpTargetAddrName OBJECT-TYPE
    SYNTAX      SnmpAdminString
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The snmpTargetAddrName of an associated
         snmpTargetAddrEntry. When the following conditions are true,





Various Authors    Expires December 11, 2001        [Page 100]





Internet Draft    Policy-Based Management MIB    June 11, 2001


         pmNewRoleNotifications and pmNewCapabilityNotifications
         should be sent to the specified target:

           1) The pmNotificationRegEntry is active
           2) The associated snmpTargetAddr entry is fully
              configured and active.
           3) The associated snmpTargetParams entry is fully
              configured and active."
    ::= { pmNotificationRegEntry 2 }

pmNotificationRegStorageType OBJECT-TYPE
    SYNTAX      StorageType
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "This object defines whether this row is kept
         in volatile storage and lost upon reboot or if this row is
         backed up by non-volatile or permanent storage."
    ::= { pmNotificationRegEntry 3 }

pmNotificationRegStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
         "The status of this entry."
    ::= { pmNotificationRegEntry 4 }

-- Notifications

pmNotifications OBJECT IDENTIFIER ::= { pmMib 13 }

pmNewRoleNotification NOTIFICATION-TYPE
    OBJECTS     { pmRoleStatus }
    STATUS      current
    DESCRIPTION
        "The pmNewRoleNotification is sent when an agent is configured with
        its first instance of a previously unused role string (not
        every time a new element is given a particular role).

        An instance of the pmRoleStatus object is sent containing
        the new roleString in it's index. In the event that two or
        more elements are given the same role simultaneously, it is an
        implementation-dependent matter as to which pmRoleTable
        instance will be included in the notification."





Various Authors    Expires December 11, 2001        [Page 101]





Internet Draft    Policy-Based Management MIB    June 11, 2001


    ::= { pmNotifications 1 }

pmNewCapabilityNotification NOTIFICATION-TYPE
    OBJECTS     { pmCapabilitiesType }
    STATUS      current
    DESCRIPTION
        "The pmNewCapabilityNotification is sent when an agent
        gains a new capability that did not previously exist in any
        element on the system (not every time an element gains a
        particular role).

        An instance of the pmCapabilitiesType object is sent containing
        the identity of the new capability. In the event that two or
        more elements gain the same capability simultaneously, it is an
        implementation-dependent matter as to which pmCapabilitiesType
        instance will be included in the notification."
    ::= { pmNotifications 2 }

pmAbnormalTerminationNotification NOTIFICATION-TYPE
    OBJECTS     { pmTrackingPEInfo }
    STATUS      current
    DESCRIPTION
        "The pmAbnormalTerminationNotification is sent when a policy's
        pmPolicyAbnormalTerminations gauge changes value from zero to
        any value greater than zero and no such notification has been
        sent for that policy in the last 5 minutes.

        The notification contains an instance of the pmTrackingPEInfo
        object where the pmPolicyIndex component of the index
        identifies the associated policy and the rest of the index
        identifies an element on which the policy failed."
    ::= { pmNotifications 3 }

-- Compliance Statements

    pmConformance   OBJECT IDENTIFIER ::= { pmMib 20 }
    pmCompliances   OBJECT IDENTIFIER ::= { pmConformance 1 }
    pmGroups        OBJECT IDENTIFIER ::= { pmConformance 2 }

pmCompliance MODULE-COMPLIANCE
    STATUS  current
    DESCRIPTION
        "Describes the requirements for conformance to
        the Policy-Based Management MIB"
    MODULE  -- this module





Various Authors    Expires December 11, 2001        [Page 102]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        MANDATORY-GROUPS { pmPolicyManagementGroup, pmSchedGroup,
                           pmNotificationGroup }
    ::= { pmCompliances 1 }

pmPolicyManagementGroup OBJECT-GROUP
    OBJECTS { pmPolicyGroup, pmPolicyPrecedence,
              pmPolicySchedule, pmPolicyElementTypeFilter,
              pmPolicyConditionProgramIndex, pmPolicyActionProgramIndex,
              pmPolicyParameters,
              pmPolicyConditionMaxLatency, pmPolicyActionMaxLatency,
              pmPolicyMaxIterations,
              pmPolicyDescription, pmPolicyMatches,
              pmPolicyAbnormalTerminations,
              pmPolicyExecutionErrors, pmPolicyDebugging,
              pmPolicyStorageType, pmPolicyAdminStatus,
              pmPolicyRowStatus, pmPolicyCodeText, pmPolicyCodeStatus,
              pmElementTypeRegMaxLatency, pmElementTypeRegDescription,
              pmElementTypeRegStorageType, pmElementTypeRegRowStatus,
              pmRoleStatus,
              pmCapabilitiesType, pmCapabilitiesSubType,
              pmCapabilitiesModificationOID,
              pmCapabilitiesModificationType,
              pmCapabilitiesModificationValue,
              pmCapabilitiesModificationString,
              pmTrackingPEInfo,
              pmTrackingEPStatus,
              pmDebuggingElement, pmDebuggingLogIndex,
              pmDebuggingMessage,
              pmNotificationRegSnmpTargetAddrName,
              pmNotificationRegStorageType, pmNotificationRegStatus }
    STATUS  current
    DESCRIPTION
        "Objects that allow for the creation and management of
        configuration policies."
    ::=  { pmGroups 1 }

pmSchedGroup OBJECT-GROUP
    OBJECTS { pmSchedLocalTime, pmSchedGroupIndex,
              pmSchedDescr, pmSchedTimePeriod,
              pmSchedMonth, pmSchedDay, pmSchedWeekDay,
              pmSchedTimeOfDay, pmSchedLocalOrUtc, pmSchedStorageType,
              pmSchedRowStatus
            }
    STATUS current
    DESCRIPTION





Various Authors    Expires December 11, 2001        [Page 103]





Internet Draft    Policy-Based Management MIB    June 11, 2001


        "Objects that allow for the scheduling of policies."
    ::= { pmGroups 2 }

pmNotificationGroup NOTIFICATION-GROUP
    NOTIFICATIONS { pmNewRoleNotification,
                    pmNewCapabilityNotification,
                    pmAbnormalTerminationNotification }
    STATUS        current
    DESCRIPTION
        "Notifications sent by an Policy MIB agent."
    ::= { pmGroups 3 }

pmBaseFunctionLibrary OBJECT IDENTIFIER ::= { pmGroups 4 }

END



































Various Authors    Expires December 11, 2001        [Page 104]





Internet Draft    Policy-Based Management MIB    June 11, 2001


12.  Security Considerations

There are a number of management objects defined in this MIB
that have a MAX-ACCESS clause of read-write and/or read-
create.  Such objects may be considered sensitive or
vulnerable in some network environments.  The support for SET
operations in a non-secure environment without proper
protection can have a negative effect on network operations.

SNMPv1 by itself is not a secure environment.  Even if the
network itself is secure (for example by using IPSec), even
then, there is no control as to who on the secure network is
allowed to access and GET/SET (read/change/create/delete) the
objects in this MIB.

It is recommended that the implementers consider the security
features as provided by the SNMPv3 framework.  Specifically,
the use of the User-based Security Model RFC 2574 [12] and the
View-based Access Control Model RFC 2575 [15] is recommended.

It is then a customer/user responsibility to ensure that the
SNMP entity giving access to an instance of this MIB, is
properly configured to give access to the objects only to
those principals (users) that have legitimate rights to indeed
GET or SET (change/create/delete) them.

Access control for SNMP requests made to the local system
depends on the security credentials of the last entity to
modify any object in the condition or action for a policy.
These security credentials are the input parameters for
isAccessAllowed from the Architecture for Describing SNMP
Management Frameworks[1].


Some policies may be designed to ensure the security of a
network. If these policies have not been installed pending the
appearance of a role or capability, some delay will occur in
the activation of these policies when the role or capability
appears because a responsible manager must notice the change
and install the policy. This delay may expose the device or
the network to unacceptable security vulnerabilities during
this delay. If the role or capability appears during a time of
network stress or when the management station is unavailable,
this delay could be extensive, further increasing the
exposure. It is recommended that management stations install





Various Authors    Expires December 11, 2001        [Page 105]





Internet Draft    Policy-Based Management MIB    June 11, 2001


any security-related policies that might ever be needed on a
particular managed device, even if a nonexistent role or
capability suggests it is not needed at a given time.


13.  Acknowledgements

The authors gratefully acknowledge the significant
contributions to this work made by Jeff Case, Joel Halpern,
Pablo Halpern, and David Partain.








































Various Authors    Expires December 11, 2001        [Page 106]





Internet Draft    Policy-Based Management MIB    June 11, 2001


14.  References

[1]  Harrington, D., Presuhn, R., and B. Wijnen, "An
     Architecture for Describing SNMP Management Frameworks",
     RFC 2571, April 1999.

[2]  Rose, M., and K. McCloghrie, "Structure and
     Identification of Management Information for TCP/IP-based
     Internets", STD 16, RFC 1155, May 1990.

[3]  Rose, M., and K. McCloghrie, "Concise MIB Definitions",
     STD 16, RFC 1212, March 1991.

[4]  Rose, M., "A Convention for Defining Traps for use with
     the SNMP", RFC 1215, March 1991.

[5]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,
     Rose, M., and S. Waldbusser, "Structure of Management
     Information Version 2 (SMIv2)", STD 58, RFC 2578, April
     1999.

[6]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,
     Rose, M., and S. Waldbusser, "Textual Conventions for
     SMIv2", STD 58, RFC 2579, April 1999.

[7]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J.,
     Rose, M., and S. Waldbusser, "Conformance Statements for
     SMIv2", STD 58, RFC 2580, April 1999.

[8]  Case, J., Fedor, M., Schoffstall, M., and J. Davin,
     "Simple Network Management Protocol", STD 15, RFC 1157,
     May 1990.

[9]  Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,
     "Introduction to Community-based SNMPv2", RFC 1901,
     January 1996.

[10] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,
     "Transport Mappings for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1906, January 1996.

[11] Case, J., Harrington D., Presuhn R., and B. Wijnen,
     "Message Processing and Dispatching for the Simple
     Network Management Protocol (SNMP)", RFC 2572, April
     1999.





Various Authors    Expires December 11, 2001        [Page 107]





Internet Draft    Policy-Based Management MIB    June 11, 2001


[12] Blumenthal, U., and B. Wijnen, "User-based Security Model
     (USM) for version 3 of the Simple Network Management
     Protocol (SNMPv3)", RFC 2574, April 1999.

[13] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,
     "Protocol Operations for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1905, January 1996.

[14] Levi, D., Meyer, P., and B. Stewart, "SNMPv3
     Applications", RFC 2573, April 1999.

[15] Wijnen, B., Presuhn, R., and K. McCloghrie, "View-based
     Access Control Model (VACM) for the Simple Network
     Management Protocol (SNMP)", RFC 2575, April 1999.

[16] McCloghrie, K. and M. Rose, Editors, "Management
     Information Base for Network Management of TCP/IP-based
     internets: MIB-II", STD 17, RFC 1213, Hughes LAN Systems,
     Performance Systems International, March 1991.

[17] McCloghrie, K. and F. Kastenholz, "The Interfaces Group
     MIB using SMIv2", RFC 2233, Cisco Systems, FTP Software,
     November 1997.

[18] Case, J., Mundy, R., Partain, D., and B. Stewart,
     "Introduction to Version 3 of the Internet-standard
     Network Management Framework", RFC 2570, April 1999.

[19] International Standards Organization, "Information
     Technology - Programming Languages - C++", ISO/IEC
     14882-1998

[20] ECMA, "ECMAScript Language Specification", ECMA-262,
     December 1999

[21] Moore, B., Ellesson, E., Strassner, J., and A.
     Westerinen, "Policy Core Information Model -- Version 1
     Specification", RFC 3060, February 2001.

[22] Dawson, F. and D. Stenerson, "Internet Calendaring and
     Scheduling Core Object Specification (iCalendar)", RFC
     2445, November 1998








Various Authors    Expires December 11, 2001        [Page 108]





Internet Draft    Policy-Based Management MIB    June 11, 2001


15.  Intellectual Property

The IETF takes no position regarding the validity or scope of
any intellectual property or other rights that might be
claimed to  pertain to the implementation or use of the
technology described in this document or the extent to which
any license under such rights might or might not be available;
neither does it represent that it has made any effort to
identify any such rights.  Information on the IETF's
procedures with respect to rights in standards-track and
standards-related documentation can be found in BCP-11.
Copies of claims of rights made available for publication and
any assurances of licenses to be made available, or the result
of an attempt made to obtain a general license or permission
for the use of such proprietary rights by implementors or
users of this specification can be obtained from the IETF
Secretariat.

The IETF invites any interested party to bring to its
attention any copyrights, patents or patent applications, or
other proprietary rights which may cover technology that may
be required to practice this standard.  Please address the
information to the IETF Executive Director.


16.  Full Copyright Statement

Copyright (C) The Internet Society (2001). All Rights Reserved.

This document and translations of it may be copied and
furnished to others, and derivative works that comment on or
otherwise explain it or assist in its implementation may be
prepared, copied, published and distributed, in whole or in
part, without restriction of any kind, provided that the above
copyright notice and this paragraph are included on all such
copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the
copyright notice or references to the Internet Society or
other Internet organizations, except as needed for the
purpose of developing Internet standards in which case the
procedures for copyrights defined in the Internet Standards
process must be followed, or as required to translate it into
languages other than English.

The limited permissions granted above are perpetual and will





Various Authors    Expires December 11, 2001        [Page 109]





Internet Draft    Policy-Based Management MIB    June 11, 2001


not be revoked by the Internet Society or its successors or
assigns.

This document and the information contained herein is provided
on an "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET
ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR
ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.








































Various Authors    Expires December 11, 2001        [Page 110]





Internet Draft    Policy-Based Management MIB    June 11, 2001


Table of Contents


1 Abstract ..............................................    1
2 The SNMP Management Framework .........................    2
3 Overview ..............................................    4
4 Policy-Based Management Architecture ..................    5
5 Policy Based Management Execution Environment .........    8
5.1 Terminology .........................................    8
5.2 Element Discovery ...................................    9
5.2.1 Implementation Notes ..............................   10
5.3 Element Filtering ...................................   11
5.3.1 Implementation Notes ..............................   11
5.4 Policy Enforcement ..................................   12
5.4.1 Implementation Notes ..............................   12
6 The PolicyScript Language .............................   13
6.1 Formal Definition ...................................   14
6.2 Variables ...........................................   17
6.2.1 The var class .....................................   18
6.3 PolicyScript QuickStart Guide .......................   22
6.3.1 Quickstart for C Programmers ......................   24
6.3.2 Quickstart for Perl Programmers ...................   24
6.3.3 Quickstart for TCL Programmers ....................   24
6.3.4 Quickstart for Python Programmers .................   25
6.3.5  Quickstart  for   JavaScript/ECMAScript/JScript
     Programmers ........................................   25
7 Index information for `this element' ..................   25
8 Accessor Functions ....................................   26
9 Base Accessor Function Library ........................   26
9.1 SNMP Accessor Functions .............................   27
9.1.1 SNMP Operations on Non-Local Systems ..............   28
9.1.2 Form of SNMP Values ...............................   29
9.1.3 Convenience SNMP Functions ........................   30
9.1.3.1 getVar() ........................................   30
9.1.3.2 exists() ........................................   31
9.1.3.3 setVar() ........................................   32
9.1.3.4 searchColumn() ..................................   32
9.1.3.5 setRowStatus() ..................................   35
9.1.3.6 counterRate() ...................................   37
9.1.3.7 counter32Delta() ................................   38
9.1.4 General SNMP Functions ............................   38
9.1.4.1 newPDU() ........................................   40
9.1.4.2 writeVar() ......................................   40
9.1.4.3 readVar() .......................................   41
9.1.4.4 snmpSend() ......................................   41





Various Authors    Expires December 11, 2001        [Page 111]





Internet Draft    Policy-Based Management MIB    June 11, 2001


9.2 Constants ...........................................   42
9.3 Policy Accessor Functions ...........................   44
9.3.1 roleMatch() .......................................   44
9.3.2 capMatch() ........................................   45
9.3.3 elementName() .....................................   45
9.3.4 ec() ..............................................   46
9.3.5 ev() ..............................................   46
9.3.6 context() .........................................   46
9.3.7 elementAddress() ..................................   46
9.3.8 setScratchpad() ...................................   47
9.3.9 getScratchpad() ...................................   48
9.3.10 Constants ........................................   50
9.3.11 signalError() ....................................   50
9.3.12 defer() ..........................................   51
9.3.13 die() ............................................   51
9.3.14 getParameters() ..................................   52
9.4 Utility Accessor Functions ..........................   52
9.4.1 regexp() ..........................................   53
9.4.2 regexpReplace() ...................................   53
9.4.3 oidlen() ..........................................   53
9.4.4 oidncmp() .........................................   54
9.4.5 inSubtree() .......................................   54
9.4.6 subid() ...........................................   54
9.4.7 subidWrite() ......................................   54
9.4.8 oidSplice() .......................................   55
9.4.9 parseIndex() ......................................   55
9.4.10 stringToDotted() .................................   57
9.4.11 integer() ........................................   57
9.4.12 string() .........................................   57
9.4.13 type() ...........................................   58
9.4.14 chr() ............................................   58
9.4.15 ord() ............................................   58
9.4.16 substr() .........................................   58
9.5 Library Accessor Functions ..........................   59
10 Schedule Table .......................................   59
11 Definitions ..........................................   62
12 Security Considerations ..............................  105
13 Acknowledgements .....................................  106
14 References ...........................................  107
15 Intellectual Property ................................  109
16 Full Copyright Statement .............................  109









Various Authors    Expires December 11, 2001        [Page 112]

