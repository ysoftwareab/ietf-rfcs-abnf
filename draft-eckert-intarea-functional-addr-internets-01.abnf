Command = 1 could be a "steer" command and the parameter is another
address = prefix{.nodefunction{.nodefunction-parameters}}
prefix = semantic{.semantic-parameters}

unicast-forward = &lt;set of prefixes>
unicast-forward-parameters = node-prefix

multicast-forward = &lt;set of prefixes>
multicast-forward-parameters = multicast-group

                                  Figure 2
unicast-forward = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D
multicast-forward = E

                                Figure 3

   In other words, because IP multicast uses addresses 224.0.0.0/4, its
   non-overlapping semantic prefix is E, and IPv4 unicast addresses use
   the non-overlapping prefixes 0...D.  Assume further that a node in
   the network had assigned prefix 10.0.0.0/24, then this would
   translate in our scheme into:

   0.A0000.XX

                                  Figure 4

   When a node processes this address, the 4-bit prefix 0 indicates that
   the following prefix has to be looked up in unicast forwarding.  This
   prefix is A0000.  Once the packet is delivered to the node, he
   remaining 8 bit XX can accordingly be interpreted by the node as a
   nodefunction with parameters.

   Likewise, an address 239.1.2.3 would translate into E.F010203, so the
   first 4-bit E value would indicate that multicast forwarding needs to
   be applied to the rest of the address, and with IP Multicast
   forwarding not having further structure (ignoring willfully for
   simplicity of the example that it does, for example with SSM), all
   the remainder of the IPv4 address is the multicast-group

   In summary, the logic does really only generalize what routers today
   already do when they do prefix lookups, except for the following core
   differences:

   *  In IPv4/IPv6, the address semantic is hard-coded by IETF
      standards.  In FA-IINAS they are definable by every network.

   *  In IPv4/IPv6, there is no notion of nodefunction{.nodefunction-
      parameters}, only SRv6 has this concept.
   In actual IPv4/IPv6 hardware forwarding lookups, one would not do one
   lookup for the semantic, followed by another lookup for the semantic-
   parameters for the case of unicast-forward, instead this would be
   flattened.  The same type of flattening would of course be useable in
   FA-IINAS.  Whether or how flattening or other optimizations are
   feasible for other semantics such as multicast is of course highly
   semantic and node implementation specific.

