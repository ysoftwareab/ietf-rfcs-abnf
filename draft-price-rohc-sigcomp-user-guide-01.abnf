token            =     (name / opcode / delimiter / dec / bin / hex) 
    
name             =     (lowercase / "_") 1*(lowercase / digit / "_") 
    
opcode           =     uppercase *(uppercase / digit / "-") 
    
delimiter        =     "." / "!" / "$" / ":" / "(" / ")" / operator 
    
dec              =     1*(digit) 
    
bin              =     "0b" 1*("0" / "1") 
    
hex              =     "0x" 1*(hex_digit) 
    
hex_digit        =     digit / %x41-46 / %x61-66 
    
digit            =     %x30-39 
    

 
 
 
 
 
uppercase        =     %x41-5a 
    
lowercase        =     %x61-7a 
    
operator         =     "+" / "-" / "*" / "/" / "%" / "&" / "|" / 
                          "^" / "~" / "<<" / ">>" 
    
ws               =     *(%x09 / %x0a / %x0d / %x20 / comment) 
    
comment          =     ";" *(%x00-09 / %x0b-0c / %x0e-ff) 
                          (%x0a / %x0d) 
    
assembly         =     *(instruction / directive / label) 
    
instruction      =     opcode ["(" operand *("," operand) ")"] 

 
 
 
 
 
operand          =     [["$"] expression] 
                              ; An empty operand is one that can be 
                              ; computed, typically a literal (#) 
                              ; operand that gives the number of 
                              ; operands. 
                              ; When "$" is prepended to an operand, 
                              ; the corresponding integer is an 
                              ; address rather than the actual operand 
                              ; value. This symbol is mandatory for 
                              ; reference operands ($), optional for 
                              ; multitypes (%) and addresses (@), and 
                              ; disallowed for literals (#). 
    
label            =     ":" name 
                              ; abbreviation for set(<name>, .) 
    
directive        =     padding / data / set 
                              ; note that directive names are  
                              ; syntactically of category <name>; all  
                              ; directives are intended to syntactically  
                              ; match: name ["(" expression *(","  
                              ; expression) ")"] 
    
padding          =     ("pad" / "align" / "at") "(" expression ")" 
    
data             =     ("byte" / "word") "(" expression *(","  
                          expression) ")" 
    
set              =     "set" "(" name "," expression ")" 
    
expression       =     value / "(" expression operator expression ")" 
    
value            =     dec / bin / hex / name / "." / "!" 
                              ; "." is the location of this  
                              ; instruction/directive, whereas "!" is  
                              ; the location of the closest  
                              ; DECOMPRESSION_FAILURE 
    
