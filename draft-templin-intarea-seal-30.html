<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The Subnetwork Encapsulation and Adaptation Layer (SEAL)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Motivation">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Approach">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Requirements">
<link href="#rfc.section.3" rel="Chapter" title="3 Applicability Statement">
<link href="#rfc.section.4" rel="Chapter" title="4 SEAL Specification">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 VET Interface Model">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 SEAL Model of Operation">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 SEAL Header Format">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 ITE Specification">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Tunnel Interface MTU">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Tunnel Interface Soft State">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 Submitting Packets for Encapsulation">
<link href="#rfc.section.4.4.4" rel="Chapter" title="4.4.4 Mid-Layer Encapsulation">
<link href="#rfc.section.4.4.5" rel="Chapter" title="4.4.5 SEAL Segmentation">
<link href="#rfc.section.4.4.6" rel="Chapter" title="4.4.6 SEAL Encapsulation">
<link href="#rfc.section.4.4.7" rel="Chapter" title="4.4.7 Outer Encapsulation">
<link href="#rfc.section.4.4.8" rel="Chapter" title="4.4.8 Sending SEAL Protocol Packets">
<link href="#rfc.section.4.4.9" rel="Chapter" title="4.4.9 Probing Strategy">
<link href="#rfc.section.4.4.10" rel="Chapter" title="4.4.10 Processing ICMP Messages">
<link href="#rfc.section.4.4.11" rel="Chapter" title="4.4.11 Black Hole Detection">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 ETE Specification">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Reassembly Buffer Requirements">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Tunnel Interface Soft State">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 IP-Layer Reassembly">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 SEAL-Layer Reassembly">
<link href="#rfc.section.4.5.5" rel="Chapter" title="4.5.5 Decapsulation and Delivery to Upper Layers">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 The SEAL Control Message Protocol (SCMP)">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Generating SCMP Messages">
<link href="#rfc.section.4.6.1.1" rel="Chapter" title="4.6.1.1 Generating SCMP Packet Too Big (PTB) Messages">
<link href="#rfc.section.4.6.1.2" rel="Chapter" title="4.6.1.2 Generating Other SCMP Error Messages">
<link href="#rfc.section.4.6.1.3" rel="Chapter" title="4.6.1.3 Generating SCMP Redirection Messages">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 Processing SCMP Messages">
<link href="#rfc.section.4.6.2.1" rel="Chapter" title="4.6.2.1 Processing SCMP PTB Messages">
<link href="#rfc.section.4.6.2.2" rel="Chapter" title="4.6.2.2 Processing Other SCMP Error Messages">
<link href="#rfc.section.4.6.2.3" rel="Chapter" title="4.6.2.3 Processing SCMP Redirection Messages">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Tunnel Endpoint Synchronization">
<link href="#rfc.section.5" rel="Chapter" title="5 Link Requirements">
<link href="#rfc.section.6" rel="Chapter" title="6 End System Requirements">
<link href="#rfc.section.7" rel="Chapter" title="7 Router Requirements">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Related Work">
<link href="#rfc.section.11" rel="Chapter" title="11 SEAL Advantages over Classical Methods">
<link href="#rfc.section.12" rel="Chapter" title="12 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Reliability">
<link href="#rfc.appendix.Appendix%20B" rel="Chapter" title="Appendix B Integrity">
<link href="#rfc.appendix.Appendix%20C" rel="Chapter" title="Appendix C Transport Mode">
<link href="#rfc.appendix.Appendix%20D" rel="Chapter" title="Appendix D Historic Evolution of PMTUD">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="For the purpose of this document, a subnetwork is defined as a virtual topology configured over a connected IP network routing region and bounded by encapsulating border nodes. These virtual topologies are manifested by tunnels that may span multiple IP and/or sub-IP layer forwarding hops, and can introduce failure modes due to packet duplication and/or links with diverse Maximum Transmission Units (MTUs).  This document specifies a Subnetwork Encapsulation and Adaptation Layer (SEAL) that accommodates such virtual topologies over diverse underlying link technologies." />
  <meta name="description" content="For the purpose of this document, a subnetwork is defined as a virtual topology configured over a connected IP network routing region and bounded by encapsulating border nodes. These virtual topologies are manifested by tunnels that may span multiple IP and/or sub-IP layer forwarding hops, and can introduce failure modes due to packet duplication and/or links with diverse Maximum Transmission Units (MTUs).  This document specifies a Subnetwork Encapsulation and Adaptation Layer (SEAL) that accommodates such virtual topologies over diverse underlying link technologies." />
  <meta name="keywords" content="I-D, Internet-Draft" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">F. L. Templin, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Boeing Research &amp; Technology</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">August 31, 2011</td>
</tr>
<tr>
<td class="left">Expires: March 03, 2012</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The Subnetwork Encapsulation and Adaptation Layer (SEAL)<br />
  <span class="filename">draft-templin-intarea-seal-30.txt</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>For the purpose of this document, a subnetwork is defined as a virtual topology configured over a connected IP network routing region and bounded by encapsulating border nodes. These virtual topologies are manifested by tunnels that may span multiple IP and/or sub-IP layer forwarding hops, and can introduce failure modes due to packet duplication and/or links with diverse Maximum Transmission Units (MTUs).  This document specifies a Subnetwork Encapsulation and Adaptation Layer (SEAL) that accommodates such virtual topologies over diverse underlying link technologies.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 03, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Motivation</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Approach</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Requirements</a>
</li>
<li>3.   <a href="#rfc.section.3">Applicability Statement</a>
</li>
<li>4.   <a href="#rfc.section.4">SEAL Specification</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">VET Interface Model</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">SEAL Model of Operation</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">SEAL Header Format</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">ITE Specification</a>
</li>
<li>4.4.1.   <a href="#rfc.section.4.4.1">Tunnel Interface MTU</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Tunnel Interface Soft State</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">Submitting Packets for Encapsulation</a>
</li>
<li>4.4.4.   <a href="#rfc.section.4.4.4">Mid-Layer Encapsulation</a>
</li>
<li>4.4.5.   <a href="#rfc.section.4.4.5">SEAL Segmentation</a>
</li>
<li>4.4.6.   <a href="#rfc.section.4.4.6">SEAL Encapsulation</a>
</li>
<li>4.4.7.   <a href="#rfc.section.4.4.7">Outer Encapsulation</a>
</li>
<li>4.4.8.   <a href="#rfc.section.4.4.8">Sending SEAL Protocol Packets</a>
</li>
<li>4.4.9.   <a href="#rfc.section.4.4.9">Probing Strategy</a>
</li>
<li>4.4.10.   <a href="#rfc.section.4.4.10">Processing ICMP Messages</a>
</li>
<li>4.4.11.   <a href="#rfc.section.4.4.11">Black Hole Detection</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">ETE Specification</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">Reassembly Buffer Requirements</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Tunnel Interface Soft State</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">IP-Layer Reassembly</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">SEAL-Layer Reassembly</a>
</li>
<li>4.5.5.   <a href="#rfc.section.4.5.5">Decapsulation and Delivery to Upper Layers</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">The SEAL Control Message Protocol (SCMP)</a>
</li>
<li>4.6.1.   <a href="#rfc.section.4.6.1">Generating SCMP Messages</a>
</li>
<li>4.6.1.1.   <a href="#rfc.section.4.6.1.1">Generating SCMP Packet Too Big (PTB) Messages</a>
</li>
<li>4.6.1.2.   <a href="#rfc.section.4.6.1.2">Generating Other SCMP Error Messages</a>
</li>
<li>4.6.1.3.   <a href="#rfc.section.4.6.1.3">Generating SCMP Redirection Messages</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">Processing SCMP Messages</a>
</li>
<li>4.6.2.1.   <a href="#rfc.section.4.6.2.1">Processing SCMP PTB Messages</a>
</li>
<li>4.6.2.2.   <a href="#rfc.section.4.6.2.2">Processing Other SCMP Error Messages</a>
</li>
<li>4.6.2.3.   <a href="#rfc.section.4.6.2.3">Processing SCMP Redirection Messages</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Tunnel Endpoint Synchronization</a>
</li>
<li>5.   <a href="#rfc.section.5">Link Requirements</a>
</li>
<li>6.   <a href="#rfc.section.6">End System Requirements</a>
</li>
<li>7.   <a href="#rfc.section.7">Router Requirements</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Related Work</a>
</li>
<li>11.   <a href="#rfc.section.11">SEAL Advantages over Classical Methods</a>
</li>
<li>12.   <a href="#rfc.section.12">Acknowledgments</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Reliability</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.Appendix%20B">Integrity</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.Appendix%20C">Transport Mode</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.Appendix%20D">Historic Evolution of PMTUD</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">As Internet technology and communication has grown and matured, many techniques have developed that use virtual topologies (including tunnels of one form or another) over an actual network that supports the Internet Protocol (IP) <a href="#RFC0791">[RFC0791]</a><a href="#RFC2460">[RFC2460]</a>. Those virtual topologies have elements that appear as one hop in the virtual topology, but are actually multiple IP or sub-IP layer hops. These multiple hops often have quite diverse properties that are often not even visible to the endpoints of the virtual hop. This introduces failure modes that are not dealt with well in current approaches.</p>
<p id="rfc.section.1.p.2">The use of IP encapsulation (also known as "tunneling") has long been considered as the means for creating such virtual topologies. However, the insertion of an outer IP header reduces the effective path MTU visible to the inner network layer. When IPv4 is used, this reduced MTU can be accommodated through the use of IPv4 fragmentation, but unmitigated in-the-network fragmentation has been found to be harmful through operational experience and studies conducted over the course of many years <a href="#FRAG">[FRAG]</a><a href="#FOLK">[FOLK]</a><a href="#RFC4963">[RFC4963]</a>. Additionally, classical path MTU discovery <a href="#RFC1191">[RFC1191]</a> has known operational issues that are exacerbated by in-the-network tunnels <a href="#RFC2923">[RFC2923]</a><a href="#RFC4459">[RFC4459]</a>. The following subsections present further details on the motivation and approach for addressing these issues.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Motivation</h1>
<p id="rfc.section.1.1.p.1">Before discussing the approach, it is necessary to first understand the problems. In both the Internet and private-use networks today, IPv4 is ubiquitously deployed as the Layer 3 protocol. The two primary functions of IPv4 are to provide for 1) addressing, and 2) a fragmentation and reassembly capability used to accommodate links with diverse MTUs. While it is well known that the IPv4 address space is rapidly becoming depleted, there is a lesser-known but growing consensus that other IPv4 protocol limitations have already or may soon become problematic.</p>
<p id="rfc.section.1.1.p.2">First, the IPv4 header Identification field is only 16 bits in length, meaning that at most 2^16 unique packets with the same (source, destination, protocol)-tuple may be active in the Internet at a given time <a href="#I-D.ietf-intarea-ipv4-id-update">[I-D.ietf-intarea-ipv4-id-update]</a>.  Due to the escalating deployment of high-speed links (e.g., 1Gbps Ethernet), however, this number may soon become too small by several orders of magnitude for high data rate packet sources such as tunnel endpoints <a href="#RFC4963">[RFC4963]</a>. Furthermore, there are many well-known limitations pertaining to IPv4 fragmentation and reassembly &#8211; even to the point that it has been deemed &#8220;harmful&#8221; in both classic and modern-day studies (see above). In particular, IPv4 fragmentation raises issues ranging from minor annoyances (e.g., in-the-network router fragmentation <a href="#RFC1981">[RFC1981]</a>) to the potential for major integrity issues (e.g., mis-association of the fragments of multiple IP packets during reassembly <a href="#RFC4963">[RFC4963]</a>).</p>
<p id="rfc.section.1.1.p.3">As a result of these perceived limitations, a fragmentation-avoiding technique for discovering the MTU of the forward path from a source to a destination node was devised through the deliberations of the Path MTU Discovery Working Group (PMTUDWG) during the late 1980&#8217;s through early 1990&#8217;s (see Appendix D). In this method, the source node provides explicit instructions to routers in the path to discard the packet and return an ICMP error message if an MTU restriction is encountered. However, this approach has several serious shortcomings that lead to an overall &#8220;brittleness&#8221; <a href="#RFC2923">[RFC2923]</a>.</p>
<p id="rfc.section.1.1.p.4">In particular, site border routers in the Internet are being configured more and more to discard ICMP error messages coming from the outside world. This is due in large part to the fact that malicious spoofing of error messages in the Internet is trivial since there is no way to authenticate the source of the messages <a href="#RFC5927">[RFC5927]</a>. Furthermore, when a source node that requires ICMP error message feedback when a packet is dropped due to an MTU restriction does not receive the messages, a path MTU-related black hole occurs. This means that the source will continue to send packets that are too large and never receive an indication from the network that they are being discarded. This behavior has been confirmed through documented studies showing clear evidence of path MTU discovery failures in the Internet today <a href="#TBIT">[TBIT]</a><a href="#WAND">[WAND]</a><a href="#SIGCOMM">[SIGCOMM]</a>.</p>
<p id="rfc.section.1.1.p.5">The issues with both IPv4 fragmentation and this &#8220;classical&#8221; method of path MTU discovery are exacerbated further when IP tunneling is used <a href="#RFC4459">[RFC4459]</a>. For example, ingress tunnel endpoints (ITEs) may be required to forward encapsulated packets into the subnetwork on behalf of hundreds, thousands, or even more original sources in the end site. If the ITE allows IPv4 fragmentation on the encapsulated packets, persistent fragmentation could lead to undetected data corruption due to Identification field wrapping. If the ITE instead uses classical IPv4 path MTU discovery, it may be inconvenienced by excessive ICMP error messages coming from the subnetwork that may be either suspect or contain insufficient information for translation into error messages to be returned to the original sources.</p>
<p id="rfc.section.1.1.p.6">Although recent works have led to the development of a robust end-to-end MTU determination scheme <a href="#RFC4821">[RFC4821]</a>, this approach requires tunnels to present a consistent MTU the same as for ordinary links on the end-to-end path. Moreover, in current practice existing tunneling protocols mask the MTU issues by selecting a "lowest common denominator" MTU that may be much smaller than necessary for most paths and difficult to change at a later date. Due to these many consideration, a new approach to accommodate tunnels over links with diverse MTUs is necessary.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Approach</h1>
<p id="rfc.section.1.2.p.1">For the purpose of this document, a subnetwork is defined as a virtual topology configured over a connected network routing region and bounded by encapsulating border nodes. Example connected network routing regions include Mobile Ad hoc Networks (MANETs), enterprise networks and the global public Internet itself. Subnetwork border nodes forward unicast and multicast packets over the virtual topology across multiple IP and/or sub-IP layer forwarding hops that may introduce packet duplication and/or traverse links with diverse Maximum Transmission Units (MTUs).</p>
<p id="rfc.section.1.2.p.2">This document introduces a Subnetwork Encapsulation and Adaptation Layer (SEAL) for tunneling network layer protocols (e.g., IP, OSI, etc.) over IP subnetworks that connect Ingress and Egress Tunnel Endpoints (ITEs/ETEs) of border nodes. It provides a modular specification designed to be tailored to specific associated tunneling protocols. A transport-mode of operation is also possible, and described in Appendix C. SEAL accommodates links with diverse MTUs, protects against off-path denial-of-service attacks, and can be configured to enable efficient duplicate packet detection through the use of a minimal mid-layer encapsulation.</p>
<p id="rfc.section.1.2.p.3">SEAL specifically treats tunnels that traverse the subnetwork as ordinary links that must support network layer services. As for any link, tunnels that use SEAL must provide suitable networking services including best-effort datagram delivery, integrity and consistent handling of packets of various sizes. As for any link whose media cannot provide suitable services natively, tunnels that use SEAL employ link-level adaptation functions to meet the legitimate expectations of the network layer service. As this is essentially a link level adaptation, SEAL is therefore permitted to alter packets within the subnetwork as long as it restores them to their original form when they exit the subnetwork. The mechanisms described within this document are designed precisely for this purpose.</p>
<p id="rfc.section.1.2.p.4">SEAL encapsulation provides extended identification fields as well as a mid-layer segmentation and reassembly capability that allows simplified cutting and pasting of packets. Moreover, SEAL engages both tunnel endpoints in ensuring a functional path MTU on the path from the ITE to the ETE. This is in contrast to "stateless" approaches which seek to avoid MTU issues by selecting a lowest common denominator MTU value that may be overly conservative for the vast majority of tunnel paths and difficult to change even when larger MTUs become available.</p>
<p id="rfc.section.1.2.p.5">The following sections provide the SEAL normative specifications, while the appendices present non-normative additional considerations.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Terminology and Requirements</h1>
<p id="rfc.section.2.p.1">The following terms are defined within the scope of this document:</p>
<p></p>

<dl>
<dt>subnetwork</dt>
<dd style="margin-left: 8">
<br>a virtual topology configured over a connected network routing region and bounded by encapsulating border nodes.</dd>
<dt>Ingress Tunnel Endpoint</dt>
<dd style="margin-left: 8">
<br>a virtual interface over which an encapsulating border node (host or router) sends encapsulated packets into the subnetwork.</dd>
<dt>Egress Tunnel Endpoint</dt>
<dd style="margin-left: 8">
<br>a virtual interface over which an encapsulating border node (host or router) receives encapsulated packets from the subnetwork.</dd>
<dt>inner packet</dt>
<dd style="margin-left: 8">
<br>an unencapsulated network layer protocol packet (e.g., IPv6 <a href="#RFC2460">[RFC2460]</a>, IPv4 <a href="#RFC0791">[RFC0791]</a>, OSI/CLNP <a href="#RFC1070">[RFC1070]</a>, etc.) before any mid-layer or outer encapsulations are added. Internet protocol numbers that identify inner packets are found in the IANA Internet Protocol registry <a href="#RFC3232">[RFC3232]</a>.</dd>
<dt>mid-layer packet</dt>
<dd style="margin-left: 8">
<br>a packet resulting from adding mid-layer encapsulating headers to an inner packet.</dd>
<dt>outer IP packet</dt>
<dd style="margin-left: 8">
<br>a packet resulting from adding an outer IP header (and possibly other outer headers) to a mid-layer packet.</dd>
<dt>packet-in-error</dt>
<dd style="margin-left: 8">
<br>the leading portion of an invoking data packet encapsulated in the body of an error control message (e.g., an ICMPv4 <a href="#RFC0792">[RFC0792]</a> error message, an ICMPv6 <a href="#RFC4443">[RFC4443]</a> error message, etc.).</dd>
<dt>Packet Too Big (PTB)</dt>
<dd style="margin-left: 8">
<br>a control plane message indicating an MTU restriction, e.g., an ICMPv6 "Packet Too Big" message <a href="#RFC4443">[RFC4443]</a>, an ICMPv4 "Fragmentation Needed" message <a href="#RFC0792">[RFC0792]</a>, an SCMP "Packet Too Big" message (see: Section 4.5), etc.</dd>
<dt>IP, IPvX, IPvY</dt>
<dd style="margin-left: 8">
<br>used to generically refer to either IP protocol version, i.e., IPv4 or IPv6.</dd>
</dl>
<p id="rfc.section.2.p.3">The following abbreviations correspond to terms used within this document and elsewhere in common Internetworking nomenclature:</p>
<p></p>

<ul class="empty">
<li>DF - the IPv4 header "Don't Fragment" flag <a href="#RFC0791">[RFC0791]</a><br>
</li>
<li>ETE - Egress Tunnel Endpoint<br>
</li>
<li>HLEN - the sum of MHLEN and OHLEN<br>
</li>
<li>ITE - Ingress Tunnel Endpoint<br>
</li>
<li>MHLEN - the length of any mid-layer headers and trailers<br>
</li>
<li>MRU - Maximum Reassembly Unit<br>
</li>
<li>MTU - Maximum Transmission Unit<br>
</li>
<li>OHLEN - the length of any outer encapsulating headers and trailers<br>
</li>
<li>S_IFT - SEAL Inner Fragmentation Threshold <br>
</li>
<li>S_MRU - SEAL Maximum Reassembly Unit<br>
</li>
<li>S_MSS - SEAL Maximum Segment Size<br>
</li>
<li>SCMP - the SEAL Control Message Protocol<br>
</li>
<li>SEAL - Subnetwork Encapsulation and Adaptation Layer<br>
</li>
<li>SEAL_PORT - a TCP/UDP service port number used for SEAL<br>
</li>
<li>SEAL_PROTO - an IPv4 protocol number used for SEAL<br>
</li>
<li>TE - Tunnel Endpoint (i.e., either ingress or egress) <br>
</li>
<li>VET - Virtual Enterprise Traversal<br>
</li>
</ul>
<p id="rfc.section.2.p.5">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>. When used in lower case (e.g., must, must not, etc.), these words MUST NOT be interpreted as described in <a href="#RFC2119">[RFC2119]</a>, but are rather interpreted as they would be in common English.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Applicability Statement</h1>
<p id="rfc.section.3.p.1">SEAL was originally motivated by the specific case of subnetwork abstraction for Mobile Ad hoc Networks (MANETs), however it soon became apparent that the domain of applicability also extends to subnetwork abstractions over enterprise networks, ISP networks, SOHO networks, the global public Internet itself, and any other connected network routing region. SEAL along with the Virtual Enterprise Traversal (VET) <a href="#I-D.templin-intarea-vet">[I-D.templin-intarea-vet]</a> tunnel virtual interface abstraction are the functional building blocks for a new Internetworking architecture based on Routing and Addressing in Networks with Global Enterprise Recursion (RANGER) <a href="#RFC5720">[RFC5720]</a><a href="#RFC6139">[RFC6139]</a> and the Internet Routing Overlay Network (IRON) <a href="#RFC6179">[RFC6179]</a>.</p>
<p id="rfc.section.3.p.2">SEAL provides a network sublayer for encapsulation of an inner network layer packet within outer encapsulating headers. For example, for IPvX in IPvY encapsulation (e.g., as IPv4/SEAL/IPv6), the SEAL header appears as a subnetwork encapsulation as seen by the inner IP layer. SEAL can also be used as a sublayer within a UDP data payload (e.g., as IPv4/UDP/SEAL/IPv6 similar to Teredo <a href="#RFC4380">[RFC4380]</a>), where UDP encapsulation is typically used for Network Address Translator (NAT) traversal as well as operation over subnetworks that give preferential treatment to the "core" Internet protocols (i.e., TCP and UDP). The SEAL header is processed the same as for IPv6 extension headers, i.e., it is not part of the outer IP header but rather allows for the creation of an arbitrarily extensible chain of headers in the same way that IPv6 does.</p>
<p id="rfc.section.3.p.3">SEAL supports a segmentation and reassembly capability for adapting the network layer to the underlying subnetwork characteristics, where the Egress Tunnel Endpoint (ETE) determines how much or how little reassembly it is willing to support. In the limiting case, the ETE can avoid reassembly altogether and act as a passive observer that simply informs the Ingress Tunnel Endpoint (ITE) of any MTU limitations and otherwise discards all packets that arrive as multiple fragments. This mode is useful for determining an appropriate MTU for tunneling between performance-critical routers connected to high data rate subnetworks such as the Internet DFZ, for unidirectional tunneling in which the ETE is stateless, and for other uses in which reassembly would present too great of a burden for the routers or end systems.</p>
<p id="rfc.section.3.p.4">When the ETE supports reassembly, the tunnel can be used to transport packets that are too large to traverse the path without fragmentation.  In this mode, the ITE determines the tunnel MTU based on the largest packet the ETE is capable of reassembling rather than on the MTU of the smallest link in the path. Therefore, tunnel endpoints that use SEAL can transport packets that are much larger than the underlying subnetwork links themselves can carry in a single piece.</p>
<p id="rfc.section.3.p.5">SEAL tunnels may be configured over paths that include not only ordinary physical links, but also virtual links that may include other tunnels. An example application would be linking two geographically remote supercomputer centers with large MTU links by configuring a SEAL tunnel across the Internet. A second example would be support for sub-IP segmentation over low-end links, i.e., especially over wireless transmission media such as IEEE 802.15.4, broadcast radio links in Mobile Ad-hoc Networks (MANETs), Very High Frequency (VHF) civil aviation data links, etc.</p>
<p id="rfc.section.3.p.6">Many other use case examples are anticipated, and will be identified as further experience is gained.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> SEAL Specification</h1>
<p id="rfc.section.4.p.1">The following sections specify the operation of SEAL:</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> VET Interface Model</h1>
<p id="rfc.section.4.1.p.1">SEAL is an encapsulation sublayer used within VET non-broadcast, multiple access (NBMA) tunnel virtual interfaces. Each VET interface connects an ITE to one or more ETE "neighbors" via tunneling across an underlying enterprise network, or "subnetwork". The tunnel neighbor relationship between the ITE and each ETE may be either unidirectional or bidirectional.</p>
<p id="rfc.section.4.1.p.2">A unidirectional tunnel neighbor relationship allows the near end TE to send data packets forward to the far end TE, while the far end only returns control messages when necessary. A bidirectional tunnel neighbor relationship is one over which both TEs can exchange both data and control messages.</p>
<p id="rfc.section.4.1.p.3">Implications of the VET unidirectional and bidirectional models for SEAL will be discussed further throughout the remainder of the document.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> SEAL Model of Operation</h1>
<p id="rfc.section.4.2.p.1">SEAL supports a multi-level segmentation and reassembly capability for the transmission of unicast and multicast packets across an underlying IP subnetwork with heterogeneous links. First, the ITE can use IPv4 fragmentation to fragment inner IPv4 packets before SEAL encapsulation if necessary. Secondly, the SEAL layer itself provides a simple cutting-and-pasting capability for mid-layer packets that can be used to avoid IP fragmentation on the outer packet. Finally, ordinary IP fragmentation is permitted on the outer packet after SEAL encapsulation and allows the TEs to detect and tune out any in-the-network fragmentation.</p>
<p id="rfc.section.4.2.p.2">SEAL-enabled ITEs encapsulate each inner packet in any mid-layer headers and trailers, segment the resulting mid-layer packet into multiple segments if necessary, then append a SEAL header and any outer encapsulations to each segment. As an example, for IPv6 within IPv4 encapsulation a single-segment inner IPv6 packet encapsulated in any mid-layer headers and trailers, followed by the SEAL header, followed by any outer headers and trailers, followed by an outer IPv4 header would appear as shown in <a href="#encaps1">Figure 1</a>:</p>
<div id="#rfc.figure.1"></div>
<div id="#encaps1"></div>
<pre>                                    +--------------------+
                                    ~  outer IPv4 header ~
                                    +--------------------+
I                                   ~  other outer hdrs  ~
n                                   +--------------------+
n                                   ~    SEAL Header     ~
e      +--------------------+       +--------------------+
r      ~  mid-layer headers ~       ~  mid-layer headers ~
       +--------------------+       +--------------------+
I --&gt;  |                    |  --&gt;  |                    |
P --&gt;  ~     inner IPv6     ~  --&gt;  ~     inner IPv6     ~
v --&gt;  ~       Packet       ~  --&gt;  ~       Packet       ~
6 --&gt;  |                    |  --&gt;  |                    |
       +--------------------+       +--------------------+
P      ~ mid-layer trailers ~       ~ mid-layer trailers ~
a      +--------------------+       +--------------------+
c                                   ~   outer trailers   ~
k         Mid-layer packet          +--------------------+
e      after mid-layer encaps.
t                                      Outer IPv4 packet
                                  after SEAL and outer encaps.</pre>
<p></p>
<p id="rfc.section.4.2.p.4">As a second example, for IPv4 within IPv6 encapsulation an inner IPv4 packet requiring three SEAL segments would appear as three separate outer IPv6 packets, where the mid-layer headers are carried only in segment 0 and the mid-layer trailers are carried in segment 2 as shown in <a href="#encaps2">Figure 2</a>:</p>
<div id="#rfc.figure.2"></div>
<div id="#encaps2"></div>
<pre>+------------------+   +------------------+   +------------------+
~  outer IPv6 hdr  ~   ~  outer IPv6 hdr  ~   ~  outer IPv6 hdr  ~
+------------------+   +------------------+   +------------------+
~ other outer hdrs ~   ~ other outer hdrs ~   ~ other outer hdrs ~
+------------------+   +------------------+   +------------------+
~ SEAL hdr (SEG=0) ~   ~ SEAL hdr (SEG=1) ~   ~ SEAL hdr (SEG=2) ~
+------------------+   +------------------+   +------------------+
|  mid-layer hdrs  |   |    inner IPv4    |   | inner IPv4 Packet|
~ plus inner IPv4  ~   ~  Packet Segment  ~   ~   Segment plus   ~
~  Packet Segment  ~   ~   (Length = L)   ~   ~ mid-layer trails ~
|   (Length = L)   |   |                  |   | (Len may be !=L) |
+------------------+   +------------------+   +------------------+
~  outer trailers  ~   ~  outer trailers  ~   ~  outer trailers  ~
+------------------+   +------------------+   +------------------+
Segment 0 (includes     Segment 1 (no mid-    Segment 2 (includes
  mid-layer hdrs)         layer encaps)         mid-layer trails)</pre>
<p></p>
<p id="rfc.section.4.2.p.6">The ITE inserts the SEAL header according to the specific tunneling protocol. Examples include the following:</p>

<ul>
<li>For simple encapsulation of an inner network layer packet within an outer IPvX header (e.g., <a href="#RFC1070">[RFC1070]</a><a href="#RFC2003">[RFC2003]</a><a href="#RFC2473">[RFC2473]</a><a href="#RFC4213">[RFC4213]</a>, etc.), the ITE inserts the SEAL header between the inner packet and outer IPvX headers as: IPvX/SEAL/{inner packet}.</li>
<li>For encapsulations over transports such as UDP (e.g., <a href="#RFC4380">[RFC4380]</a>), the ITE inserts the SEAL header between the outer transport layer header and the mid-layer packet, e.g., as IPvX/UDP/SEAL/{mid-layer packet}. Here, the UDP header is seen as an "other outer header".</li>
</ul>

<p>The SEAL header includes per-neighbor, per-link and per-packet identification values which routers within the subnetwork can use for duplicate packet detection and both TEs can use for SEAL segmentation/reassembly.</p>
<p id="rfc.section.4.2.p.7">The following sections specify the SEAL header format and SEAL-related operations of the ITE and ETE.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> SEAL Header Format</h1>
<p id="rfc.section.4.3.p.1">The SEAL header is formatted as follows:</p>
<div id="#rfc.figure.3"></div>
<div id="#minimal"></div>
<pre>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |VER|C|A|I|F|M|R|  NEXTHDR/SEG  |            LINK_ID            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             NBR_ID                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   PKT_ID (when necessary)                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p></p>
<p id="rfc.section.4.3.p.3">where the header fields are defined as:</p>
<p></p>

<dl>
<dt>VER (2)</dt>
<dd style="margin-left: 8">
<br>a 2-bit version field. This document specifies Version 0 of the SEAL protocol, i.e., the VER field encodes the value 0.</dd>
<dt>C (1)</dt>
<dd style="margin-left: 8">
<br>the "Control/Data" bit. Set to 1 by the ITE in SEAL Control Message Protocol (SCMP) control messages, and set to 0 in ordinary data packets.</dd>
<dt>A (1)</dt>
<dd style="margin-left: 8">
<br>the "Acknowledgement Requested" bit.  Set to 1 by the ITE in data packets for which it wishes to receive an explicit acknowledgement from the ETE.</dd>
<dt>I (1)</dt>
<dd style="margin-left: 8">
<br>the "Identification Field Included" bit. Set to 1 if the SEAL header includes a 32-bit packet Identification field (see below); set to 0 otherwise.</dd>
<dt>F (1)</dt>
<dd style="margin-left: 8">
<br>the "First Segment" bit. Set to 1 if this SEAL protocol packet contains the first segment (i.e., Segment #0) of a mid-layer packet.</dd>
<dt>M (1)</dt>
<dd style="margin-left: 8">
<br>the "More Segments" bit. Set to 1 if this SEAL protocol packet contains a non-final segment of a multi-segment mid-layer packet.</dd>
<dt>R (1)</dt>
<dd style="margin-left: 8">
<br>the "Reserved" bit. Set to 0 by the ITE and ignored by the ETE. Future specifications may define different behaviors.</dd>
<dt>NEXTHDR/SEG (8)</dt>
<dd style="margin-left: 8">an 8-bit field. When 'F'=1, encodes the next header Internet Protocol number the same as for the IPv4 protocol and IPv6 next header fields. When 'F'=0, encodes a segment number of a multi-segment mid-layer packet. (The segment number 0 is reserved.)</dd>
<dt>LINK_ID (16)</dt>
<dd style="margin-left: 8">
<br>a 16-bit link identification value, set to a unique value for each underlying link over which the ITE will send encapsulated packets to the ETE. Used as a neighbor selector adjunct for the NBR_ID.</dd>
<dt>NBR_ID (32)</dt>
<dd style="margin-left: 8">
<br>a 32-bit neighbor identification value. Set to a random value by the ETE in an initial exchange with the ITE, and used as a neighbor selector in conjunction with the LINK_ID.</dd>
<dt>PKT_ID (32)</dt>
<dd style="margin-left: 8">
<br>a 32-bit per-packet identification field. Present only when the I bit is set to 1 (see above).</dd>
</dl>

<p>Setting of the various bits and fields of the SEAL header is specified in the following sections.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> ITE Specification</h1>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> Tunnel Interface MTU</h1>
<p id="rfc.section.4.4.1.p.1">The tunnel interface must present a constant MTU value to the inner network layer as the size for admission of inner packets into the interface. Since VET NBMA tunnel virtual interfaces may support a large set of ETEs that accept widely varying maximum packet sizes, however, a number of factors should be taken into consideration when selecting a tunnel interface MTU.</p>
<p id="rfc.section.4.4.1.p.2">Due to the ubiquitous deployment of standard Ethernet and similar networking gear, the nominal Internet cell size has become 1500 bytes; this is the de facto size that end systems have come to expect will either be delivered by the network without loss due to an MTU restriction on the path or a suitable ICMP Packet Too Big (PTB) message returned. When large packets sent by end systems incur additional encapsulation at an ITE, however, they may be dropped silently within the tunnel since the network may not always deliver the necessary PTBs <a href="#RFC2923">[RFC2923]</a>.</p>
<p id="rfc.section.4.4.1.p.3">The ITE should therefore set a tunnel interface MTU of at least 1500 bytes plus extra room to accommodate any additional encapsulations that may occur on the path from the original source.  The ITE can also set smaller MTU values; however, care must be taken not to set so small a value that original sources would experience an MTU underflow. In particular, IPv6 sources must see a minimum path MTU of 1280 bytes, and IPv4 sources should see a minimum path MTU of 576 bytes.</p>
<p id="rfc.section.4.4.1.p.4">The ITE can alternatively set an indefinite MTU on the tunnel interface such that all inner packets are admitted into the interface without regard to size. For ITEs that host applications that use the tunnel interface directly, this option must be carefully coordinated with protocol stack upper layers since some upper layer protocols (e.g., TCP) derive their packet sizing parameters from the MTU of the outgoing interface and as such may select too large an initial size. This is not a problem for upper layers that use conservative initial maximum segment size estimates and/or when the tunnel interface can reduce the upper layer's maximum segment size, e.g., by reducing the size advertised in the MSS option of outgoing TCP messages.</p>
<p id="rfc.section.4.4.1.p.5">The inner network layer protocol consults the tunnel interface MTU when admitting a packet into the interface. For non-SEAL inner IPv4 packets with the IPv4 Don't Fragment (DF) bit set to 0, if the packet is larger than the tunnel interface MTU the inner IPv4 layer uses IPv4 fragmentation to break the packet into fragments no larger than the tunnel interface MTU. The ITE then admits each fragment into the interface as an independent packet.</p>
<p id="rfc.section.4.4.1.p.6">For all other inner packets, the inner network layer admits the packet if it is no larger than the tunnel interface MTU; otherwise, it drops the packet and sends a PTB error message to the source with the MTU value set to the tunnel interface MTU. The message must contain as much of the invoking packet as possible without the entire message exceeding the network layer minimum MTU (e.g., 576 bytes for IPv4, 1280 bytes for IPv6, etc.). For SEAL packets that would undergo recursive encapsulation, however, the inner layer must send a SEAL PTB message instead of a PTB of the inner network layer (see: Section 4.4.3).</p>
<p id="rfc.section.4.4.1.p.7">In light of the above considerations, the ITE SHOULD configure an indefinite MTU on tunnel *router* interfaces, since these may be required to carry recursively-nested SEAL encapsulations. The ITE MAY instead set a finite MTU on tunnel *host* interfaces. Any necessary tunnel adaptations are then performed by the SEAL layer within the tunnel interface as described in the following sections.</p>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> Tunnel Interface Soft State</h1>
<p id="rfc.section.4.4.2.p.1">The ITE maintains per-ETE soft state within the tunnel interface, e.g., in a neighbor cache. The soft state includes the following:</p>
<p><a href="#RFC2675">[RFC2675]</a>) can be accommodated when appropriate for a given subnetwork.</p>

<ul>
<li>a Mid-layer Header Length (MHLEN); set to the length of any mid-layer encapsulation headers and trailers that must be added before SEAL segmentation.</li>
<li>an Outer Header Length (OHLEN); set to the length of the outer IP, SEAL and other outer encapsulation headers and trailers.</li>
<li>a total Header Length (HLEN); set to MHLEN plus OHLEN.</li>
<li>a SEAL Maximum Segment Size (S_MSS). The ITE initializes S_MSS to the minimum MTU of the underlying interfaces if the underlying interface MTUs can be determined (otherwise, the ITE initializes S_MSS to "infinity"). The ITE decreases or increases S_MSS based on any SCMP "Packet Too Big (PTB)" messages received (see Section 4.6).</li>
<li>a SEAL Maximum Reassembly Unit (S_MRU). If the ITE is not configured to use SEAL segmentation, it initializes S_MRU to the constant value 0 and ignores any S_MRU values reported by the ETE. Otherwise, the ITE initializes S_MRU to "infinity" (i.e., the largest possible inner packet size) and decreases or increases S_MRU based on any SCMP PTB messages received from the ETE (see Section 4.6). When (S_MRU&gt;(S_MSS*256)), the ITE uses (S_MSS*256) as the effective S_MRU value.</li>
<li>a SEAL Inner Fragmentation Threshold (S_IFT); used to determine a maximum fragment size for fragmentable IPv4 packets.  Required only for tunnels that support encapsulation with IPv4 as the inner network layer protocol. The ITE should use a "safe" estimate for S_IFT that would be highly unlikely to trigger additional fragmentation on the path to the ETE. This estimate SHOULD be selected such that S_IFT &lt;= MAX(S_MSS, MS_MRU); more specifically, it is RECOMMENDED that the ITE set S_IFT to 512 unless it can determine a more accurate safe value (e.g., via probing).</li>
<li>a NBR_ID value that is coordinated with the ETE and used to fill the SEAL header field of the same name for packets sent to this ETE.</li>
<li>one or more LINK_ID values that are coordinated with the ETE and used to fill the SEAL header field of the same name for packets sent to this ETE.</li>
<li>a PKT_ID value that is randomly-initialized and monotonically-incremented for each packet sent to this ETE.</li>
<li>an outer IP address (and UDP port number when UDP encapsulation is used) for use as the destination addresses for each packet sent to this ETE.</li>
</ul>

<p>Note that S_MSS and S_MRU include the length of the outer and mid-layer encapsulating headers and trailers (i.e., HLEN), since the ETE must retain the headers and trailers during reassembly. Note also that the ITE maintains S_MSS and S_MRU as 32-bit values such that inner packets larger than 64KB (e.g., IPv6 jumbograms </p>
<h1 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> Submitting Packets for Encapsulation</h1>
<p id="rfc.section.4.4.3.p.1">Once an inner packet/fragment has been admitted into the tunnel interface, it transitions from the inner network layer and becomes subject to SEAL layer processing. The ITE then examines each packet to determine whether it is too large for SEAL encapsulation, then submits the packet for encapsulation according to whether it is "fragmentable" (discussed in the next paragraph) or "unfragmentable" (discussed in the following paragraph).</p>
<p id="rfc.section.4.4.3.p.2">For IPv4 packets with DF=0 in the IPv4 header, if the packet is no larger than S_IFT the ITE submits the packet for encapsulation.  Otherwise, the ITE uses inner IPv4 fragmentation to break the packet into IPv4 fragments no larger than S_IFT bytes. For non-SEAL IPv4 packets, the ITE then submits each fragment for encapsulation separately. For SEAL IPv4 packets, the ITE instead uses the first fragment to prepare an SCMP PTB message with Code=0 to return to the source (see: Section 4.6.1.1) then discards each fragment.</p>
<p id="rfc.section.4.4.3.p.3">For all other packets, if the packet is larger than (MAX(S_MRU, S_MSS) - HLEN), the ITE discards it and sends a PTB message to the source with an MTU value of (MAX(S_MRU, S_MSS) - HLEN); otherwise, the ITE submits the packet for encapsulation. The ITE must include the length of the uncompressed headers and trailers when calculating HLEN even if the tunnel is using header compression. The ITE is also permitted to submit inner packets for encapsulation if they can be accommodated in a single SEAL segment (i.e., no larger than S_MSS) even if they are larger than the ETE would be willing to reassemble if fragmented (i.e., larger than S_MRU) - see: Section 4.5.1.</p>
<h1 id="rfc.section.4.4.4">
<a href="#rfc.section.4.4.4">4.4.4.</a> Mid-Layer Encapsulation</h1>
<p id="rfc.section.4.4.4.p.1">After inner IP fragmentation (if necessary), the ITE next encapsulates each inner packet/fragment in the MHLEN bytes of any mid-layer headers and trailers. The ITE then submits the mid-layer packet for SEAL segmentation and encapsulation.</p>
<h1 id="rfc.section.4.4.5">
<a href="#rfc.section.4.4.5">4.4.5.</a> SEAL Segmentation</h1>
<p id="rfc.section.4.4.5.p.1">If the ITE is configured to use SEAL segmentation, it checks the length of the resulting packet after mid-layer encapsulation to determine whether segmentation is needed. If the length of the resulting mid-layer packet plus OHLEN is larger than S_MSS but no larger than S_MRU the ITE performs SEAL segmentation by breaking the mid-layer packet into N segments (N &lt;= 256) that are no larger than (S_MSS - OHLEN) bytes each.</p>
<p id="rfc.section.4.4.5.p.2">When the ITE performs SEAL segmentation, it MUST segment the mid-layer packet such that the first segment includes at least the mid-layer headers. (When the inner packet header is available in-the-clear, the first segment MUST also include the inner header.) Each segment except the final one MUST be of equal length, and the first byte of each segment MUST begin immediately after the final byte of the previous segment, i.e., the segments MUST NOT overlap.  The ITE SHOULD generate the smallest number of segments possible, e.g., it SHOULD NOT generate 6 smaller segments when the packet could be accommodated with 4 larger segments.</p>
<p id="rfc.section.4.4.5.p.3">This SEAL segmentation process ignores the fact that the mid-layer packet may be unfragmentable outside of the subnetwork.  The process is a mid-layer (not an IP layer) operation employed by the ITE to adapt the mid-layer packet to the subnetwork path characteristics, and the ETE will restore the packet to its original form during reassembly. Therefore, the fact that the packet may have been segmented within the subnetwork is not observable outside of the subnetwork.</p>
<h1 id="rfc.section.4.4.6">
<a href="#rfc.section.4.4.6">4.4.6.</a> SEAL Encapsulation</h1>
<p id="rfc.section.4.4.6.p.1">Following SEAL segmentation, the ITE next encapsulates each segment in a SEAL header formatted as specified in Section 4.3.</p>
<p id="rfc.section.4.4.6.p.2">For the first segment, the ITE then sets F=1, and sets M=1 if there are more segments or sets M=0 otherwise. The ITE then sets NEXTHDR to the Internet Protocol number corresponding to the encapsulated inner packet. For example, the ITE sets NEXTHDR to the value '4' for encapsulated IPv4 packets <a href="#RFC2003">[RFC2003]</a>, the value '41' for encapsulated IPv6 packets <a href="#RFC2473">[RFC2473]</a><a href="#RFC4213">[RFC4213]</a>, the value '50' for encapsulated IPsec/ESP payloads <a href="#RFC4301">[RFC4301]</a><a href="#RFC4303">[RFC4303]</a>, the value '80' for encapsulated OSI packets <a href="#RFC1070">[RFC1070]</a>, etc.</p>
<p id="rfc.section.4.4.6.p.3">For each non-initial segment of an N-segment mid-layer packet (N &lt;= 256), the ITE instead sets (F=0; M=1; SEG=1) in the SEAL header of the first non-initial segment, sets (F=0; M=1; SEG=2) in the next non-initial segment, etc., and sets (F=0; M=0; SEG=N-1) in the final segment. (Note that the value SEG=0 is not used, since the initial segment encodes a NEXTHDR value and not a SEG value.)</p>
<p id="rfc.section.4.4.6.p.4">For each segment (i.e., both initial and non-initial), the ITE then sets C=0 and R=0. For initial segments, the ITE also sets A=1 if an explicit acknowledgement is required (see Section 4.4.9). The ITE then sets the NBR_ID and LINK_ID fields in order to identify itself to the ETE.</p>
<p id="rfc.section.4.4.6.p.5">Finally, for each SEAL segment of a multi-segment SEAL packet, the ITE sets I=1 and includes the current PKT_ID value in a trailing 32-bit Identification field in the SEAL header of each segment. For each SEAL packet that will be sent as a single segment, however, the ITE MAY set I=0 and omit the trailing PKT_ID field. Whether or not the PKT_ID field was included, the ITE then monotonically increments the PKT_ID value (modulo 2^32) for the next SEAL packet to be sent to the ETE. (This allows the ETE to determine whether a large number of SEAL packets have been received since an incomplete reassembly was initiated.)</p>
<h1 id="rfc.section.4.4.7">
<a href="#rfc.section.4.4.7">4.4.7.</a> Outer Encapsulation</h1>
<p id="rfc.section.4.4.7.p.1">Following SEAL encapsulation, the ITE next encapsulates each SEAL segment in the requisite outer headers and trailers according to the specific encapsulation format (e.g., <a href="#RFC1070">[RFC1070]</a>, <a href="#RFC2003">[RFC2003]</a>, <a href="#RFC2473">[RFC2473]</a>, <a href="#RFC4213">[RFC4213]</a>, etc.), except that it writes 'SEAL_PROTO' in the protocol field of the outer IP header (when simple IP encapsulation is used) or writes 'SEAL_PORT' in the outer destination service port field (e.g., when IP/UDP encapsulation is used). The ITE then writes the outer IP address for this ETE in the destination address of the outer IP header.</p>
<p id="rfc.section.4.4.7.p.2">When IPv4 is used as the outer encapsulation layer, the ITE finally sets the DF flag in the IPv4 header of each segment. If the path to the ETE correctly implements IP fragmentation (see: Section 4.4.9), the ITE sets DF=0; otherwise, it sets DF=1.</p>
<p id="rfc.section.4.4.7.p.3">When IPv6 is used as the outer encapsulation layer, the "DF" flag is absent but implicitly set to 1. The packet therefore will not be fragmented within the subnetwork, since IPv6 deprecates in-the-network fragmentation.</p>
<h1 id="rfc.section.4.4.8">
<a href="#rfc.section.4.4.8">4.4.8.</a> Sending SEAL Protocol Packets</h1>
<p id="rfc.section.4.4.8.p.1">Following outer encapsulation, the ITE sends each outer packet that encapsulates a segment of the same mid-layer packet over the same underlying link in canonical order, i.e., segment 0 first, followed by segment 1, etc., and finally segment N-1.</p>
<h1 id="rfc.section.4.4.9">
<a href="#rfc.section.4.4.9">4.4.9.</a> Probing Strategy</h1>
<p id="rfc.section.4.4.9.p.1">When IPv4 is used as the outer encapsulation layer, the ITE can perform a qualification exchange over each underlying link to determine whether each subnetwork path to the ETE correctly implements IPv4 fragmentation. This procedure could be employed, e.g., to determine whether there are any middleboxes on the path that violate the <a href="#RFC1812">[RFC1812]</a>, Section 5.2.6 requirement that: "A router MUST NOT reassemble any datagram before forwarding it".</p>
<p id="rfc.section.4.4.9.p.2">To perform this qualification, the ITE prepares a probe packet that is no larger than 576 bytes (e.g., a NULL packet with A=1 and NEXTHDR="No Next Header" <a href="#RFC2460">[RFC2460]</a> in the SEAL header), then splits the packet into two outer IPv4 fragments and sends both fragments to the ETE over the same underlying link. If the ETE returns an SCMP PTB message with Code=0 (see Section 4.6.1.1), then the subnetwork path correctly implements IPv4 fragmentation. If the ETE returns an SCMP PTB message with Code=2, however, then a middlebox in the subnetwork is reassembling the IPv4 fragments before they are delivered to the ETE (i.e., in violation of <a href="#RFC1812">[RFC1812]</a>).</p>
<p id="rfc.section.4.4.9.p.3">In addition to any control plane probing, all SEAL encapsulated data packets sent by the ITE are considered implicit probes. SEAL encapsulated packets that use IPv4 as the outer layer of encapsulation with DF=0 will elicit SCMP PTB messages from the ETE if any IPv4 fragmentation occurs in the path. SEAL encapsulated packets that use either IPv6 or IPv4 with DF=1 as the outer layer of encapsulation may be dropped by a router on the path to the ETE which will also return an ICMP PTB message to the ITE. If the message includes enough information (see Section 4.4.10), the ITE can then use the (NBR_ID, LINK_ID, PKT_ID)-tuple along with the destination addresses within the packet-in-error to determine whether the PTB message corresponds to one of its recent packet transmissions.</p>
<p id="rfc.section.4.4.9.p.4">The ITE should also send explicit probes, periodically, to verify that the ETE is still reachable. The ITE sets A=1 in the SEAL header of the first segment of a SEAL packet to be used as an explicit probe, where the probe can be either an ordinary data packet segment or a NULL packet (see above). The probe will elicit an SCMP PTB message with Code=2 from the ETE as an acknowledgement (see Section 4.6.1.1).</p>
<h1 id="rfc.section.4.4.10">
<a href="#rfc.section.4.4.10">4.4.10.</a> Processing ICMP Messages</h1>
<p id="rfc.section.4.4.10.p.1">When the ITE sends outer IP packets, it may receive ICMP error messages <a href="#RFC0792">[RFC0792]</a><a href="#RFC4443">[RFC4443]</a> from either the ETE or routers within the subnetwork. The ICMP messages include an outer IP header, followed by an ICMP header, followed by a portion of the outer IP packet that generated the error (also known as the "packet-in-error"). The ITE can use the (NBR_ID, LINK_ID, PKT_ID)-tuple along with the source and destination addresses within the packet-in-error to confirm that the ICMP message came from either the ETE or an on-path router, and can use any additional information to determine whether to accept or discard the message.</p>
<p id="rfc.section.4.4.10.p.2">The ITE should specifically process raw ICMPv4 Protocol Unreachable messages and ICMPv6 Parameter Problem messages with Code "Unrecognized Next Header type encountered" as a hint that the ETE does not implement the SEAL protocol. The ITE can also process other raw ICMPv4 messages as a hint that the path to the ETE may be failing. Specific actions that the ITE may take in these cases are out of scope.</p>
<h1 id="rfc.section.4.4.11">
<a href="#rfc.section.4.4.11">4.4.11.</a> Black Hole Detection</h1>
<p id="rfc.section.4.4.11.p.1">In some subnetwork paths, ICMP error messages may be lost due to filtering or may not contain enough information due to a router in the path not observing the recommendations of <a href="#RFC1812">[RFC1812]</a>. The ITE can use explicit probing as described in Section 4.4.9 to determine whether the path to the ETE is silently dropping packets (also known as a "black hole"). For example, when the ITE is obliged to set DF=1 in the outer headers of data packets it should send explicit probe packets, periodically, in order to detect path MTU increases or decreases.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> ETE Specification</h1>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> Reassembly Buffer Requirements</h1>
<p id="rfc.section.4.5.1.p.1">The ETE SHOULD support the minimum IP-layer reassembly requirements specified for IPv4 (i.e., 576 bytes <a href="#RFC1812">[RFC1812]</a>) and IPv6 (i.e., 1500 bytes <a href="#RFC2460">[RFC2460]</a>). The ETE SHOULD also support SEAL-layer reassembly for inner packets of at least 1280 bytes in length and MAY support reassembly for larger inner packets. The ETE records the SEAL-layer reassembly buffer size in a soft-state variable "S_MRU" (see: Section 4.5.2).</p>
<p id="rfc.section.4.5.1.p.2">The ETE may instead omit the reassembly function altogether and set S_MRU=0, but this may cause ITEs to experience tunnel MTU underruns in some environments resulting in an unusable link. When reassembly is supported, the ETE must retain the outer IP, SEAL and other outer headers and trailers during both IP-layer and SEAL-layer reassembly for the purpose of associating the fragments/segments of the same packet, and must also configure a SEAL-layer reassembly buffer that is no smaller than the IP-layer reassembly buffer.  Hence, the ETE:</p>
<p></p>

<ul>
<li>SHOULD configure an outer IP-layer reassembly buffer of at least the minimum specified for the outer IP protocol version.</li>
<li>SHOULD configure a SEAL-layer reassembly buffer S_MRU size of at least (1280 + HELN) bytes, and</li>
<li>MUST be capable of discarding inner packets that require IP-layer and/or SEAL-layer reassembly and that are larger than (S_MRU - HLEN).</li>
</ul>
<p id="rfc.section.4.5.1.p.4">The ETE is permitted to accept inner packets that did not undergo IP-layer and/or SEAL-layer reassembly even if they are larger than (S_MRU - HELN) bytes. Hence, S_MRU is a maximum *reassembly* size, and may be less than the largest packet size the ETE is able to receive when no reassembly is required.</p>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> Tunnel Interface Soft State</h1>
<p id="rfc.section.4.5.2.p.1">The ETE maintains a per-interface default S_MRU value to be applied for all ITEs, and can optionally maintain individual per-ITE S_MRU values that override the default.</p>
<p id="rfc.section.4.5.2.p.2">The ETE also maintains per-ITE soft state to associate (NBR_ID, LINK_ID, PKT_ID)-tuples with the inner and/or mid-layer source addresses used by ITEs.</p>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> IP-Layer Reassembly</h1>
<p id="rfc.section.4.5.3.p.1">The ETE submits unfragmented SEAL protocol IP packets for SEAL-layer reassembly as specified in Section 4.5.4. The ETE instead performs standard IP-layer reassembly for multi-fragment SEAL protocol IP packets as follows.</p>
<p id="rfc.section.4.5.3.p.2">The ETE should maintain conservative IP-layer reassembly cache high- and low-water marks. When the size of the reassembly cache exceeds this high-water mark, the ETE should actively discard incomplete reassemblies (e.g., using an Active Queue Management (AQM) strategy) until the size falls below the low-water mark. The ETE should also actively discard any pending reassemblies that clearly have no opportunity for completion, e.g., when a considerable number of new fragments have arrived before a fragment that completes a pending reassembly arrives. Following successful IP-layer reassembly, the ETE submits the reassembled packet for SEAL-layer reassembly as specified in Section 4.5.4.</p>
<p id="rfc.section.4.5.3.p.3">When the ETE processes the IP first fragment (i.e., one with MF=1 and Offset=0 in the IP header) of a fragmented SEAL packet for which the (NBR_ID, LINK_ID, PKT_ID)-tuple belongs to a neighboring ITE, it sends an SCMP PTB message with Code=0 back to the ITE (see Section 4.6.1.1). When the ETE processes an IP fragment that would cause the reassembled outer packet to be larger than the IP-layer reassembly buffer following reassembly, it discontinues the reassembly and discards any further fragments of the same packet.</p>
<h1 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> SEAL-Layer Reassembly</h1>
<p id="rfc.section.4.5.4.p.1">Following IP reassembly (if necessary), the ETE examines each SEAL data packet (i.e., those with C=0 in the SEAL header) packet) to determine whether an SCMP error message is required. If the packet has an incorrect value in the SEAL header the ETE discards the packet and returns an SCMP "Parameter Problem" message (see Section 4.6.1.4). Next, if the SEAL header has (A=1; F=1) and the packet did not arrive as multiple outer IP fragments, the ETE sends an SCMP PTB message with Code=2 back to the ITE (see Section 4.6.1.1). The ETE next submits single-segment mid-layer packets for decapsulation and delivery to upper layers (see Section 4.5.5). The ETE instead performs SEAL-layer reassembly for multi-segment mid-layer packets with I=1 in the SEAL header as follows.</p>
<p id="rfc.section.4.5.4.p.2">The ETE adds each segment of a multi-segment mid-layer packet with I=1 in the SEAL header to a SEAL-layer pending-reassembly queue according to the (NBR_ID, LINK_ID, PKT_ID)-tuple found in the SEAL header. The ETE performs SEAL-layer reassembly through simple in-order concatenation of the encapsulated segments of the same mid-layer packet from N consecutive SEAL segments. SEAL-layer reassembly requires the ETE to maintain a cache of recently received segments for a hold time that would allow for nominal inter-segment delays. When a SEAL reassembly times out, the ETE discards the incomplete reassembly and returns an SCMP "Time Exceeded" message to the ITE (see Section 4.6.1.4). As for IP-layer reassembly, the ETE should also maintain a conservative reassembly cache high- and low-water mark and should actively discard any pending reassemblies that clearly have no opportunity for completion, e.g., when a considerable number of new SEAL packets have been received before a packet that completes a pending reassembly has arrived.</p>
<p id="rfc.section.4.5.4.p.3">If the ETE receives a SEAL packet for which a segment with the same (NBR_ID, LINK_ID, PKT_ID)-tuple is already in the queue, it must determine whether to accept the new segment and release the old, or drop the new segment. If accepting the new segment would cause an inconsistency with other segments already in the queue (e.g., differing segment lengths), the ETE drops the segment that is least likely to complete the reassembly. When the ETE has already received the SEAL first segment (i.e., one with F=1 and M=1 in the SEAL header) of a SEAL protocol packet that arrived as multiple SEAL segments, and accepting the current segment would cause the size of the reassembled packet to exceed S_MRU, the ETE schedules the reassembly resources for garbage collection and sends an SCMP PTB message with Code=1 back to the ITE (see Section 4.6.1.1).</p>
<p id="rfc.section.4.5.4.p.4">After all segments are gathered, the ETE reassembles the packet by concatenating the segments encapsulated in the N consecutive SEAL packets beginning with the initial segment (i.e., SEG=0) and followed by any non-initial segments 1 through N-1. That is, for an N-segment mid-layer packet, reassembly entails the concatenation of the SEAL-encapsulated packet segments with the same value in the Identification field and with (F=1, M=1) in the first SEAL header, followed by (F=0, M=1, SEG=1) in the next SEAL header, followed by (F=0, M=1, SEG=2), etc., up to (F=0, M=0, SEG=(N-1)) in the final SEAL header. Following successful SEAL-layer reassembly, the ETE submits the reassembled mid-layer packet for decapsulation and delivery to upper layers as specified in Section 4.5.5.</p>
<p id="rfc.section.4.5.4.p.5">The ETE must not perform SEAL-layer reassembly for multi-segment mid-layer packets with I=0 in the SEAL header. The ETE instead silently drops all segments with (I=0 &amp;&amp; (F=0 || M=1)) in the SEAL header and sends an SCMP Parameter Problem message back to the ITE.</p>
<h1 id="rfc.section.4.5.5">
<a href="#rfc.section.4.5.5">4.5.5.</a> Decapsulation and Delivery to Upper Layers</h1>
<p id="rfc.section.4.5.5.p.1">Following any necessary IP- and SEAL-layer reassembly, the ETE performs ingress filtering on the mid-layer and/or inner source addresses (e.g., via a Reverse-Path Forwarding (RPF) lookup) to determine whether they are correct for the (NBR_ID, LINK_ID)-tuple encoded in the SEAL header. (When the outer source address and/or port number for the ITE is known, they are also included in the ingress filtering check.) If the source addresses are incorrect, the ETE silently drops the packet.</p>
<p id="rfc.section.4.5.5.p.2">Otherwise, the ETE performs any mid-layer transformations on the mid-layer packet and delivers the inner packet to the upper-layer protocol identified either in the SEAL NEXTHDR field or the next header field of the mid-layer packet (i.e., if the packet included mid-layer encapsulations). The ETE instead silently discards the inner packet if it was a NULL packet (see Section 4.4.9).</p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> The SEAL Control Message Protocol (SCMP)</h1>
<p id="rfc.section.4.6.p.1">SEAL uses a companion SEAL Control Message Protocol (SCMP) based on the same message format as the Internet Control Message Protocol for IPv6 (ICMPv6) <a href="#RFC4443">[RFC4443]</a>. Each SCMP message is embedded within an SCMP packet which begins with the same outer header format as would be used for outer encapsulation of a SEAL data packet (see: Section 4.4.7). The following sections specify the generation and processing of SCMP messages:</p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> Generating SCMP Messages</h1>
<p id="rfc.section.4.6.1.p.1">SCMP messages use the same message Type and Code values specified for ordinary ICMPv6 messages in <a href="#RFC4443">[RFC4443]</a>. SCMP is also used to carry Redirect messages <a href="#RFC4861">[RFC4861]</a> that include Route Information Options (RIOs) <a href="#RFC4191">[RFC4191]</a> for the purpose of dynamic route optimization. The general format for SCMP messages is shown in <a href="#control">Figure 4</a>:</p>
<div id="#rfc.figure.4"></div>
<div id="#control"></div>
<pre>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |          Checksum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                         Message Body                          ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  As much of invoking SEAL data                |
   ~                packet as possible without the SCMP            ~
   |                  packet exceeding 576 bytes (*)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   (*) also known as the "packet-in-error"</pre>
<p></p>
<p id="rfc.section.4.6.1.p.3">TEs generate SCMP error messages and SCMP Redirect messages in response to certain SEAL data packets. As for ICMP, TEs must not generate SCMP error messages in response to other SCMP messages.</p>
<p id="rfc.section.4.6.1.p.4">As for ordinary ICMPv6 messages, the SCMP message begins with a 4 byte header that includes 8-bit Type and Code fields followed by a 16-bit Checksum field followed by a variable-length Message Body.  The TE sets the Type and Code fields to the same values that would appear in the corresponding ICMPv6 message and also formats the Message Body the same as for the corresponding ICMPv6 message.</p>
<p id="rfc.section.4.6.1.p.5">For SCMP error messages, the Message Body is followed by the leading portion of the invoking SEAL data packet as the "packet-in-error". For SCMP Redirect messages, the packet-in-error is instead included in a Redirected Header Option (RHO), which may or may not be the final option in the message. The packet-in-error includes as much of the leading portion of the invoking SEAL data packet as possible beginning with the outer IP header and extending to a length that would not cause the entire SCMP packet following outer encapsulation to exceed 576 bytes (see: <a href="#scmpencaps">Figure 5</a>).</p>
<p id="rfc.section.4.6.1.p.6">The TE calculates the SCMP message Checksum the same as specified for ICMPv6 messages except that it does not prepend a pseudo-header of the outer IP header, i.e., the Checksum calculation procedure is identical to that used for ICMPv4 <a href="#RFC0792">[RFC0792]</a>.  The TE then encapsulates the SCMP message in the outer headers as shown in <a href="#scmpencaps">Figure 5</a>:</p>
<div id="#rfc.figure.5"></div>
<div id="#scmpencaps"></div>
<pre>                                    +--------------------+
                                    ~  outer IPv4 header ~
                                    +--------------------+
                                    ~  other outer hdrs  ~
                                    +--------------------+
                                    ~    SEAL Header     ~
       +--------------------+       +--------------------+
       ~ SCMP message header~  --&gt;  ~ SCMP message header~
       +--------------------+  --&gt;  +--------------------+
       ~  SCMP message body ~  --&gt;  ~  SCMP message body ~
       +--------------------+  --&gt;  +--------------------+
       ~   packet-in-error  ~  --&gt;  ~  packet-in-error   ~
       +--------------------+       +--------------------+
                                    ~   outer trailers   ~
            SCMP Message            +--------------------+
        before encapsulation
                                          SCMP Packet
                                      after encapsulation</pre>
<p></p>
<p id="rfc.section.4.6.1.p.8">When an ETE processes a SEAL data packet that passes ingress filtering (see: Section 4.5.5) but for which an error must be returned, it prepares an SCMP error message. The ETE sets the outer destination address/port numbers of the SCMP message to the outer source address/port numbers of the SEAL data packet, and sets the outer source address/port numbers of the SCMP message to the outer destination address/port numbers of the data packet. The ETE then sets the NBR_ID, LINK_ID and I flag in the SEAL header of the SCMP message to the same values that appeared in the SEAL header of the data packet; if the I flag is set, the ETE also includes the PKT_ID value copied from the SEAL header of the data packet.</p>
<p id="rfc.section.4.6.1.p.9">When an ITE forwards a SEAL data packet for which it is in a position to inform the previous hop of a more direct route, the ITE sends an SCMP "Predirect" message forward to the ETE (see: Section 4.6.1.3). The ETE in turn either proxies the Predirect message forward or returns a Redirect message.</p>
<p id="rfc.section.4.6.1.p.10">For all SCMP messages, the TE then sets the other flag bits in the SEAL header to C=1, A=0, F=1, M=0 and R=0. It next sets the NEXTHDR/SEG field to 0 and sends the SCMP packet to the tunnel neighbor.</p>
<h1 id="rfc.section.4.6.1.1">
<a href="#rfc.section.4.6.1.1">4.6.1.1.</a> Generating SCMP Packet Too Big (PTB) Messages</h1>
<p id="rfc.section.4.6.1.1.p.1">An ETE generates an SCMP "Packet Too Big" (PTB) message under one of the following cases:</p>
<p></p>

<ul>
<li>Case 0: when it receives the IP first fragment (i.e., one with MF=1 and Offset=0 in the outer IP header) of a SEAL protocol packet that arrived as multiple IP fragments, or:</li>
<li>Case 1: when it has already received the SEAL first segment (i.e., one with F=1 and M=1 in the SEAL header) of a SEAL protocol packet that arrived as multiple SEAL segments, and accepting the current segment would cause the size of the reassembled packet to exceed S_MRU, or:</li>
<li>Case 2: when it receives a SEAL protocol data packet with A=1 in the SEAL header that did not arrive as multiple IP fragments (i.e., one that does not also match Case 0).</li>
</ul>
<p id="rfc.section.4.6.1.1.p.3">The ETE prepares an SCMP PTB message the same as for the corresponding ICMPv6 PTB message, except that it writes the S_MRU value for this ITE in the MTU field (i.e., even if the S_MRU value is 0). For cases 0 and 2 above, the packet-in-error field includes the leading portion of the IP packet or fragment that triggered the condition. For case 1 above, the packet-in-error field includes the leading portion of the SEAL first segment, beginning with the encapsulating outer IP header.</p>
<p id="rfc.section.4.6.1.1.p.4">Finally, the ETE writes the value 0, 1 or 2 in the Code field of the PTB message according to whether the reason for generating the message was due to the corresponding case number from the list of cases above.</p>
<p id="rfc.section.4.6.1.1.p.5">NB: Unlike cases 0 and 1 above, case 2 is not an error condition and does not necessarily signify packet loss. Instead, it is a control plane acknowledgement of a data plane probe. Also, if the ETE generates a Case 0 SCMP PTB message it MUST NOT also generate a Case 2 PTB message on behalf of the same SEAL segment.</p>
<h1 id="rfc.section.4.6.1.2">
<a href="#rfc.section.4.6.1.2">4.6.1.2.</a> Generating Other SCMP Error Messages</h1>
<p id="rfc.section.4.6.1.2.p.1">An ETE generates an SCMP "Destination Unreachable - Communication with Destination Administratively Prohibited" message when its association with the ITE is bidirectional and it receives a SEAL packet with a (NBR_ID, LINK_ID, PKT_ID)-tuple or outer IP/UDP source address/port that does not correspond to this ITE (see: Section 4.5.5).</p>
<p id="rfc.section.4.6.1.2.p.2">An ETE generates an SCMP "Destination Unreachable" message with an appropriate code under the same circumstances that an IPv6 system would generate an ICMPv6 Destination Unreachable message using the same code. The SCMP Destination Unreachable message is formatted the same as for ICMPv6 Destination Unreachable messages.</p>
<p id="rfc.section.4.6.1.2.p.3">An ETE generates an SCMP "Parameter Problem" message when it receives a SEAL packet with an incorrect value in the SEAL header, and generates an SCMP "Time Exceeded" message when it garbage collects an incomplete SEAL data packet reassembly. The message formats used are the same as for the corresponding ICMPv6 messages.</p>
<p id="rfc.section.4.6.1.2.p.4">Generation of all other SCMP message types is outside the scope of this document.</p>
<h1 id="rfc.section.4.6.1.3">
<a href="#rfc.section.4.6.1.3">4.6.1.3.</a> Generating SCMP Redirection Messages</h1>
<p id="rfc.section.4.6.1.3.p.1">TEs generate SCMP Redirect/Predirect messages as part of a route optimization procedure as specified in <a href="#I-D.templin-intarea-vet">[I-D.templin-intarea-vet]</a>. An ITE generates an SCMP "Predirect" message when it sends a SEAL data packet forward to a next hop ETE which the previous hop could have instead reached directly, i.e., for route optimization purposes. An ETE generates an SCMP "Redirect" message in response to a Predirect message received from an ITE.</p>
<p id="rfc.section.4.6.1.3.p.2">When an ETE generates an SCMP Redirect message for a unidirectional neighbor, it creates randomly-generated NBR_ID and LINK_ID values to return to the ITE. The ETE then caches the values for ingress filtering purposes when decapsulating packets coming from the ITE.</p>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> Processing SCMP Messages</h1>
<p id="rfc.section.4.6.2.p.1">A TE processes any SCMP messages it receives as long as it can verify that the corresponding SCMP packet was sent from an on-path tunnel neighbor. The TE can verify that the SCMP packet came from an on-path neighbor by checking that the (NBR_ID, LINK_ID, PKT_ID)-tuple in the SEAL header as well as the source addresses of the packet correspond to the neighbor.</p>
<p id="rfc.section.4.6.2.p.2">For each SCMP message it receives, the TE first verifies that the identifying information is acceptable, then verifies that the Checksum in the SCMP message header is correct. If the identifying information and/or checksum are incorrect, the TE discards the message; otherwise, it processes the message the same as for ordinary ICMPv6 messages.</p>
<h1 id="rfc.section.4.6.2.1">
<a href="#rfc.section.4.6.2.1">4.6.2.1.</a> Processing SCMP PTB Messages</h1>
<p id="rfc.section.4.6.2.1.p.1">An ITE may receive an SCMP PTB message after it sends a SEAL data packet to an ETE (see: Section 4.6.1.1). The packet-in-error within the PTB message consists of the encapsulating IP/*/SEAL headers followed by the mid-layer/inner packet in the form in which the ITE received it prior to SEAL encapsulation.</p>
<p id="rfc.section.4.6.2.1.p.2">If the PTB message has Code=2 in the SCMP header, the ITE processes the message as both a response to an explicit probe request and an indication that the tunnel neighbor is responsive, i.e., in the same manner implied for IPv6 Neighbor Unreachability Detection "hints of forward progress" (see: <a href="#RFC4861">[RFC4861]</a>). If the PTB has Code=0 or Code=1 in the SCMP header, however, the ITE processes the message as an indication of an MTU limitation.</p>
<p id="rfc.section.4.6.2.1.p.3">if the PTB has Code =0, the ITE first verifies that the outer IP header in the packet-in-error encodes an IP first fragment, then examines the outer IP header length field to determine a new S_MSS value as follows:</p>
<p><a href="#RFC1191">[RFC1191]</a>. This searching strategy may entail multiple iterations in which the ITE sends additional SEAL data packets using a reduced S_MSS and receives additional SCMP PTB messages, but the process should quickly converge. During this process, it is essential that the ITE reduce S_MSS based on the first SCMP PTB message received under the current S_MSS size, and refrain from further reducing S_MSS until SCMP PTB messages pertaining to packets sent under the new S_MSS are received.</p>

<ul>
<li>If the length is no less than 1280, the ITE records the length as the new S_MSS value.</li>
<li>If the length is less than the current S_MSS value and also less than 1280, the ITE can discern that IP fragmentation is occurring but it cannot determine the true MTU of the restricting link due to the possibility that a router on the path is generating runt first fragments.</li>
</ul>

<p>In this latter case, the ITE may need to search for a reduced S_MSS value through an iterative searching strategy that parallels the IPv4 Path MTU Discovery "plateau table" procedure in a similar fashion as described in Section 5 of </p>
<p id="rfc.section.4.6.2.1.p.5">For both Code=0 and Code=1 PTB messages, the ITE next records the value in the MTU field of the SCMP PTB message as the new S_MRU value for this ETE and examines the inner packet within the packet-in-error. If the inner packet was unfragmentable (see: Section 4.4.3) and larger than (MAX(S_MRU, S_MSS) - HLEN), the ITE then sends a transcribed PTB message appropriate for the inner packet to the original source with MTU set to (MAX(S_MRU, S_MSS) - HLEN). (In the case of nested SEAL encapsulations, the transcribed PTB message will itself be an SCMP PTB message). If the inner packet is fragmentable, however, the ITE instead reduces its inner fragmentation S_IFT estimate to a size no larger than S_MSS for this ETE (see: Section 4.4.3) and does not send a transcribed PTB.  In that case, some fragmentable packets may be silently discarded but future fragmentable packets will subsequently undergo inner fragmentation based on this new S_IFT estimate.</p>
<p id="rfc.section.4.6.2.1.p.6">The ITE may alternatively ignore the S_MSS and S_MRU values, thus disabling SEAL-layer segmentation. In that case, the ITE sends all SEAL-encapsulated packets as single segments and implements stateless MTU discovery. In that case, if the ITE receives an SCMP PTB message from the ETE with Code=0 and with a degenerate length value in the outer IP header, it can send a translated PTB message back to the source listing a slightly smaller MTU size than the length value in the inner IP header. For example, if the ITE receives an SCMP PTB message with Code=0, outer IP length 256 and inner IP length 1500, it can send a PTB message listing an MTU of 1400 back to the source. If the ITE subsequently receives an SCMP PTB message with Code=0, outer IP length 256 and inner IP length 1400, it can send a PTB message listing an MTU of 1300 back to the source, etc.</p>
<p id="rfc.section.4.6.2.1.p.7">Actual plateau table values for this "step-down" MTU determination procedure are up to the implementation, which may consult Section 7 of <a href="#RFC1191">[RFC1191]</a> for non-normative example guidance.</p>
<h1 id="rfc.section.4.6.2.2">
<a href="#rfc.section.4.6.2.2">4.6.2.2.</a> Processing Other SCMP Error Messages</h1>
<p id="rfc.section.4.6.2.2.p.1">An ITE may receive an SCMP "Destination Unreachable - Communication with Destination Administratively Prohibited" message after it sends a SEAL data packet to a bidirectional neighbor. The ITE processes the message as an indication that it needs to (re)synchronize with the ETE (see: Section 4.7).</p>
<p id="rfc.section.4.6.2.2.p.2">An ITE may receive other SCMP "Destination Unreachable" messages with an appropriate code under the same circumstances that an IPv6 node would receive an ICMPv6 Destination Unreachable message. The ITE processes the message the same as for the corresponding ICMPv6 Destination Unreachable messages.</p>
<p id="rfc.section.4.6.2.2.p.3">An ITE may receive an SCMP "Parameter Problem" message when the ETE receives a SEAL packet with an incorrect value in the SEAL header. The ITE should examine the incorrect SEAL header field setting to determine whether a different setting should be used in subsequent packets.</p>
<p id="rfc.section.4.6.2.2.p.4">.An ITE may receive an SCMP "Time Exceeded" message when the ETE garbage collects an incomplete SEAL data packet reassembly.  The ITE should consider the message as an indication of congestion.</p>
<p id="rfc.section.4.6.2.2.p.5">Processing of all other SCMP message types is outside the scope of this document.</p>
<h1 id="rfc.section.4.6.2.3">
<a href="#rfc.section.4.6.2.3">4.6.2.3.</a> Processing SCMP Redirection Messages</h1>
<p id="rfc.section.4.6.2.3.p.1">TEs process SCMP Redirect/Predirect messages as part of a route optimization procedure as specified in <a href="#I-D.templin-intarea-vet">[I-D.templin-intarea-vet]</a>.</p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> Tunnel Endpoint Synchronization</h1>
<p id="rfc.section.4.7.p.1">The tunnel neighbor relationship between a pair of SEAL TEs can be either unidirectional or bidirectional. A unidirectional relationship can be used when TE 'A' will tunnel data packets directly to TE 'B', but 'B' will not tunnel data packets directly to 'A'. A bidirectional relationship is necessary when both TEs will tunnel data packets directly to one another.</p>
<p id="rfc.section.4.7.p.2">In order to establish a bidirectional tunnel neighbor relationship, the initiating TE (call it "A") performs a reliable exchange (e.g., a short TCP transaction) with the responding TE (call it "B"). The application layer details of the transaction are out of scope for this document, and indeed need not be standardized as long as both TEs observe the same specifications. Note that a short transaction instead of a persistent connection is advised if the outer network layer protocol addresses may change, e.g., due to a mobility event, due to loss of state in network middleboxes, etc. If there is assurance that the outer network layer protocol addresses will not change, then a persistent connection may be used.</p>
<p id="rfc.section.4.7.p.3">During the transaction, "A" and "B" first authenticate themselves to each other, then exchange information regarding the inner network layer prefixes that will be used for conveying inner packets that will be forwarded over the tunnel. Both TEs then select a randomly-generated NBR_ID and one or more randomly-generated LINK_IDs, where each LINK_ID represents a different underlying link over which the tunnel interface is configured. Both TEs then register their (NBR_ID, LINK_ID)-tuples with each other to establish the appropriate bidirectional tunnel neighbor soft state (see Sections 4.4.2 and 4.5.2).</p>
<p id="rfc.section.4.7.p.4">Following this bidirectional tunnel neighbor establishment, the TEs monitor the soft state for liveness, e.g., using Neighbor Unreachability Detection hints of forward progress. When one of the TEs wishes to terminate the relationship, it performs another short transaction to request the termination, then both TEs delete their respective tunnel soft state.</p>
<p id="rfc.section.4.7.p.5">Outbound and inbound traffic engineering between bidirectional tunnel neighbors is then coordinated by a link management agent that monitors the underlying link paths over which the tunnel is configured, and can remain continuous even if the paths through one or more of the underlying links has failed. When one TE detects that most/all underlying link paths to the other TE have failed, however, it terminates the bidirectional tunnel neighbor relationship.</p>
<p id="rfc.section.4.7.p.6">This bidirectional tunnel neighbor establishment is most commonly initiated by a client TE in establishing a connection with a serving TE, e.g., when a customer router within a home network establishes a connection with a serving router in a provider network, when a mobile handset connects with a serving router in a cellular operator network, etc.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Link Requirements</h1>
<p id="rfc.section.5.p.1">Subnetwork designers are expected to follow the recommendations in Section 2 of <a href="#RFC3819">[RFC3819]</a> when configuring link MTUs.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> End System Requirements</h1>
<p id="rfc.section.6.p.1">SEAL provides robust mechanisms for returning PTB messages; however, end systems that send unfragmentable IP packets larger than 1500 bytes are strongly encouraged to implement their own end-to-end MTU assurance, e.g., using Packetization Layer Path MTU Discovery per <a href="#RFC4821">[RFC4821]</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Router Requirements</h1>
<p id="rfc.section.7.p.1">IPv4 routers within the subnetwork are strongly encouraged to implement IPv4 fragmentation such that the first fragment is the largest and approximately the size of the underlying link MTU, i.e., they should avoid generating runt first fragments.</p>
<p id="rfc.section.7.p.2">IPv6 routers within the subnetwork are required to generate the necessary PTB messages when they drop outer IPv6 packets due to an MTU restriction.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> IANA Considerations</h1>
<p id="rfc.section.8.p.1">The IANA is instructed to allocate an IP protocol number for 'SEAL_PROTO' in the 'protocol-numbers' registry.</p>
<p id="rfc.section.8.p.2">The IANA is instructed to allocate a Well-Known Port number for 'SEAL_PORT' in the 'port-numbers' registry.</p>
<p id="rfc.section.8.p.3">The IANA is instructed to establish a "SEAL Protocol" registry to record SEAL Version values. This registry should be initialized to include the initial SEAL Version number, i.e., Version 0.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">Unlike IPv4 fragmentation, overlapping fragment attacks are not possible due to the requirement that SEAL segments be non-overlapping.  This condition is naturally enforced due to the fact that each consecutive SEAL segment begins at offset 0 with respect to the previous SEAL segment.</p>
<p id="rfc.section.9.p.2">An amplification/reflection attack is possible when an attacker sends IP first fragments with spoofed source addresses to an ETE in an attempt to generate a stream of SCMP messages returned to a victim ITE. The (NBR_ID, LINK_ID, PKT_ID)-tuple as well as the mid-layer and inner headers of the packet provide mitigation for the ETE to detect and discard SEAL segments with spoofed source addresses.</p>
<p id="rfc.section.9.p.3">The SEAL header is sent in-the-clear (outside of any IPsec/ESP encapsulations) the same as for the outer IP and other outer headers. In this respect, the threat model is no different than for IPv6 extension headers. As for IPv6 extension headers, the SEAL header is protected only by L2 integrity checks and is not covered under any L3 integrity checks.</p>
<p id="rfc.section.9.p.4">SCMP messages carry the (NBR_ID, LINK_ID, PKT_ID)-tuple as well as the mid-layer and inner headers of the packet-in-error. Therefore, when an ITE receives an SCMP message it can unambiguously associate it with the SEAL data packet that triggered the error.</p>
<p id="rfc.section.9.p.5">Security issues that apply to tunneling in general are discussed in <a href="#I-D.ietf-v6ops-tunnel-security-concerns">[I-D.ietf-v6ops-tunnel-security-concerns]</a>.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> Related Work</h1>
<p id="rfc.section.10.p.1">Section 3.1.7 of <a href="#RFC2764">[RFC2764]</a> provides a high-level sketch for supporting large tunnel MTUs via a tunnel-level segmentation and reassembly capability to avoid IP level fragmentation, which is in part the same approach used by SEAL. SEAL could therefore be considered as a fully functioned manifestation of the method postulated by that informational reference.</p>
<p id="rfc.section.10.p.2">Section 3 of <a href="#RFC4459">[RFC4459]</a> describes inner and outer fragmentation at the tunnel endpoints as alternatives for accommodating the tunnel MTU; however, the SEAL protocol specifies a mid-layer segmentation and reassembly capability that is distinct from both inner and outer fragmentation.</p>
<p id="rfc.section.10.p.3">Section 4 of <a href="#RFC2460">[RFC2460]</a> specifies a method for inserting and processing extension headers between the base IPv6 header and transport layer protocol data. The SEAL header is inserted and processed in exactly the same manner.</p>
<p id="rfc.section.10.p.4">The concepts of path MTU determination through the report of fragmentation and extending the IP Identification field were first proposed in deliberations of the TCP-IP mailing list and the Path MTU Discovery Working Group (MTUDWG) during the late 1980's and early 1990's. SEAL supports a report fragmentation capability using bits in an extension header (the original proposal used a spare bit in the IP header) and supports ID extension through a 16-bit field in an extension header (the original proposal used a new IP option). A historical analysis of the evolution of these concepts, as well as the development of the eventual path MTU discovery mechanism for IP, appears in Appendix D of this document.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> SEAL Advantages over Classical Methods</h1>
<p id="rfc.section.11.p.1">The SEAL approach offers a number of distinct advantages over the classical path MTU discovery methods <a href="#RFC1191">[RFC1191]</a> <a href="#RFC1981">[RFC1981]</a>:</p>
<p></p>

<ol>
<li>Classical path MTU discovery always results in packet loss when an MTU restriction is encountered. Using SEAL, IP fragmentation provides a short-term interim mechanism for ensuring that packets are delivered while SEAL adjusts its packet sizing parameters.</li>
<li>Classical path MTU may require several iterations of dropping packets and returning PTB messages until an acceptable path MTU value is determined. Under normal circumstances, SEAL determines the correct packet sizing parameters in a single iteration.</li>
<li>Using SEAL, ordinary packets serve as implicit probes without exposing data to unnecessary loss. SEAL also provides an explicit probing mode not available in the classic methods.</li>
<li>Using SEAL, ETEs encapsulate SCMP error messages in outer and mid-layer headers such that packet-filtering network middleboxes will not filter them the same as for "raw" ICMP messages that may be generated by an attacker.</li>
<li>The SEAL approach ensures that the tunnel either delivers or deterministically drops packets according to their size, which is a required characteristic of any IP link.</li>
<li>Most importantly, all SEAL packets have Identification values that are sufficiently long to be used for duplicate packet detection purposes and to associate ICMP error messages with actual packets sent without requiring per-packet state; hence, SEAL avoids certain denial-of-service attack vectors open to the classical methods.</li>
</ol>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#acknowledge" id="acknowledge">Acknowledgments</a>
</h1>
<p id="rfc.section.12.p.1">The following individuals are acknowledged for helpful comments and suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner, Ian Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph Droms, Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci, Joel Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob Hinden, Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt Mathis, Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark Townsley, Ole Troan, Margaret Wasserman, Magnus Westerlund, Robin Whittle, James Woodyatt, and members of the Boeing Research &amp; Technology NST DC&amp;NT group.</p>
<p id="rfc.section.12.p.2">Path MTU determination through the report of fragmentation was first proposed by Charles Lynn on the TCP-IP mailing list in 1987. Extending the IP identification field was first proposed by Steve Deering on the MTUDWG mailing list in 1989.</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC0791">[RFC0791]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>", STD 5, RFC 791, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0792">[RFC0792]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc792">Internet Control Message Protocol</a>", STD 5, RFC 792, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4443">[RFC4443]</b></td>
<td class="top">
<a>Conta, A.</a>, <a>Deering, S.</a> and <a>M. Gupta</a>, "<a href="http://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>", RFC 4443, March 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3971">[RFC3971]</b></td>
<td class="top">
<a>Arkko, J.</a>, <a>Kempf, J.</a>, <a>Zill, B.</a> and <a>P. Nikander</a>, "<a href="http://tools.ietf.org/html/rfc3971">SEcure Neighbor Discovery (SEND)</a>", RFC 3971, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4861">[RFC4861]</b></td>
<td class="top">
<a>Narten, T.</a>, <a>Nordmark, E.</a>, <a>Simpson, W.</a> and <a>H. Soliman</a>, "<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>", RFC 4861, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2460">[RFC2460]</b></td>
<td class="top">
<a href="mailto:deering@cisco.com" title="Cisco Systems, Inc.">Deering, S.E.</a> and <a href="mailto:hinden@iprg.nokia.com" title="Nokia">R.M. Hinden</a>, "<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>", RFC 2460, December 1998.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC1063">[RFC1063]</b></td>
<td class="top">
<a title="Digital Equipment Corporation (DEC)">Mogul, J.</a>, <a title="Digital Equipment Corporation (DEC)">Kent, C.</a>, <a title="Bolt Baranek and Newman (BBN)">Partridge, C.</a> and <a title="The Wollongong Group (TWG)">K. McCloghrie</a>, "<a href="http://tools.ietf.org/html/rfc1063">IP MTU discovery options</a>", RFC 1063, July 1988.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1191">[RFC1191]</b></td>
<td class="top">
<a href="mailto:mogul@decwrl.dec.com" title="Digital Equipment Corporation (DEC) , Western Research Laboratory">Mogul, J.</a> and <a href="mailto:deering@xerox.com" title="Xerox Palo Alto Research Center">S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc1191">Path MTU discovery</a>", RFC 1191, November 1990.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1981">[RFC1981]</b></td>
<td class="top">
<a href="mailto:mccann@zk3.dec.com" title="Digital Equipment Corporation">McCann, J.</a>, <a href="mailto:deering@parc.xerox.com" title="Xerox Palo Alto Research Center">Deering, S.</a> and <a href="mailto:mogul@pa.dec.com" title="Digital Equipment Corporation, Western Research Laboratory">J. Mogul</a>, "<a href="http://tools.ietf.org/html/rfc1981">Path MTU Discovery for IP version 6</a>", RFC 1981, August 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2003">[RFC2003]</b></td>
<td class="top">
<a href="mailto:perk@watson.ibm.com" title="Room H3-D34">Perkins, C.</a>, "<a href="http://tools.ietf.org/html/rfc2003">IP Encapsulation within IP</a>", RFC 2003, October 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2473">[RFC2473]</b></td>
<td class="top">
<a href="mailto:aconta@lucent.com" title="Lucent Technologies Inc.">Conta, A.</a> and <a href="mailto:deering@cisco.com" title="Cisco Systems">S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc2473">Generic Packet Tunneling in IPv6 Specification</a>", RFC 2473, December 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2923">[RFC2923]</b></td>
<td class="top">
<a>Lahey, K.</a>, "<a href="http://tools.ietf.org/html/rfc2923">TCP Problems with Path MTU Discovery</a>", RFC 2923, September 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3366">[RFC3366]</b></td>
<td class="top">
<a>Fairhurst, G.</a> and <a>L. Wood</a>, "<a href="http://tools.ietf.org/html/rfc3366">Advice to link designers on link Automatic Repeat reQuest (ARQ)</a>", BCP 62, RFC 3366, August 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3819">[RFC3819]</b></td>
<td class="top">
<a>Karn, P.</a>, <a>Bormann, C.</a>, <a>Fairhurst, G.</a>, <a>Grossman, D.</a>, <a>Ludwig, R.</a>, <a>Mahdavi, J.</a>, <a>Montenegro, G.</a>, <a>Touch, J.</a> and <a>L. Wood</a>, "<a href="http://tools.ietf.org/html/rfc3819">Advice for Internet Subnetwork Designers</a>", BCP 89, RFC 3819, July 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4213">[RFC4213]</b></td>
<td class="top">
<a>Nordmark, E.</a> and <a>R. Gilligan</a>, "<a href="http://tools.ietf.org/html/rfc4213">Basic Transition Mechanisms for IPv6 Hosts and Routers</a>", RFC 4213, October 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1812">[RFC1812]</b></td>
<td class="top">
<a href="mailto:fred@cisco.com" title="Cisco Systems">Baker, F.</a>, "<a href="http://tools.ietf.org/html/rfc1812">Requirements for IP Version 4 Routers</a>", RFC 1812, June 1995.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4380">[RFC4380]</b></td>
<td class="top">
<a>Huitema, C.</a>, "<a href="http://tools.ietf.org/html/rfc4380">Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)</a>", RFC 4380, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4301">[RFC4301]</b></td>
<td class="top">
<a>Kent, S.</a> and <a>K. Seo</a>, "<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>", RFC 4301, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4303">[RFC4303]</b></td>
<td class="top">
<a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4459">[RFC4459]</b></td>
<td class="top">
<a>Savola, P.</a>, "<a href="http://tools.ietf.org/html/rfc4459">MTU and Fragmentation Issues with In-the-Network Tunneling</a>", RFC 4459, April 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4821">[RFC4821]</b></td>
<td class="top">
<a>Mathis, M.</a> and <a>J. Heffner</a>, "<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>", RFC 4821, March 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4963">[RFC4963]</b></td>
<td class="top">
<a>Heffner, J.</a>, <a>Mathis, M.</a> and <a>B. Chandler</a>, "<a href="http://tools.ietf.org/html/rfc4963">IPv4 Reassembly Errors at High Data Rates</a>", RFC 4963, July 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2764">[RFC2764]</b></td>
<td class="top">
<a href="mailto:bgleeson@shastanets.com" title="Nortel Networks">Gleeson, B.</a>, <a href="mailto:jh@telia.fi" title="Telia Finland, Inc.">Heinanen, J.</a>, <a href="mailto:alin@shastanets.com" title="Nortel Networks">Lin, A.</a>, <a href="mailto:gja@lucent.com" title="Bell Labs Research Silicon Valley, Lucent Technologies">Armitage, G.</a> and <a href="mailto:amalis@lucent.com" title="Lucent Technologies">A.G. Malis</a>, "<a href="http://tools.ietf.org/html/rfc2764">A Framework for IP Based Virtual Private Networks</a>", RFC 2764, February 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2675">[RFC2675]</b></td>
<td class="top">
<a href="mailto:dab@bsdi.com" title="Berkeley Software Design, Inc.">Borman, D.</a>, <a href="mailto:deering@cisco.com" title="Cisco Systems, Inc.">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com" title="Nokia">R. Hinden</a>, "<a href="http://tools.ietf.org/html/rfc2675">IPv6 Jumbograms</a>", RFC 2675, August 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5445">[RFC5445]</b></td>
<td class="top">
<a>Watson, M.</a>, "<a href="http://tools.ietf.org/html/rfc5445">Basic Forward Error Correction (FEC) Schemes</a>", RFC 5445, March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1070">[RFC1070]</b></td>
<td class="top">
<a href="mailto:hagens@cs.wisc.edu" title="University of Wisconsin, Madison, Computer Sciences Department">Hagens, R.</a>, <a href="mailto:nhall@cs.wisc.edu" title="University of Wisconsin, Madison, Computer Sciences Department">Hall, N.</a> and <a href="mailto:mrose@twg.com" title="The Wollongong Group">M. Rose</a>, "<a href="http://tools.ietf.org/html/rfc1070">Use of the Internet as a subnetwork for experimentation with the OSI network layer</a>", RFC 1070, February 1989.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3232">[RFC3232]</b></td>
<td class="top">
<a>Reynolds, J.</a>, "<a href="http://tools.ietf.org/html/rfc3232">Assigned Numbers: RFC 1700 is Replaced by an On-line Database</a>", RFC 3232, January 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4191">[RFC4191]</b></td>
<td class="top">
<a>Draves, R.</a> and <a>D. Thaler</a>, "<a href="http://tools.ietf.org/html/rfc4191">Default Router Preferences and More-Specific Routes</a>", RFC 4191, November 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4987">[RFC4987]</b></td>
<td class="top">
<a>Eddy, W.</a>, "<a href="http://tools.ietf.org/html/rfc4987">TCP SYN Flooding Attacks and Common Mitigations</a>", RFC 4987, August 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5720">[RFC5720]</b></td>
<td class="top">
<a>Templin, F.</a>, "<a href="http://tools.ietf.org/html/rfc5720">Routing and Addressing in Networks with Global Enterprise Recursion (RANGER)</a>", RFC 5720, February 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.templin-intarea-vet">[I-D.templin-intarea-vet]</b></td>
<td class="top">
<a>Templin, F</a>, "<a href="http://tools.ietf.org/html/draft-templin-intarea-vet-31">Virtual Enterprise Traversal (VET)</a>", Internet-Draft draft-templin-intarea-vet-31, November 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6179">[RFC6179]</b></td>
<td class="top">
<a>Templin, F.</a>, "<a href="http://tools.ietf.org/html/rfc6179">The Internet Routing Overlay Network (IRON)</a>", RFC 6179, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6139">[RFC6139]</b></td>
<td class="top">
<a>Russert, S.</a>, <a>Fleischman, E.</a> and <a>F. Templin</a>, "<a href="http://tools.ietf.org/html/rfc6139">Routing and Addressing in Networks with Global Enterprise Recursion (RANGER) Scenarios</a>", RFC 6139, February 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5927">[RFC5927]</b></td>
<td class="top">
<a>Gont, F.</a>, "<a href="http://tools.ietf.org/html/rfc5927">ICMP Attacks against TCP</a>", RFC 5927, July 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-v6ops-tunnel-security-concerns">[I-D.ietf-v6ops-tunnel-security-concerns]</b></td>
<td class="top">
<a>Krishnan, S</a>, <a>Thaler, D</a> and <a>J Hoagland</a>, "<a href="http://tools.ietf.org/html/draft-ietf-v6ops-tunnel-security-concerns-04">Security Concerns With IP Tunneling</a>", Internet-Draft draft-ietf-v6ops-tunnel-security-concerns-04, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-intarea-ipv4-id-update">[I-D.ietf-intarea-ipv4-id-update]</b></td>
<td class="top">
<a>Touch, J</a>, "<a href="http://tools.ietf.org/html/draft-ietf-intarea-ipv4-id-update-04">Updated Specification of the IPv4 ID Field</a>", Internet-Draft draft-ietf-intarea-ipv4-id-update-04, September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="FRAG">[FRAG]</b></td>
<td class="top">
<a>Kent, C</a> and <a>J Mogul</a>, "<a>Fragmentation Considered Harmful</a>", October 1987.</td>
</tr>
<tr>
<td class="reference"><b id="FOLK">[FOLK]</b></td>
<td class="top">
<a>Shannon, C</a>, <a>Moore, D</a> and <a>k claffy</a>, "<a>Beyond Folklore: Observations on Fragmented Traffic</a>", December 2002.</td>
</tr>
<tr>
<td class="reference"><b id="MTUDWG">[MTUDWG]</b></td>
<td class="top">
<a>, </a>, "<a>IETF MTU Discovery Working Group mailing list, gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November 1989 - February 1995.</a>", .</td>
</tr>
<tr>
<td class="reference"><b id="TCP-IP">[TCP-IP]</b></td>
<td class="top">
<a>, </a>, "<a>Archive/Hypermail of Early TCP-IP Mail List, http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May 1987 - May 1990.</a>", .</td>
</tr>
<tr>
<td class="reference"><b id="TBIT">[TBIT]</b></td>
<td class="top">
<a>Medina, A</a>, <a>Allman, M</a> and <a>S Floyd</a>, "<a>Measuring Interactions Between Transport Protocols and Middleboxes</a>", October 2004.</td>
</tr>
<tr>
<td class="reference"><b id="WAND">[WAND]</b></td>
<td class="top">
<a>Luckie, M</a>, <a>Cho, K</a> and <a>B Owens</a>, "<a>Inferring and Debugging Path MTU Discovery Failures</a>", October 2005.</td>
</tr>
<tr>
<td class="reference"><b id="SIGCOMM">[SIGCOMM]</b></td>
<td class="top">
<a>Luckie, M</a> and <a>B Stasiewicz</a>, "<a>Measuring Path MTU Discovery Behavior</a>", November 2010.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> Reliability</h1>
<p id="rfc.section.Appendix A.p.1">Although a SEAL tunnel may span an arbitrarily-large subnetwork expanse, the IP layer sees the tunnel as a simple link that supports the IP service model. Since SEAL supports segmentation at a layer below IP, SEAL therefore presents a case in which the link unit of loss (i.e., a SEAL segment) is smaller than the end-to-end retransmission unit (e.g., a TCP segment).</p>
<p id="rfc.section.Appendix A.p.2">Links with high bit error rates (BERs) (e.g., IEEE 802.11) use Automatic Repeat-ReQuest (ARQ) mechanisms <a href="#RFC3366">[RFC3366]</a> to increase packet delivery ratios, while links with much lower BERs typically omit such mechanisms. Since SEAL tunnels may traverse arbitrarily-long paths over links of various types that are already either performing or omitting ARQ as appropriate, it would therefore often be inefficient to also require the tunnel to perform ARQ.</p>
<p id="rfc.section.Appendix A.p.3">When the SEAL ITE has knowledge that the tunnel will traverse a subnetwork with non-negligible loss due to, e.g., interference, link errors, congestion, etc., it can solicit Segment Reports from the ETE periodically to discover missing segments for retransmission within a single round-trip time. However, retransmission of missing segments may require the ITE to maintain considerable state and may also result in considerable delay variance and packet reordering.</p>
<p id="rfc.section.Appendix A.p.4">SEAL may also use alternate reliability mechanisms such as Forward Error Correction (FEC). A simple FEC mechanism may merely entail gratuitous retransmissions of duplicate data, however more efficient alternatives are also possible. Basic FEC schemes are discussed in <a href="#RFC5445">[RFC5445]</a>.</p>
<p id="rfc.section.Appendix A.p.5">The use of ARQ and FEC mechanisms for improved reliability are for further study.</p>
<h1 id="rfc.appendix.Appendix B">
<a href="#rfc.appendix.Appendix%20B">Appendix B.</a> Integrity</h1>
<p id="rfc.section.Appendix B.p.1">Each link in the path over which a SEAL tunnel is configured is responsible for link layer integrity verification for packets that traverse the link. As such, when a multi-segment SEAL packet with N segments is reassembled, its segments will have been inspected by N independent link layer integrity check streams instead of a single stream that a single segment SEAL packet of the same size would have received. Intuitively, a reassembled packet subjected to N independent integrity check streams of shorter-length segments would seem to have integrity assurance that is no worse than a single-segment packet subjected to only a single integrity check steam, since the integrity check strength diminishes in inverse proportion with segment length. In any case, the link-layer integrity assurance for a multi-segment SEAL packet is no different than for a multi-fragment IPv6 packet.</p>
<p id="rfc.section.Appendix B.p.2">Fragmentation and reassembly schemes must also consider packet-splicing errors, e.g., when two segments from the same packet are concatenated incorrectly, when a segment from packet X is reassembled with segments from packet Y, etc. The primary sources of such errors include implementation bugs and wrapping IP ID fields. In terms of implementation bugs, the SEAL segmentation and reassembly algorithm is much simpler than IP fragmentation resulting in simplified implementations. In terms of wrapping ID fields, when IPv4 is used as the outer IP protocol, the 16-bit IP ID field can wrap with only 64K packets with the same (src, dst, protocol)-tuple alive in the system at a given time <a href="#RFC4963">[RFC4963]</a> increasing the likelihood of reassembly mis-associations. However, SEAL ensures that any outer IPv4 fragmentation and reassembly will be short-lived and tuned out as soon as the ITE receives an SCMP PTB message, and SEAL segmentation and reassembly uses a much longer Identification field. Therefore, reassembly mis-associations of IP fragments nor of SEAL segments should be prohibitively rare.</p>
<h1 id="rfc.appendix.Appendix C">
<a href="#rfc.appendix.Appendix%20C">Appendix C.</a> Transport Mode</h1>
<p id="rfc.section.Appendix C.p.1">SEAL can also be used in "transport-mode", e.g., when the inner layer comprises upper-layer protocol data rather than an encapsulated IP packet. For instance, TCP peers can negotiate the use of SEAL (e.g., by inserting a 'SEAL_OPTION' TCP option during connection establishment) for the carriage of protocol data encapsulated as IPv4/SEAL/TCP. In this sense, the "subnetwork" becomes the entire end-to-end path between the TCP peers and may potentially span the entire Internet.</p>
<p id="rfc.section.Appendix C.p.2">If both TCPs agree on the use of SEAL, their protocol messages will be carried as IPv4/SEAL/TCP and the connection will be serviced by the SEAL protocol using TCP (instead of an encapsulating tunnel endpoint) as the transport layer protocol. The SEAL protocol for transport mode otherwise observes the same specifications as for Section 4.</p>
<h1 id="rfc.appendix.Appendix D">
<a href="#rfc.appendix.Appendix%20D">Appendix D.</a> Historic Evolution of PMTUD</h1>
<p id="rfc.section.Appendix D.p.1">The topic of Path MTU discovery (PMTUD) saw a flurry of discussion and numerous proposals in the late 1980's through early 1990. The initial problem was posed by Art Berggreen on May 22, 1987 in a message to the TCP-IP discussion group <a href="#TCP-IP">[TCP-IP]</a>. The discussion that followed provided significant reference material for [FRAG]. An IETF Path MTU Discovery Working Group <a href="#MTUDWG">[MTUDWG]</a> was formed in late 1989 with charter to produce an RFC. Several variations on a very few basic proposals were entertained, including:</p>
<p></p>

<ol>
<li>Routers record the PMTUD estimate in ICMP-like path probe messages (proposed in [FRAG] and later <a href="#RFC1063">[RFC1063]</a>)</li>
<li>The destination reports any fragmentation that occurs for packets received with the "RF" (Report Fragmentation) bit set (Steve Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)</li>
<li>A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)</li>
<li>Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30, 1990)</li>
<li>Fragmentation avoidance by setting "IP_DF" flag on all packets and retransmitting if ICMPv4 "fragmentation needed" messages occur (Geof Cooper's 1987 proposal; later adapted into <a href="#RFC1191">[RFC1191]</a> by Mogul and Deering).</li>
</ol>
<p id="rfc.section.Appendix D.p.3">Option 1) seemed attractive to the group at the time, since it was believed that routers would migrate more quickly than hosts. Option 2) was a strong contender, but repeated attempts to secure an "RF" bit in the IPv4 header from the IESG failed and the proponents became discouraged. 3) was abandoned because it was perceived as too complicated, and 4) never received any apparent serious consideration.  Proposal 5) was a late entry into the discussion from Steve Deering on Feb. 24th, 1990. The discussion group soon thereafter seemingly lost track of all other proposals and adopted 5), which eventually evolved into <a href="#RFC1191">[RFC1191]</a> and later <a href="#RFC1981">[RFC1981]</a>.</p>
<p id="rfc.section.Appendix D.p.4">In retrospect, the "RF" bit postulated in 2) is not needed if a "contract" is first established between the peers, as in proposal 4) and a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on Feb 19.  1990. These proposals saw little discussion or rebuttal, and were dismissed based on the following the assertions:</p>
<p></p>

<ul>
<li>routers upgrade their software faster than hosts</li>
<li>PCs could not reassemble fragmented packets</li>
<li>Proteon and Wellfleet routers did not reproduce the "RF" bit properly in fragmented packets</li>
<li>Ethernet-FDDI bridges would need to perform fragmentation (i.e., "translucent" not "transparent" bridging)</li>
<li>the 16-bit IP_ID field could wrap around and disrupt reassembly at high packet arrival rates</li>
</ul>

<p>The first four assertions, although perhaps valid at the time, have been overcome by historical events. The final assertion is addressed by the mechanisms specified in SEAL.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Fred L. Templin</span> editor
	  <span class="n hidden">
		<span class="family-name">Templin</span>
	  </span>
	</span>
	<span class="org vcardline">Boeing Research & Technology</span>
	<span class="adr">
	  <span>P.O. Box 3707</span>

	  <span class="vcardline">
		<span class="locality">Seattle</span>,  
		<span class="region">WA</span> 
		<span class="code">98124</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:fltemplin@acm.org">fltemplin@acm.org</a></span>

  </address>
</div>

</body>
</html>