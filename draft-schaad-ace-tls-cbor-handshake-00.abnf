Handshake = handshakeMessage

handshakeMessage = {
      1 : ClientHello,
      2 : ServerHello,
      3 : EndOfEarlyData,
      4 : EncryptedExtensions,
      5 : CertificateRequest,
      6 : Certificate,
      7 : CertificateVerify,
      8 : Finished,
      9 : NewSessionTicket,
      10 : KeyUpdate
ClientHello = [
       random : bstr .len 32,
       cipher_suites : [+ int . len 1], // max 2^8-1
       extensions : [ + Extension ]
ServerHello = [
      random : bstr .len 32
      cipher_suite : int,
      extensions : [ + Extension ]
ExtensionType = (
Extension = ( int, any )

signature_algorithms = bstr

NamedGroup = {
       secp256r1: 1, secp384r1: 2, secp521r1: 3,
       x25519: 4, x448:5
supported_groups = [ + NamedGroup ]

keyShareEntry = {
       secp256r1 : CompressedPointRepresentation,
       secp384r1 : CompressedPointRepresentation,
       secp521r1 : CompressedPointRepresentation,
       x25519 : bstr,
       x448 : bstr,
       * NamedGroup : any
key_share = KeyShare_ClientHello | KeyShare_HelloRetryRequest |
           KeyShare_ServerHello

KeyShare_ClientHello = [ *keyShareEntry]
KeyShare_HelloRetryRequest = NamedGroup
KeyShare_ServerHello = keyShareEntry


CompressedPointReprentation = [
       x : bstr,
       y : bool
pskKeyExchangeMode = ( psk_key: 0, psk_dhe_ke:1 }

psk_key_exchange_modes = [ + pskKeyExchangeMode]

pre_shared_key = clientHello_PSK | serverHello_PSK

clientHello_PSK = OfferedPsks

serverHello_PSK = int

OfferedPsks = [
      identities : [ +PskIdentity ],
      binders : bstr
PskIdentity = (
       identity : bstr,
       ? obfuscated_ticket_age : int
clientCertType = certTypeRequest | certTypeResponse
serverCertType = certTypeRequest | certTypeResponse

certTypeRequest = [+ cerType]
certTypeResponse = certType

certType = (x509:0, rawPublicKey:1 }


EncryptedExtensions = [ * Extension ]







certificate = [
       ? certificate_request_context : bstr,
       certificate_list : [* CertificateEntry]
CertificateEntry = [
       certificate : {
           0 : bstr, // cert_data,
           1 : bstr  // ASN1_subjectPublicKeyInfo
       },
       extensions : [* Extension]
CertificateVerify = [
       algorithm : SignatureScheme,
       signature : bstr
Finished = bstr

contentType = (
       invalid: 0, change_cipher_spec: 20, alert:21, handshake:22,
       application_data:23
TLSPlaintext = (
       type : contentType,
       fragment : bstr
TLSCiphertext = (
       type : application_data,
       encrypted_record : bstr
