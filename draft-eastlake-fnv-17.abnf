hash = offset_basis
hash = hash xor octet_of_data
hash = hash * FNV_Prime
value = ( value << 8 ) + hash[i];

temp = FNV_S ( data-to-be-hashed )
k-bit-hash = ( temp xor temp>>k ) bitwise-and ( 2**k - 1 )

X = ( int( ( 2**S - 1 ) / ( max+1 ) ) ) * ( max+1 )
hash = ( hash * FNV_Prime ) + offset_basis
fnvxyz = FNVoffset_basis ( fnvxy, Z). The resulting fnvxyz would be
FNVinited = 22,
FNVcomputed = 76,
FNVemptied = 220,
FNVclobber = 122 /* known bad value for testing */
FNV32state = 1,
FNV32Bstate = 17,
FNV64state = 3,
FNV64Bstate = 19,
FNV128state = 5,
FNV256state = 7,
FNV512state = 11,
FNV1024state = 13
fnvSuccess = 0,
temp = FNV32basis;
temp = FNV32prime * ( temp ^ ch );
temp = FNV32prime * ( temp ^ *in++ );
temp = FNV32prime * ( temp ^ *in++ );
temp = ctx->Hash;
temp = FNV32prime * ( temp ^ ch );
fnvSuccess = 0,
temp = FNV32basis;
temp = FNV32prime * ( temp ^ ch );
temp =>> 8;
temp =>> 8;
temp =>> 8;
temp = FNV32prime * ( temp ^ *in++ );
temp =>> 8;
temp =>> 8;
temp =>> 8;
temp = FNV32prime * ( temp ^ *in++ );
temp = ctx->Hash;
temp = FNV32prime * ( temp ^ ch );
fnvSuccess = 0,
temp = FNV64basis;
temp = FNV64prime * ( temp ^ ch );
temp = FNV64prime * ( temp ^ *in++ );
temp = hash & 0xFF;
temp = ( temp << 8 ) + ( hash & 0xFF );
temp = FNV64prime * ( temp ^ *in++ );
temp = ctx->Hash;
temp = FNV64prime * ( temp ^ ch );
fnvSuccess = 0,
temp = FNV64basis;
temp = FNV64prime * ( temp ^ ch );
temp = FNV64prime * ( temp ^ *in++ );
temp = hash & 0xFF;
temp = ( temp << 8 ) + ( hash & 0xFF );
temp = FNV64prime * ( temp ^ *in++ );
temp = ctx->Hash;
temp = FNV64prime * ( temp ^ ch );
fnvSuccess = 0,
err = FNV128init ( &ctx );
err = FNV128stringin ( &ctx, in );
err = FNV128init ( &ctx );
err = FNV128blockin ( &ctx, in, length );
ui8p = basis;
temp = (*ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
ui8p = basis + ( FNV128size/4 - 1 );
temp = (*ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
ui8p = basis;
temp = *ui8p++;
ui8p = basis + (FNV128size/2 - 1);
temp = *ui8p--;
fnvSuccess = 0,
ui8p = basis;
temp = (*ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
ui8p = basis + (FNV256size/4 - 1);
temp = (*ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
ui8p = basis;
temp = *ui8p++;
ui8p = basis + FNV256size/2 -1;
temp = *ui8p--;
fnvSuccess = 0,
ui8p = basis;
temp = (*ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
ui8p = basis + (FNV512size/4 - 1);
temp = (*ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
ui8p = basis;
temp = *ui8p++;
ui8p = basis + ( FNV512size/2 - 1 );
temp = *ui8p--;
fnvSuccess = 0,
ui8p = basis;
temp = (*ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
temp = (temp + *ui8p++)<<8;
ui8p = basis + (FNV1024size/4 - 1);
temp = (*ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
temp = (temp + *ui8p--)<<8;
ui8p = basis;
temp = *ui8p++;
ui8p = basis + ( FNV1024size/2 - 1 );
temp = *ui8p--;
funcName = "Testing TestR ";
         /* test the Test Return function */
funcName = "Test32Value";
funcName = "FNV32";

Terr = 0;
Terr = 0;
err = TestR ( "string", fnvSuccess,
                  FNV32string ( teststring[i], &eUint32 ) );
err = TestR ( "block", fnvSuccess,
                  FNV32block ( (uint8_t *)teststring[i],
                               (unsigned long)(strlen(teststring[i])+1),
                               &eUint32 ) );
err = TestR ( "init", fnvSuccess, FNV32init ( &eContext ) );
iLen = strlen ( teststring[i] );
err = TestR ( "blockin", fnvSuccess,
                  FNV32blockin ( &eContext,
                                 (uint8_t *)teststring[i],
                                 iLen/2 ) );
err = TestR ( "stringin", fnvSuccess,
err = TestR ( "result", fnvSuccess,
                  FNV32result ( &eContext, &eUint32 ) );
funcName = "FNV64";

Terr = 0;
Terr = 0;
err = TestR ( "string", fnvSuccess,
                  FNV64string ( teststring[i], &eUint64 ) );
err = TestR ( "block", fnvSuccess,
                  FNV64block ( (uint8_t *)teststring[i],
                               (unsigned long)(strlen(teststring[i])+1),
                               &eUint64 ) );
err = TestR ( "init", fnvSuccess, FNV64init ( &eContext ) );

funcName = "FNV128";

Terr = 0;
Terr = 0;
funcName = "FNV256";

Terr = 0;
Terr = 0;
funcName = "FNV512";

Terr = 0;
Terr = 0;
funcName = "FNV1024";

Terr = 0;
Terr = 0;
digest = digest.xor(BigInteger.valueOf((int) b & 255));
digest = digest.multiply(fnvPrime).mod(m);
