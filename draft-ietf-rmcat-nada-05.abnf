d_tilde = <                                           (1)
              |                  (d_queue-QTH)
              \ QTH exp(-LAMBDA ---------------) , otherwise.
                                    QTH
tloss_exp = MULTILOSS * tloss_int.


x_curr = d_tilde + DMARK*(p_mark/PMRREF)^2 + DLOSS*(p_loss/PLRREF)^2.  (2)


   Here, DMARK is prescribed reference delay penalty associated with ECN
   markings at the reference marking ratio of PMRREF; DLOSS is
   prescribed reference delay penalty associated with packet losses at
   the reference packet loss ratio of PLRREF.  The value of DLOSS and
   DMARK does not depend on configurations at the network node.  Since
   ECN-enabled active queue management schemes typically mark a packet
   before dropping it, the value of DLOSS SHOULD be higher than that of
   DMARK.  Furthermore, the values of DLOSS and DMARK need to be set
   consistently across all NADA flows for them to compete fairly.

   In the absence of packet marking and losses, the value of x_curr
   reduces to the observed queuing delay d_queue.  In that case the NADA
   algorithm operates in the regime of delay-based adaptation.

   Given observed per-packet delay and loss information, the receiver is
   also in a good position to determine whether the network is
   underutilized and recommend the corresponding rate adaptation mode
   for the sender.  The criteria for operating in accelerated ramp-up
   mode are:

   o  No recent packet losses within the observation window LOGWIN; and

   o  No build-up of queuing delay: d_fwd-d_base < QEPS for all previous
      delay samples within the observation window LOGWIN.

   Otherwise the algorithm operates in graduate update mode.

x_prev = x_curr
t_last = t_curr

gamma = min(GAMMA_MAX, ------------------)     (3)
                               rtt+DELTA+DFILT

r_ref = max(r_ref, (1+gamma) r_recv)           (4)


x_offset = x_curr - PRIO*XREF*RMAX/r_ref          (5)

x_diff   = x_curr - x_prev                        (6)

                              delta    x_offset
r_ref = r_ref - KAPPA*-------*------------*r_ref
                               TAU       TAU

                                   x_diff
                     - KAPPA*ETA*---------*r_ref         (7)
                                    TAU

r_ref = min(r_ref, RMAX)          (8)

r_ref = max(r_ref, RMIN)          (9)


p_loss = ALPHA*p_inst + (1-ALPHA)*p_loss.   (10)
r_vin = r_ref - BETA_V*8*buffer_len*FPS.     (11)

r_send = r_ref + BETA_S*8*buffer_len*FPS.    (12)

q_avg = w*q + (1-w)*q_avg.

p= <  p_max*--------------, if q_lo <= q < q_hi;
              |         q_hi - q_lo
              |
              \ p = 1,                if q >= q_hi.

p = <  p_max* --------------, if b_lo<= b-b_tk <b_hi;
            |           b_hi-b_lo
            |
            \ 1,                     if b-b_tk>=b_hi.


