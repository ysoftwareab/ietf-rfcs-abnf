<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Obscuring Location</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Method Characteristics and Applicability">
<link href="#rfc.section.3" rel="Chapter" title="3 Obscuring Static Locations">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Known Point Locations">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Known Locations with Uncertainty">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Selecting a Offset Vector">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Angle and Distance Method">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Square Peg Method">
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 Randomness Requirements">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Multiple Reported Locations">
<link href="#rfc.section.4" rel="Chapter" title="4 Obscuring Changing Locations">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Update Conditions">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Bad Triggers">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Hidden Trigger">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Consecutive Reported Locations">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Reducing Variation between Offset Vectors">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Trade-off in Reducing Variation">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Returning to the Same Location">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Positional Stability">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Triggering with Positional Stability">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Selecting a Grid">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 Random Grid">
<link href="#rfc.section.4.3.5" rel="Chapter" title="4.3.5 Linear Interpolation of Random Offsets">
<link href="#rfc.section.4.3.5.1" rel="Chapter" title="4.3.5.1 Uniformly Distributed Interpolation">
<link href="#rfc.section.4.3.5.2" rel="Chapter" title="4.3.5.2 Applying Uniformly Distributed Interpolation">
<link href="#rfc.section.4.3.5.3" rel="Chapter" title="4.3.5.3 Selecting an Appropriate Grid Size">
<link href="#rfc.section.4.3.6" rel="Chapter" title="4.3.6 The Wonky Grid">
<link href="#rfc.section.4.3.6.1" rel="Chapter" title="4.3.6.1 Wonky Grid Points at the Poles">
<link href="#rfc.section.4.3.6.2" rel="Chapter" title="4.3.6.2 Interpolation About the 180th Meridian">
<link href="#rfc.section.4.3.7" rel="Chapter" title="4.3.7 Temporal Interpolation">
<link href="#rfc.section.5" rel="Chapter" title="5 Examples">
<link href="#rfc.section.6" rel="Chapter" title="6 Acknowledgements">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Sample Implementation">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="A method for obscuring location information is described.  Both static and changing location information can be obscured.  A single distance measure is input to the process; this parameter controls the precision of location information that can be extracted by a recipient.  " />
  <meta name="description" content="A method for obscuring location information is described.  Both static and changing location information can be obscured.  A single distance measure is input to the process; this parameter controls the precision of location information that can be extracted by a recipient.  " />
  <meta name="keywords" content="geopriv, geolocation, privacy, obscure, location, fuzz" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">GEOPRIV</td>
<td class="right">M. Thomson</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Andrew Corporation</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">June 27, 2011</td>
</tr>
<tr>
<td class="left">Expires: December 29, 2011</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Obscuring Location<br />
  <span class="filename"></span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>A method for obscuring location information is described.  Both static and changing location information can be obscured.  A single distance measure is input to the process; this parameter controls the precision of location information that can be extracted by a recipient.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 29, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Method Characteristics and Applicability</a>
</li>
<li>3.   <a href="#rfc.section.3">Obscuring Static Locations</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Known Point Locations</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Known Locations with Uncertainty</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Selecting a Offset Vector</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">Angle and Distance Method</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Square Peg Method</a>
</li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">Randomness Requirements</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Multiple Reported Locations</a>
</li>
<li>4.   <a href="#rfc.section.4">Obscuring Changing Locations</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Update Conditions</a>
</li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">Bad Triggers</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Hidden Trigger</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Consecutive Reported Locations</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Reducing Variation between Offset Vectors</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Trade-off in Reducing Variation</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Returning to the Same Location</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Positional Stability</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Triggering with Positional Stability</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Selecting a Grid</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">Random Grid</a>
</li>
<li>4.3.5.   <a href="#rfc.section.4.3.5">Linear Interpolation of Random Offsets</a>
</li>
<li>4.3.5.1.   <a href="#rfc.section.4.3.5.1">Uniformly Distributed Interpolation</a>
</li>
<li>4.3.5.2.   <a href="#rfc.section.4.3.5.2">Applying Uniformly Distributed Interpolation</a>
</li>
<li>4.3.5.3.   <a href="#rfc.section.4.3.5.3">Selecting an Appropriate Grid Size</a>
</li>
<li>4.3.6.   <a href="#rfc.section.4.3.6">The Wonky Grid</a>
</li>
<li>4.3.6.1.   <a href="#rfc.section.4.3.6.1">Wonky Grid Points at the Poles</a>
</li>
<li>4.3.6.2.   <a href="#rfc.section.4.3.6.2">Interpolation About the 180th Meridian</a>
</li>
<li>4.3.7.   <a href="#rfc.section.4.3.7">Temporal Interpolation</a>
</li>
<li>5.   <a href="#rfc.section.5">Examples</a>
</li>
<li>6.   <a href="#rfc.section.6">Acknowledgements</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Sample Implementation</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">A method for obscuring location information is described.  This method obscures location information such that it can be provided to recipients without revealing the location of the subject to within the desired distance.  </p>
<p id="rfc.section.1.p.2">Obscuring location has applications for protecting privacy, as described in <a href="#I-D.ietf-geopriv-policy">[I-D.ietf-geopriv-policy]</a>.  </p>
<p id="rfc.section.1.p.3">This method uses a single configuration parameter as input: an <em>obscuring distance</em>.  </p>
<p id="rfc.section.1.p.4">A location recipient (or recipient) is the entity that is given location about a target entity.  The goal is to ensure that the recipient is unable to recover location information with better accuracy than is desired.  Despite this obscuring the recipient should still be able to use the reported locations.  </p>
<p id="rfc.section.1.p.5">The obscuring process takes a series of <em>known locations</em>, which might have greater accuracy than the recipient is permitted to receive.  The obscuring process produces a series of <em>reported locations</em>.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#characteristics" id="characteristics">Method Characteristics and Applicability</a>
</h1>
<p id="rfc.section.2.p.1">The method described here is intended to provide limited protection for location information by constrained degradation.  The method has the following characteristics: </p>

<dl>
<dt>Simple Configuration:</dt>
<dd style="margin-left: 8">It might be possible to define a more complete solution for obscuring location information that is more configurable.  However, a more configurable option would also demand greater involvement from users so that they would be able to specify a configuration that meets their goals.  This method is designed to be easy to understand, which increases the chances that a user is able to successfully choose an appropriate configuration.  The method has just one input parameter: the obscuring distance.  <br><br> A separate parameter for the size of the grid used in the algorithm can affect results; a fixed value is recommended in this document.  </dd>
<dt>Irreversible:</dt>
<dd style="margin-left: 8">Obscuring is intended to be irreversible.  Information is lost by applying the process.  Multiple applications of this process to the same input location is could reduce information more than a single application of the process with the largest obscuring distance.  </dd>
<dt>Increases Uncertainty:</dt>
<dd style="margin-left: 8">A recipient does not need to treat obscured location information any differently to location information that contains uncertainty.  The uncertainty of the reported location is increased so that the reported location includes the known location.  Thus, the information that is reported is correct, though the accuracy might be reduced.  This document relies on a definition of uncertainty for location described in more detail in <a href="#I-D.thomson-geopriv-uncertainty">[I-D.thomson-geopriv-uncertainty]</a>.  </dd>
<dt>Two Dimensions:</dt>
<dd style="margin-left: 8">The method described in this document operates in two dimensions only.  Many of the principles might be applicable in a higher number of dimensions, though no effort has been made to validate their integrity.  A three-dimensional location can be reduced to a two-dimensional form for use in this algorithm.  This is not contrary to the goal of reducing the amount of information provided.  </dd>
<dt>Time Invariant:</dt>
<dd style="margin-left: 8">The method described in this document does not use time.  An entity performing obscuring does not need to consider time in applying this method.  Only the location is protected, not the time that the location was determined.  The time from the known location is included in the reported location.  </dd>
<dt>Obscuring Distance Not Secret:</dt>
<dd style="margin-left: 8">No attempt is made to protect the obscuring distance as a secret.  It is assumed that a recipient is able to learn this value.  </dd>
<dt>Minimal State:</dt>
<dd style="margin-left: 8">An entity that performs obscuring of locations often performs this service for the combination of many targets and recipients.  This process requires only that the obscuring entity hold maintain a trigger location for each recipient.  The additional state that an obscuring entity retains in order to apply this obscuring method is a small increment over what is typically required.  The current known location does not need to be retained; it need only be reacted to when it changes.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#static" id="static">Obscuring Static Locations</a>
</h1>
<p id="rfc.section.3.p.1">A static location doesn't change.  That is, different locations are not attributed to a single target at different times.  </p>
<p id="rfc.section.3.p.2">The basic location obscuring case involves a single, isolated instance of location information.  </p>
<p id="rfc.section.3.p.3">It might be appropriate to apply just this section in protecting the privacy of a single location.   A recipient must be unable to acquire multiple location instances for the same entity if this is the only form of obscuring used.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#point" id="point">Known Point Locations</a>
</h1>
<p id="rfc.section.3.1.p.1">A known point location can be obscured by adding a randomized offset vector to the location.  The size of the offset vector is randomly selected so that the reported location could be anywhere within the obscuring distance of the known location, see <a href="#rvector">Section 3.3</a>.  </p>
<p id="rfc.section.3.1.p.2">The uncertainty of the reported location is set to the obscuring distance.  This ensures that the reported uncertainty region encloses the known location.  </p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">It's not sufficient to increase the uncertainty region so that it minimally includes the known location.  Doing this reveals that the known location is at the boundary of the reported uncertainty region.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Known Locations with Uncertainty</h1>
<p id="rfc.section.3.2.p.1">A known location with uncertainty is reduced to a circular uncertainty region (see <a href="#I-D.thomson-geopriv-uncertainty">[I-D.thomson-geopriv-uncertainty]</a>, Section 4.2).  An irregularly shaped uncertainty region is difficult to evaluate against the scalar obscuring distance, and it might inadvertently reveal more information than intended.  </p>
<p id="rfc.section.3.2.p.2">A known location with uncertainty greater than the obscuring radius does not require additional obscuring.  The radius of the circular uncertainty region is compared to the obscuring distance to determine if further obscuring is necessary.  A location with sufficient uncertainty can be directly reported.  </p>
<p id="rfc.section.3.2.p.3">Randomization is needed if the known location contains insufficient uncertainty.  As for a point location, an offset vector is added and the uncertainty increased to the obscuring distance.  A smaller offset vector is necessary where the known location has uncertainty - this vector need only be of a size up to the obscuring distance, less the existing uncertainty.  </p>
<p id="rfc.section.3.2.p.4">The reported uncertainty is increased so that the reported location contains an uncertainty radius of at least the obscuring distance.  An uncertainty in a known location cannot be recovered by a recipient of an obscured location unless it is larger than the obscuring distance.  </p>
<p></p>

<ul class="empty">
<li>Paradoxically, more accurate location determination methods are better suited to obscuring.  </li>
<li>A location that is reported with uncertainty does not always have a uniform probability distribution.  A non-uniform distribution is not conducive to obscuring, since a location with an unevently distributed probability distribution reveals that the location of the target is more likely to be in specific parts of the uncertainty region.  </li>
<li>Information on the likely probability distribution cannot be conveyed in many systems, including presence (see <a href="#RFC4119">[RFC4119]</a>, <a href="#RFC5491">[RFC5491]</a>).  The location determination method can be reported, which can reveal characteristics of the probability distribution.  Specific measures to counteract this effect are therefore not feasible.  </li>
<li>Removing or replacing the location determination method parameter denies a recipient any information about probability distribution.  </li>
</ul>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#rvector" id="rvector">Selecting a Offset Vector</a>
</h1>
<p id="rfc.section.3.3.p.1">There are two methods that can be used to generate a random vector.  Both methods produce random vectors that are evenly distributed on the plane within the maximum size.  </p>
<p id="rfc.section.3.3.p.2">The angle and distance (polar) method is considerably simpler, but it is less well suited to the complete algorithm.  The square peg method is more conducive to the interpolation used.  </p>
<p id="rfc.section.3.3.p.3">Both methods take two uniformly distributed random numbers as input.  </p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#polar" id="polar">Angle and Distance Method</a>
</h1>
<p id="rfc.section.3.3.1.p.1">In the polar method, the first random value is used to select a random angle, the second to select a random distance.  </p>
<p id="rfc.section.3.3.1.p.2">Assuming a <samp>random()</samp> function produces a number distributed between 0 (inclusive) and 1 (exclusive) - that is, the range [0, 1) - the angle and length can be produced by the following: </p>
<div id="#rfc.figure.1"></div>
<pre>
      angle  =  random() * 2 * pi
      length =  sqrt(random()) * size
   or
      length =  (1 - |random() - random()|) * size
      </pre>
<p id="rfc.section.3.3.1.p.3">...where <samp>sqrt(x)</samp> takes the square root of <samp>x</samp> and <samp>|</samp> takes the absolute value of the enclosed.   <samp>size</samp> is the desired size of the random vector, which could be the obscuring distance less any existing uncertainty.  </p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#squarepeg" id="squarepeg">Square Peg Method</a>
</h1>
<p id="rfc.section.3.3.2.p.1">In this method, the two random values are used to select a point in a 2x2 square between -1 and +1 on each axis.  Vectors that are in the direction of a corner are reduced in length so that the total length of any vector is limited to 1 (as opposed to the square root of 2).  </p>
<div id="#rfc.figure.2"></div>
<pre>
		  ^y
  (-1,-1)         |          (1,1)
     +-------,,---+---..-------+
     |    ,-'     |     `-.    |
     |  ,'        |        `._,|
     | /          |       ,-'\ |
     |/           |   _,-'    \|
     |            |,-'  a      |
-----+------------+------------+----&gt;x
     |            |            |
     |\           |           /|
     | \          |          / |
     |  `.        |        ,'  |
     |    `-._    |    _.-'    |
     +--------``--+--''--------+
   (-1,-1)        |          (1,-1)
</pre>
<p id="rfc.section.3.3.2.p.2">The effect of this is that the probability of finding a value that is toward the corners of the square (angles of PI/4, 3PI/4, -PI/4, etc...) is twice the probability of finding a value along the axes (angles of 0, PI/2, PI, etc...).  This can be corrected by applying the resulting cumulative distribution function to the angle.  </p>
<div id="#rfc.figure.3"></div>
<pre>
      x      = random() * 2 - 1
      y      = random() * 2 - 1
      length = sqrt(x*x + y*y)
      angle  = atan2(y, x)
      a_side = round(angle * 2 / PI);
      a_rem  = angle - a_side * PI / 2
      length = length * cos(a_rem) * size
      angle  = (tan(a_rem) / 8 + a_side / 4) * 2 * PI
</pre>
<p id="rfc.section.3.3.2.p.3">...where <samp>atan2</samp> produces the angle of the vector, <samp>round(x)</samp> produces the nearest whole number to <samp>x</samp> and the cosine and tangent functions are represented by <samp>cos(x)</samp> and <samp>tan(x)</samp> respectively.  </p>
<p id="rfc.section.3.3.2.p.4">This can be more efficiently calculated without trigonometric functions using:</p>
<div id="#rfc.figure.4"></div>
<pre>
      x      = random() * 2 - 1
      y      = random() * 2 - 1
      length = max(|x|, |y|) * size
      if (x == 0) and (y == 0)
	 &gt;&gt; return zero length vector
      if (|x| &gt; |y|)
	 angle = PI * y / x / 4
      else
	 angle = PI * (2 - x / y) / 4
      if (y &lt; -x)
	 angle = angle + PI
</pre>
<p id="rfc.section.3.3.2.p.5">...where <samp>max(x, y)</samp> chooses the more positive value of <samp>x</samp> and <samp>y</samp>.  </p>
<h1 id="rfc.section.3.3.3">
<a href="#rfc.section.3.3.3">3.3.3.</a> Randomness Requirements</h1>
<p id="rfc.section.3.3.3.p.1">A recipient that is able to learn the state of the random number generator could use this to determine the offset vector.  This would reveal the known location based on a given reported location.  A <a href="#RFC4086">secure pseudo-random number generator</a> <cite title="NONE">[RFC4086]</cite> provides an assurance that recovering the state of the random number generator is made considerably more difficult.  </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#multiplestatic" id="multiplestatic">Multiple Reported Locations</a>
</h1>
<p id="rfc.section.3.4.p.1">Multiple applications of this algorithm produce different results.  The intersection of multiple reported locations can be used to recover a better estimate of the known location.  This recovered estimate has less uncertainty than the obscuring distance, which is not desirable.  </p>
<p id="rfc.section.3.4.p.2">Multiple reported locations for the same known location must not be produced.  An entity that is responsible for obscuring location might achieve this by storing the reported location with the obscured location.  </p>
<p id="rfc.section.3.4.p.3">It is possible to implement obscuring for a static location without retaining state.  Seeding a pseudo-random number generator with data that is not available to the recipient can ensure that the same result is produced from the same input.  Taking a hash of the known location combined with a secret key ensures that this seed cannot be easily determined by a recipient (see Section 6.2 of <a href="#RFC4086">[RFC4086]</a> for alternative methods).  A hash function that uses the values shown in <a href="#noise2d">Section 4.3.4</a> as input might be sufficient for this task.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#dynamic" id="dynamic">Obscuring Changing Locations</a>
</h1>
<p id="rfc.section.4.p.1">Applications that use the location of a target over time, such as <a href="#RFC4079">presence</a> <cite title="NONE">[RFC4079]</cite> require additional steps to ensure that the location a recipient acquires does not reveal more information than desired.  </p>
<p id="rfc.section.4.p.2">The first consideration is the frequency of updates.  As the target moves, the known location changes.  A frequently updated sequence of reported locations could give a recipient sufficient information to determine the known location with low uncertainty in a fashion close to that described in <a href="#multiplestatic">Section 3.4</a>.  </p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">It is not necessary to ensure that a recipient always has accurate location information.  Early proposed algorithms wrongly assumed that the reported location was required to cover the known location at all times.  Even in the absence of obscuring, changes in location result in a recipient having outdated information.  The only necessary constraint is that the location be accurate at the time that it is reported (or the time associated with that report).  </dd>
</dl>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#trigger" id="trigger">Update Conditions</a>
</h1>
<p id="rfc.section.4.1.p.1">To limit the amount of information provided to a recipient, new reported locations are not generated in response to all changes in the known location.  The trigger for creating a new reported location can be defined.  </p>
<p id="rfc.section.4.1.p.2">Any trigger condition needs to be constructed in a way that does not reveal information.  At the point that a new reported location is provided to a recipient, the fact that the trigger conditions are met at that point in time provides the recipient with significant information that could - if the trigger conditions were poorly defined - reveal significant information.  </p>
<p id="rfc.section.4.1.p.3">The goal is to provide a new reported location when the known location moves by approximately the obscuring distance.  This limits the information that a recipient has available with similar accuracy to each individual location.  </p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#bad-trigger" id="bad-trigger">Bad Triggers</a>
</h1>
<p id="rfc.section.4.1.1.p.1">One potential trigger is the movement of the target outside of the reported uncertainty region.  At the point that a new reported location is generated, a recipient knows that the target is a) at the boundary of the last uncertainty region, and b) somewhere in the new uncertainty region.  The intersection of these two regions produces an area that is significantly smaller than desired.  </p>
<div id="#rfc.figure.5"></div>
<div id="#overlap"></div>
<pre>
				  New Reported
				    Location
	   ..--"""--..   ..--"""--..   /
	.-'           /=\.          `-.
      ,'            ,'   \\            `.
     /             /       \\            \
    /             /         \\            \
   |             |           ||            |
   |             |           ||            |
   |             |           ||            |
    \             \         //            /
     `.            `.     // \          .'
       `._           `._//    \      _.'
      /   `--..___..--' `--..__\..--'
   Last Reported                \
     Location               Recovered Location
			      Along Border
</pre>
<p id="rfc.section.4.1.1.p.2">Similarly, information is revealed if the trigger is movement based on the known location.  A new reported location might be produced when the known location moves more than the obscuring distance from the known location from the last report.  </p>

<ul class="empty"><li>That is, when a new location is reported, the corresponding known location is saved.  A new reported location is determined when the current known location is more than the obscuring distance from the saved location.  </li></ul>

<p> If the recipient is able to assume that the target is moving in a straight line, the speed of the target is revealed.  </p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#hidden-trigger" id="hidden-trigger">Hidden Trigger</a>
</h1>
<p id="rfc.section.4.1.2.p.1">To limit the information that is revealed at the point that a new reported location is provided, the trigger conditions can be based on information that is not available to the recipient.  </p>
<p id="rfc.section.4.1.2.p.2">Applying randomization to the trigger reduces the ability of a recipient to make assertions about the significance of a new reported location.  </p>
<p id="rfc.section.4.1.2.p.3">A hidden trigger is established using the following process: </p>

<ul>
<li>When a new reported location is generated: <ol>
<li>The centroid of the known location is determined.</li>
<li>A <a href="#rvector">random offset vector</a> <cite title="NONE">[rvector]</cite> of a maximum size of half the obscuring distance is determined.</li>
<li>The offset vector is added to the centroid and this value is saved as a trigger point.  </li>
</ol>
<p> </p>
</li>
<li>When the known location changes: <ol>
<li>The centroid of the (new) known location is determined.</li>
<li>If this centroid is further than the obscuring distance from the saved trigger point, a new reported location is generated.  </li>
</ol>
<p> </p>
</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.4">Each new reported location is randomized using the process described in <a href="#static">Section 3</a>.  </p>
<p id="rfc.section.4.1.2.p.5">This algorithm ensures that the centroid of the known location moves between 0.5 and 1.5 times the obscuring distance before a new reported location is produced.  As a consequence, the uncertainty in the distance moved is equal to the obscuring distance.  </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#consecutive" id="consecutive">Consecutive Reported Locations</a>
</h1>
<p id="rfc.section.4.2.p.1">The obscuring method has a weakness that is as a direct consequence of the triggering conditions.  These conditions grant a recipient this information: </p>

<ul class="empty"><li>For any two consecutive reported locations there is a pair of points that are less than 1.5 times the obscuring distance apart, with one point in the area described by each reported location.  The first point is the known location at the time of the first reported location; the second point is the known location at the time of the second reported location.  </li></ul>

<p> </p>
<p id="rfc.section.4.2.p.2">At the time that a location is reported, the recipient can use this knowledge to determine that the current location of the target is at the intersection of the new reported location and a circle with a radius of 2.5 times the obscuring distance, centered on the last reported location, as shown in <a href="#biggap">Figure 6</a> </p>
<div id="#rfc.figure.6"></div>
<div id="#biggap"></div>
<pre>
		   Known location .
		   is in overlap   \
      Last                    \     \             New
	  ,.--"--..            \     \   ,.--"--..
       ,-'         `-.          \    |,-'         `-.
      /               \          \_  +               \
     |                 |            /|                |
     |        o        |&lt;----------&gt;||       o        |
     |         \       | --&gt; 1.5OD  \|                |
      \         \     /              +               /
       `.        \  ,'               |`.           ,'
	 `-..___,.+'                 ;  `-..___,.-'
		   \                /
     |&lt;------&gt;|&lt;----\-&gt;|&lt;------&gt;|&lt;-/----&gt;|&lt;------&gt;|&lt;--...
	  OD      OD \     OD     / OD       OD
		      \         ,'
		 2.5OD \       /
			\   _,'
			_\/'         OD = obscuring
		     _,,-'                distance
</pre>
<p id="rfc.section.4.2.p.3">Two consecutive reported locations can have their centers up to 3.5 times the obscuring distance apart; making the closest points on each uncertainty region up to 1.5 times the obscuring distance apart.  When consecutive reported locations are maximally distant, a recipient can recover the location of the target almost perfectly.  </p>
<p id="rfc.section.4.2.p.4">In general, the known location can be found by taking the intersection of the current reported location and the preceding and following reported locations with their radius increased to 2.5 times the obscuring distance.  </p>
<p id="rfc.section.4.2.p.5">This relies on the recipient being able to determine the obscuring distance.  As long as the known location has lower uncertainty than the obscuring distance at any point in time, the obscuring distance is trivial to recover.  </p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#smoothing" id="smoothing">Reducing Variation between Offset Vectors</a>
</h1>
<p id="rfc.section.4.2.1.p.1">This shortcoming can be addressed by reducing the difference between the random offset vector added to consecutive reported locations.  The extreme case shown in <a href="#biggap">Figure 6</a> only arises because the absolute difference between the randomization vector used for in consecutive reported locations is twice the obscuring distance.  The problem occurs when the difference between consecutive known locations approaches 1.5 times the obscuring distance in combination with this large difference between randomization vectors.  </p>
<p id="rfc.section.4.2.1.p.2">Reducing the amount that a offset vector can change between consecutive reported locations ensures that the most extreme configuration cannot occur.  </p>
<p id="rfc.section.4.2.1.p.3">Using the same offset vector for all reported locations removes the problem entirely.  However, using the same offset vector increases the probability of that vector being discovered and results a serious problem if it is discovered.  An adversary need only discover a single known location for a specific reported location.  For instance, if the target is following a road, reported locations that have a fixed offset from the known location will reveal the shape of the road.  From this it is trivial to learn the offset vector and hence all past and future locations can be recovered.  </p>
<p id="rfc.section.4.2.1.p.4">Averaging is one potential approach to this problem.  Each time a location is randomized, the offset vector used can be the average of a new random offset vector and the offset vector that was last used.  The proportion of old and new vectors determines the trade-off between the probability that a recipient is able to learn a more accurate location with the probability that a recipient is able to learn the offset.  </p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#smoothingamt" id="smoothingamt">Trade-off in Reducing Variation</a>
</h1>
<p id="rfc.section.4.2.2.p.1">It is more difficult to learn an offset vector if additional randomness is added to each new vector.  An adversary that learns a known location immediately has less information about subsequent known locations based on the amount of additional randomness.  As long as the offset vector is able to change significantly as several locations are reported, learning a limited number of offset vectors is of limited use in recovering future known locations.  </p>
<p id="rfc.section.4.2.2.p.2">Too large a change in the offset vector increases the chances of revealing the known location to a small area.  Too small a change provides an adversary that discovers a known location information more information about subsequent known locations.  A trade-off is necessary.  </p>
<p id="rfc.section.4.2.2.p.3">The only way that the known location can be guaranteed to be unknown over the entire area is when the offset vector doesn't change at all.  If the absolute difference in offset vectors is half the obscuring distance, in the worst case the recipient is able to determine the known location to be within 77 percent of the desired area.  This varies based on <samp>o(diff)</samp>, as follows: </p>
<div id="#rfc.figure.7"></div>
<pre>
   diff    = | offset[x] - offset[x - 1] | / obscuring distance
   a(diff) = ((1.5 + diff)^2 - 5.25) / (2*(1.5 + diff))
   o(diff) = acos(a(diff)) + 6.25 * acos((1.5 + diff - a(diff)) / 2.5)
	     - (1.5 + diff) * sqrt(1 - a(diff)^2)
</pre>
<p id="rfc.section.4.2.2.p.4">...where <samp>acos(x)</samp> returns the inverse cosine of <samp>x</samp>.  This only produces a result where <samp>diff</samp> is less than 2.  </p>
<p id="rfc.section.4.2.2.p.5">It might be useful in this case to create a offset vector that is no more than <samp>diff</samp> times the oscuring distance different to the previous vector.  This might be done by taking a weighted average of the previous vector with a new random offset vector as follows: </p>
<div id="#rfc.figure.8"></div>
<pre>
   o[new] =  (o[prev] * (2 - diff) + o[random] * diff) / 2
</pre>
<p id="rfc.section.4.2.2.p.6">...where <samp>o[new]</samp> is the new ofset vector, <samp>o[prev]</samp> is the new previous vector, and <samp>o[random]</samp> is a completely random vector of the same magnitude.  </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Returning to the Same Location</h1>
<p id="rfc.section.4.3.p.1">A moving target might return to the same location several times.  The method described thus far produces a different reported location each time.  A recipient that is able to observe location over time could intersect reported locations to recover the known location as long as they make the assumption that the known location is the same each time.  </p>
<p id="rfc.section.4.3.p.2">This can be extended to reveal a path that is habitually followed in the same way.  Each time the path is travelled, changing offset vectors eventually reveal a more accurate view of the path.  </p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#posstability" id="posstability">Positional Stability</a>
</h1>
<p id="rfc.section.4.3.1.p.1">The key to addressing this flaw is to have the randomization of offset vectors based on the known location.  If the same known location produced a reported location that was equal or very close to it each time that the location was obscured, this would address the problem.  </p>
<p id="rfc.section.4.3.1.p.2">It might be possible to take the coordinates of the known location and pass them - along with a secret key - through a cryptographic hash function. The resulting bits could be used as randomness that produces an offset vector.  This would ensure that the exact same location always produces the same random vector.  </p>
<p id="rfc.section.4.3.1.p.3">The drawback of this sort of method is that the location is obscured inconsistently when the known location changes even slightly.  Such imprecision is commonplace in location determination methods, rendering this approach unsuitable.  </p>
<p id="rfc.section.4.3.1.p.4">The goal is to ensure that two known locations in close proximity produce a constant (or near almost constant) random offset vector.  It is also desirable that the random vector change as the locations change.  This has the consequence of reducing the difference in randomness between consecutive reported locations, provided that the random values do not vary significantly over shorter distances (see <a href="#smoothing">Section 4.2.1</a>).  The offset vector needs to change over a longer distance to limit the amount that an adversary benefits from learning both known and reported locations.  </p>
<p id="rfc.section.4.3.1.p.5">An approach similar to that described in <a href="#PERLIN">[PERLIN]</a> is used to achieve a continuously varying random field.  In this, randomness is constrained to a grid of points with interpolation used to determine values for intervening points.  </p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> Triggering with Positional Stability</h1>
<p id="rfc.section.4.3.2.p.1">No specific changes are required for the triggering process, though this does require that some state be maintained by the entity that performs obscuring.  For a SIP entity that is maintaining a subscription, this is not expected to be onerous.  </p>
<p id="rfc.section.4.3.2.p.2">The advantage of having a specific trigger for providing a new reported location is that it reduces the information provided to a recipient.  Providing updates at a higher rate provide a recipient with additional information that could be used to recover the offset.  </p>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#grid" id="grid">Selecting a Grid</a>
</h1>
<p id="rfc.section.4.3.3.p.1">In selecting an appropriate grid with two dimensions, the curvature of the surface of the Earth presents a challenge.  The simplest approach might be to select an origin at latitude 0, longitude 0.  Grid points could be placed at increments based on a constant ratio between latitude and longitude and distance; for example, 9e-6 degrees per meter assumes a spherical planet of 6366197 meter radius, which is slightly smaller than the semi-major axis of the ellipsoid used in most Earth models.  </p>
<p id="rfc.section.4.3.3.p.2">For a two-dimensional grid with a multiple of <samp>m</samp>, the following equations identify the latitude and longitude of the four nearest grid points to a given location: </p>
<div id="#rfc.figure.9"></div>
<pre>
   grid =  m * obscuring distance * 9e-6

   latitude[low] =  floor(latitude / grid) * grid
   latitude[high] =  latitude[low] + grid

   longitude[low] =  floor(longitude / grid) * grid
   longitude[high] =  longitude[low] + grid
</pre>
<p id="rfc.section.4.3.3.p.3">...where <samp>floor(x)</samp> produces the nearest whole integer that is more negative than <samp>x</samp>.  </p>
<p id="rfc.section.4.3.3.p.4">Grid intervals can be set to a multiple of the obscuring distance that ensures that consecutive reported locations have continuously varying offset vectors.  These vectors need to change at a rate that ensures maximum change over multiple reported locations without causing too much information to be revealed from two consecutive locations (as described in <a href="#consecutive">Section 4.2</a>).  Selecting a grid size is discussed in more detail in <a href="#gridsize">Section 4.3.5.3</a>.  </p>
<p id="rfc.section.4.3.3.p.5">The shortcoming of a grid of this nature is that changes in longitude are more rapid as locations get closer to the poles.  At approximately 60 degrees of latitude (North or South), grid intervals on the East-West direction are twice as frequent as desired.  For this reason, larger intervals between grid points might be chosen for longitudes.  </p>
<p id="rfc.section.4.3.3.p.6">A solution for this problem is described in <a href="#wonky">Section 4.3.6</a>.  An alternative solution might use a local tangent plane, though this introduces the problem of selecting an appropriate tangent plane as locations change and providing consistent transitions between different tangent planes.  </p>
<p></p>

<ul class="empty"><li>In three dimensions, conversion to Earth-centered, Earth-fixed Cartesian coordinates renders this problem moot.</li></ul>
<h1 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> <a href="#noise2d" id="noise2d">Random Grid</a>
</h1>
<p id="rfc.section.4.3.4.p.1">At each of the points on the grid, a random offset vector is produced using the method described in <a href="#squarepeg">Section 3.3.2</a>.  Interpolation is used to produce the offset vector for points within each grid cell, as shown in <a href="#interp">Figure 11</a>.  </p>
<p id="rfc.section.4.3.4.p.2">Rather than use a random number generator, random numbers are produced using a cryptographic hash function.  The input to this hash might include: </p>

<ul>
<li>a secret known only by the entity that performs the obscuring with sufficient entropy to render guessing ineffective (a <a href="#RFC4086">random sequence</a> <cite title="NONE">[RFC4086]</cite> is suitable for this purpose), </li>
<li>the identity of the target, </li>
<li>each individual coordinate of the grid point, and </li>
<li>as necessary, a counter that allows for multiple random values to be generated (for angle and distance, x and y, depending on the method used to generate the random offset vector).  </li>
</ul>

<p> The inclusion of a secret ensures that a recipient is unable to construct the offset vector.  This secret is persistent so that later applications of the obscuring formula do not produce a different offset vector for the same location.  </p>
<p><a href="#rvector">Section 3.3</a> requires that multiple random numbers are produced.  The additional identifier produces additional randomness where multiple random (or pseudo-random) numbers are required.  </p>
<p id="rfc.section.4.3.4.p.4">Using a hash in this fashion ensures that each target gets a different set of random offset vectors and that the same grid point coordinates produce the same result.  </p>
<p id="rfc.section.4.3.4.p.5">Though ordering need only be consistent between consequent applications of the obscuring algorithm, the following might be used to produce random bits: </p>
<div id="#rfc.figure.10"></div>
<pre>
   random = HMAC(secret key, target identity | identifier
			     | coordinate | coordinate | ...)
</pre>
<p id="rfc.section.4.3.4.p.6">...where <samp>HMAC</samp> is the hash MAC function <a href="#RFC2104">[RFC2104]</a> and <samp>|</samp> represents concatenation, which might require a delimiter to terminate variable length values.  </p>
<p id="rfc.section.4.3.4.p.7">Alternatively, the same sequence could be used to seed a <a href="#RFC4086">secure pseudo-random number generator</a> <cite title="NONE">[RFC4086]</cite>.  Extracting values in the same order makes the <samp>identifier</samp> unnecessary.  </p>
<p id="rfc.section.4.3.4.p.8">One consequence of this approach is that changes to the obscuring distance result in the noise pattern being completely changed.  This can result in the same known location producing a significantly different reported location before and after the change.  </p>
<h1 id="rfc.section.4.3.5">
<a href="#rfc.section.4.3.5">4.3.5.</a> <a href="#interpolation" id="interpolation">Linear Interpolation of Random Offsets</a>
</h1>
<p id="rfc.section.4.3.5.p.1">Once a grid of random offset vectors is established, an offset vector is calculated based on the centroid of the known location.  <a href="#interp">Figure 11</a> shows a centroid at the point <samp>(x,y)</samp> and the values that are used in the interpolation process.  </p>
<div id="#rfc.figure.11"></div>
<div id="#interp"></div>
<pre>
	 |                              |
    - ---o------------------------------o---
	/|          ^                  /|
 (x1,y2) |          |           (x2,y2) |
	 |          | (y2-y)            |
	 |    (x,y) |                   |
	 |        \ v                   |
	 |&lt;-(x-x1)-&gt;X&lt;------(x2-x)-----&gt;|
	 |          ^                   |
	 |          | (y-y1)            |
	 |          v                   |
    - ---o------------------------------o---
	/|                             /|
 (x1,y1) |                      (x2,y1) |
</pre>
<p id="rfc.section.4.3.5.p.2">The offset vector at the identified point is produced by taking the weighted average of the offset vectors.  Two weighted averages are taken between pairs of adjacent grid points along the same axis, then the weighted average of the two resulting vectors is taken along the other axis.  </p>
<p id="rfc.section.4.3.5.p.3">The following equations produce an linearly interpolated offset vector for any point in this grid cell: </p>
<div id="#rfc.figure.12"></div>
<pre>
   tx = (x - x1) / (x2 - x1)
   ty = (y - y1) / (y2 - y1)
   w1 = o[x1,y1] * (1 - tx) + o[x2,y1] * tx
   w2 = o[x1,y1] * (1 - tx) + o[x2,y1] * tx
   offset = w1 * (1 - ty) + w2 * ty
</pre>
<p id="rfc.section.4.3.5.p.4">...where <samp>o[x1,y1]</samp> is the random offset vector at the grid point <samp>(x1,y1)</samp>.  </p>
<h1 id="rfc.section.4.3.5.1">
<a href="#rfc.section.4.3.5.1">4.3.5.1.</a> <a href="#uderp" id="uderp">Uniformly Distributed Interpolation</a>
</h1>
<p id="rfc.section.4.3.5.1.p.1">A consequence of performing a weighted average is that the resulting value is not uniformly distributed.  Depending on the weighting factor (the value <samp>tx</samp> or <samp>ty</samp> in <a href="#interpolation">Section 4.3.5</a>), the resulting probability distribution has a higher probability of producing values in the middle of the range of possible values.  </p>
<p id="rfc.section.4.3.5.1.p.2">For example, the probability distribution for a weighted average of two uniformly distributed random numbers between 0 and 1 is shown in <a href="#weightedpdf">Figure 13</a>.  The figure shows the case where <samp>t</samp> is less than 0.5, though the same distribution is produced for <samp>t</samp> and <samp>(1-t)</samp>.  </p>
<div id="#rfc.figure.13"></div>
<div id="#weightedpdf"></div>
<pre>
	     P(x)
	      |
	      |    ,---------------.
	      |   /:               :\
	      |  / :               : \
	      | /  :               :  \
	      |/   :               :   \
	      '----+---------------+------ x
	      0    t             (1-t)  1
</pre>
<p id="rfc.section.4.3.5.1.p.3">In order to correct for this skewing of results toward the middle of the range, a smoothed interpolation is used.</p>
<p id="rfc.section.4.3.5.1.p.4">Over the range from 0 to 1, the following produces a uniformly distributed interpolation between <samp>a</samp> and <samp>b</samp>: </p>
<div id="#rfc.figure.14"></div>
<pre>
   r = a * (1 - t) + b * t
   IF r &lt; t AND r &lt; (1 - t) THEN:
      r = r * r / 2 / t / (1 - t)
   ELSE IF r &gt; t AND r &gt; (1 - t) THEN:
      r = 1 - (1 - r) * (1 - r) / t / (1 - t)
   ELSE IF t &lt; 0.5 THEN:
      r = (2 * r - t) / 2 / (1 - t)
   ELSE:
      r = (2 * r - 1 + t) / 2 / t
</pre>
<p id="rfc.section.4.3.5.1.p.5">This maps a linearly interpolated value to a smoothed value, using the cumulative distribution function for the weighted sum of <samp>a</samp> and <samp>b</samp>.  This mapping produces a value between 0 and 1 for inputs between 0 and 1.  The mapping is continuous. The mapping is not monotonically increasing for some values of <samp>a</samp> and <samp>b</samp>; the intent is to have a uniform distribution between 0 and 1, not between <samp>a</samp> and <samp>b</samp>.  </p>
<p id="rfc.section.4.3.5.1.p.6">For convenience, this interpolation function is represented in shorthand throughout the remainder of the document: <samp>uniformDistInterp(a, b, t)</samp>.  </p>
<p id="rfc.section.4.3.5.1.p.7">Uniform interpolation alters the rate of change of the output.  For a proportional movement in <samp>t</samp> of <samp>dt</samp>, the absolute change in output is at most: </p>
<div id="#rfc.figure.15"></div>
<pre>
   dr = 1 - (1 - dt)^2
</pre>
<p id="rfc.section.4.3.5.1.p.8">Toward the middle of the range, for values of <samp>a</samp> and <samp>b</samp> that are at the extents of the possible range and small values of <samp>dt</samp>, changes are magnified by up to two times their magnitude.  </p>
<p id="rfc.section.4.3.5.1.p.9">This interpolation function has similar characteristics to the smoothing function used in <a href="#PERLIN">[PERLIN]</a>, except that the goal is not smoothing, but ensuring a uniform distribution of values in the output.  Values are continuous, but their first derivative is not.  </p>
<h1 id="rfc.section.4.3.5.2">
<a href="#rfc.section.4.3.5.2">4.3.5.2.</a> Applying Uniformly Distributed Interpolation</h1>
<p id="rfc.section.4.3.5.2.p.1">The methods for producing random vectors described in <a href="#rvector">Section 3.3</a> produce a result that is uniformly distributed in a circular area.  As a result, the cartesian coordinates produced are not evenly distributed on each axis.  Similarly, the polar coordinates have a non-uniformly distributed magnitude.  Rather than interpolate on the output of this process, the uniformly distributed interpolation is applied to the random inputs.  </p>
<p id="rfc.section.4.3.5.2.p.2">Interpolation is performed on a set of random numbers that are produced at each grid vertex.  This is used to produce a single set of random numbers that are used as input to the random vector algorithm.  </p>
<p id="rfc.section.4.3.5.2.p.3">A consequence of this process with the simple polar method described in <a href="#polar">Section 3.3.1</a> is that the angle of the random vector does not cross 360 degrees (2*pi) when being interpolated.  In the worst case, interpolation between two points requires rotation through almost 360 degrees.  </p>
<p></p>

<ul class="empty"><li>The alternative method of interpolating angles - linear interpolation using the shortest path - does produce an uniformly distributed output, but it also produces a discontinuity that could be exploited by a recipient when interpolation is applied in more than one dimension.  It is possible to produce a change in the offset vector of up to twice the obscuring distance in size as the known location moves only a short distance.</li></ul>
<p id="rfc.section.4.3.5.2.p.5">The more complicated <a href="#squarepeg">square peg method</a> <cite title="NONE">[squarepeg]</cite> results produces evenly distributed values without this problem.  </p>
<h1 id="rfc.section.4.3.5.3">
<a href="#rfc.section.4.3.5.3">4.3.5.3.</a> <a href="#gridsize" id="gridsize">Selecting an Appropriate Grid Size</a>
</h1>
<p id="rfc.section.4.3.5.3.p.1">In the worst case, the polar method of generating a random vector in combination with uniformly distributed interpolation can result in twice the rate of rotation.  Interpolation through a complete 360 degrees results in a maximum absolute change of: </p>
<div id="#rfc.figure.16"></div>
<pre>
   d[p] = 2 * sin(pi * dr)))
</pre>
<p id="rfc.section.4.3.5.3.p.2">...where <samp>dr</samp> is the distance moved as a proportion of the obscuring distance, which is no more than 0.5.</p>
<p id="rfc.section.4.3.5.3.p.3">Using the maximum value from <a href="#uderp">Section 4.3.5.1</a>, the number of multiples required to limit movement can be calculated using: </p>
<div id="#rfc.figure.17"></div>
<pre>
   m[p] = 1.5 / (1 - sqrt(1 - asin(d[p] / 2) / pi))
</pre>
<p id="rfc.section.4.3.5.3.p.4">For an absolute change in the random vector of no more than the obscuring distance, the grid needs to be at least 17.22 multiples of the obscuring distance.  If the absolute change is only half this amount, the grid needs to be larger, at 36.53 multiples of the obscuring distance.  </p>
<p id="rfc.section.4.3.5.3.p.5">Using such a large grid to deal with a low probability case is suboptimal.  The square peg method allows for a much smaller grid, with a maximum absolute change being dependent on only the increased rate of change produced by the interpolation method: </p>
<div id="#rfc.figure.18"></div>
<pre>
   d[sp] = 2 * dr
	 = 2 * (1 - (1 - 1.5 / m[sp])^2)
   m[sp] = 1.5 / (1 - sqrt(1 - d[sp] / 2))
</pre>
<p id="rfc.section.4.3.5.3.p.6">This means that a grid of 5.12 times the obscuring distance limits absolute difference in the offset vector to obscuring distance; a grid of 11.20 times the obscuring distances limits the difference to half.  </p>
<p id="rfc.section.4.3.5.3.p.7">Selecting a grid size at 8 times the obscuring distances ensures that the absolute change in offset vector is 0.680 times the obscuring distance.  A complete change in offset vector can then occur after linear movement of only 8 times the obscuring distance.  In the worst case, movement reveals a location within 66.0% of the area of a circle with a radius of the obscuring distance.  </p>
<h1 id="rfc.section.4.3.6">
<a href="#rfc.section.4.3.6">4.3.6.</a> <a href="#wonky" id="wonky">The Wonky Grid</a>
</h1>
<p id="rfc.section.4.3.6.p.1">To address the concerns caused by the curvature of the Earth, a modified grid-like structure can be used.  It is not strictly necessary that the grid be absolutely grid-like in structure.  Therefore, it's possible that different grid intervals could be selected.  </p>
<p id="rfc.section.4.3.6.p.2">This structure uses a different interval for points at different latitudes, at the selected low latitude: </p>
<div id="#rfc.figure.19"></div>
<pre>
   grid[llat] =  grid / cos(latitude[low])
   longitude[low,llat] =  floor(longitude / grid[llat]) * grid[llat]
   longitude[high,llat] =  longitude[low,llat] + grid[llat]
</pre>
<p id="rfc.section.4.3.6.p.3">...and at the high latitude: </p>
<div id="#rfc.figure.20"></div>
<pre>
   grid[hlat] = grid / cos(latitude[high])
   longitude[low,hlat] = floor(longitude / grid[hlat]) * grid[hlat]
   longitude[high,hlat] = longitude[low,hlat] + grid[hlat]
</pre>
<p id="rfc.section.4.3.6.p.4">...where <samp>cos(x)</samp> produces the cosine of <samp>x</samp>.  </p>
<p id="rfc.section.4.3.6.p.5">This produces fewer grid points for latitudes that are further from the Equator.  At the poles (and above), a single offset vector is sufficient.  </p>
<p id="rfc.section.4.3.6.p.6">Interpolation of these points uses four distinct points, as shown in <a href="#wonkyinterp">Figure 21</a>.  </p>
<div id="#rfc.figure.21"></div>
<div id="#wonkyinterp"></div>
<pre>
			   (x-x1_2)        (x2_2-x)
			 |&lt;--------&gt;|&lt;-----------------&gt;|
			 |          |                   |
		    - ---o------------------------------o--- -
			/|          |         ^         |\
	       (x1_2,y2) :          |         |         : (x2_2,y2)
				    |         | (y2-y)
			     (x,y)  '         |
				  \           v
				    X   - ------
					      ^
	    :                       .   :     | (y-y1)
	    |                       |   |     v
       - ---o---------------------------o--------------- -
	   /|                       |   |\
  (x1_1,y1) |&lt;---------------------&gt;|&lt;-&gt;| (x2_1,y1)
		    (x-x1_1)       (x2_1-x)
</pre>
<p id="rfc.section.4.3.6.p.7">Linear interpolation uses the amended equations: </p>
<div id="#rfc.figure.22"></div>
<pre>
   tx_1 = (x - x1_1) / (x2_1 - x1_1)
   w1 = uniformDistInterp(r[x1_1,y1], r[x2_1,y1], tx_1)
   tx_2 = (x - x1_2) / (x2_2 - x1_2)
   w2 = uniformDistInterp(r[x1_2,y2], r[x2_2,y2], tx_2)
</pre>
<p id="rfc.section.4.3.6.p.8">Note that this uses the uniformly distributed random values selected at each grid point, rather than the offset vectors.  Each random value is a uniformly distributed random value in the range [0, 1).  </p>
<h1 id="rfc.section.4.3.6.1">
<a href="#rfc.section.4.3.6.1">4.3.6.1.</a> Wonky Grid Points at the Poles</h1>
<p id="rfc.section.4.3.6.1.p.1">At 90 degrees North and South, the cosine used to determine the wonky grid produces a zero.  This produces an undefined grid spacing.</p>
<p id="rfc.section.4.3.6.1.p.2">To avoid this problem, produce a single value at each pole: (90, 0) and (-90, 0).  This value replaces <samp>w1</samp> or <samp>w2</samp> in the interpolation equations.  Retaining the same weighting (that is, <samp>ty</samp>) for determining the final offset is desirable, so that the rate of change is not artificially increased.  </p>
<h1 id="rfc.section.4.3.6.2">
<a href="#rfc.section.4.3.6.2">4.3.6.2.</a> Interpolation About the 180th Meridian</h1>
<p id="rfc.section.4.3.6.2.p.1">At 180 degrees East (or West), longitude values cross from positive to negative values.  This produces a discontinuity in the values used.  This could be exploited to learn when the known location cross the 180th meridian.  </p>
<div id="#rfc.figure.23"></div>
<div id="#interp180"></div>
<pre>
	     180/-180                         180/-180
		|                                |
 +ve: x1a       |    x2a                  x1a    |        x2a
    ---o---o--X--------o---o--- ... ---o---o--X--------o---o---
	  x1b   |         x2b         x1b        |    x2b
	.       |       .                .       |       .
	|               |                |               |
	|&lt;-------------&gt;|                |&lt;-------------&gt;|
      overlap = grid interval          overlap = grid interval
</pre>
<p id="rfc.section.4.3.6.2.p.2">This problem might only manifest for one of the two interpolations performed across changing longitude values in a wonky grid.  To address this, the values produced by the negative and positive aspects are independently generated, then these values are interpolated over a span of one grid interval.  </p>
<p id="rfc.section.4.3.6.2.p.3">For any point within half of one grid interval from the 180th meridian, this algorithm is used.  Perform interpolation using the selected grid points, then add or subtract 360 degrees from the original value to get a value that is either more than 180 degrees or less than -180 degrees.  Perform interpolation on this second point.  </p>
<p id="rfc.section.4.3.6.2.p.4">The two interpolated values are then interpolated using a different proportion.  This interpolation is taken on the overlap interval that crosses the 180th meridian, as shown in the <a href="#interp180">Figure 23</a>.  This proportion is produced by taking the positive input value (that is, the longitude value, with 360 degrees added if it is negative) and applying the following: </p>
<div id="#rfc.figure.24"></div>
<pre>
   grid = m * obscuring distance * 9e-6 / cos(latitude)
   IF longitide + grid / 2 &gt; 180 OR longitude - grid / 2 &lt; -180 THEN:
      t = ((longitude + 360) % 360 - 180 - grid / 2) / grid
      random[o] = uniformDistInterp(random[+ve], random[-ve], t)
   ENDIF
</pre>
<p id="rfc.section.4.3.6.2.p.5">...where <samp>%</samp> represents the modulo operation.  The final interpolated value is determined using the uniformly distributed weighted average method described in <a href="#uderp">Section 4.3.5.1</a>.  </p>
<h1 id="rfc.section.4.3.7">
<a href="#rfc.section.4.3.7">4.3.7.</a> Temporal Interpolation</h1>
<p id="rfc.section.4.3.7.p.1">Providing different values over time is difficult to balance against the need to obscure the same location in the same way.  It is possible to add additional dimensions upon which to interpolate the offset vector.  Adding time as one such dimension would allow the offset vector to change gradually over time as well as with respect to space.  </p>
<p id="rfc.section.4.3.7.p.2">A form of temporal interpolation might allow the obscuring entity to change the secret key that it maintains over time.  However, this does not provide positional stability unless the interpolation is performed over a period that is significantly longer than the period over which the known location might return to the same location.  Changing the offset vector applied to the same location would negate much of the benefit derived from the algorithm.  </p>
<p id="rfc.section.4.3.7.p.3">In practice, the period over which the offset would change would have to be significantly longer than the time taken for all potential visited locations to completely change in all aspects.  This implies that temporal interpolation is likely only useful on geological time scales.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#examples" id="examples">Examples</a>
</h1>
<p id="rfc.section.5.p.1">Obscuring a known location at latitude -34.401072, longitude 150.636361 with 100 meter obscuring distance first requires calculation of the grid size and the grid points:</p>
<div id="#rfc.figure.25"></div>
<pre>
   gridsize = 8 * obscuring_distance * 9e-6 = 0.0072
</pre>
<p id="rfc.section.5.p.2">Once that is determined, the two latitude values used for the grid are determined: </p>
<div id="#rfc.figure.26"></div>
<pre>
   lowlat = floor(-34.401072 / 0.0072) * 0.0072 = -34.4016
   highlat = lowlat + 0.0072 = -34.3944
</pre>
<p id="rfc.section.5.p.3">For each latitude value, two longitude values are determined using a modified grid size to find the final set of of grid points: </p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">Intermediate values in this example are rounded for presentation purposes.  </dd>
</dl>
<div id="#rfc.figure.27"></div>
<pre>
   grid[lowlat] = gridsize / cos(lowlat * pi / 180) = 0.0087262
   lowlng[lowlat] = floor(150.636361 / 0.0087262) * 0.0087262
		  = 150.632339
   highlng[lowlat] = lowlng[lowlat] + 0.0087262 = 150.641066
   grid[highlat] = 0.0087255
   lowlng[highlat] = 150.628105
   highlng[highlat] = 150.636831
</pre>
<p id="rfc.section.5.p.4">This gives a set of points for which random values are produced.  The actual random values used depend on many factors (see <a href="#noise2d">Section 4.3.4</a>).  The following values are used in this example: </p>
<div id="#rfc.figure.28"></div>
<pre>
   random[-34.4016, 150.632339] = 0.4228538586758077
   random[-34.4016, 150.641066] = 0.9430289615411311
   random[-34.3944, 150.628105] = 0.9174296103883535
   random[-34.3944, 150.636831] = 0.008725488356129405
</pre>
<p id="rfc.section.5.p.5">The random values are interpolated along the same latitude using a <samp>t</samp> value that is based on the distance from the corresponding low longitude value.  The two resulting values are interpolated along the same longitude using a <samp>t</samp> value that is based on the distance from the low latitude value.  Uniformly distributed interpolation is used in both cases.  </p>
<div id="#rfc.figure.29"></div>
<pre>
   t[-34.4016] = (150.636361 - 150.632339) / 0.0087262 = 0.460866
   r[-34.4016] = 0.770898
   t[-34.3944] = (150.636361 - 150.628105) / 0.0087255 = 0.946145
   r[-34.3944] = 0.440578
   t = (-34.401072 - -34.4016) / 0.0072 = 0.0733055
   r = 0.7661978449732944
</pre>
<p id="rfc.section.5.p.6">This first random value is used for the <samp>x</samp> component.  A second random value for <samp>y</samp> is chosen using the same process, producing 0.16585607985072537.  </p>
<p id="rfc.section.5.p.7">These values are then input into the square peg algorithm: </p>
<div id="#rfc.figure.30"></div>
<pre>
   d = 100 * max(0.7661978449732944, 0.16585607985072537)
     = 76.61978449732944
   -- since |x| &gt; |y|
   a = y * pi / x / 4 = 5.3380813420741795
   -- no further change since y &gt; -x
</pre>
<p id="rfc.section.5.p.8">Therefore, the location is moved 76.62 meters on a bearing of 305.84 degrees.  The resulting reported location is moved along the local tangent plane to {-34.400719, 150.635772} and a circle of 100 meter radius is described.</p>
<p id="rfc.section.5.p.9">Finally, a random point is chosen within 50 meters of the original point.  No more location is provided until the known location moves more than 100 meters from that point.  In this case, the trigger point is set to {-34.401388, 150.636471}.  If the known location is updated to {-34.401816, 150.636361}, no new location is reported.  </p>
<p id="rfc.section.5.p.10">Moving to {-34.400621, 150.635717} is more than 100 meters from the trigger point, even though this is very close to the last reported location.  This results in a new location being reported at {-34.400346, 150.634929}.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#ack" id="ack">Acknowledgements</a>
</h1>
<p id="rfc.section.6.p.1">Thanks go to Robert Sparks for identifying key shortcomings in early attempts to obscure location.   Richard Barnes, Jorge Cuellar, Cullen Jennings, Warren Kumari, and Hannes Tschofenig variously provided input, feedback, criticisms and insightful ideas.  </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.7.p.1">This document has no IANA actions.</p>
<p id="rfc.section.7.p.2">[RFC Editor: please remove this section prior to publication.]</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document describes a method for obscuring location.  An effort has been made to ensure that reported locations do not reveal any more information than the input dictates.  However, obscuring location is not a substitute for withholding location information if the goal is to ensure that a recipient remains ignorant of the known location.  Alternatively, a recipient might be provided with completely falsified location information.  </p>
<p id="rfc.section.8.p.2">There is little point in obscuring location when other location-related information is included in a composite document, like a <a href="#RFC3863">presence document</a> <cite title="NONE">[RFC3863]</cite>.  Removing other information, such as <a href="#RFC5965">dynamic location information</a> <cite title="NONE">[RFC5965]</cite> is necessary to ensure that this cannot be used to recover the known location.  </p>
<p id="rfc.section.8.p.3">A reported location can inadvertently reveal far more information than intended to a recipient in possession of additional information.  A recipient might be able to apply this additional information to determine the location of the target with less uncertainty than desired.  Additional information includes information about the reported location or information about the Target.  </p>
<p id="rfc.section.8.p.4">For instance, a recipient with a map might be able to identify areas on that map that a target is more likely to be found.  A recipient can combine any additional information with the knowledge that the reported location is correct at the time it is reported to recover a better estimate of the known location.  Aside from map-based data, other information that could be used to acquire a more accurate estimate of the location of a target might include knowledge of the target's past behavior, personality traits, or aggregated demographic data.  </p>
<p id="rfc.section.8.p.5">Increasing the obscuring distance might increase the uncertainty in the location that a recipient with additional information can ultimately recover.  The complexity involved and the large volume of additional data involved makes more specific measures difficult.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2104">[RFC2104]</b></td>
<td class="top">
<a href="mailto:hugo@watson.ibm.com" title="IBM, T.J. Watson Research Center">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu" title="University of California at San Diego, Dept of Computer Science and Engineering">Bellare, M.</a> and <a href="mailto:canetti@watson.ibm.com" title="IBM T.J. Watson Research Center">R. Canetti</a>, "<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, February 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3863">[RFC3863]</b></td>
<td class="top">
<a>Sugano, H.</a>, <a>Fujimoto, S.</a>, <a>Klyne, G.</a>, <a>Bateman, A.</a>, <a>Carr, W.</a> and <a>J. Peterson</a>, "<a href="http://tools.ietf.org/html/rfc3863">Presence Information Data Format (PIDF)</a>", RFC 3863, August 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4079">[RFC4079]</b></td>
<td class="top">
<a>Peterson, J.</a>, "<a href="http://tools.ietf.org/html/rfc4079">A Presence Architecture for the Distribution of GEOPRIV Location Objects</a>", RFC 4079, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4119">[RFC4119]</b></td>
<td class="top">
<a>Peterson, J.</a>, "<a href="http://tools.ietf.org/html/rfc4119">A Presence-based GEOPRIV Location Object Format</a>", RFC 4119, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5491">[RFC5491]</b></td>
<td class="top">
<a>Winterbottom, J.</a>, <a>Thomson, M.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc5491">GEOPRIV Presence Information Data Format Location Object (PIDF-LO) Usage Clarification, Considerations, and Recommendations</a>", RFC 5491, March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5965">[RFC5965]</b></td>
<td class="top">
<a>Shafranovich, Y.</a>, <a>Levine, J.</a> and <a>M. Kucherawy</a>, "<a href="http://tools.ietf.org/html/rfc5965">An Extensible Format for Email Feedback Reports</a>", RFC 5965, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-geopriv-arch">[I-D.ietf-geopriv-arch]</b></td>
<td class="top">
<a>Barnes, R</a>, <a>Lepinski, M</a>, <a>Cooper, A</a>, <a>Morris, J</a>, <a>Tschofenig, H</a> and <a>H Schulzrinne</a>, "<a href="http://tools.ietf.org/html/draft-ietf-geopriv-arch-03">An Architecture for Location and Location Privacy in Internet Applications</a>", Internet-Draft draft-ietf-geopriv-arch-03, October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-geopriv-policy">[I-D.ietf-geopriv-policy]</b></td>
<td class="top">
<a>Schulzrinne, H</a>, <a>Tschofenig, H</a>, <a>Cuellar, J</a>, <a>Polk, J</a>, <a>Morris, J</a> and <a>M Thomson</a>, "<a href="http://tools.ietf.org/html/draft-ietf-geopriv-policy-25">Geolocation Policy: A Document Format for Expressing Privacy Preferences for Location Information</a>", Internet-Draft draft-ietf-geopriv-policy-25, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.thomson-geopriv-uncertainty">[I-D.thomson-geopriv-uncertainty]</b></td>
<td class="top">
<a>Thomson, M</a> and <a>J Winterbottom</a>, "<a href="http://tools.ietf.org/html/draft-thomson-geopriv-uncertainty-06">Representation of Uncertainty and Confidence in PIDF-LO</a>", Internet-Draft draft-thomson-geopriv-uncertainty-06, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="PERLIN">[PERLIN]</b></td>
<td class="top">
<a>Perlin, K</a>, "<a>An Image Synthesizer </a>", ACM SIGGRAPH Computer Graphics v.19 n.3, p.287-296, July 1985.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> Sample Implementation</h1>
<p id="rfc.section.Appendix A.p.1">This javascript implements the obscuring algorithm.</p>
<div id="#rfc.figure.31"></div>
<pre>
/**
 * Location obscurer:
 *   var f = new GeoShape.Fuzzer(100, secret, target);
 *   var reported = f.fuzz(known);
 * This object retains state.
 */
GeoShape.Fuzzer = function(dist, secret, targetIdentity) {
    this.distance = dist;
    var key = Hash.HMAC(secret, targetIdentity, Hash.SHA1);
    this.random = new GeoShape.UIRandom(key, dist);
    this.trigger = null;
    this.used = 0;
    return this;
};
GeoShape.Fuzzer.prototype = {
    /**
     * Main obscuring function.
     * @param {GeoShape} a shape
     * @returns {GeoShape.GeoCircle} a fuzzed circle
     */
    fuzz: function(shape) {
	var cu = shape.to2d().calculateCentroid();
	/*
	 * cu contains two attributes:
	 * centroid: a WGS84 point; uncertainty: a distance in metres
	 */
	if (!cu.uncertainty) {
	    cu.uncertainty = 0;
	}
	if (this.hasMoved(cu.centroid)) {
	    var addunc = Math.max(0, this.distance - cu.uncertainty);
	    var centre = this.fuzzPoint(cu.centroid, addunc);
	    var unc = Math.max(cu.uncertainty, this.distance);
	    this.fuzzed = new GeoShape.GeoCircle(centre, unc);
	    var td = this.distance / 2;
	    this.trigger = this.randomize(cu.centroid, td);
	    this.used = 0;
	}
	this.used++;
	return this.fuzzed;
    },
    /**
     * Determine if the location has moved sufficient distance
     * from the trigger to require fuzzing.
     */
    hasMoved: function(centroid) {
	if (!this.trigger) {
	    return true;
	}
	return this.trigger.distanceTo(centroid) &gt; this.distance;
    },
    /**
     * Use a continuously varying random grid to move a point.
     */
    fuzzPoint: function(point, dist) {
	this.random.reset();
	var x = this.random.next(point.lat, point.lng) * 2 - 1;
	var y = this.random.next(point.lat, point.lng) * 2 - 1;
	if (x === 0 &amp;&amp; y === 0) {
	    return point;
	}
	var d = dist * Math.max(Math.abs(x), Math.abs(y));
	var a;
	if (Math.abs(x) &gt; Math.abs(y)) {
	    a = y / x;
	} else {
	    a = 2 - x / y;
	}
	if (y &lt; -x) {
	    a += 4;
	}
	return point.movePoint(d, a * Math.PI / 4);
    },
    /**
     * Move a point randomly (polar method).
     */
    randomize: function(point, dist) {
	var d = Math.sqrt(Math.random()) * dist;
	var a = Math.random() * 2 * Math.PI;
	return point.movePoint(d, a);
    }
};

/**
 * A uniformly distributed, interpolated, pseudorandom number
 * generator that produces the same value for the same key,
 * location and grid size.
 *
 * @param secret a unique, secret key sequence
 * @param gridSize the desired size of the grid, in metres
 */
GeoShape.UIRandom = function(secret, gridSize) {
    this.key = secret;
    this.grid = 8 * gridSize * 9e-6;
    this.reset();
    return this;
};
GeoShape.UIRandom.prototype = {
    /**
     * Get next pseudorandom value for a latitude and longitude.
     */
    next: function(lat, lng) {
	var lowlat = Math.floor(lat / this.grid) * this.grid;
	var bottom = this.interpLongitude(lowlat, lng);
	var top = this.interpLongitude(lowlat + this.grid, lng);
	var tlat = (lat - lowlat) / this.grid;

	this.rCount++; /* next time produces a different answer */
	return this.uniformDistInterp(bottom, top, tlat);
    },
    reset: function() {
	this.rCount = 0;
    },
    /* Takes a point and produces a "random" value. */
    hashRandom: function(lat, lng) {
	/* need to fix the lat and lng: 7 decimal places */
	var flat = Math.round(lat * 1e7).toString();
	var flng = Math.round(lng * 1e7).toString();

	var input = [].concat(this.rCount, UTF8(flat),
			      0xff, UTF8(flng));
	var h = Hash.HMAC(this.key, input, Hash.SHA1);
	var r = 0;
	for (var i = 0; i &lt; h.length; ++i) {
	    r ^= h[i] &lt;&lt; ((i % 4) * 8);
	}
	/* add 0.5 to deal with sign bit */
	return r / Math.pow(2, 32) + 0.5;
    },
    /* interpolate a and b using t, with a uniform distribution */
    uniformDistInterp: function(a, b, t) {
	var r = a * (1 - t) + b * t;
	if (r &lt; t &amp;&amp; r &lt; (1 - t)) {
	    r = r * r / 2 / t / (1 - t);
	} else if (r &gt; t &amp;&amp; r &gt; (1 - t)) {
	    r = 1 - (1 - r) * (1 - r) / 2 / t / (1 - t);
	} else {
	    r = 0.5 + (r - 0.5) / Math.max(t, 1 - t);
	}
	return r;
    },
    interpLongitude: function(lat, lng) {
	if (Math.abs(lat) &gt;= 90) {
	    return this.hashRandom((lat &gt; 0) ? 90 : -90, lng);
	}
	var size = this.grid / Math.cos(lat * Math.PI / 180);
	if ((lng - size / 2) &lt; -180 || (lng + size / 2) &gt; 180) {
	    var lngpos = (lng + 360) % 360;
	    var rpos = this.interpLongSimple(lat, lngpos, size);
	    var lngneg = lngpos - 360;
	    var rneg = this.interpLongSimple(lat, lngneg, size);
	    var t = ((lng + 360) % 360 - 180 - size / 2) / size;
	    return this.uniformDistInterp(rpos, rneg, t);
	}
	return this.interpLongSimple(lat, lng, size);
    },
    interpLongSimple: function(lat, lng, size) {
	var lowlng = Math.floor(lng / size) * size;
	var rlow = this.hashRandom(lat, lowlng);
	var rhigh = this.hashRandom(lat, lowlng + size);
	var t = (lng - lowlng) / size;
	return this.uniformDistInterp(rlow, rhigh, t);
    }
};
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Andrew Corporation</span>
	<span class="adr">
	  <span>Andrew Building (39)</span>
<span>Wollongong University Campus</span>
<span>Northfields Avenue</span>

	  <span class="vcardline">
		<span class="locality">Wollongong</span>,  
		<span class="region">NSW</span> 
		<span class="code">2522</span>
	  </span>
	  <span class="country-name vcardline">AU</span>
	</span>
	<span class="vcardline">Phone: +61 2 4221 2915</span>

<span class="vcardline">EMail: <a href="mailto:martin.thomson@andrew.com">martin.thomson@andrew.com</a></span>

  </address>
</div>

</body>
</html>