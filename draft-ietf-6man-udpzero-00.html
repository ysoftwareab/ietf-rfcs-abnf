<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>IPv6 UDP Checksum Considerations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="IPv6 UDP Checksum Considerations">
<meta name="keywords" content="template">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">G. Fairhurst</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">University of Aberdeen</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">M. Westerlund</td></tr>
<tr><td class="header">Expires: November 9, 2010</td><td class="header">Ericsson Research</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">May 8, 2010</td></tr>
</table></td></tr></table>
<h1><br />IPv6 UDP Checksum Considerations<br />draft-ietf-6man-udpzero-00</h1>

<h3>Abstract</h3>

<p>This document examines the role of the transport checksum when used
      with IPv6, as defined in RFC2460. It presents a summary of the
      trade-offs for evaluating the safety of updating RFC 2460 to permit an
      IPv6 UDP endpoint to use a zero value in the checksum field to indicate
      that no checksum is present. The document describes issues and design
      principles that need to be considered and provides recommendations.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on November 9, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Background<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Use of UDP Tunnels <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.2.1.</a>&nbsp;
Motivation for new approaches<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.2.2.</a>&nbsp;
Reducing forwarding cost<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.2.3.</a>&nbsp;
Need to inspect the entire packet<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">1.2.4.</a>&nbsp;
Interactions with middleboxes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">1.2.5.</a>&nbsp;
Support for load balancing<br />
<a href="#anchor9">2.</a>&nbsp;
Standards-Track Transports<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">2.1.</a>&nbsp;
UDP with Standard Checksum<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">2.2.</a>&nbsp;
UDP-Lite<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">2.2.1.</a>&nbsp;
Using UDP-Lite as a Tunnel Encapsulation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">2.3.</a>&nbsp;
IP in IPv6 Tunnel Encapsulations<br />
<a href="#Proposal">3.</a>&nbsp;
Evaluation of proposal to update to RFC 2460 to support zero checksum<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.1.</a>&nbsp;
Alternatives to the Standard Checksum<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.2.</a>&nbsp;
Applicability of method<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.3.</a>&nbsp;
Effect of packet modification in the network<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.3.1.</a>&nbsp;
Corruption of the destination IP address<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.3.2.</a>&nbsp;
Corruption of the source IP address<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">3.3.3.</a>&nbsp;
Delivery to an unexpected port<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">3.3.4.</a>&nbsp;
Validating the network path<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">3.4.</a>&nbsp;
Comparision<br />
<a href="#anchor22">4.</a>&nbsp;
Requirements on the specification of transported protocols<br />
<a href="#anchor23">5.</a>&nbsp;
Summary<br />
<a href="#Acknowledgements">6.</a>&nbsp;
Acknowledgements<br />
<a href="#IANA">7.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">8.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#anchor26">Appendix&nbsp;A.</a>&nbsp;
Document Change History<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The User Datagram Protocol (UDP) transport was defined by <a class='info' href='#RFC0768'>RFC768<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a> [RFC0768] for IPv4 <a class='info' href='#RFC0791'>RFC791<span> (</span><span class='info'>Postel, J., &ldquo;Internet Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> [RFC0791] and is defined in <a class='info' href='#RFC2460'>RFC2460<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a> [RFC2460] for IPv6 hosts and routers. A UDP
      transport endpoint may be either a host or a router. The <a class='info' href='#RFC5405'>UDP Usage Guidelines<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5405] provides overall guidance
      for application designers, including the use of UDP to support
      tunneling. These guidelines are applicable to this discussion.
</p>
<p>This section provides a background to key issues, and introduces the
      use of UDP as a tunnel transport protocol.
</p>
<p>Section 2 describes a set of standards-track datagram transport
      protocols that may be used to support tunnels.
</p>
<p>Section 3 evaluates proposals to update the UDP transport behaviour
      to allow for better support of tunnel protocols. It focuses on a
      proposal to eliminate the checksum for this use-case with IPv6 and
      assess the trade-offs that would arise.
</p>
<p>Section 4 reviews the trade offs and provides recommendations.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Background</h3>

<p>An Internet transport endpoint should concern itself with the
        following issues:
</p>
<p></p>
<ul class="text">
<li>Protection of the endpoint transport state from unnecessary
            extra state (i.e. Invalid state from rogue packets).
</li>
<li>Protection of the endpoint transport state from corruption of
            internal state.
</li>
<li>Pre-filtering by the endpoint of erroneous data, to protect the
            transport from unnecessary processing and from corruption that it
            can not itself reject.
</li>
<li>Pre-filter of incorrectly addressed destination packets, before
            responding to a source address.
</li>
</ul>

<p>UDP, as defined in <a class='info' href='#RFC0768'>[RFC0768]<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a>, supports two
        checksum behaviours when used with IPv4. The normal behaviour is for
        the sender to calculate a checksum over a block of data that includes
        a pseudo header and the UDP datagram payload. The UDP header includes
        a 16-bit one's complement checksum that provides a statistical
        guarantee that the payload was not corrupted in transit. This also
        allows a receiver to verify that the endpoint was the intended
        destination of the datagram, because the transport pseudo header
        covers the IP addresses, port numbers, transport payload length, and
        Next Header/Protocol value corresponding to the UDP transport protocol
        <a class='info' href='#RFC1071'>[RFC1071]<span> (</span><span class='info'>Braden, R., Borman, D., Partridge, C., and W. Plummer, &ldquo;Computing the Internet checksum,&rdquo; September&nbsp;1988.</span><span>)</span></a>. The length field verifies that the
        datagram is not truncated or padded. The checksum therefore protects
        an application against receiving corrupted payload data in place of,
        or in addition to, the data that was sent. Although the IPv4 <a class='info' href='#RFC0768'>UDP<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a> [RFC0768] checksum may be disabled, applications are
        recommended to enable UDP checksums <a class='info' href='#RFC5405'>[RFC5405]<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; November&nbsp;2008.</span><span>)</span></a>.
</p>
<p>IPv4 UDP checksum control is often a kernel-wide configuration
        control (e.g. In Linux and BSD), rather than a per socket call. There
        are Networking Interface Cards (NICs) that automatically calculate
        <a class='info' href='#RFC0793'>TCP<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a> [RFC0793] and UDP checksums on transmission
        if a checksum of zero is sent to the NIC, using a method known as
        checksum offloading.
</p>
<p>The network-layer fields that are validated by a transport checksum
        are:
</p>
<p></p>
<ul class="text">
<li>Endpoint IP source address (always included in the pseudo
            header of the checksum)
</li>
<li>Endpoint IP destination address (always included in the pseudo
            header of the checksum)
</li>
<li>Upper Layer Payload type (always included in the pseudo header
            of the checksum)
</li>
<li>IP length of payload (always included in the pseudo header of
            the checksum)
</li>
<li>Length of the network layer extension headers (i.e. By correct
            position of the hecksum bytes)
</li>
</ul>

<p>The transport-layer fields that are validated by a transport
        checksum are:</p>
<ul class="text">
<li>Transport demultiplexing, i.e. ports (always included in the
            checksum)
</li>
<li>Transport payload size (always included in checksum)
</li>
</ul>

<p>Transport endpoints also need to verify the correctness of
        reassembly of any fragmented datagram (unless the application using
        the payload is corruption tolerant, as indicated by UDP-Lite's
        checksum coverage field). For UDP, this is normally provided as a part
        of the integrity check. Disabling the IPv4 checksum prevents this
        check. A lack of checksum can lead to issues in a translator or
        middlebox (e.g. Many IPv4 Network Address Translators, NATs, rely on
        port numbers to find the mappings, packet fragments do not carry port
        numbers, so fragments get dropped). <a class='info' href='#RFC2765'>RFC2765<span> (</span><span class='info'>Nordmark, E., &ldquo;Stateless IP/ICMP Translation Algorithm (SIIT),&rdquo; February&nbsp;2000.</span><span>)</span></a> [RFC2765] provides some guidance on the
        processing of fragmented IPv4 UDP datagrams that do not carry a UDP
        checksum.
</p>
<p>IPv6 does not provide a network-layer integrity check. The removal
        of the header checksum from the IPv6 specification released routers
        from a need to update a network-layer checksum for each router hop as
        the IPv6 Hop Count is changed (comapraed to the checksum update needed
        when an IPv4 router modifies the Time-To-Live (TTL)).
</p>
<p>The IP header checksum calculation was seen as redundant for most
        traffic (with UDP or TCP checksums enabled), and people wanted to
        avoid this extra processing. However, there was concern that the
        removal of the IP header checksum in IPv6 would lessen the protection
        of the source/destination IP addresses and result in a significant (a
        multiplier of ~32,000) increase in the number of times that a UDP
        packet was accidentally delivered to the wrong destination address
        and/or apparently sourced from the wrong source address when the UDP
        checksum was set to zero. This would have had implications on the
        detectability of mis-delivery of a packet to an incorrect
        endpoint/socket, and the robustness of the Internet infrastructure.
        The use of the UDP checksum is therefore required<a class='info' href='#RFC2460'>[RFC2460]<span> (</span><span class='info'>Deering, S. and R. Hinden, &ldquo;Internet Protocol, Version 6 (IPv6) Specification,&rdquo; December&nbsp;1998.</span><span>)</span></a> when applications transmit UDP datagrams
        over IPv6.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Use of UDP Tunnels </h3>

<p>One increasingly popular use of UDP is as a tunneling protocol,
        where a tunnel endpoint encapsulates the packets of another protocol
        inside UDP datagrams and transmits them to another tunnel endpoint.
        Using UDP as a tunneling protocol is attractive when the payload
        protocol is not supported by the middleboxes that may exist along the
        path, because many middleboxes support transmission using UDP. In this
        use, the receiving endpoint decapsulates the UDP datagrams and
        forwards the original packets contained in the payload <a class='info' href='#RFC5405'>[RFC5405]<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; November&nbsp;2008.</span><span>)</span></a>. Tunnels establish virtual links that appear
        to directly connect locations that are distant in the physical
        Internet topology and can be used to create virtual (private)
        networks.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.1"></a><h3>1.2.1.&nbsp;
Motivation for new approaches</h3>

<p>A number of tunnel protocols are currently being defined (e.g.
          Automated Multicast Tunnels, <a class='info' href='#AMT'>AMT<span> (</span><span class='info'>Internet draft,             draft-ietf-mboned-auto-multicast-10, &ldquo;Automatic IP Multicast Without Explicit Tunnels (AMT),&rdquo; March&nbsp;2010.</span><span>)</span></a> [AMT], and the
          Locator/Identifier Separation Protocol, <a class='info' href='#LISP'>LISP<span> (</span><span class='info'>Internet draft,             draft-farinacci-lisp-12.txt, &ldquo;Locator/ID Separation Protocol (LISP),&rdquo; March&nbsp;2009.</span><span>)</span></a> [LISP]). These protocols have proposed an update
          to IPv6 UDP checksum processing. These tunnel protocols could
          benefit from simpler checksum processing for various reasons:</p>
<ul class="text">
<li>Reducing forwarding costs, motivated by redundancy present in
              the encapsulated packet header, since in tunnel encapsulations,
              payload integrity and length verification may be provided by
              higher layer encapsulations (often using the IPv4, UDP,
              UDP-Lite, or TCP checksums).
</li>
<li>Eliminating a need to access the entire packet when
              forwarding the packet.
</li>
<li>Enhancing ability to traverse middleboxes, especially Network
              Address Translators, NATs.
</li>
<li>A desire to use the port number space to enable
              load-sharing.
</li>
</ul>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.2"></a><h3>1.2.2.&nbsp;
Reducing forwarding cost</h3>

<p>It is a common requirement to terminate a large number of tunnels
          on a single router/host. Processing costs per tunnel concern both
          state (memory requirements) and processing costs.
</p>
<p>Automatic IP Multicast Without Explicit Tunnels, known as <a class='info' href='#AMT'>AMT<span> (</span><span class='info'>Internet draft,             draft-ietf-mboned-auto-multicast-10, &ldquo;Automatic IP Multicast Without Explicit Tunnels (AMT),&rdquo; March&nbsp;2010.</span><span>)</span></a> [AMT] currently specifies UDP as the transport
          protocol for tunneled packets carrying tunneled IP multicast
          packets. The current specification for AMT requires that the UDP
          checksum in the outer packet header should be 0 (see Section 6.6).
          It argues that the computation of an additional checksum, when an
          inner packet is already adequately protected, is an unwarranted
          burden on nodes implementing lightweight tunneling protocols. The
          AMT protocol needs to replicate a multicast packet to each gateway
          tunnel. In this case, the outer IP addresses are different for each
          tunnel and therefore require a different pseudo header to be built
          for each UDP replicated encapsulation.
</p>
<p>The argument concerning redundant processing costs is valid
          regarding the integrity of a tunneled packet. In some architectures
          (e.g. PC-based routers), other mechanisms may also significantly
          reduce checksum processing costs: There are implementations that
          have optimised checksum processing algorithms, including the use of
          checksum-offloading. This processing is readily available for IPv4
          packets at high line rates. Such processing may be anticipated for
          IPv6 endpoints, allowing them to reject corrupted packets without
          further processing. Relaxing RFC 2460 to minimise the processing
          impact for existing hardware is a transition policy decision, which
          seems undesirable if at the same time it yields a solution that may
          reduce stability and functionality in future network scenarios.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.3"></a><h3>1.2.3.&nbsp;
Need to inspect the entire packet</h3>

<p>The currently-deployed hardware in many routers uses a fast-path
          processing that only provides the first n bytes of a packet to the
          forwarding engine, where typically n &lt; 128. This prevents fast
          processing of a transport checksum over an entire (large) packet.
          Hence the currently defined IPv6 UDP checksum is poorly suited to
          use within a router that is unable to access the entire packet and
          does not provide checksum-offloading.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.4"></a><h3>1.2.4.&nbsp;
Interactions with middleboxes</h3>

<p>In IPv4, UDP-encapsulation may be desirable for NAT traversal,
          since UDP support is commonly provided.
</p>
<p>IPv6 NAT traversal does not necessarily present the same protocol
          issues as for IPv4. It is not clear that NATs will work the same way
          for IPv6. Any change to RFC 2460 is going to require rewriting (or
          defining) IPv6 NAT behaviour to achieve consistent widescale
          deployment.
</p>
<p>The requirements for IPv6 firewall traversal are likely be to be
          similar to those for IPv4. In addition, it can be reasonably
          expected that a firewall conforming to RFC 2460 will not regard UDP
          datagrams with a zero checksum as valid packets, and if such a mode
          were to be defined for IPv6, this may also need to be updated.
</p>
<p>Key questions in this space include:
</p>
<p></p>
<ul class="text">
<li>What types of middleboxes does the protocol need to cross
              (routers, NAT boxes, firewalls, etc.), and how will those
              middleboxes deal with these packets?
</li>
<li>What do IPv6 routers do today with zero-checksum UDP
              packets?
</li>
<li>What other IPv6 middleboxes exist today, and what would they
              do?
</li>
</ul>

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.5"></a><h3>1.2.5.&nbsp;
Support for load balancing</h3>

<p>The UDP port number fields have been used as a basis to design
          load-balancing solutions for IPv4. This approach could also be
          leveraged for IPv6. However, support for extension headers would
          increase the complexity of providing standards-compliant solutions
          for IPv6.
</p>
<p>An alternate method could utilise the IPv6 Flow Label to perform
          load balancing. This would release IPv6 load-balancing devices from
          the need to assume semantics for the use of the transport port
          field. This use of the flow-label is consistent with the intended
          use, although further clarity may be needed to ensure the field can
          be consistently used for this purpose, (e.g. ECMP <a class='info' href='#ECMP'>[ECMP]<span> (</span><span class='info'>, &ldquo;Using the IPv6 flow label for equal cost multipath routing in           tunnels (draft-carpenter-flow-ecmp),&rdquo; .</span><span>)</span></a>). Router vendors could be encouraged to start
          using the IPv6 Flow Label as a part of the flow hash.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Standards-Track Transports</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
UDP with Standard Checksum</h3>

<p>UDP with standard checksum behaviour is defined in RFC 2460, and
        should be the default choice. Guidelines are provided in <a class='info' href='#RFC5405'>[RFC5405]<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; November&nbsp;2008.</span><span>)</span></a>.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
UDP-Lite</h3>

<p>UDP-Lite <a class='info' href='#RFC3828'>[RFC3828]<span> (</span><span class='info'>Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and G. Fairhurst, &ldquo;The Lightweight User Datagram Protocol (UDP-Lite),&rdquo; July&nbsp;2004.</span><span>)</span></a> offers an alternate
        transport to UDP, specified as a proposed standard, RFC 3828. A MIB is
        defined in RFC 5097 and unicast usage guidelines in <a class='info' href='#RFC5405'>[RFC5405]<span> (</span><span class='info'>Eggert, L. and G. Fairhurst, &ldquo;Unicast UDP Usage Guidelines for Application Designers,&rdquo; November&nbsp;2008.</span><span>)</span></a>. UDP-Lite has been implemented, e.g. as a
        part of the Linux kernel since version 2.6.20.
</p>
<p>UDP-Lite provides a checksum with an optional partial coverage.
        When using this option, a datagram is divided into a sensitive part
        (covered by the checksum) and an insensitive part (not covered by the
        checksum). Errors/corruption in the insensitive part will not cause
        the datagram to be discarded by the transport layer at the receiving
        host. A minor side-effect of using UDP-Lite is that this was specified
        for damage-tolerant payloads, and some link-layers may employ
        different link encapsulations when forwarding UDP-Lite segments (e.g.
        Over radio access bearers). When the checksum covers the entire
        packet, which should be the default, UDP-Lite is semantically
        identical to UDP and is specified for use with IPv4 and IPv6. It uses
        an IP protocol type (or IPv6 next header) with a value of 136 decimal.
        This value is different to that used by UDP.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.1"></a><h3>2.2.1.&nbsp;
Using UDP-Lite as a Tunnel Encapsulation</h3>

<p>Tunnel encapsulations can use UDP-Lite (e.g. Control And
          Provisioning of Wireless Access Points, CAPWAP), since UDP-Lite
          provides a transport-layer checksum, including an IP pseudo header
          checksum, in IPv6, without the need for a router/middelbox to
          traverse the entire packet payload.
</p>
<p>In the LISP case, the bytes that would need to be "checksummed"
          for UDP-Lite would be the set of bytes that are added to the packet
          by the LISP encapsulating router. When an IPv4/UDP header is
          per-pended by a LISP router, the LISP ETR needs to calculate the IP
          header checksum over 20 bytes (the IP header). If an IPv6/UDP-Lite
          header were per-pended by a LISP router, the ETR would need to
          calculate an IP header checksum over 48 bytes (the IP pseudo header
          and the UDP header). This results in an increase in the number of
          bytes to be the checksummed for IPv6 (48 bytes rather than 20), but
          this is not thought to be a major additional processing overhead for
          a well-optimized implementation where the pre-pended header bytes
          are already in memory.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
IP in IPv6 Tunnel Encapsulations</h3>

<p>The IETF has defined a set of tunneling protocols. These do not
        include a checksum, since tunnel encapsulations are typically layered
        directly over the Internet layer (identified by the upper layer type
        field) and are also not used as endpoint transport protocols. That is,
        there is little chance of confusing a tunnel-encapsulated packet with
        other application data that could result in corruption of application
        state or data.
</p>
<p>From the end-to-end perspective, the principal difference is that
        the network-layer Next Header field identifies a separate transport,
        which reduces the probability that corruption could result in the
        packet being delivered to the wrong endpoint or application.
        Specifically, packets are only delivered to protocol modules that
        process a specific next header value. The next header field therefore
        provides a first-level check of correct demultiplexing. In contrast,
        the UDP port space is shared by many diverse application and therefore
        UDP demultiplexing relies solely on the port numbers.
</p>
<a name="Proposal"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Evaluation of proposal to update to RFC 2460 to support zero checksum</h3>

<p>This section evaluates a proposal to update IPv6 [RFC2460], to
      provide the option that some nodes may suppress generation and checking
      of the UDP transport checksum. The decision to omit an integrity check
      at the IPv6 level means that the transport check is overloaded with many
      functions including validating: </p>
<ul class="text">
<li>the endpoint address was not corrupted within a router - i.e.
          This packet was intended to be received by this destination and a
          wrong header has not been spliced to a different payload.
</li>
<li>the extension header processing is correctly delimited - i.e. The
          start of data has not been corrupted. The protocol type field also
          provides some protection.
</li>
<li>reassembly processing, when used.
</li>
<li>the length of the payload.
</li>
<li>the port values - i.e. The correct application gets the payload
          (applications should also check the expecetd use of source
          ports/addresses).
</li>
<li>the payload integrity.
</li>
</ul>

<p>In IPv4, the first 4 checks are performed using the IPv4 header
      checksum.
</p>
<p>In IPv6, these checks occur within the endpoint stack using the UDP
      checksum information. An IPv6 node also relies on the header information
      to determine whether to send an ICMPv6 error message and to determine
      the node to which this is sent. Corrupted information may lead to
      misdelivery to an unintended application socket on an unexpected
      host.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Alternatives to the Standard Checksum</h3>

<p>There are several alternatives to the normal method for calculating
        the UDP Checksum that do not require a tunnel endpoint to inspect the
        entire packet when computing a checksum. These include (in decreasing
        complexity):
</p>
<p></p>
<ul class="text">
<li>Delta computation of the checksum from an encapsulated checksum
            field. Since the checksum is a cumulative sum (RFC 1624), an
            encapsulating header checksum can be derived from the new pseudo
            header, the inner checksum and the sum of the other network-layer
            fields not included in the pseudo header of the encapsulated
            packet, in maaner resembling incremental checksum update <a class='info' href='#RFC1141'>[RFC1141]<span> (</span><span class='info'>Mallory, T. and A. Kullberg, &ldquo;Incremental updating of the Internet checksum,&rdquo; January&nbsp;1990.</span><span>)</span></a>. This would not require access to the
            whole packet, but does require fields to be collected across the
            header, and arithmetic operations on each packet. The method would
            only work for packets that contain a 2's complement transport
            checksum (i.e. it would not be appropriate for SCTP or when IP
            fragmentation is used). The process may be easier for IPv4 over
            IPv6 encapsulation, where the encapsulated IPv4 header checksum
            could be used as a basis.
</li>
<li>UDP-Lite. Where the checksum coverage may be set to only the
            header portion of a packet. This requires a pseudo header checksum
            calculation only on the encapsulating packet header, which
            includes extracting the UDP payload length for the pseudo header,
            however this is expected to be also known when performing packet
            forwarding. The value may be cached per flow/destination and
            subsequently combined only with the Length field to minimise
            per-packet processing.
</li>
<li>The proposed UDP Tunnel Transport, UDPTT <a class='info' href='#UDPTT'>[UDPTT]<span> (</span><span class='info'>, &ldquo;The UDP Tunnel Transport mode,&rdquo; Feb&nbsp;2010.</span><span>)</span></a> proposed a method where UDP is modified to
            derive the checksum only from the encapsulating packet protocol
            header. This value does not change between packets in a flow. The
            value may be cached per flow/destination to minimise per-packet
            processing. This proposal is not discussed further in this
            document.
</li>
<li>Use of a new IPv6 Extension Header that provides an end-to-end
            validation check at the network layer. This would allow an
            endpoint to verfiy delivery to an appropriate end point, but would
            also require IPv6 nodes to correctly handle the additional
            header.
</li>
<li>UDP modified to disable checksum processing<a class='info' href='#UDPZ'>[UDPZ]<span> (</span><span class='info'>, &ldquo;UDP Checksums for Tunneled Packets,&rdquo; (Oct&nbsp;2009.</span><span>)</span></a> (if progressed). This requires no checksum
            calculation.
</li>
</ul><p>These options are discussed further in later sections.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Applicability of method</h3>

<p>The expectation of the present proposal to permit omission of UDP
        checksums <a class='info' href='#UDPZ'>[UDPZ]<span> (</span><span class='info'>, &ldquo;UDP Checksums for Tunneled Packets,&rdquo; (Oct&nbsp;2009.</span><span>)</span></a> is that this would apply only to
        IPv6 router nodes that implement specific protocols. However, the
        distinction between a router and a host is not always clear,
        especially at the transport level. Systems (such as unix-based
        operating systems) routinely provide both functions. There is also no
        way to identify the role of a receiver from a received packet.
</p>
<p>Any new method would therefore need a specific applicability
        statement indicating when the mechanism can (and can not) be used.
        There are additional requirements, e.g. fragmentation must not be
        performed, since correct reassembly can not be verified at the
        receiver when there is no checksum. Allowing fragmentation would also
        open the receiver to a wide range of mis-behaviours.
</p>
<p>Host-based fragmentation must therefore be dsiabled. Policing this
        and ensuring correct interactions with the stack implies much more
        than simply disabling the checksum algorithm for specific packets at
        the transport interface. There are also proposals to simply ignore a
        specific received UDP checksum value, however this also can result in
        problems (e.g. when used with a NAT that always adjusts the checksum
        value).
</p>
<p>The IETF should carefully consider constraints on sanctioning the
        use of this mode. If this is specified and widely available, it may be
        expected to be used by applications that are perceived to gain
        benefit. Any solution that uses an end-to-end transport protocol,
        rather than an IP in IP encapsulation, also needs to minimise the
        possibility that end-hosts could confuse a corrupted or wrongly
        delivered packet with that of data addressed to an application running
        on their endpoint.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Effect of packet modification in the network</h3>

<p>IP packets may be corrupted as they traverse an Internet path.
        Evidence has been presented <a class='info' href='#Sigcomm2000'>[Sigcomm2000]<span> (</span><span class='info'>http://conferences.sigcomm.org/sigcomm/2000/conf/abstract/9-1.htm, &ldquo;When the CRC and TCP Checksum Disagree,&rdquo; 2000.</span><span>)</span></a> to show
        that this was once an issue with IPv4 routers, and occasional
        corruption could result from bad internal router processing in routers
        or hosts. These errors are not detected by the strong frame checksums
        employed at the link-layer (RFC 3819). There is no current evidence
        that such cases are rare in the modern Internet, nor that they may not
        be applicable to IPv6. It therefore seems prudent not to relax this
        constraint. The emergence of low-end IPv6 routers and the proposed use
        of NAT with IPv6 further motivate the need to protect from this type
        of error.
</p>
<p>Corruption in the network may result in: </p>
<ul class="text">
<li>A datagram being mis-delivered to the wrong host/router or the
            wrong transport entity within an endpoint. Such a datagram needs
            to be discarded.
</li>
<li>A datagram payload being corrupted, but still delivered to the
            intended host/router transport entity. Such a datagram needs to be
            either discarded or correctly processed by an application that
            provides its own integrity checks.
</li>
<li>A datagram payload being truncated by corruption of the length
            field. Such a datagram needs to be discarded.
</li>
</ul>

<p>When a checksum is used with UDP/IPv6, this significantly reduces
        the impact of errors, reducing the probability of undetected
        corruption of state (and data) on both the host stack and the
        applications using the transport service.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
Corruption of the destination IP address</h3>

<p>An IP endpoint destination address could be modified in the
          network (e.g. corrupted by an error). This is not a concern for
          IPv4, because the IP header checksum will result in this packet
          being discarded by the receiving IP stack. Such modification in the
          network can not be detected when using IPv6.
</p>
<p>There are two possible outcomes:
</p>
<p></p>
<ul class="text">
<li>Delivery to a destination address that is not in use (the
              packet will not be delivered, but could result in an error
              report).
</li>
<li>Delivery to a different destination address. This
              modification will normally be detected by the transport
              checksum, resulting in silent discard. Without this checksum,
              the packet would be passed to the endpoint port demultiplexing
              function. If an application is bound to the associated ports,
              the packet payload will be passed to the application (see the
              subsequent section on port processing).
</li>
</ul>

<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
Corruption of the source IP address</h3>

<p>This section examines what happens when the source address is
          corrupted in transit. (This is not a concern in IPv4, because the IP
          header checksum will result in this packet being discarded by the
          receiving IP stack).
</p>
<p>Corruption of an IPv6 source address does not result in the IP
          packet being delivered to a different endpoint protocol or
          destination address. If only the source address is corrupted, the
          datagram will likely be processed in the intended context, although
          with erroneous origin information. The result will depend on the
          application or protocol that processes the packet. Some examples
          are:
</p>
<p></p>
<ul class="text">
<li>An application that requires pre-established context may
              disregard the datagram as invalid, or could map this to another
              context (if a context for the modified source address was
              already activated).
</li>
<li>A stateless application will process the datagram outside of
              any context, a simple example is the ECHO server, which will
              respond with a datagram directed to the modified source address.
              This would create unwanted additional processing load, and
              generate traffic to the modified endpoint address.
</li>
<li>Some applications build state using the information from
              packet headers. A previously unused source address would result
              in receiver processing and the creation of unnecessary
              transport-layer state at the receiver. For example, RTP flows
              commonly employ a source independent receiver port. State is
              created for each received flow. Reception of a datagram with a
              corrupted source address will therefore result in accumulation
              of unnecessary state in the RTP state machine, including
              collision detection and response (since the same synchronization
              source, SSRC, value will appear to arrive from multiple source
              IP addresses).
</li>
</ul>

<p>In general, the effect of corrupting the source address will
          depend upon the protocol that processes the packet and its
          robustness to this error. For the case where the packet is received
          by a tunnel endpoint, the tunnel application is expected to
          correctly handle a corrupted source address.
</p>
<p>The impact of source address modification is more difficult to
          quantify when the receiving application is not that originally
          intended and several fields have been modified in transit.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3"></a><h3>3.3.3.&nbsp;
Delivery to an unexpected port</h3>

<p>This section considers what happens if one or both of the UDP
          port values are corrupted in transit. (This can also happen with
          IPv4 in the zero checksum case, but not when UDP checksums are
          enabled or with UDP-Lite). If the ports were corrupted in transit,
          packets may be delivered to the wrong process (on the intended
          machine) and/or responses or errors sent to the wrong application
          process (on the intended machine).
</p>
<p>There are several possible outcomes for a packet that passes and
          does not use the UDP checksum validation:
</p>
<p></p>
<ul class="text">
<li>Delivery to a port that is not in use. The packet is
              discarded, but could generate an ICMPv6 message (e.g. port
              unreachable).
</li>
<li>It could be delivered to a different node that implements the
              same application, where the packet may be accepted, generating
              side-effects or accumulated state.
</li>
<li>It could be delivered to an application that does not
              implement the tunnel protocol, where the packet may be
              incorrectly parsed, and may be misinterpreted, generating
              side-effects or accumulated state.
</li>
</ul>

<p>The probability of each outcome depends on the statistical
          probability that the source address and the destination port of the
          datagram (the source port is not always used in UDP) match those of
          an existing connection. Unfortunately, such a match may be more
          likely for UDP than for connection-oriented transports, because</p>
<ol class="text">
<li>There is no handshake prior to communication and no sequence
              numbers (as in TCP, DCCP, or SCTP). Together, this makes it hard
              to verify that an application is given only the data associated
              with a session.
</li>
<li>Applications writers often bind to wild-card values in
              endpoint identifiers and do not always validate correctness of
              datagrams they receive.
</li>
</ol><p>While these ruled could be revised to declare naive
          applications as Historic.This remedy is not realistic - the
          transport owes it to the stack to do its best to reject bogus
          datagrams.
</p>
<p>If checksum coverage is suppressed, the application needs to
          provide a method to detect and discard the unwanted data. The
          encapsulated tunnel protocol would need to perform its own integrity
          checks on any control information and ensure an integrity check is
          applied to the tunneled packet. It is not reasonable to assume that
          it is safe for one application to use a zero checksum value and that
          other applications will not. It is therefore important to consider
          the possibility that a packet will be received by a different node
          to that for which it was intended, or that it will arrive at the
          correct tunnel destination with the wrong source address in the
          external header.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.4"></a><h3>3.3.4.&nbsp;
Validating the network path</h3>

<p>IP transports designed for use in the general Internet should not
          assume specific characteristics. Network protocols may reroute
          packets and change the set of routers and middleboxes along a path.
          Therefore transports such as TCP, SCTP and DCCP are designed to
          negotiate protocol parameters, adapt to different characteristics,
          and receive feedback that the current path is suited to the intended
          application. Applications using UDP and UDP-Lite need to provide
          their own mechanisms to confirm the validity of the current network
          path.
</p>
<p>Any application/tunnel that seeks to make use of zero checksum
          must include functionality to both negotiate and verify that the
          zero checksum support is provided by the path and validate that this
          continues to work (e.g., in the case of re-routing events) between
          the intended parties. This increases the complexity of using such a
          solution.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Comparision</h3>

<p>This section compares different methods to support datagram
        tunneling. This includes a proposal for updating the behaviour of UDP.
        This is provided as an example, and does not seek to endorse any
        specific method or suggest that these proposals are ready to be
        standardised. The final column the expected functions if an additional
        end-to-end IPv6 extension header were to be required in combination
        with use of the zero checksum option.
</p>
<p>Comparison of functions for selected methods
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>                            UDP UDPv4 UDPL IP   IP  UDPv6 UDPv6 UPv6
                                 zero      in   in         zero  EH
                                           IPv4 IPv6

Incremental cksum update?    X    -     X  N/A   N/A  X     -    ?
Verification of IP length?   X    X     X  X     X    X     X    X
Detect dest addr corruption? X    X     X  X     -    X     -    X
Detect NH addr corruption?   -    -     -  X     -    -     -    X
Flow demux fields present?   X    X     X  -     X    X     X    -
Detect port corruption?      X    -     X  N/A   N/A  X     -    -
Detect illegal pay length?   X    X     -  N/A   N/A  X     X    X
Detect pay corruption?       X    -     ?  N/A   N/A  X     -    -
Static cksum per flow?       -    X     -  N/A   N/A  -     X    X
Partial/full midbox support? X    *     ?  ?     ?    X     ?    ?
Restricted tunnel behaviour  X    *     X  X     ?    X     -    -


X   = Provided/supported
-   = Not provided/supported
N/A = Not applicable
?   = Partial support
*   = Supports a subset of functions (i.e. not all combinations)</pre></div>
<p>Table 1
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Requirements on the specification of transported protocols</h3>

<p>If the IETF were to revise the standard for UDP using IPv6 for
      specific use-cases there are a set of questions that would need to be
      answered. These include:
</p>
<p>Is there a reason why IP in IP is not a reasonable choice for
      encapsulation?
</p>
<p></p>
<ul class="text">
<li>Examples of arguments for requiring an encapsulation beyond
          IP-in-IP include the need for NAT traversal and/or firewall
          traversal. However, the use of any new or non-standard transport
          protocol or variant would require specific support in
          middleboxes.
</li>
<li>Another example is a need to perform port-demultiplexing (e.g.
          for load balancing). This need could also be met using UDP,
          UDP-Lite, or another supported transport, or by utilising the IPv6
          flow label.
</li>
</ul>

<p>Is there a reason why UDP-Lite is not a reasonable choice for
      encapsulation?
</p>
<p></p>
<ul class="text">
<li>One argument against using UDP-Lite is that this transport is not
          implemented on all endpoints. However, there is at least one open
          source implementation.
</li>
<li>Another argument against using UDP-Lite is that it uses a
          different IPv6 Next Header, which is currently not widely supported
          in middleboxes (see previous).
</li>
<li>It has also been argued that UDP-Lite requires a checksum
          computation. The UDP-Lite checksum, for instance includes the length
          field, but need not include the UDP-Lite payload, and therefore
          would not require access to the full datagram payload by the tunnel
          endpoints.
</li>
</ul>

<p>If the IETF needs to revise the rationale for UDP checksums in RFC
      2460, should we remove the checksum or replace it with one closer to
      UDP-Lite ?
</p>
<p>Additional topics to be considered in making this decision:</p>
<ul class="text">
<li>The role of a router and host are not fixed, and a consistent
          method must be specified that can be used on all nodes. In IPv6, a
          node selects the role of a router or host on a per interface basis.
          It can not be assumed that a particular protocol (or transport mode)
          will only be used on a specific type of network node (e.g.
          permitting the UDP checksum to be disabled only on a router). It is
          important to note that protocol changes intended for one specific
          use are often re-used for different applications.
</li>
<li>Behaviour of NAT/Middleboxes may need to be updated. This is the
          case for UDP cksum==0 and also for use of an IPv6 Extension Header
          carrying a transport checksum.
</li>
<li>The method needs to consider the impact of load balancing, and
          whether this may be enabled for the chosen transport protocol.
</li>
</ul><p>If a zero checksum approach were to be adopted by the IETF, the
      specification should consider adding the following constraints on
      usage:
</p>
<p></p>
<ol class="text">
<li>A method must be specified to verify the integrity of the inner
          (tunneled) packet.
</li>
<li>Non-IP inner (tunneled) packets must have a CRC or other
          mechanism for checking packet integrity.
</li>
<li>If a method proposes selective ignoring of the checksum on
          reception, it needs to provide guidance that is appropriate for all
          use-cases, including defining how currently standardised nodes
          handle any new use.
</li>
<li>The tunneling protocol must not allow fragmentation of the inner
          packets being carried. We suggest the following elaborations of the
          above restrictions, if a change in the IPv6 specification moves
          forward: That is a tunnel must not forward an inner (tunneled) IPv4
          packet that also has a UDP checksum equal to 0. This includes not
          tunneling other tunneling protocols that also use a UDP checksum
          equal to 0, even if more deeply encapsulated packets have checksums
          or other integrity checking mechanisms.
</li>
<li>Restrictions may be needed to the use of a tunnel encapsulations
          and the use of recursive tunnels (e.g. Necessary when the endpoint
          is not verified).
</li>
<li>General protocol stack implementations should not by default
          allow the new method. The new method should remain restricted to
          endpoints that explicitly enable this mode and adopt the above
          procedures.
</li>
</ol>

<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Summary</h3>

<p>This document examines the role of the transport checksum when used
      with IPv6, as defined in RFC2460.
</p>
<p>It presents a summary of the trade-offs for evaluating the safety of
      updating RFC 2460 to permit an IPv6 UDP endpoint to use a zero value in
      the checksum field to indicate that no checksum is present. A decision
      not to include a UDP checksum in received IPv6 datagrams could impact a
      tunnel application that receives these packets. However, a well-designed
      tunnel application should include consistency checks to validate any
      header information encapsulated with a packet and ensure that a an
      integrity check is included for each tunneled packet. When correctly
      implemented, such a tunnel endpoint will not be negatively impacted by
      omission of the transport-layer checksum. However, other applications at
      the intended destination node or another IPv6 node can be impacted if
      they are allowed to receive datagrams without a transport-layer
      checksum.
</p>
<p>In particular, it is important that already deployed applications are
      not impacted by any change at the transport layer. If these applications
      execute on nodes that implement RFC 2460, they will reject all datagrams
      without a UDP checksum.
</p>
<p>The implications on firewalls, NATs and other middleboxes need to be
      considered. It should not be expected that NATs handle IPv6 UDP
      datagrams in the same way as they handle IPv4 UDP datagrams. Firewalls
      are intended to be configured, and therefore may need to be explicitly
      updated to allow new services or protocols.
</p>
<p>In general, UDP-based applications need to employ a mechanism that
      allows a large percentage of the corrupted packets to be removed before
      they reach an application, both to protect the applications data stream
      and the control plane of higher layer protocols. These checks are
      currently performed by the UDP checksum for IPv6, or the reduced
      checksum for UDP-Lite when used with IPv6.
</p>
<p>Although the use of UDP over IPv6 with no checksum may have merits as
      a tunnel encapsulation and is widely used in IPv4, there are dangers for
      IPv6 nodes (hosts and routers). If the use of UDP transport without a
      checksum were to become prevalent for IPv6 (e.g. tunnel and host
      applications using this are widely deployed), there would also be a
      significant danger of the Internet carrying an increased volume of
      packets without a transport checksum for other applications, potentially
      including applications that have traditionally used IPv4 UDP transport
      without a checksum. This result is highly undesirable. Other solutions
      need to be found, such as the use of IPV6 with the minimal checksum
      coverage for UDP-Lite. This requires that the IPv4 and IPv6 solutions to
      differ, since there are different deployed infrastructures.
</p>
<p>Guidance has also been provided to help evaluate the case for
      disabling the checksum for specific applications
</p>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>Brian Haberman, Brian Carpenter, Magaret Wasserman, Lars Eggert,
      Magnus Westerlund, others in the TSV directorate.
</p>
<p>Thanks also to: R&eacute;mi Denis-Courmont, Pekka Savola and many
      others who contributed comments and ideas via the 6man, behave, lisp and
      mboned lists.
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This document does not require IANA considerations.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>Transport checksums provide the first stage of protection for the
      stack, although they can not be considered authentication mechanisms.
      These checks are also desirable to ensure packet counters correctly log
      actual activity, and can be used to detect unusual behaviours.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC0791">[RFC0791]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>,&rdquo; STD&nbsp;5, RFC&nbsp;791, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc791.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1071">[RFC1071]</a></td>
<td class="author-text">Braden, R., Borman, D., Partridge, C., and W. Plummer, &ldquo;<a href="http://tools.ietf.org/html/rfc1071">Computing the Internet checksum</a>,&rdquo; RFC&nbsp;1071, September&nbsp;1988 (<a href="http://www.rfc-editor.org/rfc/rfc1071.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2460">[RFC2460]</a></td>
<td class="author-text"><a href="mailto:deering@cisco.com">Deering, S.</a> and <a href="mailto:hinden@iprg.nokia.com">R. Hinden</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>,&rdquo; RFC&nbsp;2460, December&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2460.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2460.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2460.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="AMT">[AMT]</a></td>
<td class="author-text">Internet draft,
            draft-ietf-mboned-auto-multicast-10, &ldquo;Automatic IP Multicast Without Explicit Tunnels (AMT),&rdquo; March&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="ECMP">[ECMP]</a></td>
<td class="author-text">&ldquo;Using the IPv6 flow label for equal cost multipath routing in
          tunnels (draft-carpenter-flow-ecmp).&rdquo;</td></tr>
<tr><td class="author-text" valign="top"><a name="LISP">[LISP]</a></td>
<td class="author-text">Internet draft,
            draft-farinacci-lisp-12.txt, &ldquo;Locator/ID Separation Protocol (LISP),&rdquo; March&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0768">[RFC0768]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>,&rdquo; STD&nbsp;6, RFC&nbsp;768, August&nbsp;1980 (<a href="http://www.rfc-editor.org/rfc/rfc768.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1141">[RFC1141]</a></td>
<td class="author-text"><a href="mailto:tmallory@CCV.BBN.COM">Mallory, T.</a> and <a href="mailto:akullberg@BBN.COM">A. Kullberg</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1141">Incremental updating of the Internet checksum</a>,&rdquo; RFC&nbsp;1141, January&nbsp;1990 (<a href="http://www.rfc-editor.org/rfc/rfc1141.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2765">[RFC2765]</a></td>
<td class="author-text"><a href="mailto:nordmark@sun.com">Nordmark, E.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2765">Stateless IP/ICMP Translation Algorithm (SIIT)</a>,&rdquo; RFC&nbsp;2765, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2765.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3828">[RFC3828]</a></td>
<td class="author-text">Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and G. Fairhurst, &ldquo;<a href="http://tools.ietf.org/html/rfc3828">The Lightweight User Datagram Protocol (UDP-Lite)</a>,&rdquo; RFC&nbsp;3828, July&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3828.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4302">[RFC4302]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>,&rdquo; RFC&nbsp;4302, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4302.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5405">[RFC5405]</a></td>
<td class="author-text">Eggert, L. and G. Fairhurst, &ldquo;<a href="http://tools.ietf.org/html/rfc5405">Unicast UDP Usage Guidelines for Application Designers</a>,&rdquo; BCP&nbsp;145, RFC&nbsp;5405, November&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5405.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Sigcomm2000">[Sigcomm2000]</a></td>
<td class="author-text">http://conferences.sigcomm.org/sigcomm/2000/conf/abstract/9-1.htm, &ldquo;When the CRC and TCP Checksum Disagree,&rdquo; 2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="UDPTT">[UDPTT]</a></td>
<td class="author-text">&ldquo;The UDP Tunnel Transport mode,&rdquo; Feb&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="UDPZ">[UDPZ]</a></td>
<td class="author-text">&ldquo;UDP Checksums for Tunneled Packets,&rdquo; (Oct&nbsp;2009.</td></tr>
</table>

<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Document Change History</h3>

<p>{RFC EDITOR NOTE: This section must be deleted prior to
      publication}
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Individual Draft 00 </dt>
<dd>This is the first DRAFT of this
          document - It contains a compilation of various discussions and
          contributions from a variety of IETF WGs, including: mboned, tsv,
          6man, lisp, and behave. This includes contributions from Magnus with
          text on RTP, and various updates.
</dd>
<dt>Individual Draft 01</dt>
<dd>
<ul class="text">
<li>This version corrects some typos and editorial NiTs and adds
              discussion of the need to negotiate and verify operation of a
              new mechanism (3.3.4).
</li>
</ul>
</dd>
<dt>Individual Draft 02</dt>
<dd>
<ul class="text">
<li>Version -02 corrects some typos and editorial NiTs.
</li>
<li>Added reference to ECMP for tunnels.
</li>
<li>Clarifies the recommendations at the end of the document.
</li>
<li>
</li>
</ul>
</dd>
<dt>Working Group Draft 00</dt>
<dd>
<ul class="text">
<li>Working Group Version -00 corrects some typos and removes
              much of rationale for UDPTT. It also adds some discussion of
              IPv6 extension header
</li>
</ul>
</dd>
</dl></blockquote>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Godred Fairhurst</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of Aberdeen</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">School of Engineering</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Aberdeen, AB24 3UE,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Scotland, UK</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.erg.abdn.ac.uk/users/gorry">http://www.erg.abdn.ac.uk/users/gorry</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Magnus Westerlund</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ericsson Research</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Torshamgatan 23</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stockholm,   SE-164 80</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sweden</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:magnus.westerlund@ericsson.com">magnus.westerlund@ericsson.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
</table>
</body></html>
