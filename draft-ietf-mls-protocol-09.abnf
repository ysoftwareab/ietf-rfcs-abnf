key_pair_secret = HKDF-Expand-Label(path_secret, "key pair",
                                       "", KeyPairSecretLength)

ciphertext = context.Seal(group_context, path_secret)

sender_data_key =
       HKDF-Expand-Label(sender_data_secret, "sd key", "", key_length)

welcome_secret = HKDF-Expand(epoch_secret, "mls 1.0 welcome", Hash.length)
welcome_nonce = HKDF-Expand(welcome_secret, "nonce", nonce_length)
welcome_key = HKDF-Expand(welcome_secret, "key", key_length)

   o  Verify the signature on the GroupInfo object.  The signature input
      comprises all of the fields in the GroupInfo object except the
      signature field.  The public key and algorithm are taken from the
      credential in the leaf node at position "signer_index".  If this
      verification fails, return an error.

   o  Verify the integrity of the ratchet tree.

      *  For each non-empty parent node, verify that exactly one of the
         node's children are non-empty and have the hash of this node
         set as their "parent_hash" value (if the child is another
         parent) or has a "parent_hash" extension in the KeyPackage
         containing the same value (if the child is a leaf).

      *  For each non-empty leaf node, verify the signature on the
         KeyPackage.

   o  Identify a leaf in the "tree" array (any even-numbered node) whose
      "key_package" field is identical to the the KeyPackage.  If no
      such field exists, return an error.  Let "index" represent the
      index of this node among the leaves in the tree, namely the index
      of the node in the "tree" array divided by two.

   o  Construct a new group state using the information in the GroupInfo
      object.  The new member's position in the tree is "index", as
      defined above.  In particular, the confirmed transcript hash for
      the new state is the "prior_confirmed_transcript_hash" in the
      GroupInfo object.

      *  Update the leaf at index "index" with the private key
         corresponding to the public key in the node.

      *  Identify the lowest common ancestor of the leaves at "index"
         and at "GroupInfo.signer_index".  Set the private key for this
         node to the private key derived from the "path_secret" in the
         KeyPackage object.

      *  For each parent of the common ancestor, up to the root of the
         tree, derive a new path secret and set the private key for the
         node to the private key derived from the path secret.  The
         private key MUST be the private key that corresponds to the
         public key in the node.

   o  Use the "epoch_secret" from the KeyPackage object to generate the
      epoch secret and other derived secrets for the current epoch.

   o  Set the confirmed transcript hash in the new state to the value of
      the "confirmed_transcript_hash" in the GroupInfo.

   o  Verify the confirmation MAC in the GroupInfo using the derived
      confirmation key and the "confirmed_transcript_hash" from the
      GroupInfo.

parent=01x => left=00x, right=10x

k = 0
k = 0
w = node_width(n)
k = level(x)
k = level(x)
r = x ^ (0x03 << (k - 1))
r = left(r)
k = level(x)
b = (x >> (k + 1)) & 0x01
p = parent_step(x)
p = parent_step(p)
p = parent(x, n)
d = []
p = parent(x, n)
r = root(n)
p = parent(p, n)
d = dirpath(x, n)
k = 0
