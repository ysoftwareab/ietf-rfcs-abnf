<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Internationalization for the NFSv4 Protocols</title>
<meta content="David Noveck" name="author">
<meta content="
       
        This document describes the handling of internationalization
 for all NFSv4 protocols, including NFSv4.0,
 NFSv4.1,
 NFSv4.2 
 and extensions thereof, and future minor versions.
       
       
 It updates RFC7530 and RFC8881.
       
    " name="description">
<meta content="xml2rfc 3.10.0" name="generator">
<meta content="draft-ietf-nfsv4-internationalization-01" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.10.0
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.2
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.6.3
    pycountry 20.7.3
    pyflakes 2.3.1
    PyYAML 5.4.1
    requests 2.26.0
    setuptools 58.0.4
    six 1.16.0
-->
<link href="/tmp/draft-ietf-nfsv4-internationalization-01-fmh5vwgi.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">NFSv4 Internationalization</td>
<td class="right">September 2021</td>
</tr></thead>
<tfoot><tr>
<td class="left">Noveck</td>
<td class="center">Expires 30 March 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">NFSv4</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-nfsv4-internationalization-01</dd>
<dt class="label-updates">Updates:</dt>
<dd class="updates">
<a href="https://www.rfc-editor.org/rfc/rfc8881" class="eref">8881</a>, <a href="https://www.rfc-editor.org/rfc/rfc7530" class="eref">7530</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2021-09-26" class="published">26 September 2021</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-03-30">30 March 2022</time></dd>
<dt class="label-authors">Author:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">D. Noveck</div>
<div class="org">NetApp</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Internationalization for the NFSv4 Protocols</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">
        This document describes the handling of internationalization
 for all NFSv4 protocols, including NFSv4.0,
 NFSv4.1,
 NFSv4.2 
 and extensions thereof, and future minor versions.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
<p id="section-abstract-2">
 It updates RFC7530 and RFC8881.<a href="#section-abstract-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 30 March 2022.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-requirements-language" class="xref">Requirements Language</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1" class="keepWithNext"><a href="#section-2.1" class="xref">2.1</a>.  <a href="#name-requirements-language-defin" class="xref">Requirements Language Definition</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1" class="keepWithNext"><a href="#section-2.2" class="xref">2.2</a>.  <a href="#name-requirements-language-deriv" class="xref">Requirements Language Derivation</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-internationalization-and-mi" class="xref">Internationalization and Minor Versioning</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-changes-relative-to-rfc7530" class="xref">Changes Relative to RFC7530</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-limitations-on-internationa" class="xref">Limitations on Internationalization-Related Processing in the NFSv4 Context</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-summary-of-server-behavior-" class="xref">Summary of Server Behavior Types</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-the-attribute-fs_charset_ca" class="xref">The Attribute Fs_charset_cap</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-the-attribute-fs_charset_cap" class="xref">The Attribute Fs_charset_cap in Published NFSv4.1 Specifications</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-the-attribute-fs_charset_cap-" class="xref">The Attribute Fs_charset_cap in Future NFSv4.1 Specifications</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-string-encoding" class="xref">String Encoding</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-normalization" class="xref">Normalization</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-case-insensitive-processing" class="xref">Case-Insensitive Processing of File Names</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="xref">10.1</a>.  <a href="#name-implementing-case-insensiti" class="xref">Implementing Case-Insensitive Comparison of File Names</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="xref">10.2</a>.  <a href="#name-important-examples-of-case-" class="xref">Important Examples of Case-insensitive Handling of File Names</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-internationalization-relate" class="xref">Internationalization-related Processing of File Names by Clients</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="xref">11.1</a>.  <a href="#name-server-restrictions-to-deal" class="xref">Server Restrictions to Deal with Lack of Client Knowledge</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="xref">11.2</a>.  <a href="#name-client-processing-of-file-n" class="xref">Client Processing of File Names for Current NFSv4 Protocols</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.3">
                <p id="section-toc.1-1.11.2.3.1"><a href="#section-11.3" class="xref">11.3</a>.  <a href="#name-client-processing-of-file-na" class="xref">Client Processing of File Names for Future NFSv4 Protocols</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="xref">12</a>. <a href="#name-string-types-with-processin" class="xref">String Types with Processing Defined by Other Internet Areas</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="xref">12.1</a>.  <a href="#name-effect-of-idna-changes" class="xref">Effect of IDNA Changes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="xref">12.2</a>.  <a href="#name-potential-compatibility-iss" class="xref">Potential Compatibility Issues Related to IDNA Changes</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="xref">13</a>. <a href="#name-errors-related-to-utf-8" class="xref">Errors Related to UTF-8</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-14" class="xref">14</a>. <a href="#name-servers-that-accept-file-co" class="xref">Servers That Accept File Component Names That Are Not Valid UTF-8 Strings</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-15" class="xref">15</a>. <a href="#name-future-minor-versions-and-e" class="xref">Future Minor Versions and Extensions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#section-16" class="xref">16</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#section-17" class="xref">17</a>. <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#section-18" class="xref">18</a>. <a href="#name-references" class="xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.18.2.1">
                <p id="section-toc.1-1.18.2.1.1"><a href="#section-18.1" class="xref">18.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.18.2.2">
                <p id="section-toc.1-1.18.2.2.1"><a href="#section-18.2" class="xref">18.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.19">
            <p id="section-toc.1-1.19.1"><a href="#appendix-A" class="xref">Appendix A</a>.  <a href="#name-history" class="xref">History</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20">
            <p id="section-toc.1-1.20.1"><a href="#appendix-B" class="xref">Appendix B</a>.  <a href="#name-form-insensitive-string-com" class="xref">Form-insensitive String Comparisons</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.1">
                <p id="section-toc.1-1.20.2.1.1"><a href="#appendix-B.1" class="xref">B.1</a>.  <a href="#name-name-hashes" class="xref">Name Hashes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.2">
                <p id="section-toc.1-1.20.2.2.1"><a href="#appendix-B.2" class="xref">B.2</a>.  <a href="#name-character-tables" class="xref">Character Tables</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.3">
                <p id="section-toc.1-1.20.2.3.1"><a href="#appendix-B.3" class="xref">B.3</a>.  <a href="#name-outline-of-comparison" class="xref">Outline of comparison</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.4">
                <p id="section-toc.1-1.20.2.4.1"><a href="#appendix-B.4" class="xref">B.4</a>.  <a href="#name-comparing-base-characters" class="xref">Comparing Base Characters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.5">
                <p id="section-toc.1-1.20.2.5.1"><a href="#appendix-B.5" class="xref">B.5</a>.  <a href="#name-comparing-combining-charact" class="xref">Comparing Combining Characters</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.21">
            <p id="section-toc.1-1.21.1"><a href="#appendix-C" class="xref"></a><a href="#name-acknowledgements" class="xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.22">
            <p id="section-toc.1-1.22.1"><a href="#appendix-D" class="xref"></a><a href="#name-authors-address" class="xref">Author's Address</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="INTRO">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">
      Internationalization is a complex topic with its own set of
      terminology (see <span>[<a href="#RFC6365" class="xref">22</a>]</span>).  The topic is
      made more complex for the NFSv4 protocols by the tangled history
      described in
      <a href="#HIST" class="xref">Appendix A</a>.   In large part, this document is based on the
      actual behavior of NFSv4 client and server implementations
      (for all existing minor versions) and is intended to serve as a basis
      for further implementations to be developed that can interact
      with existing implementations as well as those to be developed
      in the future.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">
      Note that the behaviors on which this document are based are each
      demonstrated by a
      combination of an NFSv4 server implementation proper and a
      server-side physical file system. It is common for servers
      and physical file systems to be configurable as to the behavior shown.
      In the discussion below, each configuration that shows different
      behavior is considered separately.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">
      As a consequence of this choice, normative terms defined
      in RFC2119 <span>[<a href="#RFC2119" class="xref">1</a>]</span> are often derived from implementation
      behavior, rather than the other way around, as is more commonly
      the case.  The specifics
      are discussed in <a href="#TERM" class="xref">Section 2</a>.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">
      With regard to the question of interoperability with existing
      specifications for NFSv4 minor versions, different minor versions
      pose different issues.<a href="#section-1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1-5.1">
          <p id="section-1-5.1.1">
 With regard to NFSv4.0 as defined in RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>,
 no significant interoperability
 issues are expected to arise because the internationalization in that
 specification, which is the basis for this one, was also based
        on the behavior of existing implementations.   Although, in a
 formal sense, the treatment of internationalization here supersedes
 that in RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>, the treatments are intended to
 be essentially the same, in order to eliminate interoperability issues.<a href="#section-1-5.1.1" class="pilcrow">¶</a></p>
<p id="section-1-5.1.2">
        Because of a change in the handling of Internationalized domain names,
        there are some differences from the handling in RFC7530
 <span>[<a href="#RFC7530" class="xref">3</a>]</span>, as discussed in <a href="#HIST" class="xref">Appendix A</a>.
 For a discussion of those differences and potential compatibility
 issues, see Sections <a href="#OTHER-idna" class="xref">12.1</a> and
 <a href="#OTHER-compat" class="xref">12.2</a>.<a href="#section-1-5.1.2" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-5.2">
          <p id="section-1-5.2.1">
 With regard to NFSv4.1 as defined by RFC881 <span>[<a href="#RFC8881" class="xref">9</a>]</span>,
 the situation is
 quite different.   The approach to internationalization specified
 in that document, based in large part on that in RFC3530
 was never implemented, and implementers were either
 unaware of the troublesome implications of that approach or
 chose to ignore the existing specification as essentially
 unimplementable.  An
 internationalization
 approach compatible with that specified in
 RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>
 tended to be followed,
 despite the fact that, in other respects, NFSv4.1 was considered to be
 a separate protocol.<a href="#section-1-5.2.1" class="pilcrow">¶</a></p>
<p id="section-1-5.2.2">
        If there were NFSv4 servers who obeyed the internationalization
        dictates
        within RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span>, or clients that
 expected servers to
 do so, they would fail to interoperate with typical clients and servers
 when dealing with non-UTF8 file names, which are quite common.  As
 no such implementations have come to our attention, it has to be assumed
 that they do not exist and interoperability with existing
 implementations as described here is an appropriate basis for
 this document.<a href="#section-1-5.2.2" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="TERM">
<section id="section-2">
      <h2 id="name-requirements-language">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-requirements-language" class="section-name selfRef">Requirements Language</a>
      </h2>
<div id="TERM-req">
<section id="section-2.1">
        <h3 id="name-requirements-language-defin">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-requirements-language-defin" class="section-name selfRef">Requirements Language Definition</a>
        </h3>
<p id="section-2.1-1">
        The key words "MUST", "MUST NOT",
        "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be
        interpreted as BCP 14 <span>[<a href="#RFC2119" class="xref">1</a>]</span>
          <span>[<a href="#RFC8174" class="xref">2</a>]</span> when, and only when,
        they appear in all capitals, as shown here.<a href="#section-2.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="TERM-derivation">
<section id="section-2.2">
        <h3 id="name-requirements-language-deriv">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-requirements-language-deriv" class="section-name selfRef">Requirements Language Derivation</a>
        </h3>
<p id="section-2.2-1">
        Although the key words "MUST", "SHOULD", and
        "MAY" retain their normal meanings, as described above,  we need
 to explain how the statements involving these terms were arrived at:<a href="#section-2.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.2-2.1"> 
   In the case of statements within Sections
   <a href="#OTHER" class="xref">12</a> and
   <a href="#FUTURE" class="xref">15</a>, these
   derive from the requirements of other internet specifications.<a href="#section-2.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-2.2-2.2">
   In the case of statements within Sections
   <a href="#CHARSET" class="xref">7</a>, 
   <a href="#CASEI" class="xref">10</a>, and
   <a href="#CLIENT" class="xref">11</a>
   derive from the author's view of the appropriate normative
   language to use and will, when this document is advanced,
   represent the working group's consensus on those same matters.<a href="#section-2.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-2.2-2.3">
   However, in
   other cases, i.e. those in sections deriving from
   RFC7530
   <span>[<a href="#RFC7530" class="xref">3</a>]</span> (i.e. Sections
   <a href="#LIMITS" class="xref">5</a>,
   <a href="#SERVTYPES" class="xref">6</a>,
   <a href="#ENCODE" class="xref">8</a>,
   <a href="#NORM" class="xref">9</a>,
   <a href="#UTF8ERR" class="xref">13</a>,
   <a href="#NONVALID" class="xref">14</a>,
   <a href="#IANA" class="xref">16</a>,
   <a href="#SEC" class="xref">17</a>)
          this specification's descriptions were
   derived from existing
   implementation patterns.  Although this pattern is atypical,
   it is needed to provide a description that satisfies the goal
   of RFC2119 <span>[<a href="#RFC2119" class="xref">1</a>]</span>, providing a normative
   description to enable future implementations to be compatible
   with existing ones.
          This requires that we explain later in this section how the normative
   terms used derive from
          the behavior of existing implementations, in those situations
   in which
          existing implementation behavior patterns can be determined.<a href="#section-2.2-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-2.2-3">
 Note that in introductory and explanatory sections of this document
 (i.e. Sections <a href="#INTRO" class="xref">1</a> through
 <a href="#CHG7530" class="xref">4</a> these terms do not appear
 except to explain how they are used in this document.  Also,
 they do not appear in <a href="#FORMI" class="xref">Appendix B</a> which provides
 non-normative implementation guidance.<a href="#section-2.2-3" class="pilcrow">¶</a></p>
<p id="section-2.2-4">
 With regard to the parts of this document deriving from RFC7530,
 we explain below how the normative
   terms used derive from
          the behavior of existing implementations, in those situations
   in which
          existing implementation behavior patterns can be determined.<a href="#section-2.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.2-5.1">
            <p id="section-2.2-5.1.1">
            Behavior implemented by all existing clients or servers is described
            using "MUST", since new implementations need to follow existing
            ones to be assured of interoperability.  While it is possible that
            different behavior might be workable, we have found no case where
            this seems reasonable.<a href="#section-2.2-5.1.1" class="pilcrow">¶</a></p>
<p id="section-2.2-5.1.2">
            The converse holds for "MUST NOT": if a type of behavior poses
            interoperability problems, it MUST NOT be implemented by any
            existing clients or servers.<a href="#section-2.2-5.1.2" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-5.2">
            <p id="section-2.2-5.2.1">
            Behavior implemented by most existing clients or servers, where
            that behavior is more desirable than any alternative, is described
            using "SHOULD", since new implementations need to follow that
            existing practice unless there are strong reasons to do otherwise.<a href="#section-2.2-5.2.1" class="pilcrow">¶</a></p>
<p id="section-2.2-5.2.2">
            The converse holds for "SHOULD NOT".<a href="#section-2.2-5.2.2" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.2-5.3">
            Behavior implemented by some, but not all, existing clients or
            servers is described using "MAY", indicating that new
            implementations have a choice as to whether they will behave
            in that way.  Thus, new implementations will have the same
            flexibility that existing ones do.<a href="#section-2.2-5.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-2.2-5.4">
            Behavior implemented by all existing clients or servers, so far
            as is known -- but where there remains some uncertainty as to
            details -- is described using "should".  Such cases primarily
            concern details of error returns.  New implementations should
            follow existing practice even though such situations generally
            do not affect interoperability.<a href="#section-2.2-5.4" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-2.2-6">
        There are also cases in which certain server behaviors, while
        not known to exist, cannot be reliably determined not to
        exist.  In part, this is a consequence of the long period of
        time that has elapsed since the publication of
        the defining specifications,
        resulting in a situation in which those involved in the
        implementation work may no longer be involved in or be
 aware of working group activities.<a href="#section-2.2-6" class="pilcrow">¶</a></p>
<p id="section-2.2-7">
        In the case of possible server behavior that is neither known
        to exist nor known not to exist, we use "SHOULD NOT" and
        "MUST NOT" as follows, and similarly for "SHOULD" and "MUST".<a href="#section-2.2-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.2-8.1">
            In some cases, the potential behavior is not known to exist but is
            of such a nature that, if it were in fact implemented,
            interoperability difficulties would be expected and reported,
            giving us cause to conclude that the potential behavior is not
            implemented.  For such behavior, we use "MUST NOT".
            Similarly, we use "MUST" to apply to the contrary behavior.<a href="#section-2.2-8.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-2.2-8.2">
            In other cases, potential behavior is not known to exist but the
            behavior, while undesirable, is not of such a nature that we are
            able to draw any conclusions about its potential existence.  In
            such cases, we use "SHOULD NOT". Similarly, we use "SHOULD"
            to apply to the contrary behavior.<a href="#section-2.2-8.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-2.2-9">
        In the case of a "MAY", "SHOULD", or "SHOULD NOT" that applies to
        servers, clients need to be aware that there are servers that
        may or may not take the specified action, and they need to
        be prepared for either eventuality.<a href="#section-2.2-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="MINOR">
<section id="section-3">
      <h2 id="name-internationalization-and-mi">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-internationalization-and-mi" class="section-name selfRef">Internationalization and Minor Versioning</a>
      </h2>
<p id="section-3-1">
      Despite the fact that NFSv4.0 and subsequent minor versions
      have differed in many ways, the actual implementations of
      internationalization have 
      remained the same and internationalized names have been handled
      without regard to the minor version being used. Minor version
      specification documents contained different treatments of
      internationalization as described in <a href="#HIST" class="xref">Appendix A</a> but of those
      only the implementation-based approach used by RFC7530
      <span>[<a href="#RFC7530" class="xref">3</a>]</span>, resulted in a workable description while
      a number of attempts to specify an approach that implementors
      were to follow were all ignored.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">
      It is expected that any future minor versions will follow a similar
      approach, even though there is nothing to prevent a future minor
      version from adopting a different approach as long as the rules
      within <span>[<a href="#RFC8178" class="xref">8</a>]</span>) are adhered to.   In any such case,
      the new minor version would have to be marked as updating or obsoleting
      this document.   Issues relating to potential extensions within the
      framework specified in this document are dealt with in
      <a href="#FUTURE" class="xref">Section 15</a>.<a href="#section-3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="CHG7530">
<section id="section-4">
      <h2 id="name-changes-relative-to-rfc7530">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-changes-relative-to-rfc7530" class="section-name selfRef">Changes Relative to RFC7530</a>
      </h2>
<p id="section-4-1">
      This document follows the internationalization approach defined
      in RFC7530, with a number of significant necessary changes.<a href="#section-4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-2.1">
 The handling of internationalization specified in
 <span>[<a href="#RFC7530" class="xref">3</a>]</span> is applied to all NFSv4 minor versions.
 No compatibility issues are expected to arise because all
 existing implementations follow the same approach to
 internationalization despite the large difference between
 <span>[<a href="#RFC7530" class="xref">3</a>]</span> and what was specified in
 <span>[<a href="#RFC5661" class="xref">21</a>]</span>. Issues
        relating to potential future minor versions
        and protocol extensions are addressed in <a href="#FUTURE" class="xref">Section 15</a>.<a href="#section-4-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-2.2">
        Some changes motivated by the shift from IDNA2003 to IDNA2008
 have been made. The
        intention is to maintain
        compatibility with all existing NFSv4 minor
        versions.   Potential compatibility issues with regard to the IDNA
        shift are discussed in <a href="#OTHER-compat" class="xref">Section 12.2</a>.<a href="#section-4-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-2.3">
 There is more detailed discussion of case-insensitive handling
 of file names, with particular attention to the complexities
 that can arise when multiple language conventions in these matters
 need to be accommodated.  The discussion in
 <a href="#CASEI" class="xref">Section 10</a> applies to both client or server, although
 issues relating to the client's knowledge are dealt with in
 <a href="#CLIENT" class="xref">Section 11</a>.<a href="#section-4-2.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-4-2.4">
 There is additional material, dealing with the implications of
 server-side internationalization-related file name processing for
 clients that cache the results of READDIR's.  This
 includes a discussion of options to deal with the current lack of
 detailed information about the server (in <a href="#CLIENT-now" class="xref">Section 11.2</a>),
 and options for handling when more detailed information is available
 (in <a href="#CLIENT-future" class="xref">Section 11.3</a>)."<a href="#section-4-2.4" class="pilcrow">¶</a>
</li>
      </ul>
</section>
</div>
<div id="LIMITS">
<section id="section-5">
      <h2 id="name-limitations-on-internationa">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-limitations-on-internationa" class="section-name selfRef">Limitations on Internationalization-Related Processing in the NFSv4 Context</a>
      </h2>
<p id="section-5-1">
      There are a number of noteworthy circumstances that limit the degree
      to which internationalization-related encoding and normalization-
      related restrictions can be made universal
      with regard to NFSv4 clients and servers:<a href="#section-5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-2.1">
          The NFSv4 client is part of an extensive set of client-side software
          components whose design and internal interfaces are not within the
          IETF's purview, limiting the degree to which a particular character
          encoding might be made standard.<a href="#section-5-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-5-2.2">
          Server-side handling of file component names is typically
          implemented within a server-side physical file system, whose
          handling of character encoding and normalization is not
   specifiable by the IETF.<a href="#section-5-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-5-2.3">
          Typical implementation patterns in UNIX systems result in the
          NFSv4 client having no knowledge of the character encoding being
          used, which might even vary between processes on the same client
          system.<a href="#section-5-2.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-5-2.4">
          Users may need access to files stored previously with non-UTF-8
          encodings, or with UTF-8 encodings that are not in accord with any
   particular normalization form.<a href="#section-5-2.4" class="pilcrow">¶</a>
</li>
      </ul>
</section>
</div>
<div id="SERVTYPES">
<section id="section-6">
      <h2 id="name-summary-of-server-behavior-">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-summary-of-server-behavior-" class="section-name selfRef">Summary of Server Behavior Types</a>
      </h2>
<p id="section-6-1">
      Servers MAY
      reject component name strings that are not valid UTF-8.  This
      leads to a number of types of valid server behavior, as
      outlined below.  When these are combined with
      the valid normalization-related behaviors as described in
      <a href="#ENCODE" class="xref">Section 8</a>,
      this leads to the combined behaviors outlined below.<a href="#section-6-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6-2.1">
          Servers that limit file component names within
   a given file system to UTF-8
          strings exist with normalization-related
          handling as described
          in <a href="#ENCODE" class="xref">Section 8</a>.  These are best
          described as behaving as "UTF-8-only servers".<a href="#section-6-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-6-2.2">
          Servers that do not limit file component names on particular
   file systems to UTF-8
          strings are very common and are necessary to deal with
          clients/applications not oriented to the use of UTF-8.
          Such servers ignore normalization-related issues, and there
          is no way for them to implement either normalization or
          representation-independent lookups.  These are best
          described as behaving as  "UTF-8-unaware servers" for such
   file systems, since they treat
          file component names as uninterpreted strings of bytes
          and have no knowledge of the characters represented.
          See <a href="#UTF8ERR" class="xref">Section 13</a> for details.<a href="#section-6-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-6-2.3">
          It is possible for a server to allow component names that
          are not valid UTF-8, while still being aware of the
          structure of UTF-8 strings.  Such servers could, in theory,
   implement
          either normalization or representation-independent lookups
          but apply those techniques only to valid UTF-8 strings.
          Such servers are not common, but it is possible to configure at
          least one known server to have this behavior.  This behavior
          SHOULD NOT be used due to the possibility that a file name
          using one encoding may, by coincidence, have the appearance
          of a UTF-8 file name; the results of UTF-8 normalization or
          representation-independent lookups are unlikely to be correct
          in all cases, when considered from the viewpoint of the other
   encoding.  Such difficulties can be compounded when case-insensitive
   name handling is in effect.<a href="#section-6-2.3" class="pilcrow">¶</a>
</li>
      </ul>
</section>
</div>
<div id="CHARSET">
<section id="section-7">
      <h2 id="name-the-attribute-fs_charset_ca">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-the-attribute-fs_charset_ca" class="section-name selfRef">The Attribute Fs_charset_cap</a>
      </h2>
<p id="section-7-1">
      This attribute, nominally "RECOMMENDED", appears to have been
      added to NFSv4.1 to allow servers, while staying within the
      constraints of the stringprep-based specification of
      internationalization, to allow uses of UTF-8-unaware naming
      by clients.  As a result, those NFSv4 servers implementing
      internationalization as NFSv3 had done, could be considered
      spec-compliant, as long as a later "SHOULD" was ignored.  However,
      because use of UTF-8 was tied to existing stringprep
      restrictions, implementations of internationalization, that
      were aware of Unicode canonical equivalence issues were not
      provided for.  Although this attribute may have been implemented
      despite the problems noted in <a href="#CHARSET-past" class="xref">Section 7.1</a>, the
      overall scheme was never implemented and NFSv4.1 implementations
      dealt with internationalization as NFSv4.0 implementations had.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">
      It is generally accepted that attributes designated
      "RECOMMENDED" are essentially OPTIONAL with the client having the
      responsibility to deal with server non-support of them.  While
      RFC7530 has gone so far as to explicitly exclude this use from the
      general statement that these terms are to be used as defined by RFC2119,
      no NFSv4.1 specification has done so, at least through RFC8881
      <span>[<a href="#RFC8881" class="xref">9</a>]</span>.  In this particular case, there are a
      number of circumstances that makes this OPTIONAL status noteworthy:<a href="#section-7-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-3.1">
 The statement "It is expected that
        servers will support all attributes they comfortably can and only
        fail to support attributes that are difficult to support in their
        operating environments", appearing in Section 5.2 of
 <span>[<a href="#RFC8881" class="xref">9</a>]</span> is troublesome since it is hard to
 understand how a server could find this read-only attribute
 "difficult to support" regardless of the operating environment<a href="#section-7-3.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-7-3.2">
 This was added in minor version one which added a number of
 REQUIRED operations and could well have added a REQUIRED attribute.<a href="#section-7-3.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-7-3.3">
 The fact that the client is to be prepared for non-support of the
 attribute would require specification of a default value, yet none
 is provided.<a href="#section-7-3.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-7-4">
      The attribute contains two flag bits. As discussed below,
      in <a href="#CHARSET-past" class="xref">Section 7.1</a>, it is hard two see why two bits are
      required while the implications of this issue for future NFSv4.1
      specifications will be discussed in <a href="#CHARSET-future" class="xref">Section 7.2</a><a href="#section-7-4" class="pilcrow">¶</a></p>
<div id="CHARSET-past">
<section id="section-7.1">
        <h3 id="name-the-attribute-fs_charset_cap">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-the-attribute-fs_charset_cap" class="section-name selfRef">The Attribute Fs_charset_cap in Published NFSv4.1 Specifications</a>
        </h3>
<p id="section-7.1-1">
 We reproduce Section 14.4 of <span>[<a href="#RFC8881" class="xref">9</a>]</span> below, with
 comments interspersed trying to make sense of what is there, in
 order to arrive at an appropriate replacement, to be presented in
 <a href="#CHARSET-future" class="xref">Section 7.2</a>.   In that connection, we need to
 understand better a few issues:<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.1">
   The use of  two bits while one is clearly adequate, given the
   subject matter actually mentioned.<a href="#section-7.1-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.1-2.2">
   The mention of possible "capabilities" which could not possibly be
   realized.<a href="#section-7.1-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.1-2.3">
   The use of the RFC2119 keyword "SHOULD" in contexts in which
   this term is clearly inappropriate.<a href="#section-7.1-2.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-3">
 Issues related to the confusion caused by mention of "UTF-8 characters"
 and the lack of mention of Unicode will be addressed in the 
 revision in <a href="#CHARSET-future" class="xref">Section 7.2</a> but will not be
 further discussed here.<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.1-4">
<pre>

   const FSCHARSET_CAP4_CONTAINS_NON_UTF8  = 0x1;
   const FSCHARSET_CAP4_ALLOWS_ONLY_UTF8   = 0x2;

   typedef uint32_t        fs_charset_cap4;
</pre><a href="#section-7.1-4" class="pilcrow">¶</a>
</div>
<p id="section-7.1-5">
 While it is made clear that two separate bits are to be provided, their
 names seem to indicate that they should be complements of
 one another.  As a way of understanding why two bits were specified,
 it is helpful to consider a possible boolean attribute as a
 potential replacement.   That attribute would clearly govern
 whether names that do not conform to the rules of UTF-8 are to
 be rejected, which was a "MUST" in RFC3530 <span>[<a href="#RFC3530" class="xref">20</a>]</span>.
 Although conveying this information is clearly part of the
 motivation, stating so clearly might have been judged by the
 authors as unnecessarily provocative, given the role of IESG in arriving
 at the internationalization approach specified in RFC3530.<a href="#section-7.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-6.1">   
          Because some operating environments and file systems do not
   enforce character set encodings,<a href="#section-7.1-6.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-7">
        It is clear that the ability of operating environments to enforce
 use of UTF-8 encoding is not an issue, since RFC3530 made this the
 responsibility of the server implementation.   That mandate was
 never followed because implementers chose not to follow it, and
 not because they were unable to do so.
 
 The apparently confused statement above is best understood if one
 notes that its essential job is to state
 that the "MUST" in RFC3530 referred to above is not
 reasonable.   However, the authors might well have felt unable
 to say so clearly,
 in light of the potential IESG reaction.<a href="#section-7.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-8.1">   
   NFSv4.1 supports the fs_charset_cap
   attribute (Section 5.8.2.11) that indicates to the client a file
          system's UTF-8 capabilities.<a href="#section-7.1-8.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-9">
 The problem with the mention of (plural) capabilities is that
 the only capability mentioned which servers could implement is to
 accept strings which are not valid UTF-8.  There are other potential
 capabilities having to do with the implementation of canonical
 equivalence, but since they were not mentioned, they will not be
 discussed further here.<a href="#section-7.1-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-10.1">   
   The attribute is an integer containing
   a pair of flags.  The first flag is
   FSCHARSET_CAP4_CONTAINS_NON_UTF8,
          which, if set to one, tells the client that the file system
   contains
          non-UTF-8 characters,<a href="#section-7.1-10.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-11">
 As stated, this would mean that a server would have to keep track of
 a count of non-UTF-8-encoded names within the file system
 and change the attribute value as that
 count varied between zero and non-zero.   Since it is most unlikely
 that any server would keep track of that or that any client would
 find it useful, we will assume that the capability to
 store such names is what is most likely intended.<a href="#section-7.1-11" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-12.1">   
   and the server will not convert non-UTF
          characters to UTF-8 if the client reads a symbolic link or directory,<a href="#section-7.1-12.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-13">
 There is no way for the server to convert non-UTF names to UTF-8
 or anything else, since it has no knowledge of the name encoding to
 begin with.  The alternative to treating names as UTF-8-encoded
 Unicode strings is to treat them as POSIX does, as uninterpreted
 strings of bytes.   That makes it impossible to interpret strings that
 do not follow the rules of UTF-8 at all, making it impossible to
 convert the string to UTF-8.<a href="#section-7.1-13" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-14.1">   
   neither will operations with component names or pathnames in the
          arguments convert the strings to UTF-8.<a href="#section-7.1-14.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-15">
 As stated above, there is no way a server could ever do that.<a href="#section-7.1-15" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-16.1">   
   The second flag is
          FSCHARSET_CAP4_ALLOWS_ONLY_UTF8, which,
   if set to one, indicates that the server will accept (and
   generate) only UTF-8 characters on the
          file system.<a href="#section-7.1-16.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-17">
 That is clear and so it poses no problem for a revised treatment,
 unlike the other flag.<a href="#section-7.1-17" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-18.1">   
   If FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set to one,
          FSCHARSET_CAP4_CONTAINS_NON_UTF8 MUST be set to zero.<a href="#section-7.1-18.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-19">
 There is no problem with this statement.  However, it does, by
 implication, raise the issue of what values of
 FSCHARSET_CAP4_CONTAINS_NON_UTF8 may be set in the case in
 which FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set to zero.<a href="#section-7.1-19" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-20.1">   
          FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 SHOULD always be set to one.<a href="#section-7.1-20.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-21">
 According to RFC2119 <span>[<a href="#RFC2119" class="xref">1</a>]</span>, "SHOULD" means
 that "there may exist valid reasons in particular
 circumstances to ignore a particular item, but the full
 implications must be understood and carefully weighing a different
 course".  In this context, it is unclear what these "full implications"
 might be given the introduction above.  The clause, "because some
 operating e
 environments and file systems do not enforce character set
 encodings", gives one no basis for treating this as other than an
 unproblematic behavior variant, calling into question the use of
 "SHOULD".<a href="#section-7.1-21" class="pilcrow">¶</a></p>
<p id="section-7.1-22">
 Also, the statement in RFC2119 that these terms (i.e. those like
 "SHOULD") "only be used where it is actually required for
 interoperation or to limit behavior which has the potential for
 causing harm"<a href="#section-7.1-22" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-23.1">
   The whole purpose of this feature is to enable interoperation
   and there is no basis for the implication that one particular
   flag value is superior to another in allowing interoperation.<a href="#section-7.1-23.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.1-23.2">
   There is no basis for assuming that accepting file names that
   are not UTF-8-encoded Unicode has any potential for causing harm.<a href="#section-7.1-23.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-7.1-24">
 Despite the statement in RFC2119, that "they [i.e. terms such as
 'SHOULD'] must not be used to impose a particular method on
 implementors", it is hard to avoid the conclusion that this is
 in fact the motivation for the "SHOULD", although the authors
 might not have had any such intention but felt that the IESG
 might well have such an intention.<a href="#section-7.1-24" class="pilcrow">¶</a></p>
</section>
</div>
<div id="CHARSET-future">
<section id="section-7.2">
        <h3 id="name-the-attribute-fs_charset_cap-">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-the-attribute-fs_charset_cap-" class="section-name selfRef">The Attribute Fs_charset_cap in Future NFSv4.1 Specifications</a>
        </h3>
<p id="section-7.2-1">
 We provide a revised version of Section 14.4 of
 <span>[<a href="#RFC8881" class="xref">9</a>]</span> below, taking into account the issues
 noted in <a href="#CHARSET-past" class="xref">Section 7.1</a>.  Given there was a
 working group consensus to adopt the confusing language
 discussed there, we must now adopt, by consensus, a clearer
 replacement that reflects the working group's intentions.
 Given the passage of time and the changed context, it might
 not be possible to determine those intentions.   In any case,
 we will have to be aware of how
 this attribute was implemented and used, particularly with
 regard to the first flag, whose meaning remains obscure.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">
       The following treatment is proposed as a basis for discussion,
       with the understanding that it would need to be changed, if it could
       raise
       interoperability issues.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.2-3">
<pre>

   const FSCHARSET_CAP4_CONTAINS_NON_UTF8  = 0x1;
   const FSCHARSET_CAP4_ALLOWS_ONLY_UTF8   = 0x2;

   typedef uint32_t        fs_charset_cap4;
</pre><a href="#section-7.2-3" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-7.2-4.1">
        This attribute provides a simple way of determining whether a
 particular file system behaves as a UTF-8-only server and rejects
 file names which are not valid UTF-8 strings.   When this
 attribute is supported and the value returned has the
 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 flag set, the error NFS4ERR_INVAL
 MUST be returned if any file name argument contains a string which
 is not a valid UTF-8 string.<a href="#section-7.2-4.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.2-4.2">
 When this
 attribute is supported and the value returned has the
 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 flag clear, the error NFS4ERR_INVAL
 will not be returned based on adherence to the rules of UTF-8.
 While such file systems are generally UTF-8-unaware, this cannot
 be assumed, since server are allowed (in some circumstances; it is a
 "SHOULD NOT") to accept non-UTF-8 names while being aware of the
 structure of UTF-8-conforming names, for the purposes of
 determining canonical equivalence, for example.  See
 <a href="#SERVTYPES" class="xref">Section 6</a>.<a href="#section-7.2-4.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.2-4.3">
 With regard to the flag FSCHARSET_CAP4_CONTAINS_NON_UTF8, it has
 proved impossible to determine, from existing treatments of this
 attribute, any value that might be helpful here.   As a result, we
 are forced to assume that this flag is always a complement of
 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 and that any result in which it is
 not is to be ignored, with the appropriate handling being the same
 as would apply if the attribute were not supported.<a href="#section-7.2-4.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-7.2-4.4">
 When this attribute is not supported, the client can perform a
 LOOKUP using a name not conforming to the rules of UTF-8 and
 use the error returned to determine whether non-UTF-8 names are
 accepted.<a href="#section-7.2-4.4" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="ENCODE">
<section id="section-8">
      <h2 id="name-string-encoding">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-string-encoding" class="section-name selfRef">String Encoding</a>
      </h2>
<p id="section-8-1">
      Strings that potentially contain characters outside the ASCII range
      <span>[<a href="#RFC20" class="xref">10</a>]</span> are generally represented in NFSv4 using
      the UTF-8 encoding <span>[<a href="#RFC3629" class="xref">7</a>]</span> of Unicode
      <span>[<a href="#UNICODE" class="xref">11</a>]</span>.  See <span>[<a href="#RFC3629" class="xref">7</a>]</span> for
      precise encoding and decoding rules.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">
      Some details of the protocol treatment depend on the type of string:<a href="#section-8-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8-3.1">
          <p id="section-8-3.1.1">
          For strings that are component names, the preferred encoding for any
          non-ASCII characters is the UTF-8 representation of Unicode.<a href="#section-8-3.1.1" class="pilcrow">¶</a></p>
<p id="section-8-3.1.2">

          In many cases, clients have no knowledge of the encoding
          being used, with the encoding done at the user level under
          the control of a per-process locale specification. As a result,
          it may be impossible for the NFSv4 client to enforce the
          use of UTF-8. The use of non-UTF-8 encodings can be
          problematic, since it may interfere with access to files
          stored using other forms of name encoding. Also,
          normalization-related
          processing (see <a href="#NORM" class="xref">Section 9</a>) of a string
          not encoded in UTF-8 could result in inappropriate name
          modification or aliasing.  In cases in which one has a
          non-UTF-8 encoded name that accidentally conforms to
          UTF-8 rules, substitution of canonically equivalent strings
          can change the non-UTF-8 encoded name drastically.<a href="#section-8-3.1.2" class="pilcrow">¶</a></p>
<p id="section-8-3.1.3">
   For similar reasons, where non-UTF-8 encoded names are
   accepted, case-related mappings cannot be relied upon.  For
   this reason, the attribute case_insensitive MUST NOT be
   returned as TRUE for file systems which accept non-UTF-8 encoded
   file names.<a href="#section-8-3.1.3" class="pilcrow">¶</a></p>
<p id="section-8-3.1.4">

          The kinds of modification and aliasing mentioned here can
          lead to both false negatives and false positives, depending on
          the strings in question, which can result in security
          issues such as elevation of privilege and denial of service
          (see <span>[<a href="#RFC6943" class="xref">23</a>]</span> for further discussion).<a href="#section-8-3.1.4" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-8-3.2">
          For strings based on domain names, non-ASCII characters MUST be
          represented using the UTF-8 encoding of Unicode, and additional
          string format restrictions may apply.
          See <a href="#OTHER" class="xref">Section 12</a> for details.<a href="#section-8-3.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-8-3.3">
          The contents of symbolic links (of type linktext4 in the
          XDR) MUST be treated as opaque data by NFSv4 servers.
          Although UTF-8 encoding is often used, it need not be.
          In this respect, the contents of symbolic links are like
          the contents of regular files in that their encoding is
          not within the scope of this specification.<a href="#section-8-3.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-8-3.4">
          For other sorts of strings, any non-ASCII characters SHOULD be
          represented using the UTF-8 encoding of Unicode.<a href="#section-8-3.4" class="pilcrow">¶</a>
</li>
      </ul>
</section>
</div>
<div id="NORM">
<section id="section-9">
      <h2 id="name-normalization">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-normalization" class="section-name selfRef">Normalization</a>
      </h2>
<p id="section-9-1">
      The client and server operating environments can
      potentially differ in their
      policies and operational methods with respect to character
      normalization (see <span>[<a href="#UNICODE" class="xref">11</a>]</span> for a discussion of
      normalization forms).  This difference may also exist between
      applications on the
      same client.  This adds to the difficulty of providing a single
      normalization policy for the protocol that allows for maximal
      interoperability.  This issue is similar to the issues of
      character case where the server may or may not support
      case-insensitive file name matching and may or may not preserve
      the character case when storing file names.  The protocol does not
      mandate a particular behavior but allows for a range of useful
      behaviors.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">
      The NFSv4 protocol does not mandate the use of a particular
      normalization form.  A subsequent minor version of
      the NFSv4 protocol might specify a particular normalization form,
      although there would be difficulties in doing so
      (see <a href="#FUTURE" class="xref">Section 15</a>
      for details).
      In any case, the server and client can expect that they might receive
      unnormalized characters within protocol requests and responses.  If
      the operating environment requires normalization, then the
      implementation will need to normalize the various UTF-8 encoded strings
      within the protocol before presenting the information to an
      application (at the client) or local file system (at the server).<a href="#section-9-2" class="pilcrow">¶</a></p>
<p id="section-9-3">
      Server implementations MAY normalize file names to conform
      to a particular normalization form before using the resulting
      string when looking up or creating a file.  Servers MAY also
      perform normalization-insensitive string comparisons without
      modifying the names to match a particular normalization form.
      Except in cases in which component names are excluded from
      normalization-related handling because they are not valid
      UTF-8 strings, a server MUST make the same choice (as to
      whether to normalize or not, the target form of normalization,
      and whether to do normalization-insensitive string comparisons)
      in the same way for all accesses to a particular file system.
      Servers SHOULD NOT reject a file name because it does not
      conform to a particular normalization form, as this would deny
      access to clients that use a different normalization form or clients
      acting on behalf of application that use a different normalization
      form.<a href="#section-9-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="CASEI">
<section id="section-10">
      <h2 id="name-case-insensitive-processing">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-case-insensitive-processing" class="section-name selfRef">Case-Insensitive Processing of File Names</a>
      </h2>
<p id="section-10-1">
      When the server is to process file names in a case-insensitive
      way in a given file system, it may choose to do so in a number of ways.<a href="#section-10-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-2.1">
 It can force all characters which have multiple forms to a
 common case, whether uppercase of lowercase. Although this may
 cause the file name shown in the directory to be different from
 that specified when the file is created, these two names will be
 judged as equivalent when a case-insensitive comparison is used.
 Such file systems are case-insensitive but not case-preserving.<a href="#section-10-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-2.2">
 It can preserve all names, presented as valid and not subject
 to case-based modification, while treating two names that are
 equivalent when a case-insensitive comparison is used as referring
 to the same file. 
 Such file systems are both case-insensitive and case-preserving.<a href="#section-10-2.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-10-3">
      When a server implements case-insensitive file name handling, it
      is necessary that clients do so as well.  For example, if a client
      possessing the cached contents of a directory, notes that the file
      "a" does not exist, it cannot immediately act on that presumed
      non-existence, without checking for the potential existence of "A"
      as well.  As a result, clients need to be able to provide
      case-insensitive name comparisons, irrespective of whether the
      server handling is case-preserving or not.<a href="#section-10-3" class="pilcrow">¶</a></p>
<p id="section-10-4">
      Because case-insensitive name comparisons are not always as
      straightforward
      as the above example suggests, the client, if it is to emulate
      the server's name handling, would need information about how certain
      cases are to be dealt with.  In cases in which that information is
      unavailable, the client needs to avoid making assumptions about the
      server's handling, since it will be unaware of the Unicode version
      implemented by the server, or many of the details of specific issues
      that might need to be addressed differently by different server
      file systems in implementing
      case-insensitive name handling.<a href="#section-10-4" class="pilcrow">¶</a></p>
<p id="section-10-5">
      Many of the problematic issues with regard to the case-insensitive
      handling of names are discussed in Section 5.18 of the Unicode Standard
      <span>[<a href="#UNICODE-CASEM" class="xref">12</a>]</span> which deals with case mapping.
      While we need to
      address all of these issues as well, our approach will not be exactly
      the same.<a href="#section-10-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-6.1">
 Since the client will be doing case-insensitive comparisons, issues
 that apply only to uppercasing or lowercasing do not have the same
 significance.<a href="#section-10-6.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-6.2">
 Many clients will have to operate correctly even in the absence
 of detailed information about the specifics of server case-mapping
 or the version of Unicode implemented by the server.<a href="#section-10-6.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-6.3">
 Clients will have to accommodate server behaviors not anticipated
 by the Unicode Specification since it might be that neither the server
 nor the
 client would have any relevant
 locale knowledge when file names are processed.<a href="#section-10-6.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-10-7">
      Another source of information about case-folding, and indirectly about
      case-insensitive comparisons, is the case-folding text file which
      is part of the Unicode Standard <span>[<a href="#UNICODE-CASEF" class="xref">13</a>]</span>.
      This file contains, for each Unicode character that can be uppercased
      or lowercased, a single character, or, in some cases a string of
      characters of the other case.  For characters in capital case, the
      lowercase counterpart is given.   Each of the mappings is characterized
      as of one of four types:<a href="#section-10-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-8.1">
 Common case folding, denoted by a status field of "C".  These
 are used for mapping where a single character can be mapped to
 a single character of another case.  These are always valid
 with one potential exception being the mappings of LATIN CAPITAL
 LETTER I to LATIN SMALL LETTER I and vice versa, which might be
 superseded by the T-type mappings of associated with
 some Turkic languages.<a href="#section-10-8.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-8.2">
 Full case folding, denoted by a status field of "F".  These are
 used for mappings in which single character is mapped to a
 multi-character string of a different case.<a href="#section-10-8.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-8.3">
 Special case folding, denoted by a status field of "S".  These
 provide additional single-character-to-single-character which
 might be used when there is also an F-type mapping of
 the same character.  In the case of case folding, this is an
 alternative to the corresponding F-type, although, for the purposes
 of case-insensitive string comparison, it is possible for both to
 be in considered valid at the same time<a href="#section-10-8.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-8.4">
 Special case foldings for Turkic languages, denoted by a status
 field of "T".  These consist of the invertible case mappings between
 LATIN SMALL LETTER I (U+0069) and LATIN CAPITAL LETTER I WITH DOT ABOVE
 (U+0130) and between LATIN CAPITAL LETTER I (U+0049) and LATIN
 SMALL LETTER DOTLESS I (U+0131).  The relationship between these
 mappings and the C-type mappings for LETTER I is discussed below in
 item EX8.<a href="#section-10-8.4" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-10-9">
      While the case mapping section does discuss case-insensitive string
      comparisons,
      and describes a procedure for constructing equivalence classes of
      Unicode characters, the description does not deal clearly with
      the effect of F-type mappings.  There are a number of problems with
      dealing with F-type mappings for case folding and basing
      case-insensitive string comparisons on
      those mappings, particularly in
      situations, such as file systems, in which extensive processing of
      strings is unlikely to be possible.<a href="#section-10-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-10.1">
 Mappings from single characters to multi-character strings, are,
 for case-folding purposes, not invertible.  However, case-insensitive
 name comparison, by its nature, requires invertible mappings, in
 which a multi-character string is mapped to a single character of
 a different case which not compatible with any existing simple
 case-mapping models.<a href="#section-10-10.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-10.2">
 Scanning of names for multi-character sequences might well be too
 complicated, especially since such sequences might overlap in
 complicated ways.<a href="#section-10-10.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-10.3">
 Case foldings which map single characters to multi-character
 sequences (see item EX4 below for an important example), would
 give rise, because of the invertibility of case mappings when
 used to determine case-insensitive string equivalence for very
 large sets of strings.  For example, a string of eight copies
 of the letter S would give rise to an set of 256 equivalent
 strings plus over two thousand 
 others when the German SHARP S characters discussed
 in item EX4 are included.<a href="#section-10-10.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-10-11">
      Despite these potential difficulties, case mappings involving
      multi-character sequences can be reversed when used as a basis for
      case-insensitive string comparisons and incorporated into 
      a set of equivalence classes on name strings.<a href="#section-10-11" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-12.1">
          <p id="section-10-12.1.1">
 Case-insensitive servers MAY do either case-mapping to a chosen
 case or case-insensitive string comparisons when providing a
 case-preserving
 implementation.  In either case, it MAY include F-type mappings,
 which map a single character to a multi-character string.   However,
 only the case in which it is doing case-insensitive string
 comparison will
 it use the inverse of F-type mappings, in which a multi-character
 string is mapped to a single character of a different case<a href="#section-10-12.1.1" class="pilcrow">¶</a></p>
<p id="section-10-12.1.2">

        In these cases, the server can choose to use either a C-type mapping
 or an F-type mapping, or both, when both exist.  Similarly
 the server may choose to implement the C-type mappings of LATIN
 CAPITAL LETTER I to LATIN SMALL LETTER I and vice versa, the
 corresponding T-type mappings or both, although using only
 the second of these
 is NOT ALLOWED, unless there is a means of informing the client that
 it has been chosen.<a href="#section-10-12.1.2" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-12.2">
 The client, when informed of the details of the client's handling
 of case, has the ability to efficiently implement an appropriate
 case-insensitive name comparison compatible with that of the
 server.  This includes the ability to handle mappings between
 single characters and multi-character strings.<a href="#section-10-12.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-10-12.3">
 Implementation of case-insensitive name comparisons will typically
 require a case-insensitive name hash.<a href="#section-10-12.3" class="pilcrow">¶</a>
</li>
      </ul>
<div id="CASEI-impl">
<section id="section-10.1">
        <h3 id="name-implementing-case-insensiti">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-implementing-case-insensiti" class="section-name selfRef">Implementing Case-Insensitive Comparison of File Names</a>
        </h3>
<p id="section-10.1-1">
 Implementing case-insensitive string comparisons based on equivalence
 classes including multi-character strings can be performed as
 described below.  This algorithm requires that if there is more
 than one multi-character string within a given equivalence class,
 they must all be equivalent,
 with any equivalences derivable from case-insensitive string
 equivalence using single-character equivalence classes.<a href="#section-10.1-1" class="pilcrow">¶</a></p>
<p id="section-10.1-2">
 Although other sources are possible (see items EX2 and EX3 in
 <a href="#CASEI-ex" class="xref">Section 10.2</a>),
 multi-character sequences often appear in case-insensitive
 equivalence classes as the result of the canonical decomposition
 of one or more precomposed characters as elements of a case-insensitive
 equivalence class.<a href="#section-10.1-2" class="pilcrow">¶</a></p>
<p id="section-10.1-3">
 While the algorithm described in this section can deal with
 certain case-based equivalences deriving from canonical decomposition,
 it is not capable of providing general handling of the combination
 of canonical equivalence and case-based equivalence.   While this can
 be addressed by normalizing strings before doing case-insensitive
 comparison, it is more efficient to do a general form-insensitive
 and case-insensitive string comparison in a single step as described
 in <a href="#FORMI" class="xref">Appendix B</a><a href="#section-10.1-3" class="pilcrow">¶</a></p>
<p id="section-10.1-4">
 The following tables would be used by the comparison algorithm
 presented below.<a href="#section-10.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10.1-5.1">
   For each possible character value, the associated equivalence
   class for case-insensitive comparison will be identified<a href="#section-10.1-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.1-5.2">
   For each such equivalence class, the hash value contribution will
   be provided.  In the case of equivalence class that do not include
   multi-character including equivalence classes that only include a
   single member, this will be the hash value contribution of one
   particular variant (usually lower case) of the character<a href="#section-10.1-5.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.1-5.3">
   In the case of equivalence classes that do include multi-character
   strings, the hash value contribution needs to equivalent to the
   combined contribution of each character within the multi-character
   string.  In addition, for each such equivalence class, the
   length of the multicharacter string will be provided together with a
   pointer to an array describing the multi-character string, most
   probably presenting each character as an equivalence class id.<a href="#section-10.1-5.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-10.1-6">
 Case-insensitive comparison proceeds as follows:<a href="#section-10.1-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10.1-7.1">
   Implementation of case-insensitive name comparisons will typically
   require a case-insensitive name hash using the tables described
   above.   If such a hash vale is kept or all cached names comparisons
   of hashes can be used instead of the detailed comparison set forth
   below.  Using such hash comparisons, a large set of potentially
   equivalent names
   can be excluded based on the occurrence of hash mismatches, since
   case-equivalent names would have the same hash value.
   value.<a href="#section-10.1-7.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.1-7.2">
   For names with matching hash values, a detailed case-insensitive
   comparison will be necessary.   This can proceed character-by-
   character or byte-by-byte.  However, in the byte-by-byte case,
   processing in the event of a mismatch must start at the start
   of the current character, rather than the byte at which the
   difference was detected.<a href="#section-10.1-7.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.1-7.3">
   In cases in which there is a mismatch, the associated equivalence
   classes will be compared.  When these are identical, indicating the
   case equivalence of the two characters, the comparison of the two
   strings continues at the next character of each string.<a href="#section-10.1-7.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.1-7.4">
   When the two equivalence classes are not identical, further
   comparisons to determine if a single character within one
   string matches (except for case) a multi-character string
   within the other.  For
   each of two equivalence classes being compared that include
   a multi-character string, the check below must be made to determine
   whether the multi-character string at the corresponding position
   of the other string being compared, is within the
   current equivalence class.   If neither of the two equivalence
   classes include multi-character strings, the comparison terminates
   with a mismatch indication.<a href="#section-10.1-7.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.1-7.5">
   For each equivalence class that does include a multi-character
   string (there might be one or two), a scan needs to be made to see
   of the characters at the current position if the other string
   matches (except for case) the multi-character string which
   is included in the current equivalence class.  If this check
   succeeds, for either equivalence class, the comparison of the two
   strings continues at the next character of each string.  In the
   event of failure, the same sort of comparison is done using the
   other current equivalence class, if it include multi-character
   strings.  Once this check fails for all equivalence classes that
   include multi-character strings, the comparison terminates with a
   mismatch indication.<a href="#section-10.1-7.5" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="CASEI-ex">
<section id="section-10.2">
        <h3 id="name-important-examples-of-case-">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-important-examples-of-case-" class="section-name selfRef">Important Examples of Case-insensitive Handling of File Names</a>
        </h3>
<p id="section-10.2-1">
 In this section, we discuss many of the interesting and/or
 troublesome issues
 that the need for case-insensitive handling gives rise to in
 fully internationalized environment.   Many of these are also
 discussed in <span>[<a href="#UNICODE-CASEM" class="xref">12</a>]</span>.  However, our treatment
 of these issues, while not inconsistent with that in
 <span>[<a href="#UNICODE-CASEM" class="xref">12</a>]</span>, differs significantly for a number
 of reasons:<a href="#section-10.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10.2-2.1">
   Our primary focus is on case-insensitive string comparison rather
   than with
   case mapping per se.   While such comparison is natural for the
   client and allowed for servers, its greater flexibility makes
   it important to understand its capabilities in dealing with
   potentially troublesome issues in providing case-insensitive file
   name handling.<a href="#section-10.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-10.2-2.2">
   Because a case mapping model forces the specification of a single
   case mapping result when there are multiple potentially valid results,
   there are inevitably cases in which the result chosen is
   inappropriate for some users.  These are cases in which F-type
   and S-type mappings are present and in which C-type and T-type
   mappings conflict.  Normally, an appropriate choice is selected by
   use of the locale, but in a filesystem environment, valid locale
   information might not be present.   As a result,
   case-insensitive string
   comparison, which does not force such case mapping choices,
   will be more
   desirable.<a href="#section-10.2-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-10.2-3">
 The examples below present common situations that go beyond the
 simple invertible case mappings of Latin characters and the
 straightforward
 adaptation of that model to Greek and Cyrillic.  In EX4 and EX5
 we have case-based equivalence classes including multi-character
 strings not derived from canonical equivalences while for EX7 and EX8
 all multi-character strings are derived from canonical
 equivalences.  In addition, EX1, EX2, EX3 and EX6 discuss other
 situations
 in which an equivalence class has more than two elements.<a href="#section-10.2-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-10.2-4">
<dt>EX1:</dt>
<dd id="section-10.2-4.1">
            <p id="section-10.2-4.1.1">
   Certain digraph characters such LATIN SMALL LETTER DZ (U+01F3)
   have additional case variants to consider such as the titlecase
   character LATIN CAPTAL LETTER D WITH SMALL LETTER Z (U+01F2) in
   addition to the uppercase LATIN CAPITAL LETTER DZ (U+01F1).
   While the titlecased variant would not appear in names in
   case-insensitive non-case-preserving file systems, case-insensitive
   string comparison has no problem in treating these three
   characters as within the same equivalence class.<a href="#section-10.2-4.1.1" class="pilcrow">¶</a></p>
<p id="section-10.2-4.1.2">
   This
   equivalence class can be derived from only C-type mappings.
   The possibility of 
   mapping these characters to two-character sequences they
   represent is not a troublesome
   issue since that would be derived from a compatibility equivalence,
   rather than a canonical equivalence, and there is no F-type 
   mapping making it an option.<a href="#section-10.2-4.1.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>EX2:</dt>
<dd id="section-10.2-4.2">
            <p id="section-10.2-4.2.1">
   To deal with the case of  the OHM SIGN (U+2126) which is 
   essentially identical to the GREEK CAPITAL LETTER OMEGA (U+03A9),
   one can construct an equivalence class consisting of OHM
   SIGN (U+2126), GREEK CAPITAL LETTER OMEGA (U+03A9), and
   GREEK SMALL LETTER OMEGA (U+03C9).<a href="#section-10.2-4.2.1" class="pilcrow">¶</a></p>
<p id="section-10.2-4.2.2">
   This
   equivalence class can be derived only from C-type mappings.
   Both OHM
   SIGN (U+2126), and GREEK CAPITAL LETTER OMEGA (U+03A9)
   lowercase to GREEK  LETTER OMEGA (U+03C9), while that
   character only uppercases to GREEK CAPITAL LETTER OMEGA (U+03A9).<a href="#section-10.2-4.2.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>EX3:</dt>
<dd id="section-10.2-4.3">
            <p id="section-10.2-4.3.1">
   To deal with the case of the ANGSTROM SIGN (U+212B) which is
   essentially identical to LATIN CAPITAL LETTER A WITH RING
   ABOVE (U+00C5), one can construct an equivalence class consisting
   of ANGSTROM SIGN (U+212B), LATIN CAPITAL LETTER A WITH RING
   ABOVE (U+00C5), LATIN SMALL LETTER A WITH RING
   ABOVE (U+00E5), together with the two-character sequences
   involving LATIN CAPITAL LETTER A (U+0041) or
   LATIN SMALL LETTER A (U+0061) followed by COMBINING RING
   ABOVE (U+030A).<a href="#section-10.2-4.3.1" class="pilcrow">¶</a></p>
<p id="section-10.2-4.3.2">
   This
   equivalence class can be derived from C-type mappings together
   with the ability to map characters to canonically equivalent
   strings.
   Both ANGSTROM 
   SIGN (U+212B), and LATIN CAPITAL LETTER A WITH RING
   ABOVE (U+00C5) lowercase to LATIN SMALL LETTER A WITH RING
   ABOVE (U+00E5), while that character only uppercases to
   CAPITAL LETTER A WITH RING ABOVE (U+00C5).<a href="#section-10.2-4.3.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>EX4:</dt>
<dd id="section-10.2-4.4">
            <p id="section-10.2-4.4.1">
   In some cases, case mapping of a single character will result
   in a multi-character string.   For example, the German character
   LATIN SMALL LETTER SHARP S (U+00DF) would be uppercased to "SS",
   i.e. two copies of LATIN CAPITAL LETTER S (U+0053).  On the other
   hand, in some situations, it would be uppercased to
   the character LATIN CAPITAL LETTER SHARP S (U+1E9E), using an
   S-type mapping. referred to as an instance of "Tailored Casing".
   Unfortunately, in the context of a file system, there is unlikely
   to be available information that provides guidance about which of
   these case mappings should be chosen.   However, the use of
   case-insensitive mappings with larger equivalence classes often
   provides handling that is acceptable to
   a wider variety of users.  In this case, German-speakers get the
   mapping they expect while those unfamiliar with these characters
   only see them when they access a file whose name contains them.<a href="#section-10.2-4.4.1" class="pilcrow">¶</a></p>
<p id="section-10.2-4.4.2">
   It appears that if the construction of case-based
   equivalence classes were generalized to include multi-character
   sequences, then all of LATIN SMALL LETTER SHARP S (U+00DF), LATIN
   CAPITAL LETTER SHARP S (U+1E9E), "ss", "sS", "Ss", and "SS"
   would belong to the same equivalence class and could be handled
   by the general algorithm described in <a href="#CASEI-impl" class="xref">Section 10.1</a>,
   as well by code specifically written to deal with this particular
   issue.<a href="#section-10.2-4.4.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>EX5:</dt>
<dd id="section-10.2-4.5">
   Other ligatures, such as LATIN SMALL LIGATURE FFL (U+FB04), could
   be handled similarly by this algorithm, if there were felt
   a need to do
   so. However, because the decomposition of this character into the
   string consisting of the three letters LATIN SMALL LETTER F (U+0066),
   LATIN SMALL LETTER F (U+0066), LATIN SMALL LETTER L (U+006C),
   is a compatibility equivalence, and the F-type mapping of this
   ligature to the three constituent is to be treated as optional,
   implementations can choose either to treat this character as
   having no uppercase equivalent or treat it as part of larger
   equivalence class including "ffl", "ffL", "fFl", etc.).<a href="#section-10.2-4.5" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt>EX6:</dt>
<dd id="section-10.2-4.6">
   The character COMBINING GREEK YPOGEGRAMMENI (U+0345), also known as
   "iota-subscript" requires special handling when uppercasing and
   lowercasing.  While the description of the appropriate handling for
   this character, in the case mapping section, is focused on multi-
   character sequences representing diphthongs, case-insensitive
   comparisons
   can be performed without consideration of multi-character
   sequences.  This can be done by  assigning COMBINING GREEK
   YPOGEGRAMMENI (U+0345), GREEK SMALL LETTER IOTA (U+03B9),
   and GREEK CAPITAL LETTER IOTA (U+0399) to the same equivalence
   class, even though the first of these is a combining character
   and the others are not.<a href="#section-10.2-4.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt>EX7:</dt>
<dd id="section-10.2-4.7">
            <p id="section-10.2-4.7.1">
   In some cases context-dependent case mapping is required.  For
   example, GREEK CAPITAL LETTER SIGMA (U+03A3) lowercases to
   GREEK SMALL LETTER SIGMA (U+03C3) if it is followed by another
   letter and to GREEK SMALL LETTER FINAL SIGMA (U+03C2) if it is not.<a href="#section-10.2-4.7.1" class="pilcrow">¶</a></p>
<p id="section-10.2-4.7.2">
   Despite this, case-insensitive comparisons can be
   implemented, by considering
   all of these characters as part of the same equivalence class,
   without any context-dependence, and this equivalence class can
   be derived using only
   C-type mappings.<a href="#section-10.2-4.7.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>EX8:</dt>
<dd id="section-10.2-4.8">
            <p id="section-10.2-4.8.1">
   In most languages written using Latin characters, the uppercase
   and lowercase varieties of the letter "I" differ in that only
   the lowercase character.  In a number of Turkic languages, there
   are two distinct characters derived from "I" which differ only
   with regard to the presence or absence of a dot so that
   there are both capital and small i's with each having dotted
   and dotless variants.
   Within such languages, the dotted and dotless I's represent
   different vowel sounds and are treated as separate characters
   with respect to case mapping.  The uppercase
   of LATIN SMALL LETTER I (U+0069) is LATIN CAPITAL LETTER I WITH
   DOT ABOVE (U+0130), rather than LATIN CAPITAL LETTER I (U+0049).
   Similarly the lowercase of LATIN CAPITAL LETTER I (U+0049) is
   LATIN SMALL LETTER DOTLESS I (U+0131) rather than LATIN SMALL
   LETTER I (U+0069).<a href="#section-10.2-4.8.1" class="pilcrow">¶</a></p>
<p id="section-10.2-4.8.2">
   When doing case mapping, the server must choose to uppercase
   LATIN SMALL LETTER I (U+0069) to either  LATIN CAPITAL LETTER I
   (U+0049), based on a C-type mapping to LATIN CAPITAL LETTER I
   WITH DOT ABOVE (U+0130), based on a T-type mapping.   The former
   is acceptable to most people but confusing to speakers of the
   Turkic languages in question since the case mapping changes the
   character to represent a different vowel sound.  On the other hand,
   the latter mapping seemingly inexplicably results in a character
   many users have never seen before.  Normally such choices are
   dealt with based on a locale but, in a file system environment,
   no locale information may be available.<a href="#section-10.2-4.8.2" class="pilcrow">¶</a></p>
<p id="section-10.2-4.8.3">
   In the context of case-insensitive string comparison, it is
   possible to create a larger equivalence class, including all of
   the letters LATIN SMALL LETTER I (U+0069),
   LATIN CAPITAL LETTER I (U+0049),
          LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), LATIN SMALL LETTER
   DOTLESS I (U+0131) together with the two-character string consisting
   of LATIN CAPITAL LETTER I (U+0049) followed by COMBINING DOT
   ABOVE (U+0307).<a href="#section-10.2-4.8.3" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="CLIENT">
<section id="section-11">
      <h2 id="name-internationalization-relate">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-internationalization-relate" class="section-name selfRef">Internationalization-related Processing of File Names by Clients</a>
      </h2>
<p id="section-11-1">
      Given the way that internationalization is addressed within the
      NFSv4 protocols, clients,
      and applications accessing NFS files can generally remain unaware
      of the specific type of internationalization-related processing
      implemented by the server.  For example, although a server MAY
      store all file names according to the rules appropriate to a particular
      normalization form, it MUST NOT reject names solely because they are
      not encoded using this normalization form, allowing the clients and
      applications to avoid knowledge of normalization choices.<a href="#section-11-1" class="pilcrow">¶</a></p>
<p id="section-11-2">
      However, as has been pointed out in
      <span>[<a href="#I-D.williams-filesystem-18n" class="xref">25</a>]</span>, there are situations
      in which clients implementing local optimizations use the saved
      contents of directories
      fetched from the server, making it necessary that the client's and the
      server's handling of internationalization-related name mapping issues
      be in concord.  There are two basic ways this issue can be addressed:<a href="#section-11-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-11-3.1">
 Where the protocol has not defined a means whereby the client can
 obtain information about the details of internationalized name
 handling implemented within the server, the client can avoid
 conflict with the server by limiting its use of local optimizations.
 While positive name caching can be used without adverse effects,
 negative name caching has to limited to avoid situations in which
 a given name is not present but an equivalent one may exist, as far
 as the server is concerned.   This situation, which applies to all
 current NFSv4 protocols is discussed in
 <a href="#CLIENT-now" class="xref">Section 11.2</a>.<a href="#section-11-3.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-11-3.2">
 The client can be provided complete information about the
 server's internationalization-related name handling
 (typically implemented
 within the server-based file system.   This situation, which could
 be implemented in later NFSv4 minor versions, or in an extension to
 an existing extensible minor version is discussed in
 <a href="#CLIENT-future" class="xref">Section 11.3</a>.<a href="#section-11-3.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-11-3.3">
 Note that when case-insensitive handling of file names is implemented
 by a server-side filesystem, further complications can arise.  For
 the most part, these are addressed in Sections
 <a href="#CLIENT-now" class="xref">11.2</a> and
 <a href="#CLIENT-future" class="xref">11.3</a> by treating
 the particulars of case-handling as a another element of the name
 handling implemented by the server.  However, some of the specific
 complexities are addressed separately in <a href="#CASEI" class="xref">Section 10</a>.<a href="#section-11-3.3" class="pilcrow">¶</a>
</li>
      </ul>
<div id="CLIENT-servrest">
<section id="section-11.1">
        <h3 id="name-server-restrictions-to-deal">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-server-restrictions-to-deal" class="section-name selfRef">Server Restrictions to Deal with Lack of Client Knowledge</a>
        </h3>
<p id="section-11.1-1">
 There are a number of restrictions, not previously specified in
 RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>, on server implementation
 of internationalized
 file name handling.   These restrictions apply to both case-sensitive
 and case-insensitive file systems and are designed to limit the
 options that servers have in choosing server-side internationalized
 file name handling so as to enable the clients to either duplicate
 that handling or limit it to avoid relying on cases in which the
 proper handling cannot be determined or duplicated by the client.<a href="#section-11.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-11.1-2.1">
   The canonical equivalence relation implemented by the server, for
   each internationalization-aware filesystem MUST match that defined
   by some particular UNICODE version equal to or later than version 4.0.<a href="#section-11.1-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-11.1-2.2">
   The case-equivalence relationship implemented by the server, for
   each case-insensitive filesystem MUST include all C-type case
   mappings included by the particular UNICODE version whose
   canonical equivalence relation is implemented by the server,
   with the possible exception of those conflicting with T-type
   case mappings.
   by some particular Unicode version equal to or later than
   version 4.0.<a href="#section-11.1-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-11.1-2.3">
            <p id="section-11.1-2.3.1">
   In cases in which the server provides no way of determining the
   details of the case-equivalence relationship implemented by the
   server for a particular file system, that mapping must include
   all C-type case mappings included by the particular UNICODE version
   whose canonical equivalence relation is implemented by the server,
   i.e. it MUST map between LATIN SMALL LETTER I (U+0069)and LATIN
   CAPITAL LETTER I (U+0049).<a href="#section-11.1-2.3.1" class="pilcrow">¶</a></p>
<p id="section-11.1-2.3.2"></p>
</li>
        </ul>
</section>
</div>
<div id="CLIENT-now">
<section id="section-11.2">
        <h3 id="name-client-processing-of-file-n">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-client-processing-of-file-n" class="section-name selfRef">Client Processing of File Names for Current NFSv4 Protocols</a>
        </h3>
<p id="section-11.2-1">
 The existing minor versions, NFSv4.0 <span>[<a href="#RFC7530" class="xref">3</a>]</span>,
 NFSv4.1 <span>[<a href="#RFC5661" class="xref">21</a>]</span>, and NFSv4.2 <span>[<a href="#RFC7862" class="xref">4</a>]</span>,
 have very limited facilities allowing a client to get information
 about the server's internationalization-related file name handling.
 Because these protocols were all defined when it was assumed that the
 server's internationalized file name handling could be specified in
 great detail, there was no provision for attributes defining the
 server's choices.   As a result, the information available to the
 client is quite limited:<a href="#section-11.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-11.2-2.1">
          The client can determine that the server is not performing
   internationalized file name processing. It can do this by looking
   up a file name using a string which is not valid UTF-8, concluding
   that if the LOOKUP is not rejected on that basis, then the file
   system is not internationalization-aware, allowing the client to
   ignore the potential difficulties which server-based
   internationalized file name processing might give rise to.<a href="#section-11.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-11.2-2.2">
   The client can use the optional per-fs attributes case_insensitive
   and case_preserving to how the server deals with character case
   for particular file system.  When one of these attributes is not
   supported by a particular file system, the client treats the
   attribute as if it were false.<a href="#section-11.2-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-11.2-3">
 When a file system is internationalization-unaware, the client can
 use both positive and negative name caching, without any issues
 arising from the potential for conflict between distinct file names
 that would be considered equivalent by the server.   In other cases,
 the handling is more restricted in the use of negative name caching.
 The issue with regard to case-sensitive and case-insensitive
 file systems are
 discussed separately below.  In each case, the client has a
 range of choices trading off forgone optimization opportunities
 against the difficulty of implementation
 while avoiding negative consequences arising from the fact that
 certain details of the server's name handling are not known to it.<a href="#section-11.2-3" class="pilcrow">¶</a></p>
<p id="section-11.2-4">
 In the case of case-sensitive file systems, the uncertainty to be
 dealt with concerns the version of Unicode implemented by the server,
 given that different versions may have different canonical
 equivalence relationships.  However, whether the server implements
 a particular normalization form or implements form-insensitive file
 name matching has no effect on client behavior.  In light of the
 uncertainty created by the lack of knowledge of the precise Unicode
 version used by the server to implement its canonical equivalence
 relation, the follow possibilities, arranged in order of increasing
 value (and difficulty of implementation) should be considered.<a href="#section-11.2-4" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-11.2-5">
<dt>A1:</dt>
<dd id="section-11.2-5.1">
            <p id="section-11.2-5.1.1">
   The client can simply decline to implement optimizations based on
   negative name caching on internationalization-aware file systems.<a href="#section-11.2-5.1.1" class="pilcrow">¶</a></p>
<p id="section-11.2-5.1.2">
          While this might have a negative effect on performance, it might
   be the best option for clients not heavily used to access
   internationalization-aware filesystems, or where, due to a lack
   of directory delegation support, the client has no assurance
   that will be notified of the invalidation of a previous
   assumption that a particular file does not exist.<a href="#section-11.2-5.1.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>A2:</dt>
<dd id="section-11.2-5.2">
            <p id="section-11.2-5.2.1">
   Relatively simple name filtering can exclude the names for which
   negative name caching might cause difficulties.  For example, the
   client could scan file names for characters whose presence might
   pose difficulties and allow negative name caching only for
   strings known not to contain such characters. Because the Unicode
   version used by the server file system is not known, this treatment
   would be limited to string only containing characters defined in the
   earliest version of Unicode which could be supported, that is,
   Unicode 4.0.<a href="#section-11.2-5.2.1" class="pilcrow">¶</a></p>
<p id="section-11.2-5.2.2">
   One simple way for a
   client to provide such filtering would be to establish an upper limit
   (e.g. U+00ff) and disallow negative name caching for strings
   containing characters above that value or characters below that
   value that might cause there to be canonically equivalent strings
   on the
   server. A simple mask could be
   used to allow each character to be examined
   allowing composed and combining characters to be identified
   together with code points unassigned in Unicode 4.0.<a href="#section-11.2-5.2.2" class="pilcrow">¶</a></p>
<p id="section-11.2-5.2.3">
   This approach would allow negative name caching to be disallowed
   for strings containing those characters while allowing it for other
   strings that do not.  A larger limit (and a corresponding mask)
   would make
   sense for clients used to access many file names containing
   characters from non-Latin alphabets.<a href="#section-11.2-5.2.3" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>A3:</dt>
<dd id="section-11.2-5.3">
            <p id="section-11.2-5.3.1">
   A client might implement its own internationalized file name
   handling paralleling that of the server.   Because the Unicode
   version used by the server filesystem is unknown, strings for
   which it is possible that the canonically equivalent string might
   be different depending on the version of Unicode implemented by the
   server will have to be identified and excluded from using
   negative name caching.  This would require that strings containing
   code points unassigned in Unicode version 4.0, and those denoting
   combining characters that could be parts of precomposed character
   added to later versions of Unicode be excluded from negative name
   caching.  The necessary filtering could apply to all
   potential code points although clients might choose to
   simplify implementation by excluding strings containing code points
   beyond a certain point, e.g. (U+0FFFF).<a href="#section-11.2-5.3.1" class="pilcrow">¶</a></p>
<p id="section-11.2-5.3.2">
   When a client implements internationalized name handling, it needs
   to be able to detect when the apparent absence of a file within
   a directory is contradicted by the occurrence of a file with a
   distinct, but canonically equivalent, name.  In order to efficiently
   find such names, when they exist, a client typically needs to
   implement a form of
   name hashing which always produces the same result for two
   canonically equivalent names.   This can be done by making the
   contribution of any character to the name hash, equal to the
   contribution of the corresponding canonical decomposition string.<a href="#section-11.2-5.3.2" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-11.2-6">
 In the case of case-insensitive file systems, the uncertainty to be
 dealt with includes the version of Unicode implemented by the server
 as well as the details of the possible case-handling implemented
 by the server.  In addition to the fact 
 that different Unicode versions may have different canonical
 equivalence relationships, the server may implement different
 approaches to the handling of issues related to the handling of dotted
 and dotless i, in Turkish and Azeri. However, the question
 of whether the server's handling
 is case-preserving has no effect on client behavior, as is the
 question of whether the server implements
 a particular normalization form or implements form-insensitive file
 name matching.  In light of the
 uncertainty created by the lack of knowledge of the details of the
 case-related equivalence relation together with the precise Unicode
 version used by the server to implement its canonical equivalence
 relation, the following possibilities, arranged in order of increasing
 value (and difficulty of implementation) should be considered.<a href="#section-11.2-6" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-11.2-7">
<dt>B1:</dt>
<dd id="section-11.2-7.1">
            <p id="section-11.2-7.1.1">
   The client can simply decline to implement optimizations based on
   negative name caching on case-insensitive file systems.<a href="#section-11.2-7.1.1" class="pilcrow">¶</a></p>
<p id="section-11.2-7.1.2">
   While this might have a negative effect on performance where
   significant benefits from negative name caching might be expected,
   it might
   be the best option for clients not heavily used to access
   case-insensitive filesystems.<a href="#section-11.2-7.1.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>B2:</dt>
<dd id="section-11.2-7.2">
            <p id="section-11.2-7.2.1">
   Filtering similar to that discussed in item A2 could be implemented,
   although a higher limit is likely to be chosen
   (e.g. U+07ff) if significant use of non-Latin scripts is expected.
   Because of the uncertainty regarding the handling of case
   relationship among characters used for the variant of I used by
   Turkic languages, this filtering
   would have to exclude names containing LATIN CAPITAL LETTER I
   WITH DOT ABOVE and
   LATIN SMALL LETTER DOTLESS I together with precomposed characters 
   derived from them.<a href="#section-11.2-7.2.1" class="pilcrow">¶</a></p>
<p id="section-11.2-7.2.2">
   In cases in which such filtering did not exclude the item from
   consideration, it would need to search for files with possibly
   equivalent names, including those equivalent by canonical equivalence,
   case-insensitive equivalence, or a combination of the two.
   This will typically require a form of name hashing which
   always produces
   the same hash for equivalent names, similar to that discussed in
   item A3 but including case-insensitive equivalence as well.<a href="#section-11.2-7.2.2" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt>B3:</dt>
<dd id="section-11.2-7.3">
            <p id="section-11.2-7.3.1">
   A client might implement its own internationalized, case-insensitive
   file name
   handling paralleling that of the server.   Because the case mappings
   are uncertain and the Unicode
   version used by the server filesystem is unknown, strings for
   which it is possible that the equivalent string might
   be different depending on the version of Unicode implemented by the
   server or the choice of case mappings would have to be identified
   and excluded from using
   negative name caching.  This would require that strings containing
   code points unassigned in Unicode version 4.0, and those denoting
   combining characters that could be parts of precomposed characters
   added to later versions of Unicode be excluded from negative name
   caching.  The necessary filtering could apply to all
   potential code points although clients might choose to
   simplify implementation by excluding strings containing code points
   beyond a certain point (e.g. U+00FFFF).<a href="#section-11.2-7.3.1" class="pilcrow">¶</a></p>
<p id="section-11.2-7.3.2">
   When a client implements internationalized name handling, it needs
   to be able to detect when the apparent absence of a file within
   a directory is contradicted by the occurrence of a file with a
   distinct, but canonically equivalent name.  In order to efficiently
   find such names, when they exist, a client typically needs to
   implements a form of
   name hashing which always produces the same result for two
   canonically equivalent names.   This can be done by making the
   contribution of any character to the name hash, equal to contribution
   of the correspond canonical decomposition string.<a href="#section-11.2-7.3.2" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="CLIENT-future">
<section id="section-11.3">
        <h3 id="name-client-processing-of-file-na">
<a href="#section-11.3" class="section-number selfRef">11.3. </a><a href="#name-client-processing-of-file-na" class="section-name selfRef">Client Processing of File Names for Future NFSv4 Protocols</a>
        </h3>
<p id="section-11.3-1">
 Because of NFSv4 has an extension framework allowing the addition of
 new attributes in later minor version or in extensions to extensible
 minor versions.   Such new attributes are likely to be optional.
 They could include a number of useful per-fs attributes to deal with
 the information gaps discussed in <a href="#CLIENT-now" class="xref">Section 11.2</a>:<a href="#section-11.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-11.3-2.1">
   The Unicode version used to define the canonical equivalence
   relation implemented by the server could be provided as an
   fs-scope attribute.<a href="#section-11.3-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-11.3-2.2">
   For case-insensitive filesystems, details regarding the actual
   case mapping used could be provided as an fs-scope attribute.
   These details would include the case mapping associated with LATIN
   LETTER I (i.e. whether the C-type or T-type case mappings or both
   are to be used).   Similarly for characters having F-type case
   mappings, information needs to be provided about whether the F-type,
   mapping, the S-type mapping, or both, are to be used.<a href="#section-11.3-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-11.3-3">
 There is little prospect of such additional attributes being
 REQUIRED.   Although the term "RECOMMENDED" has been used to
 describe NFSv4 attributes that are not REQUIRED, any such
 attributes are best considered OPTIONAL for the server to
 support with the client required to deal with the case in
 which the attribute is not supported.<a href="#section-11.3-3" class="pilcrow">¶</a></p>
<p id="section-11.3-4">
 When such attributes are defined and implemented, it would be
 possible for the client and server to implement compatible
 internationalization-related file name handling.  However,
 as a practical matter, such compatibility would be considerably
 eased if there existed unencumbered open-source implementations
 of the algorithm and tables described in <a href="#FORMI" class="xref">Appendix B</a>.
 This would allow clients, servers, and server-based file systems,
 to easily adopt compatible approaches to these issues, each calling
 a common set of primitives, even though each might have a
 different execution environment and might be processing file names
 for different purposes.<a href="#section-11.3-4" class="pilcrow">¶</a></p>
<p id="section-11.3-5">
 In the case of case-sensitive file system, the case-mapping
 attribute is not relevant.  In dealing with the non-support of
 the Unicode version attribute, the client is in the same position
 as that of clients described in <a href="#CLIENT-now" class="xref">Section 11.2</a>.  In
 the case in which the Unicode version is supported, the client
 would be able to implement the same version of the canonical
 equivalence relation implemented by the server, thus avoiding the
 need for the sort of overbroad filtering mentioned in items A2 and
 A3 within <a href="#CLIENT-now" class="xref">Section 11.2</a><a href="#section-11.3-5" class="pilcrow">¶</a></p>
<p id="section-11.3-6"> 
        The case of case-insensitive file systems is more complicated,
 since there are two OPTIONAL attributes to deal with:<a href="#section-11.3-6" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-11.3-7">
<dt>C1:</dt>
<dd id="section-11.3-7.1">
   When neither of these OPTIONAL attributes is supported, the
   client is in the same position as that of clients described
   in <a href="#CLIENT-now" class="xref">Section 11.2</a> in dealing with a case-insensitive
   file system.<a href="#section-11.3-7.1" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt>C2:</dt>
<dd id="section-11.3-7.2">
   When the Unicode version is available but the details of
   case mapping are not, the client handling will be similar
   to that specified the options B1 through B3 defined in
   <a href="#CLIENT-now" class="xref">Section 11.2</a>.  However, in cases B2 and B3,
   it will be possible to reduce the scope of the character
   filtering applied, by enabling names containing characters
   defined after Unicode version 4.0 to be processed, as long as
   none of the case
   mapping options for those characters is at all problematic.<a href="#section-11.3-7.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt>C3:</dt>
<dd id="section-11.3-7.3">
   When the details of case mapping are available but Unicode
   version is not, the client handling will be similar
   to that specified the options B1 through B3 defined in
   <a href="#CLIENT-now" class="xref">Section 11.2</a>.  However, in cases B2 and B3
   However, in cases B2 and B3, it will be possible to reduce
   the scope of the character filtering by enabling names containing
   characters of uncertain case mapping to be processed as long as
   those character were defined in Unicode version 4.0.<a href="#section-11.3-7.3" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt>C4:</dt>
<dd id="section-11.3-7.4">
   When both of these OPTIONAL attributes are supported, the client
   has the ability, at least theoretically, to reproduce the
   internationalization-related file name handling implemented by a
   server for a case-insensitive file system.   However, when the
   client is unable to provide such an implementation, it is free
   to ignore the attribute and implement one of the options B1 through
   B3 defined in <a href="#CLIENT-now" class="xref">Section 11.2</a>.<a href="#section-11.3-7.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="OTHER">
<section id="section-12">
      <h2 id="name-string-types-with-processin">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-string-types-with-processin" class="section-name selfRef">String Types with Processing Defined by Other Internet Areas</a>
      </h2>
<p id="section-12-1">
      There are two types of strings that NFSv4 deals with that are based
      on domain names.  Processing of such strings is defined by other
      Internet standards, and hence the processing behavior for such
      strings should be consistent across all server operating systems
      and server file systems.<a href="#section-12-1" class="pilcrow">¶</a></p>
<p id="section-12-2">
      This section differs from other sections of this document in two
      respects:<a href="#section-12-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12-3.1">
 The normative statements within this section are not derived
 from the behavior from existing NFSv4 implementations, but
 derive instead from existing RFCs.<a href="#section-12-3.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-12-3.2">
 Because of the switch from IDNA2003 <span>[<a href="#RFC3490" class="xref">18</a>]</span>
          <span>[<a href="#RFC3491" class="xref">19</a>]</span> to IDNA2008 <span>[<a href="#RFC5890" class="xref">5</a>]</span>,
 this section is necessarily different from the corresponding
 section (i.e. Section 12.6) of <span>[<a href="#RFC7530" class="xref">3</a>]</span>. The
 differences are discussed in <a href="#OTHER-idna" class="xref">Section 12.1</a>.<a href="#section-12-3.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-12-4">
      Because of this shift, there could be compatibility issues to be
      expected between implementations  obeying Section 12.6 of
      <span>[<a href="#RFC7530" class="xref">3</a>]</span> and those following this document.   Whether
      such compatibility issues actually exist depends on the behavior of
      NFSv4 implementations and how domain names are actually used in
      existing implementations.  These matters will be discussed in
      <a href="#OTHER-compat" class="xref">Section 12.2</a>.<a href="#section-12-4" class="pilcrow">¶</a></p>
<p id="section-12-5">
      The types of strings referred to above are as follows:<a href="#section-12-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12-6.1">
          Server names as they appear in the fs_locations and
   fs_locations_info attribute.  Notes
          that for most purposes, such server names will only be sent by the
          server to the client.  The exception is the use of 
          these attributes in a VERIFY or NVERIFY operation.<a href="#section-12-6.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-12-6.2">
          Principal suffixes that are used to denote sets of users and
          groups, and are in the form of domain names.<a href="#section-12-6.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-12-7">
      The general rules for handling all of these domain-related strings
      are similar and independent of the role of the sender or receiver as
      client or server, although the consequences of failure to obey these
      rules may be different for client or server.  The server can report
      errors when it is sent invalid strings, whereas the client will
      simply ignore an invalid string or use a default value in its place.<a href="#section-12-7" class="pilcrow">¶</a></p>
<p id="section-12-8">
      The string sent SHOULD be in the form of one or more unvalidated
      U-labels
      as defined by <span>[<a href="#RFC5890" class="xref">5</a>]</span>.   In cases where this cannot
      be done, the string will
      instead be in the form of one or more LDH labels
      <span>[<a href="#RFC5890" class="xref">5</a>]</span>. The receiver
      needs to be able to accept domain and server names in any of
      the formats allowed. The server MUST reject, using the error
      NFS4ERR_INVAL, any of the following:<a href="#section-12-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12-9.1">
   a string that is not valid UTF-8.<a href="#section-12-9.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-12-9.2">
   a string that contains an XN‑label (begins with "xn--")
   for which the characters after "xn--" are not valid output of
   the Punycode algorithm <span>[<a href="#RFC3492" class="xref">6</a>]</span>.<a href="#section-12-9.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-12-9.3">
   a string that contains a reserved LDH label which is not an
   XN‑label.<a href="#section-12-9.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-12-10">
      When a domain string is part of id@domain or group@domain, there are
      two possible approaches:<a href="#section-12-10" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-12-11">
<li id="section-12-11.1">
          The server generally treats the domain string as a series of
   unvalidated
   U-labels.
          In cases where the domain string is a series of unvalidated A-labels
          or Non‑Reserved LDH (NR-LDH) labels, it converts them to
          U-labels using the Punycode algorithm <span>[<a href="#RFC3492" class="xref">6</a>]</span>.
          As a result, the domain string returned
          within a user id on a GETATTR may not match that sent when
          the user id is set using SETATTR, although when this
          happens, the domain will be in the form of an unvalidated U-label.<a href="#section-12-11.1" class="pilcrow">¶</a>
</li>
        <li id="section-12-11.2">
          The server treats the domain string
          as a series of unvalidated U-labels. Specifically, it does not map a
          domain string that is not a U-label into a U-label using
          the methods described above. As a result, the domain
          string returned on a GETATTR of the user id MUST be the
          same as that used when setting the user id by the SETATTR.<a href="#section-12-11.2" class="pilcrow">¶</a>
</li>
      </ol>
<p id="section-12-12">

      A server SHOULD use the first method.<a href="#section-12-12" class="pilcrow">¶</a></p>
<p id="section-12-13">
      For VERIFY and NVERIFY, additional string processing requirements
      apply to verification of the owner and owner_group attributes;
      see the section entitled "Interpreting owner and owner_group" for
      the document specifying the minor version in question 
      (RFC750 <span>[<a href="#RFC7530" class="xref">3</a>]</span>, RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span>)<a href="#section-12-13" class="pilcrow">¶</a></p>
<div id="OTHER-idna">
<section id="section-12.1">
        <h3 id="name-effect-of-idna-changes">
<a href="#section-12.1" class="section-number selfRef">12.1. </a><a href="#name-effect-of-idna-changes" class="section-name selfRef">Effect of IDNA Changes</a>
        </h3>
<p id="section-12.1-1">
 Overall, the effect of the shift to IDNA2008  is to limit the
 degree of understanding of the IDNA-based restrictions on domain names
 that were expected of NFSv4 in RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>.
 Despite this specification, the degree to which implementations
 actually implemented such restrictions is open to question and will
 be discussed in detail in <a href="#OTHER-compat" class="xref">Section 12.2</a><a href="#section-12.1-1" class="pilcrow">¶</a></p>
<p id="section-12.1-2">
        In analyzing how various cases are to be dealt with according to
        RFC7530, there a number of troubling uncertainties that arise in
        trying to interpret the existing specification:<a href="#section-12.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12.1-3.1">
   There are a number of cases in which "SHOULD" is used that are
   confusing.  According to RFC2119 <span>[<a href="#RFC2119" class="xref">1</a>]</span>, "SHOULD"
   means that "there may exist valid reasons in particular
   circumstances to ignore a particular item, but the full
   implications must be understood and
          carefully weighed before choosing a different course".   To
   fully understand a particular "SHOULD", there needs to be enough
   context to determine whether particular reasons for ignoring the
   item are in fact valid, and sufficient guidance to understand
   the implication of ignoring the item.  In the absence of such
   information, the relevant fact is that the peer needs to deal
   with the item being ignored, making the implications of 
   a "SHOULD" hard to distinguish from those of "MAY".<a href="#section-12.1-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-12.1-3.2">
   While the document states, "the general rules for handling all of
   these domain-related strings are similar and independent of the role
   of the sender or receiver as client or server", all of the following
   text is explicitly about the server's options, choices and
   responsibilities, leaving the client case unclear.<a href="#section-12.1-3.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-12.1-3.3">
   In a number of places within the paragraph describing server approach
   #1, the word "can" is used as in the text "the
          server can use the ToUnicode function", leaving it unclear whether
   the server can choose to do anything else and if so what.<a href="#section-12.1-3.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-12.1-4">
        The following cases are those where RFC7530 requires use of IDNA
 handling and this requirement could, if implementations follow them,
 create potential compatibility issues, which need to be understood.<a href="#section-12.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12.1-5.1">
   The degree to which RFC3490 <span>[<a href="#RFC3490" class="xref">18</a>]</span> requires that
   characters other than U+002E (full stop) be treated as label
   separators, including  U+3002 (ideographic full stop), U+FF0E
   (fullwidth full stop), U+FF61 (halfwidth ideographic full stop).<a href="#section-12.1-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-12.1-5.2">  
   The degree to which RFC3490 <span>[<a href="#RFC3490" class="xref">18</a>]</span> that server
   or client needs to validate a putative A-label or U-label or to
   rectify it if it is not valid.<a href="#section-12.1-5.2" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="OTHER-compat">
<section id="section-12.2">
        <h3 id="name-potential-compatibility-iss">
<a href="#section-12.2" class="section-number selfRef">12.2. </a><a href="#name-potential-compatibility-iss" class="section-name selfRef">Potential Compatibility Issues Related to IDNA Changes</a>
        </h3>
<p id="section-12.2-1">
 There are a number of factors relating to the handling of domain
 names within NFSv4 implementations that are important in
 understanding why any compatibility issues might be less troubling
 than a comparison of the two IDNA approaches might suggest:<a href="#section-12.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12.2-2.1">
   Much of the potentially conflicting IDNA-related behavior required
   or recommended for the server by RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>
   might not actually
   be implemented, limiting the potential harmful effects of ceasing to
   mandate it.<a href="#section-12.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-12.2-2.2">
   Even if such behavior were implemented by servers, no compatibility
   issue would arise unless clients actually relied on the server to
   implement it.   Given that none of this behavior is made
   required, the chances of that occurring is quite small.<a href="#section-12.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-12.2-2.3">
            <p id="section-12.2-2.3.1">
   The range of potential values for user and group attributes sent
   by clients are often quite small with implementations commonly
   restricting all such values to a single domain string.  This is even
   though
   RFCs 7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span> and 5661
   <span>[<a href="#RFC5661" class="xref">21</a>]</span> are written without mention of such
   restrictions.<a href="#section-12.2-2.3.1" class="pilcrow">¶</a></p>
<p id="section-12.2-2.3.2">
   Specification of users and groups in the "id@domain" format within
   NFSv4 was
   adopted to enable expansion of the spaces of users and groups
   beyond the 32-bit id spaces mandated in NFSv3 <span>[<a href="#RFC1813" class="xref">15</a>]</span>
   and NFsv2 <span>[<a href="#RFC1094" class="xref">14</a>]</span>.  While one obstacle to expansion
   was eliminated, most implementations were unable to actually effect
   that expansion, principally because the physical file systems used
   assume that user and group identifiers fit in 32 bits each and the
   vnode interfaces used by server implementations make similar
   assumptions.<a href="#section-12.2-2.3.2" class="pilcrow">¶</a></p>
<p id="section-12.2-2.3.3">
   Given these restrictions, the typical implementation pattern is
   for servers to accept only a single domain, specified as
   part of the server configuration, together with information
   necessary to effect the appropriate name-to-id mappings.<a href="#section-12.2-2.3.3" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-12.2-2.4">
   The other uses of domain names in NFSv4, to represent host names in
   location attributes, the values are generated by the server and
   will normally include only include host names within DNS-registered
   domains.<a href="#section-12.2-2.4" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-12.2-3">
 Keeping the above in mind, we can see that interoperability issues,
 while they might exist are unlikely to raise major challenges as
 looking to the following specific cases shows<a href="#section-12.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-12.2-4.1">
            <p id="section-12.2-4.1.1">
   When an internationalized domain name is used as part of a user
   or group, it would need to be configured as such, with the domain
   string known to both client and server.<a href="#section-12.2-4.1.1" class="pilcrow">¶</a></p>
<p id="section-12.2-4.1.2">
   While it is theoretically possible that a client might work with
   an invalid domain string and rely on the server to correct it to
   an IDNA-acceptable one, such a scenario has to be considered
   extremely unlikely, since it would depend on multiple servers
   implementing the same correction, especially since there is no
   evidence of such corrections ever having been implemented by
   NFSv4 servers.<a href="#section-12.2-4.1.2" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-12.2-4.2">
            <p id="section-12.2-4.2.1">
   When an internationalized domain in a location string is meant to
   specify a registered domain, similar considerations apply.<a href="#section-12.2-4.2.1" class="pilcrow">¶</a></p>
<p id="section-12.2-4.2.2">
   While it is theoretically possible that a client might work with
   an invalid domain string and rely on the server to correct it to
   the appropriate registered one, such a scenario has
   to be considered
   extremely unlikely, since it would depend on multiple servers
   implementing the same correction, especially since there is no
   evidence of such corrections ever having been implemented by
   NFSv4 servers.<a href="#section-12.2-4.2.2" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-12.2-4.3">
            <p id="section-12.2-4.3.1">
   When an internationalized domain in a location string is meant to
   specify a non-registered domain, any such server-applied
   corrections would be useless.<a href="#section-12.2-4.3.1" class="pilcrow">¶</a></p>
<p id="section-12.2-4.3.2">
   In this situation, any potential interoperability issue would
   arise from rejecting the name, which has to be considered as
   what should have been done in the first place.<a href="#section-12.2-4.3.2" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="UTF8ERR">
<section id="section-13">
      <h2 id="name-errors-related-to-utf-8">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-errors-related-to-utf-8" class="section-name selfRef">Errors Related to UTF-8</a>
      </h2>
<p id="section-13-1">
      Where the client sends an invalid UTF-8 string, the server MAY
      return an NFS4ERR_INVAL error.  This includes cases in which
      inappropriate prefixes are detected and where the count includes
      trailing bytes that do not constitute a full Multiple-Octet
      Coded Universal Character Set (UCS) character.<a href="#section-13-1" class="pilcrow">¶</a></p>
<p id="section-13-2">
      Requirements for server handling of component names that are not
      valid UTF-8, when a server does not return NFS4ERR_INVAL in response
      to receiving them, are described in <a href="#NONVALID" class="xref">Section 14</a>.<a href="#section-13-2" class="pilcrow">¶</a></p>
<p id="section-13-3">
      Where the string supplied by the client is not rejected with
      NFS4ERR_INVAL but contains characters that are not supported
      by the server as a value for that string (e.g., names containing
      slashes, or characters that do not fit into 16 bits when
      converted from UTF-8 to a Unicode codepoint), the server
      should return an NFS4ERR_BADCHAR error.<a href="#section-13-3" class="pilcrow">¶</a></p>
<p id="section-13-4">
      Where a UTF-8 string is used as a file name, and the file
      system, while supporting all of the characters within the
      name, does not allow that particular name to be used, the
      server should return the error NFS4ERR_BADNAME.  This includes
      such situations as file system prohibitions of "." and ".."
      as file names for certain operations, and similar constraints.<a href="#section-13-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="NONVALID">
<section id="section-14">
      <h2 id="name-servers-that-accept-file-co">
<a href="#section-14" class="section-number selfRef">14. </a><a href="#name-servers-that-accept-file-co" class="section-name selfRef">Servers That Accept File Component Names That Are Not Valid UTF-8 Strings</a>
      </h2>
<p id="section-14-1">
      As stated previously, servers MAY accept, on all or on some
      subset of the physical file systems exported, component names
      that are not valid UTF-8 strings.  A typical pattern is for
      a server to use UTF‑8-unaware physical file systems that treat
      component names as uninterpreted strings of bytes, rather
      than having any awareness of the character set being used.<a href="#section-14-1" class="pilcrow">¶</a></p>
<p id="section-14-2">
      Such servers SHOULD NOT change the stored representation of
      component names from those received on the wire and SHOULD
      use an octet-by-octet comparison of component name strings
      to determine equivalence (as opposed to any broader notion
      of string comparison).  This is because the server has no
      knowledge of the character encoding being used.<a href="#section-14-2" class="pilcrow">¶</a></p>
<p id="section-14-3">
      Nonetheless, when such a server uses a broader notion of
      string equivalence than what is recommended in the
      preceding paragraph, the following considerations apply:<a href="#section-14-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-14-4.1">
          Outside of 7-bit ASCII, string processing that changes string
          contents is usually specific to a character set and hence is
          generally unsafe when the character set is unknown.  This
          processing could change the file name in an unexpected fashion,
          rendering the file inaccessible to the application or client that
          created or renamed the file and to others expecting the original
          file name.  Hence, such processing should not be performed,
          because doing so is likely to result in incorrect string
          modification or aliasing.<a href="#section-14-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-14-4.2">
          Unicode normalization is particularly dangerous, as such
          processing assumes that the string is UTF-8.  When that assumption
          is false because a different character set was used to create the
          file name, normalization may corrupt the file name with respect to
          that character set, rendering the file inaccessible to the
          application that created it and others expecting the original
          file name.  Hence, Unicode normalization SHOULD NOT be performed,
          because it may cause incorrect string modification or aliasing.<a href="#section-14-4.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-14-5">
 
      When the above recommendations are not followed, the resulting
      string modification and aliasing can lead to both false negatives
      and false positives, depending on the strings in question, which can
      result in security issues such as elevation of privilege and
      denial of service (see <span>[<a href="#RFC6943" class="xref">23</a>]</span> for further discussion).<a href="#section-14-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="FUTURE">
<section id="section-15">
      <h2 id="name-future-minor-versions-and-e">
<a href="#section-15" class="section-number selfRef">15. </a><a href="#name-future-minor-versions-and-e" class="section-name selfRef">Future Minor Versions and Extensions</a>
      </h2>
<p id="section-15-1">
      As stated above, all current NFSv4 minor versions allow use of
      non-UTF-8 encodings, allow servers a choice of whether to
      be aware of normalization issues or not, and allows servers a number
      of choices about how to address normalization issues.  This range of
      choices reflects the need to accommodate existing file systems and user
      expectations about character handling which in turn reflect the
      assumptions of the POSIX model of handling file names.<a href="#section-15-1" class="pilcrow">¶</a></p>
<p id="section-15-2">
      While it is theoretically
      possible for a subsequent minor version to change these aspects of
      the protocol (see <span>[<a href="#RFC8178" class="xref">8</a>]</span>), this section will
      explain why any such change is highly unlikely, making it expected
      that these aspects of NFSv4 internationalization handling will be
      retained indefinitely.  As a result, any new minor
      version specification document that made such a change would
      have to be marked as updating or obsoleting this document<a href="#section-15-2" class="pilcrow">¶</a></p>
<p id="section-15-3">
      No such change could be done as an extension to an existing minor
      version or in a new minor version consisting only of OPTIONAL
      features.   Such a change could only be done in a new minor version,
      which like minor version one, was prepared to be incompatible to some
      degree with the previous minor versions.   While it appears unlikely
      that such minor versions will be adopted, the possibility cannot be
      excluded, so we need to explore the difficulties of changing the
      aspects of internationalization handling mentioned above.<a href="#section-15-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-15-4.1">
 Establishing UTF-8 as the sole means of encoding for internationalized
 characters, would make inaccessible existing files stored with other
 encodings.   Further, unless there were a corresponding change in
 the UNIX file interface model, it would cause the set of valid
 names for local and remote files to diverge.<a href="#section-15-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-15-4.2">
 Imposing a particular normalization form, in the sense of refusing
 to create to allow access to files whose UTF-8-encoded names are
 not of the selected normalization form would give rise to similar
 difficulties.<a href="#section-15-4.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-15-4.3">
 Defining a preferred normalization form to be returned as the names
 of all internationalized files, would result in applications having
 to deal with sudden unexplained changes of file names for existing
 files.<a href="#section-15-4.3" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-15-5">
      None of the above appears likely since there does not seem to be any
      corresponding benefits to justify the difficulties that
      they would create.<a href="#section-15-5" class="pilcrow">¶</a></p>
<p id="section-15-6">
      There would also be difficulties in otherwise reducing the set of 
      three acceptable normalization handling options, without reducing it
      to a single option by imposing a specific normalization form.<a href="#section-15-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-15-7.1">
          <p id="section-15-7.1.1">
 Eliminating the possibility of a single possible normalization
 form, would pose similar difficulties to imposing the other one,
 even if representation-independent comparisons were also allowed.<a href="#section-15-7.1.1" class="pilcrow">¶</a></p>
<p id="section-15-7.1.2">
        In either case, a specific normalization form would be disfavored,
        with no corresponding benefit.<a href="#section-15-7.1.2" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-15-7.2">
          <p id="section-15-7.2.1">
 Allowing only representation-independent lookups would not impose
 difficulties for clients, but there are reasons to doubt it
 could be universally implemented, since such name comparisons
 would have to be done within the file system itself.<a href="#section-15-7.2.1" class="pilcrow">¶</a></p>
<p id="section-15-7.2.2">
        Such a change could only be made once file system support
        for representation-independent file lookups would become commonly
        available.  As long as the POSIX file naming model continues
        its sway, that would be unlikely to happen.<a href="#section-15-7.2.2" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-15-8">

      One possible internationalization-related extension that
      the working could adopt would be definition of an OPTIONAL
      per-fs attribute defining the internationalization-related
      handling for that file system.   That would allow clients
      to be aware of server choices in this area and could be
      adopted
      without disrupting existing clients
      and servers.<a href="#section-15-8" class="pilcrow">¶</a></p>
<p id="section-15-9"></p>
</section>
</div>
<div id="IANA">
<section id="section-16">
      <h2 id="name-iana-considerations">
<a href="#section-16" class="section-number selfRef">16. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-16-1">
      The current document does not require any actions by IANA.<a href="#section-16-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="SEC">
<section id="section-17">
      <h2 id="name-security-considerations">
<a href="#section-17" class="section-number selfRef">17. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-17-1">
      Unicode in the form of UTF-8 is generally is used for file component
      names (i.e., both directory and file components).  However, 
      other character sets may also be allowed for these names.
      For the owner and owner_group attributes and other sorts strings
      whose form is affected by standards outside NFSv4 (see
      <a href="#OTHER" class="xref">Section 12</a>.) are always encoded as UTF-8.
      String processing (e.g., Unicode normalization) raises
      security concerns for string comparison.  See
      Sections <a href="#OTHER" class="xref">12</a> and
      <a href="#NORM" class="xref">9</a> as well as the respective
      Sections 5.9 of RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span> and
      RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span> 
      for further discussion. See <span>[<a href="#RFC6943" class="xref">23</a>]</span> 
      for related identifier comparison security considerations.  File
      component names are identifiers with respect to the identifier
      comparison discussion in <span>[<a href="#RFC6943" class="xref">23</a>]</span> because they are
      used to identify the objects to which ACLs are applied (See the
      respective Sections 6 of RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span> and
      RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span>).<a href="#section-17-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-18">
      <h2 id="name-references">
<a href="#section-18" class="section-number selfRef">18. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-18.1">
        <h3 id="name-normative-references">
<a href="#section-18.1" class="section-number selfRef">18.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[1]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[2]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7530">[3]</dt>
        <dd>
<span class="refAuthor">Haynes, T., Ed.</span> and <span class="refAuthor">D. Noveck, Ed.</span>, <span class="refTitle">"Network File System (NFS) Version 4 Protocol"</span>, <span class="seriesInfo">RFC 7530</span>, <span class="seriesInfo">DOI 10.17487/RFC7530</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7530">https://www.rfc-editor.org/info/rfc7530</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7862">[4]</dt>
        <dd>
<span class="refAuthor">Haynes, T.</span>, <span class="refTitle">"Network File System (NFS) Version 4 Minor Version 2 Protocol"</span>, <span class="seriesInfo">RFC 7862</span>, <span class="seriesInfo">DOI 10.17487/RFC7862</span>, <time datetime="2016-11" class="refDate">November 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7862">https://www.rfc-editor.org/info/rfc7862</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5890">[5]</dt>
        <dd>
<span class="refAuthor">Klensin, J.</span>, <span class="refTitle">"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework"</span>, <span class="seriesInfo">RFC 5890</span>, <span class="seriesInfo">DOI 10.17487/RFC5890</span>, <time datetime="2010-08" class="refDate">August 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5890">https://www.rfc-editor.org/info/rfc5890</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3492">[6]</dt>
        <dd>
<span class="refAuthor">Costello, A.</span>, <span class="refTitle">"Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)"</span>, <span class="seriesInfo">RFC 3492</span>, <span class="seriesInfo">DOI 10.17487/RFC3492</span>, <time datetime="2003-03" class="refDate">March 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3492">https://www.rfc-editor.org/info/rfc3492</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3629">[7]</dt>
        <dd>
<span class="refAuthor">Yergeau, F.</span>, <span class="refTitle">"UTF-8, a transformation format of ISO 10646"</span>, <span class="seriesInfo">STD 63</span>, <span class="seriesInfo">RFC 3629</span>, <span class="seriesInfo">DOI 10.17487/RFC3629</span>, <time datetime="2003-11" class="refDate">November 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8178">[8]</dt>
        <dd>
<span class="refAuthor">Noveck, D.</span>, <span class="refTitle">"Rules for NFSv4 Extensions and Minor Versions"</span>, <span class="seriesInfo">RFC 8178</span>, <span class="seriesInfo">DOI 10.17487/RFC8178</span>, <time datetime="2017-07" class="refDate">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8178">https://www.rfc-editor.org/info/rfc8178</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8881">[9]</dt>
        <dd>
<span class="refAuthor">Noveck, D., Ed.</span> and <span class="refAuthor">C. Lever</span>, <span class="refTitle">"Network File System (NFS) Version 4 Minor Version 1 Protocol"</span>, <span class="seriesInfo">RFC 8881</span>, <span class="seriesInfo">DOI 10.17487/RFC8881</span>, <time datetime="2020-08" class="refDate">August 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8881">https://www.rfc-editor.org/info/rfc8881</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC20">[10]</dt>
        <dd>
<span class="refAuthor">Cerf, V.</span>, <span class="refTitle">"ASCII format for network interchange"</span>, <span class="seriesInfo">STD 80</span>, <span class="seriesInfo">RFC 20</span>, <time datetime="1969-10" class="refDate">October 1969</time>, <span>&lt;<a href="http://www.rfc-editor.org/info/rfc20">http://www.rfc-editor.org/info/rfc20</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="UNICODE">[11]</dt>
        <dd>
<span class="refAuthor">The Unicode Consortium</span>, <span class="refTitle">"The Unicode Standard, Version 7.0.0"</span>, <span class="seriesInfo">(Mountain View, CA: The Unicode Consortium, 2014 ISBN 978-1-936213-09-2)</span>, <time datetime="2014-06" class="refDate">June 2014</time>, <span>&lt;<a href="http://www.unicode.org/versions/Unicode7.0.0/">http://www.unicode.org/versions/Unicode7.0.0/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="UNICODE-CASEM">[12]</dt>
        <dd>
<span class="refAuthor">The Unicode Consortium</span>, <span class="refTitle">"The Unicode Standard, Version 13.0.0, Section 5.18 Case Mappings"</span>, <span class="seriesInfo">(Mountain View, CA: The Unicode Consortium, 2014 ISBN 978-1-936213-26-9)</span>, <time datetime="2020-03" class="refDate">March 2020</time>, <span>&lt;<a href="http://www.unicode.org/versions/Unicode13.0.0/ch05.pdf#G21180">http://www.unicode.org/versions/Unicode13.0.0/ch05.pdf#G21180</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="UNICODE-CASEF">[13]</dt>
      <dd>
<span class="refAuthor">The Unicode Consortium</span>, <span class="refTitle">"CaseFolding-13.0.0.txt"</span>, <span class="seriesInfo">(Mountain View, CA: The Unicode Consortium, 2014 ISBN 978-1-936213-26-9)</span>, <time datetime="2020-03" class="refDate">March 2020</time>, <span>&lt;<a href="https://www.unicode.org/Public/13.0.0/ucd/CaseFolding.txt">https://www.unicode.org/Public/13.0.0/ucd/CaseFolding.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-18.2">
        <h3 id="name-informative-references">
<a href="#section-18.2" class="section-number selfRef">18.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC1094">[14]</dt>
        <dd>
<span class="refAuthor">Nowicki, B.</span>, <span class="refTitle">"NFS: Network File System Protocol specification"</span>, <span class="seriesInfo">RFC 1094</span>, <span class="seriesInfo">DOI 10.17487/RFC1094</span>, <time datetime="1989-03" class="refDate">March 1989</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1094">https://www.rfc-editor.org/info/rfc1094</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC1813">[15]</dt>
        <dd>
<span class="refAuthor">Callaghan, B.</span>, <span class="refAuthor">Pawlowski, B.</span>, and <span class="refAuthor">P. Staubach</span>, <span class="refTitle">"NFS Version 3 Protocol Specification"</span>, <span class="seriesInfo">RFC 1813</span>, <span class="seriesInfo">DOI 10.17487/RFC1813</span>, <time datetime="1995-06" class="refDate">June 1995</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1813">https://www.rfc-editor.org/info/rfc1813</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3010">[16]</dt>
        <dd>
<span class="refAuthor">Shepler, S.</span>, <span class="refAuthor">Callaghan, B.</span>, <span class="refAuthor">Robinson, D.</span>, <span class="refAuthor">Thurlow, R.</span>, <span class="refAuthor">Beame, C.</span>, <span class="refAuthor">Eisler, M.</span>, and <span class="refAuthor">D. Noveck</span>, <span class="refTitle">"NFS version 4 Protocol"</span>, <span class="seriesInfo">RFC 3010</span>, <span class="seriesInfo">DOI 10.17487/RFC3010</span>, <time datetime="2000-12" class="refDate">December 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3010">https://www.rfc-editor.org/info/rfc3010</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3454">[17]</dt>
        <dd>
<span class="refAuthor">Hoffman, P.</span> and <span class="refAuthor">M. Blanchet</span>, <span class="refTitle">"Preparation of Internationalized Strings ("stringprep")"</span>, <span class="seriesInfo">RFC 3454</span>, <span class="seriesInfo">DOI 10.17487/RFC3454</span>, <time datetime="2002-12" class="refDate">December 2002</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3454">https://www.rfc-editor.org/info/rfc3454</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3490">[18]</dt>
        <dd>
<span class="refAuthor">Faltstrom, P.</span>, <span class="refAuthor">Hoffman, P.</span>, and <span class="refAuthor">A. Costello</span>, <span class="refTitle">"Internationalizing Domain Names in Applications (IDNA)"</span>, <span class="seriesInfo">RFC 3490</span>, <span class="seriesInfo">DOI 10.17487/RFC3490</span>, <time datetime="2003-03" class="refDate">March 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3490">https://www.rfc-editor.org/info/rfc3490</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3491">[19]</dt>
        <dd>
<span class="refAuthor">Hoffman, P.</span> and <span class="refAuthor">M. Blanchet</span>, <span class="refTitle">"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)"</span>, <span class="seriesInfo">RFC 3491</span>, <span class="seriesInfo">DOI 10.17487/RFC3491</span>, <time datetime="2003-03" class="refDate">March 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3491">https://www.rfc-editor.org/info/rfc3491</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3530">[20]</dt>
        <dd>
<span class="refAuthor">Shepler, S.</span>, <span class="refAuthor">Callaghan, B.</span>, <span class="refAuthor">Robinson, D.</span>, <span class="refAuthor">Thurlow, R.</span>, <span class="refAuthor">Beame, C.</span>, <span class="refAuthor">Eisler, M.</span>, and <span class="refAuthor">D. Noveck</span>, <span class="refTitle">"Network File System (NFS) version 4 Protocol"</span>, <span class="seriesInfo">RFC 3530</span>, <span class="seriesInfo">DOI 10.17487/RFC3530</span>, <time datetime="2003-04" class="refDate">April 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3530">https://www.rfc-editor.org/info/rfc3530</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5661">[21]</dt>
        <dd>
<span class="refAuthor">Shepler, S., Ed.</span>, <span class="refAuthor">Eisler, M., Ed.</span>, and <span class="refAuthor">D. Noveck, Ed.</span>, <span class="refTitle">"Network File System (NFS) Version 4 Minor Version 1 Protocol"</span>, <span class="seriesInfo">RFC 5661</span>, <span class="seriesInfo">DOI 10.17487/RFC5661</span>, <time datetime="2010-01" class="refDate">January 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5661">https://www.rfc-editor.org/info/rfc5661</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6365">[22]</dt>
        <dd>
<span class="refAuthor">Hoffman, P.</span> and <span class="refAuthor">J. Klensin</span>, <span class="refTitle">"Terminology Used in Internationalization in the IETF"</span>, <span class="seriesInfo">BCP 166</span>, <span class="seriesInfo">RFC 6365</span>, <span class="seriesInfo">DOI 10.17487/RFC6365</span>, <time datetime="2011-09" class="refDate">September 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6365">https://www.rfc-editor.org/info/rfc6365</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6943">[23]</dt>
        <dd>
<span class="refAuthor">Thaler, D., Ed.</span>, <span class="refTitle">"Issues in Identifier Comparison for Security Purposes"</span>, <span class="seriesInfo">RFC 6943</span>, <span class="seriesInfo">DOI 10.17487/RFC6943</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6943">https://www.rfc-editor.org/info/rfc6943</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-nfsv4-rfc3010bis">[24]</dt>
        <dd>
<span class="refAuthor">Beame, C.</span>, <span class="refAuthor">Thurlow, R.</span>, <span class="refAuthor">Callaghan, B.</span>, <span class="refAuthor">Robinson, D.</span>, <span class="refAuthor">Noveck, D.</span>, <span class="refAuthor">Eisler, M.</span>, and <span class="refAuthor">S. Shepler</span>, <span class="refTitle">"Network File System (NFS) version 4 Protocol"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-nfsv4-rfc3010bis-05</span>, <time datetime="2002-11-07" class="refDate">7 November 2002</time>, <span>&lt;<a href="https://www.ietf.org/archive/id/draft-ietf-nfsv4-rfc3010bis-05.txt">https://www.ietf.org/archive/id/draft-ietf-nfsv4-rfc3010bis-05.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.williams-filesystem-18n">[25]</dt>
      <dd>
<span class="refAuthor">Williams, N.</span>, <span class="refTitle">"Internationalization Considerations for Filesystems and Filesystem Protocols"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-williams-filesystem-18n-00</span>, <time datetime="2020-07-06" class="refDate">6 July 2020</time>, <span>&lt;<a href="https://www.ietf.org/archive/id/draft-williams-filesystem-18n-00.txt">https://www.ietf.org/archive/id/draft-williams-filesystem-18n-00.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="HIST">
<section id="appendix-A">
      <h2 id="name-history">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-history" class="section-name selfRef">History</a>
      </h2>
<p id="appendix-A-1">
      This section describes the history of internationalization within NFSv4.
      Despite the fact that NFSv4.0 and subsequent minor versions
      have differed in many ways, the actual implementations of
      internationalization have 
      remained the same and internationalized names have been handled
      without regard to the minor version being used.  This is the reason the
      document is able to treat internationalization for all NFSv4
      minor versions
      together.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<p id="appendix-A-2">
      During the period from the publication of RFC3010 <span>[<a href="#RFC3010" class="xref">16</a>]</span>
      until now, two different perspectives with regard to internationalization
      have been held and represented, to varying degrees, in specifications
      for NFSv4 minor versions.<a href="#appendix-A-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A-3.1">
 The perspective held by NFSv4 implementers treated most aspects of
 internationalization
 as basically outside the scope of what NFSv4 client and server
 implementers could deal with.  This was because the POSIX interface
 treated file names as uninterpreted strings of bytes, because the
 file systems used by NFSv4 servers treated file names similarly, and
 because those file systems contained files with internationalized
 names using a number of different encoding methods, chosen by
 the users of the POSIX interface. From this perspective, wider
 support for internationalized names and general use of universal
 encodings was a matter for users and applications and not for
 protocol implementers or designers.<a href="#appendix-A-3.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-3.2">
 Within the IETF in general and in the IESG, there was a feeling
 that new protocols, such as NFSv4, could not avoid dealing with
 internationalization issues, making it difficult to treat these
 matters, as the implementers'
 perspective would have it, as essentially out of scope.<a href="#appendix-A-3.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-A-4">
      As specifications were developed, approved, and at times rewritten,
      this fundamental difference of approach was never fully resolved,
      although, with the publication of
      RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span>, a satisfactory
      modus vivendi may have been arrived at.<a href="#appendix-A-4" class="pilcrow">¶</a></p>
<p id="appendix-A-5">
      Although many specifications were published dealing with NFSv4
      internationalization, all minor versions used the same
      implementation approach, even  when the current specification for
      that minor version specified an entirely different approach.  As a
      result, we need to treat the history of NFSv4 internationalization
      below as an integrated whole, rather than treating individual minor
      versions separately.<a href="#appendix-A-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A-6.1">
          <p id="appendix-A-6.1.1">
 The approach to internationalization specified in 
 RFC3010 <span>[<a href="#RFC3010" class="xref">16</a>]</span> sidestepped the conflict
 of approaches cited above by
 discussing the reasons that UTF-8 encoding was desirable
 while leaving file names as uninterpreted strings of bytes.
 The issue of string normalization was avoided by saying
 "The NFS version 4 protocol does not mandate the use of
 a particular normalization form at this time."<a href="#appendix-A-6.1.1" class="pilcrow">¶</a></p>
<p id="appendix-A-6.1.2">
        Despite this approach's inconsistency with general IETF
        expectations regarding internationalization, RFC3010 was
 published as a Proposed Standard.   NFSv4.0 implementation related
 to internationalization of file names followed the same paradigm used
 by NFSv3, assuring interoperability with files created using
 that protocol, as well as with those created using local
 means of file creation.<a href="#appendix-A-6.1.2" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-A-6.2">
          <p id="appendix-A-6.2.1">
 When it became necessary, because of issues with byte-range
 locking, to create an rfc3010bis, no change to the
 previously approved approach seemed indicated and the
 drafts submitted up until 
 <span>[<a href="#I-D.ietf-nfsv4-rfc3010bis" class="xref">24</a>]</span>
 closely followed RFC3010 as regards internationalization.
 The IESG
 then decided that a different approach to internationalization
 was required, to be based on stringprep <span>[<a href="#RFC3454" class="xref">17</a>]</span>
 and rfc3010bis
 was accordingly revised, replacing all of the Internationalization
 section, before being published as
        RFC3530 <span>[<a href="#RFC3530" class="xref">20</a>]</span>.<a href="#appendix-A-6.2.1" class="pilcrow">¶</a></p>
<p id="appendix-A-6.2.2">
        These changes required the rejection of file names that were
        not valid UTF-8, file names that included code points not, at the
 time of publication, assigned a Unicode character (e.g. capital eszett)
 or that were not allowed by stringprep (e.g. Zero-width joiner and
 non-joiner characters).
 Because these restrictions would have caused the set of valid file
 names to be different on NFS-mounted and local file systems
 there was no chance of them ever being implemented.<a href="#appendix-A-6.2.2" class="pilcrow">¶</a></p>
<p id="appendix-A-6.2.3">
        Because these specification changes were made without working group
        involvement, most implementers were unaware of them while
 those who were aware of the changes ignored them and continued
 to develop implementations based on
 the internationalization approach specified in RFC3010.<a href="#appendix-A-6.2.3" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-A-6.3">
          <p id="appendix-A-6.3.1">
 When NFsv4.1 was being developed, it seemed that no changes
 in internationalization would be required.  Many people were
 unaware of the stringprep-based requirements which made the NFSv4.0
 internationalization specified in RFC3530 unimplementable.
 As a result, the internationalization specified in 
 RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span> was based on that
 in RFC3530 <span>[<a href="#RFC3530" class="xref">20</a>]</span>, although the addition of
 the attribute fs_charset_cap, discussed below, provided additional
 flexibility.<a href="#appendix-A-6.3.1" class="pilcrow">¶</a></p>
<p id="appendix-A-6.3.2">
        The attribute fs_charset_cap, discussed below in
        <a href="#CHARSET" class="xref">Section 7</a> provides flags allowing the server to
 indicate that it accepts and processes non-UTF-8 file names.
 Rejecting them
 was a "MUST" in RFC3530 and became a "SHOULD" in RFC5661, although
 there is no evidence that any of these designations ever affected
 server behavior.<a href="#appendix-A-6.3.2" class="pilcrow">¶</a></p>
<p id="appendix-A-6.3.3">
        As a result of this treatment of internationalization,
        even though NFSv4.1 was a separate
        protocol and could
        have had a different approach to internationalization, for a
 considerable time, the internationalization specification
 for both protocols was based on stringprep (in RFC3530 and
 RFC5661)  while the actual implementations of the two minor
 versions both followed the approach specified in RFC3010, despite
 its obsoleted status.<a href="#appendix-A-6.3.3" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-A-6.4">
          <p id="appendix-A-6.4.1">
 When work started on rfc3530bis it was clear that issues
        related to internationalization  had to be addressed.  When the
 implications of the stringprep references in RFC3530 were discussed with
 implementers it became clear that mandating that
 NFSv4.0 file names conform to stringprep was not appropriate.  While
 some working group members articulated the view that, because of the
 need to maintain compatibility with the POSIX interface and existing
 file systems, internationalization for NFSv4 could not be successfully
 addressed by the IETF, the rfc3530bis draft submitted to the IESG
 did not explicitly embrace the implementers' perspective set forth
 above.<a href="#appendix-A-6.4.1" class="pilcrow">¶</a></p>
<p id="appendix-A-6.4.2">
        The draft submitted to the IESG and
        RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span> as published provided an
 explanation (see <a href="#LIMITS" class="xref">Section 5</a>) as to why restrictions on
 character encodings were not viable.  It allowed non-UTF-8 encodings to
 be used for internationalized file names while defining UTF-8 as the
 preferred encoding and allowing
 servers to reject non-UTF-8 string as invalid.   Other
 stringprep-based string restrictions were eliminated.
 With regard to
 normalization, it continued to defer the matter, leaving open the
 possibility that one might be chosen later.<a href="#appendix-A-6.4.2" class="pilcrow">¶</a></p>
<p id="appendix-A-6.4.3">
        This approach is compatible, in implementation terms, with that
        specified in RFC3010 <span>[<a href="#RFC3010" class="xref">16</a>]</span>, allowing it to
 be used compatibly with existing implementations for all existing
 minor versions.   This is despite the fact that
 RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span> specifies an entirely
 different approach.<a href="#appendix-A-6.4.3" class="pilcrow">¶</a></p>
<p id="appendix-A-6.4.4">
        As a result of discussions leading up to the publishing of
        RFC7530, it was discovered that some local file systems used
 with NFSv4 were configured to be both normalization-aware and
 normalization-preserving, mapping all canonically equivalent
 file names to the same file while preserving the form actually
 used to create the file, of whatever form, normalized or not.
 This behavior, which is legal according to RFC3010, which says
 little about name mapping is probably illegal according to stringprep.
 Nevertheless, it was expressly pointed out in RFC7530 as a valid
 choice to deal with normalization issues, since it allows
 normalization-aware processing without the difficulties that
 arise in imposing a particular normalization form, as described in
 <a href="#NORM" class="xref">Section 9</a>.<a href="#appendix-A-6.4.4" class="pilcrow">¶</a></p>
<p id="appendix-A-6.4.5">
        In its discussion of internationalized domain names,
        RFC7530 <span>[<a href="#RFC7530" class="xref">3</a>]</span> adopted an approach compatible
 with IDNA2003,
 rather than attempting to derive the specification from the behavior
 of existing implementations.<a href="#appendix-A-6.4.5" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-A-6.5">
 When IDNA2003 was replaced by IDNA2008, the internationalization
 specified by <span>[<a href="#RFC7530" class="xref">3</a>]</span> was not changed.  Also, it
 appears unlikely that implementations were changed to reflect that
 shift.<a href="#appendix-A-6.5" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-6.6">
          <p id="appendix-A-6.6.1">
 NFSv4.2 made no changes to internationalization.  As a result,
 RFC7862 <span>[<a href="#RFC7862" class="xref">4</a>]</span> which made no mention of
 internationalization, implicitly aligned internationalization
 in NFSv4.2 with that in NFSv4.1, as specified by
 RFC5661 <span>[<a href="#RFC5661" class="xref">21</a>]</span>.<a href="#appendix-A-6.6.1" class="pilcrow">¶</a></p>
<p id="appendix-A-6.6.2">
        As a result of this implicit alignment, there is no need for this
        document to specifically address NFSv4.2 or be marked as updating
 RFC7862.  It is sufficient that it updates RFC5661, which specifies
 the internationalization for NFSv4.1, inherited by NFSv4.2.<a href="#appendix-A-6.6.2" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-A-6.7">
 Later, as work on the predecessors of this document was underway,
 <span>[<a href="#I-D.williams-filesystem-18n" class="xref">25</a>]</span> was submitted, making
 it necessary that some gaps the discussion of internationalization
 in <span>[<a href="#RFC7530" class="xref">3</a>]</span> be filled in.  These gaps primarily
 concerned the need of NFSv4 clients to match the handling of the
 corresponding server when using cached file name data locally, or
 to avoid making invalid assumptions about that handling, when
 information on the details of such handling was not available.<a href="#appendix-A-6.7" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-A-7">
      The above history, can, for the purposes of the rest of this document
      be summarized in the following statements:<a href="#appendix-A-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A-8.1">
 The actual treatment of internationalization within NFSv4 has not
 been affected by the particular minor version used, despite the fact
 that the specifications for the minor versions have often differed
 in their treatment of internationalization.<a href="#appendix-A-8.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-8.2">
 With regard to file names, implementations have followed the
 internationalization approach
 specified in RFC3010, which is compatible with the treatment in
 RFC7530.<a href="#appendix-A-8.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-8.3">
 With regard to internationalized domain names, RFC7530
 <span>[<a href="#RFC7530" class="xref">3</a>]</span> specified an approach compatible
 with IDNA at the time of publication.  However, no detailed
 analysis was done to determine whether NFSv4 implementations
 actually followed that approach<a href="#appendix-A-8.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-A-8.4">
 Because <span>[<a href="#RFC7530" class="xref">3</a>]</span> did not specifically address the
 special issues that clients would face, relying on the assumption
 that each file is accessible only by its name.   As this assumption
 is no longer true when internationalized name handling is in effect,
 the appropriate handling is discusssed below.
 <a href="#CLIENT-now" class="xref">Section 11.2</a> explains the options for handling in
 the case in which the client has very limited information about the
 details about the server's internationalization-related handling of
 file names while <a href="#CLIENT-future" class="xref">Section 11.3</a> discusses how a
 client might use more complete information provided by new
 attributes.<a href="#appendix-A-8.4" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-A-9">
      In order to deal with all NFSv4 minor versions, this document
      follows the internationalization approach defined in RFC7530, with
      some changes discussed in <a href="#CHG7530" class="xref">Section 4</a> and applies that
      approach to all NFSv4 minor versions.<a href="#appendix-A-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="FORMI">
<section id="appendix-B">
      <h2 id="name-form-insensitive-string-com">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-form-insensitive-string-com" class="section-name selfRef">Form-insensitive String Comparisons</a>
      </h2>
<p id="appendix-B-1">
      This section deal with two varieties of form-insensitive string
      comparison:<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-2.1">
 Providing a comparison function which is form-insensitive only.  For
 any string, whether normalized or not, this function will determine it
 to be equivalent to all canonically equivalent strings,
 including but not
 limited, to the normalized forms NFC and NFD<a href="#appendix-B-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-B-2.2">
 Providing a comparison function which is both form-insensitive and
 case-insensitive.  This function will determine strings that only
 differ in case to be equal but will also be form-insensitive, as
 described above.<a href="#appendix-B-2.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-B-3">
      The non-normative guidance provided in this Appendix is intended to
      be helpful to two distinct implementation areas:<a href="#appendix-B-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-4.1">
 Implementation of server-side file systems intended to be accessed
 using NFSv4 protocols.   While it is often the case that such
 filesystems are developed by separate organizations from those
 concerned with NFSv4 server development, the internationalization-
 related requirements specified in this document must be adhered to
 for successful inter-operation, making this implementation guidance
 apropos despite any potential organizational barriers.<a href="#appendix-B-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="appendix-B-4.2">
 Implementation of NFSv4 clients that need to provide matching
 internationalization-related handling for reason discussed in
 <a href="#CLIENT" class="xref">Section 11</a>.<a href="#appendix-B-4.2" class="pilcrow">¶</a>
</li>
      </ul>
<p id="appendix-B-5">
      There are three basic reasons that two strings being compared
      might be canonically equivalent even though not identical. For
      each such reason, the implementation will be similar in the
      cases in which form-insensitive comparison (only) is being done
      and in which the comparison is both case-insensitive and form-
      insensitive.<a href="#appendix-B-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-6.1">
          <p id="appendix-B-6.1.1">
 Two strings may differ only because each has a different one of two
 code points that are essentially the same. Three code points
 assigned to represent units, are essentially equivalent to the
 character denoting those units.  For example, the OHM SIGN (U+2126)
 is essentially identical to the GREEK CAPITAL LETTER OMEGA (U+03A9)
 as MICRO SIGN (U+00B5) is to GREEK SMALL LETTER MU (U+03BC) and
 ANGSTROM SIGN (U+212B) is to 
 LATIN CAPITAL LETTER A WITH RING ABOVE (U+00C5).<a href="#appendix-B-6.1.1" class="pilcrow">¶</a></p>
<p id="appendix-B-6.1.2">
        As discussed in items EX2 and EX3 in <a href="#CASEI-ex" class="xref">Section 10.2</a>, it
        is possible to adjust for this situation using tables designed to
 resolve case-insensitive equivalence, essentially treating the
 unit symbols as an additional case variant, essentially
 ignoring the fact that the
 graphic representation is the same.  As a result, those doing string
 comparisons that are both form-insensitive and case-insensitive do
 not need to address this issue as part of form-insensitivity, since
 it would be dealt with by existing case-insensitive comparison logic.<a href="#appendix-B-6.1.2" class="pilcrow">¶</a></p>
<p id="appendix-B-6.1.3">
        Where there is no case-insensitive comparison logic, this function
        needs to be performed using similar tables whose primary function
 is to provide the decomposition of precomposed characters, as
 described in <a href="#FORMI-table" class="xref">Appendix B.2</a>.<a href="#appendix-B-6.1.3" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-B-6.2">
          <p id="appendix-B-6.2.1">
 Two strings may differ in that one has the decomposed form
 consisting of a base
 character and an associated combining character while the other has
 a precomposed character equivalent.<a href="#appendix-B-6.2.1" class="pilcrow">¶</a></p>
<p id="appendix-B-6.2.2">
        Although, as discussed in items EX3 in <a href="#CASEI-ex" class="xref">Section 10.2</a>, it
        is possible to use tables designed to resolve case-insensitive
 equivalence by providing as possible case-insensitively equivalent
 string, multi-character string providing the decomposition of
 precomposed characters, special logic to do so is only necessary
 when the decomposition is not a canonical one, i.e. it is a
 compatibility equivalence.<a href="#appendix-B-6.2.2" class="pilcrow">¶</a></p>
<p id="appendix-B-6.2.3">
        In general, the table used to do comparisons, whether case-sensitive
        or not, need to provide information about the canonical
 decomposition of precomposed characters.  See
 <a href="#FORMI-table" class="xref">Appendix B.2</a> for details.<a href="#appendix-B-6.2.3" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-B-6.3">
          <p id="appendix-B-6.3.1">
 Two strings may differ in that the strings consist of
 combining characters that have the same effect differ as to the
 order in which the characters appear.<a href="#appendix-B-6.3.1" class="pilcrow">¶</a></p>
<p id="appendix-B-6.3.2">
        There is no way this function could be performed within code
        primarily devoted to case-insensitive equivalence.  However,
 this function could be added to implementations, providing
 both sorts of equivalence once it is determined that the base
 characters are case-equivalent while there is a difference of
 combining characters in to be resolved.  (See
 <a href="#FORMI-combining" class="xref">Appendix B.5</a> for a discussion of how
 sets of combining characters can be compared).<a href="#appendix-B-6.3.2" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="appendix-B-7"></p>
<div id="FORMI-hash">
<section id="appendix-B.1">
        <h3 id="name-name-hashes">
<a href="#appendix-B.1" class="section-number selfRef">B.1. </a><a href="#name-name-hashes" class="section-name selfRef">Name Hashes</a>
        </h3>
<p id="appendix-B.1-1">
 We discussed in <a href="#CASEI-impl" class="xref">Section 10.1</a> the construction of a
 case-insensitive file name hash.   While such a hash could also
 be form-insensitive if the hash contribution of every
 pre-composed character matched the combined contribution of the
 characters that it decomposes into.<a href="#appendix-B.1-1" class="pilcrow">¶</a></p>
<p id="appendix-B.1-2">
 However, there is no obvious way that sort of hash could respect
 the canonical equivalence of multiple combining characters
 modifying the same base character, when those combining
 characters appear in different orders.  Addressing that issue
 would require a significantly different sort of hash, in which
 combining characters are treated differently from others, so that
 the re-ordering of a string of combining characters applying to the
 same base character will not affect the hash.<a href="#appendix-B.1-2" class="pilcrow">¶</a></p>
<p id="appendix-B.1-3">
 In the hash discussed in <a href="#CASEI-impl" class="xref">Section 10.1</a>, there is no
 guarantee that the hash for multiple combining characters
 presented in different orders will be the same.   This is because
 typically such hashes implement some transformation on the
 existing hash, together with adding the new character to the hash
 being accumulated.  Such methods of hash construction will
 arrive at different values if
 the ordering of combining characters changes.<a href="#appendix-B.1-3" class="pilcrow">¶</a></p>
<p id="appendix-B.1-4">
 In order to create a hash with the necessary characteristics, one can
 construct a separate sub-hash for composite character, consisting
 of one non-combining character (may be pre-composed) together with the
 set (possibly null) of combining characters immediately following it.
 Each such composed character, whether precomposed or not, will have
 its own sub-hash, which will be the same regardless of the order of
 the combining characters.<a href="#appendix-B.1-4" class="pilcrow">¶</a></p>
<p id="appendix-B.1-5">
 If the hash is to include case-insensitivity, special handling is
 needed to deal with issues arising from the handling of
 COMBINING GREEK YPOGEGRAMMENI (U+0345).   That combining character, as
 discussed in item EX6 of <a href="#CASEI-ex" class="xref">Section 10.2</a> is uppercased to
 the non-combining character GREEK CAPITAL LETTER IOTA (U+0399) which is
 in turn lowercased to the non-combining character GREEK SMALL
 LETTER IOTA (U+03B9).  As a result,  when computing a case-insensitive
 hash, when a base character is IOTA (of either case) and the previous
 base character is ALPHA, ETA, or OMEGA (of the same case as the IOTA),
 that IOTA is treated, for the purpose of defining the composite
 characters for which to generate sub-hashes as if it were a combining
 character.  As a result, in this case a string of containing two
 composite characters will be treated as were a single
 composite character since the iota will be treated as if it were a
 combining character.   This string will have its own sub-hash, which
 will be the same regardless of the order of combining characters.<a href="#appendix-B.1-5" class="pilcrow">¶</a></p>
<p id="appendix-B.1-6">
 The same outline will be followed for generating hashes which are
 to be form-insensitive (only) and for those which are to be both
 form-insensitive and case-insensitive. The initial value, representing
 the base character, will differ based on the type of hash.<a href="#appendix-B.1-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.1-7.1">
   In the case-sensitive case, the initial value of the sub-hash
   will reflect the value of the base character with the only possible
   need to map to a different value deriving from the existence of
   OHM SIGN (U+2126), ANGSTROM SIGN (U+212B), and MICRO SIGN (U+00B5)
   as characters distinct from the letters that represent these code
   points.
   This could be done with a mapping table but most implementations
   would probably choose to implement special-purpose code to do this.<a href="#appendix-B.1-7.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.1-7.2">
   In the case-insensitive case, the initial value of the sub-hash
   will reflect the case-based equivalence class to which the
   character (the lower-case equivalent is generally suitable). In
   this context a table-based mapping is required and this mapping
   can shift OHM SIGN, ANGSTROM SIGN, and MICRO SIGN to the case-based
   equivalence class for the corresponding character.<a href="#appendix-B.1-7.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.1-8">
        Regardless of the type of hash to be produced, values based on the
        following combining characters need to reflected in the sub-hash.
 In order to make the sub-hash invariant to changes in the order of
 combining characters, values based on the particular combining
 character are combined with the hash being computed using a commutative
 associative operation, such as addition.<a href="#appendix-B.1-8" class="pilcrow">¶</a></p>
<p id="appendix-B.1-9">
 To reduce false-positives it is desirable to make the hash relatively
 wide (i.e. 32-64 bits) with the value based on base character in the
 upper portion of the word with the values for the combining
 characters appearing in a wide range of bit positions in the rest
 of the word to limit the degree that multiple distinct sets of
 combining characters have value that are the same.  Although the details
 will be affected by processor cache structure and the distribution
 of names processed, a
 table of values will be used but typical implementations will be
 different in the two cases we are dealing as described in
 <a href="#FORMI-table" class="xref">Appendix B.2</a>.<a href="#appendix-B.1-9" class="pilcrow">¶</a></p>
<p id="appendix-B.1-10">
 As each sub-hash is computed, it is combined into a name-wide hash.
 There is no need for this computation to be order-independent and it
 will probably include a circular shift of the hash computed so far
 to be added to the contribution of the sub-hash for the new base
 or composed character.<a href="#appendix-B.1-10" class="pilcrow">¶</a></p>
<p id="appendix-B.1-11">
 As described in <a href="#FORMI-outline" class="xref">Appendix B.3</a> the appropriate
 full name hash will have the major role in excluding potential
 matches efficiently.  However, in some small number of cases, there
 will be a hash match in which the names to be compared are not
 equivalent, requiring more involved processing.   It is assumed below
 that a given name will be searching for potential cached matches
 within the directory so that for that name, on will be able retain
 information used to construct the full name hash (e.g. individual
 sub-hashes plus the bounds of each composite character.   These will
 be compared against cached entries where only the full (e.g. 64-bit)
 name hash and the name itself will be available for comparison.<a href="#appendix-B.1-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="FORMI-table">
<section id="appendix-B.2">
        <h3 id="name-character-tables">
<a href="#appendix-B.2" class="section-number selfRef">B.2. </a><a href="#name-character-tables" class="section-name selfRef">Character Tables</a>
        </h3>
<p id="appendix-B.2-1">
 The per-character tables used in these algorithms have a number
 of type of entries for different types of characters.   In some
 cases, information for a given character type will be essentially
 the same whether the comparison is to be form-insensitive or case-
 insensitive.   In others, there will be differences.  Also, there
 may be entry types that only exist for particular types of
 comparisons.   In any case, some bits within the table entry will
 be devoted to representing the type of character and entry:<a href="#appendix-B.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.2-2.1">
   For combining characters, the entry will provide information
   about the character's contribution to the composite character
   sub-hash in which it appears.<a href="#appendix-B.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.2">
   For case-insensitive comparisons, there need to be special
   entries for characters, which, while not themselves combining
   characters, are the case-insensitive equivalents of combining
   characters.   An example of this situation is provided in item
   EX6 within <a href="#CASEI-ex" class="xref">Section 10.2</a><a href="#appendix-B.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.3">
   For pre-composed characters, the entry needs to provide the initial
   hash value which is to be the basis for the sub-hash for the
   name substring including contributions for the base character
   together with contribution of included combining characters.
   In addition, such entries will provide, separately, information
   about the character's canonical decomposition.<a href="#appendix-B.2-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.4">
   For case-insensitive comparisons, there needs to be,
   for base characters, entries assigning each base character to
   the case-based equivalence class to which it belongs, although
   such entries can be avoided if the equivalence class matches
   the character (usually caseless and lowercase characters.<a href="#appendix-B.2-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.5">
   Also, for case-insensitive comparisons, there will need
   to be special entries for characters which multi-character
   string as case-insensitive equivalent of the base character.
   Examples of this situation are provided in items EX4 and EX5
   within <a href="#CASEI-ex" class="xref">Section 10.2</a>.   Such entries will need to
   have a hash-contribution that reflects the hash that would be
   computed for the multi-character string.<a href="#appendix-B.2-2.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-2.6">
   For form-insensitive comparisons, there will be special
   entries to provide special handling for those cases in which
   there are two canonically equivalent single characters.  Such entries
   do not exist for case-insensitive comparison since this situation
   can be handled by a non-standard use of
   case mapping for base characters by placing these two characters
   in the same case-based equivalence<a href="#appendix-B.2-2.6" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.2-3">
 In the common case in which a two-stage mapping will be used,
 there will be common groups of characters in which no table entry
 will be required, allowing a default entry type to be used for some
 character groups with entry
 contents easily calculable from the code point.<a href="#appendix-B.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.2-4.1">
   In the case form-insensitive comparison, this consists of all
   base characters, with the hash contribution of the character
   derivable by a pre-specified transformation of the code point value.<a href="#appendix-B.2-4.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.2-4.2">
   In the case case-insensitive comparison, this consists of all
   base character which are either caseless or equivalence class
   is the same as the code point, typically lowercase characters.
   As in the form-insensitive case, the hash contribution of the
   character is derivable by a pre-specified transformation of the
   code point value, which matches, in this case, the id assigned
   to the case-based equivalence class.<a href="#appendix-B.2-4.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.2-5"></p>
</section>
</div>
<div id="FORMI-outline">
<section id="appendix-B.3">
        <h3 id="name-outline-of-comparison">
<a href="#appendix-B.3" class="section-number selfRef">B.3. </a><a href="#name-outline-of-comparison" class="section-name selfRef">Outline of comparison</a>
        </h3>
<p id="appendix-B.3-1">
 We are assuming that comparisons will be based on the hash values
 computed as described in <a href="#FORMI-hash" class="xref">Appendix B.1</a>, whether the
 comparison is to be form-insensitive or both case-insensitive and
 form-insensitive.<a href="#appendix-B.3-1" class="pilcrow">¶</a></p>
<p id="appendix-B.3-2">
 To facilitate this comparison, the name hash will be stored with
 the names to be compared.   As a result, when there is a need to
 investigate a new name and whether there are existing matches,
 it will be possible to search for matches with existing names cached
 for that directory, using a hash for the new name which is computed
 and compared
 to all the existing names, with the result that the detailed
 comparisons described in Appendices
 <a href="#FORMI-base" class="xref">B.4</a> and
 <a href="#FORMI-combining" class="xref">B.5</a> have to be
 done relatively rarely, since non-matching names together with
 matching hashes are likely to be atypical.<a href="#appendix-B.3-2" class="pilcrow">¶</a></p>
<p id="appendix-B.3-3">
 Given the above, it is a reasonable assumption, which we will take
 note of in the sections below, that for one of the names to be
 compared, we will have access to data generated in the process of
 computing the name hash while for the other names, such data would
 have to be generated anew, when necessary.  When that data includes,
 as we expect it will, the offset and length of the string regions
 covered by each sub-hash, direct byte-by-byte comparisons between
 corresponding regions of the two strings can exclude the possibility
 of difference without invoking any detailed logic to deal with
 the possibility of canonical equivalence or case-based equivalence
 in the absence of identical name segment.<a href="#appendix-B.3-3" class="pilcrow">¶</a></p>
<p id="appendix-B.3-4">
 In the case in which the byte-by-byte comparisons fail, further
 analysis is necessary:<a href="#appendix-B.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.3-5.1">
   First, the associated base characters are compared, as is discussed
   in <a href="#FORMI-base" class="xref">Appendix B.4</a>.   When doing form-insensitive
   comparison this is straightforward.  However, when case-insensitive
   comparison is to be done, there is the possibility that the
   sub-hash boundaries of the two comparands are different, requiring
   that a common point in both comparands be found to resume
   comparison after a successful match.   For either form of
   comparison, if a mismatch is found at this point then the
   comparison fails, while, if there is match, there must be a
   comparison of any following combining characters, as described
   below, before moving on to the region covered by the appropriate
   sub-string covered by the appropriate next sub-hash for each
   comparand.<a href="#appendix-B.3-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-5.2">
   If there is no mismatch as to the base characters, the set of
   associated combining characters (might be null) must be compared,
   as is discussed in <a href="#FORMI-combining" class="xref">Appendix B.5</a>.  If a mismatch
   is found at this point then the comparison fails.  This may be
   because the sets of combining characters are different, because there
   are multiple copies of the same combining character in one of the
   string, or because the difference in combining character is not one
   that maintains canonical equivalence (due to combining classes).<a href="#appendix-B.3-5.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.3-5.3">
   When both comparisons show a match, the comparison resumes at the
   next substring, using a byte-by-byte comparison initially.  If the
   comparison cannot be resumed because one of the strings is
   exhausted, the comparison terminate, succeeding only if both
   strings are exhausted while failing if only one of the strings
   is exhausted.<a href="#appendix-B.3-5.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="FORMI-base">
<section id="appendix-B.4">
        <h3 id="name-comparing-base-characters">
<a href="#appendix-B.4" class="section-number selfRef">B.4. </a><a href="#name-comparing-base-characters" class="section-name selfRef">Comparing Base Characters</a>
        </h3>
<p id="appendix-B.4-1">
 In general, the task of comparing based characters is simple, using
 a table lookup using the numeric value of the initial character in
 the substring.   When doing form-insensitive comparison this is the
 base character associated with the initial (possibly pre-composed)
 character, while for case-insensitive comparison it is the case-based
 equivalence class associated with that character.<a href="#appendix-B.4-1" class="pilcrow">¶</a></p>
<p id="appendix-B.4-2">
 When doing case-insensitive comparison, issues may arise that
 result when there is a multi-character string that as the case-
 insensitive equivalent of a single base character, as discussed
 in items EX4 and EX5 within <a href="#CASEI-ex" class="xref">Section 10.2</a>.   These are
 best dealt with using the approach outlined in
 <a href="#CASEI-impl" class="xref">Section 10.1</a>.   When it is noted that the current
 base character (for either comparand) is a character whose
 associated equivalence class contains one or more multi-character
 strings, then these comparisons, normally requiring that each
 base character be mapped to the same case-based equivalence class
 by modified to allow equivalences allowed by these multi-character
 sequences.<a href="#appendix-B.4-2" class="pilcrow">¶</a></p>
<p id="appendix-B.4-3">
 In such cases, there may need to be comparisons involving the
 multi-character string, in addition to the normal comparisons
 using the base characters' equivalence class.   As an illustration,
 we will consider possible comparison results that involve
 characters string within the equivalence class mentioned in item
 EX4 within <a href="#CASEI-ex" class="xref">Section 10.2</a><a href="#appendix-B.4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.4-4.1">
   When the base character for both comparands are either 
          LATIN SMALL LETTER SHARP S (U+00DF) or LATIN
   CAPITAL LETTER SHARP S (U+1E9E), then a match is recognized.<a href="#appendix-B.4-4.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.4-4.2">
   When the base character for one comparand is either 
          LATIN SMALL LETTER SHARP S (U+00DF) or LATIN
   CAPITAL LETTER SHARP S (U+1E9E), while the other is not,
   each character in the that other comparand is case-insensitively
   compared to the corresponding character of the string "ss" with
   a match being signaled when all such subsequent characters match,
   except for possibly being of a different case.  Because that
   comparison will involve multiple base characters, the overall
   comparison point for that comparand will have to be adjusted to
   reflect character already processed as part of the comparison.<a href="#appendix-B.4-4.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.4-4.3">
   When the base character for neither comparands is either 
          LATIN SMALL LETTER SHARP S (U+00DF) or LATIN
   CAPITAL LETTER SHARP S (U+1E9E), then matching proceeds
   normally.   As a result, the only cases in which character strings
   within the equivalence class being discussed will result is
   where both comparands have one of the strings "ss", "sS", "Ss", or
   "SS" at the current comparison point.<a href="#appendix-B.4-4.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="FORMI-combining">
<section id="appendix-B.5">
        <h3 id="name-comparing-combining-charact">
<a href="#appendix-B.5" class="section-number selfRef">B.5. </a><a href="#name-comparing-combining-charact" class="section-name selfRef">Comparing Combining Characters</a>
        </h3>
<p id="appendix-B.5-1">
 In order to effect the necessary comparison, one needs to assemble,
 for each comparand, the set of combining characters within the
 current substring.   The means used might be different for different
 comparands since there
 might be useful information retained from the generation of the
 associated string hash for one of the comparands.  In any case,
 there are two potential sources for these characters:<a href="#appendix-B.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.5-2.1">
   Those deriving from the canonical decomposition of a pre-composed
   character, treated as a null set of if the base character is
   not a precomposed one.<a href="#appendix-B.5-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.5-2.2">
   Those combining characters that immediate following the base
   character, which will be a null set if the immediately following
   character is not a combining character.  Note that it is possible,
   when doing case-insensitive comparison to treat certain character,
   not normally combining characters, as if they are.  Such situations
   can arise, when, as described in item EX6 within
   <a href="#CASEI-ex" class="xref">Section 10.2</a>, such non-combining character are the
   uppercase or lowercase equivalents of combining characters.<a href="#appendix-B.5-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.5-3">
 Although, the two sets of character can be checked to see if they are
 identical, this is a sufficient but not a necessary condition for
 equivalence since some permutations of a set of combining
 characters are considered canonically equivalent.  To summarize
 the appropriate equivalence rules:<a href="#appendix-B.5-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.5-4.1">
   Combining characters of different combining classes may be
   freely reordered.<a href="#appendix-B.5-4.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.5-4.2">
   If combining characters of the same combining class are reordered,
   then result is not canonically equivalent<a href="#appendix-B.5-4.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.5-5">
 The rules above do not directly apply to the case, discussed above,
 in which some non-combining characters are the case-based equivalents
 of combining characters such as COMBINING GREEK YPOGEGRAMMENI
 (U+0345).   Nevertheless, because of this equivalence, those
 implementing case-insensitive comparisons do have to deal with this
 potential equivalence when considering whether two strings containing
 combining characters or their case-based equivalents match.  As a
 result when comparing strings of combining characters, we need to
 implement the following modified rules.<a href="#appendix-B.5-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.5-6.1">
   When one comparand has a true combining character and the other
   comparand has an identical one, they may differ in location as
   long as there is no permutation of combining characters of the
   same combining class.<a href="#appendix-B.5-6.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.5-6.2">
   When one comparand has a true combining character and the other
   has a case-insensitive equivalent which is not a combining
   character, that character must appear last in its string
   while the combining may character appear in its string in any
   position except the last.  In this case, there are no
   restrictions based on combining classes.<a href="#appendix-B.5-6.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="appendix-B.5-6.3">
   When both comparands contain a non-combining character
   case-insensitively equivalent to a combining character, these
   character must appear last in their respective strings.<a href="#appendix-B.5-6.3" class="pilcrow">¶</a>
</li>
        </ul>
<p id="appendix-B.5-7">
        Although it is possible to divide combining characters based
 on their combining
 classes, sort each of the list and compare, that approach will not
 be discussed here.  Even though the use of sorts might allow use
 of an overall N log N algorithm, the number of combining characters
 is likely to be too low for this to be a practical benefit.
 Instead, we present below an order N-squared algorithm based on
 searches.<a href="#appendix-B.5-7" class="pilcrow">¶</a></p>
<p id="appendix-B.5-8">
 In this algorithm, one string, chosen arbitrarily id designated the
 "source string" and successive character from it, are searched for
 in the other, designated the "target string".  Associated with the
 target string is a mask to allow characters search for a found to
 be marked so that they will not be found a second time.  In the
 treatment below, when a character is "searched for" only characters
 not yet in the mask are examined and the character sought has its
 associated mask bit set when it is found.<a href="#appendix-B.5-8" class="pilcrow">¶</a></p>
<p id="appendix-B.5-9">
 Each character in the source string is processed in turn with the
 actual processing depending on particular character being processed,
 with the following three possibilities to be dealt with.<a href="#appendix-B.5-9" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-B.5-10">
<li id="appendix-B.5-10.1">
            <p id="appendix-B.5-10.1.1">
   For the typical case (i.e. a combining character with no case-
   insensitive equivalents), the character is searched for in the
   target string with the compare failing if it is not found.<a href="#appendix-B.5-10.1.1" class="pilcrow">¶</a></p>
<p id="appendix-B.5-10.1.2">
   If it is found, then the region of the target string between
   the point corresponding to the current position in the source
   string and the character found is examined to check for
   characters of the same combining class.   If any are found, the
   overall comparison fails.<a href="#appendix-B.5-10.1.2" class="pilcrow">¶</a></p>
</li>
          <li id="appendix-B.5-10.2">
   For the case of a combining character with a case-
   insensitive equivalents, the character is searched for as
   described in the first paragraph of item 1.  However, the
   compare does not fail if it is not found.
   Instead, a case-insensitive equivalent character is searched for
   at the final position of the string and the compare fails if that
   is not found.<a href="#appendix-B.5-10.2" class="pilcrow">¶</a>
</li>
          <li id="appendix-B.5-10.3">
   For the case of a non-combining character that has a combining
   character as a case-insensitive equivalents, the overall comparison
   fail if the character is not in the final position within the source
   string or has already been successfully searched for.  Otherwise,
   the corresponding
   combining character is searched for in the target as described in
   in the first paragraph of item 1.  The overall compare fails if it
   is not found.<a href="#appendix-B.5-10.3" class="pilcrow">¶</a>
</li>
        </ol>
<p id="appendix-B.5-11">
 Once all characters in the source string has been processed, the mask
 associated is examined to see if there are combining character that
        were not found in the matching process described above.
 Normally, if there
 are such characters, the overall comparison fails.   However, if the
 last character of the target was not matched and if it is a
 non-combining character that is case-insensitively equivalent to a
 combining character, then comparison succeeds and the remaining
 character needs to be matched with the next substring in the source.<a href="#appendix-B.5-11" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<section id="appendix-C">
      <h2 id="name-acknowledgements">
<a href="#name-acknowledgements" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="appendix-C-1">
      This document is based, in large part, on Section 12 of
      <span>[<a href="#RFC7530" class="xref">3</a>]</span> and all the people who contributed
      to that work, have helped make this document possible, including
      David Black, Peter Staubach, Nico Williams, Mike Eisler,
      Trond Myklebust, James Lentini, Mike Kupfer and Peter
      Saint-Andre.<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<p id="appendix-C-2">
      The author wishes to thank Tom Haynes for his timely suggestion
      to pursue the task of dealing with internationalization on an
      NFSv4-wide basis.<a href="#appendix-C-2" class="pilcrow">¶</a></p>
<p id="appendix-C-3">
      The author wishes to thank Nico WIlliams for his insights 
      regarding the need for clients implementing file access protocols
      to be aware of the details of the server's
      internationalization-related name processing, particularly when
      case-insensitive file systems are being accessed.<a href="#appendix-C-3" class="pilcrow">¶</a></p>
</section>
<div id="authors-addresses">
<section id="appendix-D">
      <h2 id="name-authors-address">
<a href="#name-authors-address" class="section-name selfRef">Author's Address</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Noveck</span></div>
<div dir="auto" class="left"><span class="org">NetApp</span></div>
<div dir="auto" class="left"><span class="street-address">1601 Trapelo Road</span></div>
<div dir="auto" class="left">
<span class="locality">Waltham</span>, <span class="region">MA</span> <span class="postal-code">02451</span>
</div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="tel">
<span>Phone:</span>
<a href="tel:+1%20781%20572%208038" class="tel">+1 781 572 8038</a>
</div>
<div class="email">
<span>Email:</span>
<a href="mailto:davenoveck@gmail.com" class="email">davenoveck@gmail.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
