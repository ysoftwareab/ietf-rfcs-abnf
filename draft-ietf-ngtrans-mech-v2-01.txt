





INTERNET-DRAFT                                               E. Nordmark
November 4, 2002                                  Sun Microsystems, Inc.
Obsoletes: 2893                                           R. E. Gilligan
                                                          Intransa, Inc.

         Basic Transition Mechanisms for IPv6 Hosts and Routers
                  <draft-ietf-ngtrans-mech-v2-01.txt>


Status of this Memo

   This document is an Internet-Draft and is subject to all provisions
   of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This draft expires on May 4, 2003.

Abstract

   This document specifies IPv4 compatibility mechanisms that can be
   implemented by IPv6 hosts and routers.  These mechanisms include
   providing complete implementations of both versions of the Internet
   Protocol (IPv4 and IPv6), and tunneling IPv6 packets over IPv4
   routing infrastructures.  They are designed to allow IPv6 nodes to
   maintain complete compatibility with IPv4, which should greatly
   simplify the deployment of IPv6 in the Internet, and facilitate the
   eventual transition of the entire Internet to IPv6.

   This document obsoletes RFC 2893.







<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 1]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   Contents

      Status of this Memo..........................................    1

      1.  Introduction.............................................    3
         1.1.  Terminology.........................................    3
         1.2.  Structure of this Document..........................    5

      2.  Dual IP Layer Operation..................................    5
         2.1.  Address Configuration...............................    6
         2.2.  DNS.................................................    6
         2.3.  Advertising Addresses in the DNS....................    7

      3.  Common Tunneling Mechanisms..............................    9
         3.1.  Encapsulation.......................................   10
         3.2.  Tunnel MTU and Fragmentation........................   11
         3.3.  Hop Limit...........................................   13
         3.4.  Handling IPv4 ICMP errors...........................   14
         3.5.  IPv4 Header Construction............................   15
         3.6.  Decapsulation.......................................   17
         3.7.  Link-Local Addresses................................   18
         3.8.  Neighbor Discovery over Tunnels.....................   19
         3.9.  Ingress Filtering...................................   19

      4.  Configured Tunneling.....................................   20
         4.1.  Ingress Filtering...................................   20

      5.  Acknowledgments..........................................   21

      6.  Security Considerations..................................   21

      7.  Authors' Addresses.......................................   22

      8.  References...............................................   22
         8.1.  Normative References................................   22
         8.2.  Non-normative References............................   22

      9.  Changes from RFC 2893....................................   23

      10.  Open issues.............................................   25

      11.  TODO....................................................   25









<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 2]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


1.  Introduction

   The key to a successful IPv6 transition is compatibility with the
   large installed base of IPv4 hosts and routers.  Maintaining
   compatibility with IPv4 while deploying IPv6 will streamline the task
   of transitioning the Internet to IPv6.  This specification defines a
   set of mechanisms that IPv6 hosts and routers may implement in order
   to be compatible with IPv4 hosts and routers.

   The mechanisms in this document are designed to be employed by IPv6
   hosts and routers that need to interoperate with IPv4 hosts and
   utilize IPv4 routing infrastructures.  We expect that most nodes in
   the Internet will need such compatibility for a long time to come,
   and perhaps even indefinitely.

   The mechanisms specified here include:

   -    Dual IP layer (also known as Dual Stack):  A technique for
        providing complete support for both Internet protocols -- IPv4
        and IPv6 -- in hosts and routers.

   -    Configured tunneling of IPv6 over IPv4:  Point-to-point tunnels
        made by encapsulating IPv6 packets within IPv4 headers to carry
        them over IPv4 routing infrastructures.

   The mechanisms defined here are intended to be the core of a
   "transition toolbox" -- a growing collection of techniques which
   implementations and users may employ to ease the transition.  The
   tools may be used as needed.  Implementations and sites decide which
   techniques are appropriate to their specific needs.

   This document defines the basic set of transition mechanisms, but
   these are not the only tools available.  Additional transition and
   compatibility mechanisms are specified in other documents.



1.1.  Terminology

   The following terms are used in this document:

   Types of Nodes

        IPv4-only node:

                A host or router that implements only IPv4.  An IPv4-
                only node does not understand IPv6.  The installed base
                of IPv4 hosts and routers existing before the transition



<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 3]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


                begins are IPv4-only nodes.

        IPv6/IPv4 node:

                A host or router that implements both IPv4 and IPv6.

        IPv6-only node:

                A host or router that implements IPv6, and does not
                implement IPv4.  The operation of IPv6-only nodes is not
                addressed here.

        IPv6 node:

                Any host or router that implements IPv6.  IPv6/IPv4 and
                IPv6-only nodes are both IPv6 nodes.

        IPv4 node:

                Any host or router that implements IPv4.  IPv6/IPv4 and
                IPv4-only nodes are both IPv4 nodes.

   Types of IPv6 Addresses

        IPv4-compatible IPv6 address:

                An IPv6 address bearing the high-order 96-bit prefix
                0:0:0:0:0:0, and an IPv4 address in the low-order 32-
                bits.  IPv4-compatible addresses are no longer used by
                this specification,

        IPv6-native address:

                The remainder of the IPv6 address space.  An IPv6
                address that bears a prefix other than 0:0:0:0:0:0.

   Techniques Used in the Transition

        IPv6-over-IPv4 tunneling:

                The technique of encapsulating IPv6 packets within IPv4
                so that they can be carried across IPv4 routing
                infrastructures.

        Configured tunneling:

                IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint
                address is determined by configuration information on



<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 4]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


                the encapsulating node.  The tunnels can be either
                unidirectional or bidirectional.  Bidirectional
                configured tunnels behave as virtual point-to-point
                links.

   Other transition mechanisms, including other tunneling mechanisms,
   are outside the scope of this document.

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [16].



1.2.  Structure of this Document

   The remainder of this document is organized as follows:

   -    Section 2 discusses the operation of nodes with a dual IP layer,
        IPv6/IPv4 nodes.

   -    Section 3 discusses the common mechanisms used in some IPv6-
        over-IPv4 tunneling techniques, including configured tunneling.

   -    Section 4 discusses configured tunneling.




2.  Dual IP Layer Operation

   The most straightforward way for IPv6 nodes to remain compatible with
   IPv4-only nodes is by providing a complete IPv4 implementation.  IPv6
   nodes that provide a complete IPv4 and IPv6 implementations are
   called "IPv6/IPv4 nodes."  IPv6/IPv4 nodes have the ability to send
   and receive both IPv4 and IPv6 packets.  They can directly
   interoperate with IPv4 nodes using IPv4 packets, and also directly
   interoperate with IPv6 nodes using IPv6 packets.

   Even though a node may be equipped to support both protocols, one or
   the other stack may be disabled for operational reasons.  Here we use
   a rather loose notion of "stack".  A stack being enabled has IP
   addresses assigned etc, but whether or not any particular application
   is available on the stacks is explicitly not defined.  Thus IPv6/IPv4
   nodes may be operated in one of three modes:

   -    With their IPv4 stack enabled and their IPv6 stack disabled.




<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 5]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    With their IPv6 stack enabled and their IPv4 stack disabled.

   -    With both stacks enabled.

   IPv6/IPv4 nodes with their IPv6 stack disabled will operate like
   IPv4-only nodes.  Similarly, IPv6/IPv4 nodes with their IPv4 stacks
   disabled will operate like IPv6-only nodes.  IPv6/IPv4 nodes MAY
   provide a configuration switch to disable either their IPv4 or IPv6
   stack.

   The IPv6-over-IPv4 tunneling techniques, which are described in
   sections 3 and 4, may or may not be used in addition to the dual IP
   layer operation.  An IPv6/IPv4 node MAY support configured tunneling.



2.1.  Address Configuration

   Because they support both protocols, IPv6/IPv4 nodes may be
   configured with both IPv4 and IPv6 addresses.  IPv6/IPv4 nodes use
   IPv4 mechanisms (e.g., DHCP) to acquire their IPv4 addresses, and
   IPv6 protocol mechanisms (e.g., stateless address autoconfiguration
   and/or DHCPv6) to acquire their IPv6-native addresses.



2.2.  DNS

   The Domain Naming System (DNS) is used in both IPv4 and IPv6 to map
   between hostnames and IP addresses.  A new resource record type named
   "AAAA" has been defined for IPv6 addresses [6].  Since IPv6/IPv4
   nodes must be able to interoperate directly with both IPv4 and IPv6
   nodes, they must provide resolver libraries capable of dealing with
   IPv4 "A" records as well as IPv6 "AAAA" records.  Note that the
   lookup of A versus AAAA records is independent of whether the DNS
   packets are carried in IPv4 or IPv6 packets.

   DNS resolver libraries on IPv6/IPv4 nodes MUST be capable of handling
   both AAAA and A records.  However, when a query locates an AAAA
   record holding an IPv6 address, and an A record holding an IPv4
   address, the resolver library MAY filter or order the results
   returned to the application in order to influence the version of IP
   packets used to communicate with that node.  In terms of filtering,
   the resolver library has three alternatives:

   -    Return only the IPv6 address(es) to the application.

   -    Return only the IPv4 address(es) to the application.



<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 6]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    Return both types of addresses to the application.

   If it returns only the IPv6 address(es), the application will
   communicate with the node using IPv6.  If it returns only the IPv4
   address(es), the application will communicate with the node using
   IPv4.  If it returns both types of addresses, the application will
   have the choice which address to use, and thus which IP protocol to
   employ.

   If it returns both, the resolver MAY elect to order the addresses --
   IPv6 first, or IPv4 first.  Since most applications try the addresses
   in the order they are returned by the resolver, this can affect the
   IP version "preference" of applications.

   The decision to filter or order DNS results is implementation
   specific.  IPv6/IPv4 nodes MAY provide policy configuration to
   control filtering or ordering of addresses returned by the resolver,
   or leave the decision entirely up to the application.

   An implementation MUST allow the application to control whether or
   not such filtering takes place.

   More details on this subject are specified in [19].



2.3.  Advertising Addresses in the DNS

   There are some constraint placed on the use of the DNS during
   transition.  The constraints allow nodes to prefer either IPv6 or
   IPv4 addresses when both types of addresses are returned by the DNS.
   Most of these are obvious but are stated here for completeness.

   The recommendation is that AAAA records for a node should not be
   added to the DNS until all of these are true:

     1) The address is assigned to the interface on the node.

     2) The address is configured on the interface.

     3) The interface is on a link which is connected to the IPv6
        infrastructure.

   If an IPv6 node is isolated from an IPv6 perspective (e.g., it is not
   connected to the 6bone to take a concrete example) constraint #3
   would mean that it should not have an address in the DNS.

   This works great when other dual stack nodes try to contact the



<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 7]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   isolated dual stack node.  There is no IPv6 address in the DNS thus
   the peer doesn't even try communicating using IPv6 but goes directly
   to IPv4 (we are assuming both nodes have A records in the DNS.)

   However, this does not work well when the isolated node is trying to
   establish communication.  Even though it does not have an IPv6
   address in the DNS it will find AAAA records in the DNS for the peer.
   Since the isolated node has IPv6 addresses assigned to at least one
   interface it will try to communicate using IPv6.  If it has no IPv6
   route to the 6bone (e.g., because the local router was upgraded to
   advertise IPv6 addresses using Neighbor Discovery but that router
   doesn't have any IPv6 routes) this communication will fail.
   Typically this means a few minutes of delay as TCP times out.  The
   TCP specification [10] says that ICMP unreachable messages could be
   due to routing transients thus they should not immediately terminate
   the TCP connection.  This means that the normal TCP timeout of a few
   minutes apply.  Once TCP times out the application will hopefully try
   the IPv4 addresses based on the A records in the DNS, but this will
   be painfully slow.

   A possible implication of the recommendations above is that, if one
   enables IPv6 on a node on a link without IPv6 infrastructure, and
   choose to add AAAA records to the DNS for that node, then external
   IPv6 nodes that might see these AAAA records will possibly try to
   reach that node using IPv6 and suffer delays or communication failure
   due to unreachability.  (A delay is incurred if the application
   correctly falls back to using IPv4 if it can not establish
   communication using IPv6 addresses.  If this fallback is not done the
   application would fail to communicate in this case.)  Thus it is
   suggested that either the recommendations be followed, or care be
   taken to only do so with nodes that will not be impacted by external
   accessing delays and/or communication failure.

   In the future, when a node discontinues its use of IPv4, analogous
   constraints apply with respect to the node's A records in the DNS;
   the removal of the A records should be tied to when the node can no
   longer be reached using IPv4.














<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 8]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


3.  Common Tunneling Mechanisms

   In most deployment scenarios, the IPv6 routing infrastructure will be
   built up over time.  While the IPv6 infrastructure is being deployed,
   the existing IPv4 routing infrastructure can remain functional, and
   can be used to carry IPv6 traffic.  Tunneling provides a way to
   utilize an existing IPv4 routing infrastructure to carry IPv6
   traffic.

   IPv6/IPv4 hosts and routers can tunnel IPv6 datagrams over regions of
   IPv4 routing topology by encapsulating them within IPv4 packets.
   Tunneling can be used in a variety of ways:

   -    Router-to-Router.  IPv6/IPv4 routers interconnected by an IPv4
        infrastructure can tunnel IPv6 packets between themselves.  In
        this case, the tunnel spans one segment of the end-to-end path
        that the IPv6 packet takes.

   -    Host-to-Router.  IPv6/IPv4 hosts can tunnel IPv6 packets to an
        intermediary IPv6/IPv4 router that is reachable via an IPv4
        infrastructure.  This type of tunnel spans the first segment of
        the packet's end-to-end path.

   -    Host-to-Host.  IPv6/IPv4 hosts that are interconnected by an
        IPv4 infrastructure can tunnel IPv6 packets between themselves.
        In this case, the tunnel spans the entire end-to-end path that
        the packet takes.

   -    Router-to-Host.  IPv6/IPv4 routers can tunnel IPv6 packets to
        their final destination IPv6/IPv4 host.  This tunnel spans only
        the last segment of the end-to-end path.

   Tunneling techniques are usually classified according to the
   mechanism by which the encapsulating node determines the address of
   the node at the end of the tunnel.  In the first two tunneling
   methods listed above -- router-to-router and host-to-router -- the
   IPv6 packet is being tunneled to a router.  The endpoint of this type
   of tunnel is an intermediary router which must decapsulate the IPv6
   packet and forward it on to its final destination.  When tunneling to
   a router, the endpoint of the tunnel is different from the
   destination of the packet being tunneled.  In some cases, the
   addresses in the IPv6 packet being tunneled can not provide the IPv4
   address of the tunnel endpoint.  In those cases, the tunnel endpoint
   address must be determined from configuration information on the node
   performing the encapsulation.  We use the term "configured tunneling"
   to describe the type of tunneling where the endpoint is explicitly
   configured.




<draft-ietf-ngtrans-mech-v2-01.txt>                             [Page 9]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   In the last two tunneling methods -- host-to-host and router-to-host
   -- the IPv6 packet is tunneled all the way to its final destination.
   In this case, the destination address of both the IPv6 packet and the
   encapsulating IPv4 header identify the same node.  However, the
   tunneling mechanism specified in this document does not handle these
   cases any differently; the IPv4 addresses is still determined using
   configuration information using configured tunneling.

   The underlying mechanisms for tunneling are:

   -    The entry node of the tunnel (the encapsulating node) creates an
        encapsulating IPv4 header and transmits the encapsulated packet.

   -    The exit node of the tunnel (the decapsulating node) receives
        the encapsulated packet, reassembles the packet if needed,
        removes the IPv4 header, updates the IPv6 header, and processes
        the received IPv6 packet.

   -    The encapsulating node MAY need to maintain soft state
        information for each tunnel recording such parameters as the MTU
        of the tunnel in order to process IPv6 packets forwarded into
        the tunnel.  In cases where the number of tunnels that any one
        host or router is using is large, it is helpful to observe that
        this state information can be cached and discarded when not in
        use.

   The remainder of this section discusses the common mechanisms.  A
   subsequent section discusses how the tunnel endpoint address is
   determined for configured tunneling.



3.1.  Encapsulation

      The encapsulation of an IPv6 datagram in IPv4 is shown below:
















<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 10]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002




                                                   +-------------+
                                                   |    IPv4     |
                                                   |   Header    |
                   +-------------+                 +-------------+
                   |    IPv6     |                 |    IPv6     |
                   |   Header    |                 |   Header    |
                   +-------------+                 +-------------+
                   |  Transport  |                 |  Transport  |
                   |   Layer     |      ===>       |   Layer     |
                   |   Header    |                 |   Header    |
                   +-------------+                 +-------------+
                   |             |                 |             |
                   ~    Data     ~                 ~    Data     ~
                   |             |                 |             |
                   +-------------+                 +-------------+

                            Encapsulating IPv6 in IPv4


   In addition to adding an IPv4 header, the encapsulating node also has
   to handle some more complex issues:

   -    Determine when to fragment and when to report an ICMP "packet
        too big" error back to the source.

   -    How to reflect IPv4 ICMP errors from routers along the tunnel
        path back to the source as IPv6 ICMP errors.

   Those issues are discussed in the following sections.



3.2.  Tunnel MTU and Fragmentation

   The encapsulating node could view encapsulation as IPv6 using IPv4 as
   a link layer with a very large MTU (65535-20 bytes to be exact; 20
   bytes "extra" are needed for the encapsulating IPv4 header).  The
   encapsulating node would need only to report IPv6 ICMP "packet too
   big" errors back to the source for packets that exceed this MTU.
   However, such a scheme would be inefficient for two reasons:

   1)   It would result in more fragmentation than needed.  IPv4 layer
        fragmentation SHOULD be avoided due to the performance problems
        caused by the loss unit being smaller than the retransmission
        unit [11].




<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 11]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   2)   Any IPv4 fragmentation occurring inside the tunnel, i.e. between
        the encapsulating node and the decapsulating node, would have to
        be reassembled at the tunnel endpoint.  For tunnels that
        terminate at a router, this would require additional memory to
        reassemble the IPv4 fragments into a complete IPv6 packet before
        that packet could be forwarded onward.

   Hence, the encapsulating node MUST NOT treat the tunnel as an
   interface with an MTU of 64 kilobytes, but use the smaller MTU
   specified below.

   The fragmentation inside the tunnel can be reduced to a minimum by
   having the encapsulating node track the IPv4 Path MTU across the
   tunnel, using the IPv4 Path MTU Discovery Protocol [8] and recording
   the resulting path MTU.  The IPv6 layer in the encapsulating node can
   then view a tunnel as a link layer with an MTU equal to the IPv4 path
   MTU, minus the size of the encapsulating IPv4 header.

   Note that this does not completely eliminate IPv4 fragmentation in
   the case when the IPv4 path MTU would result in an IPv6 MTU less than
   1280 bytes. (Any link layer used by IPv6 has to have an MTU of at
   least 1280 bytes [4].) In this case the IPv6 layer has to "see" a
   link layer with an MTU of 1280 bytes and the encapsulating node has
   to use IPv4 fragmentation in order to forward the 1280 byte IPv6
   packets.

   This dynamic MTU determination is OPTIONAL.  However, if it is
   implemented it SHOULD have the behavior described in this document
   and the tunnel MTU MUST be not exceed 4400 bytes.  If it is not
   implemented instead the node MUST instead limit the size of the IPv6
   packets it tunnels to 1280 bytes i.e., treat the tunnel interface as
   having a fixed interface MTU of 1280 bytes.  An implementation MAY
   have a configuration knob which can be used to set a larger value of
   the tunnel MTU than 1280 bytes, but if so the default MUST be 1280
   bytes.

   The encapsulating node can employ the following algorithm to
   determine when to forward an IPv6 packet that is larger than the
   tunnel's path MTU using IPv4 fragmentation, and when to return an
   IPv6 ICMP "packet too big" message:











<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 12]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002



           if (IPv4 path MTU - 20) is less than or equal to 1280
                   if packet is larger than 1280 bytes
                           Send IPv6 ICMP "packet too big" with MTU = 1280.
                           Drop packet.
                   else
                           Encapsulate but do not set the Don't Fragment
                           flag in the IPv4 header.  The resulting IPv4
                           packet might be fragmented by the IPv4 layer on
                           the encapsulating node or by some router along
                           the IPv4 path.
                   endif
           else
                   if packet is larger than (IPv4 path MTU - 20) or packet
                       is larger than 4400
                           Send IPv6 ICMP "packet too big" with
                           MTU = MIN(IPv4 path MTU - 20, 4400).
                           Drop packet.
                   else
                           Encapsulate and set the Don't Fragment flag
                           in the IPv4 header.
                   endif
           endif


   Encapsulating nodes that have a large number of tunnels might not be
   able to store the IPv4 Path MTU for all tunnels.  Such nodes can, at
   the expense of additional fragmentation in the network, avoid using
   the IPv4 Path MTU algorithm across the tunnel and instead use the MTU
   of the link layer (under IPv4) in the above algorithm instead of the
   IPv4 path MTU.

   In this case the Don't Fragment bit MUST NOT be set in the
   encapsulating IPv4 header.



3.3.  Hop Limit

   IPv6-over-IPv4 tunnels are modeled as "single-hop".  That is, the
   IPv6 hop limit is decremented by 1 when an IPv6 packet traverses the
   tunnel.  The single-hop model serves to hide the existence of a
   tunnel.  The tunnel is opaque to users of the network, and is not
   detectable by network diagnostic tools such as traceroute.

   The single-hop model is implemented by having the encapsulating and
   decapsulating nodes process the IPv6 hop limit field as they would if
   they were forwarding a packet on to any other datalink.  That is,



<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 13]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   they decrement the hop limit by 1 when forwarding an IPv6 packet.
   (The originating node and final destination do not decrement the hop
   limit.)

   The TTL of the encapsulating IPv4 header is selected in an
   implementation dependent manner.  The current suggested value is
   published in the "Assigned Numbers" RFC.  Implementations MAY provide
   a mechanism to allow the administrator to configure the IPv4 TTL such
   as the one specified in the IP Tunnel MIB [17].



3.4.  Handling IPv4 ICMP errors

   In response to encapsulated packets it has sent into the tunnel, the
   encapsulating node might receive IPv4 ICMP error messages from IPv4
   routers inside the tunnel.  These packets are addressed to the
   encapsulating node because it is the IPv4 source of the encapsulated
   packet.

   The ICMP "packet too big" error messages are handled according to
   IPv4 Path MTU Discovery [8] and the resulting path MTU is recorded in
   the IPv4 layer.  The recorded path MTU is used by IPv6 to determine
   if an IPv6 ICMP "packet too big" error has to be generated as
   described in section 3.2.

   The handling of other types of ICMP error messages depends on how
   much information is included in the "packet in error" field, which
   holds the encapsulated packet that caused the error.

   Many older IPv4 routers return only 8 bytes of data beyond the IPv4
   header of the packet in error, which is not enough to include the
   address fields of the IPv6 header.  More modern IPv4 routers are
   likely to return enough data beyond the IPv4 header to include the
   entire IPv6 header and possibly even the data beyond that.

   If the offending packet includes enough data, the encapsulating node
   MAY extract the encapsulated IPv6 packet and use it to generate an
   IPv6 ICMP message directed back to the originating IPv6 node, as
   shown below:











<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 14]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002



                   +--------------+
                   | IPv4 Header  |
                   | dst = encaps |
                   |       node   |
                   +--------------+
                   |     ICMP     |
                   |    Header    |
            - -    +--------------+
                   | IPv4 Header  |
                   | src = encaps |
           IPv4    |       node   |
                   +--------------+   - -
           Packet  |    IPv6      |
                   |    Header    |   Original IPv6
            in     +--------------+   Packet -
                   |  Transport   |   Can be used to
           Error   |    Header    |   generate an
                   +--------------+   IPv6 ICMP
                   |              |   error message
                   ~     Data     ~   back to the source.
                   |              |
            - -    +--------------+   - -

       IPv4 ICMP Error Message Returned to Encapsulating Node




3.5.  IPv4 Header Construction

   When encapsulating an IPv6 packet in an IPv4 datagram, the IPv4
   header fields are set as follows:

        Version:

                4

        IP Header Length in 32-bit words:

                5 (There are no IPv4 options in the encapsulating
                header.)

        Type of Service:

                0 unless otherwise specified. (See [20] and [21] for
                issues relating to the ToS byte and tunneling.)




<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 15]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


        Total Length:

                Payload length from IPv6 header plus length of IPv6 and
                IPv4 headers (i.e., IPv6 payload length plus a constant
                60 bytes).

        Identification:

                Generated uniquely as for any IPv4 packet transmitted by
                the system.

        Flags:

                Set the Don't Fragment (DF) flag as specified in section
                3.2.  Set the More Fragments (MF) bit as necessary if
                fragmenting.

        Fragment offset:

                Set as necessary if fragmenting.

        Time to Live:

                Set in implementation-specific manner.

        Protocol:

                41 (Assigned payload type number for IPv6)

        Header Checksum:

                Calculate the checksum of the IPv4 header.

        Source Address:

                IPv4 address of outgoing interface of the encapsulating
                node.  The source address MAY alternatively be
                administratively specified to be a specific IPv4 address
                assigned to the encapsulating node.

        Destination Address:

                IPv4 address of tunnel endpoint.

   Any IPv6 options are preserved in the packet (after the IPv6 header).






<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 16]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


3.6.  Decapsulation

   When an IPv6/IPv4 host or a router receives an IPv4 datagram that is
   addressed to one of its own IPv4 address, and the value of the
   protocol field is 41, it reassembles if the packet if it is
   fragmented at the IPv4 level, then it removes the IPv4 header and
   submits the IPv6 datagram to its IPv6 layer code.

   The decapsulating node MUST be capable of reassembling an IPv4 packet
   that is 4420 bytes (4400 bytes plus IPv4 header).  This limit allows
   dynamic tunnel MTU determination by the encapsulator to take
   advantage of larger IPv4 path MTUs.  An implementation MAY have a
   configuration knob which can be used to set a larger value of the
   tunnel MRU than 4420 bytes, but the value MUST not be set below 4420.

   The decapsulation is shown below:

           +-------------+
           |    IPv4     |
           |   Header    |
           +-------------+                 +-------------+
           |    IPv6     |                 |    IPv6     |
           |   Header    |                 |   Header    |
           +-------------+                 +-------------+
           |  Transport  |                 |  Transport  |
           |   Layer     |      ===>       |   Layer     |
           |   Header    |                 |   Header    |
           +-------------+                 +-------------+
           |             |                 |             |
           ~    Data     ~                 ~    Data     ~
           |             |                 |             |
           +-------------+                 +-------------+

                       Decapsulating IPv6 from IPv4


   When decapsulating the packet, the IPv6 header is not modified.  (See
   [20] and [21] for issues relating to the Type of Service byte and
   tunneling.)  If the packet is subsequently forwarded, its hop limit
   is decremented by one.

   As part of the decapsulation the node SHOULD silently discard a
   packet with an invalid IPv4 source address such as a multicast
   address, a broadcast address, 0.0.0.0, and 127.0.0.1.  In general it
   SHOULD apply the rules for martian filtering in [18] and ingress
   filtering [13] on the IPv4 source address.

   The decapsulating node performs IPv4 reassembly before decapsulating



<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 17]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   the IPv6 packet.  All IPv6 options are preserved even if the
   encapsulating IPv4 packet is fragmented.

   The encapsulating IPv4 header is discarded.

   After the decapsulation the node SHOULD silently discard a packet
   with an invalid IPv6 source address.  This includes IPv6 multicast
   addresses, the unspecified address, and the loopback address but also
   IPv4-compatible IPv6 source addresses where the IPv4 part of the
   address is an (IPv4) multicast address, broadcast address, 0.0.0.0,
   or 127.0.0.1.  In general it SHOULD apply the rules for martian
   filtering in [18] and ingress filtering [13] on the IPv4-compatible
   source address.

   After the IPv6 packet is decapsulated, it is processed almost the
   same as any received IPv6 packet.  The only difference being that a
   decapsulated packet MUST NOT be forwarded unless the node has been
   explicitly configured to forward such packets for the given IPv4
   source address.  This configuration can be implicit in e.g., having a
   configured tunnel which matches the IPv4 source address.  This
   restriction is needed to prevent tunneling to be used as a tool to
   circumvent ingress filtering [13].



3.7.  Link-Local Addresses

   The configured tunnels are IPv6 interfaces (over the IPv4 "link
   layer") thus MUST have link-local addresses.  The link-local
   addresses are used by routing protocols operating over the tunnels.

   The Interface Identifier [14] for such an Interface SHOULD be the
   32-bit IPv4 address of that interface, with the bytes in the same
   order in which they would appear in the header of an IPv4 packet,
   padded at the left with zeros to a total of 64 bits.  Note that the
   "Universal/Local" bit is zero, indicating that the Interface
   Identifier is not globally unique.  When the host has more than one
   IPv4 address in use on the physical interface concerned, an
   administrative choice of one of these IPv4 addresses is made.

   The IPv6 Link-local address [14] for an IPv4 virtual interface is
   formed by appending the Interface Identifier, as defined above, to
   the prefix FE80::/64.








<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 18]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   +-------+-------+-------+-------+-------+-------+------+------+
   |  FE      80      00      00      00      00      00     00  |
   +-------+-------+-------+-------+-------+-------+------+------+
   |  00      00   |  00   |  00   |   IPv4 Address              |
   +-------+-------+-------+-------+-------+-------+------+------+



3.8.  Neighbor Discovery over Tunnels

   For unidirectional configured tunnels most of Neighbor Discovery [17]
   and Stateless Address Autoconfiguration [5] does not apply; only the
   formation of the link-local address applies.

   If an implementation provides bidirectional configured tunnels it
   MUST at least accept and respond to the probe packets used by
   Neighbor Unreachability Detection [7].  Such implementations SHOULD
   also send NUD probe packets to detect when the configured tunnel
   fails at which point the implementation can use an alternate path to
   reach the destination.  Note that Neighbor Discovery allows that the
   sending of NUD probes be omitted for router to router links if the
   routing protocol tracks bidirectional reachability.

   For the purposes of Neighbor Discovery the configured tunnels
   specified in this document are assumed to NOT have a link-layer
   address, even though the link-layer (IPv4) does have address.  This
   means that a sender of Neighbor Discovery packets

    -   SHOULD NOT include Source Link Layer Address options or Target
        Link Layer Address options on the tunnel link.

    -   MUST silently ignore any received SLLA or TLLA options on the
        tunnel link.

   Not using alink layer address options is consistent with how neighbor
   discovery is used on other point-to-point links.



3.9.  Ingress Filtering

   The specification above contains rules that apply ingress filtering
   to packets before they are decapsulated.  The purpose of ingress
   filtering in general is specified in [13].  When IP-in-IP tunneling
   (independent of IP versions) is used it is important that this not be
   a tool to bypass ingress filtering for non-tunneled packets.  For
   instance, without specific ingress filtering checks in the
   decapsulating node, it would be possible for an attacker to inject a



<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 19]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   packet with:

    -   Outer IPv4 source: real IPv4 address of attacker

    -   Outer IPv4 destination: IPv4 address of decapsulating node

    -   Inner IPv6 source: Alice which is either the decapsulating node
        or a node close to it.

    -   Inner IPv6 destination: Bob

   Even if all IPv4 routers between the attacker and the decapsulating
   node implement IPv4 ingress filtering, and all IPv6 routers between
   the decapsulating node and Bob implement IPv6 ingress filter, the
   above spoofed packets will not be filtered out.

   The solution to this is to have the decapsulating node perform
   ingress filtering checks as part of the decapsulation as specified in
   section 4.1.




4.  Configured Tunneling

   In configured tunneling, the tunnel endpoint address is determined
   from configuration information in the encapsulating node.  For each
   tunnel, the encapsulating node must store the tunnel endpoint
   address.  When an IPv6 packet is transmitted over a tunnel, the
   tunnel endpoint address configured for that tunnel is used as the
   destination address for the encapsulating IPv4 header.

   The determination of which packets to tunnel is usually made by
   routing information on the encapsulating node.  This is usually done
   via a routing table, which directs packets based on their destination
   address using the prefix mask and match technique.



4.1.  Ingress Filtering

   The decapsulating node MUST verify that the tunnel source address is
   acceptable before forwarding decapsulated packets to avoid
   circumventing ingress filtering [13].  Note that packets which are
   delivered to transport protocols on the decapsulating node SHOULD NOT
   be subject to these checks.  For bidirectional configured tunnels
   this is done by verifying that the source address is the IPv4 address
   of the other end of the tunnel.  For unidirectional configured



<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 20]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   tunnels the decapsulating node MUST be configured with a list of
   source IPv4 address prefixes that are acceptable.  Such a list MUST
   default to not having any entries i.e., the node has to be explicitly
   configured to forward decapsulated packets received over
   unidirectional configured tunnels.




5.  Acknowledgments

   We would like to thank the members of the IPng working group and the
   Next Generation Transition (ngtrans) working group for their many
   contributions and extensive review of this document.  Special thanks
   are due to Jim Bound, Ross Callon, Bob Hinden, John Moy, and Pekka
   Savola for many helpful suggestions.




6.  Security Considerations

   Tunneling is not known to introduce any security holes except for the
   possibility to circumvent ingress filtering [13].  This is prevented
   by requiring that decapsulating routers only forward packets if they
   have been configured to accept encapsulated packets from the IPv4
   source address in the receive packet.

   An implementation of tunneling needs to be aware that while a tunnel
   is a link (as defined in [4]), the threat model for a tunnel might be
   rather different than for other links, since the tunnel potentially
   includes all of the Internet.  The recommendations to verify that the
   IPv4 addresses in the encapsulated packet matches what has been
   configured for the tunnel, coupled with use of ingress filtering in
   IPv4, ameliorate some of this.  In addition, an implementation must
   treat interfaces to different links as separate e.g. to ensure that
   Neighbor Discovery packets arriving on one link does not effect other
   links.  This is especially important for tunnel links.













<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 21]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


7.  Authors' Addresses

   Erik Nordmark
   Sun Microsystems Laboratories
   180, avenue de l'Europe
   38334 SAINT ISMIER Cedex, France
   Tel : +33 (0)4 76 18 88 03
   Fax : +33 (0)4 76 18 88 88
   EMail : erik.nordmark@sun.com

   Robert E. Gilligan
   Intransa, Inc.
   2870 Zanker Rd., Suite 100
   San Jose, CA 95134

   Tel : +1 408 678 8600
   Fax : +1 408 678 8800
   Email : gilligan@intransa.com, gilligan@leaf.com




8.  References



8.1.  Normative References


  [4]   Deering, S., and Hinden, R. "Internet Protocol, Version 6 (IPv6)
        Specification", RFC 2460, December 1998.

  [8]   Mogul, J., and Deering, S., "Path MTU Discovery", RFC 1191,
        November 1990.

 [14]   Hinden, R., and S. Deering, "IP Version 6 Addressing
        Architecture", RFC 2373, July 1998.



8.2.  Non-normative References


  [5]   Thomson, S., and Narten, T. "IPv6 Stateless Address
        Autoconfiguration," RFC 2462, December 1998.

  [6]   Thomson, S., and Huitema C. "DNS Extensions to support IP
        version 6", RFC 1886, December 1995.



<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 22]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


  [7]   Narten, T., Nordmark, E., and Simpson, W. "Neighbor Discovery
        for IP Version 6 (IPv6)", RFC 2461, December 1998.

 [10]   Braden, R., "Requirements for Internet Hosts - Communication
        Layers", STD 3, RFC 1122, October 1989.

 [11]   Kent, C., and J. Mogul, "Fragmentation Considered Harmful".  In
        Proc.  SIGCOMM '87 Workshop on Frontiers in Computer
        Communications Technology.  August 1987.

 [13]   Ferguson, P., and Senie, D., "Network Ingress Filtering:
        Defeating Denial of Service Attacks which employ IP Source
        Address Spoofing", RFC 2267, January 1998.

 [16]   S. Bradner, "Key words for use in RFCs to Indicate Requirement
        Levels", RFC 2119, March 1997.

 [17]   D. Thaler, "IP Tunnel MIB", RFC 2667, August 1999.

 [18]   F. Baker, "Requirements for IP Version 4 Routers", RFC 1812,
        June 1995.

 [19]   R. Draves, "Default Address Selection for IPv6", Work in
        progress, draft-ietf-ipv6-default-addr-select-09.txt, June
        2002.

 [20]   D. Black, "Differentiated Services and Tunnels", RFC 2893,
        October 2000.

 [21]   K. Ramakrishnan, S. Floyd, D. Black, "The Addition of Explicit
        Congestion Notification (ECN) to IP", RFC 3168, September 2001.



9.  Changes from RFC 2893

     The motivation for the bulk of these changes are to simplify the
     document to only contain the mechanisms of wide-spread use.

     RFC 2893 contains a mechanism called automatic tunneling.  But a
     much more general mechanism is specified in RFC 3056 which gives
     each node with a (global) IPv4 address a /48 IPv6 prefix i.e.,
     enough for a whole site.




   -    Removed references to A6 and retained AAAA.



<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 23]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    Removed automatic tunneling and IPv4-compatible addresses.

   -    Removed default Configured Tunnel using IPv4 "Anycast Address"

   -    Removed Source Address Selection section since this is now
        covered by another document ([19]).

   -    Removed brief mention of 6over4.

   -    Split into normative and non-normative references.

   -    Drop "or equal" in if (IPv4 path MTU - 20) is less than or equal
        to 1280

   -    Dropped this: However, IPv6 may be used in some environments
        where interoperability with IPv4 is not required.  IPv6 nodes
        that are designed to be used in such environments need not use
        or even implement these mechanisms.

   -    Increased the minimum MRU from 1300 to 4420.

   -    Clarified that the dynamic path MTU mechanism in section 3.2 is
        OPTIONAL but if it is implemented it should follow the rules in
        section 3.2.

   -    Stated that when the dynamic PMTU is not implemented the sender
        MUST NOT by default send IPv6 packets larger than 1280 into the
        tunnel.

   -    Stated that implementations MAY have a knob by which the "min
        MRU" and the max MTU" can be set to larger values on a tunnel by
        tunnel basis, but that the defaults MUST be the above numbers.

   -    Restated the "currently underway" language about ToS to loosely
        point at [20] and [21].

   -    Stated that IPv4 source MAY also be administratively specified.
        (This is especially useful on multi-interface nodes and with
        configured tunneling)












<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 24]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


10.  Open issues



   -    Should all of section 2.2 (DNS stuff) be removed?  It duplicates
        [19].

   -    Should we drop the discussion about unidirectional tunneling?

   -    Is 1280 a reasonable MTU for encapsulators that do not implement
        dynamic tunnel MTU discovery?

   -    Is 4400 a reasonable cap on the MTU for encapsulators that
        implement dynamic tunnel MTU discovery?

   -    Is 4420 is reasonable minimum MRU for decapsulating nodes?

   -    IPv6 native addresses include IPv4-mapped as currently defined.
        Is this an issue that needs to be dealt with?  The term "IPv6-
        native" is only used once in the document.





11.  TODO



   -    Section 4.1: Ingress filtering as described does not guard
        against the attack described in 3.9. Checking must be done on
        the v6 address - attacker can spoof the v4 source address,
        unless tunnel is secured.  Make it more clear that the
        assumption is that *if* IPv4 and IPv6 ingress filtering is
        deployed, the decapsulating node can't blindly decapsulate since
        it would circumvent the ingress filtering.

   -    Section 3.3 reference to Assigned Numbers needs to be to online
        version (with proper pointer to "Assigned Numbers is obsolete"
        RFC)











<draft-ietf-ngtrans-mech-v2-01.txt>                            [Page 25]

