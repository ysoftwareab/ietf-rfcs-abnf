



Network Working Group                                       T. Dreibholz
Internet-Draft                                Simula Research Laboratory
Intended status: Experimental                             April 11, 2017
Expires: October 13, 2017


                            NEAT Sockets API
               draft-dreibholz-taps-neat-socketapi-00.txt

Abstract

   This document describes the NEAT Sockets API.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on October 13, 2017.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.







Dreibholz               Expires October 13, 2017                [Page 1]

Internet-Draft              NEAT Sockets API                  April 2017


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Conventions . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Initialisation and Clean-Up . . . . . . . . . . . . . . . . .   3
     2.1.  nsa_cleanup() . . . . . . . . . . . . . . . . . . . . . .   4
     2.2.  nsa_map_socket()  . . . . . . . . . . . . . . . . . . . .   4
     2.3.  nsa_unmap_socket()  . . . . . . . . . . . . . . . . . . .   4
   3.  Connection Establishment and Teardown . . . . . . . . . . . .   5
     3.1.  nsa_socket()  . . . . . . . . . . . . . . . . . . . . . .   5
     3.2.  nsa_close() . . . . . . . . . . . . . . . . . . . . . . .   5
     3.3.  nsa_fcntl() . . . . . . . . . . . . . . . . . . . . . . .   6
     3.4.  nsa_bind()  . . . . . . . . . . . . . . . . . . . . . . .   6
     3.5.  nsa_bindx() . . . . . . . . . . . . . . . . . . . . . . .   7
     3.6.  nsa_bindn() . . . . . . . . . . . . . . . . . . . . . . .   8
     3.7.  nsa_connect() . . . . . . . . . . . . . . . . . . . . . .   8
     3.8.  nsa_connectx()  . . . . . . . . . . . . . . . . . . . . .   9
     3.9.  nsa_connectn()  . . . . . . . . . . . . . . . . . . . . .   9
     3.10. nsa_listen()  . . . . . . . . . . . . . . . . . . . . . .  10
     3.11. nsa_accept()  . . . . . . . . . . . . . . . . . . . . . .  10
     3.12. nsa_shutdown()  . . . . . . . . . . . . . . . . . . . . .  11
   4.  Options Handling  . . . . . . . . . . . . . . . . . . . . . .  11
     4.1.  nsa_getsockopt()  . . . . . . . . . . . . . . . . . . . .  11
     4.2.  nsa_setsockopt()  . . . . . . . . . . . . . . . . . . . .  12
     4.3.  nsa_opt_info()  . . . . . . . . . . . . . . . . . . . . .  13
   5.  Security  . . . . . . . . . . . . . . . . . . . . . . . . . .  13
     5.1.  nsa_set_secure_identity() . . . . . . . . . . . . . . . .  13
     5.2.  ... . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
   6.  Input/Output Handling . . . . . . . . . . . . . . . . . . . .  13
     6.1.  nsa_write() . . . . . . . . . . . . . . . . . . . . . . .  13
     6.2.  nsa_send()  . . . . . . . . . . . . . . . . . . . . . . .  14
     6.3.  nsa_sendto()  . . . . . . . . . . . . . . . . . . . . . .  14
     6.4.  nsa_sendmsg() . . . . . . . . . . . . . . . . . . . . . .  15
     6.5.  nsa_sendv() . . . . . . . . . . . . . . . . . . . . . . .  16
     6.6.  nsa_read()  . . . . . . . . . . . . . . . . . . . . . . .  16
     6.7.  nsa_recv()  . . . . . . . . . . . . . . . . . . . . . . .  17
     6.8.  nsa_recvfrom()  . . . . . . . . . . . . . . . . . . . . .  17
     6.9.  nsa_recvmsg() . . . . . . . . . . . . . . . . . . . . . .  18
     6.10. nsa_recvv() . . . . . . . . . . . . . . . . . . . . . . .  19
   7.  Poll and Select . . . . . . . . . . . . . . . . . . . . . . .  20
     7.1.  nsa_poll()  . . . . . . . . . . . . . . . . . . . . . . .  20
     7.2.  nsa_select()  . . . . . . . . . . . . . . . . . . . . . .  20
   8.  Address Handling  . . . . . . . . . . . . . . . . . . . . . .  20
     8.1.  nsa_getsockname() . . . . . . . . . . . . . . . . . . . .  20
     8.2.  nsa_getpeername() . . . . . . . . . . . . . . . . . . . .  21
     8.3.  nsa_getladdrs() . . . . . . . . . . . . . . . . . . . . .  22
     8.4.  nsa_freeladdrs()  . . . . . . . . . . . . . . . . . . . .  22
     8.5.  nsa_getpaddrs() . . . . . . . . . . . . . . . . . . . . .  22



Dreibholz               Expires October 13, 2017                [Page 2]

Internet-Draft              NEAT Sockets API                  April 2017


     8.6.  nsa_freepaddrs()  . . . . . . . . . . . . . . . . . . . .  23
   9.  Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . .  23
     9.1.  nsa_open()  . . . . . . . . . . . . . . . . . . . . . . .  23
     9.2.  nsa_creat() . . . . . . . . . . . . . . . . . . . . . . .  23
     9.3.  nsa_pipe()  . . . . . . . . . . . . . . . . . . . . . . .  24
     9.4.  nsa_ioctl() . . . . . . . . . . . . . . . . . . . . . . .  24
   10. Code Examples . . . . . . . . . . . . . . . . . . . . . . . .  24
   11. Testbed Platform  . . . . . . . . . . . . . . . . . . . . . .  24
   12. Security Considerations . . . . . . . . . . . . . . . . . . .  24
   13. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  25
   14. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  25
   15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  25
     15.1.  Normative References . . . . . . . . . . . . . . . . . .  25
     15.2.  Informative References . . . . . . . . . . . . . . . . .  25
     15.3.  URIs . . . . . . . . . . . . . . . . . . . . . . . . . .  26
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  27

1.  Introduction

   The NEAT project [9], [4], [3], [7] wants to achieve a complete
   redesign of the way in which Internet applications interact with the
   network.  Our goal is to allow network "services" offered to
   applications - such as reliability, low-delay communication or
   security - to be dynamically tailored based on application demands,
   current network conditions, hardware capabilities or local policies,
   and also to support the integration of new network functionality in
   an evolutionary fashion, without applications having to be rewritten.
   This architectural change will make the Internet truly "enhanceable",
   by allowing applications to seamlessly and more easily take advantage
   of new network features as they evolve.

   This document describes the NEAT Sockets API on top of the callback-
   based NEAT Core API [9], [10], [11], [12].  It provides a BSD
   Sockets-like API that is intended to simplify using NEAT in network
   applications.

1.1.  Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [1].

2.  Initialisation and Clean-Up








Dreibholz               Expires October 13, 2017                [Page 3]

Internet-Draft              NEAT Sockets API                  April 2017


2.1.  nsa_cleanup()

   nsa_cleanup() is used to free all resources allocated by NEAT.  Note,
   that the NEAT Sockets API is automatically initialized when creating
   a NEAT socket.

   Function Prototype:

   void nsa_cleanup()

2.2.  nsa_map_socket()

   nsa_map_socket() is used to map a system socket descriptor into the
   NEAT socket descriptor space.  This is useful for using NEAT API
   functions as wrapper to calls on non-NEAT sockets.  Mapped socket
   descriptors can be unmapped by using nsa_unmap_socket().

   Function Prototype:

   int nsa_map_socket(int systemSD, int neatSD)

   Arguments:

   systemSD:  System socket descriptor.

   neatSD:  Desired NEAT socket descriptor; -1 for automatic allocation.

   Return Value:

   nsa_map_socket() returns the new NEAT socket descriptor, or -1 in
   case of error.  The error code will be set in the errno variable.

2.3.  nsa_unmap_socket()

   nsa_unmap_socket() is used to unmap a system socket descriptor from
   the NEAT socket descriptor space.

   Function Prototype:

   int nsa_unmap_socket(int neatSD)

   Arguments:

   neatSD:  NEAT socket descriptor.







Dreibholz               Expires October 13, 2017                [Page 4]

Internet-Draft              NEAT Sockets API                  April 2017


3.  Connection Establishment and Teardown

3.1.  nsa_socket()

   nsa_socket() creates a new NEAT socket.  The NEAT socket can either
   be a wrapper around the NEAT Core API (if properties are specified)
   or be a wrapper around a system socket (if no properties are
   specified).

   Function Prototype:

   int nsa_socket(int domain, int type, int protocol,
                  const char* properties)

   Arguments:

   domain:  Domain for system socket (e.g.  AF_INET).

   type:  Type for system socket (SOCK_SEQPACKET).

   protocol:  Protocol for system socket (IPPROTO_SCTP).

   properties:  Properties for NEAT Core socket.

   Return Value:

   nsa_socket() returns the NEAT socket descriptor in case of success,
   or -1 in case of error.  The error code will be set in the errno
   variable.

   See the socket() documentation for details.

3.2.  nsa_close()

   nsa_close() closes a given NEAT socket.

   Function Prototype:

   int nsa_close(int sockfd)

   Arguments:

   sockfd:  NEAT socket descriptor.

   nsa_close() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the close() documentation for details.



Dreibholz               Expires October 13, 2017                [Page 5]

Internet-Draft              NEAT Sockets API                  April 2017


3.3.  nsa_fcntl()

   nsa_fcntl() manipulates a given NEAT socket.

   Function Prototype:

   int nsa_fcntl(int sockfd, int cmd, ...)

   Arguments:

   sockfd:  NEAT socket descriptor.

   cmd:  Command.

   ...:  Command-specific arguments.

   nsa_fcntl() returns a command-specific value.

   For NEAT sockets, the following commands are specified:

   F_GETFL:  Obtain value of the socket descriptor status flags.  For
      NEAT sockets, the flag O_NONBLOCK specifies whether the socket is
      non-blocking.  By default, it is blocking (i.e.  O_NONBLOCK is not
      set).

   F_SETFL:  Set value of the socket descriptor status flags.  For NEAT
      sockets, the flag O_NONBLOCK specifies whether the socket is non-
      blocking.  By default, it is blocking (i.e.  O_NONBLOCK is not
      set).  F_SETFL can then be used to change the blocking mode.

   See the fcntl() documentation for details.

3.4.  nsa_bind()

   nsa_bind() binds a given NEAT socket to a given address.  Note: this
   function is provided as legacy wrapper, and it is RECOMMENDED to use
   nsa_bindn() instead.  Note further, that nsa_bind() also supports a
   single address only (i.e. no multi-homing). nsa_bindx() SHOULD be
   used instead to support multi-homing.

   Function Prototype:

   int nsa_bind(int sockfd,
                const struct sockaddr* addr, socklen_t addrlen,
                struct neat_tlv* opt, const int optcnt)

   Arguments:




Dreibholz               Expires October 13, 2017                [Page 6]

Internet-Draft              NEAT Sockets API                  April 2017


   sockfd:  NEAT socket descriptor.

   addr:  Address to bind to.

   addrlen:  Length of the address structure "addr".

   opt:  NEAT options (NULL, if there are none).

   optcnt:  Number of NEAT options provided by "opt".

   nsa_bind() returns 0 in case of success, or -1 in case of error.  The
   error code will be set in the errno variable.

   See the bind() documentation for details.

3.5.  nsa_bindx()

   nsa_bindx() binds a given NEAT socket to a given set of addresses.
   Note: this function is provided as legacy wrapper, and it is
   RECOMMENDED to use nsa_bindn() instead.

   Function Prototype:

   int nsa_bindx(int sockfd, const struct sockaddr* addrs, int addrcnt,
                 int flags,
                 struct neat_tlv* opt, const int optcnt)

   Arguments:

   sockfd:  NEAT socket descriptor.

   addrs:  Addresses to bind to.

   addrcnt:  Number of addresses in "addr".

   flags:  Optional flags (0, if there are none).

   opt:  NEAT options (NULL, if there are none).

   optcnt:  Number of NEAT options provided by "opt".

   nsa_bindx() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the sctp_bindx() documentation for details.






Dreibholz               Expires October 13, 2017                [Page 7]

Internet-Draft              NEAT Sockets API                  April 2017


3.6.  nsa_bindn()

   nsa_bindn() binds a given NEAT socket to a given port.  NEAT takes
   care of handling local addresses.

   Function Prototype:

   int nsa_bindn(int sockfd, uint16_t port, int flags,
                 struct neat_tlv* opt, const int optcnt)

   Arguments:

   sockfd:  NEAT socket descriptor.

   port:  Port number to bind to.

   flags:  Optional flags (0, if there are none).

   opt:  NEAT options (NULL, if there are none).

   optcnt:  Number of NEAT options provided by "opt".

   nsa_bindn() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

3.7.  nsa_connect()

   nsa_connect() connects a given NEAT socket to a given remote address.
   Note: this function is provided as legacy wrapper, and it is
   RECOMMENDED to use nsa_connectn() instead.  Note further, that
   nsa_connect() also supports a single address only (i.e. no multi-
   homing). nsa_connectx() SHOULD be used instead to support multi-
   homing.

   Function Prototype:

   int nsa_connect(int sockfd,
                   const struct sockaddr* addr, socklen_t addrlen,
                   struct neat_tlv* opt, const int optcnt)

   Arguments:

   sockfd:  NEAT socket descriptor.

   addr:  Address to connect to.

   addrlen:  Length of the address structure "addr".




Dreibholz               Expires October 13, 2017                [Page 8]

Internet-Draft              NEAT Sockets API                  April 2017


   opt:  NEAT options (NULL, if there are none).

   optcnt:  Number of NEAT options provided by "opt".

   nsa_connect() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the connect() documentation for details.

3.8.  nsa_connectx()

   nsa_connectx() connects a given NEAT socket to a given set of remote
   addresses.  Note: this function is provided as legacy wrapper, and it
   is RECOMMENDED to use nsa_connectn() instead.

   Function Prototype:

   int nsa_connectx(int sockfd,
                    const struct sockaddr* addrs, int addrcnt,
                    neat_assoc_t* id,
                    struct neat_tlv* opt, const int optcnt)

   Arguments:

   sockfd:  NEAT socket descriptor.

   addrs:  Addresses to connect to.

   addrcnt:  Number of addresses in "addr".

   id Pointer to store association ID to (not used yet, use NULL!).

   opt:  NEAT options (NULL, if there are none).

   optcnt:  Number of NEAT options provided by "opt".

   nsa_connectx() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the sctp_connectx() documentation for details.

3.9.  nsa_connectn()

   nsa_connectn() connects a given NEAT socket to a given remote name
   and port.  The remote name is resolved by NEAT to corresponding
   remote addresses.

   Function Prototype:



Dreibholz               Expires October 13, 2017                [Page 9]

Internet-Draft              NEAT Sockets API                  April 2017


   int nsa_connectn(int sockfd, const char* name, const uint16_t port,
                    neat_assoc_t* id,
                    struct neat_tlv* opt, const int optcnt)

   Arguments:

   sockfd:  NEAT socket descriptor.

   name:  Remote name to connect to.

   port:  Remote port number to connect to.

   id Pointer to store association ID to (not used yet, use NULL!).

   opt:  NEAT options (NULL, if there are none).

   optcnt:  Number of NEAT options provided by "opt".

   nsa_connectn() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

3.10.  nsa_listen()

   nsa_listen() marks a given NEAT socket as listening socket, i.e.
   accepting incoming connections.

   Function Prototype:

   int nsa_listen(int sockfd, int backlog)

   Arguments:

   sockfd:  NEAT socket descriptor.

   backlog:  Defines the maximum length to which the queue of pending
      connections for "sockfd" may grow.

   nsa_listen() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the listen() documentation for details.

3.11.  nsa_accept()

   nsa_accept() extracts the first connection request in the queue of
   pending connections for a listening NEAT socket, creates a new
   connected socket, and returns a new NEAT socket descriptor referring
   to that socket.



Dreibholz               Expires October 13, 2017               [Page 10]

Internet-Draft              NEAT Sockets API                  April 2017


   Function Prototype:

   int nsa_accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)

   Arguments:

   sockfd:  NEAT socket descriptor.

   addr:  Pointer to storage space to store the peer's primary address
      to (or NULL, if address is not needed).

   addrlen:  Pointer to variable with size of the storage in "addr" (or
      NULL, if address is not needed).

   nsa_accept() returns the new NEAT socket descriptor in case of
   success, or -1 in case of error.  The error code will be set in the
   errno variable.  In case of success, the peer's primary address is
   stored in "addr", if there is sufficient space.  The variable pointer
   to by "addrlen" will then contain the actual address size.

   See the accept() documentation for details.

3.12.  nsa_shutdown()

   nsa_shutdown() shuts down the connection of a given NEAT socket.

   Function Prototype:

   int nsa_shutdown(int sockfd, int how)

   Arguments:

   sockfd:  NEAT socket descriptor.

   how:  Not used for NEAT sockets (set to SHUT_RDWR).

   nsa_shutdown() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the shutdown() documentation for details.

4.  Options Handling

4.1.  nsa_getsockopt()

   nsa_getsockopt() gets a socket option of a given NEAT socket.

   Function Prototype:



Dreibholz               Expires October 13, 2017               [Page 11]

Internet-Draft              NEAT Sockets API                  April 2017


   int nsa_getsockopt(int sockfd, int level, int optname,
                      void* optval, socklen_t* optlen)

   Arguments:

   sockfd:  NEAT socket descriptor.

   level:  Option level.

   optname:  Option number.

   optval:  Buffer to store option value to.

   optlen:  Pointer to variable with length of the buffer in "optval".

   nsa_getsockopt() returns 0 in case of success, or -1 in case of
   error.  The error code will be set in the errno variable.

   See the getsockopt() documentation for details.

4.2.  nsa_setsockopt()

   nsa_getsockopt() sets a socket option of a given NEAT socket.

   Function Prototype:

   int nsa_setsockopt(int sockfd, int level, int optname,
                      const void* optval, socklen_t optlen)

   Arguments:

   sockfd:  NEAT socket descriptor.

   level:  Option level.

   optname:  Option number.

   optval:  Buffer with option value to set.

   optlen:  Length of buffer with option value.

   nsa_setsockopt() returns 0 in case of success, or -1 in case of
   error.  The error code will be set in the errno variable.

   See the setsockopt() documentation for details.






Dreibholz               Expires October 13, 2017               [Page 12]

Internet-Draft              NEAT Sockets API                  April 2017


4.3.  nsa_opt_info()

   nsa_opt_info() gets a socket option of a given NEAT socket.

   Function Prototype:

   int nsa_opt_info(int sockfd, neat_assoc_t id,
                    int opt, void* arg, socklen_t* size)

   Arguments:

   sockfd:  NEAT socket descriptor.

   id:  Association identifier (0 in case of 1:1-style sockets).

   opt:  Option number.

   arg:  Buffer to store option value to.

   size:  Pointer to variable with length of the buffer in "arg".

   nsa_opt_info() returns 0 in case of success, or -1 in case of error.
   The error code will be set in the errno variable.

   See the sctp_opt_info() documentation for details.

5.  Security

5.1.  nsa_set_secure_identity()

   TBD.

5.2.  ...

   TBD.

6.  Input/Output Handling

6.1.  nsa_write()

   nsa_write() sends data over a given connected NEAT socket.  For NEAT
   sockets, nsa_write() is equal to nsa_send() with "flags" set to 0.

   Function Prototype:

   ssize_t nsa_write(int fd, const void* buf, size_t len)

   Arguments:



Dreibholz               Expires October 13, 2017               [Page 13]

Internet-Draft              NEAT Sockets API                  April 2017


   fd:  NEAT socket descriptor.

   buf:  Data to send.

   len:  Length of data to send.

   nsa_write() returns the number of sent bytes in case of success, or
   -1 in case of error.  The error code will be set in the errno
   variable.

   See the write() documentation for details.

6.2.  nsa_send()

   nsa_send() sends data over a given connected NEAT socket.

   Function Prototype:

   ssize_t nsa_send(int sockfd, const void* buf, size_t len, int flags)

   Arguments:

   sockfd:  NEAT socket descriptor.

   buf:  Data to send.

   len:  Length of data to send.

   flags:  Optional flags (0, if there are none).

   nsa_send() returns the number of sent bytes in case of success, or -1
   in case of error.  The error code will be set in the errno variable.

   See the send() documentation for details.

6.3.  nsa_sendto()

   nsa_sendto() is a wrapper around the sendto() call, using NEAT socket
   descriptors instead.  Note: this function is provided as legacy
   wrapper, and it is RECOMMENDED to use nsa_send() instead.  On NEAT
   sockets, a provided destination address is ignored.

   Function Prototype:

   ssize_t nsa_sendto(int sockfd, const void* buf, size_t len,
                      int flags,
                      const struct sockaddr* to, socklen_t tolen)




Dreibholz               Expires October 13, 2017               [Page 14]

Internet-Draft              NEAT Sockets API                  April 2017


   Arguments:

   sockfd:  NEAT socket descriptor.

   buf:  Data to send.

   len:  Length of data to send.

   flags:  Optional flags (0, if there are none).

   to:  Address to send data to (ignored for NEAT sockets).

   tolen:  Length of address to send data to (ignored for NEAT sockets).

   nsa_sendto() returns the number of sent bytes in case of success, or
   -1 in case of error.  The error code will be set in the errno
   variable.

   See the send() documentation for details.

6.4.  nsa_sendmsg()

   nsa_sendmsg() sends data over a given connected NEAT socket.  The
   data and control information is provided by a msghdr structure.  On
   NEAT sockets, a provided destination address is ignored.

   Function Prototype:

   ssize_t nsa_sendmsg(int sockfd, const struct msghdr* msg, int flags)

   Arguments:

   sockfd:  NEAT socket descriptor.

   msg:  Data to send and corresponding control information as msghdr
      structure.

   flags:  Optional flags (0, if there are none).

   nsa_sendmsg() returns the number of sent bytes in case of success, or
   -1 in case of error.  The error code will be set in the errno
   variable.

   See the sendmsg() documentation for details.







Dreibholz               Expires October 13, 2017               [Page 15]

Internet-Draft              NEAT Sockets API                  April 2017


6.5.  nsa_sendv()

   nsa_sendv() sends data over a given connected NEAT socket.  The data
   and control information is provided by iovec and info structures.  On
   NEAT sockets, a provided destination address is ignored.

   Function Prototype:

   ssize_t nsa_sendv(int sockfd, struct iovec* iov, int iovcnt,
                     struct sockaddr* to, int tocnt,
                     void* info, socklen_t infolen,
                     unsigned int infotype, int flags)

   Arguments:

   sockfd:  NEAT socket descriptor.

   iov:  Data to send provided as iovec structures.

   iovcnt:  Number of provided iovec structures.

   to:  Address(es) to send data to (ignored for NEAT sockets).

   tocnt:  Number of of addresses to send data to (ignored for NEAT
      sockets).

   info:  Control information.

   infolen:  Length of control information.

   infotype:  Type of control information.

   flags:  Optional flags (0, if there are none).

   nsa_sendmsg() returns the number of sent bytes in case of success, or
   -1 in case of error.  The error code will be set in the errno
   variable.

   See the sctp_sendv() documentation for details.

6.6.  nsa_read()

   nsa_read() reads data from a given connected NEAT socket.  For NEAT
   sockets, nsa_read() is equal to nsa_recv() with "flags" set to 0.

   Function Prototype:

   ssize_t nsa_read(int fd, void* buf, size_t len)



Dreibholz               Expires October 13, 2017               [Page 16]

Internet-Draft              NEAT Sockets API                  April 2017


   Arguments:

   fd:  NEAT socket descriptor.

   buf:  Buffer to store read data to.

   len:  Length of the storage buffer.

   nsa_read() returns the number of read bytes in case of success, 0 in
   case of connection shutdown, or -1 in case of error.  The error code
   will be set in the errno variable.

   See the read() documentation for details.

6.7.  nsa_recv()

   nsa_recv() reads data from a given connected NEAT socket.

   Function Prototype:

   ssize_t nsa_recv(int sockfd, void* buf, size_t len, int flags)

   Arguments:

   sockfd:  NEAT socket descriptor.

   buf:  Buffer to store read data to.

   len:  Length of the storage buffer.

   flags:  Optional flags (0, if there are none).

   nsa_recv() returns the number of read bytes in case of success, 0 in
   case of connection shutdown, or -1 in case of error.  The error code
   will be set in the errno variable.

   See the recv() documentation for details.

6.8.  nsa_recvfrom()

   nsa_recvfrom() reads data from a given connected NEAT socket.  The
   peer's sending address of the data (if possible and useful for
   underlying transport protocol) is obtained as well.  Note: this
   function is provided as legacy wrapper, and it is RECOMMENDED to use
   nsa_recv() instead.

   Function Prototype:




Dreibholz               Expires October 13, 2017               [Page 17]

Internet-Draft              NEAT Sockets API                  April 2017


   ssize_t nsa_recvfrom(int sockfd, void* buf, size_t len, int flags,
                        struct sockaddr* from, socklen_t* fromlen)

   sockfd:  NEAT socket descriptor.

   buf:  Buffer to store read data to.

   len:  Length of the storage buffer.

   flags:  Optional flags (0, if there are none).

   from:  Pointer to storage space to store the peer's primary address
      to (or NULL, if address is not needed).

   fromlen:  Pointer to variable with size of the storage in "from" (or
      NULL, if address is not needed).

   nsa_recvfrom() returns the number of read bytes in case of success, 0
   in case of connection shutdown, or -1 in case of error.  The error
   code will be set in the errno variable.  In case of success, the
   peer's sending address (if possible and useful for underlying
   transport protocol) may be stored in "from", if there is sufficient
   space.  The variable pointer to by "fromlen" will then contain the
   actual address size.

   See the recvfrom() documentation for details.

6.9.  nsa_recvmsg()

   nsa_recvmsg() reads data from a given connected NEAT socket.  The
   data and control information buffers are provided by a msghdr
   structure.

   Function Prototype:

   ssize_t nsa_recvmsg(int sockfd, struct msghdr* msg, int flags)

   Arguments:

   sockfd:  NEAT socket descriptor.

   msg:  Data to send and corresponding control information as msghdr
      structure.

   flags:  Optional flags (0, if there are none).






Dreibholz               Expires October 13, 2017               [Page 18]

Internet-Draft              NEAT Sockets API                  April 2017


   nsa_recvmsg() returns the number of read bytes in case of success, 0
   in case of connection shutdown, or -1 in case of error.  The error
   code will be set in the errno variable.

   See the recvmsg() documentation for details.

6.10.  nsa_recvv()

   nsa_recvv() reads data from a given connected NEAT socket.  The data
   and control information buffers are provided by iovec and info
   structures.

   Function Prototype:

   ssize_t nsa_recvv(int sockfd, struct iovec* iov, int iovcnt,
                     struct sockaddr* from, socklen_t* fromlen,
                     void* info, socklen_t* infolen,
                     unsigned int* infotype, int* msg_flags)

   Arguments:

   sockfd:  NEAT socket descriptor.

   iov:  Data to send provided as iovec structures.

   iovcnt:  Number of provided iovec structures.

   from:  Pointer to storage space to store the peer's primary address
      to (or NULL, if address is not needed).

   fromlen:  Pointer to variable with size of the storage in "from" (or
      NULL, if address is not needed).

   info:  Pointer to storage space for control information.

   infolen:  Pointer to variable with length of control information.

   infotype:  Pointer to variable for storing the control information
      type to.

   flags:  Pointer to variable with optional flags.

   nsa_recvv() returns the number of sent received in case of success,
   or -1 in case of error.  The error code will be set in the errno
   variable.

   See the sctp_recvv() documentation for details.




Dreibholz               Expires October 13, 2017               [Page 19]

Internet-Draft              NEAT Sockets API                  April 2017


7.  Poll and Select

7.1.  nsa_poll()

   nsa_poll() waits for activity (input/output/error/...) on a set of
   given NEAT sockets.

   Function Prototype:

   int nsa_poll(struct pollfd* ufds, const nfds_t nfds, int timeout)

   Arguments:

   ufds:  NEAT socket descriptor and requested activity for each NEAT
      socket.

   nfds:  Number of sockets given by "ufds".

   timeout:  Timeout in milliseconds.

   nsa_poll() returns the number of NEAT sockets with activity in case
   of success, 0 in case of timeout, or -1 in case of error.  The error
   code will be set in the errno variable.

   See the poll() documentation for details.

7.2.  nsa_select()

   nsa_select() is a wrapper around the select() call, using NEAT socket
   descriptors instead.  Note: this function is provided as legacy
   wrapper, and it is RECOMMENDED to use nsa_poll() instead.

   Function Prototype:

   int nsa_select(int n,
                  fd_set* readfds, fd_set* writefds, fd_set* exceptfds,
                  struct timeval* timeout)

   See the select() documentation for details.

8.  Address Handling

8.1.  nsa_getsockname()

   nsa_getsockname() obtains the first local address of a socket.  Note:
   this function is provided as legacy wrapper, and it is RECOMMENDED to
   use nsa_getladdrs() instead to support multi-homed transport
   protocols!



Dreibholz               Expires October 13, 2017               [Page 20]

Internet-Draft              NEAT Sockets API                  April 2017


   Function Prototype:

   int nsa_getsockname(int sockfd,
                       struct sockaddr* name, socklen_t* namelen)

   Arguments:

   sockfd:  NEAT socket descriptor.

   name:  Storage space for the address.

   namelen:  Pointer to variable with the storage space's size.

   Return Value:

   nsa_getsockname() returns 0 in case of success (with the actual
   address size stored into the "namelen" variable), or -1 in case of
   error.  The error code will be set in the errno variable.

   See the getsockname() documentation for details.

8.2.  nsa_getpeername()

   nsa_getpeername() obtains the first remote address of a connected
   socket.  Note: this function is provided as legacy wrapper, and it is
   RECOMMENDED to use nsa_getpaddrs() instead to support multi-homed
   transport protocols!

   Function Prototype:

   int nsa_getpeername(int sockfd,
                       struct sockaddr* name, socklen_t* namelen)

   Arguments:

   sockfd:  NEAT socket descriptor.

   name:  Storage space for the address.

   namelen:  Pointer to variable with the storage space's size.

   Return Value:

   nsa_getpeername() returns 0 in case of success (with the actual
   address size stored into the "namelen" variable), or -1 in case of
   error.  The error code will be set in the errno variable.

   See the getpeername() documentation for details.



Dreibholz               Expires October 13, 2017               [Page 21]

Internet-Draft              NEAT Sockets API                  April 2017


8.3.  nsa_getladdrs()

   nsa_getladdrs() obtains the local addresses of a socket.  The storage
   space for the addresses will be automatically allocated and needs to
   be freed by nsa_freeladdrs().

   Function Prototype:

   int nsa_getladdrs(int sockfd, neat_assoc_t id,
                     struct sockaddr** addrs)

   Arguments:

   sockfd:  NEAT socket descriptor.

   id:  Association identifier (0 in case of 1:1-style sockets).

   addrs:  Pointer to variable to store pointer to addresses to.

   nsa_getladdrs() returns the number of addresses stored into a newly
   allocated space.  The pointer to this space is stored into the
   variable provided by "addrs".  In case of error, -1 is returned, and
   the error code will be set in the errno variable.

8.4.  nsa_freeladdrs()

   nsa_freeladdrs() frees addresses obtained by nsa_getladdrs().

   Function Prototype:

   void nsa_freeladdrs(struct sockaddr* addrs)

   Arguments:

   addrs:  Pointer to addresses to be freed.

8.5.  nsa_getpaddrs()

   nsa_getpaddrs() obtains the remote addresses of a connected socket.
   The storage space for the addresses will be automatically allocated
   and needs to be freed by nsa_freepaddrs().

   Function Prototype:

   int nsa_getpaddrs(int sockfd, neat_assoc_t id,
                     struct sockaddr** addrs)

   Arguments:



Dreibholz               Expires October 13, 2017               [Page 22]

Internet-Draft              NEAT Sockets API                  April 2017


   sockfd:  NEAT socket descriptor.

   id:  Association identifier (0 in case of 1:1-style sockets).

   addrs:  Pointer to variable to store pointer to addresses to.

   nsa_getpaddrs() returns the number of addresses stored into a newly
   allocated space.  The pointer to this space is stored into the
   variable provided by "addrs".  In case of error, -1 is returned, and
   the error code will be set in the errno variable.

8.6.  nsa_freepaddrs()

   nsa_freepaddrs() frees addresses obtained by nsa_getpaddrs().

   Function Prototype:

   void nsa_freepaddrs(struct sockaddr* addrs)

   Arguments:

   addrs:  Pointer to addresses to be freed.

9.  Miscellaneous

9.1.  nsa_open()

   nsa_open() is a wrapper around the open() call, returning a NEAT
   socket descriptor instead.

   Function Prototype:

   int nsa_open(const char* pathname, int flags, mode_t mode)

   See the open() documentation for details.

9.2.  nsa_creat()

   nsa_creat() is a wrapper around the creat() call, returning a NEAT
   socket descriptor instead.

   Function Prototype:

   int nsa_creat(const char* pathname, mode_t mode)

   See the creat() documentation for details.





Dreibholz               Expires October 13, 2017               [Page 23]

Internet-Draft              NEAT Sockets API                  April 2017


9.3.  nsa_pipe()

   nsa_pipe() is a wrapper around the pipe() call, returning NEAT socket
   descriptors instead.

   Function Prototype:

   int nsa_pipe(int fds[2])

   See the pipe() documentation for details.

9.4.  nsa_ioctl()

   nsa_ioctl() is a wrapper around the ioctl() call, using a NEAT socket
   descriptor instead.

   Function Prototype:

   int nsa_ioctl(int fd, int request, const void* argp)

   See the ioctl() documentation for details.

10.  Code Examples

   Running code examples can be found in the NEAT Git repository:

      URL: https://github.com/NEAT-project/neat

      Branch: dreibh/neat-socketapi [2]

      Directory: socketapi/examples/ [3]

11.  Testbed Platform

   A large-scale and realistic Internet testbed platform with support
   for the multi-homing feature of the underlying SCTP and MPTCP
   protocols is NorNet.  A description of NorNet is provided in [5],
   [6], some further information can be found on the project website
   [8].

12.  Security Considerations

   Security considerations for the SCTP sockets API are described in
   [2].







Dreibholz               Expires October 13, 2017               [Page 24]

Internet-Draft              NEAT Sockets API                  April 2017


13.  IANA Considerations

   This document does not require IANA actions.

14.  Acknowledgments

   The authors would like to thank (ADD NAMES HERE) for their support.

15.  References

15.1.  Normative References

   [1]        Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [2]        Stewart, R., Tuexen, M., Poon, K., Lei, P., and V.
              Yasevich, "Sockets API Extensions for the Stream Control
              Transmission Protocol (SCTP)", RFC 6458,
              DOI 10.17487/RFC6458, December 2011,
              <http://www.rfc-editor.org/info/rfc6458>.

   [3]        Gjessing, S. and M. Welzl, "A Minimal Set of Transport
              Services for TAPS Systems", draft-gjessing-taps-minset-04
              (work in progress), March 2017.

   [4]        Welzl, M., Tuexen, M., and N. Khademi, "On the Usage of
              Transport Features Provided by IETF Transport Protocols",
              draft-ietf-taps-transports-usage-04 (work in progress),
              April 2017.

15.2.  Informative References

   [5]        Dreibholz, T., "NorNet - Building an Inter-Continental
              Internet Testbed based on Open Source Software",
               Proceedings of the LinuxCon Europe, October 2016,
              <https://simula.no/file/linuxcon2016-presentationpdf/
              download>.

   [6]        Gran, E., Dreibholz, T., and A. Kvalbein, "NorNet Core - A
              Multi-Homed Research Testbed", Computer Networks, Special
              Issue on Future Internet Testbeds Volume 61, Pages 75-87,
              ISSN 1389-1286, DOI 10.1016/j.bjp.2013.12.035, March 2014,
              <https://www.simula.no/file/simulasimula2236pdf/download>.






Dreibholz               Expires October 13, 2017               [Page 25]

Internet-Draft              NEAT Sockets API                  April 2017


   [7]        Dreibholz, T., "NEAT - A New, Evolutive API and Transport-
              Layer Architecture for the Internet", Online:
              https://www.neat-project.org/, 2017, <https://www.neat-
              project.org/>.

   [8]        Dreibholz, T., "NorNet - A Real-World, Large-Scale Multi-
              Homing Testbed", Online: https://www.nntb.no/, 2017,
              <https://www.nntb.no/>.

   [9]        Fairhurst, G., Jones, T., Bozakov, Z., Brunstroem, A.,
              Damjanovi&#263;, D., Eckert, K., Grinnemo, K., Hansen, A.,
              Khademi, N., Mangiante, S., McManus, P., Papastergiou, G.,
              Ros, D., Tuexen, M., Vyncke, E., and M. Welzl, "NEAT
              Architecture",  Number D1.1, December 2015,
              <https://www.neat-project.org/wp-content/uploads/2016/02/
              D1.1.pdf>.

   [10]       Welzl, M., Brunstroem, A., Damjanovi&#263;, D., Evensen,
              K., Eckert, T., Fairhurst, G., Khademi, N., Mangiante, S.,
              Petlund, A., Ros, D., and M. Tuexen, "NEAT - First Version
              of Services and APIs",  Number D1.2, March 2016,
              <https://www.neat-project.org/wp-content/uploads/2017/03/
              D1.2-public.pdf>.

   [11]       Khademi, N., Bozakov, Z., Brunstroem, A., Damjanovi&#263;,
              D., Evensen, K., Fairhurst, G., Grinnemo, K., Jones, T.,
              Mangiante, S., Papastergiou, G., Ros, D., Tuexen, M., and
              M. Welzl, "NEAT - First Version of Low-Level Core
              Transport System",  Number D2.1, March 2016,
              <https://www.neat-project.org/wp-content/uploads/2015/05/
              D2.1.pdf>.

   [12]       Khademi, N., Bozakov, Z., Brunstroem, A., Dale, Oe.,
              Damjanovi&#263;, D., Evensen, K., Fairhurst, G., Grinnemo,
              K., Jones, T., Mangiante, S., Petlund, A., Ros, D.,
              Stenberg, D., Tuexen, M., Weinrank, F., and M. Welzl,
              "NEAT - Core Transport System, with both Low-level and
              High-level Components",  Number D2.2, March 2017,
              <https://www.neat-project.org/wp-content/uploads/2017/03/
              D2.2-public.pdf>.

15.3.  URIs

   [2] https://github.com/NEAT-project/neat/tree/dreibh/neat-socketapi

   [3] https://github.com/NEAT-project/neat/tree/dreibh/neat-
       socketapi/socketapi/examples




Dreibholz               Expires October 13, 2017               [Page 26]

Internet-Draft              NEAT Sockets API                  April 2017


Author's Address

   Thomas Dreibholz
   Simula Research Laboratory, Network Systems Group
   Martin Linges vei 17
   1364 Fornebu, Akershus
   Norway

   Phone: +47-6782-8200
   Fax:   +47-6782-8201
   Email: dreibh@simula.no
   URI:   https://simula.no/people/dreibh







































Dreibholz               Expires October 13, 2017               [Page 27]
