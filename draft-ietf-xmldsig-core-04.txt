
XML Digital Signatures Working Group               D. Eastlake,
INTERNET-DRAFT                                     IBM
draft-ietf-xmldsig-core-04.txt                     J. Reagle,
Expires August 08, 2000                            W3C/MIT
                                                   D. Solo,
                                                   Citigroup

                         XML-Signature Syntax
                                      
Copyright Notice

   Copyright (c) 2000 The Internet Society & W3C (MIT, INRIA, Keio), All
   Rights Reserved.
   
IETF Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.
   
   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.
   
   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet- Drafts as reference
   material or to cite them other than as "work in progress."
   
   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt
   
   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.
   
W3C Status of this document

   This document is a production of the joint IETF/W3C XML Signature
   Working Group.
   
   http://www.w3.org/Signature
   
   The comparable html draft of this version may be found at
   
   http://www.w3.org/TR/2000/WD-xmldsig-core-20000208/
   
   The latest version of this draft series may be found at:
   
   http://www.w3.org/TR/xmldsig-core/
   
   This is a public Working Draft of the IETF/W3C XML Signature Working
   Group . This version follows from the January face-to-face meeting. We
   hope to issue an institutional (IETF/W3C) Last Call within four weeks.
   This version includes and XML Schema definition and a DTD; both of
   which are fairly mature but may contain bugs.
   

Eastlke, Reagle, Solo					[Page 1]

Internet Draft		XML-Signature Syntax	February 2000


   Please send comments to the editors and cc: the list
   <w3c-ietf-xmldsig@w3.org>. Publication as a Working Draft does not
   imply endorsement by the W3C membership or IESG. This is a draft
   document and may be updated, replaced or obsoleted by other documents
   at any time. It is inappropriate to cite W3C Drafts as other than
   "work in progress." A list of current W3C working drafts can be found
   at http://www.w3.org/TR
   
   Patent disclosures relevant to this specification may be found on the
   WG's patent disclosure page.
   
Abstract

   This document specifies XML digital signature processing rules and
   syntax. XML Signatures provide integrity, message authentication,
   and/or signer authentication services for data of any type, whether
   located within the XML that includes the signature or elsewhere.
   
Table of Contents

    1. Introduction
         1. Editorial Conventions
         2. Design Philosophy
         3. Namespaces and Identifiers
         4. Acknowledgements
    2. Signature Overview
         1. The Signature Element
         2. The SignedInfo Element
         3. The Reference Element
         4. The Manifest Element
         5. The SignatureProperties Element
    3. Processing Rules
         1. Signature Generation
         2. Signature Validation
    4. Core Signature Syntax
         1. The Signature element
         2. The SignatureValue Element
         3. The SignedInfo Element
         4. The KeyInfo Element
         5. The Object Element
    5. Additional Signature Syntax
         1. The Manifest Element
         2. The SignatureProperties Element
         3. Other Useful Types
         4. Processing Instructions
         5. Comments in dsig Elements
    6. Algorithms
         1. Algorithm Identifiers and Implementation Requirements
         2. Message Digests
         3. Message Authentication Codes
         4. Signature Algorithms
         5. Canonicalization Algorithms
         6. Transform Algorithms

Eastlke, Reagle, Solo					[Page 2]

Internet Draft		XML-Signature Syntax	February 2000


    7. XML Canonicalization and Syntax Constraint Considerations
         1. XML 1.0, Syntax Constraints, and Canonicalization
         2. DOM/SAX Processing and Canonicalization
    8. Security Considerations
         1. Only What is Signed is Secure
         2. Only What is "Seen" Should be Signed
         3. Check the Security Model
         4. Algorithms, Key Lengths, Etc.
    9. Schema, DTD, and Data Model
   10. Example Syntax
   11. Definitions
   12. References
     _________________________________________________________________
   
1.0 Introduction

   This document specifies XML syntax and processing rules for creating
   and representing digital signatures. XML Signatures can be applied to
   any digital content (data object), including XML. An XML Signature may
   be applied to the content of one or more resources: enveloped or
   enveloping signatures are over data within the same XML document as
   the signature; detached signatures are over data external to the
   signature document.
   
   This specification also defines other useful types including methods
   of referencing collections of resources, and key management and
   algorithm definitions.
   
  1.1 Editorial Conventions
  
   For readability we use the term "signature" to refer generically to
   public key signatures and secret key authenticators. We use the term
   "authenticator" and "authentication" specifically when reffering to
   keyed hash message authentication.
   
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   specification are to be interpreted as described in RFC2119
   [KEYWORDS]:
   
     "they MUST only be used where it is actually required for
     interoperation or to limit behavior which has potential for causing
     harm (e.g., limiting retransmissions)"
     
   Consequently, we use these capitalized keywords to unambiguously
   specify requirements over protocol and application features and
   behavior that affect the interoperability and security of
   implementations. These key words are not used (capitalized) to
   describe XML grammar; schema definitions formally and unambiguously
   describe such requirements and we wish to reserve the prominence of
   these terms for the natural language descriptions of protocols and
   features. For instance, an XML attribute might be described as being
   "optional." Compliance with the XML-namespace specification is

Eastlke, Reagle, Solo					[Page 3]

Internet Draft		XML-Signature Syntax	February 2000


   described as "REQUIRED."
   
  1.2 Design Philosophy
  
   The design philosophy and requirements of this specification are
   addressed in the XML-Signature Requirements document
   [XML-Signature-RD].
   
  1.3 Versions, Namespaces and Identifiers
  
   No provision is made for an explicit version number in this syntax. If
   a future version is needed, it will use a different namespace  The XML
   namespace [XML-ns] URI that MUST be used by experimental
   implementations of this dated specification is:
   
   xmlns="http://www.w3.org/2000/01/xmldsig#"
   
   This namespace is also used as the prefix for algorithm identifiers
   used by this specification. While applications MUST support XML and
   XML-namespaces, the use of internal entities [XML] or our "dsig" XML
   namespace prefix and defaulting/scoping conventions are OPTIONAL; we
   use these facilities so as to provide compact and readable examples.
   
   This specification uses Uniform  Resource Identifiers [URI] to
   identify resources, algorithms, and semantics. The URI in the
   namespace declaration above is also used as a prefix for URIs under
   the control of this specification. For resources not under the control
   of this specification, we use the designated Uniform Resource Names
   [URN] or Uniform Resource Locators [URL] defined by its normative
   external specification. If an external specification has not allocated
   itself a Uniform Resource Identifier we allocate an identifier under
   our own namespace. For instance:
   
   SignatureProperties is identified and defined by this specification's
          namespace
          http://www.w3.org/2000/01/xmldsig#SignatureProperties
          
   XSLT is identified and defined by an external namespace
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   SHA1 is identified via this specification's namespace and defined via
          a normative reference
          http://www.w3.org/2000/01/xmldsig#sha1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          
   This specification uses both XML Schemas [XML-schema] and DTDs [XML].
   (Readers unfamiliar with DTD syntax may wish to refer to Ron Bourret's
   "Declaring Elements and Attributes in an XML DTD" [Bourret].)
   
   Finally, in order to provide for terse namespace declarations we
   sometimes use XML internal entities [XML] as macros within URIs. For
   instance:

Eastlke, Reagle, Solo					[Page 4]

Internet Draft		XML-Signature Syntax	February 2000


   
   <?xml version='1.0'?>
   <!DOCTYPE Signature SYSTEM "xmldsig-core-schema.dtd" [
   <!ENTITY dsig "http://www.w3.org/2000/01/xmldsig#">
   ]>
   <Signature xmlns="&dsig;">
     <SignedInfo Id="mypage">
     ...
   
  1.4 Acknowledgements
  
     * Milton Anderson, FSTC
     * Mark Bartel, JetForm Corporation (Author)
     * John Boyer, UWI.com (Author)
     * Richard Brown, Globeset
     * Donald Eastlake 3rd, Motorola  (Chair, Editor)
     * Barb Fox, Microsoft (Author)
     * Phillip Hallam-Baker, VeriSign Inc
     * Richard Himes, US Courts
     * Joseph Reagle, W3C (Chair, Editor)
     * Ed Simon , Entrust Technologies Inc. (Author)
     * Chris Smithies, PenOp
     * David Solo, Citigroup (Editor)
     * Winchel Todd Vincent III, GSU
     * Greg Whitehead, Signio Inc.
     * Gregor Karlinger, IAIK
       
2.0 Signature Overview

   This section provides an overview of XML digital signature syntax. An
   overview of processing appears in section 3:Processing Rules. The
   formal syntax is found in section 4: Core Signature Syntax and section
   5: Additional Signature Syntax.
   
   In this section, an informal representation is used to describe the
   structure of the XML signature syntax. This representation omits many
   attributes and details. The following suffix symbols are used to
   represent the number of times elements may occur: "?" denotes zero or
   one occurrence; "+" denotes one or more occurrences; and "*" denotes
   zero or more occurrences.
   
  2.1 The Signature Element
  
   XML Signatures are very flexible and can sign arbitrary digital
   content (data objects). An XML Signature is applied via an
   indirection. Data objects are digested; the resulting value is placed
   in an element (with other information) and that element is then
   digested and cryptographically signed. While the data object(s) are
   not directly operated on by a cryptographic signature algorithm, we
   still refer to the signature as being over the data object(s).
   Somtimes content is obtained by dereferencing an identified resource.
   Within an XML document, signatures are related to data objects via
   IDREFs [XML] and the data can be included within an enveloping

Eastlke, Reagle, Solo					[Page 5]

Internet Draft		XML-Signature Syntax	February 2000


   signature or can enclose an enveloped signature. Signatures are
   related to external data objects via URIs [URI] and the signature and
   data object are said to be detached.
   
   XML digital signatures are represented by the Signature element which
   has the following structure:
   
   <Signature>
     (SignedInfo)
     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The required SignedInfo element is the information which is actually
   signed. SignedInfo includes a list of References to data objects and
   their calculated digest value. The core validation consists of two
   mandatory processes: validation of the signature over SignedInfo and
   validation of each Reference digest within SignedInfo. The algorithms
   used in calculating the SignatureValue are also included in the signed
   information while the SignatureValue element is outside SignedInfo.
   
   KeyInfo indicates what key is to be used to validate the signature.
   Possible forms for identification include certificates, key names, and
   key agreement algorithms and information -- we define only a few.
   KeyInfo is OPTIONAL for two reasons. First, KeyInfo might contain
   information the signer does not wish to reveal to all signature
   verifiers. Second, the information may be known within the
   application's context and need not be represented explicitly. Since
   KeyInfo is outside of SignedInfo, if the signer wishes to bind the
   keying information to the signature, a Reference can easily identify
   and include the KeyInfo as part of the signature.
   
   Object is an optional element for including data objects within the
   signature document. The Object can be optionally typed and/or encoded.
   
   Signature properties, such as time of signing, can be optionally
   included in a SignatureProperties within Object. (These properties are
   traditionally called signature "attributes" although that term in that
   context has no relationship to the XML term "attribute".)
   SignatureProperties can be included within an Object and signed at the
   signer's discretion.
   
  2.2 The SignedInfo Element
  
   The SignedInfo element has the structure indicated below.
   
   <Signature>
     <SignedInfo>
       (CanonicalizationMethod)?
       (SignatureMethod)
       (Reference)+
     </SignedInfo>

Eastlke, Reagle, Solo					[Page 6]

Internet Draft		XML-Signature Syntax	February 2000


     (SignatureValue)
     (KeyInfo)?
     (Object)*
   </Signature>
   
   The CanonicalizationMethod is the algorithm which is used to
   canonicalize the SignedInfo element before it is digested as part of
   the signature operation. In the absence of a CanonicalizationMethod
   element, no canonicalization is done.
   
   The SignatureMethod is the algorithm used to convert the canonicalized
   SignedInfo into the SignatureValue. It is a combination of a digest
   algorithm and a key dependent algorithm and possibly other algorithms
   such as padding, for example RSA-SHA1 or HMAC-SHA1. The algorithm
   names are signed to resist attacks based on substituting a weaker
   algorithm.
   
   To promote application interoperability we specify mandatory to
   implement canonicalization, digest, and signature algorithms. We
   specify additional algorithms as recommended or optional and the
   signature design permits arbitrary signer algorithm specification.
   
   Each Reference element includes the digest method and resulting digest
   value calculated over the identified data object. It also may include
   transformations that produce the input to the digest operation. A data
   object is signed by computing its digest value and a signature over
   that value. The signature is later checked via reference and signature
   validation.
   
  2.3 The Reference Element
  
   The Reference element has the structure indicated below.
   
   ...
   <SignedInfo>
      (CanonicalizationMethod)?
      (SignatureMethod)
      (<Reference (URI=|IDREF=)? Type=?>
        (Transforms)?
        (DigestMethod)
        (DigestValue)
      </Reference>)+
   </SignedInfo>
   ...
   
   The optional URI/IDREF attribute of Reference identifies the data
   object to be signed. This attribute may be omitted on at most one
   Reference in a Signature. (This limitation is imposed in order to
   ensure that references and objects may be matched unambiguously.)
   
   This identification, along with the transforms, is a description
   provided by the signer on how they obtained the signed data object in
   the form it was digested (i.e. the digested content). The verifier

Eastlke, Reagle, Solo					[Page 7]

Internet Draft		XML-Signature Syntax	February 2000


   (i.e., relying party) may obtain the digested content in another
   method so long as the digest verifies. In particular, the verifier may
   obtain the content from a different location such as a local store)
   than that specified in the URI/IDREF.
   
   The optional Type attribute provides information about the resource
   identified by the URI/IDREF. In particular, it can indicate that it is
   an Object, SignatureProperties, or Manifest element. This can be used
   by applications to initiate special processing of some Reference
   elements. References to an XML data element within an Object element
   SHOULD identify the actual element pointed to. Where the element
   content is not XML (perhaps it is binary or encoded data) the
   reference should identify the Object and the Reference Type, if given,
   SHOULD indicate Object. Note, that Type is advisory and no action
   based on it or checking of its correctness is required by core
   behaviour.
   
   Transforms is an optional ordered list of processing steps that were
   applied to the resource's content before it is digested. Transforms
   can include operations such as canonicalization, encoding/decoding
   (including compression/inflation), XSLT and XPath. XPath transforms
   permit the signer to derive an XML document that omits portions of the
   source document. Consequently those excluded portions can change
   without affecting signature validity (this is how the Working Group
   satisfied the requirement of signing portions of a document.) For
   example, if the resource being signed encloses the signature itself,
   such a transform must be used to exclude the signature value from its
   own computation. If no Transforms element is present, the resource's
   content is digested directly.
   
   Arbitrary user specified transforms are permitted. To promote
   interoperability, we specify mandatory to implement canonicalization
   and decoding transformation algorithms. Additional canonicalization,
   coding, XSLT, and XPath based transform algorithms are specified as
   recommended or optional.
   
   DigestMethod is the algorithm applied to the data, after Transforms is
   applied if specified, to yield the DigestValue. The signing of the
   DigestValue is what bind's a resources content to the signer's key.
   
  2.4 The Manifest Element
  
   The Manifest element is provided to meet additional requirements not
   directly addressed by this mandatory part of this specification. The
   level of indirection provided by these elements readily meets these
   requirements. Two examples follow.
   
   First, applications frequently need to efficiently sign multiple data
   objects even where the signature operation itself is an expensive
   public key signature. This requirement can be achieved by including
   multiple References within SignedInfo since the inclusion of each
   digest secures the data digested. However, some applications may not
   want the core validation behavior associated with this approach

Eastlke, Reagle, Solo					[Page 8]

Internet Draft		XML-Signature Syntax	February 2000


   because it requires References within SignedInfo to undergo reference
   validation -- the DigestValue elements are checked. Some applications
   may wish to reserve reference validation decision logic to themselves.
   For example, an application might receive a signature valid SignedInfo
   element that includes three References. If a single Reference fails
   (the identified data object when digested does not yield the specified
   DigestValue) the signature would fail core validation. However, the
   application may wish to treat the signature over the two valid
   References as valid.
   
   Second, consider an application where many signatures (using different
   keys) are applied to a large number of documents. An inefficient
   solution is to have a separate signature (per key) repeatedly applied
   to a large SignedInfo element (with many References); this is wasteful
   and redundant.
   
   To address these requirements, the Manifest element type has been
   defined which may be referenced by SignedInfo Reference elements.
   First, the Manifest element may contain a collection of References,
   but leaves reference validation up to the application. Thus the first
   case above can be solved by simply putting one reference inside
   SignedInfo to a Manifest which references the three data objects.
   Second, multiple signatures over a large number of References need
   only point to a single Manifest with the many references.
   
   The structure of Manifest, which reuses the Reference element
   described above, is as follows:
   
   <Manifest>
     (Reference)*
   </Manifest>
   
   Manifest may appear as the content of an Object. Note that an
   application could decide whether to verify a DigestValue in a Manifest
   based on the Type given in the enclosing Reference.
   
  2.5 The SignatureProperties Element
  
   This specification does not address mechanisms for making statements
   or assertions. Instead, this whole document simply defines what it
   means for something to be signed by an XML Signature (message
   authentication, integrity, and/or signer authentication). Applications
   that wish to represent other semantics must rely upon other
   technologies, such as [XML, XML-schema, RDF]. However, we do define a
   SignatureProperties element type for the inclusion of assertions about
   the signature itself (e.g., the time of signing or the serial number
   of hardware used in cryptographic processes). Such assertions may be
   signed by including a Reference for the SignatureProperties in
   SignedInfo.
   
   <SignatureProperties>
     (SignatureProperty Target= )*
   </SignatureProperties>

Eastlke, Reagle, Solo					[Page 9]

Internet Draft		XML-Signature Syntax	February 2000


   
   The structure of SignatureProperties is shown above. Any content about
   the signature generation may be located within the SignatureProperty
   element. The mandatory Target attribute references the element to
   which the property applies. In particular, target may include a
   reference to a SignedInfo or Reference element.
   
3.0 Processing Rules

   The sections below describe the operations to be performed as part of
   signature generation and validation.
   
  3.1 Generation
  
   The REQUIRED steps include the generation of References and the
   SignatureValue over SignedInfo.
   
    3.1.1 Reference Generation
    
   For each data object being signed:
    1. Apply the Transforms, as determined by the application, to the
       data object.
    2. Calculate the digest value over the resulting data object.
    3. Create a Reference element, including the (optional)
       identification of the data object, any (optional) transform
       elements, the digest algorithm and the DigestValue.
       
    3.1.2 Signature Generation
    
    1. Create SignedInfo element with SignatureMethod,
       CanonicalizationMethod if required, and Reference(s).
    2. Canonicalize and then calculate the SignatureValue over SignedInfo
       based on algorithms specified in SignedInfo.
    3. Construct the Signature element that includes SignedInfo, Object
       (s) (if desired, encoding may be different than that used for
       signing), KeyInfo (if required), and SignatureValue.
       
  3.2 Validation
  
   The REQUIRED steps of core validation include (1) reference
   validation, the verification of the digest contained in each Reference
   in SignedInfo, and (2) the cryptographic signature validation of the
   signature calculated over SignedInfo.
   
    3.2.1 Reference Validation
    
   For each Reference in SignedInfo:
    1. Obtain the data object to be digested. (The signature application
       may rely upon the identification (URI/IDREF) and Transforms
       provided by the signer in the Reference element, or it may obtain
       the content through other means such as a local cache.)
    2. Digest the resulting data object using the DigestMethod specified
       in its Reference specification.

Eastlke, Reagle, Solo					[Page 10]

Internet Draft		XML-Signature Syntax	February 2000


    3. Compare the generated digest value against DigestValue in
       SignedInfo; if there is any mismatch, validation fails.
       
    3.2.2 Signature Validation
    
    1. Canonicalize the SignedInfo element based on the
       CanonicalizationMethod, if any, in SignedInfo.
    2. Obtain the keying information from KeyInfo or from an external
       source.
    3. Use the specified SignatureMethod to validate the SignatureValue
       over the (optionally canonicalized) SignedInfo element.
       
4.0 Core Signature Syntax

   The general structure of an XML signature is described in section 2:
   Signature Overview. This section provides detailed syntax of the core
   signature features and actual examples. Features described in this
   section are mandatory to implement unless otherwise indicated. The
   syntax is defined via [XML-Schema] with the following XML preamble,
   declaration, and internal entity:
Schema Definition:

<?xml version='1.0'?>
<!DOCTYPE schema
   SYSTEM 'http://www.w3.org/TR/1999/WD-xmlschema-1-19991217/structures.dtd'
  [
   <!ENTITY dsig 'http://www.w3.org/2000/01/xmldsig#'>
  ]>

<schema targetNamespace='&dsig;'
   version='0.1'
   xmlns='http://www.w3.org/1999/XMLSchema'
   xmlns:ds='&dsig;'>

  4.1 The Signature element
  
   The Signature element is the root element of a XML Signature. A simple
   example of a complete signature follows:
   
   Dummy Example:
   
   <!DOCTYPE Signature [
   <!ENTITY dsig 'http://www.w3.org/2000/01/xmldsig#'>]>
   <Signature xmlns="http://www.w3.org/2000/01/xmldsig#">
     <SignedInfo>
       <CanonicalizationMethod
        Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729/" />
       <SignatureMethod Algorithm="&dsig;dsaWithSHA-1"/>
       <Reference Location="http://www.mypage.com">
         <DigestMethod Algorithm="&dsig;sha1"/>
         <DigestValue>a23bcd43</DigestValue>
       </Reference>
     </SignedInfo>

Eastlke, Reagle, Solo					[Page 11]

Internet Draft		XML-Signature Syntax	February 2000


     <SignatureValue>C0CFFrVLtRlk</SignatureValue>
     <KeyInfo>
        <KeyValue>MIIBtzCCASwGByqGSM44BAE</KeyValue>
     </KeyInfo>
   </Signature>
Schema Definition:

   <element name='Signature'>
     <type content='elementOnly'>
       <group order='seq' minOccurs='1' maxOccurs='1'>
          <element ref='ds:SignedInfo' minOccurs='1' maxOccurs='1'/>
          <element ref='ds:SignatureValue' minOccurs='1' maxOccurs='1'/>
          <element ref='ds:KeyInfo' minOccurs='0' maxOccurs='1'/>
          <element ref='ds:Object' minOccurs='0' maxOccurs='*'/>
        </group>
        <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
     </type>
   </element>
DTD:

<!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?, Object*)  >
<!ATTLIST Signature
        xmlns   CDATA   #FIXED 'http://www.w3.org/2000/01/xmldsig#'
        Id      ID      #IMPLIED >

  4.2 The SignatureValue Element
  
   The SignatureValue element contains the actual value of the digital
   signature. The encoding of this value is determined by
   SignatureMethod. Base64 [MIME] is the encoding method for all
   SignatureMethods specified within this specification. The ability to
   define a SignatureMethod and SignatureValue pair which includes
   multiple distinct signatures is explicitly permitted (e.g.
   "rsawithsha-1 and ecdsawithsha-1").
Schema Definition:

<element name='SignatureValue' type='string'/>
DTD:

<!ELEMENT SignatureValue  (#PCDATA)  >

  4.3 The SignedInfo Element
  
   The structure of SignedInfo includes the canonicalization algorithm
   (if any), a signature algorithm, and one or more references. The
   SignedInfo element may contain an optional ID attribute that will
   allow it to be referenced by other signatures and objects.
Schema Definition:

<element name='SignedInfo'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
          <element ref='ds:CanonicalizationMethod' minOccurs='0' maxOccurs='1'/

Eastlke, Reagle, Solo					[Page 12]

Internet Draft		XML-Signature Syntax	February 2000


>
          <element ref='ds:SignatureMethod' minOccurs='1' maxOccurs='1'/>
          <element ref='ds:Reference' minOccurs='1' maxOccurs='*'/>
        </group>
        <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT SignedInfo (CanonicalizationMethod?,
        SignatureMethod,  Reference+)  >
<!ATTLIST SignedInfo
        Id       ID      #IMPLIED >

   SignedInfo does not include explicit signature or digest properties
   (such as calculation time, cryptographic device serial number, etc.).
   If an application needs to associate properties with the signature or
   digest, it may include such information in a   SignatureProperties
   element found within an Object element.
   
    4.3.1 The CanonicalizationMethod Element
    
   CanonicalizationMethod is an optional element which specifies the
   canonicalization algorithm applied to the SignedInfo element prior to
   performing signature calculations. This element uses the general
   structure here for algorithms described in section 5.1: Algorithm
   Identifiers. Possible options may include a minimal algorithm (CRLF
   and charset normalization), or more extensive operations such as
   [XML-C14N]. If the CanonicalizationMethod is omitted, no change is
   made to SignedInfo before digesting. (Note this may lead to
   interoperability failures as other applications may not serialize it
   as the creators application did by default.)
Schema Definition:

<element name='CanonicalizationMethod'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='uri' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT CanonicalizationMethod ANY >
<!ATTLIST CanonicalizationMethod
          Algorithm CDATA #REQUIRED >

    4.3.2 The SignatureMethod Element
    
   SignatureMethod is a required element which specifies the algorithm
   used for signature generation and validation. This algorithm
   identifies all cryptographic functions involved in the signature
   operation (e.g. hashing, public key algorithms, MACs, padding, etc.).
   This element uses the general structure here for algorithms described
   in section 5.1.   While there is a single identifier, that identifier

Eastlke, Reagle, Solo					[Page 13]

Internet Draft		XML-Signature Syntax	February 2000


   may specify a format containing multiple distinct signature values.
Schema Definition:

<element name='SignatureMethod'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='uri' minOccurs='1' maxOccurs='1'/>
</type>
</element>
DTD:

<!ELEMENT SignatureMethod ANY >
<!ATTLIST SignatureMethod
          Algorithm CDATA #REQUIRED >

    4.3.3 The Reference Element
    
   Reference is an element that may occur one or more times. It specifies
   a digest algorithm and digest value, and optionally the object being
   signed, the type of the object, and/or a list of transforms to be
   applied prior to digesting. The identification, and transforms are
   information provided to inform the verifier how the digested content
   (i.e., the input to the digest method) may be created. The type
   attribute facilitates the processing of referenced data. For example,
   while this specification makes no requirements over external data, an
   application may wish to signal that the referent is a Manifest. An
   optional ID attribute permits a Reference to be referenced from
   elsewhere.
Schema Definition:

<element name='Reference'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
          <element ref='ds:Transforms' minOccurs='0' maxOccurs='1'/>
          <element ref='ds:DigestMethod' minOccurs='1' maxOccurs='1'/>
          <element ref='ds:DigestValue' minOccurs='1' maxOccurs='1'/>
    </group>
        <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
        <attribute name='URI' type='uri' minOccurs='0' maxOccurs='1'/>
        <attribute name='IDREF' type='IDREF' minOccurs='0' maxOccurs='1'/>
        <attribute name='Type' type='uri' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Reference (Transforms?, DigestMethod, DigestValue)  >
<!ATTLIST Reference
        Id      ID      #IMPLIED
        URI     CDATA   #IMPLIED
        IDREF   IDREF   #IMPLIED
        Type    CDATA   #IMPLIED>

   The URI/IDREF attribute identifies a data object using a URI [URI] or
   IDREF [XML]. We distinguish between URIs and IDREFs so as to provide

Eastlke, Reagle, Solo					[Page 14]

Internet Draft		XML-Signature Syntax	February 2000


   expositional clarity and ease signature processing. Note there is some
   popular confusion about URIs and fragment identifiers. As specified by
   RFC2396 [URI], URIs can be used in conjunction with a fragment
   identifier by use of a separating pound symbol '#', but the URI proper
   does not include the fragment identifier. (The meaning of the fragment
   is defined by the resource's MIME type). URI/IDREF only permits a
   'clean' URI or IDREF; fragment identification is specified under
   Transforms. This choice permits References to identify a fragment of a
   document that is encoded: the Reference identifies the resource, the
   first Transform could specify decoding, and the second Transform could
   specify the fragment.
   
   Note that a null URI (URI="") is permitted and identifies the document
   the reference is in (the root element).
   
   If the URI/IDREF attribute is omitted all-together, the receiving
   application is expected to know the identity of the object. For
   example, a lightweight data protocol might omit this attribute given
   the identity of the object is part of the application context. This
   attribute may be omitted from at most one Reference in any particular
   SignedInfo, or Manifest.
   
   The digest algorithm is applied to the data octets being secured.
   Typically that is done by locating (possibly using the URI/IDREF if
   provided) the data and transforming it. If the data is an XML
   document, the document is assumed to be unparsed prior to the
   application of Transforms. If there are no Transforms, then the data
   is passed to the digest algorithm unmodified.
   
   The optional Type attribute contains information about the type of
   object being signed. This is represented as a URI. For example:
   
   Type="http://www.w3.org/2000/01/xmldsig#Object"
   Type="http://www.w3.org/2000/01/xmldsig#Manifest"
   Type="http://www.w3.org/2000/01/xmldsig#SignatureProperty"
   
   The Type attribute applies to the item being pointed at, not its
   contents. For example, a reference that identifies an Object element
   containing a SignatureProperties element is still of type #Object. The
   type attribute is advisory. No validation of the type information is
   required by this specification.
   
    4.3.3.1 The Transforms Element
    
   The optional Transforms element contains an ordered list of  Transform
   elements; these describe how the signer obtained the data object that
   was digested. The output of each Transform (octets) serve as input to
   the next Transform. The input to the first Transform is the source
   data. The output from the last Transform is the input for the
   DigestMethod algorithm. When transforms are applied the signer is not
   signing the native (original) document but the resulting (transformed)
   document [section 7.2: Only What is "Seen" Should be Signed].
   

Eastlke, Reagle, Solo					[Page 15]

Internet Draft		XML-Signature Syntax	February 2000


   Each Transform consists of an Algorithm attribute, optional MimeType
   and Charset attributes, and content parameters, if any, appropriate
   for the given algorithm. The Algorithm attribute value specifies the
   name of the algorithm to be performed, and the Transform content
   provides additional data to govern the algorithm's processing of the
   input resource.
   
   The optional MimeType and Charset (IANA registered character set)
   attributes are made available to algorithms which need and are
   otherwise unable to deduce that information about the data they are
   processing.
Schema Definition:

<element name='Transforms' >
  <type content='elementOnly'>
    <element ref='ds:Transform' minOccurs='1' maxOccurs='*'/>
  </type>
</element>

<element name='Transform'>
  <type content='elementOnly'>
    <attribute name='Algorithm' type='string' minOccurs='1' maxOccurs='1'/>
    <attribute name='MimeType' type='string' minOccurs='0' maxOccurs='1'/>
    <attribute name='Charset' type='string' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Transforms (Transform+)>

<!ELEMENT Transform ANY>
<!ATTLIST Transform
          Algorithm    CDATA     #REQUIRED
          MimeType     CDATA    #IMPLIED
          Charset      CDATA    #IMPLIED >

   Examples of transforms include but are not limited to base-64 decoding
   [MIME], canonicalization [XML-c14n], XPath filtering [XPath], and XSLT
   [XSLT]. The generic definition of the Transform element also allows
   application-specific transform algorithms. For example, the transform
   could be a decompression routine given by a Java class appearing as a
   base-64 encoded parameter to a Java Transform algorithm. However,
   applications should refrain from using application-specific transforms
   if they wish their signatures to be verifiable outside of their
   application domain. Section 5-6: Transform Algorithms defines the list
   of standard transformations.
   
    4.3.3.2 The DigestMethod Element
    
   DigestMethod is a required element which identifies the digest
   algorithm to be applied to the signed object. This element uses the
   general structure here for algorithms specified in section 5.1:
   Algorithm Identifiers.

Eastlke, Reagle, Solo					[Page 16]

Internet Draft		XML-Signature Syntax	February 2000


Schema Definition:

<element name='DigestMethod'>
  <type content='elementOnly'>
        <attribute name='Algorithm' type='uri' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT DigestMethod ANY >
<!ATTLIST DigestMethod
        Algorithm               CDATA   #REQUIRED >

    4.3.3.3 The DigestValue Element
    
   DigestValue is an element which contains the encoded value of the
   digest. The digest is always encoded using Base 64 [MIME].
Schema Definition:

<element name='DigestValue' type='ds:encoded'/>
DTD:

<!ELEMENT DigestValue  (#PCDATA)  >
<!-- base64 encoded signature value -->

  4.4 The KeyInfo Element
  
   KeyInfo may contain keys, names, certificates and other public key
   management information (such as in-band key distribution or agreement
   data or data supporting any other method.) This specification defines
   a few simple types but applications may place their own key
   identification and exchange semantics within this element through the
   XML-namespace facility. [XML-namespace]
Schema Definition:

<element name='KeyInfo'>
  <type content='elementOnly'>
    <group order='choice' minOccurs='1' maxOccurs='*'>
        <element name='KeyName' type='string'/>
        <element name='KeyValue' type='string'/>
        <element name='RetrievalMethod' type='uri'/>
        <element ref='ds:X509Data'/>
        <element ref='ds:PGPData'/>
        <element name='MgmtData' type='string' minOccurs='0' maxOccurs='1'/>
        <any/>
    </group>
        <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT KeyInfo ((KeyName | KeyValue | RetrievalMethod |
          X509Data | PGPData  | MgmtData)*)  >

Eastlke, Reagle, Solo					[Page 17]

Internet Draft		XML-Signature Syntax	February 2000


<!ATTLIST KeyInfo
        Id      ID       #IMPLIED>
<!ELEMENT KeyName  (#PCDATA) >
<!ELEMENT KeyValue  (#PCDATA)  >
<!ELEMENT RetrievalMethod  (#PCDATA)  >

   KeyInfo is an optional element which enables the recipient(s) to
   obtain the key(s) needed to validate the signature. If omitted, the
   recipient is expected to be able to identify the key based on
   application context information. Multiple declarations within KeyInfo
   refer to the same key. Applications may define and use any mechanism
   they choose through inclusion of elements from a different namespace.
   
   Compliant versions implementing KeyInfo MUST implement KeyValue, and
   SHOULD implement RetrievalMethod.
     * KeyName contains an identifier for the key which may be useful to
       the recipient. This may be a simple string name, index, encoded
       DN, email address, etc.
     * KeyValue contains the actual key(s) used to validate the
       signature. If the key is sent in protected form, the MgmtData
       element should be used. Specific types must be defined for each
       algorithm type (see algorithms).
     * RetrievalMethod is a URI which may be used to obtain key and/or
       certificate information. The URI should contain the complete
       string for retrieving the key needed for this message (rather than
       a generic URI).
     * X509Data contains an identifier of the key/cert used for
       validation (either an IssuerSerial value, a subject name, or a
       subjectkeyID) and an optional collection of certificates and
       revocation/status information which may be used by the recipient.
       IssuerSerial contains the encoded issuer name (RFC 2253) along
       with the serial number.
     * PGPData data associated with a PGP key.
     * MgmtData contains in-band key distribution or agreement data.
       Examples may include DH key exchange, RSA key encryption etc.
       
Schema Definition

<element name='X509Data'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
      <group order='choice' minOccurs='1' maxOccurs='1'>
          <element ref='ds:X509IssuerSerial'/>
          <element name='X509SKI' type='string'/>
          <element name='X509SubjectName' type='string'/>
        </group>
        <element name='X509Certificate' type='string' minOccurs='0' maxOccurs='
*'/>
        <element name='X509CRL' type='string' minOccurs='0' maxOccurs='*'/>
    </group>
  </type>
</element>


Eastlke, Reagle, Solo					[Page 18]

Internet Draft		XML-Signature Syntax	February 2000


<element name='X509IssuerSerial'>
   <type content='elementOnly'>
      <group order='seq' minOccurs='1' maxOccurs='1'>
         <element name='X509IssuerName' type='string' minOccurs='1' maxOccurs='
1'/>
         <element name='X509SerialNumber' type='string' minOccurs='1' maxOccurs
='1'/>
        </group>
  </type>
</element>
<element name='PGPData'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
         <element name='PGPKeyID' type='string' minOccurs='1' maxOccurs='1'/>
         <element name='PGPKeyPacket' type='string' minOccurs='1' maxOccurs='1'
/>
        </group>
  </type>
</element>
DTD:

<!ELEMENT X509Data ((X509IssuerSerial | X509SKI | X509SubjectName),
          X509Certificate*, X509CRL*)>
<!ELEMENT X509IssuerSerial (X509IssuerName, X509SerialNumber)  >
<!ELEMENT X509IssuerName (#PCDATA)  >
<!ELEMENT X509SubjectName (#PCDATA) >
<!ELEMENT X509SerialNumber  (#PCDATA)  >
<!ELEMENT X509SKI  (#PCDATA)  >
<!ELEMENT X509Certificate  (#PCDATA)  >
<!ELEMENT X509CRL  (#PCDATA)  >

<!ELEMENT PGPData (PGPKeyID, PGPKeyPacket?)  >
<!ELEMENT PGPKeyPacket  (#PCDATA)  >
<!ELEMENT PGPKeyID  (#PCDATA)  >
<!ELEMENT MgmtData (#PCDATA)>

  4.5 The Object Element
  
   Object is an optional element which may occur one or more times. When
   present, this element may contain any data. The Object element may
   include optional MIME type, ID, and encoding attributes.
   
   The MimeType attribute is an optional attribute which describes the
   data within the Object. This is a string with values defined by
   [MIME]. For example, if the Object contains XML, the MimeType would be
   text/xml. This attribute is purely advisory, no validation of the
   MimeType informatin is required by this specification.
   
   The Object's ID is commonly referenced from a Reference in SignedInfo,
   or Manifest. This element is typically used for enveloping signatures
   where the object being signed is to be included in the signature
   document. The digest is calculated over the entire Object element
   including start and end tags.

Eastlke, Reagle, Solo					[Page 19]

Internet Draft		XML-Signature Syntax	February 2000


   
   Note, if the application wishes to exclude the <Object> tags from the
   digest calculation the Reference must identify the actual data object
   (easy for XML documents) or a transform must be used to remove the
   Object tags (likely where the data object is non-XML). Exclusion of
   the object tags may be desired for cases where one wants the signature
   to remain valid if the data object is moved from inside a signature to
   outside the signature (or vice-versa), or where the content of the
   Object is an encoding of an original binary document and it is desired
   to extract and decode so as to sign the original bitwise
   representation.
Schema Definition:

<element name='Object' >
  <type content='mixed'>
     <any namespace='##targetNamespace'/>
        <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
        <attribute name='MimeType' type='string' minOccurs='0' maxOccurs='1'/>
        <attribute name='Encoding' type='uri' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Object (#PCDATA) >
<!ATTLIST Object
        Id      ID      #IMPLIED
        MimeType        CDATA   #IMPLIED
        Encoding        CDATA   #IMPLIED >

5.0 Additional Signature Syntax

   This section describes the optional to implement Manifest and
   SignatureProperties elements and describes the handling of XML
   Processing Instructions and Comments. With respect to the elements
   Manifest and SignatureProperties this section specifies syntax and
   little behavior -- it is left to the application. These elements can
   appear anywhere the parent's content model permits; the Signature
   content model only permits them within Object.
   
  5.1 The Manifest Element
  
   The Manifest element provides a list of References. The difference
   from the list in SignedInfo is that it is application defined which,
   if any, of the digests are actually checked against the objects
   referenced and what to do if the object is inaccessible or the digest
   compare fails. If a Manifest is pointed to from SignedInfo, the digest
   over the Manifest itself will be checked by the core signature
   validation behavior. The digests within such a Manifest are checked at
   application discretion. If a Manifest is referenced from another
   Manifest, even the overall digest of this two level deep Manifest
   might not be checked.
Schema Definition:


Eastlke, Reagle, Solo					[Page 20]

Internet Draft		XML-Signature Syntax	February 2000


<element name='Manifest'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
        <element ref='ds:Reference' minOccurs='1' maxOccurs='*'/>
        <element ref='ds:Object' minOccurs='0' maxOccurs='*'/>
    </group>
  <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT Manifest ((Reference | Object)+)  >
<!ATTLIST Manifest
        Id      ID      #IMPLIED >

  5.2 The SignatureProperties Element
  
   Additional information items concerning the generation of the
   signature(s) can be placed in a SignatureProperty element (i.e.,
   date/time stamp or the serial number of cryptographic hardware used in
   signature generation.)
Schema Definition:

<element name='SignatureProperties'>
  <type content='elementOnly'>
    <element ref='ds:SignatureProperty' minOccurs='1' maxOccurs='*'/>
    <attribute name='Id' type='ID' minOccurs='0' maxOccurs='1'/>
  </type>
</element>

<element name='SignatureProperty'>
  <type content='mixed'>
    <any namespace='##other'/>
    <attribute name='Target' type='IDREF' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:
<!ELEMENT SignatureProperties (SignatureProperty*)  >
<!ATTLIST SignatureProperties
        Id      ID       #IMPLIED  >

<!ELEMENT SignatureProperty (#PCDATA)  >
<!ATTLIST SignatureProperty
        Target  IDREF    #REQUIRED  >

  5.3 Other Useful Types
  
   We define the following URIs for use in identifying XML resources that
   include non-core but signature related semantics.
   
   http://www.w3.org/2000/01/xmldsig#Object
          designates that the referenced resource is a Signature Object
          element type.

Eastlke, Reagle, Solo					[Page 21]

Internet Draft		XML-Signature Syntax	February 2000


          
   http://www.w3.org/2000/01/xmldsig#SignatureProperties
          designates that the referenced resource is a statement about
          the referring signature.
          
   http://www.w3.org/2000/01/xmldsig#Manifest
          designates that the referenced resource is a collection of
          other resources.
          
  5.5 Processing Instructions in Signature Elements
  
   No XML processing instructions (PIs) are used by this specification.
   
   Note that PIs placed inside SignedInfo by an application will be
   signed unless the CanonicalizationMethod algorithm discards them.
   (This is true for any signed XML content.) All of the
   CanonicalizationMethods specified within this specification retain
   PIs. When a PI is part of content that is signed (e.g., within
   SignedInfo or referenced XML documents) any change to the PI will
   obviously result in a signature failure.
   
  5.5 Comments in Signature Elements
  
   XML comments are not used by this specification.
   
   Note that unless CanonicalizationMethod removes comments within
   SignedInfo or any other referenced XML, they will be signed.
   Consequently, a change to the comment will cause a signature failure.
   Similarly, the XML signature over any XML data will be sensitive to
   comment changes unless a comment-ignoring canonicalization/transform
   method, such as the Canonical XML [XML-canonicalization], is
   specified.
   
6.0 Algorithms

   This section identifies algorithms used with the XML digital signature
   standard. Entries contain the identifier to be used in Signature
   elements, a reference to the formal specification, and definitions,
   where applicable, for the representation of keys and the results of
   cryptographic operations.
   
  6.1 Algorithm Identifiers and Implementation Requirements
  
   Algorithms are identified by URIs that appear as an attribute to the
   element that identifies the algorithms' role (DigestMethod, Transform,
   SignatureMethod, or CanonicalizationMethod). All algorithms used
   herein take parameters but in many cases the parameters are implicit.
   For example, a SignatureMethod is implicitly given two parameters: the
   keying info and the output of CanonicalizationMethod (or SignedInfo
   directly if there is no CanonicalizationMethod). Explicit additional
   parameters to an algorithm appear as content elements within the
   algorithm role element. Such parameter elements have a descriptive
   element name, which is frequently algorithm specific, and MUST be in

Eastlke, Reagle, Solo					[Page 22]

Internet Draft		XML-Signature Syntax	February 2000


   the XML Signature namespace or an algorithm specific namespace.
   
   This specification defines a set of algorithms, their URIs, and
   requirements for implementation. Requirements are specified over
   implementation, not over requirements for signature use. Furthermore,
   the mechanism is extensible, alternative algorithms may be used by
   signature applications.
   
   Algorithm Type Algorithm Requirements Algorithm URI
   Digest
     SHA1 REQUIRED http://www.w3.org/2000/01/xmldsig#sha1
   Encoding
     Base64 REQUIRED http://www.w3.org/2000/01/xmldsig#base64
     QuotedPrintable RECOMMENDED http://www.w3.org/2000/01/xmldsig#qp
   MAC
     HMAC-SHA1 REQUIRED http://www.w3.org/2000/01/xmldsig#hmac-sha1
   Signature
     DSAwithSHA1 (DSS) REQUIRED http://www.w3.org/2000/01/xmldsig#dsa
     RSAwithSHA1 RECOMMENDED http://www.w3.org/2000/01/xmldsig#rsa-sha1
   [[DELETE]] ECDSAwithSHA1 OPTIONAL
   http://www.w3.org/2000/01/xmldsig#ecdsa
   Canonicalization
     minimal REQUIRED http://www.w3.org/2000/01/xmldsig#minimal
     XML-Canonicalization RECOMMENDED
   http://www.w3.org/TR/1999/WD-xml-c14n-19991115
   Transform
     XSLT RECOMMENDED http://www.w3.org/TR/1999/REC-xslt-19991116
     XPath RECOMMENDED http://www.w3.org/TR/1999/REC-xpath-19991116
     XPointer RECOMMENDED http://www.w3.org/TR/1999/WD-xptr-19991206
   
   Note that the normative identifier is the complete URIs in the table
   though they are frequently abbreviated in XML syntax as "&dsig;base64"
   or the like.
   
  6.2 Message Digests
  
   Only one digest algorithm is defined herein. However, it is expected
   that one or more additional strong digest algorithms will be developed
   in connection with the US Advanced Encryption Standard effort. Use of
   MD5 [MD5] is NOT RECOMMENDED because recent advances in cryptography
   have cast doubt on its strength.
   
    6.2.1 SHA-1
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig#sha1
          
   The SHA-1 algorithm [SHA-1] takes no explicit parameters. An example
   of an SHA-1 DigestAlg element is:
   
   <DigestMethod Algorithm="&dsig;sha1"/>
   
   A SHA-1 digest is a 160-bit string. The content of the DigestValue

Eastlke, Reagle, Solo					[Page 23]

Internet Draft		XML-Signature Syntax	February 2000


   element shall be the base64 encoding of this bit string viewed as a
   20-octet octet stream. Example, the DigestValue element for the
   message digest:
   
   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
   
   from Appendix A of the SHA-1 standard would be:
   
   <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>
   
  6.3 Message Authentication Codes
  
   MAC algorithms take two implicit parameters, their keying material
   determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no
   CanonicalizationMethod. MACs and signature algorithms are
   syntactically identical but a MAC implies a shared secret key.
   
    6.3.1 HMAC
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig#hmac-sha1
          
   The HMAC algorithm [RFC2104:HMAC] takes the truncation length in bits
   as a parameter. An example of an HMAC SignatureMethod element:
   
   <SignatureMethod Algorithm="&dsig;hmac-sha1">
      <HMACOutputLength>128</HMACOutputLength>
   </SignatureMethod>
   
   The output of the HMAC algorithm is ultimately the output (possibly
   truncated) of the chosen digest algorithm. This value shall be base64
   encoded in the same straightforward fashion as the output of the
   digest algorithms. Example: the SignatureValue element for the
   HMAC-SHA1 digest
   
   9294727A 3638BB1C 13F48EF8 158BFC9D
   
   from the test vectors in [HMAC] would be
   
   <SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>
Schema Definition:

<element name='HMACOutputLength' type='integer' minOccurs='0' maxOccurs='1'/>
DTD:

<!ELEMENT HMACOutputLength (#PCDATA)>

  6.4 Signature Algorithms
  
   Signature algorithms take two implicit parameters, their keying
   material determined from KeyInfo and the byte stream output by
   CanonicalizationMethod or SignedInfo directly if there is no

Eastlke, Reagle, Solo					[Page 24]

Internet Draft		XML-Signature Syntax	February 2000


   CanonicalizationMethod. Signature and MAC algorithms are syntactically
   identical but a signature implies public key cryptography.
   
   Note: the schema and DTD declarations within this section are not yet
   part of section 9: schemas.
   
    6.4.1 DSA
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig#dsa
          
   The DSA algorithm [DSS] takes no explicit parameters. An example of a
   DSA SignatureMethod element is:
   
   <SignatureMethod Algorithm="&dsig;dsa"/>
   
   The output of the DSA algorithm consists of a pair of integers usually
   referred by the pair (r, s). The signature value shall consist of the
   base64 encoding of the concatenation of two octet-streams that
   respectively result from the octet-encoding of the values r and s.
   Integer to octet-stream conversion shall be done according to the
   I2OSP operation defined in the RFC 2437 [RSA] specification with a k
   parameter equal to 20. Example: the SignatureValue element for a DSA
   signature (r, s) with values specified in hexadecimal
   
   r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0
   s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8
   
   from the example in Appendix 5 of the DSS standard would be
   
   <SignatureValue
   >i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==</SignatureVa
   lue>
   
   DSA key values have the following set of fields: P, Q, G and Y are
   mandatory when appearing as a key value, J, seed and pgenCounter are
   optional but SHOULD be present. (The seed and pgenCounter fields MUST
   both either appear or be absent). All parameters are encoded as base64
   values.
Schema:

<element name='DSAKeyValue'>
  <type content='elementOnly'>
    <group order='seq' minOccurs='1' maxOccurs='1'>
      <element name='ds:P' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='ds:Q' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='ds:G' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='ds:Y' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='ds:J' type='string' minOccurs='0' maxOccurs='1'/>
    </group>
    <group order='seq' minOccurs='0' maxOccurs='1'>
      <element name='ds:Seed' type='string' minOccurs='1' maxOccurs='1'/>
      <element name='ds:PgenCounterQ' type='string'   minOccurs='1' maxOccurs='

Eastlke, Reagle, Solo					[Page 25]

Internet Draft		XML-Signature Syntax	February 2000


1'/>
    </group>
  </type>
</element>
DTD:

<!ELEMENT DSAKeyValue (P, Q, G, Y, J?, (Seed, PgenCounter)?) >
<!ELEMENT P (#PCDATA) >
<!ELEMENT Q (#PCDATA) >
<!ELEMENT G (#PCDATA) >
<!ELEMENT Y (#PCDATA) >
<!ELEMENT J (#PCDATA) >
<!ELEMENT Seed (#PCDATA) >
<!ELEMENT PgenCounter (#PCDATA) >
<!-- Each of these fields consists a PCDATA
     where the data is base64 encoded -->

    6.4.2 RSA
    
   Identifier:
          http://www.w3.org/2000/01/xmldsig#rsa-sha1
          
   The expression "RSA algorithm" as used in this specification refers to
   the RSASSA-PKCS1-v1_5 algorithm described in  RFC 2437 [RSA]. The RSA
   algorithm takes no parameters. An example of an RSA SignatureMethod
   element is:
   
   <SignatureMethod Algorithm="&dsig;rsa-sha1"/>
   
   The output of the RSA algorithm is an octet string. The SignatureValue
   content for an RSA signature shall be the base64 encoding of this
   octet string. Example: TBD
   
   RSA key values have two fields: Modulus and Exponent.
Schema:

<element name='RSAKeyValue'>
  <type content='elementOnly'>
    <element name='ds:Modulus' type='string' minOccurs='1' maxOccurs='1'/>
    <element name='ds:Exponent' type='string' minOccurs='1' maxOccurs='1'/>
  </type>
</element>
DTD:

<!ELEMENT RSAKeyValue (Modulus, Exponent) >
<!ELEMENT Modulus (#PCDATA) >
<!ELEMENT Exponent (#PCDATA) >
<!-- Each field contains a CDATA which is the
     value for that item base64 encoded -->

  6.5 Canonicalization Algorithms
  
    6.5.1 Minimal Canonicalization

Eastlke, Reagle, Solo					[Page 26]

Internet Draft		XML-Signature Syntax	February 2000


    
   Identifier:
          http://www.w3.org/2000/01/xmldsig#minimal
          
   The algorithm identifier for the minimal canonicalization is
   &dsig;minimal. An example of a minimal canonicalization element is:
   
   <CanonicalizationMethod Algorithm="&dsig;minimal"/>
   
   The minimal canonicalization algorithm:
     * converts the character encoding to UTF-8, removing the encoding
       pseudo-attribute
     * normalizes line endings as provided by [XML]. (See section 7: XML
       and Canonicalization and Syntactical Considerations.)
       
    6.5.1 Canonical XML
    
   Identifier:
          http://www.w3.org/TR/1999/WD-xml-c14n-19991115
          
   An example of an XML canonicalization element is:
   
   <CanonicalizationMethod
   Algorithm="http://www.w3.org/TR/1999/WD-xml-c14n-19991115"/>
   
   The normative specification of Canonical XML is [XML-c14n].
   
  6.6 Transform Algorithms
  
   A Transform algorithm has three implicit parameters. The first is a
   byte stream from the Reference or as the output of an earlier
   Transform. The second and third are the optional MimeType and Charset
   attributes that can be specified on the Transform element.
   
   Application developers are strongly encouraged to support all
   transforms listed in this section as RECOMMENDED unless the
   application environment has resource constraints that would make such
   support impractical. The Working Group goal is to maximize application
   interoperability on XML signatures, and the working group expects
   ubiquitous availability of software to support these transforms that
   can be incorporated into applications without extensive development.
   
    6.6.1 Canonicalization
    
   Any canonicalization algorithm that can be used for
   CanonicalizationMethod can be used as a Transform.
   
    6.6.2 Base-64 and Quoted-Printable Decoding
    
   Identifiers:
          http://www.w3.org/2000/01/xmldsig#base-64
          http://www.w3.org/2000/01/xmldsig#qp
          

Eastlke, Reagle, Solo					[Page 27]

Internet Draft		XML-Signature Syntax	February 2000


   The normative specification for base 64 and quoted-printable decoding
   transforms is [MIME]. The base-64 Transform element has no content.
   The input is base-64 decoded by this algorithm. This transform is
   useful if an application needs to sign the raw data associated with
   base-64 encoded content of an element.
   
    6.6.3 XPath Filtering
    
   Identifier:
          http://www.w3.org/TR/1999/REC-xpath-19991116
          
   The Transform element content MUST conform to the XML Path Language
   [XPath] syntax. XPath is a language for addressing parts of an XML
   document. Hence, an XPath expression MUST be applied to an entire
   well-formed XML document.
   
   Note: The current output of a Reference's IDREF cannot be used as
   input to an XPath transform. The XPath transform could be defined to
   provide an XML declaration when one is found not to exist since the
   encoding attribute could be set equal to the XPath transform's Charset
   attribute. However, there is currently no way to communicate the
   correct byte order mark to the transform. For security reasons, a
   default cannot be selected.
   
   The XPath transform applies the W3C XML canonicalization [XML-C14N] to
   the input resource. This ensures all entity reference substitutions
   and attribute normalizations are performed in a manner consistent with
   a validating XML processor. Linefeeds are normalized, and CDATA
   sections are eliminated. The types of quotes around attributes are
   normalized, and the order of attributes is defined. Namespace
   attributes are created in descendant elements that use namespace
   definitions. All of these modifications are necessary to achieve a
   consistent interpretation of the XPath expression and a consistent
   output of the XPath transform.
   
   Finally, the XPath expression is evaluated assuming that the entity
   references created by canonicalization have been replaced by the
   corresponding entity values and that each block of consecutive text
   characters has been replaced by a single text node.
   
   The result of the XPath is a string, boolean, number, or node-set. If
   the result of the XPath expression is a string, then the string is the
   output of the XPath transform. If the XPath result is a boolean or
   number, then the result is converted to a string using the XPath
   string() function. If the result of the XPath expression is a
   node-set, then the output of the transform is a string containing the
   text rendering of the nodes in the node-set. The nodes are selected
   for rendering based on the document order (as defined in [XPath]) of
   the canonicalized input resource. The text rendering is performed in
   accordance with [XML-C14N].
   
   It is RECOMMENDED that the XPath be constructed such that the result
   of this operation is a well-formed XML document. This should be the

Eastlke, Reagle, Solo					[Page 28]

Internet Draft		XML-Signature Syntax	February 2000


   case if root element of the input resource is included by the XPath
   (even if a number of its descendant elements and attributes are
   omitted by the XPath).
   
    6.6.4 XSLT Transform
    
   Identifier:
          http://www.w3.org/TR/1999/REC-xslt-19991116
          
   The Transform element content MUST conform to the XSL Transforms
   [XSLT] language syntax. The processing rules for the XSLT transform
   are stated in the XSLT specification [XSLT].
   
7.0 XML Canonicalization and Syntax Constraint Considerations

   Digital signatures only work if the verification calculations are
   performed on exactly the same bits as the signing calculations. If the
   surface representation of the signed data can change between signing
   and verification, then some way to standardize the changeable aspect
   must be used before signing and verification. For example, even for
   simple ASCII text there are at least three widely used line ending
   sequences. If it is possible for signed text to be modified from one
   line ending convention to another between the time of signing and
   signature verification, then the line endings need to be canonicalized
   to a standard form before signing and verification or the signatures
   will break.
   
   XML is subject to surface representation changes and to processing
   which discards some surface information. For this reason, XML digital
   signatures have a provision for indicating canonicalization methods in
   the signature so that a verifier can use the same canonicalization as
   the signer.
   
   Throughout this specification we distinguish between the
   canonicalization of a Signature data object and other signed XML data
   objects. It is possible for an isolated XML document to be treated as
   if it were binary data so that no changes can occur. In that case, the
   digest of the document will not change and it need not be
   canonicalized if it is signed and verified as such. However, XML that
   is read and processed using standard XML parsing and processing
   techniques is frequently changed such that some of its surface
   representation information is lost or modified. In particular, this
   will occur in many cases for the Signature and enclosed SignedInfo
   elements since they, and possibly an encompassing XML document, will
   be processed as XML.
   
   Similarly, these considerations apply to Manifest, Object, and
   SignatureProperties elements if those elements have been digested,
   their DigestValue is to be checked, and they are being processed as
   XML.
   
   The kinds of changes in XML that may need to be canonicalized can be
   divided into three categories. There are those related to the basic

Eastlke, Reagle, Solo					[Page 29]

Internet Draft		XML-Signature Syntax	February 2000


   [XML], as described in 7.1 below. There are those related to [DOM],
   [SAX], or similar processing as described in 7.2 below. And, third,
   there is the possibility of character set conversion, such as between
   UTF-8 and UTF-16, both of which all XML standards compliant processors
   are required to support. Any canonicalization algorithm should yield
   output in a specific fixed character set. For both the minimal
   canonicalization defined in this specification and the W3C Canonical
   XML [XML-c14n], that character set is UTF-8.
   
  7.1 XML 1.0, Syntax Constraints, and Canonicalization
  
   XML 1.0 [XML] defines an interface where a conformant application
   reading XML is given certain information from that XML and not other
   information. In particular,
    1. line endings are normalized to the single character #xA by
       dropping #xD characters if they are immediately followed by a #xA
       and replacing them with #xA in all other cases,
    2. missing attributes declared to have default values are provided to
       the application as if present with the default value,
    3. character references are replaced with the corresponding
       character,
    4. entity references are replaced with the corresponding declared
       entity,
    5. attribute values are normalized by
         A. replacing character and entity references as above,
         B. replacing occurrences of #x9, #xA, and #xD with #x20 (space)
            except that the sequence #xD#xA is replaced by a single
            space, and
         C. if the attribute is not declared to be CDATA, stripping all
            leading and trailing spaces and replacing all interior runs
            of spaces with a single space, and
    6. for elements declared to have element content, eliminate white
       space that appears within their content but not within the content
       of any enclosed element.
       
   Note that items (2), (4), (5C), and (6) depend on specific Schema,
   DTD, or similar declarations. In the general case, such declarations
   will not be available to or used by the signature verifier. Thus, to
   interoperate between different XML implementations, the following
   syntax contraints MUST be observed when generating any signed material
   to be processed as XML, including the SignedInfo element:
    1. attributes having default values be explicitly present,
    2. all entity references (except "amp", "lt", "gt", "apos", and
       "quot" which are pre-defined) be expanded,
    3. attribute value white space be normalized, and
    4. insignificant white space not be generated within elements having
       element content.
       
  7.2 DOM/SAX Processing and Canonicalization
  
   In addition to the canonicalization and syntax constraints discussed
   above, many XML applications use the Document Object Model [DOM] or
   The Simple API for XML  [SAX]. DOM maps XML into a tree structure of

Eastlke, Reagle, Solo					[Page 30]

Internet Draft		XML-Signature Syntax	February 2000


   nodes and typically assumes it will be used on an entire document with
   subsequent processing being done on this tree. SAX converts XML into a
   series of events such as a start tag, content, etc. In either case,
   many surface characteristics such as the ordering of attributes and
   insignificant white space within start/end tags is lost. In addition,
   namespace declarations are mapped over the nodes to which they apply,
   losing the namespace prefixes in the source text and, in most cases,
   losing the where namespace declarations appeared in the original
   instance.
   
   If an XML Signature is to be produced or verified on a system using
   the DOM or SAX processing, a canonical method is needed to serialize
   the relevant part of a DOM tree or sequence of SAX events. XML
   canonicalization specifications, such as [XML-c14n], are based only on
   information which is preserved by DOM and SAX. For an XML Signature to
   be verifiable by an implementation using DOM or SAX, not only must the
   syntax constraints given in section 7.1 be followed but an appropriate
   XML canonicalization MUST be specified so that the verifier can
   re-serialize DOM/SAX mediated input into the same byte sequence that
   was signed.
   
8.0 Security Considerations

   The XML Signature specification provides a very flexible digital
   signature mechanism. Implementors must give consideration to their
   application threat models and to the following factors.
   
  8.1 Only What is Signed is Secure
  
   A requirement of this specification is to permit signatures to "apply
   to a part or totality of a XML document." [3.1.3 XML-Signature-RD] The
   Transforms mechanism meets this requirement by permitting one to sign
   data derived from processing the content of the identified resource.
   For instance, applications that wish to sign a form, but permit users
   to enter limited field data without invalidating the form itself might
   use XPath [XPath] to exclude those portions the user needs to change.
   Transforms may be arbitrarily specified and may include
   canonicalization instructions or even XSLT transformations. Of course,
   signatures over such a dervied document do not secure any information
   discarded by the Transforms.
   
   Furthermore, core validation behavior does not confirm that the signed
   data was obtained by applying each step of the indicated transforms.
   (Though it does check that the digest of the resulting content matches
   that specified in the signature.)  For example, some application may
   be satisfied with verifying an XML signature over a cached copy of
   already transformed data. Other application might require that content
   be freshly dereferenced and transformed.
   
  8.2 Only What is "Seen" Should be Signed
  
   If signing is intended to convey the judgment or consent of an
   automated mechanism or person concerning some information, then it is

Eastlke, Reagle, Solo					[Page 31]

Internet Draft		XML-Signature Syntax	February 2000


   normally necessary to secure as exactly as practical the information
   that was presented to that mechanism or person. Note that this can be
   accomplished by literally signing what was presented, for example the
   screen images shown a user. However, this may result in data which it
   is difficult for subsequent software to manipulate. It can be
   effective instead to secure the full data along with whatever filters,
   style sheets, or the like were used to control the part of the
   information that was presented.
   
   Also note that the use of Canonical  XML [XML-C14N] ensures that all
   internal entities and XML namespaces are expanded within the content
   being signed. All entities are replaced with their definitions and the
   canonical form explitly represents the namespace that an element would
   otherwise inhereit. Those application that do not canonicalize XML
   content (especially the  SignedInfo element) SHOULD NOT use internal
   entities and SHOULD represent the name space explicitly within the
   content being signed since they can not rely upon canonicalization to
   do this for them.
   
  8.3 Check the Security Model
  
   This standard specifies public key signatures and keyed hash
   authentication codes. These have substantially different security
   models. Furthermore, it permits user specified additions which may
   have other models.
   
   With public key signatures, any number of parties can hold the public
   key and verify signatures while only the parties with the private key
   can create signatures. The number of holders of the private key should
   be minimized and preferably be one. Confidence by verifiers in the
   public key they are using and its binding to the entity or
   capabilities represented by the corresponding private key is an
   important issue, usually addressed by certificate or online authority
   systems.
   
   Keyed hash authentication codes, based on secret keys, are typically
   much more efficient in terms of the computational effort required but
   have the characteristic that all verifiers need to have possession of
   the same key as the signer. Thus any verifier can forge signatures.
   
   This standard permits user provided signature algorithms and keying
   information designators. Such user provided algorithms may have
   further different security models. For example, methods involving
   biometrics usually depend on a physical characteristic of the
   authorized user that can not be changed the way public or secret keys
   can be and may have other security model differences.
   
  8.4 Key Lengths, Algorithms, Certificates, Etc.
  
   The strength of a particular signature depends on all links in the
   security chain. This includes the signature and digest algorithms
   used, the strength of the key generation [RANDOM] and the size of the
   key, the security of key and certificate authentication and

Eastlke, Reagle, Solo					[Page 32]

Internet Draft		XML-Signature Syntax	February 2000


   distribution mechanisms, certificate chain valiation policy,
   protection of cryptographic processing from hostile observation and
   tampering, etc. The security of an overall system would also depend on
   the security and integrity of its operating procedures, its personnel,
   and on the administrative enforcement of those procedures. The factors
   listed in this paragraph, while critical to the overall security of a
   system, are mostly beyond the scope of this specification.
   
9.0 Schema, DTD, and Data Model

   XML Signature Schema Instance
          xmldsig-core-schema.xsd
          XML schema instance validates to 19991207 Schema DTD
          [XML-Schema].
          
   XML Signature DTD
          xmldsig-core-schema.dtd
          XML DTD that could still use improvement.
          
   RDF Data Model
          xmldsig-datamodel-20000112.gif
          
10.0 Example syntax

   XML Signature Example
          signature-example.xml
          Well formed XML that validates under the schema and DTD. The
          non-normative cryptographic values were generated by Ed Simon
          and Tamura Kent. The text below was edited for readability.
          
<Signature xmlns="http://www.w3.org/2000/01/xmldsig">
  <SignedInfo Id="mypage">
    <CanonicalizationMethod
     Algorithm="http://www.w3.org/1999/07/WD-xml-c14n-19990729">
    </CanonicalizationMethod>
    <SignatureMethod Algorithm="http://www.w3.org/2000/01/xmldsig/dsa">
    </SignatureMethod>
    <Reference URI="http://www.w3.org/TR/xml-stylesheet/">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/01/xmldsig/base64"/>
        <Transform Algorithm="http://www.w3.org/2000/01/xmldsig/null"/>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/01/xmldsig/sha1">
      </DigestMethod>
      <DigestValue>j6lwx3rvEPO0vKtMup4NbeVu8nk=</DigestValue>
    </Reference>
    <Reference URI="http://www.w3.org/TR/REC-xml-names/">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/01/xmldsig/base64"/>
     </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/01/xmldsig/sha1">
      </DigestMethod>
    <DigestValue>UrXLDLBIta6skoV5/A8Q38GEw44=</DigestValue>

Eastlke, Reagle, Solo					[Page 33]

Internet Draft		XML-Signature Syntax	February 2000


    </Reference>
  </SignedInfo>
  <SignatureValue>MC0CFFrVLtRlkMc3Daon4BqqnkhCOlEaAhUAk8pH1iRNK+q1I
    +sisDTz2TFEALE=</SignatureValue>
  <KeyInfo>
    <KeyValue xmlns:java="http://xsl.lotus.com/java"
     xmlns:dsig="http://www.w3.org/2000/01/xmldsig">
     MIIBtzCCASwGByqGSM44BAEwggEfAoGBAP1/U4EddRIpUt9KnC7s5Of2E
     bdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/xfW6MPbLm1Vs14E7gB00b/
     JmYLdrmVClpJ+f6AR7ECLCT7up1/63xhv4O1fnxqimFQ8E+4P208UewwI1
     VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC/
     BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeO
     utRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpn
     WRbqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFM
     O/7PSSoDgYQAAoGAQFL0+RhXZbDxdt17o05PlMzQGqDnAq2NM1eun+ie21
     4okrmIp4r0CGKvHM1HbFgwXMlBpkXyStYg64RTMnL9dtShw5rCkEv145TV
     0EYVoxBQ5X0gmrQ2NftRHH8imBhx9glz//y6NE4JhfIVPu3o+55VYUwdFP
     0cbBvWkKOngo0=
    </KeyValue>
  </KeyInfo>
</Signature>

11.0 Definitions

   Authentication, Message
          "A signature should identify what is signed, making it
          impracticable to falsify or alter either the signed matter or
          the signature without detection." [Digital Signature
          Guidelines, ABA]
          
   Authentication, Signer
          "A signature should indicate who signed a document, message or
          record, and should be difficult for another person to produce
          without authorization." [Digital Signature Guidelines, ABA] See
          non-repudiation.
          
   Core
          The syntax and processing defined by this specification,
          including core validation. We use this term to distinguish
          other markup, processing, and applications semantics from our
          own.
          
   Data Object (Content/Document)
          The actual binary/octet data being operated on (transformed,
          digested, or signed) by an application -- frequently an HTTP
          entity [HTTP]. Note that the proper noun Object designates a
          specific XML element. Occasionally we refer to a data object as
          a document or as a resource's content. The term element content
          is used to describe the data between XML start and end tags
          [XML]. The term XML document is used to describe data objects
          which conform to the XML specification [XML].
          
   Integrity

Eastlke, Reagle, Solo					[Page 34]

Internet Draft		XML-Signature Syntax	February 2000


          The inability to change a message without also changing the
          signature value. See message authentication.
          
   Non-repudiation
          The inability of a key holder to assert that their key was not
          associated with a message given a strong signature algorithm.
          (This definition speaks nothing of the number of key holders,
          the key length, whether the key is comprised, whether the
          signature was coerced, etc.) See signer authentication.
          
   Object
          An XML Signature element wherein arbitrary (non-core) data may
          be placed. An Object element is merely one type of digital data
          (or document) that can be signed via a Reference.
          
   Resource
          "A resource can be anything that has identity. Familiar
          examples include an electronic document, an image, a service
          (e.g., 'today's weather report for Los Angeles'), and a
          collection of other resources.... The resource is the
          conceptual mapping to an entity or set of entities, not
          necessarily the entity which corresponds to that mapping at any
          particular instance in time. Thus, a resource can remain
          constant even when its content---the entities to which it
          currently corresponds---changes over time, provided that the
          conceptual mapping is not changed in the process." [URI] In
          order to avoid a collision of the term entity within the URI
          and XML specifications, we use the term data object, content or
          document to refer to the actual bits being operated upon.
          
   Signature
          A value generated from the application of a key to a message
          via a cryptographic algorithm such that it has the properties
          of signer authentication, integrity, and non-repudiation. A
          signature may be (non-exclusively) described as detached,
          enveloping, or enveloped.
          
   Signature, Detached
          The signature is over content external to the Signature
          element, and can be identified via a URI, IDREF, or transform.
          Consequently, the signature is "detached" from the content it
          signs. This definition typically applies to separate data
          objects, but it also includes the instance where the Signature
          and data object reside within the same XML document but are
          sibling elements.
          
   Signature, Enveloping
          The signature is over content found within the Object element
          of the signature itself. The Object(or its content) is
          identified via a Reference (via IDREF or transform). The
          enveloping Signature element is used to provide the root
          document element.
          

Eastlke, Reagle, Solo					[Page 35]

Internet Draft		XML-Signature Syntax	February 2000


   Signature, Enveloped
          The signature is over the XML content that contains the
          signature as an element. The content provides the root XML
          document element. Obviously, enveloped signatures must take
          care not to include their own value in the calculation of the
          SignatureValue.
          
   Transform
          The processing of a byte stream from source content to derived
          content. Typical transforms include XML Canonicalization,
          XPath, and XSLT.
          
   Validation, Core
          The core processing requirements of this specification
          requiring signature validation and SignedInfo reference
          validation.
          
   Validation, Reference
          The hash value of the identified and transformed content,
          specified by Reference, matches its specified DigestValue.
          
   Validation, Signature
          The SignatureValue matches the result of processing SignedInfo
          with  CanonicalizationMethod and SignatureMethod as specified
          in section 6.2.
          
   Validation, Trust/Application
          The application determines that the semantics associated with a
          signature are valid. For example, an application may validate
          the time stamps or the integrity of the signer key -- though
          this behavior is external to this core specification.
          
12.0 References

   ABA
          Digital Signature Guidelines.
          http://www.abanet.org/scitech/ec/isc/dsgfree.html
          
   Bourret
          Ron Bourret. Declaring Elements and Attributes in an XML DTD.
          http://www.informatik.tu-darmstadt.de/DVS1/staff/bourret/xml/xm
          ldtd.html
          
   DOM
          Document Object Model (DOM) Level 1 Specification.
          http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/
          
   DOMHASH
          Internet Draft. Digest Values for DOM (DOMHASH)
          http://search.ietf.org/internet-drafts/draft-hiroshi-dom-hash-0
          1.txt .
          
   DSS

Eastlke, Reagle, Solo					[Page 36]

Internet Draft		XML-Signature Syntax	February 2000


          FIPS PUB 186-1. Digital Signature Standard (DSS). U.S.
          Department of Commerce/National Institute of Standards and
          Technology.
          
   HMAC
          RFC 2104. HMAC: Keyed-Hashing for Message Authentication. H.
          Krawczyk, M. Bellare, R. Canetti. INFORMATIONAL.
          
   HTTP
          RFC 2616.Hypertext Transfer Protocol -- HTTP/1.1. J. Gettys, J.
          Mogul, H. Frystyk, L. Masinter, P. Leach, T. Berners-Lee.
          http://www.ietf.org/rfc/rfc2616.txt
          
   KEYWORDS
          RFC2119 -- Key words for use in RFCs to Indicate Requirement
          Levels.
          http://www.ietf.org/rfc/rfc2119.txt
          
   MD5
          RFC 1321. The MD5 Message-Digest Algorithm. R. Rivest.
          INFORMATIONAL.
          http://www.ietf.org/rfc/rfc1321.txt
          
   MIME
          RFC 2045. Multipurpose Internet Mail Extensions (MIME) Part
          One: Format of Internet Message Bodies. N. Freed & N.
          Borenstein. DRAFT STANDARD.
          http://www.ietf.org/rfc/rfc2045.txt
          
   RANDOM
          RFC1750 -- Randomness Recommendations for Security.
          http://www.ietf.org/rfc/rfc1750.txt
          
   RDF
          RDF Schema
          http://www.w3.org/TR/1999/PR-rdf-schema-19990303/
          RDF Model and Syntax
          http://www.w3.org/TR/1999/REC-rdf-syntax-19990222
          
   RSA
          RFC 2437. PKCS #1: RSA Cryptography Specifications Version 2.0.
          B. Kaliski, J. Staddon. INFORMATIONAL.
          http://www.ietf.org/rfc/rfc2432.txt
          
   SAX
          David Megginson et. al. SAX: The Simple API for XML May 1998.
          http://www.megginson.com/SAX/index.html
          
   SHA-1
          FIPS PUB 180-1. Secure Hash Standard. U.S. Department of
          Commerce/National Institute of Standards and Technology.
          http://csrc.nist.gov/fips/fip180-1.pdf
          

Eastlke, Reagle, Solo					[Page 37]

Internet Draft		XML-Signature Syntax	February 2000


   URI
          RFC2396 - Uniform Resource Identifiers (URI): Generic Syntax
          http://www.ietf.org/rfc/rfc2396.txt
          
   URL
          RFC1738. Uniform Resource Locators (URL). Berners-Lee, T.,
          Masinter, L., and M. McCahill . December 1994.
          http://www.ietf.org/rfc/rfc1738.txt
          
   URN
          RFC 2141. URN Syntax. R. Moats. PROPOSED STANDARD.
          ftp://ftp.isi.edu/in-notes/rfc2141.txt
          RFC 2611. URN Namespace Definition Mechanisms. L. Daigle, D.
          van Gulik, R. Iannella, P. Falstrom. BEST CURRENT PRACTICE.
          ftp://ftp.isi.edu/in-notes/rfc2611.txt
          
   XLink
          XML Linking Language
          http://www.w3.org/1999/07/WD-xlink-19990726
          
   XML
          Extensible Markup Language (XML) Recommendation.
          http://www.w3.org/TR/1998/REC-xml-19980210
          
   XML-c14n
          Canonical XML. W3C Working Draft
          http://www.w3.org/TR/1999/WD-xml-c14n-19991115
          
   XML-ns
          Namespaces in XML
          http://www.w3.org/TR/1999/REC-xml-names-19990114
          
   XPath
          XML Path Language (XPath)Version 1.0. W3C Proposed
          Recommendation
          http://www.w3.org/TR/1999/PR-xpath-19991008
          
   XPointer
          XML Pointer Language (XPointer). W3C Working Draft.
          http://www.w3.org/1999/07/WD-xptr-19990709
          
   XML-schema
          XML Schema Part 1: Structures
          http://www.w3.org/TR/1999/WD-xmlschema-1-19991217/
          XML Schema Part 2: Datatypes
          http://www.w3.org/TR/1999/WD-xmlschema-2-19991217/
          
   XML-Signature-RD
          XML-Signature Requirements
          http://www.w3.org/1999/08/WD-xmldsig-requirements-990820
          
   XSL
          Extensible Stylesheet Language (XSL) W3C Working Draft

Eastlke, Reagle, Solo					[Page 38]

Internet Draft		XML-Signature Syntax	February 2000


          http://www.w3.org/TR/2000/WD-xsl-20000112/
          
   XSLT
          XSL Transforms (XSLT) Version 1.0. W3C Proposed Recommendation
          http://www.w3.org/TR/1999/PR-xslt-19991008
          
   WebData
          Web Architecture: Describing and Exchanging Data.
          http://www.w3.org/1999/04/WebData
          
12. Author's Address

   [other authors -  TBD]
   
   Donald E. Eastlake 3rd
   Motorola
   65 Shindegan Hill Road
   Carmel, NY 10512 USA
   Phone: 1-508-261-5434
   Email: dee3@torque.pothole.com
   
   Joseph M. Reagle Jr., W3C
   Massachusetts Institute of Technology
   Laboratory for Computer Science
   NE43-350, 545 Technology Square
   Cambridge, MA 02139
   Phone: 1.617.258.7621
   Email: reagle@w3.org
   
   David Solo
   Citigroup
   666 Fifth Ave, 3rd Floor
   NY, NY 10103 USA
   Phone: +1-212-830-8118
   Email: dsolo@alum.mit.edu


















Eastlke, Reagle, Solo					[Page 39]

