





INTERNET-DRAFT                                               E. Nordmark
February 24, 2003                                  Sun Microsystems, Inc.
Obsoletes: 2893                                           R. E. Gilligan
                                                          Intransa, Inc.

         Basic Transition Mechanisms for IPv6 Hosts and Routers
                   <draft-ietf-v6ops-mech-v2-00.txt>


Status of this Memo

   This document is an Internet-Draft and is subject to all provisions
   of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This draft expires on August 24, 2003.

Abstract

   This document specifies IPv4 compatibility mechanisms that can be
   implemented by IPv6 hosts and routers.  These mechanisms include
   providing complete implementations of both versions of the Internet
   Protocol (IPv4 and IPv6), and tunneling IPv6 packets over IPv4
   routing infrastructures.  They are designed to allow IPv6 nodes to
   maintain complete compatibility with IPv4, which should greatly
   simplify the deployment of IPv6 in the Internet, and facilitate the
   eventual transition of the entire Internet to IPv6.

   This document obsoletes RFC 2893.







<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 1]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   Contents

      Status of this Memo..........................................    1

      1.  Introduction.............................................    3
         1.1.  Terminology.........................................    3
         1.2.  Structure of this Document..........................    5

      2.  Dual IP Layer Operation..................................    5
         2.1.  Address Configuration...............................    6
         2.2.  DNS.................................................    6
         2.3.  Advertising Addresses in the DNS....................    7

      3.  Common Tunneling Mechanisms..............................    8
         3.1.  Encapsulation.......................................   10
         3.2.  Tunnel MTU and Fragmentation........................   11
         3.3.  Hop Limit...........................................   13
         3.4.  Handling IPv4 ICMP errors...........................   13
         3.5.  IPv4 Header Construction............................   14
         3.6.  Decapsulation.......................................   16
         3.7.  Link-Local Addresses................................   18
         3.8.  Neighbor Discovery over Tunnels.....................   18
         3.9.  Ingress Filtering...................................   19

      4.  Configured Tunneling.....................................   20
         4.1.  Ingress Filtering...................................   20

      5.  Acknowledgments..........................................   21

      6.  Security Considerations..................................   21

      7.  Authors' Addresses.......................................   21

      8.  References...............................................   22
         8.1.  Normative References................................   22
         8.2.  Non-normative References............................   22

      9.  Changes from RFC 2893....................................   24













<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 2]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


1.  Introduction

   The key to a successful IPv6 transition is compatibility with the
   large installed base of IPv4 hosts and routers.  Maintaining
   compatibility with IPv4 while deploying IPv6 will streamline the task
   of transitioning the Internet to IPv6.  This specification defines a
   set of mechanisms that IPv6 hosts and routers may implement in order
   to be compatible with IPv4 hosts and routers.

   The mechanisms in this document are designed to be employed by IPv6
   hosts and routers that need to interoperate with IPv4 hosts and
   utilize IPv4 routing infrastructures.  We expect that most nodes in
   the Internet will need such compatibility for a long time to come,
   and perhaps even indefinitely.

   The mechanisms specified here include:

   -    Dual IP layer (also known as Dual Stack):  A technique for
        providing complete support for both Internet protocols -- IPv4
        and IPv6 -- in hosts and routers.

   -    Configured tunneling of IPv6 over IPv4:  Point-to-point tunnels
        made by encapsulating IPv6 packets within IPv4 headers to carry
        them over IPv4 routing infrastructures.

   The mechanisms defined here are intended to be the core of a
   "transition toolbox" -- a growing collection of techniques which
   implementations and users may employ to ease the transition.  The
   tools may be used as needed.  Implementations and sites decide which
   techniques are appropriate to their specific needs.

   This document defines the basic set of transition mechanisms, but
   these are not the only tools available.  Additional transition and
   compatibility mechanisms are specified in other documents.



1.1.  Terminology

   The following terms are used in this document:

   Types of Nodes

        IPv4-only node:

                A host or router that implements only IPv4.  An IPv4-
                only node does not understand IPv6.  The installed base
                of IPv4 hosts and routers existing before the transition



<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 3]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


                begins are IPv4-only nodes.

        IPv6/IPv4 node:

                A host or router that implements both IPv4 and IPv6.

        IPv6-only node:

                A host or router that implements IPv6, and does not
                implement IPv4.  The operation of IPv6-only nodes is not
                addressed here.

        IPv6 node:

                Any host or router that implements IPv6.  IPv6/IPv4 and
                IPv6-only nodes are both IPv6 nodes.

        IPv4 node:

                Any host or router that implements IPv4.  IPv6/IPv4 and
                IPv4-only nodes are both IPv4 nodes.

   Types of IPv6 Addresses

        IPv4-compatible IPv6 address:

                An IPv6 address bearing the high-order 96-bit prefix
                0:0:0:0:0:0, and an IPv4 address in the low-order 32-
                bits.  IPv4-compatible addresses are no longer used by
                this specification, thus this definition is preserved in
                the specification merely to clarify their non-use.



   Techniques Used in the Transition

        IPv6-over-IPv4 tunneling:

                The technique of encapsulating IPv6 packets within IPv4
                so that they can be carried across IPv4 routing
                infrastructures.

        Configured tunneling:

                IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint
                address is determined by configuration information on
                the encapsulating node.  The tunnels can be either
                unidirectional or bidirectional.  Bidirectional



<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 4]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


                configured tunnels behave as virtual point-to-point
                links.

   Other transition mechanisms, including other tunneling mechanisms,
   are outside the scope of this document.

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [RFC2119].



1.2.  Structure of this Document

   The remainder of this document is organized as follows:

   -    Section 2 discusses the operation of nodes with a dual IP layer,
        IPv6/IPv4 nodes.

   -    Section 3 discusses the common mechanisms used in some IPv6-
        over-IPv4 tunneling techniques, including configured tunneling.

   -    Section 4 discusses configured tunneling.




2.  Dual IP Layer Operation

   The most straightforward way for IPv6 nodes to remain compatible with
   IPv4-only nodes is by providing a complete IPv4 implementation.  IPv6
   nodes that provide a complete IPv4 and IPv6 implementations are
   called "IPv6/IPv4 nodes."  IPv6/IPv4 nodes have the ability to send
   and receive both IPv4 and IPv6 packets.  They can directly
   interoperate with IPv4 nodes using IPv4 packets, and also directly
   interoperate with IPv6 nodes using IPv6 packets.

   Even though a node may be equipped to support both protocols, one or
   the other stack may be disabled for operational reasons.  Here we use
   a rather loose notion of "stack".  A stack being enabled has IP
   addresses assigned etc, but whether or not any particular application
   is available on the stacks is explicitly not defined.  Thus IPv6/IPv4
   nodes may be operated in one of three modes:

   -    With their IPv4 stack enabled and their IPv6 stack disabled.

   -    With their IPv6 stack enabled and their IPv4 stack disabled.




<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 5]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    With both stacks enabled.

   IPv6/IPv4 nodes with their IPv6 stack disabled will operate like
   IPv4-only nodes.  Similarly, IPv6/IPv4 nodes with their IPv4 stacks
   disabled will operate like IPv6-only nodes.  IPv6/IPv4 nodes MAY
   provide a configuration switch to disable either their IPv4 or IPv6
   stack.

   The IPv6-over-IPv4 tunneling techniques, which are described in
   sections 3 and 4, may or may not be used in addition to the dual IP
   layer operation.  An IPv6/IPv4 node MAY support configured tunneling.



2.1.  Address Configuration

   Because they support both protocols, IPv6/IPv4 nodes may be
   configured with both IPv4 and IPv6 addresses.  IPv6/IPv4 nodes use
   IPv4 mechanisms (e.g., DHCP) to acquire their IPv4 addresses, and
   IPv6 protocol mechanisms (e.g., stateless address autoconfiguration
   and/or DHCPv6) to acquire their IPv6 addresses.



2.2.  DNS

   The Domain Naming System (DNS) is used in both IPv4 and IPv6 to map
   between hostnames and IP addresses.  A new resource record type named
   "AAAA" has been defined for IPv6 addresses [RFC1886].  Since
   IPv6/IPv4 nodes must be able to interoperate directly with both IPv4
   and IPv6 nodes, they must provide resolver libraries capable of
   dealing with IPv4 "A" records as well as IPv6 "AAAA" records.  Note
   that the lookup of A versus AAAA records is independent of whether
   the DNS packets are carried in IPv4 or IPv6 packets.

   DNS resolver libraries on IPv6/IPv4 nodes MUST be capable of handling
   both AAAA and A records.  However, when a query locates an AAAA
   record holding an IPv6 address, and an A record holding an IPv4
   address, the resolver library MAY filter or order the results
   returned to the application in order to influence the version of IP
   packets used to communicate with that node.  In terms of filtering,
   the resolver library has three alternatives:

   -    Return only the IPv6 address(es) to the application.

   -    Return only the IPv4 address(es) to the application.

   -    Return both types of addresses to the application.



<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 6]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   If it returns only the IPv6 address(es), the application will
   communicate with the node using IPv6.  If it returns only the IPv4
   address(es), the application will communicate with the node using
   IPv4.  If it returns both types of addresses, the application will
   have the choice which address to use, and thus which IP protocol to
   employ.

   If it returns both, the resolver MAY elect to order the addresses --
   IPv6 first, or IPv4 first.  Since most applications try the addresses
   in the order they are returned by the resolver, this can affect the
   IP version "preference" of applications.

   The decision to filter or order DNS results is implementation
   specific.  IPv6/IPv4 nodes MAY provide policy configuration to
   control filtering or ordering of addresses returned by the resolver,
   or leave the decision entirely up to the application.

   An implementation MUST allow the application to control whether or
   not such filtering takes place.

   More details on this subject are specified in [RFC3484].



2.3.  Advertising Addresses in the DNS

   There are some constraint placed on the use of the DNS during
   transition.  The constraints allow nodes to prefer either IPv6 or
   IPv4 addresses when both types of addresses are returned by the DNS.
   Most of these are obvious but are stated here for completeness.

   The recommendation is that AAAA records for a node should not be
   added to the DNS until all of these are true:

     1) The address is assigned to the interface on the node.

     2) The address is configured on the interface.

     3) The interface is on a link which is connected to the IPv6
        infrastructure.

   If an IPv6 node is isolated from an IPv6 perspective (e.g., it is not
   connected to the 6bone to take a concrete example) constraint #3
   would mean that it should not have an address in the DNS.

   This works great when other dual stack nodes try to contact the
   isolated dual stack node.  There is no IPv6 address in the DNS thus
   the peer doesn't even try communicating using IPv6 but goes directly



<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 7]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   to IPv4 (we are assuming both nodes have A records in the DNS.)

   However, this does not work well when the isolated node is trying to
   establish communication.  Even though it does not have an IPv6
   address in the DNS it will find AAAA records in the DNS for the peer.
   Since the isolated node has IPv6 addresses assigned to at least one
   interface it will try to communicate using IPv6.  If it has no IPv6
   route to the 6bone (e.g., because the local router was upgraded to
   advertise IPv6 addresses using Neighbor Discovery but that router
   doesn't have any IPv6 routes) this communication will fail.
   Typically this means a few minutes of delay as TCP times out.  The
   TCP specification [RFC1122] says that ICMP unreachable messages could
   be due to routing transients thus they should not immediately
   terminate the TCP connection.  This means that the normal TCP timeout
   of a few minutes apply.  Once TCP times out the application will
   hopefully try the IPv4 addresses based on the A records in the DNS,
   but this will be painfully slow.

   A possible implication of the recommendations above is that, if one
   enables IPv6 on a node on a link without IPv6 infrastructure, and
   choose to add AAAA records to the DNS for that node, then external
   IPv6 nodes that might see these AAAA records will possibly try to
   reach that node using IPv6 and suffer delays or communication failure
   due to unreachability.  (A delay is incurred if the application
   correctly falls back to using IPv4 if it can not establish
   communication using IPv6 addresses.  If this fallback is not done the
   application would fail to communicate in this case.)  Thus it is
   suggested that either the recommendations be followed, or care be
   taken to only do so with nodes that will not be impacted by external
   accessing delays and/or communication failure.

   In the future, when a node discontinues its use of IPv4, analogous
   constraints apply with respect to the node's A records in the DNS;
   the removal of the A records should be tied to when the node can no
   longer be reached using IPv4.




3.  Common Tunneling Mechanisms

   In most deployment scenarios, the IPv6 routing infrastructure will be
   built up over time.  While the IPv6 infrastructure is being deployed,
   the existing IPv4 routing infrastructure can remain functional, and
   can be used to carry IPv6 traffic.  Tunneling provides a way to
   utilize an existing IPv4 routing infrastructure to carry IPv6
   traffic.




<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 8]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   IPv6/IPv4 hosts and routers can tunnel IPv6 datagrams over regions of
   IPv4 routing topology by encapsulating them within IPv4 packets.
   Tunneling can be used in a variety of ways:

   -    Router-to-Router.  IPv6/IPv4 routers interconnected by an IPv4
        infrastructure can tunnel IPv6 packets between themselves.  In
        this case, the tunnel spans one segment of the end-to-end path
        that the IPv6 packet takes.

   -    Host-to-Router.  IPv6/IPv4 hosts can tunnel IPv6 packets to an
        intermediary IPv6/IPv4 router that is reachable via an IPv4
        infrastructure.  This type of tunnel spans the first segment of
        the packet's end-to-end path.

   -    Host-to-Host.  IPv6/IPv4 hosts that are interconnected by an
        IPv4 infrastructure can tunnel IPv6 packets between themselves.
        In this case, the tunnel spans the entire end-to-end path that
        the packet takes.

   -    Router-to-Host.  IPv6/IPv4 routers can tunnel IPv6 packets to
        their final destination IPv6/IPv4 host.  This tunnel spans only
        the last segment of the end-to-end path.

   Tunneling techniques are usually classified according to the
   mechanism by which the encapsulating node determines the address of
   the node at the end of the tunnel.  In the first two tunneling
   methods listed above -- router-to-router and host-to-router -- the
   IPv6 packet is being tunneled to a router.  The endpoint of this type
   of tunnel is an intermediary router which must decapsulate the IPv6
   packet and forward it on to its final destination.  When tunneling to
   a router, the endpoint of the tunnel is different from the
   destination of the packet being tunneled.  In some cases, the
   addresses in the IPv6 packet being tunneled can not provide the IPv4
   address of the tunnel endpoint.  In those cases, the tunnel endpoint
   address must be determined from configuration information on the node
   performing the encapsulation.  We use the term "configured tunneling"
   to describe the type of tunneling where the endpoint is explicitly
   configured.

   In the last two tunneling methods -- host-to-host and router-to-host
   -- the IPv6 packet is tunneled all the way to its final destination.
   In this case, the destination address of both the IPv6 packet and the
   encapsulating IPv4 header identify the same node.  However, the
   tunneling mechanism specified in this document does not handle these
   cases any differently; the IPv4 addresses is still determined using
   configuration information using configured tunneling.

   The underlying mechanisms for tunneling are:



<draft-ietf-v6ops-mech-v2-00.txt>                               [Page 9]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    The entry node of the tunnel (the encapsulating node) creates an
        encapsulating IPv4 header and transmits the encapsulated packet.

   -    The exit node of the tunnel (the decapsulating node) receives
        the encapsulated packet, reassembles the packet if needed,
        removes the IPv4 header, updates the IPv6 header, and processes
        the received IPv6 packet.

   -    The encapsulating node MAY need to maintain soft state
        information for each tunnel recording such parameters as the MTU
        of the tunnel in order to process IPv6 packets forwarded into
        the tunnel.  In cases where the number of tunnels that any one
        host or router is using is large, it is helpful to observe that
        this state information can be cached and discarded when not in
        use.

   The remainder of this section discusses the common mechanisms.  A
   subsequent section discusses how the tunnel endpoint address is
   determined for configured tunneling.



3.1.  Encapsulation

      The encapsulation of an IPv6 datagram in IPv4 is shown below:


                                                   +-------------+
                                                   |    IPv4     |
                                                   |   Header    |
                   +-------------+                 +-------------+
                   |    IPv6     |                 |    IPv6     |
                   |   Header    |                 |   Header    |
                   +-------------+                 +-------------+
                   |  Transport  |                 |  Transport  |
                   |   Layer     |      ===>       |   Layer     |
                   |   Header    |                 |   Header    |
                   +-------------+                 +-------------+
                   |             |                 |             |
                   ~    Data     ~                 ~    Data     ~
                   |             |                 |             |
                   +-------------+                 +-------------+

                            Encapsulating IPv6 in IPv4


   In addition to adding an IPv4 header, the encapsulating node also has
   to handle some more complex issues:



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 10]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    Determine when to fragment and when to report an ICMP "packet
        too big" error back to the source.

   -    How to reflect IPv4 ICMP errors from routers along the tunnel
        path back to the source as IPv6 ICMP errors.

   Those issues are discussed in the following sections.



3.2.  Tunnel MTU and Fragmentation

   The encapsulating node could view encapsulation as IPv6 using IPv4 as
   a link layer with a very large MTU (65535-20 bytes to be exact; 20
   bytes "extra" are needed for the encapsulating IPv4 header).  The
   encapsulating node would need only to report IPv6 ICMP "packet too
   big" errors back to the source for packets that exceed this MTU.
   However, such a scheme would be inefficient for two reasons and is
   therefor NOT RECOMMENDED:

   1)   It would result in more fragmentation than needed.  IPv4 layer
        fragmentation SHOULD be avoided due to the performance problems
        caused by the loss unit being smaller than the retransmission
        unit [KM97].

   2)   Any IPv4 fragmentation occurring inside the tunnel, i.e. between
        the encapsulating node and the decapsulating node, would have to
        be reassembled at the tunnel endpoint.  For tunnels that
        terminate at a router, this would require additional memory to
        reassemble the IPv4 fragments into a complete IPv6 packet before
        that packet could be forwarded onward.

   Hence, the encapsulating node MUST NOT treat the tunnel as an
   interface with an MTU of 64 kilobytes, but instead use the smaller
   MTU specified below.

   The fragmentation inside the tunnel can be reduced to a minimum by
   having the encapsulating node track the IPv4 Path MTU across the
   tunnel, using the IPv4 Path MTU Discovery Protocol [RFC1191] and
   recording the resulting path MTU.  The IPv6 layer in the
   encapsulating node can then view a tunnel as a link layer with an MTU
   equal to the IPv4 path MTU, minus the size of the encapsulating IPv4
   header.

   Note that this does not eliminate IPv4 fragmentation in the case when
   the IPv4 path MTU would result in an IPv6 MTU less than 1280 bytes.
   (Any link layer used by IPv6 has to have an MTU of at least 1280
   bytes [RFC2460].) In this case the IPv6 layer has to "see" a link



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 11]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   layer with an MTU of 1280 bytes and the encapsulating node has to use
   IPv4 fragmentation in order to forward the 1280 byte IPv6 packets.

   This dynamic MTU determination is OPTIONAL.  However, if it is
   implemented it SHOULD have the behavior described in this document.
   If it is not implemented instead the node MUST instead limit the size
   of the IPv6 packets it tunnels to 1280 bytes i.e., treat the tunnel
   interface as having a fixed interface MTU of 1280 bytes.  An
   implementation MAY have a configuration knob which can be used to set
   a larger value of the tunnel MTU than 1280 bytes, but if so the
   default MUST be 1280 bytes.  A larger fixed MTU should not be
   configured unless it has been administratively ensured that the
   decapsulating node can reassemble packets of that size.

   The encapsulating node SHOULD employ the following algorithm to
   determine when to forward an IPv6 packet that is larger than the
   tunnel's path MTU using IPv4 fragmentation, and when to return an
   IPv6 ICMP "packet too big" message per [RFC1981]:

           if (IPv4 path MTU - 20) is less than or equal to 1280
                   if packet is larger than 1280 bytes
                           Send IPv6 ICMP "packet too big" with MTU = 1280.
                           Drop packet.
                   else
                           Encapsulate but do not set the Don't Fragment
                           flag in the IPv4 header.  The resulting IPv4
                           packet might be fragmented by the IPv4 layer on
                           the encapsulating node or by some router along
                           the IPv4 path.
                   endif
           else
                   if packet is larger than (IPv4 path MTU - 20)
                           Send IPv6 ICMP "packet too big" with
                           MTU = (IPv4 path MTU - 20).
                           Drop packet.
                   else
                           Encapsulate and set the Don't Fragment flag
                           in the IPv4 header.
                   endif
           endif


   Encapsulating nodes that have a large number of tunnels might not be
   able to store the IPv4 Path MTU for all tunnels.  Such nodes can, at
   the expense of additional fragmentation in the network, avoid using
   the IPv4 Path MTU algorithm across the tunnel and instead use the MTU
   of the link layer (under IPv4) in the above algorithm instead of the
   IPv4 path MTU.  In that case the IPv6 MTU for the tunnel MUST be



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 12]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   limited to 1280 unless it has explicitly been configured to be
   larger.

   In this case the Don't Fragment bit MUST NOT be set in the
   encapsulating IPv4 header.



3.3.  Hop Limit

   IPv6-over-IPv4 tunnels are modeled as "single-hop".  That is, the
   IPv6 hop limit is decremented by 1 when an IPv6 packet traverses the
   tunnel.  The single-hop model serves to hide the existence of a
   tunnel.  The tunnel is opaque to users of the network, and is not
   detectable by network diagnostic tools such as traceroute.

   The single-hop model is implemented by having the encapsulating and
   decapsulating nodes process the IPv6 hop limit field as they would if
   they were forwarding a packet on to any other datalink.  That is,
   they decrement the hop limit by 1 when forwarding an IPv6 packet.
   (The originating node and final destination do not decrement the hop
   limit.)

   The TTL of the encapsulating IPv4 header is selected in an
   implementation dependent manner.  The current suggested value is
   published in the "Assigned Numbers" RFC [RFC3232][ASSIGNED].
   Implementations MAY provide a mechanism to allow the administrator to
   configure the IPv4 TTL such as the one specified in the IP Tunnel MIB
   [RFC2667].



3.4.  Handling IPv4 ICMP errors

   In response to encapsulated packets it has sent into the tunnel, the
   encapsulating node might receive IPv4 ICMP error messages from IPv4
   routers inside the tunnel.  These packets are addressed to the
   encapsulating node because it is the IPv4 source of the encapsulated
   packet.

   The ICMP "packet too big" error messages are handled according to
   IPv4 Path MTU Discovery [RFC1191] and the resulting path MTU is
   recorded in the IPv4 layer.  The recorded path MTU is used by IPv6 to
   determine if an IPv6 ICMP "packet too big" error has to be generated
   as described in section 3.2.

   The handling of other types of ICMP error messages depends on how
   much information is included in the "packet in error" field, which



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 13]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   holds the encapsulated packet that caused the error.

   Many older IPv4 routers return only 8 bytes of data beyond the IPv4
   header of the packet in error, which is not enough to include the
   address fields of the IPv6 header.  More modern IPv4 routers are
   likely to return enough data beyond the IPv4 header to include the
   entire IPv6 header and possibly even the data beyond that.

   If the offending packet includes enough data, the encapsulating node
   MAY extract the encapsulated IPv6 packet and use it to generate an
   IPv6 ICMP message directed back to the originating IPv6 node, as
   shown below:

                   +--------------+
                   | IPv4 Header  |
                   | dst = encaps |
                   |       node   |
                   +--------------+
                   |     ICMP     |
                   |    Header    |
            - -    +--------------+
                   | IPv4 Header  |
                   | src = encaps |
           IPv4    |       node   |
                   +--------------+   - -
           Packet  |    IPv6      |
                   |    Header    |   Original IPv6
            in     +--------------+   Packet -
                   |  Transport   |   Can be used to
           Error   |    Header    |   generate an
                   +--------------+   IPv6 ICMP
                   |              |   error message
                   ~     Data     ~   back to the source.
                   |              |
            - -    +--------------+   - -

       IPv4 ICMP Error Message Returned to Encapsulating Node




3.5.  IPv4 Header Construction

   When encapsulating an IPv6 packet in an IPv4 datagram, the IPv4
   header fields are set as follows:

        Version:




<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 14]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


                4

        IP Header Length in 32-bit words:

                5 (There are no IPv4 options in the encapsulating
                header.)

        Type of Service:

                0 unless otherwise specified. (See [RFC2983] and
                [RFC3168] for issues relating to the ToS byte and
                tunneling.)

        Total Length:

                Payload length from IPv6 header plus length of IPv6 and
                IPv4 headers (i.e., IPv6 payload length plus a constant
                60 bytes).

        Identification:

                Generated uniquely as for any IPv4 packet transmitted by
                the system.

        Flags:

                Set the Don't Fragment (DF) flag as specified in section
                3.2.  Set the More Fragments (MF) bit as necessary if
                fragmenting.

        Fragment offset:

                Set as necessary if fragmenting.

        Time to Live:

                Set in implementation-specific manner.

        Protocol:

                41 (Assigned payload type number for IPv6)

        Header Checksum:

                Calculate the checksum of the IPv4 header.

        Source Address:




<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 15]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


                IPv4 address of outgoing interface of the encapsulating
                node.  The source address MAY alternatively be
                administratively specified to be a specific IPv4 address
                assigned to the encapsulating node.

        Destination Address:

                IPv4 address of tunnel endpoint.

   Any IPv6 options are preserved in the packet (after the IPv6 header).



3.6.  Decapsulation

   When an IPv6/IPv4 host or a router receives an IPv4 datagram that is
   addressed to one of its own IPv4 address, and the value of the
   protocol field is 41, it reassembles if the packet if it is
   fragmented at the IPv4 level, then it removes the IPv4 header and
   submits the IPv6 datagram to its IPv6 layer code.

   The decapsulating node MUST be capable of reassembling an IPv4 packet
   that is the maximum of 1280 bytes and the largest interface MTU on
   the decapsulator.  The 1280 byte number is a result of encapsulators
   that use the static MTU in section 3.2, while encapsulators that use
   the dynamic scheme in section 3.2 can cause up to the largest
   interface MTU on the decapsulator to be received. (Note that it is
   strictly the interface MTU on the last IPv4 router *before* the
   decapsulator that matters, but for most links the MTU is the same
   between all neighbors.)

   This reassembly limit allows dynamic tunnel MTU determination by the
   encapsulator to take advantage of larger IPv4 path MTUs.  An
   implementation MAY have a configuration knob which can be used to set
   a larger value of the tunnel reassembly buffers than the above
   number, but it MUST NOT be set below the above number.

   The decapsulation is shown below:













<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 16]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002



           +-------------+
           |    IPv4     |
           |   Header    |
           +-------------+                 +-------------+
           |    IPv6     |                 |    IPv6     |
           |   Header    |                 |   Header    |
           +-------------+                 +-------------+
           |  Transport  |                 |  Transport  |
           |   Layer     |      ===>       |   Layer     |
           |   Header    |                 |   Header    |
           +-------------+                 +-------------+
           |             |                 |             |
           ~    Data     ~                 ~    Data     ~
           |             |                 |             |
           +-------------+                 +-------------+

                       Decapsulating IPv6 from IPv4


   When decapsulating the packet, the IPv6 header is not modified.  (See
   [RFC2983] and [RFC3168] for issues relating to the Type of Service
   byte and tunneling.)  If the packet is subsequently forwarded, its
   hop limit is decremented by one.

   As part of the decapsulation the node SHOULD silently discard a
   packet with an invalid IPv4 source address such as a multicast
   address, a broadcast address, 0.0.0.0, and 127.0.0.1.  In general it
   SHOULD apply the rules for martian filtering in [RFC1812] and ingress
   filtering [RFC2267] on the IPv4 source address.

   The decapsulating node performs IPv4 reassembly before decapsulating
   the IPv6 packet.  All IPv6 options are preserved even if the
   encapsulating IPv4 packet is fragmented.

   The encapsulating IPv4 header is discarded.

   After the decapsulation the node SHOULD silently discard a packet
   with an invalid IPv6 source address.  This includes IPv6 multicast
   addresses, the unspecified address, and the loopback address but also
   IPv4-compatible IPv6 source addresses where the IPv4 part of the
   address is an (IPv4) multicast address, broadcast address, 0.0.0.0,
   or 127.0.0.1.  In general it SHOULD apply the rules for martian
   filtering in [RFC1812] and ingress filtering [RFC2267] on the IPv4
   address embedded in IPv4-compatible source addresses.

   After the IPv6 packet is decapsulated, it is processed almost the
   same as any received IPv6 packet.  The difference being that a



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 17]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   decapsulated packet MUST NOT be accepted (and delivered locally or
   forwarded) unless the node has been explicitly configured to accept
   tunneled packets with the given IPv4 source address.  This
   configuration can be implicit in e.g., having a bidirectional
   configured tunnel which matches the IPv4 source address.  This
   restriction is needed to prevent tunneling to be used as a tool to
   circumvent ingress filtering [RFC2267] when ingress filtering is used
   in IPv4 and IPv6 on both "sides" of the decapsulator.



3.7.  Link-Local Addresses

   The configured tunnels are IPv6 interfaces (over the IPv4 "link
   layer") thus MUST have link-local addresses.  The link-local
   addresses are used by routing protocols operating over the tunnels.

   The Interface Identifier [RFC2373] for such an Interface SHOULD be
   the 32-bit IPv4 address of that interface, with the bytes in the same
   order in which they would appear in the header of an IPv4 packet,
   padded at the left with zeros to a total of 64 bits.  Note that the
   "Universal/Local" bit is zero, indicating that the Interface
   Identifier is not globally unique.  When the host has more than one
   IPv4 address in use on the physical interface concerned, an
   administrative choice of one of these IPv4 addresses is made.

   The IPv6 Link-local address [RFC2373] for an IPv4 virtual interface
   is formed by appending the Interface Identifier, as defined above, to
   the prefix FE80::/64.

   +-------+-------+-------+-------+-------+-------+------+------+
   |  FE      80      00      00      00      00      00     00  |
   +-------+-------+-------+-------+-------+-------+------+------+
   |  00      00   |  00   |  00   |   IPv4 Address              |
   +-------+-------+-------+-------+-------+-------+------+------+



3.8.  Neighbor Discovery over Tunnels

   For unidirectional configured tunnels most of Neighbor Discovery
   [RFC2667] and Stateless Address Autoconfiguration [RFC2462] does not
   apply; only the formation of the link-local address applies.

   If an implementation provides bidirectional configured tunnels it
   MUST at least accept and respond to the probe packets used by
   Neighbor Unreachability Detection [RFC2461].  Such implementations
   SHOULD also send NUD probe packets to detect when the configured



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 18]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   tunnel fails at which point the implementation can use an alternate
   path to reach the destination.  Note that Neighbor Discovery allows
   that the sending of NUD probes be omitted for router to router links
   if the routing protocol tracks bidirectional reachability.

   For the purposes of Neighbor Discovery the configured tunnels
   specified in this document are assumed to NOT have a link-layer
   address, even though the link-layer (IPv4) does have address.  This
   means that a sender of Neighbor Discovery packets

    -   SHOULD NOT include Source Link Layer Address options or Target
        Link Layer Address options on the tunnel link.

    -   MUST silently ignore any received neighbor discovery source link
        layer address or target link layer address options received over
        the tunnel link.

   Not using a link layer address options is consistent with how
   neighbor discovery is used on other point-to-point links.



3.9.  Ingress Filtering

   The specification above contains rules that apply ingress filtering
   to packets before they are decapsulated.  The purpose of ingress
   filtering in general is specified in [RFC2267].  When IP-in-IP
   tunneling (independent of IP versions) is used it is important that
   this not be a tool to bypass any ingress filtering in use for non-
   tunneled packets.  Thus the rules are derived based on the assumption
   that should ingress filtering be used for IPv4 and IPv6, the use of
   tunneling should not provide an easy way to circumvent the filtering.
   In this case, without specific ingress filtering checks in the
   decapsulating node, it would be possible for an attacker to inject a
   packet with:

    -   Outer IPv4 source: real IPv4 address of attacker

    -   Outer IPv4 destination: IPv4 address of decapsulating node

    -   Inner IPv6 source: Alice which is either the decapsulating node
        or a node close to it.

    -   Inner IPv6 destination: Bob

   Even if all IPv4 routers between the attacker and the decapsulating
   node implement IPv4 ingress filtering, and all IPv6 routers between
   the decapsulating node and Bob implement IPv6 ingress filtering, the



<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 19]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   above spoofed packets will not be filtered out unless the
   decapsulator performs some checks.

   The solution to this is to have the decapsulating node perform
   ingress filtering checks as part of the decapsulation as specified in
   section 4.1.




4.  Configured Tunneling

   In configured tunneling, the tunnel endpoint address is determined
   from configuration information in the encapsulating node.  For each
   tunnel, the encapsulating node must store the tunnel endpoint
   address.  When an IPv6 packet is transmitted over a tunnel, the
   tunnel endpoint address configured for that tunnel is used as the
   destination address for the encapsulating IPv4 header.

   The determination of which packets to tunnel is usually made by
   routing information on the encapsulating node.  This is usually done
   via a routing table, which directs packets based on their destination
   address using the prefix mask and match technique.



4.1.  Ingress Filtering

   The decapsulating node MUST verify that the tunnel source address is
   acceptable before accepting decapsulated packets to avoid
   circumventing ingress filtering [RFC2267].  This check also applies
   to packets which are delivered to transport protocols on the
   decapsulating node.  For bidirectional configured tunnels this is
   done by verifying that the source address is the IPv4 address of the
   other end of the tunnel.  For unidirectional configured tunnels the
   decapsulating node MUST be configured with a list of source IPv4
   address prefixes that are acceptable.  Such a list MUST default to
   not having any entries i.e., the node has to be explicitly configured
   to forward decapsulated packets received over unidirectional
   configured tunnels.











<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 20]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


5.  Acknowledgments

   We would like to thank the members of the IPv6 working group, the
   Next Generation Transition (ngtrans) working group, and the v6ops
   working group for their many contributions and extensive review of
   this document.  Special thanks are due to Jim Bound, Ross Callon, Bob
   Hinden, John Moy, and Pekka Savola for many helpful suggestions.




6.  Security Considerations

   Tunneling is not known to introduce any security holes except for the
   possibility to circumvent ingress filtering [RFC2267].  This
   specification prevent tunneling from introducing additional
   weaknesses when IPv4 and/or IPv6 ingress filtering is in used by
   requiring that decapsulating nodes only accept packets if they have
   been configured to accept encapsulated packets from the IPv4 source
   address in the received packet.  Such a check is easy to perform for
   bidirectional tunnels, but for uni-directional tunnels it requires a
   separate configuration of the IPv4 source addresses that are
   acceptable.

   An implementation of tunneling needs to be aware that while a tunnel
   is a link (as defined in [RFC2460]), the threat model for a tunnel
   might be rather different than for other links, since the tunnel
   potentially includes all of the Internet.  The recommendations to
   verify that the IPv4 addresses in the encapsulated packet matches
   what has been configured for the tunnel, coupled with use of ingress
   filtering in IPv4, ameliorate some of this.  In addition, an
   implementation must treat interfaces to different links as separate
   e.g. to ensure that Neighbor Discovery packets arriving on one link
   does not effect other links.  This is especially important for tunnel
   links.



7.  Authors' Addresses












<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 21]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002



   Erik Nordmark
   Sun Microsystems Laboratories
   180, avenue de l'Europe
   38334 SAINT ISMIER Cedex, France
   Tel : +33 (0)4 76 18 88 03
   Fax : +33 (0)4 76 18 88 88
   Email : erik.nordmark@sun.com

   Robert E. Gilligan
   Intransa, Inc.
   2870 Zanker Rd., Suite 100
   San Jose, CA 95134

   Tel : +1 408 678 8600
   Fax : +1 408 678 8800
   Email : gilligan@intransa.com, gilligan@leaf.com




8.  References



8.1.  Normative References


 [RFC1191]  Mogul, J., and S. Deering., "Path MTU Discovery", RFC 1191,
            November 1990.

 [RFC1981]  McCann, J., S. Deering, and J. Mogul. "Path MTU Discovery
            for IP version 6", RFC 1981, August 1996.

 [RFC2119]  S. Bradner, "Key words for use in RFCs to Indicate
            Requirement Levels", RFC 2119, March 1997.

 [RFC2460]  Deering, S., and Hinden, R. "Internet Protocol, Version 6
            (IPv6) Specification", RFC 2460, December 1998.



8.2.  Non-normative References


 [ASSIGNED] IANA, "Assigned numbers online database",
            http://www.iana.org/numbers.html




<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 22]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


 [KM97]     Kent, C., and J. Mogul, "Fragmentation Considered Harmful".
            In Proc.  SIGCOMM '87 Workshop on Frontiers in Computer
            Communications Technology.  August 1987.

 [RFC1122]  Braden, R., "Requirements for Internet Hosts - Communication
            Layers", STD 3, RFC 1122, October 1989.

 [RFC1812]  F. Baker, "Requirements for IP Version 4 Routers", RFC 1812,
            June 1995.

 [RFC1886]  Thomson, S., and Huitema C. "DNS Extensions to support IP
            version 6", RFC 1886, December 1995.

 [RFC2267]  Ferguson, P., and Senie, D., "Network Ingress Filtering:
            Defeating Denial of Service Attacks which employ IP Source
            Address Spoofing", RFC 2267, January 1998.

 [RFC2373]  Hinden, R., and S. Deering, "IP Version 6 Addressing
            Architecture", RFC 2373, July 1998.

 [RFC2461]  Narten, T., Nordmark, E., and Simpson, W. "Neighbor
            Discovery for IP Version 6 (IPv6)", RFC 2461, December 1998.

 [RFC2462]  Thomson, S., and Narten, T. "IPv6 Stateless Address
            Autoconfiguration," RFC 2462, December 1998.

 [RFC2667]  D. Thaler, "IP Tunnel MIB", RFC 2667, August 1999.

 [RFC2983]  D. Black, "Differentiated Services and Tunnels", RFC 2983,
            October 2000.

 [RFC3056]  B. Carpenter, and K. Moore, "Connection of IPv6 Domains via
            IPv4 Clouds", RFC 3056, February 2001.

 [RFC3168]  K. Ramakrishnan, S. Floyd, D. Black, "The Addition of
            Explicit Congestion Notification (ECN) to IP", RFC 3168,
            September 2001.

 [RFC3232]  Reynolds, J., "Assigned Numbers: RFC 1700 is Replaced by an
            On-line Database", RFC 3232, January 2002.

 [RFC3484]  R. Draves, "Default Address Selection for IPv6", Work in
            progress, draft-ietf-ipv6-default-addr-select-09.txt, June
            2002.







<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 23]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


9.  Changes from RFC 2893

     The motivation for the bulk of these changes are to simplify the
     document to only contain the mechanisms of wide-spread use.

     RFC 2893 contains a mechanism called automatic tunneling.  But a
     much more general mechanism is specified in RFC 3056 [RFC3056]
     which gives each node with a (global) IPv4 address a /48 IPv6
     prefix i.e., enough for a whole site.




   -    Removed references to A6 and retained AAAA.

   -    Removed automatic tunneling and IPv4-compatible addresses.

   -    Removed default Configured Tunnel using IPv4 "Anycast Address"

   -    Removed Source Address Selection section since this is now
        covered by another document ([RFC3484]).

   -    Removed brief mention of 6over4.

   -    Split into normative and non-normative references and other
        reference cleanup.

   -    Dropped "or equal" in if (IPv4 path MTU - 20) is less than or
        equal to 1280

   -    Dropped this: However, IPv6 may be used in some environments
        where interoperability with IPv4 is not required.  IPv6 nodes
        that are designed to be used in such environments need not use
        or even implement these mechanisms.

   -    Clarified that the dynamic path MTU mechanism in section 3.2 is
        OPTIONAL but if it is implemented it should follow the rules in
        section 3.2.

   -    Stated that when the dynamic PMTU is not implemented the sender
        MUST NOT by default send IPv6 packets larger than 1280 into the
        tunnel.

   -    Stated that implementations MAY have a knob by which the MTU can
        be set to larger values on a tunnel by tunnel basis, but that
        the default MUST be 1280 and that decapsulators need to be
        configured to match the encapsulaltor's MTU.




<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 24]

INTERNET DRAFT      Basic IPv6 Transition Mechanisms       November 2002


   -    Restated the "currently underway" language about ToS to loosely
        point at [RFC2983] and [RFC3168].

   -    Stated that IPv4 source MAY also be administratively specified.
        (This is especially useful on multi-interface nodes and with
        configured tunneling)

   -    Fixed reference to Assigned Numbers to be to online version
        (with proper pointer to "Assigned Numbers is obsolete" RFC)

   -    Clarified text about ingress filtering e.g. that it applies to
        packet delivered to transport protocols on the decapsulating
        node as well as packets being forwarded by the decapsulator, and
        how the decapsulator's checks help when IPv4 and IPv6 ingress
        filtering is in place.




































<draft-ietf-v6ops-mech-v2-00.txt>                              [Page 25]

