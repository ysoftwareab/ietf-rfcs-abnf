


Secure Shell Working Group                                  J. Hutzelman
Internet-Draft                                                       CMU
Expires: November 7, 2005                                     J. Salowey
                                                           Cisco Systems
                                                            J. Galbraith
                                             Van Dyke Technologies, Inc.
                                                                V. Welch
                                                         U Chicago / ANL
                                                             May 6, 2005


  GSSAPI Authentication and Key Exchange for the Secure Shell Protocol
                      draft-ietf-secsh-gsskeyex-09

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on November 7, 2005.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   The Secure Shell protocol (SSH) is a protocol for secure remote login
   and other secure network services over an insecure network.




Hutzelman, et al.       Expires November 7, 2005                [Page 1]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   The Generic Security Service Application Program Interface (GSS-API)
   [GSSAPI] provides security services to callers in a mechanism-
   independent fashion.

   This memo describes methods for using the GSS-API for authentication
   and key exchange in SSH.  It defines an SSH user authentication
   method which uses a specified GSSAPI mechanism to authenticate a
   user, and a family of SSH key exchange methods which use GSSAPI to
   authenticate the Diffie-Hellman exchange described in [SSH-
   TRANSPORT].

   This memo also defines a new host public key algorithm which can be
   used when no operations are needed using a host's public key, and a
   new user authentication method which allows an authorization name to
   be used in conjunction with any authentication which has already
   occurred as a side-effect of GSSAPI-based key exchange.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [KEYWORDS].































Hutzelman, et al.       Expires November 7, 2005                [Page 2]

Internet-Draft             SSH GSSAPI Methods                   May 2005


Table of Contents

   1.   Introduction . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1  SSH terminology  . . . . . . . . . . . . . . . . . . . . .   4
   2.   GSSAPI Authenticated Diffie-Hellman Key Exchange . . . . . .   5
     2.1  Generic GSSAPI Key Exchange  . . . . . . . . . . . . . . .   5
     2.2  Group Exchange . . . . . . . . . . . . . . . . . . . . . .  11
     2.3  gss-group1-sha1-*  . . . . . . . . . . . . . . . . . . . .  13
     2.4  gss-group14-sha1-* . . . . . . . . . . . . . . . . . . . .  13
     2.5  gss-gex-sha1-* . . . . . . . . . . . . . . . . . . . . . .  13
     2.6  Other GSSAPI key exchange methods  . . . . . . . . . . . .  13
   3.   GSSAPI User Authentication . . . . . . . . . . . . . . . . .  15
     3.1  GSSAPI Authentication Overview . . . . . . . . . . . . . .  15
     3.2  Initiating GSSAPI authentication . . . . . . . . . . . . .  15
     3.3  Initial server response  . . . . . . . . . . . . . . . . .  16
     3.4  GSSAPI session . . . . . . . . . . . . . . . . . . . . . .  16
     3.5  Binding Encryption Keys  . . . . . . . . . . . . . . . . .  17
     3.6  Client acknowledgement . . . . . . . . . . . . . . . . . .  18
     3.7  Completion . . . . . . . . . . . . . . . . . . . . . . . .  19
     3.8  Error Status . . . . . . . . . . . . . . . . . . . . . . .  19
     3.9  Error Token  . . . . . . . . . . . . . . . . . . . . . . .  20
   4.   Authentication using GSSAPI Key Exchange . . . . . . . . . .  21
   5.   Null Host Key Algorithm  . . . . . . . . . . . . . . . . . .  23
   6.   Summary of Message Numbers . . . . . . . . . . . . . . . . .  24
   7.   GSSAPI Considerations  . . . . . . . . . . . . . . . . . . .  25
     7.1  Naming Conventions . . . . . . . . . . . . . . . . . . . .  25
     7.2  Channel Bindings . . . . . . . . . . . . . . . . . . . . .  25
     7.3  SPNEGO . . . . . . . . . . . . . . . . . . . . . . . . . .  25
   8.   IANA Considerations  . . . . . . . . . . . . . . . . . . . .  27
   9.   Security Considerations  . . . . . . . . . . . . . . . . . .  28
   10.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . .  29
   11.  Changes the last version . . . . . . . . . . . . . . . . . .  30
   12.  References . . . . . . . . . . . . . . . . . . . . . . . . .  31
     12.1   Normative References . . . . . . . . . . . . . . . . . .  31
     12.2   Non-Normative References . . . . . . . . . . . . . . . .  32
        Authors' Addresses . . . . . . . . . . . . . . . . . . . . .  32
        Intellectual Property and Copyright Statements . . . . . . .  34














Hutzelman, et al.       Expires November 7, 2005                [Page 3]

Internet-Draft             SSH GSSAPI Methods                   May 2005


1.  Introduction

   This document describes the methods used to perform key exchange and
   user authentication in the Secure Shell protocol using the GSSAPI.
   To do this, it defines a family of key exchange methods, two user
   authentication methods, and a new host key algorithm.  These
   definitions allow any GSSAPI mechanism to be used with the Secure
   Shell protocol.

   This document should be read only after reading the documents
   describing the SSH protocol architecture [SSH-ARCH], transport layer
   protocol [SSH-TRANSPORT], and user authentication protocol [SSH-
   USERAUTH].  This document freely uses terminology and notation from
   the architecture document without reference or further explanation.

1.1  SSH terminology

   The data types used in the packets are defined in the SSH
   architecture document [SSH-ARCH].  It is particularly important to
   note the definition of string allows binary content.

   The SSH_MSG_USERAUTH_REQUEST packet refers to a service; this service
   name is an SSH service name, and has no relationship to GSSAPI
   service names.  Currently, the only defined service name is "ssh-
   connection", which refers to the SSH connection protocol [SSH-
   CONNECT].

























Hutzelman, et al.       Expires November 7, 2005                [Page 4]

Internet-Draft             SSH GSSAPI Methods                   May 2005


2.  GSSAPI Authenticated Diffie-Hellman Key Exchange

   This section defines a class of key exchange methods which combine
   the Diffie-Hellman key exchange from section 8 of [SSH-TRANSPORT]
   with mutual authentication using GSSAPI.

   Since the GSSAPI key exchange methods described in this section do
   not require the use of public key signature or encryption algorithms,
   they MAY be used with any host key algorithm, including the "null"
   algorithm described in Section 5.

2.1  Generic GSSAPI Key Exchange

   The following symbols are used in this description:

   o  C is the client, and S is the server

   o  p is a large safe prime, g is a generator for a subgroup of GF(p),
      and q is the order of the subgroup

   o  V_S is S's version string, and V_C is C's version string

   o  I_C is C's KEXINIT message, and I_S is S's KEXINIT message

   1.  C generates a random number x (1 < x < q) and computes e = g^x
       mod p.

   2.  C calls GSS_Init_sec_context, using the most recent reply token
       received from S during this exchange, if any.  For this call, the
       client MUST set the mutual_req_flag to "true" to request that
       mutual authentication be performed.  It also MUST set the
       integ_req_flag to "true" to request that per-message integrity
       protection be supported for this context.  In addition, the
       deleg_req_flag MAY be set to "true" to request access delegation,
       if requested by the user.  Since the key exchange process
       authenticates only the host, the setting of the anon_req_flag is
       immaterial to this process.  If the client does not support the
       "gssapi-keyex" user authentication method described in Section 4,
       or does not intend to use that method in conjunction with the
       GSSAPI context established during key exchange, then the
       anon_req_flag SHOULD be set to "true".  Otherwise, this flag MAY
       be set to true if the client wishes to hide its identity.  Since
       the key exchange process will involve the exchange of only a
       single token once the context has been established, it is not
       necessary that the GSSAPI context support detection of replayed
       or out-of-sequence tokens.  Thus, the setting of the
       replay_det_req_flag and sequence_req_flag are not needed for this
       process.  These flags SHOULD be set to "false".



Hutzelman, et al.       Expires November 7, 2005                [Page 5]

Internet-Draft             SSH GSSAPI Methods                   May 2005


       *  If the resulting major_status code is GSS_S_COMPLETE and the
          mutual_state flag is not true, then mutual authentication has
          not been established, and the key exchange MUST fail.

       *  If the resulting major_status code is GSS_S_COMPLETE and the
          integ_avail flag is not true, then per-message integrity
          protection is not available, and the key exchange MUST fail.

       *  If the resulting major_status code is GSS_S_COMPLETE and both
          the mutual_state and integ_avail flags are true, the resulting
          output token is sent to S.

       *  If the resulting major_status code is GSS_S_CONTINUE_NEEDED,
          the output_token is sent to S, which will reply with a new
          token to be provided to GSS_Init_sec_context.

       *  The client MUST also include "e" with the first message it
          sends to the server during this process; if the server
          receives more than one "e" or none at all, the key exchange
          fails.

       *  It is an error if the call does not produce a token of non-
          zero length to be sent to the server.  In this case, the key
          exchange MUST fail.

   3.  S calls GSS_Accept_sec_context, using the token received from C.

       *  If the resulting major_status code is GSS_S_COMPLETE and the
          mutual_state flag is not true, then mutual authentication has
          not been established, and the key exchange MUST fail.

       *  If the resulting major_status code is GSS_S_COMPLETE and the
          integ_avail flag is not true, then per-message integrity
          protection is not available, and the key exchange MUST fail.

       *  If the resulting major_status code is GSS_S_COMPLETE and both
          the mutual_state and integ_avail flags are true, then the
          security context has been established, and processing
          continues with step 4.

       *  If the resulting major_status code is GSS_S_CONTINUE_NEEDED,
          then the output token is sent to C, and processing continues
          with step 2.

       *  If the resulting major_status code is GSS_S_COMPLETE, but a
          non-zero-length reply token is returned, then that token is
          sent to the client.




Hutzelman, et al.       Expires November 7, 2005                [Page 6]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   4.  S generates a random number y (0 < y < q) and computes f = g^y
       mod p.  It computes K = e ^ y mod p, and H = hash(V_C || V_S ||
       I_C || I_S || K_S || e || f || K).  It then calls GSS_GetMIC to
       obtain a GSSAPI message integrity code for H. S then sends f and
       the MIC to C.

   5.  This step is performed only if the server's final call to
       GSS_Accept_sec_context produced a non-zero-length final reply
       token to be sent to the client _and_ no previous call by the
       client to GSS_Init_sec_context has resulted in a major_status of
       GSS_S_COMPLETE.  Under these conditions, the client makes an
       additional call to GSS_Init_sec_context to process the final
       reply token.  This call is made exactly as described above.
       However, if the resulting major_status is anything other than
       GSS_S_COMPLETE, or a non-zero-length token is returned, it is an
       error and the key exchange MUST fail.

   6.  C computes K = f^x mod p, and H = hash(V_C || V_S || I_C || I_S
       || K_S || e || f || K).  It then calls GSS_VerifyMIC to verify
       that the MIC sent by S matches H. If the MIC is not successfully
       verified, the key exchange MUST fail.

   Either side MUST NOT send or accept e or f values that are not in the
   range [1, p-1].  If this condition is violated, the key exchange
   fails.

   If any call to GSS_Init_sec_context or GSS_Accept_sec_context returns
   a major_status other than GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED, or
   any other GSSAPI call returns a major_status other than
   GSS_S_COMPLETE, the key exchange fails.  In this case, several
   mechanisms are available for communicating error information to the
   peer before terminating the connection as required by [SSH-
   TRANSPORT]:

   o  If the key exchange fails due to any GSSAPI error on the server
      (including errors returned by GSS_Accept_sec_context), the server
      MAY send a message informing the client of the details of the
      error.  In this case, if an error token is also sent (see below),
      then this message MUST be sent before the error token.

   o  If the key exchange fails due to a GSSAPI error returned from the
      server's call to GSS_Accept_sec_context, and an "error token" is
      also returned, then the server SHOULD send the error token to the
      client to allow completion of the GSS security exchange.

   o  If the key exchange fails due to a GSSAPI error returned from the
      client's call to GSS_Init_sec_context, and an "error token" is
      also returned, then the client SHOULD send the error token to the



Hutzelman, et al.       Expires November 7, 2005                [Page 7]

Internet-Draft             SSH GSSAPI Methods                   May 2005


      server to allow completion of the GSS security exchange.

   As noted in Section 9, it may be desirable under site security policy
   to obscure information about the precise nature of the error; thus,
   it is RECOMMENDED that implementations provide a method to suppress
   these messages as a matter of policy.

   This is implemented with the following messages.  The hash algorithm
   for computing the exchange hash is defined by the method name, and is
   called HASH.  The group used for Diffie-Hellman key exchange and the
   underlying GSSAPI mechanism are also defined by the method name.

   After the client's first call to GSS_Init_sec_context, it sends the
   following:

           byte      SSH_MSG_KEXGSS_INIT
           string    output_token (from GSS_Init_sec_context)
           mpint     e

   Upon receiving the SSH_MSG_KEXGSS_INIT message, the server MAY send
   the following message, prior to any other messages, to inform the
   client of its host key.

           byte      SSH_MSG_KEXGSS_HOSTKEY
           string    server public host key and certificates (K_S)

   Since this key exchange method does not require the host key to be
   used for any encryption operations, this message is OPTIONAL.  If the
   "null" host key algorithm described in Section 5 is used, this
   message MUST NOT be sent.  If this message is sent, the server public
   host key(s) and/or certificate(s) in this message are encoded as a
   single string, in the format specified by the public key type in use
   (see [SSH-TRANSPORT], section 6.6).

   In traditional SSH deployments, host keys are normally expected to
   change infrequently, and there is often no mechanism for validating
   host keys not already known to the client.  As a result, the use of a
   new host key by an already-known host is usually considered an
   indication of a possible man-in-the-middle attack, and clients often
   present strong warnings and/or abort the connection in such cases.

   By contrast, when GSSAPI-based key exchange is used, host keys sent
   via the SSH_MSG_KEXGSS_HOSTKEY message are authenticated as part of
   the GSSAPI key exchange, even when previously unknown to the client.
   Further, in environements in which GSSAPI-based key exchange is used
   heavily, it is possible and even likely that host keys will change
   much more frequently and/or without advance warning.




Hutzelman, et al.       Expires November 7, 2005                [Page 8]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   Therefore, when a new key for an already-known host is received via
   the SSH_MSG_KEXGSS_HOSTKEY message, clients SHOULD NOT issue strong
   warnings or abort the connection, provided the GSSAPI-based key
   exchange succeeds.

   In order to facilitate key re-exchange after the user's GSSAPI
   credentials have expired, client implementations SHOULD store host
   keys received via SSH_MSG_KEXGSS_HOSTKEY for the duration of the
   session, even when such keys are not stored for long-term use.

   Each time the server's call to GSS_Accept_sec_context returns a
   major_status code of GSS_S_CONTINUE_NEEDED, it sends the following
   reply to the client:

           byte      SSH_MSG_KEXGSS_CONTINUE
           string    output_token (from GSS_Accept_sec_context)

   If the client receives this message after a call to
   GSS_Init_sec_context has returned a major_status code of
   GSS_S_COMPLETE, a protocol error has occurred and the key exchange
   MUST fail.

   Each time the client receives the message described above, it makes
   another call to GSS_Init_sec_context.  It then sends the following:

           byte      SSH_MSG_KEXGSS_CONTINUE
           string    output_token (from GSS_Init_sec_context)

   The server and client continue to trade these two messages as long as
   the server's calls to GSS_Accept_sec_context result in major_status
   codes of GSS_S_CONTINUE_NEEDED.  When a call results in a
   major_status code of GSS_S_COMPLETE, it sends one of two final
   messages.

   If the server's final call to GSS_Accept_sec_context (resulting in a
   major_status code of GSS_S_COMPLETE) returns a non-zero-length token
   to be sent to the client, it sends the following:

           byte      SSH_MSG_KEXGSS_COMPLETE
           mpint     f
           string    per_msg_token (MIC of H)
           boolean   TRUE
           string    output_token (from GSS_Accept_sec_context)

   If the client receives this message after a call to
   GSS_Init_sec_context has returned a major_status code of
   GSS_S_COMPLETE, a protocol error has occurred and the key exchange
   MUST fail.



Hutzelman, et al.       Expires November 7, 2005                [Page 9]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   If the server's final call to GSS_Accept_sec_context (resulting in a
   major_status code of GSS_S_COMPLETE) returns a zero-length token or
   no token at all, it sends the following:

           byte      SSH_MSG_KEXGSS_COMPLETE
           mpint     f
           string    per_msg_token (MIC of H)
           boolean   FALSE

   If the client receives this message when no call to
   GSS_Init_sec_context has yet resulted in a major_status code of
   GSS_S_COMPLETE, a protocol error has occurred and the key exchange
   MUST fail.

   If either the client's call to GSS_Init_sec_context or the server's
   call to GSS_Accept_sec_context returns an error status and produces
   an output token (called an "error token"), then the following SHOULD
   be sent to convey the error information to the peer:

           byte      SSH_MSG_KEXGSS_CONTINUE
           string    error_token

   If a server sends both this message and an SSH_MSG_KEXGSS_ERROR
   message, the SSH_MSG_KEXGSS_ERROR message MUST be sent first, to
   allow clients to record and/or display the error information before
   processing the error token.  This is important because a client
   processing an error token will likely disconnect without reading any
   further messages.

   In the event of a GSSAPI error on the server, the server MAY send the
   following message before terminating the connection:

           byte      SSH_MSG_KEXGSS_ERROR
           uint32    major_status
           uint32    minor_status
           string    message
           string    language tag

   The message text MUST be encoded in the UTF-8 encoding described in
   [UTF8].  Language tags are those described in [LANGTAG].  Note that
   the message text may contain multiple lines separated by carriage
   return-line feed (CRLF) sequences.  Application developers should
   take this into account when displaying these messages.








Hutzelman, et al.       Expires November 7, 2005               [Page 10]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   The hash H is computed as the HASH hash of the concatenation of the
   following:

           string    V_C, the client's version string (CR, NL excluded)
           string    V_S, the server's version string (CR, NL excluded)
           string    I_C, the payload of the client's SSH_MSG_KEXINIT
           string    I_S, the payload of the server's SSH_MSG_KEXINIT
           string    K_S, the host key
           mpint     e, exchange value sent by the client
           mpint     f, exchange value sent by the server
           mpint     K, the shared secret

   This value is called the exchange hash, and it is used to
   authenticate the key exchange.  The exchange hash SHOULD be kept
   secret.  If no SSH_MSG_KEXGSS_HOSTKEY message has been sent by the
   server or received by the client, then the empty string is used in
   place of K_S when computing the exchange hash.

   The GSS_GetMIC call MUST be applied over H, not the original data.

2.2  Group Exchange

   This section describes a modification to the generic GSSAPI
   authenticated Diffie-Hellman key exchange to allow the negotiation of
   the group to be used, using a method based on that described in
   [GROUP-EXCHANGE].

   The server keeps a list of safe primes and corresponding generators
   that it can select from.  These are chosen as described in section 5
   of [GROUP-EXCHANGE].  The client requests a modulus from the server,
   indicating the minimum, maximum, and preferred sizes; the server
   responds with a suitable modulus and generator.  The exchange then
   proceeds as described in Section 2.1 above.

   This description uses the following symbols, in addition to those
   defined above:

   o  n is the size of the modulus p in bits that the client would like
      to receive from the server

   o  min and max are the minimal and maximal sizes of p in bits that
      are acceptable to the client

   1.  C sends "min || n || max" to S, indicating the minimal acceptable
       group size, the preferred size of the group, and the maximal
       group size in bits the client will accept.





Hutzelman, et al.       Expires November 7, 2005               [Page 11]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   2.  S finds a group that best matches the client's request, and sends
       "p || g" to C.

   3.  The exchange proceeds as described in Section 2.1 above,
       beginning with step 1, except that the exchange hash is computed
       as described below.

   Servers and clients SHOULD support gorups with a modulus length of k
   bits, where 1024 <= k <= 8192.  The recommended values for min and
   max are 1024 and 8192, respectively.

   This is implemented using the following messages, in addition to
   those described above:

   First, the client sends:

           byte      SSH_MSG_KEXGSS_GROUPREQ
           uint32    min, minimal size in bits of an acceptable group
           uint32    n, preferred size in bits of the group the server
                     should send
           uint32    max, maximal size in bits of an acceptable group

   The server responds with:

           byte      SSH_MSG_KEXGSS_GROUP
           mpint     p, safe prime
           mpint     g, generator for subgroup in GF(p)

   This is followed by the message exchange described above in
   Section 2.1, except that the exchange hash H is computed as the HASH
   hash of the concatenation of the following:

           string    V_C, the client's version string (CR, NL excluded)
           string    V_S, the server's version string (CR, NL excluded)
           string    I_C, the payload of the client's SSH_MSG_KEXINIT
           string    I_S, the payload of the server's SSH_MSG_KEXINIT
           string    K_S, the host key
           uint32    min, minimal size in bits of an acceptable group
           uint32    n, preferred size in bits of the group the server
                     should send
           uint32    max, maximal size in bits of an acceptable group
           mpint     p, safe prime
           mpint     g, generator for subgroup in GF(p)
           mpint     e, exchange value sent by the client
           mpint     f, exchange value sent by the server
           mpint     K, the shared secret





Hutzelman, et al.       Expires November 7, 2005               [Page 12]

Internet-Draft             SSH GSSAPI Methods                   May 2005


2.3  gss-group1-sha1-*

   Each of these methods specifies GSSAPI authenticated Diffie-Hellman
   key exchange as described in Section 2.1 with SHA-1 as HASH, and the
   group defined in section 8.1 of [SSH-TRANSPORT].  The method name for
   each method is the concatenation of the string "gss-group1-sha1-"
   with the Base64 encoding of the MD5 hash [MD5] of the ASN.1 DER
   encoding [ASN1] of the underlying GSSAPI mechanism's OID.  Base64
   encoding is described in section 6.8 of [MIME].

   Each and every such key exchange method is implicitly registered by
   this specification.  The IESG is considered to be the owner of all
   such key exchange methods; this does NOT imply that the IESG is
   considered to be the owner of the underlying GSSAPI mechanism.

2.4  gss-group14-sha1-*

   Each of these methods specifies GSSAPI authenticated Diffie-Hellman
   key exchange as described in Section 2.1 with SHA-1 as HASH, and the
   group defined in section 8.2 of [SSH-TRANSPORT].  The method name for
   each method is the concatenation of the string "gss-group14-sha1-"
   with the Base64 encoding of the MD5 hash [MD5] of the ASN.1 DER
   encoding [ASN1] of the underlying GSSAPI mechanism's OID.  Base64
   encoding is described in section 6.8 of [MIME].

   Each and every such key exchange method is implicitly registered by
   this specification.  The IESG is considered to be the owner of all
   such key exchange methods; this does NOT imply that the IESG is
   considered to be the owner of the underlying GSSAPI mechanism.

2.5  gss-gex-sha1-*

   Each of these methods specifies GSSAPI authenticated Diffie-Hellman
   key exchange as described in Section 2.2 with SHA-1 as HASH.  The
   method name for each method is the concatenation of the string "gss-
   gex-sha1-" with the Base64 encoding of the MD5 hash [MD5] of the
   ASN.1 DER encoding [ASN1] of the underlying GSSAPI mechanism's OID.
   Base64 encoding is described in section 6.8 of [MIME].

   Each and every such key exchange method is implicitly registered by
   this specification.  The IESG is considered to be the owner of all
   such key exchange methods; this does NOT imply that the IESG is
   considered to be the owner of the underlying GSSAPI mechanism.

2.6  Other GSSAPI key exchange methods

   Key exchange method names starting with "gss-" are reserved for key
   exchange methods which conform to this document; in particular, for



Hutzelman, et al.       Expires November 7, 2005               [Page 13]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   those methods which use the GSSAPI authenticated Diffie-Hellman key
   exchange algorithm described in Section 2.1, including any future
   methods which use different groups and/or hash functions.  The intent
   is that the names for any such future methods methods be defined in a
   similar manner to that used in Section 2.3.














































Hutzelman, et al.       Expires November 7, 2005               [Page 14]

Internet-Draft             SSH GSSAPI Methods                   May 2005


3.  GSSAPI User Authentication

   This section describes a general-purpose user authentication method
   based on [GSSAPI].  It is intended to be run over the SSH user
   authentication protocol [SSH-USERAUTH].

   The authentication method name for this protocol is "gssapi-with-
   mic".

3.1  GSSAPI Authentication Overview

   GSSAPI authentication must maintain a context.  Authentication begins
   when the client sends a SSH_MSG_USERAUTH_REQUEST, which specifies the
   mechanism OIDs the client supports.

   If the server supports any of the requested mechanism OIDs, the
   server sends a SSH_MSG_USERAUTH_GSSAPI_RESPONSE message containing
   the mechanism OID.

   After the client receives SSH_MSG_USERAUTH_GSSAPI_RESPONSE, the
   client and server exchange SSH_MSG_USERAUTH_GSSAPI_TOKEN packets
   until the authentication mechanism either succeeds or fails.

   If at any time during the exchange, the client sends a new
   SSH_MSG_USERAUTH_REQUEST packet, the GSSAPI context is completely
   discarded and destroyed, and any further GSSAPI authentication MUST
   restart from the beginning.

3.2  Initiating GSSAPI authentication

   The GSSAPI authentication method is initiated when the client sends a
   SSH_MSG_USERAUTH_REQUEST:

           byte      SSH_MSG_USERAUTH_REQUEST
           string    user name (in ISO-10646 UTF-8 encoding)
           string    service name (in US-ASCII)
           string    "gssapi-with-mic" (US-ASCII method name)
           uint32    n, the number of mechanism OIDs client supports
           string[n] mechanism OIDs

   Mechanism OIDs are encoded according to the ASN.1 distinguished
   encoding rules (DER), as described in [ASN1] and in section 3.1 of
   [GSSAPI].  The mechanism OIDs MUST be listed in order of preference,
   and the server must choose the first mechanism OID on the list that
   it supports.

   The client SHOULD send GSSAPI mechanism OID's only for mechanisms
   which are of the same priority, compared to non-GSSAPI authentication



Hutzelman, et al.       Expires November 7, 2005               [Page 15]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   methods.  Otherwise, authentication methods may be executed out of
   order.  Thus, the client could first send a SSH_MSG_USERAUTH_REQUEST
   for one GSSAPI mechanism, then try public key authentication, and
   then try another GSSAPI mechanism.

   If the server does not support any of the specified OIDs, the server
   MUST fail the request by sending a SSH_MSG_USERAUTH_FAILURE packet.

   The user name may be an empty string if it can be deduced from the
   results of the GSSAPI authentication.  If the user name is not empty,
   and the requested user does not exist, the server MAY disconnect, or
   MAY send a bogus list of acceptable authentications but never accept
   any.  This makes it possible for the server to avoid disclosing
   information about which accounts exist.  In any case, if the user
   does not exist, the authentication request MUST NOT be accepted.

   The client MAY at any time continue with a new
   SSH_MSG_USERAUTH_REQUEST message, in which case the server MUST
   abandon the previous authentication attempt and continue with the new
   one.

3.3  Initial server response

   The server responds to the SSH_MSG_USERAUTH_REQUEST with either a
   SSH_MSG_USERAUTH_FAILURE if none of the mechanisms are supported, or
   with SSH_MSG_USERAUTH_GSSAPI_RESPONSE as follows:

           byte        SSH_MSG_USERAUTH_GSSAPI_RESPONSE
           string      selected mechanism OID

   The mechanism OID must be one of the OIDs sent by the client in the
   SSH_MSG_USERAUTH_REQUEST packet.

3.4  GSSAPI session

   Once the mechanism OID has been selected, the client will then
   initiate an exchange of one or more pairs of
   SSH_MSG_USERAUTH_GSSAPI_TOKEN packets.  These packets contain the
   tokens produced from the 'GSS_Init_sec_context()' and
   'GSS_Accept_sec_context()' calls.  The actual number of packets
   exchanged is determined by the underlying GSSAPI mechanism.

           byte        SSH_MSG_USERAUTH_GSSAPI_TOKEN
           string      data returned from either GSS_Init_sec_context()
                       or GSS_Accept_sec_context()

   If an error occurs during this exchange on server side, the server
   can terminate the method by sending a SSH_MSG_USERAUTH_FAILURE



Hutzelman, et al.       Expires November 7, 2005               [Page 16]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   packet.  If an error occurs on client side, the client can terminate
   the method by sending a new SSH_MSG_USERAUTH_REQUEST packet.

   When calling GSS_Init_sec_context(), the client MUST set the the
   integ_req_flag to "true" to request that per-message integrity
   protection be supported for this context.  In addition, the
   deleg_req_flag MAY be set to "true" to request access delegation, if
   requested by the user.

   Since the user authentication process by its nature authenticates
   only the client, the setting of the mutual_req_flag is not needed for
   this process.  This flag SHOULD be set to "false".

   Since the user authentication process will involve the exchange of
   only a single token once the context has been established, it is not
   necessary that the context support detection of replayed or out-of-
   sequence tokens.  Thus, the setting of the replay_det_req_flag and
   sequence_req_flag are not needed for this process.  These flags
   SHOULD be set to "false".

   Additional SSH_MSG_USERAUTH_GSSAPI_TOKEN messages are sent if and
   only if the calls to the GSSAPI routines produce send tokens of non-
   zero length.

   Any major status code other than GSS_S_COMPLETE or
   GSS_S_CONTINUE_NEEDED SHOULD be a failure.

3.5  Binding Encryption Keys

   In some cases, it is possible to obtain improved security by allowing
   access only if the client sends a valid message integrity code (MIC)
   binding the GSSAPI context to the keys used for encryption and
   integrity protection of the SSH session.  With this extra level of
   protection, a "man-in-the-middle" attacker who has convinced a client
   of his authenticity cannot then relay user authentication messages
   between the real client and server, thus gaining access to the real
   server.  This additional protection is available when the negotiated
   GSSAPI context supports per-message integrity protection, as
   indicated by the setting of the integ_avail flag on successful return
   from GSS_Init_sec_context() or GSS_Accept_sec_context().

   When the client's call to GSS_Init_sec_context() returns
   GSS_S_COMPLETE with the integ_avail flag set, the client MUST
   conclude the user authentication exchange by sending the following
   message:

           byte      SSH_MSG_USERAUTH_GSSAPI_MIC
           string    MIC



Hutzelman, et al.       Expires November 7, 2005               [Page 17]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   This message MUST be sent only if GSS_Init_sec_context() returned
   GSS_S_COMPLETE.  If a token is also returned then the
   SSH_MSG_USERAUTH_GSSAPI_TOKEN message MUST be sent before this one.

   The contents of the MIC field are obtained by calling GSS_GetMIC over
   the following, using the GSSAPI context which was just established:

           string    session identifier
           byte      SSH_MSG_USERAUTH_REQUEST
           string    user name
           string    service
           string    "gssapi-with-mic"

   If this message is received by the server before the GSSAPI context
   is fully established, the server MUST fail the authentication.

   If this message is received by the server when the negotiated GSSAPI
   context does not support per-message integrity protection, the server
   MUST fail the authentication.

3.6  Client acknowledgement

   Some servers may wish to permit user authentication to proceed even
   when the negotitated GSSAPI context does not support per-message
   integrity protection.  In such cases, it is possible for the server
   to successfully complete the GSSAPI method, while the client's last
   call to GSS_Init_sec_context fails.  If the server simply assumed
   success on the part of the client and completed the authentication
   service, it is possible that the client would fail to complete the
   authentication method, but not be able to retry other methods because
   the server had already moved on.  To protect against this, a final
   message is sent by the client to indicate it has completed
   authentication.

   When the client's call to GSS_Init_sec_context() returns
   GSS_S_COMPLETE with the integ_avail flag not set, the client MUST
   conclude the user authentication exchange by sending the following
   message:

           byte      SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE

   This message MUST be sent only if GSS_Init_sec_context() returned
   GSS_S_COMPLETE.  If a token is also returned then the
   SSH_MSG_USERAUTH_GSSAPI_TOKEN message MUST be sent before this one.

   If this message is received by the server before the GSSAPI context
   is fully established, the server MUST fail the authentication.




Hutzelman, et al.       Expires November 7, 2005               [Page 18]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   If this message is received by the server when the negotiated GSSAPI
   context supports per-message integrity protection, the server MUST
   fail the authentication.

   It is a site policy descision for the server whether or not to permit
   authentication using GSSAPI mechanisms and/or contexts which do not
   support per-message integrity protection.  The server MAY fail the
   otherwise valid gssapi-with-mic authentication if per-message
   integrity protection is not supported.

3.7  Completion

   As with all SSH authentication methods, successful completion is
   indicated by a SSH_MSG_USERAUTH_SUCCESS if no other authentication is
   required, or a SSH_MSG_USERAUTH_FAILURE with the partial success flag
   set if the server requires further authentication.  This packet
   should be sent immediately following receipt of the the
   SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE packet.

3.8  Error Status

   In the event a GSSAPI error occurs on the server during context
   establishment, the server MAY send the following message to inform
   the client of the details of the error before sending a
   SSH_MSG_USERAUTH_FAILURE message:

           byte      SSH_MSG_USERAUTH_GSSAPI_ERROR
           uint32    major_status
           uint32    minor_status
           string    message
           string    language tag

   The message text MUST be encoded in the UTF-8 encoding described in
   [UTF8].  Language tags are those described in [LANGTAG].  Note that
   the message text may contain multiple lines separated by carriage
   return-line feed (CRLF) sequences.  Application developers should
   take this into account when displaying these messages.

   Clients receiving this message MAY log the error details and/or
   report them to the user.  Any server sending this message MUST ignore
   any SSH_MSG_UNIMPLEMENTED sent by the client in response.










Hutzelman, et al.       Expires November 7, 2005               [Page 19]

Internet-Draft             SSH GSSAPI Methods                   May 2005


3.9  Error Token

   In the event that, during context establishment, a client's call to
   GSS_Init_sec_context or a server's call to GSS_Accept_sec_context
   returns a token along with an error status, the resulting "error
   token" SHOULD be sent to the peer using the following message:

           byte        SSH_MSG_USERAUTH_GSSAPI_ERRTOK
           string      error token

   This message implies that the authentication is about to fail, and is
   defined to allow the error token to be communicated without losing
   synchronization.

   When a server sends this message, it MUST be followed by a
   SSH_MSG_USERAUTH_FAILURE message, which is to be interpreted as
   applying to the same authentication request.  A client receiving this
   message SHOULD wait for the following SSH_MSG_USERAUTH_FAILURE
   message before beginning another authentication attempt.

   When a client sends this message, it MUST be followed by a new
   authentication request or by terminating the connection.  A server
   receiving this message MUST NOT send a SSH_MSG_USERAUTH_FAILURE in
   reply, since such a message might otherwise be interpreted by a
   client as a response to the following authentication sequence.

   Any server sending this message MUST ignore any SSH_MSG_UNIMPLEMENTED
   sent by the client in response.  If a server sends both this message
   and an SSH_MSG_USERAUTH_GSSAPI_ERROR message, the
   SSH_MSG_USERAUTH_GSSAPI_ERROR message MUST be sent first, to allow
   the client to store and/or display the error status before processing
   the error token.



















Hutzelman, et al.       Expires November 7, 2005               [Page 20]

Internet-Draft             SSH GSSAPI Methods                   May 2005


4.  Authentication using GSSAPI Key Exchange

   This section describes a user authentication method building on the
   framework described in [SSH-USERAUTH].  This method performs user
   authentication by making use of an existing GSSAPI context
   established during key exchange.

   The authentication method name for this protocol is "gssapi-keyex".

   This method may be used only if the initial key exchange was
   performed using a GSSAPI-based key exchange method defined in
   accordance with Section 2.  The GSSAPI context used with this method
   is always that established during an initial GSSAPI-based key
   exchange.  Any context established during key exchange for the
   purpose of rekeying MUST NOT be used with this method.

   The server SHOULD include this user authentication method in the list
   of methods that can continue (in a SSH_MSG_USERAUTH_FAILURE) if the
   initial key exchange was performed using a GSSAPI-based key exchange
   method and provides information about the user's identity which is
   useful to the server.  It MUST NOT include this method if the initial
   key exchange was not performed using a GSSAPI-based key exchange
   method defined in accordance with Section 2.

   The client SHOULD attempt to use this method if it is advertised by
   the server, initial key exchange was performed using a GSSAPI-based
   key exchange method, and this method has already been tried.  The
   client SHOULD NOT try this method more than once per session.  It
   MUST NOT try this method if initial key exchange was not performed
   using a GSSAPI-based key exchange method defined in accordance with
   Section 2.

   If a server receives a request for this method when initial key
   exchange was not performed using a GSSAPI-based key exchange method
   defined in accordance with Section 2, it MUST return
   SSH_MSG_USERAUTH_FAILURE.

   This method is defined as a single message:

           byte        SSH_MSG_USERAUTH_REQUEST
           string      user name
           string      service
           string      "gssapi-keyex"
           string      MIC







Hutzelman, et al.       Expires November 7, 2005               [Page 21]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   The contents of the MIC field are obtained by calling GSS_GetMIC over
   the following, using the GSSAPI context which was established during
   initial key exchange:

           string      session identifier
           byte        SSH_MSG_USERAUTH_REQUEST
           string      user name
           string      service
           string      "gssapi-keyex"

   Upon receiving this message when initial key exchange was performed
   using a GSSAPI-based key exchange method, the server uses
   GSS_VerifyMIC() to verify that the MIC received is valid.  If the MIC
   is not valid, the user authentication fails, and the server MUST
   return SSH_MSG_USERAUTH_FAILURE.

   If the MIC is valid and the server is satisfied as to the user's
   credentials, it MAY return either SSH_MSG_USERAUTH_SUCCESS, or
   SSH_MSG_USERAUTH_FAILURE with the partial success flag set, depending
   on whether additional authentications are needed.































Hutzelman, et al.       Expires November 7, 2005               [Page 22]

Internet-Draft             SSH GSSAPI Methods                   May 2005


5.  Null Host Key Algorithm

   The "null" host key algorithm has no associated host key material,
   and provides neither signature nor encryption algorithms.  Thus, it
   can be used only with key exchange methods that do not require any
   public-key operations and do not require the use of host public key
   material.  The key exchange methods described in section 1 of this
   document are examples of such methods.

   This algorithm is used when, as a matter of configuration, the host
   does not have or does not wish to use a public key.  For example, it
   can be used when the administrator has decided as a matter of policy
   to require that all key exchanges be authenticated using Kerberos
   [KRB5], and thus the only permitted key exchange method is the
   GSSAPI-authenticated Diffie-Hellman exchange described above, with
   Kerberos V5 as the underlying GSSAPI mechanism.  In such a
   configuration, the server implementation supports the "ssh-dss" key
   algorithm (as required by [SSH-TRANSPORT]), but could be prohibited
   by configuration from using it.  In this situation, the server needs
   some key exchange algorithm to advertise; the "null" algorithm fills
   this purpose.

   Note that the use of the "null" algorithm in this way means that the
   server will not be able to interoperate with clients which do not
   support this algorithm.  This is not a significant problem, since in
   the configuration described, it will also be unable to interoperate
   with implementations that do not support the GSSAPI-authenticated key
   exchange and Kerberos.

   Any implementation supporting at least one key exchange method which
   conforms to section 1 of this document MUST also support the "null"
   host key algorithm.  Servers MUST NOT advertise the "null" host key
   algorithm unless it is the only algorithm advertised.


















Hutzelman, et al.       Expires November 7, 2005               [Page 23]

Internet-Draft             SSH GSSAPI Methods                   May 2005


6.  Summary of Message Numbers

   The following message numbers have been defined for use with GSSAPI-
   based key exchange methods:

          #define SSH_MSG_KEXGSS_INIT                       30
          #define SSH_MSG_KEXGSS_CONTINUE                   31
          #define SSH_MSG_KEXGSS_COMPLETE                   32
          #define SSH_MSG_KEXGSS_HOSTKEY                    33
          #define SSH_MSG_KEXGSS_ERROR                      34
          #define SSH_MSG_KEXGSS_GROUPREQ                   40
          #define SSH_MSG_KEXGSS_GROUP                      41

   The numbers 30-49 are specific to key exchange and may be redefined
   by other kex methods.

   The following message numbers have been defined for use with the
   'gssapi' user authentication method:

          #define SSH_MSG_USERAUTH_GSSAPI_RESPONSE          60
          #define SSH_MSG_USERAUTH_GSSAPI_TOKEN             61
          #define SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE 63
          #define SSH_MSG_USERAUTH_GSSAPI_ERROR             64
          #define SSH_MSG_USERAUTH_GSSAPI_ERRTOK            65
          #define SSH_MSG_USERAUTH_GSSAPI_MIC               66

   The numbers 60-79 are specific to user authentication and may be
   redefined by other user auth methods.  Note that in the method
   described in this document, message number 62 is unused.






















Hutzelman, et al.       Expires November 7, 2005               [Page 24]

Internet-Draft             SSH GSSAPI Methods                   May 2005


7.  GSSAPI Considerations

7.1  Naming Conventions

   In order to establish a GSSAPI security context, the SSH client needs
   to determine the appropriate targ_name to use in identifying the
   server when calling GSS_Init_sec_context.  For this purpose, the
   GSSAPI mechanism-independent name form for host-based services is
   used, as described in section 4.1 of [GSSAPI].

   In particular, the targ_name to pass to GSS_Init_sec_context is
   obtained by calling GSS_Import_name with an input_name_type of
   GSS_C_NT_HOSTBASED_SERVICE, and an input_name_string consisting of
   the string "host@" concatenated with the hostname of the SSH server.

7.2  Channel Bindings

   This document recommends that channel bindings SHOULD NOT be
   specified in the calls during context establishment.  This document
   does not specify any standard data to be used as channel bindings and
   the use of network addresses as channel bindings may break SSH in
   environments where it is most useful.

7.3  SPNEGO

   The use of the Simple and Protected GSS-API Negotiation Mechanism
   [SPNEGO] in conjunction with the authentication and key exchange
   methods described in this document is both unnecessary and
   undesirable.  As a result, mechanisms conforming to this document
   MUST NOT use SPNEGO as the underlying GSSAPI mechanism.

   Since SSH performs its own negotiation of authentication and key
   exchange methods, the negotiation capability of SPNEGO alone does not
   provide any added benefit.  In fact, as described below, it has the
   potential to result in the use of a weaker method than desired.

   Normally, SPNEGO provides the added benefit of protecting the GSSAPI
   mechanism negotiation.  It does this by having the server compute a
   MIC of the list of mechanisms proposed by the client, and then
   checking that value at the client.  In the case of key exchange, this
   protection is not needed because the key exchange methods described
   here already perform an equivalent operation; namely, they generate a
   MIC of the SSH exchange hash, which is a hash of several items
   including the lists of key exchange mechanisms supported by both
   sides.  In the case of user authentication, the protection is not
   needed because the negotiation occurs over a secure channel, and the
   host's identity has already been proved to the user.




Hutzelman, et al.       Expires November 7, 2005               [Page 25]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   The use of SPNEGO combined with GSSAPI mechanisms used without SPNEGO
   can lead to interoperability problems.  For example, a client which
   supports key exchange using the Kerberos V5 GSSAPI mechanism [KRB5-
   GSS] only underneath SPNEGO will not interoperate with a server which
   supports key exchange only using the Kerberos V5 GSSAPI mechanism
   directly.  As a result, allowing GSSAPI mechanisms to be used both
   with and without SPNEGO is undesirable.

   If a client's policy is to first prefer GSSAPI-based key exchange
   method X, then non-GSSAPI method Y, then GSSAPI-based method Z, and
   if a server supports mechanisms Y and Z but not X, then an attempt to
   use SPNEGO to negotiate a GSSAPI mechanism might result in the use of
   method Z when method Y would have been preferable.  As a result, the
   use of SPNEGO could result in the subversion of the negotiation
   algorithm for key exchange methods as described in section 7.1 of
   [SSH-TRANSPORT] and/or the negotiation algorithm for user
   authentication methods as described in [SSH-USERAUTH].


































Hutzelman, et al.       Expires November 7, 2005               [Page 26]

Internet-Draft             SSH GSSAPI Methods                   May 2005


8.  IANA Considerations

   Consistent with section 8 of [SSH-ARCH] and section 4.6 of [SSH-
   NUMBERS], this document makes the following registrations:

      The family of SSH key exchange method names beginning with "gss-
      group1-sha1-" and not containing the at-sign ('@'), to name the
      key exchange methods defined in Section 2.3.

      The family of SSH key exchange method names beginning with "gss-
      gex-sha1-" and not containing the at-sign ('@'), to name the key
      exchange methods defined in Section 2.5.

      All other SSH key exchange method names beginning with "gss-" and
      not containing the at-sign ('@'), to be reserved for future key
      exchange methods defined in conformance with this document, as
      noted in Section 2.6.

      The SSH host public key algorithm name "null", to name the NULL
      host key algorithm defined in Section 5.

      The SSH user authentication method name "gssapi-with-mic", to name
      the GSSAPI user authentication method defined in Section 3.

      The SSH user authentication method name "gssapi-keyex", to name
      the GSSAPI user authentication method defined in Section 4.

      The SSH user authentication method name "gssapi" is to be
      reserved, in order to avoid conflicts with implementations
      supporting an earlier version of this specification.

      The SSH user authentication method name "external-keyx" is to be
      reserved, in order to avoid conflicts with implementations
      supporting an earlier version of this specification.

   This document creates no new registries.















Hutzelman, et al.       Expires November 7, 2005               [Page 27]

Internet-Draft             SSH GSSAPI Methods                   May 2005


9.  Security Considerations

   This document describes authentication and key-exchange protocols.
   As such, security considerations are discussed throughout.

   This protocol depends on the SSH protocol itself, the GSSAPI, any
   underlying GSSAPI mechanisms which are used, and any protocols on
   which such mechanisms might depend.  Each of these components plays a
   part in the security of the resulting connection, and each will have
   its own security considerations.

   The key exchange method described in section 1 of this document
   depends on the underlying GSSAPI mechanism to provide both mutual
   authentication and per-message integrity services.  If either of
   these features is not supported by a particular GSSAPI mechanism, or
   by a particular implementation of a GSSAPI mechanism, then the key
   exchange is not secure and MUST fail.

   In order for the "external-keyx" user authentication method to be
   used, it MUST have access to user authentication information obtained
   as a side-effect of the key exchange.  If this information is
   unavailable, the authentication MUST fail.

   Revealing information about the reason for an authentication failure
   may be considered by some sites to be an unacceptable security risk
   for a production environment.  However, having that information
   available can be invaluable for debugging purposes.  Thus, it is
   RECOMMENDED that implementations provide a means for controlling, as
   a matter of policy, whether to send SSH_MSG_USERAUTH_GSSAPI_ERROR,
   SSH_MSG_USERAUTH_GSSAPI_ERRTOK, and SSH_MSG_KEXGSS_ERROR messages,
   and SSH_MSG_KEXGEE_CONTINUE messages containing a GSSAPI error token.




















Hutzelman, et al.       Expires November 7, 2005               [Page 28]

Internet-Draft             SSH GSSAPI Methods                   May 2005


10.  Acknowledgements

   The authors would like to thank the following individuals for their
   invaluable assistance and contributions to this document:

   o  Sam Hartman

   o  Love Hornquist-Astrand

   o  Joel N. Weber II

   o  Simon Wilkinson

   o  Nicolas Williams

   Much of the text describing DH group exchnage was borrowed from
   [GROUP-EXCHANGE], by Markus Friedl, Niels Provos, and William A.
   Simpson.

































Hutzelman, et al.       Expires November 7, 2005               [Page 29]

Internet-Draft             SSH GSSAPI Methods                   May 2005


11.  Changes the last version

   This section lists important changes since the previous version of
   this internet-draft.  This section should be removed at the time of
   publication of this document as an RFC.

   o  Added text about not giving loud warnings when getting a new host
      key from an already-known host via GSSAPI.

   o  Added gss-group14-sha1-*

   o  Updated references to the ssh core documents.

   o  Converted to RFC3978 boilerplate.





































Hutzelman, et al.       Expires November 7, 2005               [Page 30]

Internet-Draft             SSH GSSAPI Methods                   May 2005


12.  References

12.1  Normative References

   [ASN1]     ISO/IEC, "ASN.1 Encoding Rules: Specification of Basic
              Encoding Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)", ITU-T
              Recommendation X.690 (1997), ISO/IEC 8825-1:1998,
              November 1998.

   [GROUP-EXCHANGE]
              Friedl, M., Provos, N., and W. Simpson, "Diffie-Hellman
              Group Exchange for the SSH Transport Layer Protocol",
              draft-ietf-secsh-dh-group-exchange-04.txt (work in
              progress), July 2003.

   [GSSAPI]   Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000.

   [KEYWORDS]
              Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", RFC 2119, BCP 14, March 1997.

   [LANGTAG]  Alvestrand, H., "Tags for the Identification of
              Languages", RFC 3066, BCP 47, January 2001.

   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              April 1992.

   [MIME]     Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [SSH-ARCH]
              Ylonen, T. and C. Lonvick, "SSH Protocol Architecture",
              draft-ietf-secsh-architecture-22.txt (work in progress),
              March 2005.

   [SSH-CONNECT]
              Ylonen, T. and C. Lonvick, "SSH Connection Protocol",
              draft-ietf-secsh-connect-25.txt (work in progress),
              March 2005.

   [SSH-NUMBERS]
              Lehtinen, S. and C. Lonvick, "SSH Connection Protocol",
              draft-ietf-secsh-assignednumbers-12.txt (work in
              progress), March 2005.




Hutzelman, et al.       Expires November 7, 2005               [Page 31]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   [SSH-TRANSPORT]
              Ylonen, T. and C. Lonvick, "SSH Transport Layer Protocol",
              draft-ietf-secsh-transport-24.txt (work in progress),
              March 2005.

   [SSH-USERAUTH]
              Ylonen, T. and C. Lonvick, "SSH Authentication Protocol",
              draft-ietf-secsh-userauth-27.txt (work in progress),
              March 2005.

   [UTF8]     Yergeau, F., "UTF-8, a transformation format of ISO
              10646", RFC 3629, STD 63, November 2003.

12.2  Non-Normative References

   [KRB5]     Kohl, J. and C. Neuman, "The Kerberos Network
              Authentication Service (V5)", RFC 1510, September 1993.

   [KRB5-GSS]
              Linn, J., "The Kerberos Version 5 GSS-API Mechanism",
              RFC 1964, June 1996.

   [SPNEGO]   Baize, E. and D. Pinkas, "The Simple and Protected GSS-API
              Negotiation Mechanism", RFC 2478, December 1998.


Authors' Addresses

   Jeffrey Hutzelman
   Carnegie Mellon University
   5000 Forbes Ave
   Pittsburgh, PA  15213
   US

   Phone: +1 412 268 7225
   Email: jhutz+@cmu.edu
   URI:   http://www.cs.cmu.edu/~jhutz/


   Joseph Salowey
   Cisco Systems
   2901 Third Avenue
   Seattle, WA  98121
   US

   Phone: +1 206 256 3380
   Email: jsalowey@cisco.com




Hutzelman, et al.       Expires November 7, 2005               [Page 32]

Internet-Draft             SSH GSSAPI Methods                   May 2005


   Joseph Galbraith
   Van Dyke Technologies, Inc.
   4848 Tramway Ridge Dr. NE
   Suite 101
   Albuquerque, NM  87111
   US

   Email: galb@vandyke.com


   Von Welch
   University of Chicago & Argonne National Laboratory
   Distributed Systems Laboratory
   701 E. Washington
   Urbana, IL  61801
   US

   Email: welch@mcs.anl.gov

































Hutzelman, et al.       Expires November 7, 2005               [Page 33]

Internet-Draft             SSH GSSAPI Methods                   May 2005


Intellectual Property Statement

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Copyright Statement

   Copyright (C) The Internet Society (2005).  This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Acknowledgment

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Hutzelman, et al.       Expires November 7, 2005               [Page 34]

