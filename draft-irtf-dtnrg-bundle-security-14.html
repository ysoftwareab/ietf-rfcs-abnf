<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Bundle Security Protocol Specification</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Bundle Security Protocol Specification">
<meta name="keywords" content="RFC, Request for Comments, I-D, Internet-Draft, DTN, Delay-Tolerant Networking, Disruption-Tolerant Networking">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">DTN Research Group</td><td class="header">S. Symington</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">The MITRE Corporation</td></tr>
<tr><td class="header">Expires: July 31, 2010</td><td class="header">S. Farrell</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Trinity College Dublin</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">H. Weiss</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Lovell</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">SPARTA, Inc.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">January 27, 2010</td></tr>
</table></td></tr></table>
<h1><br />Bundle Security Protocol Specification<br />draft-irtf-dtnrg-bundle-security-14</h1>

<h3>Abstract</h3>

<p>This document defines the bundle security protocol, which provides data 
integrity and confidentiality services for the bundle protocol. 
Separate capabilities are provided to protect the bundle payload and 
additional data that may be included within the bundle. We also describe 
various bundle security considerations including policy options.  
</p>
<p>This document is a product of the Delay Tolerant Networking Research 
Group and has been reviewed by that group.  No objections to its 
publication as an RFC were raised. 
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on July 31, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Related Documents<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Terminology<br />
<a href="#Headers">2.</a>&nbsp;
Security Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#asb">2.1.</a>&nbsp;
Abstract Security Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.BAB">2.2.</a>&nbsp;
Bundle Authentication Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.PIB">2.3.</a>&nbsp;
Payload Integrity Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.PCB">2.4.</a>&nbsp;
Payload Confidentiality Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.ESB">2.5.</a>&nbsp;
Extension Security Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.PRF">2.6.</a>&nbsp;
Parameters and Result Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.KT">2.7.</a>&nbsp;
Key Transport<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">2.8.</a>&nbsp;
PIB and PCB combinations<br />
<a href="#anchor5">3.</a>&nbsp;
Security Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#secPEP">3.1.</a>&nbsp;
Nodes as policy enforcement points<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.stack">3.2.</a>&nbsp;
Processing order of security blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.sz">3.3.</a>&nbsp;
Security Regions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#C14N">3.4.</a>&nbsp;
Canonicalisation of bundles<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#srcPCB">3.5.</a>&nbsp;
Endpoint ID confidentiality<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.bon">3.6.</a>&nbsp;
Bundles received from other nodes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.7.</a>&nbsp;
The At-Most-Once-Delivery Option<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frag">3.8.</a>&nbsp;
Bundle Fragmentation and Reassembly<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reactive">3.9.</a>&nbsp;
Reactive fragmentation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.10.</a>&nbsp;
Attack Model<br />
<a href="#ciphersuites">4.</a>&nbsp;
Mandatory Ciphersuites<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#BABhmac">4.1.</a>&nbsp;
BAB-HMAC<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PIBrsasha">4.2.</a>&nbsp;
PIB-RSA-SHA256<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rsaaes">4.3.</a>&nbsp;
PCB-RSA-AES128-PAYLOAD-PIB-PCB<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ESBrsaaes">4.4.</a>&nbsp;
ESB-RSA-AES128-EXT<br />
<a href="#sec.keymgmt">5.</a>&nbsp;
Key Management<br />
<a href="#sec.Defaults">6.</a>&nbsp;
Default Security Policy<br />
<a href="#anchor8">7.</a>&nbsp;
Security Considerations<br />
<a href="#anchor9">8.</a>&nbsp;
Conformance<br />
<a href="#anchor10">9.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document 
are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S. and J. Reynolds, &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; October&nbsp;1997.</span><span>)</span></a>.
</p>
<p>This document defines security features for the bundle protocol 
<a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> intended for use in delay tolerant networks, 
in order to provide DTN security services.
</p>
<p>The bundle protocol is used in DTNs which overlay multiple networks, some of 
which may be challenged by limitations such as intermittent and possibly 
unpredictable loss of connectivity, long or variable delay, asymmetric data 
rates, and high error rates. The purpose of the bundle protocol is to support 
interoperability across such stressed networks. The bundle protocol is layered 
on top of underlay-network-specific convergence layers, on top of 
network-specific lower layers, to enable an application in one network to 
communicate with an application in another network, both of which are spanned 
by the DTN.  
</p>
<p>Security will be important for the bundle protocol. The stressed environment 
of the underlying networks over which the bundle protocol will operate makes it 
important for the DTN to be protected from unauthorized use, and this stressed 
environment poses unique challenges for the mechanisms needed to secure the 
bundle protocol. Furthermore, DTNs may very likely be deployed in environments 
where a portion of the network might become compromised, posing the usual 
security challenges related to confidentiality, integrity and availability.
</p>
<p>Different security processing applies to the payload and extension 
blocks that may accompany it in a bundle, and different rules apply to 
various extension blocks.
</p>
<p>This document describes both the base Bundle Security Protocol (BSP) and 
a set of mandatory ciphersuites. A ciphersuite is a specific collection of 
various cryptographic algorithms and implementation rules that are used 
together to provide certain security services.
</p>
<p>The Bundle Security Protocol applies, by definition, only to those nodes 
that implement it, known as "security-aware" nodes. There MAY be other nodes 
in the DTN that do not implement BSP. All nodes can interoperate with the 
exception that BSP security operations can only happen at security-aware nodes. 
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Related Documents</h3>

<p>This document is best read and understood within the context of the 
following other DTN documents: 
</p>
<blockquote class="text">
<p>The Delay-Tolerant Network Architecture <a class='info' href='#DTNarch'>[DTNarch]<span> (</span><span class='info'>Cerf, V., Burleigh, S., Durst, R., Fall, K., Hooke, A., Scott, K., Torgerson, L., and H. Weiss, &ldquo;Delay-Tolerant Network Architecture,&rdquo; April&nbsp;2007.</span><span>)</span></a> 
defines the architecture for delay-tolerant networks, but does not 
discuss security at any length.  
</p>
<p>The DTN Bundle Protocol <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> defines the format 
and processing of the blocks used to implement the bundle protocol, 
excluding the security-specific blocks defined here.  
</p>
</blockquote>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Terminology</h3>

<p> We introduce the following terminology for purposes of clarity: 
</p>
<blockquote class="text">
<p>source - the bundle node from which a bundle originates
</p>
<p>destination - the bundle node to which a bundle is ultimately destined
</p>
<p>forwarder - the bundle node that forwarded the bundle on its most recent 
hop
</p>
<p>intermediate receiver or "next hop" - the neighboring bundle node to which a forwarder 
forwards a bundle.
</p>
<p>path - the ordered sequence of nodes through which a bundle passes on its way from 
source to destination
</p>
</blockquote>
<p>In the figure below, which is adapted from figure 1 in the Bundle Protocol Specification, 
four bundle nodes (denoted BN1, BN2, BN3, and BN4) reside above 
some transport layer(s). Three distinct transport and network protocols 
(denoted T1/N1, T2/N2, and T3/N3) are also shown.
</p><br /><hr class="insert" />
<a name="protocolStack"></a>

<p> 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>


+---------v-|   +-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v-+     +-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v-+   +-^---------+
| BN1     v |   | ^   BN2   v |     | ^   BN3   v |   | ^  BN4    |
+---------v-+   +-^---------v-+     +-^---------v-+   +-^---------+
| T1      v |   + ^  T1/T2  v |     + ^  T2/T3  v |   | ^  T3     |
+---------v-+   +-^---------v-+     +-^---------v +   +-^---------+
| N1      v |   | ^  N1/N2  v |     | ^  N2/N3  v |   | ^  N3     |
+---------v-+   +-^---------v +     +-^---------v-+   +-^---------+
|         &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;^         &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;^         &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;^         |
+-----------+   +------------+      +-------------+   +-----------+
|                     |                    |                      |
|&lt;--  An Internet ---&gt;|                    |&lt;--- An Internet  ---&gt;|
|                     |                    |                      |

BN = "Bundle Node" as defined in the Bundle Protocol Specification
</pre></div>
<p> 
Bundle Nodes Sit at the Application layer of the Internet Model. 

</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Bundle node BN1 originates a bundle that it forwards to BN2. BN2 forwards 
the bundle to BN3, and BN3 forwards the bundle to BN4. BN1 is the source of the 
bundle and BN4 is the destination of the bundle. BN1 is the first forwarder, and 
BN2 is the first intermediate receiver; BN2 then becomes the forwarder, and BN3 the 
intermediate receiver; BN3 then becomes the last forwarder, and BN4 the last intermediate 
receiver, as well as the destination.  
</p>
<p>If node BN2 originates a bundle (for example, a bundle 
status report or a custodial signal), which is then forwarded on to BN3, and 
then to BN4, then BN2 is the source of the bundle (as well as being the first 
forwarder of the bundle) and BN4 is the destination of the bundle (as well as 
being the final intermediate receiver).  
</p>
<p> 
We introduce the following security-specific DTN terminology: 

</p>
<blockquote class="text">
<p>security-source - a bundle node that adds a security block to a bundle
</p>
<p>security-destination - a bundle node that processes a security block of a 
bundle
</p>
<p>security path - the ordered sequence of security-aware nodes through which a
bundle passes on its way from the security-source to the security-destination
</p>
</blockquote>
<p>Referring to <a class='info' href='#protocolStack'>Figure&nbsp;1</a>  again:
</p>
<p>If the bundle that originates at BN1 as source is given a security block by BN1, 
then BN1 is the security-source of this bundle with 
respect to that security block, as well as being the source of the bundle.  
</p>
<p>If the bundle that originates at BN1 as source is given a security block by BN2, 
then BN2 is the security-source of this bundle with 
respect to that security block, even though BN1 is the source.  
</p>
<p>If the bundle that originates at BN1 as source is given a security block 
by BN1 that is intended to be processed by BN3, then BN1 is the 
security-source and BN3 is the security destination with respect to this security 
block. The security path for this block is BN1 to BN3. 
</p>
<p>A bundle MAY have multiple security blocks. The security-source of a bundle with 
respect to a given security block in the bundle MAY be the same as or different from 
the security-source of the bundle with respect to a different security block in the bundle. 
Similarly, the security-destination of a bundle with respect to each of that bundle's 
security blocks MAY be the same or different. Therefore the security paths for 
various blocks MAY be and often will be different.
</p>
<p>If the bundle that originates at BN1 as source is given a security block 
by BN1 that is intended to be processed by BN3, and BN2 adds a security block 
with security-destination BN4, the security paths for the two blocks overlap 
but not completely. This problem is discussed further in 
<a class='info' href='#sec.sz'>Section&nbsp;3.3<span> (</span><span class='info'>Security Regions</span><span>)</span></a>. 
</p>
<p>As required in <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>, forwarding nodes MUST transmit blocks in 
a bundle in the same order in which they were received. 
This requirement applies to all DTN nodes, not just ones which implement security 
processing. Blocks in a bundle MAY be added or deleted according to the applicable 
specification, but those blocks which are both received and transmitted MUST be 
transmitted in the same order that they were received.
</p>
<p>If a node is not security-aware then it forwards the security blocks in the 
bundle unchanged unless the bundle's block processing flags specify otherwise. 
If a network has some nodes that are not security-aware then the block processing 
flags SHOULD be set such that security blocks are not discarded at those nodes 
solely because they can not be processed there. Except for this, 
the non-security-aware nodes are transparent relay points and are 
invisible as far as security processing is concerned. 
</p>
<p>The block sequence also indicates the order in which certain significant actions 
have affected the bundle, and therefore the sequence in which actions MUST occur 
in order to produce the bundle at its destination. 
</p>
<a name="Headers"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Security Blocks</h3>

<p>There are four types of security block that MAY be included in a bundle. 
These are the Bundle Authentication Block (BAB), the Payload Integrity Block (PIB), 
the Payload Confidentiality Block (PCB) and the Extension Security Block (ESB).
</p>
<blockquote class="text">
<p>The BAB is used to assure the authenticity and integrity of the bundle 
along a single hop from forwarder to intermediate receiver. 
Since security blocks are only processed at security-aware nodes, 
a "single hop" from a security-aware forwarder to the next security-aware 
intermediate receiver might be more than one actual hop. This situation 
is discussed further below <a class='info' href='#sec.BAB'>Section&nbsp;2.2<span> (</span><span class='info'>Bundle Authentication Block</span><span>)</span></a>.
</p>
<p>The PIB is used to assure the authenticity and integrity of the payload from 
the PIB security-source, which creates the PIB, to the PIB security-destination, 
which verifies the PIB authenticator.  The authentication information in the 
PIB MAY (if the ciphersuite allows) be verified by any node in between 
the PIB security-source and the PIB security-destination that has access to the 
cryptographic keys and revocation status information required to do so.  
</p>
<p>Since a BAB protects a bundle on a "hop-by-hop" basis and other security 
blocks MAY be protecting over several hops or end-to-end, whenever both are 
present the BAB MUST form the "outer" layer of protection - that is, the 
BAB MUST always be calculated and added to the bundle after all other 
security blocks have been calculated and added to the bundle.
</p>
<p>The PCB indicates that the payload has been encrypted, in whole or in part, 
at the PCB security-source in order to protect the bundle content while 
in transit to the PCB security-destination.
</p>
<p>PIB and PCB protect the payload and are regarded as "payload-related" 
for purposes of the security discussion in this document. Other blocks are 
regarded as "non-payload" blocks. Of course, the primary block is 
unique and has separate rules.
</p>
<p>The ESB provides security for non-payload blocks in a bundle. 
ESB therefore is not applied to PIB or PCBs, and of course is not 
appropriate for either the payload block or primary block.
</p>
</blockquote>
<p>Each of the security blocks uses the Canonical Bundle Block Format as 
defined in the Bundle Protocol Specification. That is, each security block is 
comprised of the following elements:
</p>
<blockquote class="text">
<p>- Block type code
</p>
<p>- Block processing control flags
</p>
<p>- Block EID reference list (optional)
</p>
<p>- Block data length
</p>
<p>- Block-type-specific data fields
</p>
</blockquote>
<p> Since the four security blocks have most fields in common, we can shorten 
the description of the Block-type-specific data fields of each security block 
if we first define an abstract security block (ASB) and then specify each of 
the real blocks in terms of the fields which are present/absent in an ASB. 
Note that no bundle ever contains an actual ASB, which is simply a specification 
artifact.
</p>
<a name="asb"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Abstract Security Block</h3>

<p>An ASB consists of the following mandatory and optional fields:
</p>
<blockquote class="text">
<p>- Block-type code (one byte) - as in all bundle protocol blocks except the 
primary bundle block. The block types codes for the security blocks are:
</p>
<blockquote class="text">
<p>BundleAuthenticationBlock    - BAB: 0x02
</p>
<p>PayloadIntegrityBlock        - PIB: 0x03
</p>
<p>PayloadConfidentialityBlock  - PCB: 0x04
</p>
<p>ExtensionSecurityBlock       - ESB: 0x09
</p>
</blockquote>
<p>- Block processing control flags (SDNV) - defined as in all bundle protocol 
blocks except the primary bundle block (as described in the Bundle Protocol 
<a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>). SDNV encoding is described 
in the bundle protocol.  There are no general constraints on the use of the block 
processing flags, and some specific requirements are discussed later.
</p>
<p>- EID references - composite field defined in <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> containing references to one or two EIDs. 
Presence of the EID-reference field is indicated by the setting of the 
"block contains an EID-reference field" (EID_REF) bit 
of the block processing control flags. If one or more references is present, 
flags in the ciphersuite ID field, described below, specify which.
</p>
<p>If no EID fields are present then the composite field itself MUST be
omitted entirely and the EID_REF bit MUST be unset. 
A count field of zero is not permitted.
</p>
<p>The possible EIDs are:
</p>
<blockquote class="text">
<p>- (optional) Security-source - specifies the security source for the 
block. If this is omitted, then the source of the bundle is assumed to be the 
security-source unless otherwise indicated.
</p>
<p>- (optional) Security-destination - specifies the security destination for 
the block.  If this is omitted, then the destination of the bundle is assumed 
to be the security-destination unless otherwise indicated.
</p>
</blockquote>
<p>If two EIDs are present, security-source is first and security-destination 
comes second.
</p>
<p>- Block data length (SDNV) - as in all bundle protocol blocks except the 
primary bundle block. SDNV encoding is described in the bundle protocol.
</p>
<p>- Block-type-specific data fields as follows:
</p>
<blockquote class="text">
<p>- Ciphersuite ID (SDNV)
</p>
<p>- Ciphersuite flags (SDNV)
</p>
<p>- (optional) Correlator - when more than one related block is inserted 
then this field MUST have the same value in each related block instance. 
This is encoded as an SDNV. See note in <a class='info' href='#frag'>Section&nbsp;3.8<span> (</span><span class='info'>Bundle Fragmentation and Reassembly</span><span>)</span></a> 
with regard to correlator values in bundle fragments.
</p>
<p>- (optional) Ciphersuite parameters - compound field of next two items
</p>
<blockquote class="text">
<p>- Ciphersuite parameters length - specifies the length of the following 
Ciphersuite parameters data field and is encoded as an SDNV. 
</p>
<p>- Ciphersuite parameters data - parameters to be used with the 
ciphersuite in use, e.g. a key identifier or initialization vector (IV). 
See <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a> for a list of potential parameters and their 
encoding rules. The particular set of parameters that are included in this 
field are defined as part of the ciphersuite specification.
</p>
</blockquote>
<p>- (optional) Security result - compound field of next two items
</p>
<blockquote class="text">
<p>- Security result length - contains the length of the next field and is encoded 
as an SDNV.
</p>
<p>- Security result data - contains the results of the appropriate 
ciphersuite-specific calculation (e.g., a signature, MAC or ciphertext block 
key).
</p>
</blockquote>
</blockquote>
</blockquote><br /><hr class="insert" />
<a name="ASBdiagram"></a>

<p> Although the 
diagram hints at a 32-bit layout this is purely for the purpose of
exposition. Except for the "type" field, all fields are variable in length.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------+----------------+----------------+----------------+
| type           |  flags (SDNV)  |  EID ref list(comp)             |
+----------------+----------------+----------------+----------------+
| length  (SDNV)                  |  ciphersuite (SDNV)             |
+----------------+----------------+----------------+----------------+
| ciphersuite flags (SDNV)        |  correlator  (SDNV)             |
+----------------+----------------+----------------+----------------+
|params len(SDNV)| ciphersuite params data                          |
+----------------+----------------+----------------+----------------+
|res-len  (SDNV) | security result data                             |
+----------------+----------------+----------------+----------------+
</pre></div>
<p>The structure of an abstract security block. 

</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Some ciphersuites are specified in <a class='info' href='#ciphersuites'>Section&nbsp;4<span> (</span><span class='info'>Mandatory Ciphersuites</span><span>)</span></a>, 
which also specifies the rules which MUST be 
satisfied by ciphersuite specifications.  Additional ciphersuites MAY be 
defined in separate specifications. Ciphersuite IDs not specified are reserved. 
Implementations of the bundle security protocol decide which ciphersuites to 
support, subject to the requirements of <a class='info' href='#ciphersuites'>Section&nbsp;4<span> (</span><span class='info'>Mandatory Ciphersuites</span><span>)</span></a>. 
It is RECOMMENDED that implementations that allow additional ciphersuites permit 
ciphersuite ID values at least up to and including 127, and they MAY decline to 
allow larger ID values. 
</p>
<p>The structure of the ciphersuite flags field is shown in 
<a class='info' href='#CIDFig'>Figure&nbsp;3</a>. In each case the presence of an optional 
field is indicated by setting the value of the corresponding flag to one. A value of 
zero indicates the corresponding optional field is missing. Presently there are 
five flags defined for the field and for convenience these are shown as they would 
be extracted from a single-byte SDNV. Future additions may cause the field to grow 
to the left so, as with the flags fields defined in <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>, 
the description below numbers the bit positions from the right rather than 
the standard RFC definition which numbers bits from the left. 
</p>
<blockquote class="text">
<p>src - bit 4 indicates whether the EID-reference 
field of the ASB contains the optional reference to the security-source.
</p>
<p>dest - bit 3 indicates whether the EID-reference 
field of the ASB contains the optional reference to the security-destination.
</p>
<p>parm - bit 2 indicates whether the ciphersuite-parameters-length and ciphersuite 
parameters data fields are present or not. 
</p>
<p>corr - bit 1 indicates whether or not the ASB contains an optional 
correlator.
</p>
<p>res - bit 0 indicates whether or not the ASB contains the 
security result length and security result data fields.
</p>
<p>bits 5-6 are reserved for future use. 
</p>
</blockquote><br /><hr class="insert" />
<a name="CIDFig"></a>

<p> 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

Ciphersuite flags
  Bit   Bit   Bit   Bit   Bit   Bit   Bit
   6     5     4     3     2     1     0
+-----+-----+-----+-----+-----+-----+-----+
| reserved  |src  |dest |parm |corr |res  |
+-----+-----+-----+-----+-----+-----+-----+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>A little bit more terminology: if the block is a PIB then when we refer to the 
"PIB-source", we mean the security source for the PIB as represented by the 
EID reference in the EID-references field. Similarly we may refer to the PCB-dest, 
meaning the security-destination of the PCB, again as represented by an EID reference. 
For example, referring to <a class='info' href='#protocolStack'>Figure&nbsp;1</a> 
again, if the bundle that originates at BN1 as source is given a Confidentiality Block 
(PCB) by BN1 that is protected using a key held by BN3 and it is given a Payload Integrity 
Block (PIB) by BN1, then BN1 is both the PCB-source and the PIB-source of the bundle, 
and BN3 is the PCB-dest of the bundle.
</p>
<p>The correlator field is used to associate several related instances of a 
security block. This can be used to place a BAB that contains the ciphersuite information 
at the "front" of a (probably large) bundle, and another correlated BAB that contains the 
security result at the "end" of the bundle. This allows even very memory-constrained nodes to 
be able to process the bundle and verify the BAB. There are similar 
use cases for multiple related instances of PIB and PCB as will be seen below.
</p>
<p>The ciphersuite specification MUST make it clear whether or not 
multiple block instances are allowed, and if so, under what conditions. Some 
ciphersuites can of course leave flexibility to the implementation, 
whereas others might mandate a fixed number of instances.
</p>
<p>For convenience, we use the term "first block" to refer to the initial block 
in a group of correlated blocks, or to the single block if there are no others 
in the set. Obviously there can be several unrelated groups in a bundle, each 
containing only one block or more than one, and each has its own "first block". 

</p>
<a name="sec.BAB"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Bundle Authentication Block</h3>

<p>In this section we describe typical BAB field values for two scenarios - 
where a single instance of the BAB contains all the information and where two related 
instances are used, one "up front" which contains the ciphersuite and another 
following the payload which contains the security result (e.g. a MAC).
</p>
<p>For the case where a single BAB is used:
</p>
<blockquote class="text">
<p>The block-type code field value MUST be 0x02.
</p>
<p>The block processing control flags value can be set to whatever values are 
required by local policy.
Ciphersuite designers should carefully consider the 
effect of setting flags that either discard the block or delete the bundle 
in the event that this block cannot be processed.
</p>
<p>The ciphersuite ID MUST be documented as a hop-by-hop 
authentication-ciphersuite which requires one instance of the BAB.
</p>
<p>The correlator field MUST NOT be present.
</p>
<p>The ciphersuite parameters field MAY be present, if so specified in the 
ciphersuite specification.
</p>
<p>An EID reference to the security-source MAY be present. The security-source 
can also be specified as part of key information described in 
<a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a> or another block such as the Previous Hop 
Insertion Block. The security-source might also be inferred from 
some implementation-specific means such as the convergence layer.
</p>
<p>An EID reference to the security-destination MAY be present 
and is useful to ensure that the bundle has been forwarded 
to the correct next-hop node.
</p>
<p>The security result MUST be present as it is effectively the "output" from 
the ciphersuite calculation (e.g. the MAC or signature) applied to the 
(relevant parts of) the bundle (as specified in the ciphersuite definition). 

</p>
</blockquote>
<p>For the case using two related BAB instances, the first instance is as defined 
above, except the ciphersuite ID MUST be documented as a hop-by-hop authentication 
ciphersuite that requires two instances of the BAB. In addition, the correlator MUST 
be present and the security result length and security result fields MUST be 
absent. The second instance of the BAB MUST have the same correlator value 
present and MUST contain security result length and security result data fields. 
The other optional fields MUST NOT be present. 
Typically, this second instance of a BAB will be the last block of the bundle.
</p>
<p>The details of key transport for BAB are specified by the particular 
ciphersuite. In the absence of conflicting requirements, the following 
should be noted by implementors: 
</p>
<blockquote class="text">
<p>- the key information item <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a> is optional, and if not 
provided then the key should be inferred from the source-destination tuple, 
being the previous key used, a key created from a key-derivation function, 
or a pre-shared key
</p>
<p>- if all the nodes are security-aware, the capabilities of the underlying 
convergence layer might be useful for identifying the security-source
</p>
<p>- depending upon the key mechanism used, bundles can be signed by the sender, 
or authenticated for one or more recipients, or both. 
</p>
</blockquote>
<a name="sec.PIB"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Payload Integrity Block</h3>

<p>A PIB is an ASB with the following additional restrictions:
</p>
<blockquote class="text">
<p>The block type code value MUST be 0x03.
</p>
<p>The block processing control flags value can be set to whatever values are 
required by local policy. Ciphersuite designers should carefully consider the 
effect of setting flags that either discard the block or delete the bundle 
in the event that this block cannot be processed.
</p>
<p>The ciphersuite ID MUST be documented as an end-to-end 
authentication-ciphersuite or as an end-to-end error-detection-ciphersuite. 

</p>
<p>The correlator MUST be present if the ciphersuite requires more than 
one related instance of a PIB be present in the bundle. The correlator MUST NOT be 
present if the ciphersuite only requires one instance of the PIB in the 
bundle.
</p>
<p>The ciphersuite parameters field MAY be present.
</p>
<p>An EID reference to the security-source MAY be present. 
The security-source can also be specified as part of key information 
described in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>.
</p>
<p>An EID reference to the security-destination MAY be present.
</p>
<p>The security result is effectively the "output" from the ciphersuite 
calculation (e.g. the MAC or signature) applied to the (relevant parts of) the 
bundle. As in the case of the BAB, this field MUST be present if the correlator 
is absent. If more than one related instance of the PIB is required then this is 
handled in the same way as described for the BAB above.
</p>
<p>The ciphersuite MAY process less than the entire original bundle payload. 
This might be because it is defined to process some subset of the bundle, or 
perhaps because the the current payload is a fragment of an original bundle. 
For whatever reason, if the ciphersuite processes less than the complete, 
original bundle payload, the ciphersuite parameters of this block MUST specify 
which bytes of the bundle payload are protected. 
</p>
</blockquote>
<p>For some ciphersuites, (e.g. those using asymmetric keying to produce 
signatures or those using symmetric keying with a group key), the security 
information can be checked at any hop on the way to the security destination 
that has access to the required keying information. This possibility is 
further discussed in <a class='info' href='#sec.bon'>Section&nbsp;3.6<span> (</span><span class='info'>Bundles received from other nodes</span><span>)</span></a> below. 
</p>
<p>The use of a generally-available key is RECOMMENDED if custodial transfer 
is employed and all nodes SHOULD verify the bundle before accepting custody. 
</p>
<p> Most asymmetric PIB-ciphersuites will use the PIB-source to indicate the 
signer and will not require the PIB-dest field because the key needed to verify 
the PIB authenticator will be a public key associated with the PIB-source. 
</p>
<a name="sec.PCB"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Payload Confidentiality Block</h3>

<p>A typical confidentiality ciphersuite will encrypt the payload using a 
randomly generated bundle encrypting key (BEK) and will use a key information 
item in the PCB security parameters to carry the BEK encrypted with some long term 
key encryption key (KEK) or well-known public key. If neither the destination 
nor security-destination resolves the key to use for decryption, the key 
information item in the ciphersuite parameters field can also be used to 
indicate the decryption key with which the BEK can be recovered. 
If the bundle already contains PIBs and/or PCBs these SHOULD also 
be encrypted using this same BEK, as described just below for 
"super-encryption". The encrypted block is encapsulated into a new PCB 
that replaces the original block at the same place in the bundle.
</p>
<p>It is strongly RECOMMENDED that a data integrity mechanism be used in 
conjunction with confidentiality, and that encryption-only ciphersuites 
NOT be used. AES-GCM satisfies this requirement. 
The "authentication tag" or "integrity check value" is 
stored into security-result rather than being appended to the payload 
as is common in some protocols since, as described below, it is 
important that there be no change in the size of the payload.
</p>
<p>The payload is encrypted "in-place", that is, following encryption, 
the payload block payload field contains ciphertext, not plaintext. 
The payload block processing flags are unmodified.
</p>
<p>The "in-place" encryption of payload bytes is to allow bundle payload 
fragmentation and re-assembly, and custody transfer, to operate 
without knowledge of whether or not encryption has occurred and, 
if so, how many times. 
</p>
<p>Fragmentation and reassembly and custody transfer are adversely affected 
by a change in size of the payload due to ambiguity about what byte range of 
the original payload is actually in any particular fragment. Ciphersuites 
SHOULD place any payload expansion, such as authentication tags 
(integrity check values) and any padding generated by a block-mode 
cipher, into an "integrity check value" item in the security-result field 
(see <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>) of the confidentiality block.
</p>
<p>Payload super-encryption is allowed; that is, encrypting a payload 
that has already been encrypted, perhaps more than once. 
Ciphersuites SHOULD define super-encryption such that, as well as 
re-encrypting the payload, it also protects the parameters of earlier 
encryption. Failure to do so may represent a vulnerability in some 
circumstances. 
</p>
<p>Confidentiality is normally applied to the payload, and possibly to 
additional blocks. It is RECOMMENDED to apply a Payload Confidentiality 
ciphersuite to non-payload blocks only if these should be super-encrypted 
with the payload. If super-encryption of the block is not desired then 
protection of the block should be done using the Extension Security Block 
mechanism rather than PCB.
</p>
<p>Multiple related PCB instances are required if both the payload 
and PIBs and PCBs in the bundle are to be encrypted. These multiple 
PCB instances require correlators to associate them with each other 
since the key information is provided only in the first PCB. 
</p>
<p>There are situations where more than one PCB instance is required but 
the instances are not "related" in the sense which requires correlators. 
One example is where a payload is encrypted for more than one security-destination 
so as to be robust in the face of routing uncertainties. In this scenario 
the payload is encrypted using a BEK. Several PCBs contain the BEK 
encrypted using different KEKs, one for each destination. 
These multiple PCB instances, are not "related" and should not 
contain correlators. 
</p>
<p>The ciphersuite MAY apply different rules to confidentiality 
for non-payload blocks.
</p>
<p>A PCB is an ASB with the following additional restrictions:
</p>
<blockquote class="text">
<p>The block type code value MUST be 0x04.
</p>
<p>The block processing control flags value can be set to whatever values are 
required by local policy, except that a PCB "first block" 
MUST have the "replicate in every fragment" flag set. 
This flag SHOULD NOT be set otherwise. 
Ciphersuite designers should carefully consider the 
effect of setting flags that either discard the block or delete the bundle 
in the event that this block cannot be processed.
</p>
<p>The ciphersuite ID MUST be documented as a confidentiality-ciphersuite.
</p>
<p>The correlator MUST be present if there is more than one related PCB instance. 
The correlator MUST NOT be present if there are no related PCB instances.
</p>
<p>If a correlator is present, the key information MUST 
be placed in the PCB "first block".
</p>
<p>Any additional bytes generated as a result of encryption and/or 
authentication processing of the payload SHOULD be placed in an 
"integrity check value" field (see <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>) 
in the security-result of the first PCB.
</p>
<p>The ciphersuite parameters field MAY be present.
</p>
<p>An EID reference to the security-source MAY be present. 
The security-source can also be specified as part of key information 
described in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>.
</p>
<p>An EID reference to the security-destination MAY be present.
</p>
<p>The security result MAY be present and normally contains fields such as 
an encrypted bundle encryption key, authentication tag or 
the encrypted versions of bundle blocks other than the payload block.
</p>
</blockquote>
<p>The ciphersuite MAY process less than the entire original bundle payload, 
either because the current payload is a fragment of the original bundle or 
just because it is defined to process some subset. For whatever reason, 
if the ciphersuite processes less than the complete, original bundle payload 
the "first" PCB MUST specify, as part of the ciphersuite parameters, which 
bytes of the bundle payload are protected. 
</p>
<p>PCB ciphersuites MUST specify which blocks are to be encrypted. 
The specification MAY be flexible and be dependent upon block type, 
security policy, various data values and other inputs but it MUST be 
deterministic. The determination of whether a block is to be encrypted 
or not MUST NOT be ambiguous.
</p>
<p>As was the case for the BAB and PIB, if the ciphersuite requires more 
than one instance of the PCB, then the "first block" MUST contain any optional 
fields (e.g., security destination etc.) that apply to all instances with this 
correlator. These MUST be contained in the first instance and MUST NOT be repeated 
in other correlated blocks. Fields that are specific to a particular instance 
of the PCB MAY appear in that PCB. For example, security result fields MAY 
(and probably will) be included in multiple related PCB instances, with each 
result being specific to that particular block. 
Similarly, several PCBs might each contain a ciphersuite parameters field 
with an IV specific to that PCB instance.
</p>
<p>Put another way: when confidentiality will generate multiple blocks, it 
MUST create a "first" PCB with the required ciphersuite ID, parameters etc. 
as specified above.  Typically, this PCB will appear early in the bundle. 
This "first" PCB contains the parameters that apply to the payload and also 
to the other correlated PCBs. The correlated PCBs follow the "first" PCB 
and MUST NOT repeat the ciphersuite parameters, security-source, 
or security-destination fields from the first PCB. These correlated PCBs 
need not follow immediately after the "first" PCB, and probably will not 
do so. Each correlated block, encapsulating an encrypted PIB or PCB, is 
at the same place in the bundle as the original PIB or PCB.
</p>
<p>A ciphersuite MUST NOT mix payload data and a non-payload block in a single PCB.
</p>
<p>Even if a to-be-encrypted block has the "discard" flag set, whether or not 
the PCB's "discard" flag is set is an implementation/policy decision for the 
encrypting node. (The "discard" flag is more properly called the "discard if 
block cannot be processed" flag.)
</p>
<p>Any existing EID-list in the to-be-encapsulated original block remains 
exactly as-is, and is copied to become the EID-list for the replacing block. 
The encapsulation process MUST NOT replace or remove the existing 
EID-list entries. This is critically important for correct updating 
of entries at the security-destination. 
</p>
<p>At the security-destination, either specific destination or the 
bundle destination, the processes described above are reversed. 
The payload is decrypted in-place using the salt, IV and key values 
in the first PCB, including verification using the ICV. 
These values are described below in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>. 
Each correlated PCB is also processed at the same destination, 
using the salt and key values from the first PCB and the 
block-specific IV item. The "encapsulated block" item in the 
security-result is decrypted and validated, using also the tag 
which SHOULD have been appended to the ciphertext of the original 
block data. Assuming the validation succeeds, the resultant 
plaintext, which is the entire content of the original 
block, replaces the PCB at the same place in the bundle. 
The block type reverts to that of the original block 
prior to encapsulation, and the other block-specific data fields 
also return to their original values. Implementors are cautioned 
that this "replacement" process requires delicate stitchery, 
as the EID-list contents in the decapsulated block are invalid. 
As noted above, the EID-list references in the original block were 
preserved in the replacing PCB, and will have been updated as 
necessary as the bundle has toured the dtn. The references from the 
PCB MUST replace the references within the EID-list of the 
newly-decapsulated block. Caveat implementor. 
</p>
<a name="sec.ESB"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Extension Security Block</h3>

<p>Extension security blocks provide protection for non-payload-related 
portions of a bundle. ESBs MUST NOT be used for the primary block or payload, 
including payload-related security blocks (PIBs and PCBs).
</p>
<p>It is sometimes desirable to protect certain parts of a bundle in ways 
other than those applied to the bundle payload. One such example is bundle 
metadata that might specify the kind of data in the payload but not the 
actual payload detail, as described in <a class='info' href='#DTNMD'>[DTNMD]<span> (</span><span class='info'>Symington, S., &ldquo;Delay-Tolerant Networking Metadata Extension Block,&rdquo; June&nbsp;2007.</span><span>)</span></a>. 

</p>
<p>ESBs are typically used to apply confidentiality protection. 
While it is possible to create an integrity-only ciphersuite, 
the block protection is not transparent and makes access to the 
data more difficult. For simplicity, this discussion describes 
use of a confidentiality ciphersuite.
</p>
<p>The protection mechanisms in ESBs are similar to other security blocks 
with two important differences:
</p>
<blockquote class="text">
<p>- different key values are used (using same key as for payload would 
defeat the purpose)
</p>
<p>- the block is not encrypted or super-encrypted with the payload
</p>
</blockquote>
<p>A typical ESB ciphersuite will encrypt the extension block using a 
randomly generated ephemeral key and will use the key information item 
in the security parameters field to carry the key encrypted with some 
long term key encryption key (KEK) or well-known public key.
If neither the destination 
nor security-destination resolves the key to use for decryption, the key 
information item in the ciphersuite parameters field can be used also to 
indicate the decryption key with which the BEK can be recovered. 
</p>
<p>It is strongly RECOMMENDED that a data integrity mechanism be used in 
conjunction with confidentiality, and that encryption-only ciphersuites 
NOT be used. AES-GCM satisfies this requirement.
</p>
<p>The ESB is placed in the bundle in the same position as the block being 
protected. That is, the entire original block is processed (encrypted, etc) 
and encapsulated in a "replacing" ESB-type block, and this appears in the 
bundle at the same sequential position as the original block. The processed 
data is placed in the security-result field.
</p>
<p>The process is reversed at the security destination with the recovered 
plaintext block replacing the ESB that had encapsulated it. Processing 
of EID-list entries, if any, is described above in <a class='info' href='#sec.PCB'>Section&nbsp;2.4<span> (</span><span class='info'>Payload Confidentiality Block</span><span>)</span></a> and 
this MUST be followed in order to correctly recover EIDs.
</p>
<p>An ESB is an ASB with the following additional restrictions:
</p>
<blockquote class="text">
<p>Block type is 0x09. 
</p>
<p>Ciphersuite flags indicate which fields are present in this block.
Ciphersuite designers should carefully consider the 
effect of setting flags that either discard the block or delete the bundle 
in the event that this block cannot be processed.
</p>
<p>EID references MUST be stored in the EID reference list. 
</p>
<p>Security-source MAY be present. The security-source 
can also be specified as part of key information described in 
<a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>. If neither is present then the 
bundle-source is used as the security-source.
</p>
<p>Security-destination MAY be present. If not present, then the 
bundle-destination is used as the security-destination. 
</p>
</blockquote>
<p>The security-parameters MAY optionally contain a block-type field 
to indicate the type of the encapsulated block. Since this replicates 
a field in the encrypted portion of the block, it is a slight security 
risk and its use is therefore OPTIONAL.
</p>
<a name="sec.PRF"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Parameters and Result Fields</h3>

<p>Various ciphersuites include several items in the security-parameters 
and/or security-result fields. Which items MAY appear is defined by the 
particular ciphersuite description. A ciphersuite MAY support several 
instances of the same type within a single block.
</p>
<p>Each item is represented as type-length-value. Type is a single byte 
indicating which item this is. Length is the count of data bytes to follow, 
and is an SDNV-encoded integer. Value is the data content of the item.
</p>
<p>Item types are
</p>
<blockquote class="text">
<p> 0:  reserved
</p>
<p> 1:  initialization vector (IV)
</p>
<p> 2:  reserved
</p>
<p> 3:  key information
</p>
<p> 4:  fragment range (offset and length as a pair of SDNVs)
</p>
<p> 5:  integrity signature
</p>
<p> 6:  reserved
</p>
<p> 7:  salt
</p>
<p> 8:  PCB integrity check value (ICV)
</p>
<p> 9:  reserved
</p>
<p> 10:  encapsulated block
</p>
<p> 11:  block type of encapsulated block
</p>
<p> 12  - 191:  reserved
</p>
<p> 192 - 250:  private use
</p>
<p> 251 - 255:  reserved
</p>
</blockquote>
<p>The folowing descriptions apply to usage of these items for all ciphersuites. 
Additional characteristics are noted in the discussion for specific suites.
</p>
<blockquote class="text">
<p>- initialization vector(IV): random value, typically eight to sixteen bytes
</p>
<p>- key information: key material encoded or protected by the key management system, 
and used to transport an ephemeral key protected by a long-term key. 
This item is discussed further below in <a class='info' href='#sec.KT'>Section&nbsp;2.7<span> (</span><span class='info'>Key Transport</span><span>)</span></a>
</p>
<p>- fragment range: pair of SDNV values (offset then length) specifying the range 
of payload bytes to which a particular operation applies. This is termed 
"fragment range" since that is its typical use, even though sometimes it 
describes a subset range that is not a fragment. The offset value MUST be 
the offset within the original bundle, which might not be the offset within 
the current bundle if the current bundle is already a fragment
</p>
<p>- integrity signature: result of BA or PI digest or signing operation. 
This item is discussed further below in <a class='info' href='#sec.KT'>Section&nbsp;2.7<span> (</span><span class='info'>Key Transport</span><span>)</span></a>
</p>
<p>- salt: an IV-like value used by certain confidentiality suites
</p>
<p>- PCB integrity check value(ICV): output from certain confidentiality 
ciphersuite operations to be used at the destination to verify that the 
protected data has not been modified
</p>
<p>- encapsulated block: result of confidentiality operation on certain 
blocks, contains the ciphertext of the block and MAY also contain an 
integrity check value appended to the ciphertext; MAY also contain 
padding if required by the encryption mode; used for non-payload 
blocks only
</p>
<p>- block type of encapsulated block: block type code for a block 
that has been encapsulated in ESB
</p>
</blockquote>
<a name="sec.KT"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.7"></a><h3>2.7.&nbsp;
Key Transport</h3>

<p>This specification endeavours to maintain separation between the 
security protocol and key management. However, these two interact in 
the transfer of key information, etc., from security-source 
to security-destination. 
The intent of the separation is to facilitate use of a variety of 
key management systems without a necessity to tailor a ciphersuite 
to each individually. 
</p>
<p>The key management process deals with such things as long-term keys, 
specifiers for long-term keys, certificates for long-term keys 
and integrity signatures using long-term keys. The ciphersuite itself 
should not require a knowledge of these, and separation is improved 
if it treats these as opaque entities, to be handled by the key management 
process.
</p>
<p>The key management process deals specifically with the content of two 
of the items defined above in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>:- 
key information (item type 3) and integrity signature (item type 5). 
The ciphersuite MUST define the details and format for these items. 
To facilitate interoperability, it is strongly RECOMMENDED that the 
implementations use the appropriate definitions from Cryptographic 
Message Syntax (CMS) <a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> and related RFCs. 
</p>
<p>Many situations will require several pieces of key information. 
Again, ciphersuites MUST define whether they accept these packed 
into a single key information item and/or separated into multiple 
instances of key information. For interoperability, it is  
RECOMMENDED that ciphersuites accept these packed into a single 
key-information item, and that they MAY 
additionally choose to accept them sent as separate items.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.8"></a><h3>2.8.&nbsp;
PIB and PCB combinations</h3>

<p>Given the above definitions, nodes are free to combine applications 
of PIB and PCB in any way they wish - the correlator value allows for 
multiple applications of security services to be handled separately. 
Since PIB and PCB apply to the payload and ESB to non-payload blocks, 
combinations of ESB with PIB and/or PCB are not considered.
</p>
<p>There are some obvious security problems that could arise when 
applying multiple services. For example, if we encrypted a payload but left a 
PIB security result containing a signature in the clear, payload 
guesses could be confirmed.
</p>
<p>We cannot, in general, prevent all such problems since we cannot assume that 
every ciphersuite definition takes account of every other ciphersuite 
definition. However, we can limit the potential for such problems by requiring 
that any ciphersuite which applies to one instance of a PIB or PCB, MUST be 
applied to all instances with the same correlator.
</p>
<p>We now list the PIB and PCB combinations which we envisage as being useful to 
support:
</p>
<blockquote class="text">
<p>Encrypted tunnels - a single bundle MAY be encrypted many times en-route to 
its destination. Clearly it has to be decrypted an equal number of times, but we 
can imagine each encryption as representing the entry into yet another layer of 
tunnel.  This is supported by using multiple instances of PCB, but with the 
payload encrypted multiple times, "in-place". Depending upon the ciphersuite 
defintion, other blocks can and should be encrypted, as discussed above 
and in <a class='info' href='#sec.PCB'>Section&nbsp;2.4<span> (</span><span class='info'>Payload Confidentiality Block</span><span>)</span></a> to ensure that parameters are protected 
in the case of super-encryption.
</p>
<p>Multiple parallel authenticators - a single security source might wish to 
protect the integrity of a bundle in multiple ways. 
This could be required if the bundle's path is 
unpredictable, and if various nodes might be involved as security destinations. 
Similarly, if the security source cannot determine in advance which algorithms 
to use, then using all might be reasonable. This would result in uses of PIB 
which presumably all protect the payload, and which cannot in general protect 
one another. Note that this logic can also apply to a BAB, if the unpredictable 
routing happens in the convergence layer, so we also envisage support for 
multiple parallel uses of BAB.
</p>
<p>Multiple sequential authenticators - if some security destination requires 
assurance about the route that bundles have taken, then it might insist that 
each forwarding node add its own PIB. More likely, however would be that outbound 
"bastion" nodes would be configured to sign bundles as a way of allowing the 
sending "domain" to take accountability for the bundle.  In this case, the 
various PIBs will likely be layered, so that each protects the earlier 
applications of PIB.
</p>
<p>Authenticated and encrypted bundles - a single bundle MAY require both 
authentication and confidentiality. Some specifications first apply 
the authenticator and follow this by encrypting the payload and authenticator. 
As noted previously in the case where the authenticator is a signature, there 
are security reasons for this ordering. (See the PCB-RSA-AES128-PAYLOAD-PIB-PCB 
ciphersuite defined later in <a class='info' href='#rsaaes'>Section&nbsp;4.3<span> (</span><span class='info'>PCB-RSA-AES128-PAYLOAD-PIB-PCB</span><span>)</span></a>.) 
Others apply the authenticator after encryption, that is, to the ciphertext. 
This ordering is generally recommended and minimizes attacks which, in some 
cases, can lead to recovery of the encryption key. 

</p>
</blockquote>
<p>There are no doubt other valid ways to combine PIB and PCB instances, but 
these are the "core" set supported in this specification. Having said that, 
as will be seen, 
the mandatory ciphersuites defined here are quite specific and restrictive in 
terms of limiting the flexibility offered by the correlator mechanism. This is 
primarily designed to keep this specification as simple as possible, while at 
the same time supporting the above scenarios.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Security Processing</h3>

<p>This section describes the security aspects of bundle processing. 
</p>
<a name="secPEP"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Nodes as policy enforcement points</h3>

<p>All nodes are REQUIRED to have and enforce their own configurable security 
policies, whether these policies be explicit or default, as defined in 
<a class='info' href='#sec.Defaults'>Section&nbsp;6<span> (</span><span class='info'>Default Security Policy</span><span>)</span></a>.  
</p>
<p>All nodes serve as Policy Enforcement Points (PEP) insofar as they enforce 
polices that MAY restrict the permissions of bundle nodes to inject traffic 
into the network. Policies MAY apply to traffic originating at the current node, 
traffic terminating at the current node and traffic to be forwarded by the 
current node to other nodes. If a particular transmission request, originating 
either locally or remotely, satisfies the node's policy or policies 
and is therefore accepted, then an outbound bundle can be created and 
dispatched. If not, then in its role as a PEP, the node will not create or 
forward a bundle. Error handling for such cases is currently considered out 
of scope of this document.
</p>
<p>Policy enforcing code MAY override all other processing steps described here 
and elsewhere in this document. For example, it is valid to implement a node 
which always attempts to attach a PIB.  Similarly it is also valid to implement 
a node which always rejects all requests which imply the use of a PIB.
</p>
<p>Nodes MUST consult their security policy to determine the criteria that 
a received bundle ought to meet before it will be forwarded. These criteria 
MUST include a determination of whether or not the received bundle MUST include 
a valid BAB, PIB, PCB or ESB.  If the bundle does not meet the node's policy 
criteria, then the bundle MUST be discarded and processed no further; in this 
case, a bundle status report indicating the failure MAY be generated.
</p>
<p>The node's policy MAY call for the node to add or subtract some security 
blocks. For example, it might require the node attempt to encrypt (parts of) 
the bundle for some security-destination, or that it add a 
PIB. If the node's policy requires a BAB to be added to the bundle, it MUST be 
added last so that the calculation of its security result MAY take into 
consideration the values of all other blocks in the bundle.
</p>
<a name="sec.stack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Processing order of security blocks</h3>

<p>The processing order of security actions for a bundle is critically 
important for the actions to complete successfully. In general, the 
actions performed at the originating node MUST be executed in the 
reverse sequence at the destination. There are variations and 
exceptions, and these are noted below.
</p>
<p>The sequence is maintained in the ordering of security blocks in the 
bundle. It is for this reason that blocks MUST not be rearranged at 
forwarding nodes, whether they support the security protocols or not. 
The only blocks that participate in this ordering are the primary 
and payload blocks, and the PIB and PCB security blocks themselves. 
All other extension blocks, including ESBs, are ignored for purposes of 
determining the processing order.
</p>
<p>The security blocks are added to and removed from a bundle in a 
last-in-first-out (LIFO) manner, with the top of the stack immediately 
after the primary block. A newly-created bundle has just the primary and 
payload blocks, and the stack is empty. As security actions are requested 
for the bundle, security blocks are pushed onto the stack immediately after 
the primary block. The early actions have security blocks close to the 
payload, later actions have blocks nearer to the primary block. 
The actions deal with only those blocks in the bundle at the 
time so, for example, the first to be added processes only the payload 
and primary blocks, the next might process the first if it chooses and 
the payload and primary, and so on. The last block to be added can 
process all the blocks. 
</p>
<p>When the bundle is received, this process is reversed and 
security processing begins at the top of the stack, immediately 
after the primary block. The security actions are performed and 
the block is popped from the stack. Processing continues with the 
next security block until finally only the payload and primary 
blocks remain.
</p>
<p>The simplicity of this description is undermined by various 
real-world requirements. Nonetheless it serves as a helpful 
initial framework for understanding the bundle security 
process.
</p>
<p>The first issue is a very common one and easy to handle. 
The bundle may be sent indirectly to its destination, requiring 
several forwarding hops to finally arrive there. Security 
processing happens at each node, assuming that the node supports 
bundle security. For the following discussion, we assume that 
a bundle is created and that confidentiality, then payload 
integrity and finally bundle authentication are applied to it. 
The block sequence would therefore be primary-BAB-PIB-PCB-payload. 
Traveling from source to destination requires going through 
one intermediate node, so the trip consists of two hops. 
</p>
<p>When the bundle is received at the intermediate node, the 
receive processing validates the BAB and pops it from 
the stack. However the PIBs and PCBs have the final 
destination as their security destination, so these can't 
be processed and removed. The intermediate node then begins 
the send process with the four remaining blocks in the bundle. 
The outbound processing adds any security blocks required 
by local policy, and these are pushed on the stack immediately 
after the primary block, ahead of the PIB. In this 
example, the intermediate node adds a PIB as a signature 
that the bundle has passed through the node. 
</p>
<p>The receive processing at the destination first handles 
the intermediate node's PIB and pops it, next is the 
originator's PIB, also popped, and finally the 
originator's confidentiality block which allows the 
payload to be decrypted and the bundle handled for 
delivery.
</p>
<p>DTNs in practice are likely to be more complex. 
The security policy for a node specifies the security requirements 
for a bundle. 
The policy will possibly cause one or more security operations 
to be applied to the bundle at the current node, each with its own 
security-destination. Application of policy at subsequent nodes 
might cause additional security operations, each with a 
security-destination. The list of security-destinations 
in the security blocks (BAB, PIB and PCB, not ESB) creates 
a partial-ordering of nodes that MUST be visited en route to the 
bundle destination. 
</p>
<p>The bundle security scheme does not deal with security paths 
that overlap partially but not completely.  
The security policy for a node MUST avoid specifying for a bundle 
a security-destination that causes a conflict with any existing 
security-destination in that bundle.
This is discussed further below in <a class='info' href='#sec.sz'>Section&nbsp;3.3<span> (</span><span class='info'>Security Regions</span><span>)</span></a>.
</p>
<p>The second issue relates to the reversibility of certain 
security process actions. In general, the actions fall into 
two categories: those which do not affect other parts of the 
bundle, and those which are fully reversible. Creating a 
bundle signature, for example, does not change the bundle 
content except for the result. The encryption performed as 
part of the confidentiality processing does change the bundle, 
but the reverse processing at the destination restores the 
original content. 
</p>
<p>The third category is the one where the bundle content has 
changed slightly and in a non-destructive way, but there is no 
mechanism to reverse the change. The simplest example is the 
addition of an EID-reference to a security block. The addition 
of the reference causes the text to be added to the bundle's 
dictionary. The text may be used also by other references so 
removal of the block and this specific EID-reference does not 
cause removal of the text from the dictionary. This shortcoming 
is of no impact to the "sequential" or "wrapping" security 
schemes described above, but does cause failures with 
"parallel" authentication mechanisms. Solutions for this 
problem are implementation-specific and typically involve 
multi-pass processing such that blocks are added at one 
stage and the security results calculated at a later stage 
of the overall process.
</p>
<p>Certain ciphersuites have sequence requirements for their correct 
operation, most notably the bundle authentication ciphersuites. 
Processing for bundle authentication is required to happen after all 
other sending operations, and prior to any receive operations at the 
next hop node. It follows therefore that BA blocks MUST always be 
pushed onto the stack after all others.
</p>
<p>Although we describe the security block list as a stack, there are 
some blocks which are placed after the payload and therefore are not 
part of the stack. The BundleAuthentication ciphersuite #1 ("BA1") 
requires a second, correlated block to contain the security-result 
and this block is placed after the payload, usually as the last block 
in the bundle. We can apply the stack rules even to these blocks by 
specifying that they be added to the end of the bundle at the same 
time that their "owner" or "parent" block is pushed on the stack. 
In fact, they form a stack beginning at the payload but growing 
in the other direction. Also, not all blocks in the main stack 
have a corresponding entry in the trailing stack. The only blocks 
which MUST follow the payload are those mandated by ciphersuites 
as correlated blocks for holding a security-result. No other 
blocks are required to follow the payload block and it is 
RECOMMENDED that they NOT do so.
</p>
<p>ESBs are effectively placeholders for the blocks they encapsulate 
and, since those do not form part of the processing sequence 
described above, ESBs themselves do not either. 
ESBs MAY be correlated, however, so the "no reordering" 
requirement applies to them as well.
</p>
<a name="sec.sz"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Security Regions</h3>

<p>Each security block has a security path, as described in the 
discussion for <a class='info' href='#protocolStack'>Figure&nbsp;1</a>, and the paths for 
various blocks are often different. 
</p>
<p>BA blocks are always for a single hop and these restricted 
paths never cause conflict. 
</p>
<p>The paths for PIBs and PCBs are often from bundle source 
to bundle destination, to provide end-to-end protection. 
A bundle-source-to-bundle-destination path likewise never 
causes a problem. 
</p>
<p>Another common scenario is for gateway-to-gateway 
protection of traffic between two sub-networks
("tunnel-mode").
</p>
<p>Looking at <a class='info' href='#protocolStack'>Figure&nbsp;1</a> and the 
simplified version shown in <a class='info' href='#sz1'>Figure&nbsp;4</a>, we can 
regard BN2 and BN3 as gateways connecting the two 
subnetworks labeled "An internet". As long as they provide 
security for the BN2-BN3 path, all is well. Problems begin, 
for example, when BN2 adds blocks with BN4 as the 
security-destination, and originating node BN1 has created 
blocks with BN3 as security-destination. We now have two paths 
and neither is a subset of the other. 
</p>
<p>This scenario should be prevented by node BN2's security 
policy being aware of the already-existing block with BN3 as 
the security destination. This policy SHOULD NOT specify a 
security-dest that is further distant than any existing 
security-dest. 
</p><br /><hr class="insert" />
<a name="sz1"></a>

<p> 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+---------v-|   +-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v-+     +-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v-+   +-^---------+
| BN1     v |   | ^   BN2   v |     | ^   BN3   v |   | ^  BN4    |
+---------v-+   +-^---------v-+     +-^---------v-+   +-^---------+
          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;^         &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;^         &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;^

 &lt;-------------  BN1 to BN3 path  ------------&gt;

                    &lt;-------------  BN2 to BN4 path  ------------&gt;
</pre></div>
<p> Overlapping security paths
</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Consider the case where the security concern is for 
data integrity, so the blocks are PIBs. 
BN1 creates one ("PIa") along with the new bundle, and BN2 
pushes its own PIB "PIb" on the stack, with 
security-destination BN4. When this bundle arrives at BN3, 
the bundle blocks are 
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
primary - PIb - PIa - payload
</pre></div><p>
 
Block PIb is not destined for this node BN3 so has to be forwarded. 
This is the security-destination for block PIa so, after validation, 
it should be removed from the bundle. But that will invalidate the 
PIb signature when the block is checked at the final destination. 
The PIb signature includes the primary block, PIb itself, PIa and 
the payload block, so PIa MUST remain in the bundle. This is why 
security blocks are treated as a stack and add/remove operations 
are permitted only at the top-of-stack. 
</p>
<p>The situation would be worse if the security concern is 
confidentiality, and PCBs are employed, using the 
confidentiality ciphersuite #3 ("PC3") described in 
<a class='info' href='#rsaaes'>Section&nbsp;4.3<span> (</span><span class='info'>PCB-RSA-AES128-PAYLOAD-PIB-PCB</span><span>)</span></a>. In this scenario, BN1 would encrypt the 
bundle with BN3 as security-destination, BN2 would create an 
overlapping security path by super-encrypting the payload 
and encapsulating the PC3 block for security-destination BN4. 
BN3 forwards all the blocks without change. BN4 decrypts the payload 
from its super-encryption and decapsulates the PC3 block, only to 
find that it should have been processed earlier. Assuming that BN4 
has no access to BN3's key store, BN4 has no way to decrypt the 
bundle and recover the original content. 

</p>
<p>As mentioned above, authors of security policy need to use care to 
ensure that their policies do not cause overlaps. These guidelines 
should prove helpful:
</p>
<p></p>
<blockquote class="text">
<p>the originator of a bundle can always specify the bundle-dest as 
the security-dest, and should be cautious about doing otherwise
</p>
<p>in the "tunnel-mode" scenario where two sub-networks are connected 
by a tunnel through a network, the gateways can each specify the other 
as security-dest, and should be cautious about doing otherwise
</p>
<p>BAB is never a problem because it is always only a single hop
</p>
<p>PIB for a bundle without PCB will usually specify the bundle 
destination as security-dest
</p>
<p>PIB for a bundle containing a PCB should specify as its 
security-dest the security-dest of the PCB (outermost PCB if there 
are more than one)
</p>
</blockquote>

<a name="C14N"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Canonicalisation of bundles</h3>

<p>In order to verify a signature or MAC on a bundle the exact same bits, in 
the exact same order, MUST be input to the calculation upon verification as 
were input upon initial computation of the original signature or MAC value. 
Consequently, a node MUST NOT change the encoding of any URI in the dictionary 
field, e.g., changing the DNS part of some HTTP URL from lower case to upper case. 
Because bundles MAY be modified while in transit (either correctly or due to 
implementation errors), a canonical form of any given bundle (that contains a 
BAB or PIB) MUST be defined.
</p>
<p>This section defines bundle canonicalisation algorithms used in the 
<a class='info' href='#BABhmac'>Section&nbsp;4.1<span> (</span><span class='info'>BAB-HMAC</span><span>)</span></a> and <a class='info' href='#PIBrsasha'>Section&nbsp;4.2<span> (</span><span class='info'>PIB-RSA-SHA256</span><span>)</span></a> ciphersuites. 
Other ciphersuites can use these or define their own canonicalization 
procedures. 
</p>
<a name="strictC14N"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Strict canonicalisation</h3>

<p>The first algorithm that can be used permits no changes at all to the bundle 
between the security-source and 
the security-destination. It is mainly intended for use in BAB ciphersuites. This 
algorithm conceptually catenates all blocks in the order presented, but 
omits all security result data fields in blocks of this ciphersuite type. 
That is, when a BA ciphersuite specifies this algorithm then we 
omit all BAB security results for all BA ciphersuites, when a PIB ciphersuite specifies 
this algorithm then we omit all PIB security results for all PI ciphersuites. 
All security result length fields are 
included, even though their corresponding security result data fields are omitted.
</p>
<p>Notes:
</p>
<blockquote class="text">
<p>- In the above we specify that security result data is omitted. This means that 
no bytes of the security result data are input. We do not set the security 
result length to zero. Rather, we assume that the security result length will 
be known to the module that implements the ciphersuite before the security result is 
calculated, and require that this value be in the security result length field even 
though the security result data itself will be omitted.
</p>
<p>- The 'res' bit of the ciphersuite ID, which indicates whether or not the 
security result length and security result data field are present, 
is part of the canonical form.
</p>
<p>- The value of the block data length field, which indicates the length of the block, 
is also part of the canonical form. Its value indicates the 
length of the entire bundle when the bundle includes the security result data field.
</p>
<p>- BABs are always added to bundles after PIBs, so when a PIB ciphersuite specifies 
this strict canonicalisation algorithm and the PIB is received with a bundle that 
also includes one or more BABs, application of strict canonicalisation as part of 
the PIB security result verification process requires that all BABs in the bundle 
be ignored entirely.
</p>
</blockquote>
<a name="mutableC14N"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Mutable canonicalisation</h3>

<p>This algorithm is intended to protect parts of the bundle which 
should not be changed in-transit. Hence it omits the mutable parts of the 
bundle.
</p>
<p>The basic approach is to define a canonical form of the primary block and 
catenate it with the security (PIBs and PCBs only) and payload blocks in the 
order that they will be transmitted. This algorithm ignores all other blocks, 
including ESBs, because it cannot be determined whether or not they will 
change as the bundle transits the network. In short, this canonicalization 
protects the payload, payload-related security blocks and parts of the 
primary block. 
</p>
<p>Many fields in various blocks are stored as variable-length SDNVs. 
These are canonicalized in unpacked form, as eight-byte fixed-width fields 
in network byte order. The size of eight bytes is chosen because 
implementations MAY handle larger values as invalid, as noted in 
<a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>. 
</p>
<p>The canonical form of the primary block is shown 
in <a class='info' href='#primaryc14n'>Figure&nbsp;5</a>. 
Essentially, it de-references the dictionary block, adjusts lengths 
where necessary and ignores flags that MAY change in transit.
</p><br /><hr class="insert" />
<a name="primaryc14n"></a>

<p> 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------+----------------+----------------+----------------+
|    Version     |      Processing flags (incl. COS and  SRR)       |
+----------------+----------------+---------------------------------+
|                Canonical primary block length                     |
+----------------+----------------+---------------------------------+
|                Destination endpoint ID length                     |
+----------------+----------------+---------------------------------+
|                                                                   |
|                      Destination endpoint ID                      |
|                                                                   |
+----------------+----------------+---------------------------------+
|                    Source endpoint ID length                      |
+----------------+----------------+----------------+----------------+
|                                                                   |
|                        Source endpoint ID                         |
|                                                                   |
+----------------+----------------+---------------------------------+
|                  Report-to endpoint ID length                     |
+----------------+----------------+----------------+----------------+
|                                                                   |
|                      Report-to endpoint ID                        |
|                                                                   |
+----------------+----------------+----------------+----------------+
|                                                                   |
+                    Creation Timestamp (2 x SDNV)                  +
|                                                                   |
+---------------------------------+---------------------------------+
|                             Lifetime                              |
+----------------+----------------+----------------+----------------+
</pre></div>
<p> 
The canonical form of the primary bundle block. 

</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The fields shown in <a class='info' href='#primaryc14n'>Figure&nbsp;5</a> 
are:
</p>
<blockquote class="text">
<p>Version is the single-byte value in the primary block. 
</p>
<p>Processing flags in the primary block is an SDNV, and includes the 
class-of-service (COS) and status report request (SRR) fields. 
For purposes of canonicalization, the SDNV is unpacked into a 
fixed-width field and some bits are masked out. The unpacked field 
is ANDed with mask 0x0000 0000 0007 C1BE to set to zero all reserved 
bits and the "bundle is a fragment" bit. 
</p>
<p>Length - a four-byte value containing the length (in bytes) of this 
structure, in network byte order.
</p>
<p>Destination endpoint ID length and value - are the length (as a 
four byte value in network byte order) and value of the destination 
endpoint ID from the primary bundle block. The URI is simply copied 
from the relevant part(s) of the dictionary block and is not itself 
canonicalised. Although the dictionary entries contain null-terminators, 
the null-terminators are not included in the length or the 
canonicalization. 
</p>
<p>Source endpoint ID length and value are handled similarly to the 
destination.
</p>
<p>Report-to endpoint ID length and value are handled similarly to the 
destination.
</p>
<p>Creation time (2 x SDNV) and Lifetime (SDNV) are simply copied 
from the primary block, with the SDNV values being represented as 
eight-byte unpacked values.
</p>
<p>Fragment offset and Total application data unit length are ignored, 
as is the case for the "bundle is a fragment" bit mentioned above. 
If the payload data to be canonicalized is less than the complete, 
original bundle payload, the offset and length are specified in the 
security-parameters. 
</p>
</blockquote>
<p>For non-primary blocks being included in the canonicalization, the 
block processing flags value used for canonicalization is the unpacked 
SDNV value with reserved and mutable bits masked to zero. The unpacked 
value is ANDed with mask 0x0000 0000 0000 0077 to zero reserved bits 
and the "last block" flag. The "last block" flag is ignored because 
BABs and other security blocks MAY be added for some parts of the journey 
but not others so the setting of this bit might change from hop to hop.
</p>
<p>Endpoint ID references in security blocks are canonicalized using the 
de-referenced text form in place of the reference pair. The reference 
count is not included, nor is the length of the endpoint ID text.
</p>
<p>The block-length is canonicalized as an eight-byte unpacked value 
in network byte order. If the payload data to be canonicalized is less 
than the complete, original bundle payload, this field contain the 
size of the data being canonicalized (the "effective block") rather 
that the actual size of the block.
</p>
<p>Payload blocks are generally canonicalized as-is with the exception 
that in some instances only a portion of the payload data is to be 
protected. In such a case, only those bytes are included in the canonical 
form, and additional ciphersuite parameters are required to specify 
which part of the payload is protected, as discussed further below. 
</p>
<p>Security blocks are handled likewise, except that the ciphersuite 
will likely specify that the "current" security block security 
result field not be considered part of the canonical form. This 
differs from the strict canonicalisation case since we might use 
the mutable canonicalisation algorithm to handle sequential 
signatures such that signatures cover earlier ones.
</p>
<p>ESBs MUST NOT be included in the canonicalization.
</p>
<p>Notes:
</p>
<blockquote class="text">
<p>- The canonical form of the bundle is not transmitted. It is 
simply an artifact used as input to digesting.
</p>
<p>- We omit the reserved flags because we cannot determine if 
they will change in transit. The masks specified above will have to be 
revised if additional flags are defined and they need to be protected. 
</p>
<p>- Our URI encoding does not preserve the "null-termination" convention 
from the dictionary field, nor do we separate the scheme and the 
scheme-specific part (SSP) as is done there.
</p>
<p>- The URI encoding will cause errors if any node rewrites the 
dictionary content (e.g. changing the DNS part of an HTTP URL from 
lower-case to upper case).  This could happen transparently when 
a bundle is synched to disk using one set of software and then read from disk 
and forwarded by a second set of software. Because there are no general 
rules for canonicalising URIs (or IRIs), this problem may be an 
unavoidable source of integrity failures.
</p>
<p>- All SDNV fields here are canonicalized as eight-byte unpacked values 
in network byte order. Length fields are canonicalized as four-byte values 
in network byte order. Encoding does not need optimization since the values 
are never sent over the network.
</p>
<p>If a bundle is fragmented before the PIB is applied then the PIB applies 
to a fragment and not the entire bundle. However, the protected fragment could 
be subsequently further fragmented, which would leave the verifier unable to 
know which bytes were protected by the PIB. Even in the absence of fragmentation 
the same situation applies if the ciphersuite is defined to allow protection 
of less than the entire, original bundle payload. 
</p>
<p>For this reason, PIB ciphersuites which support applying a PIB to less than 
the complete, original bundle payload MUST specify, as part of the ciphersuite 
parameters, which bytes of the bundle payload are protected. When verification 
occurs, only the specified range of the payload bytes are input to PIB verification. 
It is valid for a ciphersuite to be specified so as to only apply to 
entire bundles and not to fragments. A ciphersuite MAY be specified to 
apply to only a portion of the payload, regardless of whether the 
payload is a fragment or the complete original bundle payload. 
</p>
<p>The same fragmentation issue applies equally to PCB ciphersuites. 
Ciphersuites which support applying confidentiality to fragments MUST specify, 
as part of the ciphersuite parameters, which bytes of the bundle payload are 
protected. When decrypting a fragment, only the specified bytes are processed. 
It is also valid for a confidentiality ciphersuite to be specified so as to 
only apply to entire bundles and not to fragments.
</p>
</blockquote>
<p>This definition of mutable canonicalization assumes that endpoint IDs 
themselves are immutable and is unsuitable for use in environments where 
that assumption might be violated. 
</p>
<p>The canonicalization applies to a specific bundle and not a specific payload. 
If a bundle is forwarded in some way, the recipient is not able to verify the 
original integrity signature since the the source EID will be different, and 
possibly other fields.
</p>
<p>The solution for either of these issues is to define and use a PIB 
ciphersuite having an alternate version of mutable canonicalization 
any fields from the primary block.
</p>
<a name="srcPCB"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Endpoint ID confidentiality</h3>

<p>Every bundle MUST contain a primary block that contains the source and 
destinations endpoint IDs, and others, and that cannot be encrypted. 
If endpoint ID confidentiality is required, then bundle-in-bundle 
encapsulation can solve this problem in some instances.
</p>
<p>Similarly, confidentiality requirements MAY also apply to other 
parts of the primary block (e.g. the current-custodian) and that is 
supported in the same manner.
</p>
<a name="sec.bon"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Bundles received from other nodes</h3>

<p>Nodes implementing this specification SHALL consult their security policy to 
determine whether or not a received bundle is required by policy to include a 
BAB. If the bundle has no BAB and one is not required then BAB processing on 
the received bundle is complete and the bundle is ready to be further processed 
for PIB/PCB/ESB handling or delivery or forwarding.  
</p>
<p>If the bundle is required to have a BAB but does not, then the bundle 
MUST be discarded and processed no further. If the bundle is required to have 
a BAB but all of its BABs identify a different node other than the receiving node 
as the BAB security destination, then the bundle MUST be discarded and processed 
no further.
</p>
<p>If the bundle is required to have a BAB and has one or more BABs that 
identify the receiving node as the BAB security destination, 
or for which there is no security destination, then 
the value in the security result field(s) of the BAB(s) MUST be verified according 
to the ciphersuite specification. If for all such BABs in the bundle either the BAB 
security source cannot be determined or the security result value check fails, 
the bundle has failed to authenticate and the bundle MUST be discarded and 
processed no further. If any of the BABs present verify, or if a BAB is 
not required, the bundle is ready for further processing as determined 
by extension blocks and/or policy.
</p>
<p>BABs received in a bundle MUST be stripped before the bundle is forwarded. 
New BABs MAY be added as required by policy. This MAY require correcting the 
"last block" field of the to-be-forwarded bundle.
</p>
<p>Further processing of the bundle MUST take place in the order indicated by the 
various blocks from the primary block to the payload block, except as defined by 
an applicable specification.
</p>
<p>If the bundle has a PCB and the receiving node is the PCB destination for the 
bundle (either because the node is listed as the bundle's PCB-dest or because 
the node is listed as the bundle's destination and there is no PCB-dest), the node 
MUST decrypt the relevant parts of the bundle in accordance with the ciphersuite 
specification. The PCB SHALL be deleted. If the relevant parts of the bundle 
cannot be decrypted (i.e. the decryption key cannot be deduced or decryption fails), 
then the bundle MUST be discarded and processed no further; in this case a bundle 
deletion status report (see the Bundle Protocol <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>) indicating 
the decryption failure MAY be generated. If the PCB security result included the 
ciphertext of a block other than the payload block, the recovered plaintext block 
MUST be placed in the bundle at the location from which the PCB was deleted.
</p>
<p>If the bundle has one or more PIBs for which the receiving node is the bundle's PIB 
destination (either because the node is listed in the bundle's PIB-dest or because the 
node is listed as the bundle's destination and there is no PIB-dest), the node MUST 
verify the value in the PIB security result field(s) in accordance with the ciphersuite 
specification. If all the checks fail, the bundle has failed to authenticate and the bundle 
SHALL be processed according to the security policy. A bundle status report indicating the 
failure MAY be generated. 
Otherwise, if the PIB verifies, the bundle is ready to be processed for either 
delivery or forwarding. Before forwarding the bundle, the node SHOULD remove 
the PIB from the bundle, subject to the requirements of <a class='info' href='#sec.stack'>Section&nbsp;3.2<span> (</span><span class='info'>Processing order of security blocks</span><span>)</span></a>, 
unless it is likely that some downstream node will also be able to verify the PIB.
</p>
<p>If the bundle has a PIB and the receiving node is not the bundle's PIB-dest 
the receiving node MAY attempt to verify the value in the security result field. 
If it is able to check and the check fails, the node SHALL discard the bundle 
and it MAY send a bundle status report indicating the failure.
</p>
<p>If the bundle has an ESB and the receiving node is the ESB destination for the 
bundle (either because the node is listed as the bundle's ESB-dest or because 
the node is listed as the bundle's destination and there is no ESB-dest), 
the node MUST decrypt and/or decapsulate the encapsulated block in accordance with the 
ciphersuite specification. The decapsulated block replaces the ESB in the bundle 
block sequence, and the ESB is thereby deleted. If the content 
cannot be decrypted (i.e., the decryption key cannot be deduced or decryption fails), 
then the bundle MAY be discarded and processed no further unless the security policy 
specifies otherwise. In this case a bundle deletion status report (see the Bundle Protocol 
<a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>) indicating the decryption failure MAY be generated. 
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
The At-Most-Once-Delivery Option</h3>

<p>An application MAY request (in an implementation specific manner) 
that a node be registered as a member of an 
endpoint and that received bundles destined for that endpoint be 
delivered to that application.  
</p>
<p>An option for use in such cases is known as 
"at-most-once-delivery".  If this option is chosen, the application 
indicates that it wants the node to check for duplicate bundles, discard 
duplicates, and deliver at most one copy of each received bundle to the 
application. If this option is not chosen, the application indicates that 
it wants the node to deliver all received bundle copies to the application. 
If this option is chosen, the node SHALL deliver at most one copy of each 
received bundle to the application. If the option is not chosen, the node 
SHOULD, subject to policy, deliver all bundles.
</p>
<p>To enforce this the node MUST look at the source/timestamp pair value of 
each complete (reassembled, if necessary) bundle received and determine if this 
pair, which uniquely identifies a bundle, has been previously received. 
If it has, then the bundle is a duplicate. 
If it has not, then the bundle is not a duplicate. The source/timestamp pair 
SHALL be added to the list of pair values already received by that node.  
</p>
<p>Each node implementation MAY decide how long to maintain a table of 
pair value state.
</p>
<p>Additional discussion relevant to at-most-once-delivery is in the 
DTN Retransmission Block specification <a class='info' href='#DTNRB'>[DTNRB]<span> (</span><span class='info'>Symington, S., &ldquo;Delay-Tolerant Network Retransmission Block,&rdquo; April&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="frag"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8"></a><h3>3.8.&nbsp;
Bundle Fragmentation and Reassembly</h3>

<p>If it is necessary for a node to fragment a bundle and security 
services have been applied to that bundle, the fragmentation rules 
described in <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a> 
MUST be followed. As defined there and repeated here for completeness, 
only the payload MAY be fragmented; security blocks, like all 
extension blocks, can never be fragmented. In addition, the following 
security-specific processing is REQUIRED:
</p>
<p>The security policy requirements for a bundle MUST be applied 
individually to all the bundles resulting from a fragmentation event.
</p>
<p>If the original bundle contained a PIB, then each of the PIB instances 
MUST be included in some fragment.
</p>
<p>If the original bundle contained one or more PCBs, then any PCB instances 
containing a key information item MUST have the "replicate in every fragment" 
flag set, and thereby be replicated in every fragment. This is to ensure 
that the canonical block-sequence can be recovered during reassembly.
</p>
<p>If the original bundle contained one or more correlated PCBs not 
containing a key information item, then each of these MUST be included in 
some fragment, but SHOULD NOT be sent more than once. 
They MUST be placed in a fragment in accordance with the fragmentation 
rules described in <a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>.
</p>
<p>Note: various fragments MAY have additional security blocks added at this 
or later stages and it is possible that correlators will collide. In order to 
facilitate uniqueness, ciphersuites SHOULD include the fragment-offset of the 
fragment as a high-order component of the correlator.
</p>
<a name="reactive"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.9"></a><h3>3.9.&nbsp;
Reactive fragmentation</h3>

<p>When a partial bundle 
has been received, the receiving node SHALL consult its security policy to 
determine if it MAY fragment the bundle, converting the received portion 
into a bundle fragment for further forwarding. Whether or not 
reactive fragmentation is permitted SHALL depend on the security policy 
and the ciphersuite used to calculate the BAB authentication information, 
if required. (Some BAB ciphersuites, i.e., the mandatory BAB-HMAC 
ciphersuite defined in <a class='info' href='#BABhmac'>Section&nbsp;4.1<span> (</span><span class='info'>BAB-HMAC</span><span>)</span></a>, 
do not accommodate reactive fragmentation because 
the security result in the BAB requires that the entire bundle be signed. 
It is conceivable, however, that a BAB ciphersuite could be defined such that 
multiple security results are calculated, each on a different segment of a 
bundle, and that these security results could be interspersed between bundle 
payload segments such that reactive fragmentation could be accommodated.)
</p>
<p>If the bundle is reactively fragmented by the intermediate receiver 
and the BAB-ciphersuite is of an appropriate type (e.g. with multiple security 
results embedded in the payload), the bundle MUST be fragmented immediately 
after the last security result value in the partial payload that is received. 
Any data received after the last security result value MUST be dropped.  
</p>
<p>If a partial bundle is received at the intermediate receiver and is 
reactively fragmented and forwarded, only the part of the bundle that was not 
received MUST be retransmitted, though more of the bundle MAY be retransmitted. 
Before retransmitting a portion of the bundle, it SHALL be changed into a 
fragment and, if the original bundle included a BAB, the fragmented bundle 
MUST also, and its BAB SHALL be recalculated.  
</p>
<p>This specification does not currently define any ciphersuite which 
can handle this reactive fragmentation case.
</p>
<p>An interesting possibility is a ciphersuite definition such that the 
transmission of a follow-up fragment would be accompanied by the signature 
for the payload up to the restart point.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.10"></a><h3>3.10.&nbsp;
Attack Model</h3>

<p>An evaluation of resilience to cryptographic attack necessarily depends 
upon the algorithms chosen for bulk data protection and for key transport. 
The mandatory ciphersuites described in the following section use AES, RSA 
and SHA algorithms in ways that are believed to be reasonably secure against 
ciphertext-only, chosen-ciphertext, known-plaintext and chosen-plaintext 
attacks.
</p>
<p>The design has been careful to preserve the resilience of the algorithms 
against attack. For example, if a message is encrypted then any message 
integrity signature is also encrypted so that guesses cannot be confirmed.
</p>
<a name="ciphersuites"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Mandatory Ciphersuites</h3>

<p>This section defines the mandatory ciphersuites for this specification.
There is currently one mandatory ciphersuite for use with each of the 
security block types BAB, PIB, PCB and ESB. 
The BAB ciphersuite is based on shared secrets using HMAC. The PIB 
ciphersuite is based on digital signatures using RSA with SHA256. The 
PCB and ESB ciphersuites are based on using RSA for key transport and 
AES for bulk encryption.
</p>
<p>The key transport mechanisms defined in Cryptographic Message Syntax 
<a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> are suitable for the ciphersuites, with only minor 
adjustment as required by the ciphersuite characteristics. 
</p>
<a name="BABhmac"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
BAB-HMAC</h3>

<p>The BAB-HMAC ciphersuite has ciphersuite ID value 0x001.
</p>
<p>BAB-HMAC uses the strict canonicalisation algorithm in 
<a class='info' href='#strictC14N'>Section&nbsp;3.4.1<span> (</span><span class='info'>Strict canonicalisation</span><span>)</span></a>.
</p>
<p>Strict canonicalization supports digesting of a fragment-bundle. 
It does not permit the digesting of only a subset of the 
payload, but only the complete contents of the payload of the 
current bundle, which might be a fragment. 
The "fragment range" item for security-parameters is not 
used to indicate a fragment, as this information is digested 
within the primary block. 
</p>
<p>The variant of HMAC to be used is HMAC-SHA1 as defined in 
<a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>.
</p>
<p>This ciphersuite requires the use of two related instances of the BAB. It 
involves placing the first BAB instance (as defined in 
<a class='info' href='#sec.BAB'>Section&nbsp;2.2<span> (</span><span class='info'>Bundle Authentication Block</span><span>)</span></a>) just after the primary block.  The second 
(correlated) instance of the BAB MUST be placed after all other blocks 
(except possibly other BAB blocks) in the bundle.
</p>
<p>This means that normally, the BAB will be the second and last blocks of the 
bundle. If a forwarder wishes to apply more than one correlated BAB pair, then 
this can be done. There is no requirement that each application "wrap" the 
others, but the forwarder MUST insert all the "up front" BABs, and their "at back" 
"partners" (without any security result), before canonicalising.
</p>
<p>Inserting more than one correlated BAB pair would be useful if the bundle 
could be routed to more than one potential "next-hop" or if both an old or 
a new key were valid at sending time, with no certainty about the situation 
that will obtain at reception time.
</p>
<p>The security result is the output of the HMAC-SHA1 calculation with input 
being the result of running the entire bundle through the strict 
canonicalisation algorithm. Both required BAB instances MUST be included in the 
bundle before canonicalisation.
</p>
<p>Security parameters are optional with this scheme, but if 
used then the only field that can be present is key information 
(see <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>). 
</p>
<p>Implementations MUST support use of "AuthenticatedData" type as defined 
in <a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> section 9.1, with RecipientInfo type 
KeyTransRecipientInfo containing the issuer and serial number of a suitable 
certificate. They MAY support additional RecipientInfo types. 
They MAY additionally use the "SignedData" type described in 
<a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> Section 5.1. In either case, the optional 
"eContent" field in EncapsulatedContentInfo MUST be omitted. That is, the data 
itself is external, being the canonicalized form of the bundle. 
</p>
<p>Because this ciphersuite requires that the security result be in the 
second, correlated BAB, the content of the "MessageAuthenticationCode" 
field in AuthenticatedData is ignored, although the field has to be 
present. 
</p>
<p>In the absence of key information the receiver is expected to be able 
to find the correct key based on the sending identity. 
The sending identity MAY be known from the security-source field or 
the content of a previous-hop block in the bundle. It MAY also be 
determined using implementation-specific means such as the 
convergence layer. 
</p>
<a name="PIBrsasha"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
PIB-RSA-SHA256</h3>

<p>The PIB-RSA-SHA256 ciphersuite has ciphersuite ID value 0x02.
</p>
<p>If the bundle being signed has been fragmented before signing, then 
we have to specify which bytes were signed in case the signed bundle 
is subsequently fragmented for a second time. If the bundle is a 
fragment, then the ciphersuite parameters MUST include a fragment-range 
field, as described in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>, 
specifying the offset and length of the signed fragment. 
If the entire bundle is signed then these numbers MUST be omitted.
</p>
<p>Implementations MUST support use of "SignedData" type as defined 
in <a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> section 5.1, with SignerInfo type 
SignerIdentifier containing the issuer and serial number of a suitable 
certificate. The optional 
"eContent" field in EncapsulatedContentInfo MUST be omitted. That is, the data 
itself is external, being the canonicalized form of the bundle. 
</p>
<p>Because the signature field in SignedData SignatureValue is a 
security-result field, the entire key information item MUST be 
placed in the block's security-result field, rather than 
security-parameters. 
</p>
<p>PIB-RSA-SHA256 uses the mutable canonicalisation algorithm 
<a class='info' href='#mutableC14N'>Section&nbsp;3.4.2<span> (</span><span class='info'>Mutable canonicalisation</span><span>)</span></a>, with the security-result data field for only 
the "current" block being excluded from the canonical form. The resulting 
canonical form of the bundle is the input to the signing process. 
This ciphersuite requires the use of a single instance of the PIB.
</p>
<p>RSA is used with SHA256 as specified for the id-sha256 PKCSv2.1 
signature scheme in <a class='info' href='#RFC4055'>[RFC4055]<span> (</span><span class='info'>Schaad, J., Kaliski, B., and R. Housley, &ldquo;Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509  Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; June&nbsp;2005.</span><span>)</span></a>. The output 
of the signing process is the SignatureValue field for the PIB.
</p>
<p>"Commensurate strength" cryptography is generally held to be a good idea. A 
combination of RSA with SHA256 is reckoned to require a 3076 bit RSA key 
according to this logic. Few implementations will choose this length by default 
(and probably some just won't support such long keys). Since this is an 
experimental protocol, we expect that 1024 or 2048 bit RSA keys will be used in 
many cases, and that that will be fine since we also expect that the hash 
function "issues" will be resolved before any standard would be derived from 
this protocol.
</p>
<a name="rsaaes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
PCB-RSA-AES128-PAYLOAD-PIB-PCB</h3>

<p>The PCB-RSA-AES128-PAYLOAD-PIB-PCB ciphersuite has ciphersuite ID value 0x003.
</p>
<p>This scheme encrypts PIBs, PCBs and the payload. 
The key size for this ciphersuite is 128 bits.
</p>
<p>Encryption is done using the AES algorithm in Galois/Counter Mode (GCM) 
as described in <a class='info' href='#RFC5084'>[RFC5084]<span> (</span><span class='info'>Housley, R., &ldquo;Using AES-CCM and AES-GCM Authenticated Encryption in the Cryptographic Message Syntax (CMS),&rdquo; November&nbsp;2007.</span><span>)</span></a> [Note: 
parts of the following description are borrowed from RFC 4106]. 
</p>
<p>The choice of GCM avoids expansion of the payload, which causes 
problems with fragmentation/reassembly and custody transfer. 
GCM also includes authentication, essential in 
preventing attacks that can alter the decrypted plaintext or even 
recover the encryption key. 
</p>
<p>GCM is a block cipher mode of operation providing both 
confidentiality and data integrity.  The GCM 
encryption operation has four inputs: a secret key, 
an initialization vector (IV), a plaintext, and an input for 
additional authenticated data (AAD) which is not used here. 
It has two outputs, a ciphertext whose length is identical to 
the plaintext, and an authentication tag, also known as 
the Integrity Check Value (ICV). 
</p>
<p>For consistency with the description in <a class='info' href='#RFC5084'>[RFC5084]<span> (</span><span class='info'>Housley, R., &ldquo;Using AES-CCM and AES-GCM Authenticated Encryption in the Cryptographic Message Syntax (CMS),&rdquo; November&nbsp;2007.</span><span>)</span></a>, 
we refer to the GCM IV as a nonce. The same key and nonce 
combination MUST NOT be used more than once. The nonce has the 
following layout 
</p><br /><hr class="insert" />
<a name="nonce"></a>

<p> 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------+----------------+----------------+----------------+
|                               salt                                |
+----------------+----------------+----------------+----------------+
|                                                                   |
|                      initialization vector                        |
|                                                                   |
+----------------+----------------+----------------+----------------+
</pre></div>
<p> 
Nonce format. 

</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The salt field is a four-octet value, usually chosen at random. 
It MUST be the same for all PCBs which have the same correlator value. 
The salt need not be kept secret.
</p>
<p>The initialization vector (IV) is an eight-octet value, usually 
chosen at random. It MUST be different for all PCBs which have the 
same correlator value. The value need not be kept secret. 
</p>
<p>The key (bundle encryption key, BEK) is a sixteen-octet (128 bits) 
value, usually chosen at random. 
The value MUST be kept secret, as described below. 
</p>
<p>The integrity check value is a sixteen-octet value used 
to verify that the protected data has not been altered. 
The value need not be kept secret. 
</p>
<p>This ciphersuite requires the use of a single PCB instance 
to deal with payload confidentiality. If the bundle already contains PIBs 
or PCBs then the ciphersuite will create additional correlated blocks 
to protect these PIBs and PCBs. These "additional" blocks replace the 
original blocks on a one-for-one basis, so the number of blocks remains 
unchanged. All these related blocks MUST have 
the same correlator value. The term "first PCB" in this section 
refers to the single PCB if there is only one or, if there are several, 
then to the one containing the key information. 
This MUST be the first of the set. 
</p>
<p>First PCB - the first PCB MAY contain a correlator value, and MAY 
specify security-source and/or security-destination in the EID-list. 
If not specified, the bundle-source and bundle-destination respectively 
are used for these values, as with other ciphersuites. The block MUST 
contain security-parameters and security-result fields. Each field MAY 
contain several items formatted as described in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>.
</p>
<p>Security-parameters
</p>
<blockquote class="text">
<p>key information
</p>
<p>salt
</p>
<p>IV (this instance applies only to payload)
</p>
<p>fragment offset and length, if bundle is a fragment
</p>
</blockquote>
<p>Security-result
</p>
<blockquote class="text">
<p>ICV
</p>
</blockquote>
<p>Subsequent PCBs MUST contain a correlator value to link them 
to the first PCB. Security-source and security-destination are 
implied from the first PCB, however see the discussion in 
<a class='info' href='#sec.PCB'>Section&nbsp;2.4<span> (</span><span class='info'>Payload Confidentiality Block</span><span>)</span></a> concerning EID-list entries. 
They MUST contain security-parameters and security-result 
fields as follows:
</p>
<p>Security-parameters
</p>
<blockquote class="text">
<p>IV for this specific block
</p>
</blockquote>
<p>Security-result
</p>
<blockquote class="text">
<p>encapsulated block
</p>
</blockquote>
<p>The security-parameters and security-result fields in the 
subsequent PCBs MUST NOT contain any items other than 
these two. Items such as key and salt are supplied in the 
first PCB and MUST NOT be repeated. 
</p>
<p>Implementations MUST support use of "Enveloped-data" type as defined 
in <a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> section 6, with RecipientInfo type 
KeyTransRecipientInfo containing the issuer and serial number of a suitable 
certificate. They MAY support additional RecipientInfo types. 
The optional "eContent" field in EncryptedContentInfo MUST be omitted. 
That is, the data itself is external, being the payload of the bundle. 
</p>
<p>The Integrity Check Value from the AES-GCM encryption of the payload 
is placed in the security-result field of the first PCB. 
</p>
<p>If the bundle being encrypted is a fragment-bundle 
we have to specify which bytes are encrypted in case the bundle 
is subsequently fragmented again. If the bundle is a fragment 
the ciphersuite parameters MUST include a fragment-range 
field, as described in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>, 
specifying the offset and length of the encrypted fragment. 
Note that this is not the same pair of fields which appear in the 
primary block as "offset and length". The "length" in this case 
is the length of the fragment, not the original length. 
If the bundle is not a fragment then this field MUST be omitted.
</p>
<p>The confidentiality processing for payload and other blocks is 
different, mainly because the payload might be fragmented later 
at some other node. 
</p>
<p>For the payload, only the bytes of the bundle payload field are 
affected, being replaced by ciphertext. The salt, IV and key values 
specified in the first PCB are used to encrypt the payload, and the 
resultant authentication tag (ICV) is placed in an ICV item 
in the security-result field of that first PCB. The other bytes 
of the payload block, such as type, flags and length, are not 
modified. 
</p>
<p>For each PIB or PCB to be protected, the entire original block is 
encapsulated in a "replacing" PCB. This replacing PCB is placed in 
the outgoing bundle in the same position as the original block, 
PIB or PCB. As mentioned above, this is one-for-one replacement and 
there is no consolidation of blocks or mixing of data in any way. 
</p>
<p>The encryption process uses AES-GCM with the salt and key values 
from the first PCB, and an IV unique to this PCB. The process creates 
ciphertext for the entire original block, and an authentication tag 
for validation at the security destination. For this encapsulation 
process, unlike the processing of the bundle payload, the 
authentication tag is appended to the ciphertext for the block and 
the combination is stored into the "encapsulated block" item in 
security-result. 
</p>
<p>The replacing block, of course, also has the same correlator value 
as the first PCB with which it is associated. It also contains the 
block-specific IV in security-parameters, and the combination of 
original-block-ciphertext and authentication tag, stored as an 
"encapsulated block" item in security-result. 
</p>
<p>If the payload was fragmented after encryption then all those 
fragments MUST be present and reassembled before decryption. 
This process might be repeated several times at different 
destinations if multiple fragmentation actions have occurred. 
</p>
<p>The size of the GCM counter field limits the payload size to 
2^39 - 256 bytes, about half a terabyte. A future revision of 
this specification will address the issue of handling payloads 
in excess of this size. 
</p>
<a name="ESBrsaaes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
ESB-RSA-AES128-EXT</h3>

<p>The ESB-RSA-AES128-EXT ciphersuite has ciphersuite ID value 0x004.
</p>
<p>This scheme encrypts non-payload-related blocks. It MUST NOT be used 
to encrypt PIBs, PCBs or primary or payload blocks.
The key size for this ciphersuite is 128 bits.
</p>
<p>Encryption is done using the AES algorithm in Galois/Counter Mode (GCM) 
as described in <a class='info' href='#RFC5084'>[RFC5084]<span> (</span><span class='info'>Housley, R., &ldquo;Using AES-CCM and AES-GCM Authenticated Encryption in the Cryptographic Message Syntax (CMS),&rdquo; November&nbsp;2007.</span><span>)</span></a> [Note: 
parts of the following description are borrowed from RFC 4106]. 
</p>
<p>GCM is a block cipher mode of operation providing both 
confidentiality and data origin authentication.  The GCM 
authenticated encryption operation has four inputs: a secret key, 
an initialization vector (IV), a plaintext, and an input for 
additional authenticated data (AAD) which is not used here. 
It has two outputs, a ciphertext whose length is identical to 
the plaintext, and an authentication tag, also known as 
the Integrity Check Value (ICV). 
</p>
<p>For consistency with the description in <a class='info' href='#RFC5084'>[RFC5084]<span> (</span><span class='info'>Housley, R., &ldquo;Using AES-CCM and AES-GCM Authenticated Encryption in the Cryptographic Message Syntax (CMS),&rdquo; November&nbsp;2007.</span><span>)</span></a>, 
we refer to the GCM IV as a nonce. The same key and nonce 
combination MUST NOT be used more than once. The nonce has the 
following layout 
</p><br /><hr class="insert" />
<a name="nonceESB"></a>

<p> 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+----------------+----------------+---------------------------------+
|                               salt                                |
+----------------+----------------+---------------------------------+
|                                                                   |
|                      initialization vector                        |
|                                                                   |
+----------------+----------------+---------------------------------+
</pre></div>
<p> 
Nonce format. 

</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The salt field is a four-octet value, usually chosen at random. 
It MUST be the same for all ESBs which have the same correlator value. 
The salt need not be kept secret.
</p>
<p>The initialization vector (IV) is an eight-octet value, usually 
chosen at random. It MUST be different for all ESBs which have the 
same correlator value. The value need not be kept secret. 
</p>
<p>The data encryption key is a sixteen-octet (128 bits) 
value, usually chosen at random. 
The value MUST be kept secret, as described below. 
</p>
<p>The integrity check value is a sixteen-octet value used 
to verify that the protected data has not been altered. 
The value need not be kept secret. 
</p>
<p>This ciphersuite replaces each BP extension block to be protected 
with a "replacing" ESB, and each can be individually specified. 
</p>
<p>If a number of related BP extension blocks are to be protected they 
can be grouped as a correlated set and protected using a single key. 
These blocks replace the original blocks on a one-for-one basis, so 
the number of blocks remains unchanged. All these related blocks MUST 
have the same correlator value. The term "first ESB" in this section 
refers to the single ESB if there is only one or, if there are several, 
then to the one containing the key or key-identifier. 
This MUST be the first of the set. If the blocks are individually 
specified then there is no correlated set and each block is its own 
"first ESB".
</p>
<p>First ESB - the first ESB MAY contain a correlator value, and MAY 
specify security-source and/or security-destination in the EID-list. 
If not specified, the bundle-source and bundle-destination respectively 
are used for these values, as with other ciphersuites. The block MUST 
contain security-parameters and security-result fields. Each field MAY 
contain several items formatted as described in <a class='info' href='#sec.PRF'>Section&nbsp;2.6<span> (</span><span class='info'>Parameters and Result Fields</span><span>)</span></a>.
</p>
<p>Security-parameters
</p>
<blockquote class="text">
<p>key information
</p>
<p>salt
</p>
<p>IV for this specific block
</p>
<p>block type of encapsulated block (optional)
</p>
</blockquote>
<p>Security-result
</p>
<blockquote class="text">
<p>encapsulated block
</p>
</blockquote>
<p>Subsequent ESBs MUST contain a correlator value to link them 
to the first ESB. Security-source and security-destination are 
implied from the first ESB, however see the discussion in 
<a class='info' href='#sec.PCB'>Section&nbsp;2.4<span> (</span><span class='info'>Payload Confidentiality Block</span><span>)</span></a> concerning EID-list entries. 
Subsequent ESBs MUST contain security-parameters and 
security-result fields as follows:
</p>
<p>Security-parameters
</p>
<blockquote class="text">
<p>IV for this specific block
</p>
<p>block type of encapsulated block (optional)
</p>
</blockquote>
<p>Security-result
</p>
<blockquote class="text">
<p>encapsulated block
</p>
</blockquote>
<p>The security-parameters and security-result fields in the 
subsequent ESBs MUST NOT contain any items other than 
those listed. Items such as key and salt are supplied in the 
first ESB and MUST NOT be repeated. 
</p>
<p>Implementations MUST support use of "Enveloped-data" type as defined 
in <a class='info' href='#RFC5652'>[RFC5652]<span> (</span><span class='info'>Housley, R., &ldquo;Cryptographic Message Syntax (CMS),&rdquo; July&nbsp;2004.</span><span>)</span></a> section 6, with RecipientInfo type 
KeyTransRecipientInfo containing the issuer and serial number of a suitable 
certificate. They MAY support additional RecipientInfo types. 
The optional "eContent" field in EncryptedContentInfo MUST be omitted. 
That is, the data itself is external, being the content of the 
block being protected. 
</p>
<p>For each block to be protected, the entire original block is 
encapsulated in a "replacing" ESB. This replacing ESB is placed in 
the outgoing bundle in the same position as the original block. 
As mentioned above, this is one-for-one replacement and 
there is no consolidation of blocks or mixing of data in any way. 
</p>
<p>The encryption process uses AES-GCM with the salt and key values 
from the first ESB, and an IV unique to this ESB. The process creates 
ciphertext for the entire original block, and an authentication tag 
for validation at the security destination. The 
authentication tag is appended to the ciphertext for the block and 
the combination is stored into the "encapsulated block" item in 
security-result. 
</p>
<p>The replacing block, of course, also has the same correlator value 
as the first ESB with which it is associated. It also contains the 
block-specific IV in security-parameters, and the combination of 
original-block-ciphertext and authentication tag, stored as an 
"encapsulated block" item in security-result. 
</p>
<a name="sec.keymgmt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Key Management</h3>

<p>Key management in delay tolerant networks is recognized as a 
difficult topic and is one that this specification does not attempt 
to solve. However, solely in order to support implementation and 
testing, implementations SHOULD support:
</p>
<blockquote class="text">
<p>- The use of well-known RSA public keys for all ciphersuites.
</p>
<p>- Long-term pre-shared-symmetric keys for the BAB-HMAC ciphersuite.
</p>
</blockquote>
<p>Since endpoint IDs are URIs and URIs can be placed in X.509 
<a class='info' href='#RFC3280'>[RFC3280]<span> (</span><span class='info'>Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; April&nbsp;2002.</span><span>)</span></a> public key certificates (in 
the subjectAltName extension) implementations SHOULD support this way of 
distributing public keys. Implementations SHOULD NOT be very strict in how they 
process X.509 though, for example, it would probably not be correct to insist 
on Certificate Revocation List (CRL) checking in many DTN contexts.
</p>
<a name="sec.Defaults"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Default Security Policy</h3>

<p>Every node serves as a Policy Enforcement Point insofar as it enforces 
some policy that controls the forwarding and delivery of bundles via one or 
more convergence layer protocol implementation.  Consequently, every node SHALL 
have and operate according to 
its own configurable security policy, whether the policy be explicit or 
default. The policy SHALL specify: 
</p>
<blockquote class="text">
<p>Under what conditions received bundles SHALL be forwarded.  
</p>
<p>Under what conditions received bundles SHALL be required to include valid 
BABs.  
</p>
<p>Under what conditions the authentication information provided in a bundle's 
BAB SHALL be deemed adequate to authenticate the bundle.  
</p>
<p>Under what conditions received bundles SHALL be required to have valid PIBs and/or PCBs. 

</p>
<p>Under what conditions the authentication information provided in a bundle's 
PIB SHALL be deemed adequate to authenticate the bundle.  
</p>
<p>Under what conditions a BAB SHALL be added to a received bundle before that 
bundle is forwarded.  
</p>
<p>Under what conditions a PIB SHALL be added to a received bundle before that 
bundle is forwarded.  
</p>
<p>Under what conditions a PCB SHALL be added to a received bundle before that 
bundle is forwarded.  
</p>
<p>Under what conditions an ESB SHALL be applied to one or more blocks in
a received bundle before that bundle is forwarded.  
</p>
<p>The actions that SHALL be taken in the event that a received bundle does not 
meet the receiving node's security policy criteria.  
</p>
</blockquote>
<p>This specification does not address how security policies get distributed to 
nodes. It only REQUIRES that nodes have and enforce security policies.  
</p>
<p>If no security policy is specified at a given node, or if a security policy 
is only partially specified, that node's default policy regarding unspecified 
criteria SHALL consist of the following:
</p>
<blockquote class="text">
<p>Bundles that are not well-formed do not meet the security policy criteria. 

</p>
<p>The mandatory ciphersuites MUST be used.
</p>
<p>All bundles received MUST have a BAB which MUST be 
verified to contain a valid security result. If the bundle does not have a BAB, 
then the bundle MUST be discarded 
and processed no further; a bundle status report indicating the authentication 
failure MAY be generated.  
</p>
<p>No received bundles SHALL be required to have a PIB; if a received bundle 
does have a PIB, however, the PIB can be ignored unless the receiving 
node is the PIB-dest, in which case the PIB MUST be verified.  
</p>
<p>No received bundles SHALL be required to have a PCB; if a received bundle 
does have a PCB, however, the PCB can be ignored unless the receiving 
node is the PCB-dest, in which case the PCB MUST be processed. 
If processing of a PCB yields a PIB, that PIB SHALL be processed 
by the node according to the node's security policy. 
</p>
<p>A PIB SHALL NOT be added to a bundle before sourcing or forwarding it.
</p>
<p>A PCB SHALL NOT be added to a bundle before sourcing or forwarding it.
</p>
<p>A BAB MUST always be added to a bundle before that bundle is forwarded. 

</p>
<p>If a destination node receives a bundle that has a PIB-dest but 
the value in that PIB-dest is not the EID of the destination node, 
the bundle SHALL be delivered at that destination node. 

</p>
<p>If a destination node receives a bundle that has an ESB-dest but 
the value in that ESB-dest is not the EID of the destination node, 
the bundle SHALL be delivered at that destination node. 

</p>
<p>If a received bundle does not satisfy the node's security policy for any 
reason, then the bundle MUST be discarded and processed no further; in this 
case, a bundle deletion status report (see the Bundle Protocol 
<a class='info' href='#DTNBP'>[DTNBP]<span> (</span><span class='info'>Scott, K. and S. Burleigh, &ldquo;Bundle Protocol Specification,&rdquo; November&nbsp;2007.</span><span>)</span></a>) indicating the failure MAY be generated.  
</p>
</blockquote>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>If a BAB ciphersuite uses digital signatures but doesn't include 
the security destination (which for a BAB is the next host), then this allows 
the bundle to be sent to some node other than the intended adjacent node. 
Because the BAB will still authenticate, the receiving node might erroneously accept 
and forward the bundle. When asymmetric BAB ciphersuites are used, the security 
destination field SHOULD therefore be included in the BAB.
</p>
<p>If a bundle's PIB-dest is not the same as its destination, then some node 
other than the destination (the node identified as the PIB-dest) is expected to 
validate the PIB security result while the bundle is en route. However, if for 
some reason the PIB is not validated, there is no way for the destination to 
become aware of this. Typically, a PIB-dest will remove the PIB from the bundle 
after verifying the PIB and before forwarding it. However, if there is a 
possibility that the PIB will also be verified at a downstream node, the 
PIB-dest will leave the PIB in the bundle. Therefore, if a destination receives 
a bundle with a PIB that has a PIB-dest (which isn't the destination), this 
might, but does not necessarily, indicate a possible problem.
</p>
<p>If a bundle is fragmented after being forwarded by its PIB-source but before 
being received by its PIB-dest, the payload in the bundle MUST be reassembled 
before validating the PIB security result in order for the security result to 
validate correctly. Therefore, if the PIB-dest is not capable of performing 
payload reassembly, its utility as a PIB-dest will be limited to validating 
only those bundles that have not been fragmented since being forwarded from 
the PIB-source. Similarly, if a bundle is fragmented after being forwarded 
by its PIB-source but before being received by its PIB-dest, all fragments 
MUST be received at that PIB-dest in order for the bundle payload to be able 
to be reassembled. If not all fragments are received at the PIB-dest node, 
the bundle will not be able to be authenticated, and will therefore never 
be forwarded by this PIB-dest node.
</p>
<p>Specification of a security-destination other than the bundle destination 
creates a routing requirement that the bundle somehow be directed to the 
security-destination node on its way to the final destination. 
This requirement is presently private to the ciphersuite, since routing 
nodes are not required to implement security processing.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Conformance</h3>

<p>As indicated above, this document describes both BSP and ciphersuites. 
A conformant implementation MUST implement both BSP support and the four 
ciphersuites described in <a class='info' href='#ciphersuites'>Section&nbsp;4<span> (</span><span class='info'>Mandatory Ciphersuites</span><span>)</span></a>. It MAY also 
support other ciphersuites.
</p>
<p>Implementations that support BSP but not all four mandatory 
ciphersuites MUST claim only "restricted compliance" with this specification, 
even if they provide other ciphersuites.
</p>
<p>All implementations are strongly RECOMMENDED to provide at least a 
BAB ciphersuite. A relay node, for example, might not deal with end-to-end 
confidentiality and data integrity but it SHOULD exclude 
unauthorized traffic and perform hop-by-hop bundle verification.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>None at this time. If the bundle protocol becomes a standards track 
protocol, then we may want to consider having IANA establish a register of 
block types, and in particular for this specification a separate register of 
ciphersuite specifications.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="DTNBP">[DTNBP]</a></td>
<td class="author-text"><a href="mailto:kscott@mitre.org">Scott, K.</a> and S. Burleigh, &ldquo;<a href="http://tools.ietf.org/html/rfc5050">Bundle Protocol Specification</a>,&rdquo; RFC&nbsp;5050, November&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="DTNMD">[DTNMD]</a></td>
<td class="author-text"><a href="mailto:susan@mitre.org">Symington, S.</a>, &ldquo;Delay-Tolerant Networking Metadata Extension Block,&rdquo; draft-irtf-dtnrg-bundle-metadata-block-00.txt&nbsp;, June&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text"><a href="mailto:hugo@watson.ibm.com">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu">Bellare, M.</a>, and <a href="mailto:canetti@watson.ibm.com">R. Canetti</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2104.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a> and <a href="mailto:jkrey@isi.edu">J. Reynolds</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, October&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3280">[RFC3280]</a></td>
<td class="author-text">Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;<a href="http://tools.ietf.org/html/rfc3280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;3280, April&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3370">[RFC3370]</a></td>
<td class="author-text">Housley, R., &ldquo;<a href="http://tools.ietf.org/html/rfc3370">Cryptographic Message Syntax (CMS) Algorithms</a>,&rdquo; RFC&nbsp;3370, August&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4055">[RFC4055]</a></td>
<td class="author-text">Schaad, J., Kaliski, B., and R. Housley, &ldquo;<a href="http://tools.ietf.org/html/rfc4055">Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 
Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;4055, June&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4055.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4106">[RFC4106]</a></td>
<td class="author-text">Viega, J. and D. McGrew, &ldquo;<a href="http://tools.ietf.org/html/rfc4106">The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4106, June&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4106.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5652">[RFC5652]</a></td>
<td class="author-text">Housley, R., &ldquo;<a href="http://tools.ietf.org/html/rfc3852">Cryptographic Message Syntax (CMS)</a>,&rdquo; RFC&nbsp;3852, July&nbsp;2004.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="DTNRB">[DTNRB]</a></td>
<td class="author-text"><a href="mailto:susan@mitre.org">Symington, S.</a>, &ldquo;Delay-Tolerant Network Retransmission Block,&rdquo; draft-irtf-dtnrg-bundle-retrans-00.txt,&nbsp;work-in-progress, April&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="DTNarch">[DTNarch]</a></td>
<td class="author-text"><a href="mailto:vint@google.com">Cerf, V.</a>, Burleigh, S., Durst, R., Fall, K., Hooke, A., Scott, K., Torgerson, L., and H. Weiss, &ldquo;<a href="http://tools.ietf.org/html/rfc4838">Delay-Tolerant Network Architecture</a>,&rdquo; RFC&nbsp;4838, April&nbsp;2007 (<a href="ftp://ftp.rfc-editor.org/in-notes/rfc4838.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5084">[RFC5084]</a></td>
<td class="author-text">Housley, R., &ldquo;<a href="http://tools.ietf.org/html/rfc5084">Using AES-CCM and AES-GCM Authenticated Encryption in the Cryptographic Message Syntax (CMS)</a>,&rdquo; RFC&nbsp;5084, November&nbsp;2007.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Susan Flynn Symington</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">7515 Colshire Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">McLean, VA  22102</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 (703) 983-7209</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:susan@mitre.org">susan@mitre.org</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://mitre.org/">http://mitre.org/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Stephen Farrell</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Trinity College Dublin</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Distributed Systems Group</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Department of Computer Science</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Trinity College</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dublin  2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ireland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+353-1-608-1539</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:stephen.farrell@cs.tcd.ie">stephen.farrell@cs.tcd.ie</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Howard Weiss</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">SPARTA, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">7110 Samuel Morse Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Columbia, MD  21046</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-443-430-8089</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hsw@sparta.com">hsw@sparta.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Peter Lovell</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">SPARTA, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">7110 Samuel Morse Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Columbia, MD  21046</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-443-430-8052</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:peter.lovell@sparta.com">peter.lovell@sparta.com</a></td></tr>
</table>
</body></html>
