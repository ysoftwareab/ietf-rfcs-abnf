

Network Working Group                                      Eric C. Rosen
Internet Draft                                             Yakov Rekhter
Expiration Date: September 1997                            Daniel Tappan
                                                          Dino Farinacci
                                                            Guy Fedorkow
                                                     Cisco Systems, Inc.

                                                              March 1997


                 Label Switching: Label Stack Encodings


                      draft-rosen-tag-stack-01.txt

Status of this Memo

   This document is an Internet-Draft.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   To learn the current status of any Internet-Draft, please check the
   "1id-abstracts.txt" listing contained in the Internet-Drafts Shadow
   Directories on ftp.is.co.za (Africa), nic.nordu.net (Europe),
   munnari.oz.au (Pacific Rim), ds.internic.net (US East Coast), or
   ftp.isi.edu (US West Coast).

Abstract

   "Label Switching" [1] requires a set of procedures for augmenting
   network layer packets with "Label Stacks" (formerly called "Tag
   Stacks"), thereby turning them into "Labeled packets".  This document
   specifies the encoding to be used, on PPP data links and LAN data
   links, in order to produce a Labeled packet from a Label Stack and a
   network layer packet.

   This document also specifies rules and procedures for processing the
   various fields of the Label Stack encoding.







Rosen, et al.                                                   [Page 1]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997




Table of Contents

    1      Introduction  ...........................................   2
    1.1    Specification of Requirements  ..........................   3
    2      The Label Stack  ........................................   3
    2.1    Encoding the Label Stack  ...............................   3
    2.2    Determining the Network Layer Protocol  .................   6
    2.3    Processing the Time to Live Field  ......................   6
    2.3.1  Definitions  ............................................   6
    2.3.2  Protocol-independent rules  .............................   6
    2.3.3  IP-dependent rules  .....................................   7
    3      Fragmentation and Path MTU Discovery  ...................   7
    3.1    Terminology  ............................................   8
    3.2    Maximum Initially Labeled IP Datagram Size  .............   9
    3.3    When are Labeled IP Datagrams Too Big?  .................  10
    3.4    Processing Labeled IP Datagrams which are Too Big  ......  11
    3.5    Implications with respect to Path MTU Discovery  ........  12
    3.5.1  Tunneling through a Transit Routing Domain  .............  12
    3.5.2  Tunneling Private Addresses through a Public Backbone  ..  13
    4      Transporting Labeled Packets over PPP  ..................  13
    4.1    Introduction  ...........................................  13
    4.2    A PPP Network Control Protocol for Label Switching  .....  14
    4.3    Sending Labeled Packets  ................................  15
    4.4    Label Switching Control Protocol Configuration Options  .  15
    5      Transporting Labeled Packets over LAN Media  ............  16
    6      Security Considerations  ................................  16
    7      Authors' Addresses  .....................................  16
    8      References  .............................................  17





1. Introduction

   [1] describes a set of procedures for augmenting network layer
   packets with "Label Stacks" (formerly called "Tag Stacks"), thereby
   turning them into "Labeled packets".  This document specifies the
   encoding to be used, on PPP data links and LAN data links, in order
   to produce a Labeled packet from a Label Stack and a network layer
   packet.

   This document also specifies rules and procedures for processing the
   various fields of the Label Stack encoding.  Label Switching itself
   is independent of any particular network layer protocol; however,
   while most of the relevant procedures are independent of the network



Rosen, et al.                                                   [Page 2]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


   layer protocol, some procedures differ for different protocols.  In
   this document, we specify the protocol-independent procedures, but we
   specify protocol-dependent procedures only for IPv4.


1.1. Specification of Requirements

   In this document, several words are used to signify the requirements
   of the specification.  These words are often capitalized.

        MUST

        This word, or the adjective "required", means that the
        definition is an absolute requirement of the specification.

        MUST NOT

        This phrase means that the definition is an absolute prohibition
        of the specification.

        SHOULD

        This word, or the adjective "recommended", means that there may
        exist valid reasons in particular circumstances to ignore this
        item, but the full implications must be understood and carefully
        weighed before choosing a different course.

        MAY

        This word, or the adjective "optional", means that this item is
        one of an allowed set of alternatives.  An implementation which
        does not include this option MUST be prepared to interoperate
        with another implementation which does include the option.


2. The Label Stack

2.1. Encoding the Label Stack

   On both PPP and LAN data links, the Label Stack is represented as a
   sequence of Label Stack Entries.  Each Label Stack Entry is
   represented by 4 octets.  This is shown in Figure 1.









Rosen, et al.                                                   [Page 3]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Labe=
l
   |                Label                |rsvd |CoS|S|     TTL     | Stac=
k
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Entr=
y

                       Label:  Label Value, 19 bits
                       rsvd:   Reserved, 3 bits
                       CoS:    Class of Service, 2 bits
                       S:      Bottom of Stack, 1 bit
                       TTL:    Time to Live, 7 bits

                                 Figure 1


   The Label Stack Entries appear AFTER the data link layer headers, but
   BEFORE any network layer headers.  The top of the Label Stack appears
   earliest in the packet, and the bottom appears latest.  The network
   layer packet immediately follows the Label Stack Entry which has the
   S bit set.

   Each Label Stack Entry is broken down into the following fields:

      1. Bottom of Stack (S)

         This bit is set to one for the last entry in the Label Stack
         (i.e., for the bottom of the stack), and zero for all other
         Label Stack Entries.

      2. Time to Live (TTL)

         This seven-bit field is used to encode a time-to-live value.
         The processing of this field is described in section 2.3.

      3. Class of Service (CoS)

         This two-bit field is used to identify a "Class of Service".
         Presumably the setting of this field will affect the scheduling
         and/or discard algorithms which are applied to the packet as it
         is transmitted through the network.

         When an unlabeled packet is initially labeled, the value
         assigned to the CoS field in the Label Stack Entry is
         determined by policy.  Some possible policies are:







Rosen, et al.                                                   [Page 4]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


           - the CoS value is a function of the IP ToS value

           - the CoS value is a function of the packet's input interface

           - the CoS value is a function of the "flow type"

         Many other policies are also possible.

         When an additional Label is pushed onto the Stack of a packet
         that is already labeled:

           - in general, the value of the CoS field in the new top stack
             entry should be equal to the value of the CoS field of the
             old top stack entry;

           - however, in some cases, most likely at boundaries between
             network service providers, the value of the CoS field in
             the new top stack entry may be determined by policy.

      4. Reserved

         These three bits are reserved.  They MUST be set to zero when
         writing, and MUST be ignored when reading.

      5. Label Value

         This 19-bit field carries the actual value of the Label.

         When a Labeled packet is received, the Label value at the top
         of the Stack is looked up.  As a result of this lookup one
         learns:

            (a) all the information needed to forward the packet

            (b) the operation to be performed on the Label Stack before
                forwarding; this operation may be to replace the top
                Label Stack Entry with another, or to pop Entries off
                the Label Stack, or to push Entries on the Label Stack,
                or any combination of these operations.

         There are several reserved Label values:

              i. A value of 0 represents the "IPv4 Explicit NULL Label".
                 This Label value is only legal when it is the sole
                 Label Stack Entry.  It indicates that the Label Stack
                 must be popped, and the forwarding of the packet must
                 then be based on the IP header.




Rosen, et al.                                                   [Page 5]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


             ii. A value of 1 represents the "Router Alert Label".  This
                 Label value is legal anywhere in the Label Stack except
                 at the bottom.  When a received packet contains this
                 Label value at the top of the Label Stack, it is
                 delivered to a local software module for processing.
                 The actual forwarding of the packet is determined by
                 the Label beneath it in the stack.  However, before the
                 packet is forwarded, the Router Alert Label should be
                 pushed back onto its Label Stack.


2.2. Determining the Network Layer Protocol

   When the last Label is popped from the Label Stack, it is necessary
   to determine the particular network layer protocol which is being
   carried.  Since the Label header carries no explicit field to
   identify the network layer header, this must be inferable from the
   value of the Label which is popped.


2.3. Processing the Time to Live Field

2.3.1. Definitions

   The "incoming TTL" of a Labeled packet is defined to be the value of
   the TTL field in the Label Stack Entry which is at the top of the
   Label Stack when the packet is received.

   The "outgoing TTL" of a Labeled packet is defined to be the larger
   of:

      (a) one less than the incoming TTL,
      (b) zero.


2.3.2. Protocol-independent rules

   If the outgoing TTL of a Labeled packet is 0, then the Labeled packet
   MUST NOT be further forwarded; the packet's lifetime in the network
   is considered to have expired.

   Depending on the Label value in the Label Stack Entry, the packet MAY
   be silently discarded, or the packet MAY have its Label Stack
   stripped off, and passed as an unlabeled packet to the ordinary
   processing for network layer packets which have exceeded their
   maximum lifetime in the network.  However, even if the Label Stack is
   stripped, the packet MUST NOT be further forwarded.




Rosen, et al.                                                   [Page 6]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


   When a Labeled packet is forwarded, the TTL field of the Label Stack
   Entry at the top of the Label Stack must be set to the outgoing TTL
   value.

   Note that the outgoing TTL value is a function solely of the incoming
   TTL value, and is independent of whether any Labels are pushed or
   popped before forwarding.


2.3.3. IP-dependent rules

   When an IP packet is first Labeled, the TTL field of the Label Stack
   Entry is set to the smaller of 127 and the value of the IP TTL field.

   When a Label is popped, and the resulting Label Stack is empty, then:

      (a) if the value in the IP TTL field is less than or equal to 127,
          it MUST be replaced with the outgoing TTL value, as defined
          above;

      (b) if the value in the IP TTL field is greater than 127, then the
          new value of the IP TTL field MUST be set to:

               (Old_IP_TTL_value - 127 + Outgoing_TTL)


3. Fragmentation and Path MTU Discovery

   Just as it is possible to receive an unlabeled IP datagram which is
   too large to be transmitted on its output link, it is possible to
   receive a Labeled packet which is too large to be transmitted on its
   output link.

   It is also possible that a received packet (Labeled or unlabeled)
   which was originally small enough to be transmitted on that link
   becomes too large by virtue of having one or more additional Labels
   pushed onto its Label Stack.  In Label switching, a packet may grow
   in size if additional Labels get pushed on.  Thus if one receives a
   Labeled packet with a 1500-byte frame payload, and pushes on an
   additional Label, one needs to forward it as frame with a 1504-byte
   payload.

   This section specifies the rules for processing Labeled packets which
   are "too large".  In particular, it provides rules which ensure that
   hosts implementing RFC 1191 Path MTU Discovery will be able to
   generate IP datagrams that do not need fragmentation, even if they
   get Labeled as the traverse the network.




Rosen, et al.                                                   [Page 7]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


   In general, hosts which do not implement RFC 1191 Path MTU Discovery
   send IP datagrams which contain no more than 576 bytes; the
   probability that such datagrams will need to get fragmented, even if
   they get labeled, is very small, since the MTUs in use on most data
   links today are 1500 bytes or greater.  Some hosts that do not
   implement RFC 1191 Path MTU Discovery will generate IP datagrams
   containing 1500 bytes, as long as the IP Source and Destination
   addresses are on the same subnet.  These datagrams will not pass
   through routers, and hence will not get fragmented.  Unfortunately,
   some hosts will generate IP datagrams containing 1500 bytes, as long
   the IP Source and Destination addresses do not have the same classful
   network number.  This is the one case in which there is significant
   risk of fragmentation when such datagrams get labeled.

   This document specifies procedures which allow one to configure the
   network so that large datagrams from hosts which do not implement
   Path MTU Discovery get fragmented just once, when they are first
   labeled.  These procedures make it possible (assuming suitable
   configuration) to avoid any need to fragment packets which have
   already been Labeled.


3.1. Terminology

   With respect to a particular data link, we can use the following
   terms:

     - Frame Payload:

            The contents of a data link frame, excluding any data link
            layer headers or trailers (e.g., MAC headers, LLC headers,
            802.1q or 802.1p headers, PPP header, frame check sequences,
            etc.).

            When a frame is carrying an an unlabeled IP datagram, the
            Frame Payload is just the IP datagram itself.  When a frame
            is carrying a Labeled IP datagram, the Frame Payload
            consists of the Label Header and the IP datagram.

     - Conventional Maximum Frame Payload Size:

            The maximum Frame Payload size allowed by standards.  For
            example, the Conventional Maximum Frame Payload Size for
            ethernet is 1500 bytes.







Rosen, et al.                                                   [Page 8]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


     - True Maximum Frame Payload Size:

            The maximum size frame payload which can be sent and
            received properly by the interface hardware attached to the
            data link.

            On ethernet and 802.3 networks, it is believed that the True
            Maximum Frame Payload Size is 4-8 bytes larger than the
            Conventional Maximum Frame Payload Size (unless an 802.1q or
            802.1p header is present).  For example, it is believed that
            most ethernet equipment could correctly send and receive
            packets carrying a payload of 1504 or perhaps even 1508
            bytes, at least, as long as the ethernet header does not
            have an 802.1q or 802.1p field.

            On PPP links, the True Maximum Frame Payload Size may be
            virtually unbounded.

     - Effective Maximum Frame Payload Size for Labeled Packets:

            This is either be the Conventional Maximum Frame Payload
            Size or the True Maximum Frame Payload Size, depending on
            the capabilities of the equipment on the data link and the
            size of the ethernet header being used.

     - Initially Labeled IP Datagram

            Suppose that an unlabeled IP datagram is received at a
            particular Label Switching Router (LSR), and that the the
            LSR pushes on a Label before forwarding the datagram.  Such
            a datagram will be called an Initially Labeled IP Datagram
            at that LSR.

     - Previously Labeled IP Datagram

            An IP datagram which had already been Labeled before it was
            received by a particular LSR.


3.2. Maximum Initially Labeled IP Datagram Size

   Every Label Switching Router which is capable of

      (a) receiving an unlabeled IP datagram,
      (b) adding a Label Stack to the datagram, and






Rosen, et al.                                                   [Page 9]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


      (c) forwarding the resulting Labeled packet,

   MUST support a configuration parameter known as the "Maximum IP
   Datagram Size for Labeling", which may be set to a non-negative
   value.

   If this configuration parameter is set to zero, it has no effect.

   If it is set to a positive value, it is used in the following way.
   If:
      (a) an unlabeled IP datagram is received, and
      (b) that datagram does not have the DF bit set in its IP header,
          and
      (c) that datagram needs to be labeled before being forwarded, and
      (d) the size of the datagram (before labeling) exceeds the value
          of the parameter,
   then
      (a) the datagram must be broken into fragments, each of whose size
          is no greater than the value of the parameter, and
      (b) each fragment must be labeled and then forwarded.

   If this configuration parameter is set to a value of 1488, for
   example, then any unlabeled IP datagram containing more than 1488
   bytes will be fragmented before being labeled.  Each fragment will be
   capable of being carried on a 1500-byte data link, without further
   fragmentation, even if as many as three Labels are pushed onto its
   Label Stack.

   In other words, setting this parameter to a non-zero value allows one
   to eliminate all fragmentation of Previously Labeled IP Datagrams,
   but it may cause some unnecessary fragmentation of Initially Labeled
   IP Datagrams.

   Note that the parameter has no effect on IP Datagrams that have the
   DF bit set, which means that it has no effect on Path MTU Discovery.


3.3. When are Labeled IP Datagrams Too Big?

   A Labeled IP datagram whose size exceeds the Conventional Maximum
   Frame Payload Size of the data link over which it is to be forwarded
   MUST be considered to be "too big".

   A Labeled IP datagram whose size exceeds the True Maximum Frame
   Payload Size of the data link over which it is to be forwarded MAY be
   considered to be "too big".

   A Labeled IP datagram which is not "too big" MUST be transmitted



Rosen, et al.                                                  [Page 10]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


   without fragmentation.


3.4. Processing Labeled IP Datagrams which are Too Big

   If a Labeled IP datagram is "too big", and the DF bit is not set in
   its IP header, then the Label Switching Router MAY discard the
   datagram.

   Note that discarding such datagrams is a sensible procedure only if
   the "Maximum Initially Labeled IP Datagram Size" is set to a non-zero
   value in every Label Switching Router in the network which is capable
   of adding a Label Stack to an unlabeled IP datagram.

   If the Label Switching Router chooses not to discard a Labeled IP
   datagram which is too big, or if the DF bit is set in that datagram,
   then it MUST execute the following algorithm:

      1. Strip off the Label header to obtain the IP datagram.

      2. Let N be the number of bytes in the Label Stack (i.e, 4 times
         the number of Label Stack Entries).

      3. If the IP datagram does NOT have the "Don't Fragment" bit set
         in its IP header:

            a. convert it into fragments, each of which MUST be at least
               N bytes less than the Effective Maximum Frame Payload
               Size.

            b. Prepend each fragment with the same Label header that
               would have been on the original datagram had
               fragmentation not been necessary.

            c. Forward the fragments

      4. If the IP datagram has the "Don't Fragment" bit set in its IP
         header:

            a. the datagram MUST NOT be forwarded

            b. Create an ICMP Destination Unreachable Message:

                    i. set its Code field (RFC 792) to "Fragmentation
                       Required and DF Set",






Rosen, et al.                                                  [Page 11]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


                   ii. set its Next-Hop MTU field (RFC 1191) to the
                       difference between the Effective Maximum Frame
                       Payload Size and the value of N

            c. If possible, transmit the ICMP Destination Unreachable
               Message to the source of the of the discarded datagram.


3.5. Implications with respect to Path MTU Discovery

   The procedures described above for handling datagrams which have the
   DF bit set, but which are "too large", have an impact on the Path MTU
   Discovery procedures of RFC 1191.  Hosts which implement these
   procedures will discover an MTU which is small enough to allow n
   Labels to be pushed on the datagrams, without need for fragmentation,
   where n is the number of Labels that actually get pushed on along the
   path currently in use.

   In other words, datagrams from hosts that use Path MTU Discovery will
   never need to be fragmented due to the need to put on a Label header,
   or to add new Labels to an existing Label header.  (Also, datagrams
   from hosts that use Path MTU Discovery generally have the DF bit set,
   and so will never get fragmented anyway.)

   However, note that Path MTU Discovery will only work properly if, at
   the point where a Labeled IP Datagram's fragmentation needs to occur,
   it is possible to route to the packet's source address.  If this is
   not possible, then the ICMP Destination Unreachable message cannot be
   sent to the source.


3.5.1. Tunneling through a Transit Routing Domain

   Suppose one is using Label switching to "tunnel" through a transit
   routing domain, where the external routes are not leaked into the
   domain's interior routers.  If a packet needs fragmentation at some
   router within the domain, and the packet's source address is an
   external address, and the packet's DF bit is set, it is desirable to
   be able to originate an ICMP message at that router and have it
   routed correctly to the source of the fragmented packet.  However,
   that source is an external address, which is not known to the
   internal routers.

   Therefore, in order for Path MTU Discovery to work, in any routing
   domain in which external routes are not leaked into the interior
   routers, there MUST be a default route which causes all packets
   carrying external destination addresses to be sent to a border
   router.



Rosen, et al.                                                  [Page 12]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


   For example, one of the border routers may inject "default" into the
   IGP.


3.5.2. Tunneling Private Addresses through a Public Backbone

   In other cases where Label switching is used to tunnel through a
   routing domain, it may not be possible to route to the source address
   of a fragmented packet at all.  This would be the case, for example,
   if the IP addresses carried in the packet were private addresses, and
   Label Switching were being used to tunnel those packets through a
   public backbone.

   In such cases, the Label Switching Router at the transmitting end of
   the tunnel MUST be able to determine the MTU of the tunnel as a
   whole.  It SHOULD do this by sending packets through the tunnel to
   the tunnel's receiving endpoint, and performing Path MTU Discovery
   with those packets.  Then any time the transmitting endpoint of the
   tunnel needs to send a packet into the tunnel, and that packet has
   the DF bit set, and it exceeds the tunnel MTU, the transmitting
   endpoint of the tunnel MUST send the ICMP Destination Unreachable
   message to the source, with code "Fragmentation Required and DF set",
   and the Next-Hop MTU Field set as described above.


4. Transporting Labeled Packets over PPP

   The Point-to-Point Protocol (PPP) [PPP] provides a standard method
   for transporting multi-protocol datagrams over point-to-point links.
   PPP defines an extensible Link Control Protocol, and proposes a
   family of Network Control Protocols for establishing and configuring
   different network-layer protocols.

   This section defines the Network Control Protocol for establishing
   and configuring Label Switching over PPP.


4.1. Introduction

   PPP has three main components:

      1. A method for encapsulating multi-protocol datagrams.

      2. A Link Control Protocol (LCP) for establishing, configuring,
         and testing the data-link connection.






Rosen, et al.                                                  [Page 13]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


      3. A family of Network Control Protocols for establishing and
         configuring different network-layer protocols.

   In order to establish communications over a point-to-point link, each
   end of the PPP link must first send LCP packets to configure and test
   the data link.  After the link has been established and optional
   facilities have been negotiated as needed by the LCP, PPP must send
   Label Switching Control packets to enable the transmission of Labeled
   packets.  Once the Label Switching Control Protocol has reached the
   Opened state, Labeled packets can be sent over the link.

   The link will remain configured for communications until explicit LCP
   or Label Switching Control Protocol packets close the link down, or
   until some external event occurs (an inactivity timer expires or
   network administrator intervention).


4.2. A PPP Network Control Protocol for Label Switching

   The Label Switching Control Protocol (LSCP) is responsible for
   enabling and disabling the use of Label switching on a PPP link.  it
   uses the same packet exchange mechanism as the Link Control Protocol
   (LCP).  LSCP packets may not be exchanged until PPP has reached the
   Network-Layer Protocol phase.  LSCP packets received before this
   phase is reached should be silently discarded.

   The Label Switching Control Protocol is exactly the same as the Link
   Control Protocol [1] with the following exceptions:

      1. Frame Modifications

         The packet may utilize any modifications to the basic frame
         format which have been negotiated during the Link Establishment
         phase.

      2. Data Link Layer Protocol Field

         Exactly one LSCP packet is encapsulated in the PPP Information
         field, where the PPP Protocol field indicates type hex 80??
         (Label Switching).

      3. Code field

         Only Codes 1 through 7 (Configure-Request, Configure-Ack,
         Configure-Nak, Configure-Reject, Terminate-Request, Terminate-
         Ack and Code-Reject) are used.  Other Codes should be treated
         as unrecognized and should result in Code-Rejects.




Rosen, et al.                                                  [Page 14]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


      4. Timeouts

         LSCP packets may not be exchanged until PPP has reached the
         Network-Layer Protocol phase.  An implementation should be
         prepared to wait for Authentication and Link Quality
         Determination to finish before timing out waiting for a
         Configure-Ack or other response.  It is suggested that an
         implementation give up only after user intervention or a
         configurable amount of time.

      5. Configuration Option Types

         None.


4.3. Sending Labeled Packets

   Before any Labeled packets may be communicated, PPP must reach the
   Network-Layer Protocol phase, and the Label Switching Control
   Protocol must reach the Opened state.

   Exactly one Labeled packet is encapsulated in the PPP Information
   field, where the PPP Protocol field indicates either type hex 00??
   (Label Switching -- Unicast) or type hex 00?? (Label Switching --
   Multicast).  The maximum length of a Labeled packet transmitted over
   a PPP link is the same as the maximum length of the Information field
   of a PPP encapsulated packet.

   The format of the Information field itself is as defined in section
   2.

   Note that two codepoints are defined for Labeled packets; one for
   multicast and one for unicast.  Once the LSCP has reached the Opened
   state, both Label Switched multicasts and Label Switched unicasts can
   be sent over the PPP link.


4.4. Label Switching Control Protocol Configuration Options

   There are no configuration options.











Rosen, et al.                                                  [Page 15]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


5. Transporting Labeled Packets over LAN Media

   A pair of two byte ethertype values will be obtained, one
   representing "Label Switching -- Unicast" and one representing "Label
   Switching -- Multicast".

   These can be used with either the Ethernet encapsulation or the 802.3
   SNAP/SAP encapsulation to carry Labeled packets.

   Exactly one Labeled packet is carried in each frame.

   The Label Stack Entries immediately precede the network layer header,
   and follow any data link layer headers, including any VLAN headers
   that may exist.


6. Security Considerations

    Security considerations are not discussed in this document.


7. Authors' Addresses

   Eric C. Rosen Cisco Systems, Inc.  250 Apollo Drive Chelmsford, MA, 01=
824

   E-mail: erosen@cisco.com


   Dan Tappan
   Cisco Systems, Inc.
   250 Apollo Drive
   Chelmsford, MA, 01824

   E-mail: tappan@cisco.com

   Dino Farinacci
   Cisco Systems, Inc.
   170 Tasman Drive
   San Jose, CA, 95134

   E-mail: dino@cisco.com

   Yakov Rekhter
   Cisco Systems, Inc.
   170 Tasman Drive
   San Jose, CA, 95134

   E-mail: yakov@cisco.com



Rosen, et al.                                                  [Page 16]

=0C
Internet Draft        draft-rosen-tag-stack-01.txt            March 1997


   Guy Fedorkow
   Cisco Systems, Inc.
   250 Apollo Drive
   Chelmsford, MA, 01824

   E-mail: fedorkow@cisco.com


8. References

   [1] "Tag Switching Architecture - Overview", 1/9/97, draft-rekhter-
   tagswitch-arch-00.txt, Rekhter, Davie, Katz, Rosen, Swallow

   [2] "Internet Control Message Protocol", RFC 792, 9/81, Postel

   [3] "Path MTU Discovery", RFC 1191, 11/90, Mogul & Deering



































Rosen, et al.                                                  [Page 17]

