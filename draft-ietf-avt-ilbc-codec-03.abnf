LPC_FILTERORDER=10 LPC filter coefficients using the autocorrelation 
i=0,...,119 
i=0,...,BLOCKL-1 
    
lag=0,...,LPC_FILTERORDER; n=0,...,BLOCKL-lag-1 
    
i=1,...,LPC_FILTERORDER 
i=0,...,LPC_FILTERORDER 
    
i=1...LPC_FILTERORDER 
    
i=1...LPC_FILTERORDER 
    
LPC_CHIRP_WEIGHTDENUM = 0.4222 
    
nsub=1,...,NSUB-1  
start=1: start state in sub-frame 0 and 1 
start=2: start state in sub-frame 1 and 2 
start=3: start state in sub-frame 2 and 3 
    
start=1: start state in sub-frame 0 and 1 
start=2: start state in sub-frame 1 and 2 
start=3: start state in sub-frame 2 and 3 
start=4: start state in sub-frame 3 and 4 
start=5: start state in sub-frame 4 and 5 
    
STATE_SHORT_LEN=58 samples for 30 ms frames. The power of the first 
state_first=1: start state is first STATE_SHORT_LEN samples 
state_first=0: start state is last STATE_SHORT_LEN samples 
 
i=0...(LPC_FILTERORDER-1) 
    
k=0..(STATE_SHORT_LEN-1) 
    
CB_MEML=147 for the two/four 40 sample sub-blocks and 85 for the 
stage=0..2 
    
i=0...(LPC_FILTERORDER-1) 
    
lTarget=SUBL. 
 
CB_MAXGAIN=1.3: 
    
         |gain| < CB_MAXGAIN 
    
gain = (target*cbvec) / ||cbvec||^2 
    
gain = (target*cbvec) / ||cbvec||^2 
    
gainQ = scaleFact * gain_sqXTbl[index] 
    
i=0...(LPC_FILTERORDER-1) 
    
k=0..(STATE_SHORT_LEN-1) 
    
n=1,2,3,-1,-2,-3 
y = > pssq(i) * pssq_weight(i) 
         /__ 
i=-3,-2,-1,1,2,3 
    
z = C * y, where C = ||pssq(0)||/||y|| 
    
e = (pssq(0)-z)*(pssq(0)-z), and "*" means the dot product 
    
e = (b * ||pssq(0)||^2)                     (Constraint 2) 
    
z= A*y + B*pssq(0)  
     
A = sqrt((b-b^2/4)*(w00*w00)/ (w11*w00 + w10*w10)) and 
          
w11 = pssq(0)*pssq(0) 
w00 = y*y 
w10 = y*pssq(0)    (* symbolizes the dot product) 
 
B = 1 - b/2 - A * w10/w00 
    
dtmp=decblock[k]; 
dtmp=MIN_SAMPLE; 
dtmp=MAX_SAMPLE; 
mode=atoi(argv[1]); 
cfileid=NULL; 
starttime=clock()/(float)CLOCKS_PER_SEC;  
    
len=encode(&Enc_Inst, encoded_data, data); 
pli=1; 
len=decode(&Dec_Inst, decoded_data, encoded_data, pli); 
runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime); 
outtime = (float)((float)blockcount*(float)mode/1000.0); 
start = FrameClassify(iLBCenc_inst, residual); 
        
diff = STATE_LEN - iLBCenc_inst->state_short_len; 
en1 = 0; 
index = (start-1)*SUBL; 
en2 = 0; 
index = (start-1)*SUBL+diff; 
state_first = 1; 
start_pos = (start-1)*SUBL; 
state_first = 0; 
start_pos = (start-1)*SUBL + diff; 
meml_gotten = iLBCenc_inst->state_short_len; 
subcount=0; 
    
Nfor = iLBCenc_inst->nsub-start-1; 
    
        
Nback = start-1; 
    
        
meml_gotten = SUBL*(iLBCenc_inst->nsub+1-start); 
    
            
meml_gotten=CB_MEML; 
pbytes=bytes; 
pos=0; 
    
diff = STATE_LEN - iLBCdec_inst->state_short_len; 
        
start_pos = (start-1)*SUBL; 
start_pos = (start-1)*SUBL + diff; 
meml_gotten = iLBCdec_inst->state_short_len; 
subcount=0; 
    
Nfor = iLBCdec_inst->nsub-start-1; 
        
Nback = start-1; 
    
meml_gotten = SUBL*(iLBCdec_inst->nsub+1-start); 
            
meml_gotten=CB_MEML; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
pbytes=bytes; 
pos=0; 
    
start=0; 
state_first=0; 
idxForMax=0; 
mode = 0; 
mode = 0; 
mode = 0; 
mode = 0; 
    
check=LSF_check(lsfdeq, LPC_FILTERORDER,  
                   iLBCdec_inst->lpc_n); 
start=0; 
            
order_plus_one = LPC_FILTERORDER + 1; 
i=0; 
lag = 20; 
maxcc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],  
               &decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL); 
            
cc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],  
                   &decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag],  
                   ENH_BLOCKL); 
            
maxcc = cc; 
lag = ilag; 
po = Out; 
    
pi = &In[i]; 
pm = &mem[LPC_FILTERORDER-1]; 
pa = a; 
pi = &In[i]; 
pa = a; 
pos=cbvectors; 
pp=&tempbuff2[k]; 
pp1=&cbfiltersTbl[CB_FILTERLEN-1]; 
nrjRecursive = (float) 0.0; 
pp = buffer - low + 1; 
ppe = buffer - low; 
    
    
tmpIndex = startIndex+icount-20; 
    
ilow = icount-4; 
                
nrjRecursive = nrjRecursive + (*ppe)*(*ppe); 
crossDot = (float) 0.0; 
pp = buffer-icount; 
alfa = (float) 0.2; 
ppo = buffer-4; 
ppi = buffer-icount-4; 
weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi); 
pp = buffer - icount; 
measure = (float)-10000000.0; 
                
    
                     Internet Low Bit Rate Codec         October 2003 
    
measure = crossDot*crossDot*invenergy[tmpIndex]; 
measure = crossDot*crossDot*invenergy[tmpIndex]; 
ftmp = crossDot*invenergy[tmpIndex]; 
            
ilow = index-5; 
                
pp = buffer-index; 
alfa1 = (float)0.2; 
alfa = 0.0; 
ppo = buffer-5; 
ppi = buffer-index-5; 
weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi); 
pp = buffer - index; 
sRange=bLen-lag; 
ftmp1 = 0.0; 
ftmp2 = 0.0; 
ftmp3 = 0.0; 
lag=inlag-3; 
maxcc=maxcc_comp; 
gain=gain_comp; 
lag=i; 
max_per=per; 
lag=iLBCdec_inst->prevLag; 
max_per=iLBCdec_inst->per; 
use_gain=1.0; 
use_gain=(float)0.9; 
use_gain=(float)0.7; 
use_gain=(float)0.5; 
use_gain=(float)0.0; 
    
ftmp=(float)sqrt(max_per); 
pitchfact=(float)1.0; 
pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4); 
pitchfact=0.0; 
    
    
use_lag=lag; 
use_lag=2*lag; 
energy = 0.0; 
randlag = 50 + ((signed long) iLBCdec_inst->seed)%70; 
pick = i - randlag; 
                
pick = i - use_lag; 
                
gain=0.0; 
crit=array[0]-value; 
bestcrit=crit*crit; 
crit=array[i]-value; 
crit=crit*crit; 
            
bestcrit=crit; 
filterlength=2*hfl+1; 
        
hfl2=(int) (dim1/2); 
hfl=hfl2; 
filterlength=2*hfl+1; 
pu=useq1; 
pp = polyp[j]; 
ps = seq1+i; 
pp = polyp[j]; 
ps = seq1+i; 
pp = polyp[j]+q; 
ps = seq1+dim1-1; 
estSegPosRounded=(int)(estSegPos - 0.5); 
    
searchSegStartPos=estSegPosRounded-ENH_SLOP; 
        
searchSegStartPos=0; 
searchSegEndPos=estSegPosRounded+ENH_SLOP; 
        
searchSegEndPos=idatal-ENH_BLOCKL-1; 
corrdim=searchSegEndPos-searchSegStartPos+1; 
        
tloc=0; maxv=corrVecUps[0]; 
tloc=i; 
maxv=corrVecUps[i]; 
tloc2=(int)(tloc/ENH_UPS0); 
        
st=searchSegStartPos+tloc2-ENH_FL0; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
        
en=st+ENH_VECTL; 
            
fraction=tloc2*ENH_UPS0-tloc; 
        
psseq=sseq+k*ENH_BLOCKL; 
psseq=sseq+k*ENH_BLOCKL; 
w00 = w10 = w11 = 0.0; 
psseq=sseq+hl*ENH_BLOCKL; /* current block  */ 
w11=1.0; 
C = (float)sqrt( w00/w11); 
        
errs=0.0; 
psseq=sseq+hl*ENH_BLOCKL; 
err=psseq[i]-odata[i]; 
w00=1; 
denom = (w11*w00-w10*w10)/(w00*w00); 
            
A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom); 
B = -alpha0/2 - A * w10/w00; 
B = B+1; 
A= 0.0; 
B= 1.0; 
psseq=sseq+hl*ENH_BLOCKL; 
centerEndPos=centerStartPos+ENH_BLOCKL-1; 
        
psseq=sseq+ENH_BLOCKL*hl; 
psseq=sseq+q*ENH_BLOCKL; 
psseq=sseq+q*ENH_BLOCKL; 
ftmp1 = 0.0; 
ftmp2 = 0.0; 
enh_buf=iLBCdec_inst->enh_buf; 
enh_period=iLBCdec_inst->enh_period; 
        
plc_blockl=ENH_BLOCKL; 
plc_blockl=40; 
    
ioffset=0; 
i=3-ioffset; 
lag = 10; 
maxcc = xCorrCoef(downsampled+60+iblock* 
               ENH_BLOCKL_HALF, downsampled+60+iblock* 
               ENH_BLOCKL_HALF-lag, ENH_BLOCKL_HALF); 
cc = xCorrCoef(downsampled+60+iblock* 
                   ENH_BLOCKL_HALF, downsampled+60+iblock* 
                   ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF); 
                
maxcc = cc; 
lag = ilag; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset]; 
    
lag = inlag-1; 
maxcc = xCorrCoef(in, in+lag, plc_blockl); 
cc = xCorrCoef(in, in+ilag, plc_blockl); 
                
maxcc = cc; 
lag = ilag; 
inPtr=&in[lag-1]; 
            
enh_bufPtr1=&plc_pred[plc_blockl-1]; 
            
start=plc_blockl; 
start=lag; 
enh_bufPtr2=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl]; 
ftmp2=0.0; 
ftmp1=0.0; 
ftmp1=(float)sqrt(ftmp1/(float)plc_blockl); 
ftmp2=(float)sqrt(ftmp2/(float)plc_blockl); 
enh_bufPtr1=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl]; 
ftmp1 = (float) (i+1) / (float) (plc_blockl+1); 
Coef_ptr = &Coef[0]; 
In_ptr = &In[i]; 
state_ptr = &state[FILTERORDER_DS-2]; 
    
o = (float)0.0; 
            
stop = (i < FILTERORDER_DS) ? i + 1 : FILTERORDER_DS; 
    
o=(float)0.0; 
            
Coef_ptr = &Coef[0]; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
In_ptr = &In[i]; 
Coef_ptr = &Coef[i-lengthIn]; 
In_ptr = &In[lengthIn-1]; 
n=0; 
pp=residual; 
pp=residual+n*SUBL; 
n=iLBCenc_inst->nsub-1; 
pp=residual+n*SUBL; 
max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l]; 
max_ssqEn_n=1; 
max_ssqEn=(fssqEn[n-1]+bssqEn[n]) * 
                               ssqEn_win[l]; 
max_ssqEn_n=n; 
scale=maxIn; 
        
scale=(float)0.1; 
cb = gain_sq3Tbl; 
cb = gain_sq4Tbl; 
cb = gain_sq5Tbl; 
minmeasure=10000000.0; 
tindex=0; 
measure=(in-scale*cb[i])*(in-scale*cb[i]); 
            
tindex=i; 
minmeasure=measure; 
scale=(float)fabs(maxIn); 
        
scale=(float)0.1; 
base_size=lMem-cbveclen+1; 
        
k=index+cbveclen; 
k=2*(index-(lMem-cbveclen+1))+cbveclen; 
        
ihigh=k/2; 
ilow=ihigh-5; 
    
alfa1=(float)0.2; 
alfa=0.0; 
k=index-base_size+cbveclen; 
sFilt=lMem-k; 
memInd=sFilt+1-CB_HALFFILTERLEN; 
    
pos=cbvec; 
pp=&tempbuff2[memInd+n+CB_HALFFILTERLEN]; 
pp1=&cbfiltersTbl[CB_FILTERLEN-1]; 
k=2*(index-base_size- 
                   (lMem-cbveclen+1))+cbveclen; 
sFilt=lMem-k; 
memInd=sFilt+1-CB_HALFFILTERLEN; 
    
pos=&tmpbuf[sFilt]; 
pp=&tempbuff2[memInd+i+CB_HALFFILTERLEN]; 
pp1=&cbfiltersTbl[CB_FILTERLEN-1]; 
ihigh=k/2; 
ilow=ihigh-5; 
    
alfa1=(float)0.2; 
alfa=0.0; 
sum = 0; 
alpha = r[0] + r[1] * k[0]; 
    
sum = r[m + 1]; 
m_h = (m + 1) >> 1; 
sum = a[i+1] + k[m] * a[m - i]; 
invcoef = (float)1.0 - coef; 
chirp = coef; 
        
pos = 0; 
mindist = FLOAT_MAX; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
minindex = 0; 
dist = X[0] - CB[pos]; 
tmp = X[i] - CB[pos + i]; 
mindist = dist; 
minindex = j; 
cb_pos = 0; 
X_pos= 0; 
i = 0; 
pos=m*dim+k; 
                    
tmp=lsf[pos+1]; 
change=1; 
change=1; 
change=1; 
pi = &In[0]; 
po = &Out[0]; 
po = &Out[0]; 
pi = &In[0]; 
po = &Out[0]; 
po = &Out[0]; 
base_size=lMem-lTarget+1; 
        
base_size=lMem-lTarget+1+lTarget/2; 
tene=0.0; 
range = search_rangeTbl[block][stage]; 
    
max_measure = (float)-10000000.0; 
gain = (float)0.0; 
best_index = 0; 
    
crossDot=0.0; 
pp=buf+LPC_FILTERORDER+lMem-lTarget; 
ppe = energy; 
ppi = buf+LPC_FILTERORDER+lMem-lTarget-1; 
ppo = buf+LPC_FILTERORDER+lMem-1; 
    
pp=buf+LPC_FILTERORDER+lMem-lTarget; 
measure=(float)-10000000.0;  
                
measure = crossDot*crossDot*invenergy[0]; 
measure = crossDot*crossDot*invenergy[0]; 
ftmp = crossDot*invenergy[0]; 
            
best_index = 0; 
max_measure = measure; 
gain = ftmp; 
crossDot=0.0; 
pp = buf+LPC_FILTERORDER+lMem-lTarget-icount; 
    
measure=(float)-10000000.0; 
                    
measure = crossDot*crossDot*invenergy[icount]; 
measure = crossDot*crossDot*invenergy[icount]; 
ftmp = crossDot*invenergy[icount]; 
    
best_index = icount; 
max_measure = measure; 
gain = ftmp; 
base_index=best_index; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
    
sInd=0; 
eInd=range-1; 
sIndAug=20; 
eIndAug=39; 
sIndAug=0; 
eIndAug=0; 
sInd=base_index-CB_RESRANGE/2; 
eInd=sInd+CB_RESRANGE; 
                
sIndAug = 40 + sInd; 
eIndAug = 39; 
sInd=0; 
    
eInd = range; 
sIndAug = 20; 
sInd = 0; 
eInd = 0; 
eIndAug = 19 + CB_RESRANGE; 
                            
eInd = eIndAug-39; 
eIndAug = 39; 
sIndAug = 20 + sInd - (base_size-20); 
eIndAug = 39; 
sInd = 0; 
eInd = CB_RESRANGE - (eIndAug-sIndAug+1); 
sInd = 0; 
eInd = range; 
counter = sInd; 
ppe = energy+base_size; 
pp=cbvectors+lMem-lTarget; 
ppi = cbvectors + lMem - 1 - lTarget; 
ppo = cbvectors + lMem - 1; 
                
crossDot=0.0; 
pp=cbvectors + lMem - (counter++) - lTarget; 
    
measure=(float)-10000000.0; 
                    
measure = crossDot*crossDot* 
                           invenergy[icount]; 
measure = crossDot*crossDot*invenergy[icount]; 
ftmp = crossDot*invenergy[icount]; 
    
best_index = icount; 
max_measure = measure; 
gain = ftmp; 
gain = 0.0; 
gain = (float)CB_MAXGAIN; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
gain = gainquant(gain, 1.0, 32, &gain_index[stage]); 
gain = gainquant(gain, (float)fabs(gains[stage-1]), 
                       16, &gain_index[stage]); 
gain = gainquant(gain, (float)fabs(gains[stage-1]), 
                       8, &gain_index[stage]); 
pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage]; 
pp=cbvectors+lMem-lTarget- 
                       index[stage]+base_size; 
pp=buf+LPC_FILTERORDER+lMem- 
                           lTarget-index[stage]; 
pp=aug_vec; 
filterno=index[stage]/base_size; 
position=index[stage]-filterno*base_size; 
    
                    
pp=cbvectors+filterno*lMem-lTarget- 
                           index[stage]+filterno*base_size; 
pp=aug_vec; 
cene=0.0; 
    
j=gain_index[0]; 
    
ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i]; 
            
j=i; 
pos = 0; 
cb_pos = 0; 
pos = 0; 
cb_pos = 0; 
lsfdeq2 = lsfdeq + length; 
lp_length = length + 1; 
        
pos = lp_length; 
pos = 0; 
    
is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl; 
is = LPC_LOOKBACK; 
    
is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl; 
lsf2 = lsf + length; 
lsfdeq2 = lsfdeq + length; 
lp_length = length + 1;  
     
pos = lp_length; 
pos = 0; 
change=LSF_check(lsfdeq, LPC_FILTERORDER, iLBCenc_inst->lpc_n); 
omega = 0.0; 
old_omega = 0.0; 
    
old_p = FLOAT_MAX; 
old_q = FLOAT_MAX; 
        
pq_coef = p_pre; 
old = &old_p; 
pq_coef = q_pre; 
old = &old_q; 
hlp = (float)cos(omega * TWO_PI); 
hlp1 = (float)2.0 * hlp + pq_coef[0]; 
hlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +  
                   pq_coef[1]; 
hlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2]; 
hlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3]; 
hlp5 = hlp * hlp4 - hlp3 + pq_coef[4]; 
                
                
omega = old_omega; 
step_idx = 0; 
                        
step_idx = LSF_NUMBER_OF_STEPS; 
old_omega = omega; 
step = steps[step_idx]; 
LPC_HALFORDER = 10 for LPC applications), then we adjust  
hlp = (freq[LPC_FILTERORDER - 1] - freq[0]) /  
               (float) (LPC_FILTERORDER - 1); 
    
posLeft=8-(*pos); 
    
bitno=0; 
index-=((index>>(bitno-posLeft))<<(bitno-posLeft)); 
                
bitno-=posLeft; 
BitsLeft=8-(*pos); 
    
bitno=0; 
bitno-=BitsLeft; 
maxVal = state_frgqTbl[idxForMax]; 
maxVal = (float)pow(10,maxVal)/(float)4.5; 
            
tmp = &tmpbuf[LPC_FILTERORDER]; 
fout = &foutbuf[LPC_FILTERORDER]; 
    
tmpi = len-1-k; 
syntOut = &syntOutBuf[LPC_FILTERORDER]; 
        
toQ = in[n]-syntOut[n]; 
tmp = &tmpbuf[LPC_FILTERORDER]; 
fout = &foutbuf[LPC_FILTERORDER]; 
    
    
                     Internet Low Bit Rate Codec         October 2003 
    
maxVal = fout[0]; 
maxVal = fout[k]; 
maxVal=(float)fabs(maxVal); 
            
maxVal = 10.0; 
maxVal = (float)log10(maxVal); 
maxVal=state_frgqTbl[*idxForMax]; 
qmax = (float)pow(10,maxVal); 
scal = (float)(4.5)/qmax; 
po=Out; 
    
pi=&Out[i-1]; 
    
                     Internet Low Bit Rate Codec         October 2003 
    
pa=&a[1]; 
pm=&mem[LPC_FILTERORDER-1]; 
pi=&Out[i-1]; 
pa=&a[1]; 
