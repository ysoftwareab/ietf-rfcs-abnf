<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The WebSocket protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The WebSocket protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">HyBi Working Group</td><td class="header">I. Fette</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Google, Inc.</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">October 17, 2010</td></tr>
<tr><td class="header">Expires: April 20, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />The WebSocket protocol<br />draft-ietf-hybi-thewebsocketprotocol-03</h1>

<h3>Abstract</h3>

<p>The WebSocket protocol enables two-way communication between a user agent running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers. The protocol consists of an initial handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or &lt;iframe&gt;s and long polling).
</p>
<p>Please send feedback to the hybi@ietf.org mailing list.
</p>
<h3>Note</h3>

<p>This draft is meant to reflect changes in direction in the HyBi working group. There is not yet consensus on everything in this draft. Specifically, details about the framing are still under discussion, however this draft is much closer to what the group is discussing than the previous draft. There have also been proposals to change the handshake, so the handshake is also not in a final form.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 20, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Background<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Protocol overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Opening handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.4.</a>&nbsp;
Closing handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.5.</a>&nbsp;
Design philosophy<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">1.6.</a>&nbsp;
Security model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">1.7.</a>&nbsp;
Relationship to TCP and HTTP<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">1.8.</a>&nbsp;
Establishing a connection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">1.9.</a>&nbsp;
Subprotocols using the WebSocket protocol<br />
<a href="#anchor11">2.</a>&nbsp;
Conformance requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">2.1.</a>&nbsp;
Terminology<br />
<a href="#anchor13">3.</a>&nbsp;
WebSocket URLs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#parsing_ws_urls">3.1.</a>&nbsp;
Parsing WebSocket URLs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.2.</a>&nbsp;
Constructing WebSocket URLs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#valid_ws_urls">3.3.</a>&nbsp;
Valid WebSocket URLs<br />
<a href="#framing">4.</a>&nbsp;
Data Framing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.2.</a>&nbsp;
Base Framing Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.3.</a>&nbsp;
Fragmentation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#controlframes">4.4.</a>&nbsp;
Control Frames<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#closeframe">4.4.1.</a>&nbsp;
Close<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.4.2.</a>&nbsp;
Ping<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.4.3.</a>&nbsp;
Pong<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">4.5.</a>&nbsp;
Data Frames<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.6.</a>&nbsp;
Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.7.</a>&nbsp;
Extensibility<br />
<a href="#handshake">5.</a>&nbsp;
Opening Handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.1.</a>&nbsp;
Client Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">5.2.</a>&nbsp;
Server-side requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">5.2.1.</a>&nbsp;
Reading the client&#039;s opening handshake<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.2.2.</a>&nbsp;
Sending the server&#039;s opening handshake<br />
<a href="#anchor27">6.</a>&nbsp;
Error Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">6.1.</a>&nbsp;
Handling errors in UTF-8 from the server<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">6.2.</a>&nbsp;
Handling errors in UTF-8 from the client<br />
<a href="#closing_connection">7.</a>&nbsp;
Closing the connection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">7.1.</a>&nbsp;
Client-initiated closure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">7.2.</a>&nbsp;
Server-initiated closure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">7.3.</a>&nbsp;
Closure<br />
<a href="#anchor33">8.</a>&nbsp;
Known extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">8.1.</a>&nbsp;
Compression<br />
<a href="#anchor35">9.</a>&nbsp;
Security considerations<br />
<a href="#anchor36">10.</a>&nbsp;
IANA considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">10.1.</a>&nbsp;
Registration of ws: scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">10.2.</a>&nbsp;
Registration of wss: scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">10.3.</a>&nbsp;
Registration of the &quot;WebSocket&quot; HTTP Upgrade keyword<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">10.4.</a>&nbsp;
Sec-WebSocket-Key1 and Sec-WebSocket-Key2<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">10.5.</a>&nbsp;
Sec-WebSocket-Location<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">10.6.</a>&nbsp;
Sec-WebSocket-Origin<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">10.7.</a>&nbsp;
Sec-WebSocket-Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">10.8.</a>&nbsp;
Sec-WebSocket-Draft<br />
<a href="#anchor45">11.</a>&nbsp;
Using the WebSocket protocol from other specifications<br />
<a href="#anchor46">12.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">13.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Background</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>Historically, creating an instant messenger chat client as a Web application has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls.
</p>
<p>This results in a variety of problems:
          </p>
<ul class="text">
<li>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client, and a new one for each incoming message.
</li>
<li>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.
</li>
<li>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.
</li>
</ul><p>
        
</p>
<p>
          A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket protocol provides. Combined with the WebSocket API, it provides an alternative to HTTP polling for two-way communication from a Web page to a remote server. <a class='info' href='#WSAPI'>[WSAPI]<span> (</span><span class='info'>Hickson, I., &ldquo;The Web Sockets API,&rdquo; August&nbsp;2010.</span><span>)</span></a>
        
</p>
<p>The same technique can be used for a variety of Web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Protocol overview</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The protocol has two parts: a handshake, and then the data transfer.
</p>
<p>
          The handshake from the client looks as follows:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     GET /demo HTTP/1.1
     Host: example.com
     Connection: Upgrade
     Sec-WebSocket-Key2: 12998 5 Y3 1  .P00
     Sec-WebSocket-Protocol: sample
     Upgrade: WebSocket
     Sec-WebSocket-Key1: 4 @1  46546xW%0l 1 5
     Origin: http://example.com

     ^n:ds[4U
</pre></div>
<p>The handshake from the server looks as follows:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     HTTP/1.1 101 WebSocket Protocol Handshake
     Upgrade: WebSocket
     Connection: Upgrade
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-Location: ws://example.com/demo
     Sec-WebSocket-Protocol: sample

     8jKS'y:G*Co,Wxa-
</pre></div>
<p>The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in the HTTP specification.
</p>
<p>
          After the leading line in both cases come an unordered ASCII case-insensitive set of fields, one per line, that each match the following non-normative ABNF: <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> <a class='info' href='#ANSI.X3-4.1986'>[ANSI.X3&#8209;4.1986]<span> (</span><span class='info'>American National Standards Institute, &ldquo;Coded Character Set - 7-bit American Standard Code for Information Interchange,&rdquo; 1986.</span><span>)</span></a>
          <br />
<br />

        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 field         = 1*name-char colon [ space ] *any-char cr lf
 colon         = %x003A ; U+003A COLON (:)
 space         = %x0020 ; U+0020 SPACE
 cr            = %x000D ; U+000D CARRIAGE RETURN (CR)
 lf            = %x000A ; U+000A LINE FEED (LF)
 name-char     = %x0000-0009
                 / %x000B-000C
                 / %x000E-0039
                 / %x003B-10FFFF
                 ; a Unicode character other than
                 ; U+000A LINE FEED (LF),
                 ; U+000D CARRIAGE RETURN (CR),
                 ; or U+003A COLON (:)
 any-char      = %x0000-0009 / %x000B-000C / %x000E-10FFFF
                 ; a Unicode character other than
                 ; U+000A LINE FEED (LF)
                 ; or U+000D CARRIAGE RETURN (CR)
</pre></div>
<p>NOTE: The character set for the above ABNF is Unicode. The fields themselves are encoded as UTF-8.
</p>
<p>Lines that don&#039;t match the above production cause the connection to be aborted.
</p>
<p>Finally, after the last field, the client sends 10 bytes starting with 0x0D 0x0A and followed by 8 random bytes, part of a challenge, and the server sends 18 bytes starting with 0x0D 0x0A and followed by 16 bytes consisting of a challenge response. The details of this challenge and other parts of the handshake are described in the next section.
</p>
<p><br />
<br />

</p>
<p>Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.
</p>
<p>Clients and servers, after a successful handshake, transfer data back and forth in conceptual units referred to in this specification as &quot;messages&quot;. A message is a complete unit of data at an application level, with the expectation that many or most applications implementing this protocol (such as web user agents) provide APIs in terms of sending and receiving messages. The websocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced, or vice versa, e.g. by an intermediary.
</p>
<p>Data is sent on the wire in the form of frames that have an associated type. Broadly speaking, there are types for textual data, which is interpreted as UTF-8 text, binary data (whose interpretation is left up to the application), and control frames, which are not intended to carry data for the application, but instead for protocol-level signalling, such as to signal that the connection should be closed. This version of the protocol defines six frame types and leaves ten reserved for future use.
</p>
<p>The WebSocket protocol uses this framing so that specifications that use the WebSocket protocol can expose such connections using an event-based mechanism instead of requiring users of those specifications to implement buffering and piecing together of messages manually.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Opening handshake</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The opening handshake is intended to be compatible with HTTP-based server-side software, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client&#039;s handshake appears to HTTP servers to be a regular GET request with an Upgrade offer:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     GET / HTTP/1.1
     Upgrade: WebSocket
     Connection: Upgrade
</pre></div>
<p>Fields in the handshake are sent by the client in a random order; the order is not meaningful.
</p>
<p>Additional fields are used to select options in the WebSocket protocol. The only options available in this version are the subprotocol selector, |Sec-WebSocket-Protocol|, and |Cookie|, which can used for sending cookies to the server (e.g. as an authentication mechanism). The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket protocol) are acceptable to the client. The server selects one of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     Sec-WebSocket-Protocol: chat superchat</pre></div>
<p>The other fields in the handshake are all security-related. The |Host| field is used to protect against DNS rebinding attacks and to allow multiple domains to be served from one IP address.<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     Host: example.com</pre></div>
<p>The server includes the hostname in the |Sec-WebSocket-Location| field of its handshake, so that both the client and the server can verify that they agree on which host is in use.
</p>
<p>The |Origin| field is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the |WebSocket| API in a Web browser. The server specifies which origin it is willing to receive requests from by including a |Sec-WebSocket-Origin| field with that origin. If multiple origins are authorized, the server echoes the value in the |Origin| field of the client&#039;s handshake.<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     Origin: http://example.com</pre></div>
<p>Finally, the server has to prove to the client that it received the client&#039;s WebSocket handshake, so that the server doesn&#039;t accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully-crafted packets using |XMLHttpRequest| or a |form| submission.
</p>
<p>To prove that the handshake was received, the server has to take three pieces of information and combine them to form a response. The first two pieces of information come from the |Sec-WebSocket-Key1| and |Sec-WebSocket-Key2| fields in the client handshake:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     Sec-WebSocket-Key1: 18x 6]8vM;54 *(5:  {   U1]8  z [  8
     Sec-WebSocket-Key2: 1_ tx7X d  &lt;  nw  334J702) 7]o}` 0
</pre></div>
<p>For each of these fields, the server has to take the digits from the value to obtain a number (in this case 1868545188 and 1733470270 respectively), then divide that number by the number of spaces characters in the value (in this case 12 and 10) to obtain a 32-bit number (155712099 and 173347027). These two resulting numbers are then used in the server handshake, as described below.
</p>
<p>
          The counting of spaces is intended to make it impossible to smuggle this field into the resource name; making this even harder is the presence of <em>two</em> such fields, and the use of a newline as the only reliable indicator that the end of the key has been reached. The use of random characters interspersed with the spaces and the numbers ensures that the implementor actually looks for spaces and newlines, instead of being treating any character like a space, which would make it again easy to smuggle the fields into the path and trick the server. Finally, <em>dividing</em> by this number of spaces is intended to make sure that even the most naïve of implementations will check for spaces, since if ther server does not verify that there are some spaces, the server will try to divide by zero, which is usually fatal (a correct handshake will always have at least one space).
        
</p>
<p>The third piece of information is given after the fields, in the last eight bytes of the handshake, expressed here as they would be seen if interpreted as UTF-8:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     Tm[K T2u</pre></div>
<p>The concatenation of the number obtained from processing the |Sec-WebSocket-Key1| field, expressed as a big-endian 32 bit number, the number obtained from processing the |Sec-WebSocket-Key2| field, again expressed as a big-endian 32 bit number, and finally the eight bytes at the end of the handshake, form a 128 bit string whose MD5 sum is then used by the server to prove that it read the handshake.
</p>
<p>
          <br />
<br />

        
</p>
<p>The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101 (the HTTP version and reason phrase aren&#039;t important):<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     HTTP/1.1 101 WebSocket Protocol Handshake</pre></div>
<p>The fields follow. Two of the fields are just for compatibility with HTTP:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     Upgrade: WebSocket
     Connection: Upgrade
</pre></div>
<p>Two of the fields are part of the security model described above, echoing the origin and stating the exact host, port, resource name, and whether the connection is expected to be encrypted:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-Location: ws://example.com/
</pre></div>
<p>These fields are checked by the Web browser when it is acting as a |WebSocket| client for scripted pages. A server that only handles one origin and only serves one resource can therefore just return hard-coded values and does not need to parse the client&#039;s handshake to verify the correctness of the values.
</p>
<p>Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. Web browsers verify that the server included one of the values as was specified in the |WebSocket| constructor.A server that speaks multiple subprotocols has to make sure it selects one based on the client&#039;s handshake and specifies it in its handshake.<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     Sec-WebSocket-Protocol: chat</pre></div>
<p>
          The server can also set cookie-related option fields to <em>set</em> cookies, as in HTTP.
        
</p>
<p>After the fields, the server sends the aforementioned MD5 sum, a 16 byte (128 bit) value, shown here as if interpreted as UTF-8:<br />
<br />

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>     fQJ,fN/4F4!~K~MH</pre></div>
<p>This value depends on what the client sends, as described above. If it doesn&#039;t match what the client is expecting, the client would disconnect.
</p>
<p>Having part of the handshake appear after the fields ensures that both the server and the client verify that the connection is not being interrupted by an HTTP intermediary such as a man-in-the-middle cache or proxy.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Closing handshake</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The closing handshake is far simpler than the opening handshake.
</p>
<p>
          Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake. Upon receiving such a frame, the other peer sends an identical frame in acknowledgement, if it hasn&#039;t already sent one. Upon receiving <em>that</em> control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.
        
</p>
<p>After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame frame indicating the connection should be closed, a peer discards any further data received.
</p>
<p>It is safe for both peers to initiate this handshake simultaneously.
</p>
<p>The closing handshake is intended to replace the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of man-in-the-middle proxies and other intermediaries.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5"></a><h3>1.5.&nbsp;
Design philosophy</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The WebSocket protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based, and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (HTTP).
</p>
<p>Conceptually, WebSocket is really just a layer on top of TCP that adds a Web &quot;origin&quot;-based security model for browsers; adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address; layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits; and reimplements the closing handshake in-band. Other than that, it adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It&#039;s also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade handshake also.
</p>
<p>The protocol is intended to be extensible; future versions will likely introduce a mechanism to compress data and might support sending binary data.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.6"></a><h3>1.6.&nbsp;
Security model</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The WebSocket protocol uses the origin model used by Web browsers to restrict which Web pages can contact a WebSocket server when the WebSocket protocol is used from a Web page. Naturally, when the WebSocket protocol is used by a dedicated client directly (i.e. not from a Web page through a Web browser), the origin model is not useful, as the client can provide any arbitrary origin string.
</p>
<p>This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP or HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake, and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).
</p>
<p>It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example as might happen if an HTML |form| were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts which themselves can only be sent by a WebSocket handshake; in particular, fields starting with |Sec-| cannot be set by an attacker from a Web browser, even when using |XMLHttpRequest|.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.7"></a><h3>1.7.&nbsp;
Relationship to TCP and HTTP</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The WebSocket protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.
</p>
<p>Based on the expert recommendation of the IANA, the WebSocket protocol by default uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over TLS.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.8"></a><h3>1.8.&nbsp;
Establishing a connection</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>There are several options for establishing a WebSocket connection.
</p>
<p>On the face of it, the simplest method would seem to be to use port 80 to get a direct connection to a WebSocket server. Port 80 traffic, however, will often be intercepted by man-in-the-middle HTTP proxies, which can lead to the connection failing to be established.
</p>
<p>The most reliable method, therefore, is to use TLS encryption and port 443 to connect directly to a WebSocket server. This has the advantage of being more secure; however, TLS encryption can be computationally expensive.
</p>
<p>When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer. In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket protocol to be deployed. In more elaborate setups (e.g. with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.9"></a><h3>1.9.&nbsp;
Subprotocols using the WebSocket protocol</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>The client can request that the server use a specific subprotocol by including the |Sec-Websocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.
</p>
<p>These subprotocol names do not need to be registered, but if a subprotocol is intended to be implemented by multiple independent WebSocket servers, potential clashes with the names of subprotocols defined independently can be avoided by using names that contain the domain name of the subprotocol&#039;s originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it &quot;chat.example.com&quot;. If the Example Organisation called their competing subprotocol &quot;example.org&#039;s chat protocol&quot;, then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.
</p>
<p>Subprotocols can be versioned in backwards-incompatible ways by changing the subprotocol name, eg. going from &quot;bookings.example.net&quot; to &quot;v2.bookings.example.net&quot;. These subprotocols would be considered completely separate by WebSocket clients. Backwards-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conformance requirements</h3>

<p>All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>
<p>
        The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in the normative parts of this document are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>
      
</p>
<p>Requirements phrased in the imperative as part of algorithms (such as &quot;strip any leading space characters&quot; or &quot;return false and abort these steps&quot;) are to be interpreted with the meaning of the key word (&quot;must&quot;, &quot;should&quot;, &quot;may&quot;, etc) used in introducing the algorithm.
</p>
<p>Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)
</p>
<p>Implementations may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.
</p>
<p>The conformance classes defined by this specification are user agents and servers.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Terminology</h3>

<p>
          <strong>ASCII</strong> shall mean the character-encoding scheme defined in  <a class='info' href='#ANSI.X3-4.1986'>[ANSI.X3&#8209;4.1986]<span> (</span><span class='info'>American National Standards Institute, &ldquo;Coded Character Set - 7-bit American Standard Code for Information Interchange,&rdquo; 1986.</span><span>)</span></a>.
        
</p>
<p>
          <strong>Converting a string to ASCII lowercase</strong> means replacing all characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).
        
</p>
<p>
          Comparing two strings in an <strong>ASCII case-insensitive</strong> manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.
        
</p>
<p>
          The term &quot;URL&quot; is used in this section in a manner consistent with the terminology used in HTML, namely, to denote a string that might or might not be a valid URI or IRI and to which certain error handling behaviors will be applied when the string is parsed. <a class='info' href='#HTML'>[HTML]<span> (</span><span class='info'>Hickson, I., &ldquo;HTML,&rdquo; August&nbsp;2010.</span><span>)</span></a>
        
</p>
<p>
          When an implementation is required to <em>send</em> data as part of the WebSocket protocol, the implementation may delay the actual transmission arbitrarily, e.g. buffering data so as to send fewer IP packets.
        
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
WebSocket URLs</h3>

<a name="parsing_ws_urls"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Parsing WebSocket URLs</h3>

<p>
          The steps to <strong>parse a WebSocket URL&apos;s components</strong> from a string /url/ are as follows. These steps return either a /host/, a /port/, a /resource name/, and a /secure/ flag, or they fail.

          </p>
<ol class="text">
<li>
              If the /url/ string is not an absolute URL, then fail this algorithm. <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> <a class='info' href='#RFC3987'>[RFC3987]<span> (</span><span class='info'>Duerst, M. and M. Suignard, &ldquo;Internationalized Resource Identifiers (IRIs),&rdquo; January&nbsp;2005.</span><span>)</span></a>
            
</li>
<li>
              Resolve the /url/ string using the resolve a Web address algorithm defined by the Web addresses specification, with the URL character encoding set to UTF-8. <a class='info' href='#RFC3629'>[RFC3629]<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a> <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> <a class='info' href='#RFC3987'>[RFC3987]<span> (</span><span class='info'>Duerst, M. and M. Suignard, &ldquo;Internationalized Resource Identifiers (IRIs),&rdquo; January&nbsp;2005.</span><span>)</span></a>
              <br />
<br />

              NOTE: It doesn&#039;t matter what it is resolved relative to, since we already know it is an absolute URL at this point.
            
</li>
<li>If /url/ does not have a &lt;scheme&gt; component whose value, when converted to ASCII lowercase, is either &quot;ws&quot; or &quot;wss&quot;, then fail this algorithm.
</li>
<li>If /url/ has a &lt;fragment&gt; component, then fail this algorithm.
</li>
<li>If the &lt;scheme&gt; component of /url/ is &quot;ws&quot;, set /secure/ to false; otherwise, the &lt;scheme&gt; component is &quot;wss&quot;, set /secure/ to true.
</li>
<li>Let /host/ be the value of the &lt;host&gt; component of /url/, converted to ASCII lowercase.
</li>
<li>If /url/ has a &lt;port&gt; component, then let /port/ be that component&#039;s value; otherwise, there is no explicit /port/.
</li>
<li>If there is no explicit /port/, then: if /secure/ is false, let /port/ be 80, otherwise let /port/ be 443.
</li>
<li>Let /resource name/ be the value of the &lt;path&gt; component (which might be empty) of /url/.
</li>
<li>If /resource name/ is the empty string, set it to a single character U+002F SOLIDUS (/).
</li>
<li>If /url/ has a &lt;query&gt; component, then append a single U+003F QUESTION MARK character (?) to /resource name/, followed by the value of the &lt;query&gt; component.
</li>
<li>Return /host/, /port/, /resource name/, and /secure/.
</li>
</ol><p>
        
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Constructing WebSocket URLs</h3>

<p>
          The steps to <strong>construct a WebSocket URL</strong> from a /host/, a /port/, a /resource name/, and a /secure/ flag, are as follows:
          </p>
<ol class="text">
<li>Let /url/ be the empty string.
</li>
<li>If the /secure/ flag is false, then append the string &quot;ws://&quot; to /url/. Otherwise, append the string &quot;wss://&quot; to /url/.
</li>
<li>Append /host/ to /url/.
</li>
<li>If the /secure/ flag is false and port is not 80, or if the /secure/ flag is true and port is not 443, then append the string &quot;:&quot; followed by /port/ to /url/.
</li>
<li>Append /resource name/ to /url/.
</li>
<li>Return /url/.
</li>
</ol><p>
        
</p>
<a name="valid_ws_urls"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Valid WebSocket URLs</h3>

<p>
          For a WebSocket URL to be considered valid, the following conditions MUST hold.
          </p>
<ul class="text">
<li>The /host/ must be ASCII-only (i.e. it must have been punycode-encoded already if necessary, and MUST NOT contain any characters above U+007E).
</li>
<li>The /origin/ must not contain characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z).
</li>
<li>
              The /resource name/ string must be a non-empty string of characters in the range U+0021 to U+007E that starts with a U+002F SOLIDUS character (/).
            
</li>
<li>The various strings in /protocols/ MUST all be non-empty strings with characters in the range U+0021 to U+007E and MUST all be unique.
            
</li>
</ul><p>
        
</p>
<p>Any WebSocket URLs not meeting the above criteria are considered invalid, and a client MUST NOT attempt to make a connection to an invalid WebSocket URL. A client SHOULD attempt to parse a URL obtained from any external source (such as a web site or a user) using the steps specified in <a class='info' href='#parsing_ws_urls'>Section&nbsp;3.1<span> (</span><span class='info'>Parsing WebSocket URLs</span><span>)</span></a> to obtain a valid WebSocket URL, but MUST NOT attempt to connect with such an unparsed URL, and instead only use the parsed version and only if that version is considered valid by the criteria above.
        
</p>
<a name="framing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Data Framing</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Overview</h3>

<p>The base framing protocol defines a frame type with an opcode, a
        payload length, and designated locations for extension and application
        data, which together define the <em>payload</em>
        data. Certain bits and opcodes are reserved for future expansion of the
        protocol. As such, In the absence of extensions negotiated during the
        opening handshake (<a class='info' href='#handshake'>Section&nbsp;5<span> (</span><span class='info'>Opening Handshake</span><span>)</span></a>), all reserved bits MUST
        be 0 and reserved opcode values MUST NOT be used.
        
</p>
<p>A data frame MAY be transmitted by either the client or the server at
        any time after handshake completion and before that host has generated a
        close message (<a class='info' href='#closeframe'>Section&nbsp;4.4.1<span> (</span><span class='info'>Close</span><span>)</span></a>).
        
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Base Framing Protocol</h3>

<p>
          This wire format for the data transfer part is described by the ABNF given in detail in this section. A high level overview of the framing is given in the following figure. <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a>
          <br />
<br />

        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-------+-+-------------+-------------------------------+
  |M|R|R|R| opcode|R| Payload len |    Extended payload length    |
  |O|S|S|S|  (4)  |S|     (7)     |             (16/63)           |
  |R|V|V|V|       |V|             |   (if payload len==126/127)   |
  |E|1|2|3|       |4|             |                               |
  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  |     Extended payload length continued, if payload len == 127  |
  + - - - - - - - - - - - - - - - +-------------------------------+
  |                               |         Extension data        |
  +-------------------------------+ - - - - - - - - - - - - - - - +
  :                                                               :
  +---------------------------------------------------------------+
  :                       Application data                        :
  +---------------------------------------------------------------+
</pre></div>
<p>
          </p>
<blockquote class="text"><dl>
<dt>MORE:</dt>
<dd>1 bit
              <br />

              Indicates more fragments follow in the current message
            
</dd>
<dt>RSV1, RSV2, RSV3, RSV4:</dt>
<dd>1 bit each
              <br />

              Must be 0 unless an extension is negotiated which defines
              meanings for non-zero values
            
</dd>
<dt>Opcode:</dt>
<dd>4 bits
              <br />

              Defines the interpretation of the payload data
            
</dd>
<dt>Payload length:</dt>
<dd>7 bits
              <br />

              The length of the payload: if 0-125, that is the payload length.
              If 126, the following 2 bytes interpreted as a 16 bit unsigned
              integer are the payload length.  If 127, the following 8 bytes
              interpreted as a 64-bit unsigned integer (the high bit must be 0)
              are the payload length. Multibyte length quantities are expressed
              in network byte order. The payload length is the length of the
              Extension data + the length of the Application Data. The length
              of the Extension data may be zero, in which case the Payload
              length is the length of the Application data.
            
</dd>
<dt>Extension data:</dt>
<dd>n bytes
              <br />

              The extension data is 0 bytes unless there is a reserved op-code
              or reserved bit present in the frame which indicates an extension
              has been negotiated. Any extension MUST specify the length of the
              extension data, or how that length may be calculated, and its use
              MUST be negotiated during the handshake.
              If present, the extension data is included in the total payload
              length.
            
</dd>
<dt>Application data:</dt>
<dd>n bytes
              <br />

              Arbitrary application data, taking up the remainder of the frame
              after any extension data. The length of the Application data is
              equal to the payload length minus the length of the Extension
              data.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>The base framing protocol is formally defined by the following ABNF <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a>:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>ws-frame</dfn>               = <cite class='id'>frame-more</cite>
                            <cite class='id'>frame-rsv1</cite>
                            <cite class='id'>frame-rsv2</cite>
                            <cite class='id'>frame-rsv3</cite>
                            <cite class='id'>frame-opcode</cite>
                            <cite class='id'>frame-rsv4</cite>
                            <cite class='id'>frame-length</cite>
                            <cite class='id'>frame-extension</cite>
                            <cite class='id'>application-data</cite><em>;</em>

   <dfn>frame-more</dfn>             = <span class='val'>%x0</span> <em>; final frame of message</em>
                          / <span class='val'>%x1</span> <em>; more frames of this message follow</em>

   <dfn>frame-rsv1</dfn>             = <span class='val'>%x0</span> <em>; 1 bit, must be 0</em>

   <dfn>frame-rsv2</dfn>             = <span class='val'>%x0</span> <em>; 1 bit, must be 0</em>

   <dfn>frame-rsv3</dfn>             = <span class='val'>%x0</span> <em>; 1 bit, must be 0</em>

   <dfn>frame-opcode</dfn>           = <span class='val'>%x0</span> <em>; continuation frame</em>
                          / <span class='val'>%x1</span> <em>; connection close</em>
                          / <span class='val'>%x2</span> <em>; ping</em>
                          / <span class='val'>%x3</span> <em>; pong</em>
                          / <span class='val'>%x4</span> <em>; text frame</em>
                          / <span class='val'>%x5</span> <em>; binary frame</em>
                          / <span class='val'>%x6-F</span> <em>; reserved</em>

   <dfn>frame-rsv4</dfn>             = <span class='val'>%x0</span> <em>; 1 bit, must be 0</em>

   <dfn>frame-length</dfn>           = <span class='val'>%x00-7D</span>
                          / <span class='val'>%x7E</span> <cite class='id'>frame-length-16</cite>
                          / <span class='val'>%x7F</span> <cite class='id'>frame-length-63</cite>

   <dfn>frame-length-16</dfn>        = <span class='val'>%x0000-FFFF</span>

   <dfn>frame-length-63</dfn>        = <span class='val'>%x0000000000000000-7FFFFFFFFFFFFFFF</span>

   <dfn>frame-extension</dfn>        = <span class='rep'>*</span>( <span class='val'>%x00-FF</span> ) <em>; to be defined later</em>

   <dfn>application-data</dfn>       = <span class='rep'>*</span>( <span class='val'>%x00-FF</span> )
</pre></div>
<p>
        
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Fragmentation</h3>

<p>The following rules apply to fragmentation:
          </p>
<ul class="text">
<li>An unfragmented message consists of a single frame with the MORE
            bit clear and an opcode other than 0.
</li>
<li>A fragmented message consists of a single frame with the MORE
            bit set and an opcode other than 0, followed by zero or more frames
            with the MORE bit set and the opcode set to 0, and terminated by
            a single frame with the MORE bit clear and an opcode of 0.  Its
            content is the concatenation of the application data from each of
            those frames in order.
</li>
<li><em>Note: There is an open question as to whether
            control frames be interjected in the middle of a fragmented message.
            If so, it must be decided whether they be fragmented (which would
            require keeping a stack of "in-progress" messages).</em>
</li>
<li>A sender MAY create fragments of any size for non control
            messages.
</li>
<li>Clients and servers MUST support receiving both fragmented and
            unfragmented messages.
            
</li>
<li>An intermediary MAY change the fragmentation of a message if the
            message uses only opcode and reserved bit values known to the
            intermediary.
            
</li>
</ul><p>
        
</p>
<a name="controlframes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Control Frames</h3>

<p>Control frames have opcodes of 0x01 (Close), 0x02 (Ping), or 0x03
        (Pong). Control frames are used to communicate state about the
        websocket.
        
</p>
<p>All control frames MUST be 125 bytes or less in length and MUST NOT
        be fragmented.
</p>
<a name="closeframe"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
Close</h3>

<p>The Close message contains an opcode of 0x01.
</p>
<p>The application MUST NOT send any more data messages after sending
          a close message.
</p>
<p>A recevied close message is deemed to be an acknowledgement if the
          message body matches the body of a close message previously sent by
          the receiver. Otherwise the close message is a close initiated by
          the sender.
</p>
<p>Upon receipt of an initiated close the endpoint MUST send a close
          acknowledgment. It should do so as soon as is practical.
</p>
<p>The websocket is considered fully closed when an endpoint has
          either received a close acknowledgment or sent a close
          acknowledgment.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
Ping</h3>

<p>The Ping message contains an opcode of 0x02.
</p>
<p>Upon receipt of a Ping message, an endpoint MUST send a Pong
          message in response. It SHOULD do so as soon as is practical. The
          message bodies of the Ping and Pong MUST be the same.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
Pong</h3>

<p>The Pong message contains an opcode of 0x03.
</p>
<p>Upon receipt of a Ping message, an endpoint MUST send a Pong
          message in response. It SHOULD do so as soon as is practical. The
          message bodies of the Ping and Pong MUST be the same.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Data Frames</h3>

<p>
          All frame types not listed in <a class='info' href='#controlframes'>Section&nbsp;4.4<span> (</span><span class='info'>Control Frames</span><span>)</span></a> are data frames, which transport
          application-layer data.  The opcode determines the interpretation of
          the application data:
          </p>
<blockquote class="text"><dl>
<dt>Text</dt>
<dd>
              <br />

              The payload data is text data encoded as UTF-8.
            
</dd>
<dt>Binary</dt>
<dd>
              <br />

              The payload data is arbitrary binary data whose interpretation
              is solely up to the application layer.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Examples</h3>

<p>
          <em>This section is non-normative.</em>
        
</p>
<p>
          </p>
<ul class="text">
<li>
              A single-frame text message
              
<ul class="text">
<li>0x04 0x05 "Hello"
</li>
</ul>
            
</li>
<li>
              A fragmented text message
              
<ul class="text">
<li>0x84 0x03 "Hel"
</li>
<li>0x00 0x02 "lo"
</li>
</ul>
            
</li>
<li>
              Ping request and response
              
<ul class="text">
<li>0x02 0x05 "Hello"
</li>
<li>0x03 0x05 "Hello"
</li>
</ul>
            
</li>
<li>
              256 bytes binary message in a single frame
              
<ul class="text">
<li>0x05 0x7E 0x0100 [256 bytes of binary data]
</li>
</ul>
            
</li>
<li>
              64KiB binary message in a single frame
              
<ul class="text">
<li>0x05 0x7F 0x0000000000010000 [65536 bytes of binary data]
</li>
</ul>
            
</li>
</ul><p>
        
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.7"></a><h3>4.7.&nbsp;
Extensibility</h3>

<p>The protocol is designed to allow for extensions, which will add
        capabilities to the base protocols. The endpoints of a connection MUST
        negotiate the use of any extensions during the
        handshake. This specification provides opcodes 0x6 through 0xF, the
        extension data field, and the frame-rsv1, frame-rsv2, frame-rsv3, and
        frame-rsv4 bits of the frame header for use by extensions.
        Below are some anticipated uses of extensions. This list is neither
        complete nor proscriptive.
          </p>
<ul class="text">
<li>Extension data may be placed in the payload before the
            application data.
</li>
<li>Reserved bits can be allocated for per-frame needs.
</li>
<li>Reserved opcode values can be defined.
</li>
<li>Reserved bits can be allocated to the opcode field if more
            opcode values are needed.
</li>
<li>A reserved bit or an "extension" opcode can be defined which
            allocates additional bits out of the payload area to define larger
            opcodes or more per-frame bits.
</li>
</ul><p>
        
</p>
<a name="handshake"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Opening Handshake</h3>

<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Client Requirements</h3>

<p>
          User agents running in controlled environments, e.g. browsers on
          mobile handsets tied to specific carriers, may offload the
          management of the connection to another agent on the network. In
          such a situation, the user agent for the purposes of conformance
          is considered to include both the handset software and any such
          agents.
        
</p>
<p>
          When the user agent is to <strong>establish a WebSocket connection</strong> to a host /host/, on a port /port/, from an origin whose ASCII serialization is /origin/, with a flag /secure/, with a string giving a /resource name/, with a (possibly empty) list of strings giving the /protocols/, and optionally with a /defer cookies/ flag, it must run the following steps. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
        
</p>
<p>
          </p>
<ol class="text">
<li>
              Verify that the WebSocket URL and its components are valid according to <a class='info' href='#valid_ws_urls'>Section&nbsp;3.3<span> (</span><span class='info'>Valid WebSocket URLs</span><span>)</span></a>. If any of the requirements are not met, the client MUST fail the WebSocket connection and abort these steps.
            
</li>
<li>
              If the user agent already has a WebSocket connection to the remote host (IP address) identified by /host/, even if known by another name, wait until that connection has been established or for that connection to have failed. If multiple connections to the same IP address are attempted simultaneously, the user agent must serialize them so that there is no more than one connection at a time running through the following steps.
              <br />
<br />

              If the user agent cannot determine the IP address of the remote
              host (for example because all communication is being done through
              a proxy server that performs DNS queries itself), then the user
              agent must assume for the purposes of this step that each host
              name refers to a distinct remote host, but should instead limit
              the total number of simultaneous connections that are not
              established to a reasonably low number (e.g., in a Web browser, to
              the number of tabs the user has open).
              <br />
<br />

              NOTE: This makes it harder for a script to perform a denial of
              service attack by just opening a large number of WebSocket
              connections to a remote host. A server can further
              reduce the load on itself when attacked by making use of this by
              pausing before closing the connection, as that will reduce the
              rate at which the client reconnects.
              <br />
<br />

              NOTE: There is no limit to the number of established WebSocket connections a user agent can have with a single remote host. Servers can refuse to connect users with an excessive number of connections, or disconnect resource-hogging users when suffering high load.
            
</li>
<li>
              <em>Connect</em>: If the user agent is configured to use a proxy when using the WebSocket protocol to connect to host /host/ and/or port /port/, then connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.
<blockquote class="text">
<p>
                  EXAMPLE: For example, if the user agent uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server:<br />
<br />

                  </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
</pre></div><p>

                
</p>
<p>
                  If there was a password, the connection might look like:<br />
<br />

                  </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
</pre></div><p>

                
</p>
</blockquote>
              Otherwise, if the user agent is not configured to use a proxy, then open a TCP connection to the host given by /host/ and the port given by /port/.
              <br />
<br />

              NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.
              <br />
<br />

              For the purpose of proxy autoconfiguration scripts, the URL to pass the function must be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the steps to construct a WebSocket URL.
              <br />
<br />

              NOTE: The WebSocket protocol can be identified in proxy autoconfiguration scripts from the scheme (&quot;ws:&quot; for unencrypted connections and &quot;wss:&quot; for encrypted connections).
            
</li>
<li>If the connection could not be opened, then fail the WebSocket connection and abort these steps.
</li>
<li>
              If /secure/ is true, perform a TLS handshake over the connection. If this fails (e.g. the server&#039;s certificate could not be verified), then fail the WebSocket connection and abort these steps. Otherwise, all further communication on this channel must run through the encrypted tunnel. <a class='info' href='#RFC2246'>[RFC2246]<span> (</span><span class='info'>Dierks, T. and C. Allen, &ldquo;The TLS Protocol Version 1.0,&rdquo; January&nbsp;1999.</span><span>)</span></a>
              <br />
<br />

              User agents must use the Server Name Indication extension in the TLS handshake. <a class='info' href='#RFC4366'>[RFC4366]<span> (</span><span class='info'>Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;Transport Layer Security (TLS) Extensions,&rdquo; April&nbsp;2006.</span><span>)</span></a>
            
</li>
<li>
              Send the UTF-8 string &quot;GET&quot; followed by a UTF-8-encoded U+0020 SPACE character to the remote side (the server).
              <br />
<br />

              Send the /resource name/ value, encoded as UTF-8.
              <br />
<br />

              Send another UTF-8-encoded U+0020 SPACE character, followed by the UTF-8 string &quot;HTTP/1.1&quot;, followed by a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
            
</li>
<li>Let /fields/ be an empty list of strings.
</li>
<li>Add the string &quot;Upgrade: WebSocket&quot; to /fields/.
</li>
<li>Add the string &quot;Connection: Upgrade&quot; to /fields/.
</li>
<li>Let /hostport/ be an empty string.
</li>
<li>Append the /host/ value, converted to ASCII lowercase, to /hostport/.
</li>
<li>If /secure/ is false, and /port/ is not 80, or if /secure/ is true, and /port/ is not 443, then append a U+003A COLON character (:) followed by the value of /port/, expressed as a base-ten integer, to /hostport/.
</li>
<li>Add the string consisting of the concatenation of the string &quot;Host:&quot;, a U+0020 SPACE character, and /hostport/, to /fields/.
</li>
<li>Add the string consisting of the concatenation of the string &quot;Origin:&quot;, a U+0020 SPACE character, and the /origin/ value, to /fields/.
</li>
<li>Add the string &quot;Sec-WebSocket-Draft: 2&quot; to /fields/.
</li>
<li>
              If there is no /protocols/, then skip this step.
              <br />
<br />

              Otherwise, generate the acceptable protocol string by joining each
              protocol in /protocols/ using a U+0020 SPACE character. Add the
              string consisting of the concatenation of the string
              &quot;Sec-WebSocket-Protocol:&quot;, a U+0020 SPACE character,
              and the acceptable protocol string generated above, to /fields/.
            
</li>
<li>
              If the client has any  cookies that would be relevant to a resource accessed over HTTP, if /secure/ is false, or HTTPS, if it is true, on host /host/, port /port/, with /resource name/ as the path (and possibly query parameters), then add to /fields/ any HTTP headers that would be appropriate for that information. <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a> <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a> <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
              <br />
<br />

              This includes &quot;HttpOnly&quot; cookies (cookies with the http-only-flag set to true); the WebSocket protocol is not considered a non-HTTP API for the purpose of cookie processing.
            
</li>
<li>
              When one or more HTTP headers are to be added to /fields/ for this step, each header must be added separately, and each header must be added as one entry consisting of the header&#039;s name in its canonical case, followed by a U+003A COLON character (:) and a U+0020 SPACE character, followed by the value with no use of continuation lines (e.g. containing no U+000A LINE FEED characters.)
            
</li>
<li>
              Let /spaces_1/ be a random integer from 1 to 12 inclusive.
              <br />
<br />

              Let /spaces_2/ be a random integer from 1 to 12 inclusive.
              <br />
<br />

              EXAMPLE: For example, 5 and 9.
            
</li>
<li>
              Let /max_1/ be the largest integer not greater than 4,294,967,295 divided by /spaces_1/.
              <br />
<br />

              Let /max_2/ be the largest integer not greater than 4,294,967,295 divided by /spaces_2/.
              <br />
<br />

              EXAMPLE: Continuing the example, 858,993,459 and 477,218,588.
            
</li>
<li>
              Let /number_1/ be a random integer from 0 to /max_1/ inclusive.
              <br />
<br />

              Let /number_2/ be a random integer from 0 to /max_2/ inclusive.
              <br />
<br />

              EXAMPLE: For example, 777,007,543 and 114,997,259.
            
</li>
<li>
              Let /product_1/ be the result of multiplying /number_1/ and /spaces_1/ together.
              <br />
<br />

              Let /product_2/ be the result of multiplying /number_2/ and /spaces_2/ together.
              <br />
<br />

              EXAMPLE: Continuing the example, 3,885,037,715 and 1,034,975,331.
            
</li>
<li>
              Let /key_1/ be a string consisting of /product_1/, expressed in base ten using the numerals in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9).
              <br />
<br />

              Let /key_2/ be a string consisting of /product_2/, expressed in base ten using the numerals in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9).
              <br />
<br />

              EXAMPLE: Continuing the example, &quot;3885037715&quot; and &quot;1034975331&quot;.
            
</li>
<li>
              Insert between one and twelve random characters from the ranges U+0021 to U+002F and U+003A to U+007E into /key_1/ at random positions.
              <br />
<br />

              Insert between one and twelve random characters from the ranges U+0021 to U+002F and U+003A to U+007E into /key_2/ at random positions.
              <br />
<br />

              NOTE: This corresponds to random printable ASCII characters other than the digits and the U+0020 SPACE character.
              <br />
<br />

              EXAMPLE: Continuing the example, this could lead to &quot;P388O503D&amp;ul7{K%gX(%715&quot; and &quot;1N?|kUT0or3o4I97N5-S3O31&quot;.
            
</li>
<li>
              Insert /spaces_1/ U+0020 SPACE characters into /key_1/ at random positions other than the start or end of the string.
              <br />
<br />

              Insert /spaces_2/ U+0020 SPACE characters into /key_2/ at random positions other than the start or end of the string.
              <br />
<br />

              EXAMPLE: Continuing the example, this could lead to &quot;P388 O503D&amp;ul7 {K%gX( %7  15&quot; and &quot;1 N ?|k UT0or 3o  4 I97N 5-S3O 31&quot;.
            
</li>
<li>
              Add the string consisting of the concatenation of the string &quot;Sec-WebSocket-Key1:&quot;, a U+0020 SPACE character, and the /key_1/ value, to /fields/.
              <br />
<br />

              Add the string consisting of the concatenation of the string &quot;Sec-WebSocket-Key2:&quot;, a U+0020 SPACE character, and the /key_2/ value, to /fields/.
            
</li>
<li>For each string in /fields/, in a random order: send the string, encoded as UTF-8, followed by a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF). It is important that the fields be output in a random order so that servers not depend on the particular order used by any particular client.
</li>
<li>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
<li>
              Let /key_3/ be a string consisting of eight random bytes (or equivalently, a random 64 bit unsigned integer encoded in big-endian order).
              <br />
<br />

              EXAMPLE: For example, 0x47 0x30 0x22 0x2D 0x5A 0x3F 0x47 0x58.
            
</li>
<li>Send /key_3/ to the server.
</li>
<li>
              Read bytes from the server until either the connection closes, or a 0x0A byte is read. Let /field/ be these bytes, including the 0x0A byte.
              <br />
<br />

              If /field/ is not at least seven bytes long, or if the last two bytes aren&#039;t 0x0D and 0x0A respectively, or if /field/ contains any 0x0D bytes other than the penultimate byte, or if /field/ does not contain at least two 0x20 bytes, then <em>fail the WebSocket connection</em> and abort these steps.
              <br />
<br />

              User agents may apply a timeout to this step, failing the WebSocket connection if the server does not send back data in a suitable time period.
            
</li>
<li>Let /code/ be the substring of /field/ that starts from the byte after the first 0x20 byte, and ends with the byte before the second 0x20 byte.
</li>
<li>
              If /code/, interpreted as UTF-8, is &quot;101&quot;, then move to the next step.
              <br />
<br />

              If /code/, interpreted as UTF-8, is &quot;407&quot;, then either close the connection and jump back to step 2, providing appropriate authentication information, or fail the WebSocket connection. 407 is the code used by HTTP meaning &quot;Proxy Authentication Required&quot;. User agents that support proxy authentication must interpret the response as defined by HTTP (e.g. to find and interpret the |Proxy-Authenticate| header).
              <br />
<br />

              Otherwise, fail the WebSocket connection and abort these steps.
            
</li>
<li>Let /fields/ be a list of name-value pairs, initially empty.
</li>
<li>
              <em>Field</em>: Let /name/ and /value/ be empty byte arrays.
            
</li>
<li>
              Read a byte from the server.
              <br />
<br />

              If the connection closes before this byte is received, then fail the WebSocket connection and abort these steps.
              <br />
<br />

              Otherwise, handle the byte as described in the appropriate entry below:
<blockquote class="text"><dl>
<dt>-> If the byte is 0x0D (UTF-8 CR)</dt>
<dd>
                  If the /name/ byte array is empty, then jump to the fields processing step. Otherwise, fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the byte is 0x0A (UTF-8 LF)</dt>
<dd>
                  Fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the byte is 0x3A (UTF-8 :)</dt>
<dd>
                  Move on to the next step.
                
</dd>
<dt>-> If the byte is in the range 0x41 to 0x5A (UTF-8 A-Z)</dt>
<dd>
                  Append a byte whose value is the byte&#039;s value plus 0x20 to the /name/ byte array and redo this step for the next byte.
                
</dd>
<dt>-> Otherwise</dt>
<dd>
                  Append the byte to the /name/ byte array and redo this step for the next byte.
                
</dd>
</dl></blockquote>
              NOTE: This reads a field name, terminated by a colon, converting upper-case  letters in the range A-Z to lowercase, and aborting if a stray CR or LF is found.
            
</li>
<li>
              Let /count/ equal 0.
              <br />
<br />

              NOTE: This is used in the next step to skip past a space character after the colon, if necessary.
            
</li>
<li>
              Read a byte from the server and increment /count/ by 1.
              <br />
<br />

              If the connection closes before this byte is received, then fail the WebSocket connection and abort these steps.
              <br />
<br />

              Otherwise, handle the byte as described in the appropriate entry below:
<blockquote class="text"><dl>
<dt>-> If the byte is 0x20 (UTF-8 space) and /count/ equals 1</dt>
<dd>
                  Ignore the byte and redo this step for the next byte.
                
</dd>
<dt>-> If the byte is 0x0D (UTF-8 CR)</dt>
<dd>
                  Move on to the next step.
                
</dd>
<dt>-> If the byte is 0x0A (UTF-8 LF)</dt>
<dd>
                  Fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> Otherwise</dt>
<dd>
                  Append the byte to the /value/ byte array and redo this step for the next byte.
                
</dd>
</dl></blockquote>
              NOTE: This reads a field value, terminated by a CRLF, skipping past a single space after the colon if there is one.
            
</li>
<li>
              Read a byte from the server.
              <br />
<br />

              If the connection closes before this byte is received, or if the byte is not a 0x0A byte (UTF-8 LF), then fail the WebSocket connection and abort these steps.
              <br />
<br />

              NOTE: This skips past the LF byte of the CRLF after the field.
            
</li>
<li>Append an entry to the /fields/ list that has the name given by the string obtained by interpreting the /name/ byte array as a UTF-8 byte stream and the value given by the string obtained by interpreting the /value/ byte array as a UTF-8 byte stream.
</li>
<li>Return to the &quot;Field&quot; step above.
</li>
<li>
              <em>Fields processing</em>: Read a byte from the server.
              <br />
<br />

              If the connection closes before this byte is received, or if the byte is not a 0x0A byte (UTF-8 LF), then fail the WebSocket connection and abort these steps.
              <br />
<br />

              NOTE: This skips past the LF byte of the CRLF after the blank line after the fields.
            
</li>
<li>
              Let the /list of cookies/ be empty.
            
</li>
<li>
              If there is not exactly one entry in the /fields/ list whose name is &quot;upgrade&quot;, or if there is not exactly one entry in the /fields/ list whose name is &quot;connection&quot;, or if there is not exactly one entry in the /fields/ list whose name is &quot;sec-websocket-origin&quot;, or if there is not exactly one entry in the /fields/ list whose name is &quot;sec-websocket-location&quot;, or if the /protocol/ was specified but there is not exactly one entry in the /fields/ list whose name is &quot;sec-websocket-protocol&quot;, or if there are any entries in the /fields/ list whose names are the empty string, then fail the WebSocket connection and abort these steps. Otherwise, handle each entry in the /fields/ list as follows:
<blockquote class="text"><dl>
<dt>-> If the entry&apos;s name is &quot;upgrade&quot;</dt>
<dd>
                  If the value, converted to ASCII lowercase, is not exactly equal to the string &quot;websocket&quot;, then fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the entry&apos;s name is &quot;connection&quot;</dt>
<dd>
                  If the value, converted to ASCII lowercase, is not exactly equal to the string &quot;upgrade&quot;, then fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-origin&quot;</dt>
<dd>
                  If the value is not exactly equal to /origin/, then fail the WebSocket connection and abort these steps. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-location&quot;</dt>
<dd>
                  If the value is not exactly equal to a string obtained from the steps to construct a WebSocket URL from /host/, /port/, /resource name/, and the /secure/ flag, then fail the WebSocket connection and abort these steps.
                
</dd>
<dt>-> If the entry&apos;s name is &quot;sec-websocket-protocol&quot;</dt>
<dd>
                  If there was a /protocols/ string specified, and the value is not exactly equal to one of the items in /protocols/, then fail the WebSocket connection and abort these steps. (If no /protocols/ was specified, the field is ignored.)
                
</dd>
<dt>-> If the entry&apos;s name is &quot;set-cookie&quot; or &quot;set-cookie2&quot; or another cookie-related field name</dt>
<dd>
                  If the relevant specification is supported by the user agent, add the cookie, interpreted as defined by the appropriate specification, to the /list of cookies/, with the resource being the one with the host /host/, the port /port/, the path (and possibly query parameters) /resource name/, and the scheme |http| if /secure/ is false and |https| if /secure/ is true. <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a> <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
                  <br />
<br />

                  If the relevant specification is not supported by the user agent, then the field must be ignored.
                  <br />
<br />

                  The cookies added to the /list of cookies/ are discarded if the connection fails to be established. Only if and when the connection is established do the cookies actually get applied.
                
</dd>
<dt>-> Any other name</dt>
<dd>
                  Ignore it.
                
</dd>
</dl></blockquote>
              <br />
<br />

            
</li>
<li>
              Let /challenge/ be the concatenation of /number_1/, expressed as a big-endian 32 bit integer, /number_2/, expressed as a big-endian 32 bit integer, and the eight bytes of /key_3/ in the order they were sent on the wire.
              <br />
<br />

              EXAMPLE: Using the examples given earlier, this leads to the 16 bytes 0x2E 0x50 0x31 0xB7 0x06 0xDA 0xB8 0x0B 0x47 0x30 0x22 0x2D 0x5A 0x3F 0x47 0x58.
            
</li>
<li>
              Let /expected/ be the MD5 fingerprint of /challenge/ as a big-endian 128 bit string. <a class='info' href='#RFC1321'>[RFC1321]<span> (</span><span class='info'>Rivest, R., &ldquo;The MD5 Message-Digest Algorithm,&rdquo; April&nbsp;1992.</span><span>)</span></a>
              <br />
<br />

              EXAMPLE: Using the examples given earlier, this leads to the 16 bytes 0x30 0x73 0x74 0x33 0x52 0x6C 0x26 0x71 0x2D 0x32 0x5A 0x55 0x5E 0x77 0x65 0x75. In UTF-8, these bytes correspond to the string &quot;0st3Rl&amp;q-2ZU^weu&quot;.
            
</li>
<li>
              Read sixteen bytes from the server. Let /reply/ be those bytes.
              <br />
<br />

              If the connection closes before these bytes are received, then fail the WebSocket connection and abort these steps.
            
</li>
<li>If /reply/ does not exactly equal /expected/, then fail the WebSocket connection and abort these steps.
</li>
<li>
              If the /defer cookies/ flag is not set, apply the cookies in the /list of cookies/.
            
</li>
<li>
              The <strong>WebSocket connection is established</strong>. Now the user agent must send and receive to and from the connection as described in the next section.
            
</li>
<li>
              If the /defer cookies/ flag is set, store the /list of cookies/ for use by the component that invoked this algorithm.
            
</li>
</ol><p>
        
</p>
<p>
          Where the algorithm above requires that a user agent
          fail the WebSocket connection,
          the user agent may first read an
          arbitrary number of further bytes from the connection (and then
          discard them) before actually <strong>failing the WebSocket connection</strong>.
          Similarly, if a
          user agent can show that the bytes read from the connection so far
          are such that there is no subsequent sequence of bytes that the
          server can send that would not result in the user agent being
          required to <strong>fail the WebSocket connection</strong>, the user
          agent may immediately <strong>fail the WebSocket connection</strong>
          without waiting for those bytes.
        
</p>
<p>
          NOTE: The previous paragraph is intended to make it
          conforming for user agents to implement the algorithm in subtlely
          different ways that are equivalent in all ways except that they
          terminate the connection at earlier or later points. For example, it
          enables an implementation to buffer the entire handshake response
          before checking it, or to verify each field as it is received rather
          than collecting all the fields and then checking them as a
          block.
        
</p>
<p>
          When the user agent is to &quot;apply the cookies&quot; in a
          /list of cookies/, it must handle each cookie in the
          /list of cookies/ as defined by the appropriate
          specification. <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a> <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
        
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Server-side requirements</h3>

<p>
          <em>This section only applies to servers.</em>
        
</p>
<p>
          Servers may offload the management of the connection to other
          agents on the network, for example load balancers and reverse
          proxies. In such a situation, the server for the purposes of
          conformance is considered to include all parts of the server-side
          infrastructure from the first device to terminate the TCP connection
          all the way to the server that processes requests and sends
          responses.
        
</p>
<p>
          EXAMPLE: For example, a data center might have a server that responds to
          Web Socket requests with an appropriate handshake, and then passes
          the connection to another server to actually process the data
          frames. For the purposes of this specification, the "server" is the
          combination of both computers.
        
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Reading the client&#039;s opening handshake</h3>

<p>When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.
</p>
<p>
            The client handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below, the server should abort the WebSocket connection.
            </p>
<ol class="text">
<li>The three-character UTF-8 string &quot;GET&quot;.
</li>
<li>A UTF-8-encoded U+0020 SPACE character (0x20 byte).
</li>
<li>A string consisting of all the bytes up to the next UTF-8-encoded U+0020 SPACE character (0x20 byte). The result of decoding this string as a UTF-8 string is the name of the resource requested by the server. If the server only supports one resource, then this can safely be ignored; the client verifies that the right resource is supported based on the information included in the server&#039;s own handshake. The resource name will begin with U+002F SOLIDUS character (/) and will only include characters in the range U+0021 to U+007E.
</li>
<li>A string of bytes terminated by a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF). All the characters from the second 0x20 byte up to the first 0x0D 0x0A byte pair in the data from the client can be safely ignored. (It will probably be the string &quot;HTTP/1.1&quot;.)
</li>
<li>
                A series of fields.
                <br />
<br />

                Each field is terminated by a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF). The end of the fields is denoted by the terminating CRLF pair being followed immediately by another CRLF pair.
                <br />
<br />

                NOTE: In other words, the fields start with the first 0x0D 0x0A byte pair, end with the first 0x0D 0x0A 0x0D 0x0A byte sequence, and are separate from each other by 0x0D 0x0A byte pairs.
                <br />
<br />

                The fields are encoded as UTF-8.
                <br />
<br />

                Each field consists of a name, consisting of one or more characters in the ranges U+0021 to U+0039 and U+003B to U+007E, followed by a U+003A COLON character (:) and a U+0020 SPACE character, followed by zero or more characters forming the value.
                <br />
<br />

                The expected field names, the meaning of their corresponding values, and the processing servers are required to apply to those fields, are described below, after the description of the client handshake.
              
</li>
<li>After the first 0x0D 0x0A 0x0D 0x0A byte sequence, indicating the end of the fields, the client sends eight random bytes. These are used in constructing the server handshake.
</li>
</ol><p>
          
</p>
<p>
            The expected field names, and the meaning of their corresponding values, are as follows. Field names must be compared in an ASCII case-insensitive manner.
            </p>
<blockquote class="text"><dl>
<dt>|Upgrade|</dt>
<dd>
                Invariant part of the handshake. Will always have a value that is an ASCII case-insensitive match for the string &quot;WebSocket&quot;.
                <br />
<br />

                Can be safely ignored, though the server should abort the WebSocket connection if this field is absent or has a different value, to avoid vulnerability to cross-protocol attacks.
              
</dd>
<dt>|Connection|</dt>
<dd>
                Invariant part of the handshake. Will always have a value that is an ASCII case-insensitive match for the string &quot;Upgrade&quot;.
                <br />
<br />

                Can be safely ignored, though the server should abort the WebSocket connection if this field is absent or has a different value, to avoid vulnerability to cross-protocol attacks.
              
</dd>
<dt>|Host|</dt>
<dd>
                The value gives the hostname that the client intended to use when opening the WebSocket. It would be of interest in particular to virtual hosting environments, where one server might serve multiple hosts, and might therefore want to return different data.
                <br />
<br />

                Can be safely ignored, though the server should abort the WebSocket connection if this field is absent or has a value that does not match the server&#039;s host name, to avoid vulnerability to cross-protocol attacks and DNS rebinding attacks.
              
</dd>
<dt>|Origin|</dt>
<dd>
                The value gives the scheme, hostname, and port (if it&#039;s not the default port for the given scheme) of the page that asked the client to open the WebSocket. It would be interesting if the server&#039;s operator had deals with operators of other sites, since the server could then decide how to respond (or indeed, <em>whether</em> to respond) based on which site was requesting a connection. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
                <br />
<br />

                Can be safely ignored, though the server should abort the WebSocket connection if this field is absent or has a value that does not match one of the origins the server is expecting to communicate with, to avoid vulnerability to cross-protocol attacks and cross-site scripting attacks.
              
</dd>
<dt>|Sec-WebSocket-Protocol|</dt>
<dd>
                The value gives the name of a subprotocol that the client is intending to select. It would be interesting if the server supports multiple protocols or protocol versions.
                <br />
<br />

                Can be safely ignored, though the server may abort the WebSocket connection if the field is absent but the conventions for communicating with the server are such that the field is expected; and the server should abort the WebSocket connection if the field has a value that does not match one of the subprotocols that the server supports, to avoid integrity errors once the connection is established.
              
</dd>
<dt>|Sec-WebSocket-Key1|</dt>
<dd>
                
              
</dd>
<dt>|Sec-WebSocket-Key2|</dt>
<dd>
                The values provide the information required for computing the server&#039;s handshake, as described in the next section.
              
</dd>
<dt>|Sec-WebSocket-Draft|</dt>
<dd>
                The value provides the version of this draft protocol that the client is attempting to establish a connection using. If this value is not equal to a version of the draft protocol that the server understands, the server MUST abort the WebSocket connection.
              
</dd>
<dt>Other fields</dt>
<dd>
                Other fields can be used, such as &quot;Cookie&quot;, for authentication purposes. Their semantics are equivalent to the semantics of the HTTP headers with the same names.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>Unrecognized fields can be safely ignored, and are probably either the result of intermediaries injecting fields unrelated to the operation of the WebSocket protocol, or clients that support future versions of the protocol offering options that the server doesn&#039;t support.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Sending the server&#039;s opening handshake</h3>

<p>
            When a client establishes a WebSocket connection to a server, the server must run the following steps.
            </p>
<ol class="text">
<li>
                If the server supports encryption, perform a TLS handshake over the connection. If this fails (e.g. the client indicated a host name in the extended client hello &quot;server_name&quot; extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server handshake) must run through the encrypted tunnel. <a class='info' href='#RFC2246'>[RFC2246]<span> (</span><span class='info'>Dierks, T. and C. Allen, &ldquo;The TLS Protocol Version 1.0,&rdquo; January&nbsp;1999.</span><span>)</span></a>
              
</li>
<li>
                Establish the following information:
<blockquote class="text"><dl>
<dt>/host/</dt>
<dd>
                    The host name or IP address of the WebSocket server, as it is to be addressed by clients. The host name must be punycode-encoded if necessary. If the server can respond to requests to multiple hosts (e.g. in a virtual hosting environment), then the value should be derived from the client&#039;s handshake, specifically from the &quot;Host&quot; field. The /host/ value must be lowercase (not containing characters in the range U+0041 LATIN CAPITAL LETTER A to U+005A LATIN CAPITAL LETTER Z).
                  
</dd>
<dt>/port/</dt>
<dd>
                    The port number on which the server expected and/or received the connection.
                  
</dd>
<dt>/resource name/</dt>
<dd>
                    An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client&#039;s handshake.
                  
</dd>
<dt>/secure flag/</dt>
<dd>
                    
                  
</dd>
<dt></dt>
<dd>
                    True if the connection is encrypted or if the server expected it to be encrypted; false otherwise.
                  
</dd>
<dt>/origin/</dt>
<dd>
                    The ASCII serialization of the origin that the server is willing to communicate with, converted to ASCII lowercase. If the server can respond to requests from multiple origins (or indeed, all origins), then the value should be derived from the client&#039;s handshake, specifically from the &quot;Origin&quot; field. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
                  
</dd>
<dt>/subprotocol/</dt>
<dd>
                    Either null, or a string representing the subprotocol the server is ready to use. If the server supports multiple subprotocols, then the value should be derived from the client&#039;s handshake, specifically by selecting one of the values from the &quot;Sec-WebSocket-Protocol&quot; field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes.
                  
</dd>
<dt>/key_1/</dt>
<dd>
                    The value of the &quot;Sec-WebSocket-Key1&quot; field in the client&#039;s handshake.
                  
</dd>
<dt>/key_2/</dt>
<dd>
                    The value of the &quot;Sec-WebSocket-Key2&quot; field in the client&#039;s handshake.
                  
</dd>
<dt>/key_3/</dt>
<dd>
                    The eight random bytes sent after the first 0x0D 0x0A 0x0D 0x0A sequence in the client&#039;s handshake.
                  
</dd>
</dl></blockquote>
              
</li>
<li>Let /location/ be the string that results from constructing a WebSocket URL from /host/, /port/, /resource name/, and /secure flag/.
</li>
<li>
                Let /key-number_1/ be the digits (characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9)) in /key_1/, interpreted as a base ten integer, ignoring all other characters in /key_1/.
                <br />
<br />

                Let /key-number_2/ be the digits (characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9)) in /key_2/, interpreted as a base ten integer, ignoring all other characters in /key_2/.
<blockquote class="text">
<p>
                    EXAMPLE: For example, assume that the client handshake was:<br />
<br />

                    </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           GET / HTTP/1.1
           Connection: Upgrade
           Host: example.com
           Upgrade: WebSocket
           Sec-WebSocket-Key1: 3e6b263  4 17 80
           Origin: http://example.com
           Sec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90

           WjN}|M(6
</pre></div><p>

                  
</p>
<p>The /key-number_1/ would be the number 3,626,341,780, and the /key-number_2/ would be the number 1,799,227,390.
</p>
<p>In this example, incidentally, /key_3/ is &quot;WjN}|M(6&quot;, or 0x57 0x6A 0x4E 0x7D 0x7C 0x4D 0x28 0x36.
</p>
</blockquote>
              
</li>
<li>
                Let /spaces_1/ be the number of U+0020 SPACE characters in /key_1/.
                <br />
<br />

                Let /spaces_2/ be the number of U+0020 SPACE characters in /key_2/.
                <br />
<br />

                If either /spaces_1/ or /spaces_2/ is zero, then abort the WebSocket connection. This is a symptom of a cross-protocol attack.
                <br />
<br />

                EXAMPLE: In the example above, /spaces_1/ would be 4 and /spaces_2/ would be 10.
              
</li>
<li>
                If /key-number_1/ is not an integral multiple of /spaces_1/, then abort the WebSocket connection.
                <br />
<br />

                If /key-number_2/ is not an integral multiple of /spaces_2/, then abort the WebSocket connection.
                <br />
<br />

                NOTE: This can only happen if the client is not a conforming WebSocket client.
              
</li>
<li>
                Let /part_1/ be /key-number_1/ divided by /spaces_1/.
                <br />
<br />

                Let /part_2/ be /key-number_2/ divided by /spaces_2/.
                <br />
<br />

                EXAMPLE: In the example above, /part_1/ would be 906,585,445 and /part_2/ would be 179,922,739.
              
</li>
<li>
                Let /challenge/ be the concatenation of /part_1/, expressed as a big-endian 32 bit integer, /part_2/, expressed as a big-endian 32 bit integer, and the eight bytes of /key_3/ in the order they were sent on the wire.
                <br />
<br />

                EXAMPLE: In the example above, this would be the 16 bytes 0x36 0x09 0x65 0x65 0x0A 0xB9 0x67 0x33 0x57 0x6A 0x4E 0x7D 0x7C 0x4D 0x28 0x36.
              
</li>
<li>
                Let /response/ be the MD5 fingerprint of /challenge/ as a big-endian 128 bit string. <a class='info' href='#RFC1321'>[RFC1321]<span> (</span><span class='info'>Rivest, R., &ldquo;The MD5 Message-Digest Algorithm,&rdquo; April&nbsp;1992.</span><span>)</span></a>
                <br />
<br />

                EXAMPLE: In the example above, this would be the 16 bytes 0x6E 0x60 0x39 0x65 0x42 0x6B 0x39 0x7A 0x24 0x52 0x38 0x70 0x4F 0x74 0x56 0x62, or &quot;n`9eBk9z$R8pOtVb&quot; in UTF-8.
              
</li>
<li>
                Send the following line, terminated by the two characters U+000D CARRIAGE RETURN and U+000A LINE FEED (CRLF) and encoded as UTF-8, to the client:<br />
<br />

                <div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        HTTP/1.1 101 WebSocket Protocol Handshake</pre></div>

                <br />
<br />

                This line may be sent differently if necessary, but must match the Status-Line production defined in the HTTP specification, with the Status-Code having the value 101.
              
</li>
<li>
                Send the following fields to the client. Each field must be sent as a line consisting of the field name, which must be an ASCII case-insensitive match for the field name in the list below, followed by a U+003A COLON character (:) and a U+0020 SPACE character, followed by the field value as specified in the list below, followed by the two characters U+000D CARRIAGE RETURN and U+000A LINE FEED (CRLF). The lines must be encoded as UTF-8. The lines may be sent in any order.
<blockquote class="text"><dl>
<dt>|Upgrade|</dt>
<dd>
                    The value must be the string &quot;WebSocket&quot;.
                  
</dd>
<dt>|Connection|</dt>
<dd>
                    The value must be the string &quot;Upgrade&quot;.
                  
</dd>
<dt>|Sec-WebSocket-Location|</dt>
<dd>
                    The value must be /location/
                  
</dd>
<dt>|Sec-WebSocket-Origin|</dt>
<dd>
                    The value must be /origin/
                  
</dd>
<dt>|Sec-WebSocket-Protocol|</dt>
<dd>
                    This field must be included if /subprotocol/ is not null, and must not be included if /subprotocol/ is null.
                    <br />
<br />

                    If included, the value must be /subprotocol/
                  
</dd>
</dl></blockquote>
                Optionally, include &quot;Set-Cookie&quot;, &quot;Set-Cookie2&quot;, or other cookie-related fields, with values equal to the values that would be used for the identically named HTTP headers. <a class='info' href='#RFC2109'>[RFC2109]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; February&nbsp;1997.</span><span>)</span></a> <a class='info' href='#RFC2965'>[RFC2965]<span> (</span><span class='info'>Kristol, D. and L. Montulli, &ldquo;HTTP State Management Mechanism,&rdquo; October&nbsp;2000.</span><span>)</span></a>
              
</li>
<li>Send two bytes 0x0D 0x0A (UTF-8 CRLF).
</li>
<li>Send /response/.
</li>
</ol><p>
          
</p>
<p>This completes the server&#039;s handshake. If the server finishes these steps without aborting the WebSocket connection, and if the client does not then fail the WebSocket connection, then the connection is established and the server may begin sending and receiving data, as described in the next section.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Error Handling</h3>

<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Handling errors in UTF-8 from the server</h3>

<p>When a client is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, then any bytes or sequences of bytes that are not valid UTF-8 sequences must be interpreted as a U+FFFD REPLACEMENT CHARACTER.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Handling errors in UTF-8 from the client</h3>

<p>When a server is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, behavior is undefined. A server could close the connection, convert invalid byte sequences to U+FFFD REPLACEMENT CHARACTERs, store the data verbatim, or perform application-specific processing. Subprotocols layered on the WebSocket protocol might define specific behavior for servers.
</p>
<a name="closing_connection"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Closing the connection</h3>

<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Client-initiated closure</h3>

<p>
          Certain algorithms require the user agent to <strong>fail the WebSocket connection</strong>. To do so, the user agent must close the WebSocket connection, and may report the problem to the user (which would be especially useful for developers).
        
</p>
<p>Except as indicated above or as specified by the application layer (e.g. a script using the WebSocket API), user agents should not close the connection.
</p>
<p>
          User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:
          </p>
<ul class="text">
<li>A server whose host name could not be resolved.
</li>
<li>A server to which packets could not successfully be routed.
</li>
<li>A server that refused the connection on the specified port.
</li>
<li>A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).
</li>
<li>A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified an origin that differed from the script&#039;s).
</li>
<li>A WebSocket server that abruptly closed the connection after successfully completing the opening handshake.
</li>
</ul><p>
        
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Server-initiated closure</h3>

<p>
          Certain algorithms require or recommend that the server <strong>abort the WebSocket connection</strong> during the opening handshake. To do so, the server must simply close the WebSocket connection.
        
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Closure</h3>

<p>
          To <strong>close the WebSocket connection</strong>, the user agent or server must close the TCP connection, using whatever mechanism possible (e.g. either the TCP RST or FIN mechanisms). When a user agent notices that the server has closed its connection, it must immediately close its side of the connection also. Whether the user agent or the server closes the connection first, it is said that the <strong>WebSocket connection is closed</strong>. If the connection was closed after the client finished the WebSocket closing handshake, then the WebSocket connection is said to have been closed <em>cleanly</em>.
        
</p>
<p>Servers may close the WebSocket connection whenever desired. User agents should not close the WebSocket connection arbitrarily.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Known extensions</h3>

<p>Extensions provide a mechanism for implementations to opt-in to
      additional protocol features. This section defines the meaning of
      well-known extensions but implementations may use extensions defined
      separately as well.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Compression</h3>

<p>The registered extension token for this compression extension is
        "deflate-stream".
</p>
<p>The extension does not have any per message extension data and it
        does not define the use of any WebSocket reserved bits or op codes.
</p>
<p>Senders using this extension MUST apply RFC 1951 encodings to all
        bytes of the data stream following the handshake including both data
        and control messages. The data stream MAY include multiple blocks of
        both compressed and uncompressed types as defined by RFC 1951. <a class='info' href='#RFC1951'>[RFC1951]<span> (</span><span class='info'>Deutsch, P., &ldquo;DEFLATE Compressed Data Format Specification version 1.3,&rdquo; May&nbsp;1996.</span><span>)</span></a>
</p>
<p>Senders MUST NOT delay the transmission of any portion of a WebSocket
        message because the deflate encoding of the message does not end on a
        byte boundary. The encodings for adjacent messages MAY appear in the
        same byte if no delay in transmission is occurred by doing so.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security considerations</h3>

<p>While this protocol is intended to be used by scripts in Web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf, and can therefore send fake &quot;Origin&quot; fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins, and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.
</p>
<p>EXAMPLE: For example, if the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.
</p>
<p>
        <br />
<br />

      
</p>
<p>Servers that are not intended to process input from any Web page but only for certain sites should verify the &quot;Origin&quot; field is an origin they expect, and should only respond with the corresponding &quot;Sec-WebSocket-Origin&quot; if it is an accepted origin. Servers that only accept input from one origin can just send back that value in the &quot;Sec-WebSocket-Origin&quot; field, without bothering to check the client&#039;s value.
</p>
<p>
        <br />
<br />

      
</p>
<p>If at any time a server is faced with data that it does not understand, or that violates some criteria by which the server determines safety of input, or when the server sees a handshake that does not correspond to the values the server is expecting (e.g. incorrect path or origin), the server should just disconnect. It is always safe to disconnect.
</p>
<p>
        <br />
<br />

      
</p>
<p>The biggest security risk when sending text data using this protocol is sending data using the wrong encoding. If an attacker can trick the server into sending data encoded as ISO-8859-1 verbatim (for instance), rather than encoded as UTF-8, then the attacker could inject arbitrary frames into the data stream.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA considerations</h3>

<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Registration of ws: scheme</h3>

<p>
          A |ws:| URL identifies a WebSocket server and resource name.
          </p>
<blockquote class="text"><dl>
<dt>URI scheme name.</dt>
<dd>
              ws
            
</dd>
<dt>Status.</dt>
<dd>
              Permanent.
            
</dd>
<dt>URI scheme syntax.</dt>
<dd>
              In ABNF terms using the terminals from the URI specifications: <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a><br />
<br />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        "ws" ":" hier-part [ "?" query ]</pre></div>

              <br />
<br />

              The path and query components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.
            
</dd>
<dt>URI scheme semantics.</dt>
<dd>
              The only operation for this scheme is to open a connection using the WebSocket protocol.
            
</dd>
<dt>Encoding considerations.</dt>
<dd>
              Characters in the host component that are excluded by the syntax defined above must be converted from Unicode to ASCII by applying the IDNA ToASCII algorithm to the Unicode host name, with both the AllowUnassigned and UseSTD3ASCIIRules flags set, and using the result of this algorithm as the host in the URI. <a class='info' href='#RFC3490'>[RFC3490]<span> (</span><span class='info'>Faltstrom, P., Hoffman, P., and A. Costello, &ldquo;Internationalizing Domain Names in Applications (IDNA),&rdquo; March&nbsp;2003.</span><span>)</span></a>
              <br />
<br />

              Characters in other components that are excluded by the syntax defined above must be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specification. <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> <a class='info' href='#RFC3987'>[RFC3987]<span> (</span><span class='info'>Duerst, M. and M. Suignard, &ldquo;Internationalized Resource Identifiers (IRIs),&rdquo; January&nbsp;2005.</span><span>)</span></a>
            
</dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd>
              WebSocket protocol.
            
</dd>
<dt>Interoperability considerations.</dt>
<dd>
              None.
            
</dd>
<dt>Security considerations.</dt>
<dd>
              See &quot;Security considerations&quot; section above.
            
</dd>
<dt>Contact.</dt>
<dd>
              Ian Hickson &lt;ian@hixie.ch&gt;
            
</dd>
<dt>Author/Change controller.</dt>
<dd>
              Ian Hickson &lt;ian@hixie.ch&gt;
            
</dd>
<dt>References.</dt>
<dd>
              This document.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Registration of wss: scheme</h3>

<p>
          A |wss:| URL identifies a WebSocket server and resource name, and indicates that traffic over that connection is to be encrypted.
          </p>
<blockquote class="text"><dl>
<dt>URI scheme name.</dt>
<dd>
              wss
            
</dd>
<dt>Status.</dt>
<dd>
              Permanent.
            
</dd>
<dt>URI scheme syntax.</dt>
<dd>
              In ABNF terms using the terminals from the URI specifications: <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a><br />
<br />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>        "wss" ":" hier-part [ "?" query ]</pre></div>

              <br />
<br />

              The path and query components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.
            
</dd>
<dt>URI scheme semantics.</dt>
<dd>
              The only operation for this scheme is to open a connection using the WebSocket protocol, encrypted using TLS.
            
</dd>
<dt>Encoding considerations.</dt>
<dd>
              Characters in the host component that are excluded by the syntax defined above must be converted from Unicode to ASCII by applying the IDNA ToASCII algorithm to the Unicode host name, with both the AllowUnassigned and UseSTD3ASCIIRules flags set, and using the result of this algorithm as the host in the URI. <a class='info' href='#RFC3490'>[RFC3490]<span> (</span><span class='info'>Faltstrom, P., Hoffman, P., and A. Costello, &ldquo;Internationalizing Domain Names in Applications (IDNA),&rdquo; March&nbsp;2003.</span><span>)</span></a>
              <br />
<br />

              Characters in other components that are excluded by the syntax defined above must be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specification. <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> <a class='info' href='#RFC3987'>[RFC3987]<span> (</span><span class='info'>Duerst, M. and M. Suignard, &ldquo;Internationalized Resource Identifiers (IRIs),&rdquo; January&nbsp;2005.</span><span>)</span></a>
            
</dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd>
              WebSocket protocol over TLS.
            
</dd>
<dt>Interoperability considerations.</dt>
<dd>
              None.
            
</dd>
<dt>Security considerations.</dt>
<dd>
              See &quot;Security considerations&quot; section above.
            
</dd>
<dt>Contact.</dt>
<dd>
              Ian Hickson &lt;ian@hixie.ch&gt;
            
</dd>
<dt>Author/Change controller.</dt>
<dd>
              Ian Hickson &lt;ian@hixie.ch&gt;
            
</dd>
<dt>References.</dt>
<dd>
              This document.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Registration of the &quot;WebSocket&quot; HTTP Upgrade keyword</h3>

<p>
          </p>
<blockquote class="text"><dl>
<dt>Name of token.</dt>
<dd>
              WebSocket
            
</dd>
<dt>Author/Change controller.</dt>
<dd>
              Ian Hickson &lt;ian@hixie.ch&gt;
            
</dd>
<dt>Contact.</dt>
<dd>
              Ian Hickson &lt;ian@hixie.ch&gt;
            
</dd>
<dt>References.</dt>
<dd>
              This document.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
Sec-WebSocket-Key1 and Sec-WebSocket-Key2</h3>

<p>
          This section describes two header fields for registration in the Permanent Message Header Field Registry. <a class='info' href='#RFC3864'>[RFC3864]<span> (</span><span class='info'>Klyne, G., Nottingham, M., and J. Mogul, &ldquo;Registration Procedures for Message Header Fields,&rdquo; September&nbsp;2004.</span><span>)</span></a>
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Header field name</dt>
<dd>
              Sec-WebSocket-Key1
            
</dd>
<dt>Applicable protocol</dt>
<dd>
              http
            
</dd>
<dt>Status</dt>
<dd>
              reserved; do not use outside WebSocket handshake
            
</dd>
<dt>Author/Change controller</dt>
<dd>
              IETF
            
</dd>
<dt>Specification document(s)</dt>
<dd>
               This document is the relevant specification.
            
</dd>
<dt>Related information</dt>
<dd>
              None.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Header field name</dt>
<dd>
              Sec-WebSocket-Key2
            
</dd>
<dt>Applicable protocol</dt>
<dd>
              http
            
</dd>
<dt>Status</dt>
<dd>
              reserved; do not use outside WebSocket handshake
            
</dd>
<dt>Author/Change controller</dt>
<dd>
              IETF
            
</dd>
<dt>Specification document(s)</dt>
<dd>
               This document is the relevant specification.
            
</dd>
<dt>Related information</dt>
<dd>
              None.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>The |Sec-WebSocket-Key1| and |Sec-WebSocket-Key2| headers are used in the WebSocket handshake. They are sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket handshake. This helps ensure that the server does not accept connections from non-Web-Socket clients (e.g. HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
Sec-WebSocket-Location</h3>

<p>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <a class='info' href='#RFC3864'>[RFC3864]<span> (</span><span class='info'>Klyne, G., Nottingham, M., and J. Mogul, &ldquo;Registration Procedures for Message Header Fields,&rdquo; September&nbsp;2004.</span><span>)</span></a>
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Header field name</dt>
<dd>
              Sec-WebSocket-Location
            
</dd>
<dt>Applicable protocol</dt>
<dd>
              http
            
</dd>
<dt>Status</dt>
<dd>
              reserved; do not use outside WebSocket handshake
            
</dd>
<dt>Author/Change controller</dt>
<dd>
              IETF
            
</dd>
<dt>Specification document(s)</dt>
<dd>
               This document is the relevant specification.
            
</dd>
<dt>Related information</dt>
<dd>
              None.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>The |Sec-WebSocket-Location| header is used in the WebSocket handshake. It is sent from the server to the client to confirm the URL of the connection. This enables the client to verify that the connection was established to the right server, port, and path, instead of relying on the server to verify that the requested host, port, and path are correct.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6"></a><h3>10.6.&nbsp;
Sec-WebSocket-Origin</h3>

<p>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <a class='info' href='#RFC3864'>[RFC3864]<span> (</span><span class='info'>Klyne, G., Nottingham, M., and J. Mogul, &ldquo;Registration Procedures for Message Header Fields,&rdquo; September&nbsp;2004.</span><span>)</span></a>
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Header field name</dt>
<dd>
              Sec-WebSocket-Origin
            
</dd>
<dt>Applicable protocol</dt>
<dd>
              http
            
</dd>
<dt>Status</dt>
<dd>
              reserved; do not use outside WebSocket handshake
            
</dd>
<dt>Author/Change controller</dt>
<dd>
              IETF
            
</dd>
<dt>Specification document(s)</dt>
<dd>
               This document is the relevant specification.
            
</dd>
<dt>Related information</dt>
<dd>
              None.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>The |Sec-WebSocket-Origin| header is used in the WebSocket handshake. It is sent from the server to the client to confirm the origin of the script that opened the connection. This enables user agents to verify that the server is willing to serve the script that opened the connection.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.7"></a><h3>10.7.&nbsp;
Sec-WebSocket-Protocol</h3>

<p>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <a class='info' href='#RFC3864'>[RFC3864]<span> (</span><span class='info'>Klyne, G., Nottingham, M., and J. Mogul, &ldquo;Registration Procedures for Message Header Fields,&rdquo; September&nbsp;2004.</span><span>)</span></a>
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Header field name</dt>
<dd>
              Sec-WebSocket-Protocol
            
</dd>
<dt>Applicable protocol</dt>
<dd>
              http
            
</dd>
<dt>Status</dt>
<dd>
              reserved; do not use outside WebSocket handshake
            
</dd>
<dt>Author/Change controller</dt>
<dd>
              IETF
            
</dd>
<dt>Specification document(s)</dt>
<dd>
               This document is the relevant specification.
            
</dd>
<dt>Related information</dt>
<dd>
              None.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>The |Sec-WebSocket-Protocol| header is used in the WebSocket handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.8"></a><h3>10.8.&nbsp;
Sec-WebSocket-Draft</h3>

<p>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <a class='info' href='#RFC3864'>[RFC3864]<span> (</span><span class='info'>Klyne, G., Nottingham, M., and J. Mogul, &ldquo;Registration Procedures for Message Header Fields,&rdquo; September&nbsp;2004.</span><span>)</span></a>
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>Header field name</dt>
<dd>
              Sec-WebSocket-Draft
            
</dd>
<dt>Applicable protocol</dt>
<dd>
              http
            
</dd>
<dt>Status</dt>
<dd>
              reserved; do not use outside WebSocket handshake
            
</dd>
<dt>Author/Change controller</dt>
<dd>
              IETF
            
</dd>
<dt>Specification document(s)</dt>
<dd>
               This document is the relevant specification.
            
</dd>
<dt>Related information</dt>
<dd>
              None.
            
</dd>
</dl></blockquote><p>
        
</p>
<p>The |Sec-WebSocket-Draft| header is used in the WebSocket handshake. It is sent from the client to the server to indicate the draft protocol version of the connection. This enables servers to correctly interpret the handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Using the WebSocket protocol from other specifications</h3>

<p>The WebSocket protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g. in a specification defining a scripted API.
</p>
<p>
        Such a specification first needs to &quot;establish a WebSocket connection&quot;, providing that algorithm with:
        </p>
<ul class="text">
<li>The destination, consisting of a /host/ and a /port/.
</li>
<li>A /resource name/, which allows for multiple services to be identified at one host and port.
</li>
<li>A /secure/ flag, which is true if the connection is to be encrypted, and false otherwise.
</li>
<li>
            An ASCII serialization of an origin that is being made responsible for the connection. <a class='info' href='#ORIGIN'>[ORIGIN]<span> (</span><span class='info'>Barth, A., Jackson, C., and I. Hickson, &ldquo;The HTTP Origin Header,&rdquo; September&nbsp;2009.</span><span>)</span></a>
          
</li>
<li>Optionally a string identifying a protocol that is to be layered over the WebSocket connection.
</li>
</ul><p>
      
</p>
<p>The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URL using the steps to parse a WebSocket URL&#039;s components. These steps fail if the URL does not specify a WebSocket.
</p>
<p>If a connection can be established, then it is said that the &quot;WebSocket connection is established&quot;.
</p>
<p>If at any time the connection is to be closed, then the specification needs to use the &quot;close the WebSocket connection&quot; algorithm.
</p>
<p>When the connection is closed, for any reason including failure to establish the connection in the first place, it is said that the &quot;WebSocket connection is closed&quot;.
</p>
<p>While a connection is open, the specification will need to handle the cases when &quot;a WebSocket message has been received&quot; with text /data/.
</p>
<p>To send some text /data/ to an open connection, the specification needs to &quot;send /data/ using the WebSocket&quot;.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgements</h3>

<p>
        Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification. <a class='info' href='#HTML'>[HTML]<span> (</span><span class='info'>Hickson, I., &ldquo;HTML,&rdquo; August&nbsp;2010.</span><span>)</span></a>
      
</p>
<p>Special thanks also to John Tamplin for providing a significant amount of text for the Data Framing section of this specification.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="HTML">[HTML]</a></td>
<td class="author-text">Hickson, I., &ldquo;<a href="http://whatwg.org/html5">HTML</a>,&rdquo; August&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="ORIGIN">[ORIGIN]</a></td>
<td class="author-text">Barth, A., Jackson, C., and I. Hickson, &ldquo;<a href="http://tools.ietf.org/html/draft-abarth-origin">The HTTP Origin Header</a>,&rdquo; draft-abarth-origin (work in progress), September&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="ANSI.X3-4.1986">[ANSI.X3-4.1986]</a></td>
<td class="author-text">American National Standards Institute, &ldquo;Coded Character Set - 7-bit American Standard Code for Information Interchange,&rdquo; ANSI&nbsp;X3.4, 1986.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1321">[RFC1321]</a></td>
<td class="author-text"><a href="mailto:rivest@theory.lcs.mit.edu">Rivest, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>,&rdquo; RFC&nbsp;1321, April&nbsp;1992 (<a href="http://www.rfc-editor.org/rfc/rfc1321.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1951">[RFC1951]</a></td>
<td class="author-text"><a href="mailto:ghost@aladdin.com">Deutsch, P.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>,&rdquo; RFC&nbsp;1951, May&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1951.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc1951.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc1951.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2109">[RFC2109]</a></td>
<td class="author-text"><a href="mailto:dmk@bell-labs.com">Kristol, D.</a> and <a href="mailto:montulli@netscape.com">L. Montulli</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2109">HTTP State Management Mechanism</a>,&rdquo; RFC&nbsp;2109, February&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2109.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2109.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2109.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2246">[RFC2246]</a></td>
<td class="author-text"><a href="mailto:tdierks@certicom.com">Dierks, T.</a> and <a href="mailto:callen@certicom.com">C. Allen</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2246">The TLS Protocol Version 1.0</a>,&rdquo; RFC&nbsp;2246, January&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2965">[RFC2965]</a></td>
<td class="author-text"><a href="mailto:dmk@bell-labs.com">Kristol, D.</a> and <a href="mailto:lou@montulli.org">L. Montulli</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2965">HTTP State Management Mechanism</a>,&rdquo; RFC&nbsp;2965, October&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2965.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2965.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2965.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3490">[RFC3490]</a></td>
<td class="author-text">Faltstrom, P., Hoffman, P., and A. Costello, &ldquo;<a href="http://tools.ietf.org/html/rfc3490">Internationalizing Domain Names in Applications (IDNA)</a>,&rdquo; RFC&nbsp;3490, March&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3490.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3864">[RFC3864]</a></td>
<td class="author-text">Klyne, G., Nottingham, M., and J. Mogul, &ldquo;<a href="http://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>,&rdquo; BCP&nbsp;90, RFC&nbsp;3864, September&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3864.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3987">[RFC3987]</a></td>
<td class="author-text">Duerst, M. and M. Suignard, &ldquo;<a href="http://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>,&rdquo; RFC&nbsp;3987, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3987.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4366">[RFC4366]</a></td>
<td class="author-text">Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &ldquo;<a href="http://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a>,&rdquo; RFC&nbsp;4366, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4366.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5234">[RFC5234]</a></td>
<td class="author-text">Crocker, D. and P. Overell, &ldquo;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5234.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="WSAPI">[WSAPI]</a></td>
<td class="author-text">Hickson, I., &ldquo;<a href="http://dev.w3.org/html5/websockets/">The Web Sockets API</a>,&rdquo; August&nbsp;2010.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ian Fette</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google, Inc.</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ifette+ietf@google.com">ifette+ietf@google.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.ianfette.com/">http://www.ianfette.com/</a></td></tr>
</table>
</body></html>
