evaluation = Evaluate(skS, pkS, blindToken)

issuedToken = Unblind(pkS, token, blindToken, evaluation)
output = Finalize(input, issuedToken, info)

contextString = I2OSP(modeBase, 1) + I2OSP(suite.ID, 2)
contextString = I2OSP(modeBase, 1) + I2OSP(suite.ID, 2)
contextString = I2OSP(modeVerifiable, 1) + I2OSP(suite.ID, 2)
contextString = I2OSP(modeVerifiable, 1) + I2OSP(suite.ID, 2)
BT = GG.Deserialize(blindedToken)
Z = skS * BT
serializedElement = GG.Serialize(Z)

Ev = Evaluation{ element: serializedElement }

T = GG.HashToGroup(input)
element = GG.Serialize(T)
issuedElement = Evaluate(skS, pkS, [element])
E = GG.Serialize(issuedElement)

finalizeDST = "RFCXXXX-Finalize-" + client.contextString
hashInput = len(input) || input ||
                 len(E) || E ||
                 len(info) || info ||
                 len(finalizeDST) || finalizeDST
digest = Hash(hashInput)

BT = GG.Deserialize(blindedToken)
Z = skS * BT
serializedElement = GG.Serialize(Z)

proof = GenerateProof(skS, pkS, blindedToken, serializedElement)
Ev = Evaluation{ element: serializedElement, proof: proof }

G = GG.Generator()
gen = GG.Serialize(G)

blindTokenList = [blindedToken]
elementList = [element]

M = GG.Deserialize(a1)
r = GG.RandomScalar()
a3 = GG.Serialize(r * G)
a4 = GG.Serialize(r * M)

challengeDST = "RFCXXXX-challenge-" + self.contextString
h2Input = I2OSP(len(gen), 2) || gen ||
               I2OSP(len(pkS), 2) || pkS ||
               I2OSP(len(a1), 2) || a1 || I2OSP(len(a2), 2) || a2 ||
               I2OSP(len(a3), 2) || a3 || I2OSP(len(a4), 2) || a4 ||
               I2OSP(len(challengeDST), 2) || challengeDST

c = GG.HashToScalar(h2Input)
s = (r - c * skS) mod p

seedDST = "RFCXXXX-seed-" + self.contextString
compositeDST = "RFCXXXX-composite-" + self.contextString
h1Input = I2OSP(len(gen), 2) || gen ||
               I2OSP(len(pkS), 2) || pkS ||
               I2OSP(len(blindedTokens), 2) || blindedTokens ||
               I2OSP(len(elements), 2) || elements ||
               I2OSP(len(seedDST), 2) || seedDST

seed = Hash(h1Input)
M = GG.Identity()
Z = GG.Identity()
h2Input = I2OSP(len(seed), 2) || seed || I2OSP(i, 2) ||
                 I2OSP(len(compositeDST), 2) || compositeDST
di = GG.HashToScalar(h2Input)
Mi = GG.Deserialize(blindedTokens[i])
Zi = GG.Deserialize(elements[i])
M = di * Mi + M
Z = di * Zi + Z
r = GG.RandomScalar()
P = GG.HashToGroup(input)
blindedToken = GG.Serialize(r * P)

token = Token{ data: input, blind: r }

r = token.blind
Z = GG.Deserialize(Ev.element)
N = (r^(-1)) * Z

unblindedToken = GG.Serialize(N)

finalizeDST = "RFCXXXX-Finalize-" + self.contextString
hashInput = len(T.data) || T.data ||
                 len(E) || E ||
                 len(info) || info ||
                 len(finalizeDST) || finalizeDST
G = GG.Generator()
gen = GG.Serialize(G)

blindTokenList = [blindedToken]
elementList = [Ev.element]

a3 = GG.Serialize(A')
a4 = GG.Serialize(B')

challengeDST = "RFCXXXX-challenge-" + self.contextString
h2Input = I2OSP(len(gen), 2) || gen ||
               I2OSP(len(pkS), 2) || pkS ||
               I2OSP(len(a1), 2) || a1 ||
               I2OSP(len(a2), 2) || a2 ||
               I2OSP(len(a3), 2) || a3 ||
               I2OSP(len(a4), 2) || a4 ||
               I2OSP(len(challengeDST), 2) || challengeDST

c  = GG.HashToScalar(h2Input)

r = token.blind
Z = GG.Deserialize(Ev.element)
N = (r^(-1)) * Z

unblindedToken = GG.Serialize(N)

PK = GG.Deserialize(pkS)
r = GG.RandomScalar()
blindedGenerator = GG.Serialize(r * GG.Generator())
blindedPublicKey = GG.Serialize(r * PK)

preproc = PrepocessedBlind{
       blind: r,
       blindedGenerator: blindedGenerator,
       blindedPublicKey: blindedPublicKey,
Q = GG.Deserialize(preproc.blindedGenerator) /* Q = r * G */
P = GG.HashToGroup(input)

token = Token{
       data: input,
       blind: preproc.blindedPublicKey
blindedToken = GG.Serialize(P + Q)           /* P + r * G */

PKR = GG.Deserialize(token.blind)
Z = GG.Deserialize(ev.element)
unblindedToken = GG.Serialize(N)

