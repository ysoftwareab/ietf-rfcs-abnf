leaf_node_secret = DeriveSecret(leaf_secret, "node")
ciphertext = context.Seal("", path_secret)

init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)
context = SetupBaseR(kem_output, external_priv, "")
init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)

psk_secret     = psk_secret[n]

   Here 0 represents the all-zero vector of length KDF.Nh.  The index
   field in PSKLabel corresponds to the index of the PSK in the psk
   array, while the count field contains the total number of PSKs.  In
   other words, the PSKs are chained together with KDF.Extract
   invocations, as follows:

                0                                   0       = psk_secret_[0]
                |                                   |
                V                                   V
membership_tag = MAC(membership_key, MLSPlaintextTBM);

ciphertext_sample = ciphertext[0..KDF.Nh-1]

sender_data_key = ExpandWithLabel(sender_data_secret, "key", ciphertext_sample, AEAD.Nk)
sender_data_nonce = ExpandWithLabel(sender_data_secret, "nonce", ciphertext_sample, AEAD.Nn)

   The Additional Authenticated Data (AAD) for the SenderData ciphertext
   is all the fields of MLSCiphertext excluding encrypted_sender_data:

   struct {
       opaque group_id<0..255>;
       uint64 epoch;
       ContentType content_type;
   } MLSSenderDataAAD;

   When parsing a SenderData struct as part of message decryption, the
   recipient MUST verify that the KeyPackageID indicated in the sender
   field identifies a member of the group.

hasUpdates = false
hasRemoves = false

proposal = proposalCache[id]
hasUpdates = hasUpdates || proposal.msg_type == update
hasRemoves = hasRemoves || proposal.msg_type == remove

welcome_nonce = KDF.Expand(welcome_secret, "nonce", AEAD.Nn)
welcome_key = KDF.Expand(welcome_secret, "key", AEAD.Nk)

parent=01x => left=00x, right=10x
k = 0
k = 0
w = node_width(n)
k = level(x)
k = level(x)
r = x ^ (0x03 << (k - 1))
r = left(r)
k = level(x)
b = (x >> (k + 1)) & 0x01
p = parent_step(x)
p = parent_step(p)
p = parent(x, n)
r = root(n)
d = []
x = parent(x, n)
d = direct_path(x, n)
dx = set([x]) | set(direct_path(x, n))
dy = set([y]) | set(direct_path(y, n))
dxy = dx & dy
k = 0
