InterfaceId = First64(SHA1(Route Prefix | M | RFU | Public Key))
                               & 0xfcffffffffffffff

   The  field "RFU" is reserved for future use, and shall be set to zero.
   The  field  "M"  is  a modifier, which is used in the following way. A
   node  generates a private/public key pair, and then attempts duplicate
   address  detection  for  an address generated using the above equation
   with  M  set  to zero. It is very unlikely that a collision will occur
   except  as  a  result  of  an  attack  on  the protocol. However, if a
   collision is detected the host MAY attempt duplicate address detection
   again  with  a  different address, generated using the same public key
   and  with  M  equal to one. If necessary, this process may be repeated
   with  M  equal  to  2 and M equal to 3. Nodes MUST NOT use values of M
   greater  than  three. Four collisions in a row are very, very unlikely
   to  occur  by chance, and are almost certainly the result of either an
   attack on the protocol or an error in the implementation.

   Bit  6 of the host part of the address is the universal/local bit [3].
   It  is  set  to  zero  to  indicate  that the address generated is not
   guaranteed  to  be  globally  unique.  This  ensures  that it will not
   collide  with  an  IP  address derived from an ethernet address. It is
   important  to  avoid such collisions, because hosts that use their MAC
   address  to  derive  their IP address will not expect such collisions,
   and  they might not have a means to recover from them when they occur.
   Bit 7 of the host part of the address is the individual/group bit [3].
   It  is set to zero to indicate that it is the address of an individual
   node, not a group of nodes.

   The  route  prefix  is  included  in the input to the hash function to
   prevent  an  attack in which the attacker expends a very large initial
   set-up  cost,  but  is  then  able to attack many different nodes at a
   relatively low cost per node. If the route prefix was not included, an
   attacker could, at great expense, compute a lookup table that contains
   a  suitable  key  pair  for  each  of  the 2^62 possible values of the
   InterfaceId.  Such  a lookup table could then be used to masquerade as
   any  mobile  node.  Including  the  route prefix makes this attack not
   economically  viable (from the point of view of the attacker), because
   it  means  that such a look-up table can only be used to masquerade as
   nodes  which  have the same route prefix. Typically, there will not be
   enough  nodes  with  the  same  route prefix to justify the expense of
   constructing the lookup table.

  8.2 Resource Exhaustion and other Denial of Service Attacks

   When  designing  these  protocols,  we  found it useful to distinguish
   between  two  different  types  of  denial of service attack. Resource
   exhaustion  attacks are attacks in which the victim has only a limited
   amount of some resource (such as network bandwidth or CPU cycles), and
   the attack consumes some of this resource, leaving the victim with not
   enough  of  it  left to carry out the other work it needs to do. There
   are  denial  of  service  attacks  that  are  not  resource exhaustion
   attacks.  For  example,  forged  binding updates can lead to denial of
   service,  because  packets  will be sent to the wrong care-of address.
   This  is  not  an  example  of  resource  exhaustion;  a  host with an
   unlimited   supply  of  network  bandwidth  and  CPU  would  still  be
   vulnerable  to  denial  of  service  attacks  based  on forged binding
   updates.  This  attack works by corrupting a host's state (its binding
   cache),  not  by  running  it  out of resources. That is, a failure of
   integrity and authentication then leads to denial of service.

   The  binding  updates  that  are  used  in  mobile  IPv6  are  only an
   optimisation.  A mobile node can communicate with a correspondent node
   even  if  the  correspondent  refuses  to  accept  any  of its binding
   updates.  However,  performance  will  suffer because packets from the
   correspondent to the mobile will be routed via the mobile's home agent
   rather  than  a  more direct route. A correspondent can protect itself
   against some of the resource exhaustion attacks by stopping processing
   binding  updates  when  it  is  flooded with a large number of binding
   updates   that   fail   the   cryptographic  integrity  checks.  If  a
   correspondent  finds  that  it  is spending more resources on checking
   bogus  binding  updates than it is likely to save by accepting genuine
   binding  updates,  then  it  can  decide to reject all binding updates
   without performing any cryptographic operations.

   Nodes  that  are willing to expend significant resources responding to
   anyone,  no  matter who they are, will often be vulnerable to resource
   exhaustion  attacks.  The  DoS protection mechanisms described in this
   memo  will  only  be  useful  if  each node has some means of deciding
   whether  it  should  expend  resources on behalf of a particular peer.
   This  information  needed to make this decision will usually originate
   in  layers above IP. For example, TCP knows if the node has a queue of
   data  that it is trying to send to a peer. It is possible to produce a
   conforming implementation of the protocols in this memo without making
   use  of  information  from higher protocol layers, but implementations
   may be able to manage resources more effectively by making use of such
   information.

   In  general, a node will be willing to devote resources to a run of an
   authentication protocol for one of two reasons. In the first case, the
   node  itself  is  trying  to  carry  out  some  work,  and  knows that
   completing  the  authentication protocol run is necessary (or helpful)
   in  getting  that  work  done.  In the second case, the node's peer is
   trying  to  carry  out some work for which the authentication protocol
   run  is  necessary  or  helpful.  In this case, the node does not know
   directly  that  the protocol run is worthwhile, but may be prepared to
   expend resources on behalf of certain peers when they ask it to. There
   is  a  problem  with  this  case  that  is  specific to authentication
   protocols,  and  does not occur with other types of protocol. The node
   will only know that it is worthwhile expending resources on a protocol
   run  when  it  knows that the run has been initiated by a peer that is
   willing  to  devote resources to. However, it will only know this when
   the  peer  has  been successfully authenticated, that is when protocol
   run  has been completed and the resources have already been spent. One
   way  in  which  this  situation  may  be  improved  is  to  divide the
   authentication  protocol  in  to  two phases. The first phase consumes
   very  little  resources,  but  does  not  provide a very high level of
   security.  The  second  phase provides a higher level of security, but
   requires  more resources to provide this level of security. The second
   phase  is  only  started if the first phase completes successfully. In
   this way, only attackers who can break the security of the first phase
   can cause a resource exhaustion attack using the second phase. We have
   used this approach in the protocols described in this memo.

  8.3 Piggybacking and Jitter

   The  mobile  IPv6  specification  allows  for "piggybacking". That is,
   control  messages  such  as binding updates may be combined with other
   messages.  Piggybacking  will  delay these other messages in two ways.
   Firstly,  it  will  make them larger, and larger messages usually take
   longer   to  transmit.  Secondly,  it  will  increase  the  amount  of
   processing that is needed to send and receive the messages because the
   mobility information in the message will need to be processed as well.
   When   the   control   messages   are  authenticated  with  asymmetric
   cryptography,  they will add a large amount of jitter, because digital
   signatures require many bytes to represent and take many CPU cycles to
   compute or verify. Some applications, for example real-time voice, are
   very sensitive to jitter.

   Some   networks  have  "quality  of  service"  facilities  whereby  an
   application can reserve a particular amount of bandwidth. Piggybacking
   can  interfere  with  these  facilities, because when packets are made
   bigger  by  adding  mobility headers they may exceed the size that has
   been  reserved,  and  this  may cause them to be discarded or severely
   delayed by the network.

   Accordingly,  we  recommend  that piggybacking should not be used when
   quality  of  service  facilities  are in use (e.g. the IPv6 flow id is
   nonzero)  and should not be used when asymmetric cryptography is being
   used  to  protect  the  mobility  control portion of the message. This
   recommendation  has  affected the design of the protocols described in
   this  memo;  digital  signatures are carried in UDP messages, not IPv6
   destination  options.  UDP messages cannot be piggybacked, but this is
   not  a  serious problem as we recommend that these messages should not
   be piggybacked.

  8.4 Length of Suboptions

   The IPv6 option length limits the amount of data that may be passed in
   a  destination  option  or as a suboption within a destination option.
   The maximum length of a suboption is 255 bytes, or 2040 bits excluding
   any  other  data  in  the  protocol.  Since  both  a  public key and a
   Diffie-Hellman  value  needs  to  be  passed  in  the CAM-DH protocol,
   passing  these  in  a suboption would limit the key size to 1020 bits.
   These  values  are  just  about enough for current security needs, but
   seem low in view of future developments. They also preclude the use of
   the  same  long  key  for both MIPv6 and other purposes. Therefore, we
   have  chosen  to  run  the  authentication  protocol as an independent
   protocol on top of UDP.

  8.5 Rationale for BAKE/2

   Our  motivation for designing BAKE/2 was that we wanted to add support
   for  mobile IP without creating major new security problems. We wanted
   a  protocol  that  would  protect against the new vulnerabilities that
   were introduced by IP mobility. It was not our goal to protect against
   attacks  that  were  already  possible  before  the introduction of IP
   mobility.  This  protocol  does not defend against an attacker who can
   monitor  the home agent to correspondent node route. Our justification
   for  this  is that if such an attacker exists, they are able to attack
   the  system  before  IP mobility is enabled, because they can mount an
   active attack against the mobile node when it is at its home location.
   Prevention  of such attacks is outside the scope of this protocol. The
   possibility  of such attacks is not an impediment to the deployment of
   mobile  IP, because these attacks are possible irrespective of whether
   mobile IP is in use or not.

   Some of our earlier protocols for authenticating binding updates, such
   as  CAM  [5],  ran  the complete protocol for each binding update. The
   protocol  described  here  establishes a session key which can then be
   used  for  many binding updates between the same nodes without running
   the  whole  protocol  again.  This can result in an efficiency saving,
   because   binding  updates  are  resent  at  regular  intervals.  This
   efficiency  saving  will  usually  be  realised  when  a  mobile  node
   communicates  with  the same correspondent node for an extended period
   of  time. If the mobile node communicates with a correspondent briefly
   and  then never talks to it again, then the establishment of a session
   key does not result in efficiency savings.

   This  protocol  protects  the  correspondent  node  against  denial of
   service  attacks in which the correspondent is flooded with many bogus
   messages.  The correspondent does not have to store state or consume a
   large  amount of processing time handling messages from a source which
   has  not  yet  been  authenticated.  The protocol does not protect the
   mobile  against  these  attacks.  This  means  that  this  protocol is
   suitable for use when a client on a mobile node accesses a server on a
   non-mobile  node,  but  may  not  be suitable for use when accessing a
   server  on  a mobile node. It is an assumption of the protocol that at
   the  start of a run the mobile node already has stored state about the
   correspondent  (perhaps  at  a  level  above  IP,  such  as TCP or the
   application),  and  knows that it is worthwhile expending resources on
   the  run.  There is a clear need for a protocol for the opposite case,
   where the correspondent has pre-existing stored state about the mobile
   and  knows  that  it is worthwhile expending resources on the protocol
   run. This is a matter for further study.

   This protocol also protects against denial of service attacks in which
   the attacker pretends to be a mobile, but uses the victim's address as
   the  care  of  address,  and  so  causes the correspondent to send the
   victim  traffic  that  it does not want. For example, suppose that the
   correspondent is a news site that will send a high-bandwidth stream of
   video  to  anyone  who  asks for it. Note that the use of flow-control
   protocols such as TCP does not necessarily defend against this type of
   attack,  because  the  attacker  can  fake  the acknowledgements. Even
   keeping  TCP initial sequence numbers secret doesn't help, because the
   attacker can receive the first few segments (including the ISN) at its
   own  address,  and  then  redirect the stream to the victim's address.
   This  protocol  defends  against  these  attacks by only completing if
   packets  sent by the correspondent to the care of address are received
   and  processed  by  an  entity  that  is willing to participate in the
   protocol. Normally, this will be the mobile node.

