leaf_node_secret = DeriveSecret(leaf_secret, "node")
ciphertext = context.Seal(group_context, path_secret)
init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)
context = SetupBaseR(kem_output, external_priv, PublicGroupState)
init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)

psk_secret     = psk_secret_[0] || ... || psk_secret_[n-1]
   The "index" field in "PSKLabel" corresponds to the index of the PSK
   in the "psk" array, while the "count" field contains the total number
   of PSKs.

membership_tag = MAC(membership_key, MLSPlaintextTBM);

ciphertext_sample = ciphertext[0..KDF.Nh-1]

sender_data_key = ExpandWithLabel(sender_data_secret, "key", ciphertext_sample, AEAD.Nk)
sender_data_nonce = ExpandWithLabel(sender_data_secret, "nonce", ciphertext_sample, AEAD.Nn)

   The Additional Authenticated Data (AAD) for the SenderData ciphertext
   is all the fields of MLSCiphertext excluding "encrypted_sender_data":

   struct {
       opaque group_id<0..255>;
       uint64 epoch;
       ContentType content_type;
   } MLSSenderDataAAD;

   When parsing a SenderData struct as part of message decryption, the
   recipient MUST verify that the sender field represents an occupied
   leaf in the ratchet tree.  In particular, the sender index value MUST
   be less than the number of leaves in the tree.

hasUpdates = false
hasRemoves = false

proposal = proposalCache[id]
hasUpdates = hasUpdates || proposal.msg_type == update
hasRemoves = hasRemoves || proposal.msg_type == remove

welcome_nonce = KDF.Expand(welcome_secret, "nonce", AEAD.Nn)
welcome_key = KDF.Expand(welcome_secret, "key", AEAD.Nk)

parent=01x => left=00x, right=10x

k = 0
k = 0
w = node_width(n)
k = level(x)
k = level(x)
r = x ^ (0x03 << (k - 1))
r = left(r)
k = level(x)
b = (x >> (k + 1)) & 0x01
p = parent_step(x)
p = parent_step(p)
p = parent(x, n)
r = root(n)
d = []
x = parent(x, n)
d = direct_path(x, n)
dx = set([x]) | set(direct_path(x, n))
dy = set([y]) | set(direct_path(y, n))
dxy = dx & dy
k = 0
