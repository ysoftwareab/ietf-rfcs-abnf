<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The Public Switched
   Telephone Network (PSTN) Validation Protocol (PVP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The Public Switched
   Telephone Network (PSTN) Validation Protocol (PVP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">dispatch</td><td class="header">J. Rosenberg</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">jdrosen.net</td></tr>
<tr><td class="header">Intended status:  Standards Track</td><td class="header">C. Jennings</td></tr>
<tr><td class="header">Expires:  May 13, 2010</td><td class="header">Cisco</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 09, 2009</td></tr>
</table></td></tr></table>
<h1><br />The Public Switched
   Telephone Network (PSTN) Validation Protocol (PVP)<br />draft-rosenberg-dispatch-vipr-pvp-00</h1>

<h3>Abstract</h3>

<p>One of the main challenges in inter-domain federation of
     Session Initiation Protocol (SIP) calls is that many domains
     continue to utilize phone numbers, and not email-style SIP
     URI. Consequently, a mechanism is needed that enables secure
     mappings from phone numbers to domains. The main technical
     challenge in doing this securely is to verify that the domain in
     question truly is the "owner" of the phone number. This
     specification defines the PSTN Validation Protocol (PVP), which
     can be used by a domain to verify this ownership by means of a
     forward routability check in the PSTN. 
</p>
<h3>Legal</h3>

<p>This documents and the information contained therein are provided on
     an "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
     OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
     THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
     INFORMATION THEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
     WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 13, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
The Wrong Way<br />
<a href="#anchor3">3.</a>&nbsp;
EKE Protocols <br />
<a href="#anchor4">4.</a>&nbsp;
Protocol Overview <br />
<a href="#anchor5">5.</a>&nbsp;
Username and Password Algorithms<br />
<a href="#anchor6">6.</a>&nbsp;
Originating Node Procedures <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">6.1.</a>&nbsp;
Establishing a Connection <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.2.</a>&nbsp;
Constructing a Username and Password <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">6.2.1.</a>&nbsp;
Method A <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">6.2.2.</a>&nbsp;
Method B<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">6.3.</a>&nbsp;
Requesting Validation<br />
<a href="#anchor12">7.</a>&nbsp;
Terminating Node Procedures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.1.</a>&nbsp;
Waiting for SRP-TLS<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">7.2.</a>&nbsp;
Receiving Validation Requests<br />
<a href="#anchor15">8.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#entropy">8.1.</a>&nbsp;
Entropy<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">8.2.</a>&nbsp;
Forward Routing Assumptions<br />
<a href="#anchor17">9.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The validation protocol is the key security mechanism in ViPR. It is
     used to couple together PSTN calls with IP destinations based on shared
     knowledge of a PSTN call. This document relies heavily on the concepts
     and terminology defined in <a class='info' href='#I-D.rosenberg-dispatch-vipr-overview'>[I&#8209;D.rosenberg&#8209;dispatch&#8209;vipr&#8209;overview]<span> (</span><span class='info'>Rosenberg, J. and C. Jennings, &ldquo;Verification Involving PSTN          Reachability: Requirements and Architecture Overview,&rdquo; November&nbsp;2009.</span><span>)</span></a> and will not make
     sense if you have not read that document first.
</p>
<p>The protocol assumes that two enterprises, the originating one
     (enterprise O) initiates a call on the PSTN to an E.164 number ECALLED
     that terminates on the terminating enterprise (enterprise T). Each
     enterprise has a ViPR server, acting as a P2P node. The node in
     enterprise O is PO, and the node in enterprise T is PT. This PSTN call
     completes successfully, and knowledge of this call is known to PO and
     PT. Later on, PO will query the P2P network with number ECALLED. It
     comes back with a peerID PCAND for a node. At this time, PO can't know
     for sure that PCAND is in fact PT. All it knows is that some node,
     PCAND, wrote an entry into the DHT claiming that it was the owner of
     number ECALLED. The objective of the protocol is for PO to determine
     that node PCAND can legitimately claim ownership of number ECALLED, by
     demonstrating knowledge of the previous PSTN call. It demonstrates that
     knowledge by demonstrating it knows the start time, stop timer, and
     possibly caller ID for the PSTN call made previously.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                      /-----------\
                  ///               \\\
                ||                     ||
                |        ViPR           \
                ||       DHT           ||\
                  X\\               ///   \
                 /    \-----------/        \
       ---------/-                      ----\------
    ///           \\\                ///           \\\
  //                 \\            //                 \\
 |                     |///---\\\ |                     |
 |    Enterprise O     |  PSTN    |     Enterprise T    |
 |                     |\\\---/// |                     |
  \\                 //            \\                 //
    \\\           ///                \\\           ///
       -----+-----                      ------+----
        +---+----+                        +---+----+
        | Phone O|                        |Phone T |
        +--------+                        +--------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 102: Validation Model&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>If node PCAND can demonstrate such knowledge, then enterprise O can
     assume that node PCAND had in fact received the call, which could only
     have happened if it had knowledge of the call to number ECALLED, which
     could only have happened if PCAND is in enterprise T, and thus it is PT.
     This is because PSTN routing is assumed to be "secure", in that, if
     someone calls some number through the PSTN, it will in fact reach a
     terminating line (whether it be analog, PRI, or other) which is the
     rightful "owner" of that number. If enterprise T was not the owner of
     the number, if would not have received the call, would not know its
     start/stop/callerID, not be able to provide that information to PT, and
     not be able to satisfy the knowledge proof. This basic approach is shown
     in Figure 102.
</p>
<p>A first question commonly asked is, why not just do regular
     authentication? What if we give each node a certificate, and then have
     the nodes authenticate each other? The answer is that a certificate
     certifies that a particular node belongs to a domain - for example, that
     node PT is part of example.com. A certificate does not assert that, not
     only is PT example.com, but example.com owns the following phone
     numbers. Therefore simple certificate authentication does not provide
     any guarantee over ownership of phone numbers.
</p>
<p>In principle, it might be possible to ask certificate authorities,
     such as Verisign, to assert just that. However, traditionally,
     certificate authorities have been extremely hesitant to certify much at
     all. The reason is, the certifier needs to be able to assure that the
     information is correct. How can a certifier like Verisign verify that,
     in fact, a particular enterprise owns phone numbers? It could make a few
     test calls, perhaps, to check if they look right. However, these test
     calls are disruptive to users that own the numbers (since their phones
     will ring!). If the test calls are done for a subset of the numbers, it
     is not secure. If the certifier simply required, as part of the business
     agreement, that the enterprises provided correct information, the
     certifier might avoid legal liability, but the legitimacy of the service
     will be compromised and customers will stop using it. Furthermore, it
     has proven incredibly hard to do this kind of certification worldwide
     with a single certificate authority.
</p>
<p>ViPR has, as a goal, to work anywhere in the world and do guarantee
     correct call routing with five nines of reliability. Consequently,
     traditional certificates and authentication do not work. It turns out to
     be quite hard to design a secure version of this validation protocol. To
     demonstrate this, we will walk through some initial attempts at it, and
     show how they fail.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
The Wrong Way</h3>

<p>The first attempt one might make is the following. PO takes the
     callerID for the call, ECALLING and called number ECALLED for the call,
     and sends them to candidate node PCAND. These two identifiers - the
     called number E and the caller ID, form a unique handle that can be used
     to identify the call in question. Node PCAND looks at all of the VCRs of
     the calls over the last 48 hours, and takes those with the given called
     party number and calling party number. If there is more than one match,
     the most recent one is used. We now have a unique call.
</p>
<p>Now, node PCAND demonstrates knowledge of this call by handing back
     the start and stop times for this call in a message back to PO. This
     approach is shown in Figure 103.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        Po             Pt
         |              |
         |              |
         |              |
         |Tell me start+stop
         |-------------&gt;|
         |              |
         |              |
         |              |Retrieve records
         |              |
         |              |
         |              |
         |start and stop|
         |&lt;-------------|
         |              |
         |              |
         |              |
         |              |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 103: Incorrect Validation Protocol: Take 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Unfortunately, this method has a major problem, shown in Figure
     104.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        Po            Pbad            Pt             DHT
         |              |              |              |
         |              |              |              |
         |              |              |              |
         |              |I own Ecalled |              |
         |              |----------------------------&gt;|
         |              |              |              |
         |              |              |              |
         |              |              |I own Ecalled |
         |              |              |-------------&gt;|
         |              |              |              |
         |              |              |              |
         |Who owns Ecalled?            |              |
         |-------------------------------------------&gt;|
         |              |              |              |
         |              |              |              |
         |Pbad and Pt   |              |              |
         |&lt;-------------------------------------------|
         |              |              |              |
         |              |              |              |
         |Tell me start+stop           |              |
         |-------------&gt;|              |              |
         |              |              |              |
         |              |              |              |
         |              |Tell me start+stop           |
         |              |-------------&gt;|              |
         |              |              |              |
         |              |              |              |
         |              |              |Retrieve records
         |              |              |              |
         |              |              |              |
         |              |              |              |
         |              |start+stop    |              |
         |              |&lt;-------------|              |
         |              |              |              |
         |              |              |              |
         |start+stop    |              |              |
         |&lt;-------------|              |              |
         |              |              |              |
         |              |              |              |
         |              |              |              |
         |              |              |              |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 104: Attack for Incorrect Validation Protocol&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Consider an attacker BadGuy PBAD. PBAD joins the P2P network, and
     advertises a number prefix they do NOT own, but which is owned by
     enterprise T and node PT. Now, when PO queries the DHT with number
     ECALLED, it comes back with two results - the one from PBAD and the one
     from node PT. Details of querying the DHT are provided in <a class='info' href='#I-D.rosenberg-dispatch-vipr-reload-usage'>[I&#8209;D.rosenberg&#8209;dispatch&#8209;vipr&#8209;reload&#8209;usage]<span> (</span><span class='info'>Rosenberg, J. and C. Jennings, &ldquo;A Usage of Resource Location and          Discovery (RELOAD) for Public Switched Telephone Network (PSTN)          Verification,&rdquo; November&nbsp;2009.</span><span>)</span></a>. It begins
     validation procedures with both. PBAD will now be asked to show the
     start and stop times for the call, given ECALLED and ECALLING. It
     doesn't know that information. However, node PT does. So now, PBAD,
     acting as if it where the originating party, begins the validation
     protocol with node PT. It passes the calling and called numbers sent by
     PO. PT finds a match and returns the call start and stop times to PBAD.
     PBAD, in turn, relays them back to PO. They are correct, and as a
     consequence, PO has just validated PBAD!
</p>
<p>Typically, the first response to this is, "Well the problem is, you
     let two separate people write the same number into the DHT. Why don't
     you make sure on the right one is allowed to write it in?". That is not
     possible, since there is no mechanism by which an arbitrary node in the
     DHT can determine who is the rightful owner of this number. "OK", the
     reader responds, "So instead, why don't you define a rule that says, if
     there are two entries in the DHT for a particular number, consider this
     an attack and don't try to validate the number". That would prevent the
     attack above. However, it introduces a Denial of service attack. An
     attacker can pick a target number, write it into the DHT, and prevent
     successful validation from happening towards that number. They can't
     misroute calls, but they can stop ViPR from working for targeted
     numbers. That is not acceptable. ViPR has to be immune from attacks like
     this; it should not be possible, through simple means such as
     configuration, for an attacker to cause a targeted number to never be
     validated.
</p>
<p>One might be tempted to add a signature over the call start and stop
     times, but it does not help. BadGuy can just resign them and relay them
     on.
</p>
<p>In essence, this simple approach is like a login protocol where the
     client sends the password in the clear. Such mechanisms have serious
     security problems.
</p>
<p>Realizing the similarities between the validation protocol and a
     login protocol, a next attempt would be to use a much more secure login
     mechanism - digest authentication. To do this, domain O takes the called
     number E and the caller ID, and send them to node P. Node P treats these
     as a "username" of sorts - an index to find a single matching call. The
     start time and stop times of the call become the "password". Enterprise
     O also sends a big random number - a nonce - to node P. Node P then
     takes the random number, takes the password, hashes them together, and
     sends back the hash. All of this is done over a TLS connection between
     enterprise O and node P. Digest over TLS is very secure, so surely this
     must be secure too, right? Wrong!
</p>
<p>It is not. Indeed it is susceptible to EXACTLY the same attack
     described previously. This is shown in Figure 105.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        Po            Pbad            Pt             DHT
         |              |              |              |
         |              |              |              |
         |              |              |              |
         |              |I own Ecalled |              |
         |              |----------------------------&gt;|
         |              |              |              |
         |              |              |              |
         |              |              |I own Ecalled |
         |              |              |-------------&gt;|
         |              |              |              |
         |              |              |              |
         |Who owns Ecalled?            |              |
         |-------------------------------------------&gt;|
         |              |              |              |
         |              |              |              |
         |Pbad and Pt   |              |              |
         |&lt;-------------------------------------------|
         |              |              |              |
         |              |              |              |
         |TLS           |              |              |
         |-------------&gt;|              |              |
         |              |              |              |
         |              |              |              |
         |Login user=Ecaller+Ecalled   |              |
         |-------------&gt;|              |              |
         |              |              |              |
         |              |              |              |
         |              |Login user=Ecaller+Ecalled   |
         |              |-------------&gt;|              |
         |              |              |              |
         |              |              |              |
         |              |              |Retrieve records
         |              |              |              |
         |              |              |              |
         |              |              |              |
         |              |Digest response              |
         |              |&lt;-------------|              |
         |              |              |              |
         |              |              |              |
         |Digest response              |              |
         |&lt;-------------|              |              |
         |              |              |              |
         |              |              |              |
         |              |              |              |
         |              |              |              |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 105: Trying Digest for Validation&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In a similar attack, PBAD could pick a random called number it is
     interested in, query the P2P network for it, find node PT. Then, provide
     node PT the number ECALLED to attack, and ECALLING, assuming it can
     guess a likely callerID. It then takes the received digest response, and
     goes through every possible start/stop time over the last 24 hours,
     running them through the hash function. When the hash produces a match,
     the PBAD has just found a full VCR for node PT. It can then write into
     the DHT using number E as a key, pointing to itself, and satisfy
     validation requests against it, without even needing to ask node P
     again. Our first attempt is susceptible to this attack too.
</p>
<p>The problem here is that the call start and stop times have "low
     entropy" - they are not very random and are easily guessable, just like
     a poorly chosen password.
</p>
<p>What we really want to do here is have a "login" protocol that
     creates a secure connection between a client and a server, where we use
     the called number and callerID as a "username" to identify a PSTN call,
     and then use the start and stop times as a "password". But our login
     protocol has to have some key features: </p>
<ol class="text">
<li>Someone posing as a server, but which does not have the username
         and password, cannot determine the username and password easily as a
         consequence of an authentication operation started by a valid
         client, aside from successfully guessing in the one attempt it is
         given on each connection attempt
</li>
<li>Someone posing as a client, but which does not have the username
         and password, cannot determine the username and password as a
         consequence of an authentication operation started against a valid
         server, aside from guessing in the one attempt it is given on each
         TLS connection attempt
</li>
<li>An active MITM, who is explicitly on the path of the exchanges
         and has visibility and the ability to modify messages, cannot obtain
         the shared secret, nor can it observe or modify information passed
         between the client and real server
</li>
<li>It is impossible for a passive observer to view the exchange and
         obtain the shared secret or any of the material that is
         exchanged
</li>
<li>It is impossible for a rogue client or rogue server to
         participate in a login with a legitimate peer, and then take the
         messages exchanged, and run an offline dictionary attack to work
         through every possible combination of start and stop times.
         Fortunately, these properties are provided by a class of password
         authentication protocols called Encrypted Key Exchange or EKE
         protocols.
</li>
</ol>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
EKE Protocols </h3>

<p>EKE protocols were proposed in 1992 by Steve Bellovin. Since their
     proposal, numerous variations have been defined. One of them, the Secure
     Remote Password protocol, was standardized by the IETF in <a class='info' href='#RFC2945'>RFC 2945<span> (</span><span class='info'>Wu, T., &ldquo;The SRP Authentication and Key Exchange System,&rdquo; September&nbsp;2000.</span><span>)</span></a> [RFC2945]. A TLS mode of SRP was later defined in
     <a class='info' href='#RFC5054'>RFC 5054<span> (</span><span class='info'>Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, &ldquo;Using the Secure Remote Password (SRP) Protocol for TLS Authentication,&rdquo; November&nbsp;2007.</span><span>)</span></a> [RFC5054]. It is the latter protocol which
     is actually used by ViPR. A high level overview of EKE protocols is
     shown in Figure 106. Alice and Bob share a shared secret P. Alice
     generates a public/private keypair. She then takes her public key, and
     encrypts it using her password as a symmetric encryption key. She sends
     this encrypted key to Bob. Bob, who shares the password, uses it as a
     symmetric key and decrypts the message, obtaining Alice's new public
     key. Bob then constructs a big random number R, which is to be used as a
     session key. Bob then encrypts R with the public key he just got from
     Alice, and sends that to Alice. Now, Alice, using her public key,
     decrypts the message and obtains the session key R.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       Alice                     Bob
         |                        |
         |                        |
         |                        |
         |Bob knows P             |
         |                        |
         |                        |
         |                        |
         |Generate PUB+PRIV       |
         |                        |
         |                        |
         |                        |
         |E(PUB,P)                |
         |-----------------------&gt;|
         |                        |
         |                        |
         |                        |decrypt with P, get PUB
         |                        |
         |                        |
         |                        |
         |                        |create session key R
         |                        |
         |                        |
         |                        |
         |E(R,PUB)                |
         |&lt;-----------------------|
         |                        |
         |                        |
         |decrypt with PUB, get R |
         |                        |
         |                        |
         |                        |
         |shares R with Bob       |
         |                        |
         |                        |
         |                        |
         |                        |
         |                        |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 106: High Level EKE Model&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>At this point Alice and Bob share a session key R which can be used
     for authentication (by having Alice and Bob prove to each other that
     they have the same value for R) or for encrypting data back and forth.
     How does this help? Consider our man-in-the-middle attack again, in
     Figure 107. Once again, Alice shares a password with legitimate user
     Bob. However, she begins the "login" process with BadGuy. She passes
     E(PUB,P) to BadGuy. BadGuy doesn't know P, so he can't decrypt the
     message. More importantly, he can't run through each possible password P
     and decrypt the message. If he did, he wouldn't be able to tell if he
     got it right, since PUB appears random; the decryption process would
     produce a random string of bits whether it was successful or not. So for
     now, BadGuy can only pass it on. BadGuy now intercepts E(R,PUB). Now,
     BadGuy can try the following. He can run through each P, decrypt
     E(PUB,R), obtain PUB. However, since we are using asymmetric encryption
     (i.e., public key encryption), even with PUB he cannot DECRYPT E(R,PUB)!
     BadGuy does not have the private key, which he needs to decrypt. Given a
     public key, he cannot guess the private key either. That is how
     public/private keying systems work. That is the secret here to making
     this work. So, once again, BadGuy has no choice but to pass the message
     on. Now, Alice and Bob share R but it is unknown to BadGuy. Bob now
     takes his peerID, encrypts it with R, and sends to Alice. Once again,
     BadGuy doesn't have R and can't get it, so he has no choice but to pass
     it on. Alice decrypts this peerID with R, and now knows that she is
     actually talking to Bob - since she has Bob's peerID. Other data can be
     substituted for the peerID, and indeed this is what happens in the
     actual validation protocol.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       Alice                Bad                 Bob
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |Bob knows P        |                   |
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |Generate PUB+PRIV  |                   |
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |E(PUB,P)           |                   |
         |------------------&gt;|                   |
         |                   |                   |
         |                   |                   |
         |                   |E(PUB,P)           |
         |                   |------------------&gt;|
         |                   |                   |
         |                   |                   |
         |                   |                   |decrypt w P, get PUB
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |                   |                   |create session key R
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |                   |E(R,PUB)           |
         |                   |&lt;------------------|
         |                   |                   |
         |                   |                   |
         |E(R,PUB)           |                   |
         |&lt;------------------|                   |
         |                   |                   |
         |                   |                   |
         |decrypt with PUB, get R                |
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |shares R with Bob  |                   |
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |                   |E(Bob PeerID, R)   |
         |                   |&lt;------------------|
         |                   |                   |
         |                   |                   |
         |E(Bob PeerID, R)   |                   |
         |&lt;------------------|                   |
         |                   |                   |
         |                   |                   |
         |                   |                   |
         |                   |                   |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 107: Attacking EKE Protocols&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>However, the main point of this exercise is to demonstrate that EKE
     protocols have the desired properties.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Protocol Overview </h3>

<p>The validation protocol begins with the following assumptions:
</p>
<p></p>
<ol class="text">
<li>Node PO wishes to validate with node PCAND, and has its peerID
         (which it obtained via the DHT) and VServiceID (which it also
         obtained via the DHT Fetch).
</li>
<li>Node PO and PCAND have a series of call records over the last 48
         hours, uploaded by their call agents. Each call record contains an
         E164 calling and called party number, and a start and stop time in
         NTP time. On the terminating side, each call record is also
         associated with a VserviceID.
</li>
<li>Node PO is seeking to validate a call to called number ECALLED
         with caller ID ECALLING.
</li>
</ol>

<p>The validation protocol operates by having the originating node make
     a series of attempts to connect to, and "login" to the terminating node.
     Each "login" attempt consists of establishment of a TCP connection, and
     then execution of TLS-SRP procedures over that connection. TLS-SRP<a class='info' href='#RFC5054'>[RFC5054]<span> (</span><span class='info'>Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, &ldquo;Using the Secure Remote Password (SRP) Protocol for TLS Authentication,&rdquo; November&nbsp;2007.</span><span>)</span></a> relies on a shared secret - in the form of a
     username and password - in order to secure the connection. In ViPR, the
     username and password are constructed by using information from a target
     VCR along with the VServiceID learned from the DHT. The "username",
     instead of identifying a user, identifies a (hopefully) unique VCR
     shared between the originating and terminating nodes. The "password" is
     constructed from the VCR such that it knowledge of the information is
     unique to knowledge of the VCR itself.
</p>
<p>Unfortunately, it is difficult to construct usernames and passwords
     that always uniquely identify a VCR. To deal with this, the validation
     protocol requires the originator to construct a series of usernames and
     passwords against a series of different nodes and their corresponding IP
     addresses and ports, and then run through them until a connection is
     securely established.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Username and Password Algorithms</h3>

<p>ViPR provides two different algorithms for mapping from a particular
     VCR to a username and password:
</p>
<p></p>
<ol class="text">
<li>Method A: This method makes use of the called party and calling
         party number to form the username, and the start and stop times of
         the call to form the password
</li>
<li>Method B: This method makes use of the called party number, along
         with a point in time in the middle of the call, as the username, and
         then the start and stop times form the password
</li>
</ol>

<p>The originating node will first try validations with method A, and if
     those all fail, then try with method B. The method itself, along with
     necessary information on how to use the method, is encoded into the
     username itself. The format of the username is always:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Username = method ":"
method-data Method = "a" / "b" / future-methods
Future-methods = 1alpha Method-data ? 1*(alphanum/method-unreserved)
</pre></div>
<p>
</p>
<p>
</p>
<p>This format starts with the method, followed by a colon, followed by
     a sequence of characters that are specific to the method. Both methods a
     and b rely on conveyance of information attributes that make up the
     username. Each attribute follows a specific format
</p>
<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Attribute = (originating-number / terminating-number / timekey
             / rounding-time / vserviceid / new-attribute) ";"
new-attribute = att-name "=" att-value
att-name = 1*(alphanum / att-unreserved)
att-value = 1*(alphanum / att-unreserved)
originating-number = "op=+" 1*16DIGIT
terminating-number = "tp=+" 1*16DIGIT
timekey = "tk=" 1*16DIGIT ?.? 1*16DIGIT
rounding-time = "r=" 1*6DIGIT
vserviceid = "vs=" 1*32 HEXDIGIT
HEXDIGIT = DIGIT / "a" / "b" / "c" / "d" / "e" / "f"
</pre></div>
<p>
</p>
<p>The method data for Method A and B is defined as:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Methoda = vserviceid originating-number
            terminating-number rounding-time
Methodb = vserviceid terminating-number timekey rounding-time
</pre></div>
<p>Examples include:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
a:vs=7g5a8630b6365bf2;op=+17327662496;tp=+14089023084;r=1000;
b:vs=7g5a8630b6365bf2;tp=+14089023084;tk=172636364.133622;r=1000;
</pre></div>
<p>Both methods use a rounding factor R. This is used to round the start
     and stop times in the password to a specific nearest multiple of R
     (which is in milliseconds). This rounding is done because the passwords
     need to be bit exact and we need to compensate for different measured
     values.
</p>
<p>If we will fallback to method B (which works more often), why have
     both? There are two answers:
</p>
<p></p>
<ol class="text">
<li>The callerID mechanism (method A) will work, and the non-callerID
         (method B) won't work, for numbers like 8xx
</li>
<li>Method A has much higher entropy (see analysis in <a class='info' href='#entropy'>Section&nbsp;8.1<span> (</span><span class='info'>Entropy</span><span>)</span></a>). Validating with it provides greater
         confidence in the validity of the number. In this phase, nothing is
         done with this "confidence". However, in later phases, it is
         anticipated that low-confidence numbers will require multiple
         validations for different calls to occur before they are trusted. To
         allow for this feature to be added later, validation with both
         methods must be present in the initial release.
</li>
</ol>

<p>The sections below detail precisely how these are constructed.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Originating Node Procedures </h3>

<p>Most of the work for validation is on the side of the originator. It
     establishes connections and performs a series of validation checks.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Establishing a Connection </h3>

<p>The first step in the process is to establish a TCP connection to
       PCAND. To do that, PO sends a DHT PING message targeted towards PCAND.
       This will return one or two IP addresses and ports. This provides one
       or two targets to which a connection attempt is made. An attempt is
       made first to the public address, then if that connection times out,
       to the private. Once connected, TLS-SRP is run over the
       connection.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Constructing a Username and Password </h3>

<p>When a terminating node receives a username in a format it doesn't
       understand, it fails the validation. This allows for graceful upgrade
       to new mechanisms in the future. 
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
Method A </h3>

<p>The PO examines the VCR it is using for validation. It extracts
         the calling and called party numbers, both of which are E.164 based.
         This VCR will have been uploaded at a previous point in time. PO
         then examines the VCRs posted in the time since this one was
         uploaded, and looks for any more recent VCRs with the same calling
         and called party numbers regardless of VService. If it finds one or
         more, it takes the most recent one (as measured by its end time). If
         it finds no more recent, it uses the VCR which triggered the
         validation in the first place.
</p>
<p>Why do this? This deals with the following case. User A calls
         user B, causing a VCR to be uploaded. The originating node sets a
         timer, which fires 12 hours later. However, within that 12 hour
         period, A called B again. If node A provides the callerID and called
         party numbers as the "key" to select a VCR, it will match multiple
         records over the past day. We need to pick one, so the most recent
         is always used. This requires the originating node to know and use
         the most recent VCR. Furthermore, we most choose the most recent VCR
         regardless of its Vservice, because the originating Upload VCRs are
         sent using an arbitrary Vservice. Thus, the more recent call may
         have been done using a different VService than the one which
         triggered the validation. Since the actual Vservices are not common
         between originating and terminating sides, we must choose the VCR on
         the originating side regardless of Vservice. The username is
         constructed by using the syntax for method A described above. The
         calling party number is set to "op", and the called party number is
         set to "tp", and "r" is the value of Tr as an integral number of
         milliseconds. The VServiceID learned from the dictionary entry is
         used as the value of "vs".
</p>
<p>This username will select the identical VCR at the terminating
         node, under the following conditions:
</p>
<p></p>
<ol class="text">
<li>PT is aware of all calls made to the called party number.
             This property is true so long as each incoming number is handled by
             a single call agent within a domain, and furthermore, the VCR
             for calls to that number is always posted to a VIPR server which
             advertises that number into the DHT. These properties are
             readily met by ViPR for typical single user numbers. For 8xx
             numbers, which are translated within the PSTN and may route to a
             multiplicity of non-8xx numbers, it is more difficult. ViPR will
             only work with 8xx numbers if all calls to those numbers get
             sent to agents which share the same ViPR server.
</li>
<li>PO is aware of all calls made to the called party number with
             the given caller ID. This property can be hard to meet. If the
             callerID for a call is set to the number of the calling phone, and
             all VCRs made from that phone are posted to the same ViPR
             server, that server will know about all calls made by the
             domain with the given DID in the caller ID. However, in
             domains that set the PSTN caller ID to the attendant line
             number, it is possible that there would be two separate
             agents, each utilizing different ViPR servers. A user in each
             agent calls the same number, and the same PSTN caller ID is
             used. However, one ViPR server knows about one of the calls, and
             a different ViPR server knows about the other call. However, PT
             knows about both. In that case, validation from one of the ViPR
             servers will fail, and from the other, succeed.
</li>
<li>There were no calls on the PSTN to the called party which
             spoofed the callerID to match the callerID used by the valid
             enterprise. In that case, PT will have a VCR for a call with a
             matching calling/called party number, but this VCR is unknown to
             PO since the call was not actually made by the originating
             enterprise. This attack is described in more detail in XXXX.
</li>
</ol>

<p>Next, the password is selected. The password is basically the
         start and stop times for the call. However, the SRP protocol
         requires a bit exact agreement on the password. Unfortunately, the
         calling and called parties will not have the same values for the
         start and stop times, for several reasons:
</p>
<p></p>
<ol class="text">
<li>The call start time at the originating and terminating ends
             will differ by the propagation delay of the call acceptance
             message through the PSTN. This can be several hundreds of
             milliseconds.
</li>
<li>The clocks at the originating and terminating ends may not be
             synchronized, which can also introduce different values for the
             start and stop times.
</li>
<li>The call termination time at the originating and terminating
             ends will also differ by the propagation time; this propagation
             time may in fact be different for the call acceptance and
             termination.
</li>
</ol>

<p>It is also important to note that agreement on a call acceptance
         and termination time assumes an explicit signaling message is sent
         for these two events. In the case of analog FXO ports, there is no
         signaling at all, and consequently, these points in time cannot be
         measured. It is possible to agree upon other call characteristics
         when analog lines are in use, but they have much worse accuracy and
         consequently much, much lower entropy. For this reason, this
         specification of ViPR only works in telephony systems with explicit
         messaging for call acceptance and termination, which includes PRI,
         SS7, BRI, analog trunks with answer and disconnect supervision, and
         CAS trunks. To deal
         with these inaccuracies in timing, the start and stop times need to
         be rounded. Let Tr be the rounding interval, so that each time is
         rounded to the value of N*Tr for integral N, such that N*Tr is less
         than the start or stop time, and (N+1)Tr is greater than it. In
         other words, "round down". If Tr=1 second, this would round down to
         the nearest second.
</p>
<p>Unfortunately, rounding doesn't fully help. Lets say that the
         difference between the start times on the originating and
         terminating nodes is delta. We can still have different values for
         the start time if one side rounds to one value, and the other side
         to a different value. If delta=100ms and Tr=1s, consider a start
         time of 10.08 seconds on one side, and 9.98 on the other side. One
         side will round to 10 seconds and the other to nine seconds. The
         probability of this happening is approximately delta/Tr. We could
         just make Tr really large to compensate, but this reduces the
         entropy of the system (see below).
</p>
<p>To deal with this, the originating node will actually compute
         FOUR different passwords. For the start time and stop time both, the
         originating node will round down as follows. Let T be the time in
         question. Let N be the value such that N*Tr &lt;= T &lt; (N+1)*Tr.
         In other words, N*Tr is the nearest round-down value, and (N+1)*Tr
         is the nearest round up. Let T1 and T2 be the two rounded values of
         T. We have:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
if (T &gt;= ((2N+1)/2) * Tr) then:
                         T1 = N*Tr
                         T2 = (N+1)*Tr
if (T &lt;  ((2N+1)/2) * Tr) then:
                         T1 = N*Tr
                         T2 = (N-1)*Tr
</pre></div>
<p>In other words, if T is in the top half of the rounding interval,
         we try the rounded values above and below. If T is in the bottom
         half, we try the rounded values below, and below again.
         Pictorially:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
TBD
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 108: Rounding mechanism for validation protocol&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>These are tried in the following sequence:
</p>
<p></p>
<ol class="text">
<li>Try Tstart-1 and Tend-1
</li>
<li>Try Tstart-2 and Tend-1
</li>
<li>Try Tstart-1 and Tend-2
</li>
<li>Try Tstart-2 and Tend-2
</li>
</ol>

<p>For example, if the originating side has a start time of 10.08
         and a stop time of 30.87, the four start and stop times with Tr=1s
         are:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Start</th><th align="left">Stop</th></tr>
<tr>
<td align="left">10</td>
<td align="left">30</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">30</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">31</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">31</td>
</tr>
</table>
<br clear="all" />

<p>Each of these times is represented in 64 bit NTP time (Tr can be
         configured to less than 1s in which case there will be non-zero
         values in the least significant 32 bits). Each password is then
         computed by taking the 64 bit start time, followed by the 64 bit end
         time, resulting in a 128 bit word. This word is base-64 encoded to
         produce an ascii string representation of 21 characters. To perform
         the caller-ID based validation, the SRP-TLS procedure is done four
         times, once with each of the four username/password combinations (of
         course the username is identical in all four cases). As long as
         delta is less than Tr/2, one of this is guaranteed to work.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
Method B</h3>

<p>Unfortunately, in many cases caller ID cannot be used as an
         identifier for the VCR. This is because:
</p>
<p></p>
<ol class="text">
<li>CallerID is frequently suppressed in the PSTN, and not
             delivered. This is especially true in international cases.
</li>
<li>CallerID is sometimes munged by the PSTN, and delivered, but
             with a different value than was sent by the originator. This
             happens in certain arbitrage interexchange carriers.
</li>
</ol>

<p>Consequently, if no caller ID was delivered at all, the
         terminating side will not have a matching record. IN that
         case, it informs the calling side that it should abort and
         revert to method B. If munged, it will also abort for the
         same reason.
</p>
<p>If the callerID attempt aborts, PO now tries
         a different approach. In this approach, the "username" is the
         combination of the called party number and a point during the call,
         selected at random. The password is equal to the start and stop
         times of the call. This method uses the method-tag "B" in the
         username.
</p>
<p>Unlike method A, with method B, the VCR which triggered the
         validation is used, regardless of whether there were other, more
         recent, calls to the same calledparty number! This is because, in
         method B (unlike method A), the time itself is used as a key to
         select a VCR. Furthermore, using a more recent VCR does not interact
         properly with multi-tenancy. The called number and point during that
         call will select an identical VCR on the terminating side if the
         following conditions are met:
</p>
<p></p>
<ol class="text">
<li>For the called party number, there was not more than one call
             in progress made to that number at the same time. This is
             generally true for numbers for a single user; typically there is
             only one active call at a time. Of course, it is possible a user
             receives a call, and then gets another. It then puts the first
             on hold while the second call is taken. In these cases, it is
             possible that the "username" will select a different VCR on PT,
             in which case the validation fails. More troubling are numbers
             representing call centers, conference bridges, 8xx numbers, and
             attendant numbers, all of which frequently have multiple calls
             in progress to them at the same time. As a consequence, for
             these types of called numbers, validation is typically only
             going to work if caller ID is delivered. Fortunately, 8xx
             numbers are only national in the first place, so it is likely
             that this will work.
</li>
<li>PO is aware of all calls made from within its enterprise to
             ECALLED. This can fail if there are multiple ViPR servers
             serving different agents, and a call is made from one
             agent, sent to one ViPR server, and a call to that same number
             is made on a different agent, send to a different ViPR server.
             As in the caller-ID case, this will still be OK in many cases -
             the validation from one ViPR server succeeds, the other
             fails,.
</li>
<li>PT is aware of all calls made to ECALLED. The same caveats as
             described above for the callerID mechanism apply. PO takes the
             VCR, and chooses a time Tkey which is uniformly distributed
             between Tstart+Tr and Tstop-Tr. The usage of the Tr here is to
             make sure that Tkey is squarely inside of the call start and
             stop for PT as well. Note that, because Tkey is not a password,
             it is sent in the clear and does not need to be rounded. Tkey is
             then taken as a 64 bit NTP time, and converted to base64
             producing 11 characters.
</li>
</ol>

<p>The username encodes the called party number, Tkey, the DHT, and
         the VserviceID learned from the DHT query. The password is computed
         identically to method A.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Requesting Validation</h3>

<p>Once the SRP-TLS connection is up, data is exchanged. This is done
       through a single VAP transaction initiated by PO. This transaction is
       only VAP in the sense that it utilizes the basic syntax (the header
       and TLV attribute structure), and its request/response model. Other
       than that, it is effectively a different protocol - the validation
       protocol.
</p>
<p>PO sends a VAP request with method ValExchange (0x00d). It contains
       one attribute, Domain. The originating ViPR server obtains this domain
       by looking at the Vservice of the VCR that was eventually used for the
       validation. Note that, in cases where the VCR which triggered the
       validation, is different than the one actually used for validation
       (because a more recent VCR to the same number was found), it is
       important to use the Vservice associated with the VCR which was
       actually used for validation, and NOT the Vservice associated with the
       VCR which triggered the attempt. Multi-tenancy does not work properly
       without this. The domain from the Vservice is placed into the message.
       This is basically the domain name of the originating enterprise. It is
       included since it is needed by PT to compute the ticket.
</p>
<p>PO will then receive a response. If it never receives a response
       within a timeout, it considers the validation to have failed, and
       continues to the next choice. If it receives any kind of error
       response, including a rejection due to a blacklisted domain, it
       considers validation to have failed, and continues to the next choice.
       If it is a success response, it will contain one attribute -
       ServiceContent, which contains a ValInfo XML object. ValInfo is an XML
       object which contains the SIPURIs and the ticket. The ViPR server must
       parse the ValInfo XML object and perform verification on it to avoid
       attacks. The following checks are done:
</p>
<p></p>
<ol class="text">
<li>Extract the &lt;number&gt; element. This will contain a single
           number. That value is compared with the E.164 called party number which
           was just validated. If they do not match, this is a potential
           attack, and the XML is discarded and the ViPR server acts as if
           validation failed. However it does not generate an alarm.
</li>
<li>Remove any extensions to the XML which are not supported by the
           ViPR server (no extensions defined, so in this version, any
           elements except for the &lt;ticket&gt;, &lt;number&gt;,
           &lt;route&gt;s and their embedded &lt;SIPRUI&gt; are removed.
</li>
<li>Verify that the &lt;route&gt; element contains a single
           element, &lt;SIPURI&gt;
</li>
<li>Verify that the SIP URI is not larger than 614 characters,
           contains a domain name that is a valid set of domain name
           characters, contains a user part that is a valid set of
           characters, if it contains maddr, that the maddr is a valid domain
           or IP and less than 255 characters, and if there is a port, it is
           within 0-65535. This is for security purposes; to make sure a
           malicious ViPR server on the terminating side cannot send invalid
           URI and attack the call agent.
</li>
<li>Verify that each SIPURI contains the same domain name. Once the
           checks and fixes are done, the patched XML is passed to
           subscribers in a Notify as described in <a class='info' href='#I-D.draft-rosenberg-dispatch-vipr-vap'>[I&#8209;D.draft&#8209;rosenberg&#8209;dispatch&#8209;vipr&#8209;vap]<span> (</span><span class='info'>Rosenberg, J. and C. Jennings, &ldquo;Validation Access Protocol          (VAP),&rdquo; November&nbsp;2009.</span><span>)</span></a>.
</li>
</ol>

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Terminating Node Procedures</h3>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Waiting for SRP-TLS</h3>

<p>PT will listen on its configured port for TCP connections, and once
       one is received, it begins waiting for SRP-TLS. The TLS messaging will
       provide PT with a username.
</p>
<p>It parses the username and determines the method. If the value of
       the method is not "a" or "b", this is a new method not supported by
       the node. The SRP-TLS procedures should be failed. If the
       method is "a", it is the callerID mechanism. The called number,
       calling number, Vservice, and rounding time are extracted. PT then
       searches through its VCRs over the last 48 hours for one with a
       matching called number and caller ID and Vservice whose VserviceID
       matches the one from the username:
</p>
<p></p>
<ol class="text">
<li>If none are found, PT proceeds with the SRP-TLS exchange, but
           using a fake username and password. This will cause the validation
           to eventually fail.
</li>
<li>If one is found, it is used
</li>
<li>If more than one is found, the one with the most recent end
           time is used
</li>
</ol>

<p>The start and stop times from the selected VCR are taken. Using the
       value of Tr from the username, both times are rounded down to the
       nearest multiple of Tr. Note that, this rounding is different than the
       one used on the originating side. The values are ALWAYS rounded down.
       So if the stop time is 10.99 and Tr is one second, the rounded down
       value of 10 is used. The start and stop times are then represented as
       64 bit NTP times (after rounding), concatenated, and base64ed to
       produce a 21 character password. This is the password used with
       SRP-TLS.
</p>
<p>Note that, the originating node will try up to four different
       password combinations. One of these should work, the others will cause
       SRP-TLS to fail due to differing shared secrets. However, it is the
       job of the originator to perform these four; to the terminating node,
       they are four separate attempts. Processing of SRP-TLS login attempts
       is stateless on the terminating side. This means that each attempt is
       treated independently by PT. It performs identical processing on each
       SRP-TLS attempt - examine the username, find a matching VCR, extract
       password, and fail the attempt or continue to success. The originating
       side has the main burden of sequencing through the various
       mechanisms.
</p>
<p>If the method is "b", PT uses the extracted called party ID and a
       time in the middle of the call. It searches through all VCR records
       whose called number matches and whose VserviceID matches, and of
       those, takes the ones where Tkey is between Tstart and Tstop. Of
       those, if more than one match, the one with the most recent Tstop is
       used. Tstart and Tstop for that VCR are extracted, and converted to a
       password just as is done for the PO. The resulting SRP-TLS procedure
       will then either succeed or fail. Note that, if a domain has
       multiple Vservices that contain the same number, there will be multiple
       VCRs for calls to that number, and there will be multiple validation
       attempts, one for each of the Vservices.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Receiving Validation Requests</h3>

<p>PT listens for incoming VAP/validation requests once the TLS
       connection is up. It rejects anything but a ValExchange method with a
       400 response. This allows for future extensibility of the validation
       protocol. If the request was ValExchange, it extracts the domain name.
       This will be something like "example.com". PT knows the VCR against
       which validation succeeded. That VCR is associated with a Vservice.
       The ViPR server checks the domain in the ValExchange request against
       the black/white list associated with that Vservice. If no Vservice is
       currently active, the ValExchange is rejected with a 403. If there is
       one active, and if the domain appears on the black list, or does not
       appear in the white list, the ViPR server rejects the ValExchange
       request with a 403 error response, indicating that this domain is not
       allowed to call.
</p>
<p>If the domain was in the whitelist or not in the blacklist, or
       there was no whitelist/blacklist, PT constructs a successful response
       to the ValExchange request. It contains one attribute: ServiceContent.
       It has a ValInfo XML object, which contains a number, a ticket, and a
       series of routes.
</p>
<p>The number is always the E164 number which was just validated,
       including the plus sign. Note that this will also appear in the
       ticket. The route element is the sequence of route elements for each
       instance associated with the vservice.
</p>
<p>Details of the ticker are provied in <a class='info' href='#I-D.rosenberg-dispatch-vipr-sip-antispam'>[I&#8209;D.rosenberg&#8209;dispatch&#8209;vipr&#8209;sip&#8209;antispam]<span> (</span><span class='info'>Rosenberg, J. and C. Jennings, &ldquo;Session Initiation Protocol (SIP)          Extensions for Blocking VoIP Spam Using PSTN Validation,&rdquo; November&nbsp;2009.</span><span>)</span></a> but the
       ticket attribute is constructed as follows: </p>
<ol class="text">
<li>A ticket unique ID TLV is created, containing a randomly chosen
           128 bit value as the ticket ID. That is the first TLV in the
           ticket.
</li>
<li>A salt TLV is created, containing a random 32 bit value. This
           is the second TLV in the ticket.
</li>
<li>The validity has the start time set using the current time as
           the start time, and the current time + the ticket lifetime as the
           end time. The ticket lifetime is a per-DHT configurable parameter.
           The terminating ViPR server will have performed the validation
           using a particular Vservice; the DHT for that Vservice is used to
           find the right value for this parameter.
</li>
<li>Number: This is the terminating number, in e164 format, which
           was just validated.
</li>
<li>Granting node: this is set to one of the nodeIDs associated
           with this ViPR server. Any will do.
</li>
<li>Granting domain: This value is taken from the domain part of
           the SIP URI associated with the vservice in which the validated
           VCR was found.
</li>
<li>Granted-To domain: This is formed using the Domain sent in the
           ValExchange request.
</li>
<li>Epoch: This is the current epoch associated with the
           password.
</li>
<li>Integrity: Using the current password, this is computed from
           the rest of the Ticket.
</li>
</ol>

<p>The resulting sequence of TLVs is base64 encoded and that is placed
       into the Ticket attribute in the ValExchange response.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>This section is mostly missing and needs to be done.
</p>
<a name="entropy"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Entropy</h3>

<p>The entropy obtained in the information from the PSTN calls
       significantly impacts the security of this protocol. This section
       needs to provide an analysis of how much entropy actually exists in
       this information.
</p>
<p>Defines the worst case of conference calls and resulting
       entropy
</p>
<p>Describe the idea of doing multiple validations to
       aggregate entropy
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Forward Routing Assumptions</h3>

<p>Discuss forward routing security in PSTN and explain how this
       protocol is reliant on that.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<p>TBD Define ports used.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC5054">[RFC5054]</a></td>
<td class="author-text">Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, &ldquo;<a href="http://tools.ietf.org/html/rfc5054">Using the Secure Remote Password (SRP) Protocol for TLS Authentication</a>,&rdquo; RFC&nbsp;5054, November&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5054.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rosenberg-dispatch-vipr-sip-antispam">[I-D.rosenberg-dispatch-vipr-sip-antispam]</a></td>
<td class="author-text"><a href="mailto:jdrosen@jdrosen.net">Rosenberg, J.</a> and <a href="mailto:fluffy@cisco.com">C. Jennings</a>, &ldquo;Session Initiation Protocol (SIP)
         Extensions for Blocking VoIP Spam Using PSTN Validation,&rdquo; November&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.draft-rosenberg-dispatch-vipr-vap">[I-D.draft-rosenberg-dispatch-vipr-vap]</a></td>
<td class="author-text"><a href="mailto:jdrosen@jdrosen.net">Rosenberg, J.</a> and <a href="mailto:fluffy@cisco.com">C. Jennings</a>, &ldquo;Validation Access Protocol
         (VAP),&rdquo; November&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rosenberg-dispatch-vipr-overview">[I-D.rosenberg-dispatch-vipr-overview]</a></td>
<td class="author-text"><a href="mailto:jdrosen@jdrosen.net">Rosenberg, J.</a> and <a href="mailto:fluffy@cisco.com">C. Jennings</a>, &ldquo;Verification Involving PSTN
         Reachability: Requirements and Architecture Overview,&rdquo; November&nbsp;2009.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2945">[RFC2945]</a></td>
<td class="author-text">Wu, T., &ldquo;<a href="http://tools.ietf.org/html/rfc2945">The SRP Authentication and Key Exchange System</a>,&rdquo; RFC&nbsp;2945, September&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2945.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rosenberg-dispatch-vipr-reload-usage">[I-D.rosenberg-dispatch-vipr-reload-usage]</a></td>
<td class="author-text"><a href="mailto:jdrosen@jdrosen.net">Rosenberg, J.</a> and <a href="mailto:fluffy@cisco.com">C. Jennings</a>, &ldquo;A Usage of Resource Location and
         Discovery (RELOAD) for Public Switched Telephone Network (PSTN)
         Verification,&rdquo; November&nbsp;2009.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jonathan Rosenberg</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">jdrosen.net</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Monmouth, NJ</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jdrosen@jdrosen.net">jdrosen@jdrosen.net</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.jdrosen.net">http://www.jdrosen.net</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cullen Jennings</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">170 West Tasman Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">MS: SJC-21/2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95134</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 408 421-9990</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:fluffy@cisco.com">fluffy@cisco.com</a></td></tr>
</table>
</body></html>
