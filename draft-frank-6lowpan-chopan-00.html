<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Chopan - Compressed HTTP Over PANs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Chopan - Compressed HTTP Over PANs">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">B. Frank</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Tridium, Inc</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">June 15, 2009</td></tr>
<tr><td class="header">Expires: December 17, 2009</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Chopan - Compressed HTTP Over PANs<br />draft-frank-6lowpan-chopan-00.txt</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on December 17, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document describes a method for compressing HTTP messages 
into a binary format to be transmitted using UDP over 6LoWPAN wireless
networks.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements notation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Terminology<br />
<a href="#anchor5">2.</a>&nbsp;
Datagram Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.1.</a>&nbsp;
Format Notation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.</a>&nbsp;
Request Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.</a>&nbsp;
Response Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">2.4.</a>&nbsp;
Compressed Headers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">2.5.</a>&nbsp;
Mime Type Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">2.6.</a>&nbsp;
Example<br />
<a href="#anchor12">3.</a>&nbsp;
UDP Transmission<br />
<a href="#anchor13">4.</a>&nbsp;
Transaction-Id<br />
<a href="#anchor14">5.</a>&nbsp;
Caching<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">5.1.</a>&nbsp;
Cache Control<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">5.2.</a>&nbsp;
ETag Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">5.3.</a>&nbsp;
Interception Proxy Caching<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">5.4.</a>&nbsp;
Sleeping Nodes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">5.5.</a>&nbsp;
Cache Refresh<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.6.</a>&nbsp;
Caching non-GET Methods<br />
<a href="#anchor21">6.</a>&nbsp;
HTTP to Chopan Gateways<br />
<a href="#Security">7.</a>&nbsp;
Security<br />
<a href="#rfc.references1">8.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The Pervasive Internet is a vision that everyday devices with
microprocessors are woven into the fabric of the Internet. One of the critical
emerging technologies in this domain is 6LoWPAN which enables low cost, low
power devices to communicate using the Internet Protocol. 6LoWPAN is the first
step towards building the Pervasive Internet. Chopan defines the next step:
integrating 6LoWPAN devices with the World Wide Web to leverage the massive 
investment in existing URI and HTTP infrastructure.
</p>
<p>
Chopan is derived from HTTP with these changes:
</p>
<ul class="text">
<li>UDP: utilizes UDP packets instead of TCP as the underlying transport 
protocol
</li>
<li>Binary compression: HTTP headers are compressed into a binary format to 
save bandwidth and buffer space
</li>
<li>Interception Caches:  transparent caching is used to minimize PAN traffic 
and manage sleeping nodes
</li>
<li>Gateways: may be used to translate between full HTTP and Chopan to 
interoperate with the existing Web infrastructure
</li>
</ul><p>

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as
described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Security Considerations</h3>

<p>Discussed in <a class='info' href='#Security'>Section&nbsp;7<span> (</span><span class='info'>Security</span><span>)</span></a>.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Terminology</h3>

<p>6LoWPAN: IPv6 for Low power Personal Area Networks described in
<a class='info' href='#RFC4944'>[RFC4944]<span> (</span><span class='info'>Montenegro, G., &ldquo;Transmission of IPv6 Packets over IEEE 802.15.4 Networks,&rdquo; September&nbsp;2007.</span><span>)</span></a>.
</p>
<p>Compression: translation from of a TCP/HTTP text based message into a
compressed binary UDP/Chopan message (gateway functionality).
</p>
<p>Decompression: translation from of a binary UDP/Chopan message into a
TCP/HTTP text based message (gateway functionality).
</p>
<p>Gateway: a node which transparently translates between HTTP and Chopan
messages.
</p>
<p>HTTP: Hyper Text Transfer Protocol described in <a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>.
</p>
<p>PAN: Personal Area Network - an IP sub-network with constrained bandwidth
and/or constrained computing devices. This specification is designed for low
power PANs running 6LoWPAN, but Chopan is an ideal solution for any network
with bandwidth or computing restraints.
</p>
<p>Interception Proxy Cache: a node which transparently intercepts HTTP
requests to an origin server and returns cached responses on its behalf.
</p>
<p>Origin Server: the server on which the master version of resource
resides.
</p>
<p>Resource: an abstract unit of information identified with a URI and
transported over a network using a MIME typed representation.
</p>
<p>Sleeping Nodes: battery powered network nodes which spend most of their time
in a hibernation state to converse power.
</p>
<p>TCP: Transmission Control Protocol described in <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>.
</p>
<p>UDP: User Datagram Protocol described in <a class='info' href='#RFC0768'>[RFC0768]<span> (</span><span class='info'>Postel, J., &ldquo;User Datagram Protocol,&rdquo; August&nbsp;1980.</span><span>)</span></a>.
</p>
<p>UTF-8: Encoding of Unicode characters compatible with ASCII described
in <a class='info' href='#RFC2279'>[RFC2279]<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; January&nbsp;1998.</span><span>)</span></a>
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Datagram Format</h3>

<p>Chopan uses a customized binary encoding for HTTP requests and responses to
achieve message compression into a UDP packet. A two byte magic number is used
to identify the packet as a Chopan message – “h6” for requests and “H6” for
responses. Both requests and responses allow for zero or more compressed
headers.
</p>
<p>Any bytes after the headers in the packet are considered the message-body.
The length of the message-body is implied by the packet length (the
Content-Length header MAY be omitted). The entire message MUST fit with in a
single UDP packet. When running over 6LoWPAN, messages SHOULD fit into a single
802.15.4 frame to avoid fragmentation.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Format Notation</h3>

<p>Message formats are described as a data structure using the following
primitive types:

</p>
<ul class="text">
<li>u1:  an unsigned 8-bit byte
</li>
<li>u2: an unsigned 16-bit integer in network byte order
</li>
<li>str: <a class='info' href='#RFC2279'>UTF-8<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; January&nbsp;1998.</span><span>)</span></a> [RFC2279] encoded text, followed by a null 
terminator (0x00) byte
</li>
<li>x[]: an sequence of type x which contains zero or more occurrences
</li>
<li>x|y: either x OR y
</li>
</ul><p>         


</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Request Format</h3>

<p>A normal HTTP request is composed of a request-line, a set of
request-headers, and the message-body. This information is compressed in the
following binary format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
request
{
  u2       magic 0x6836 – ASCII "h6"
  u1       method-code
  str      uri
  header[] headers
  u1       zero byte end of headers
  u1[]     message-body
}
</pre></div>
<p>The HTTP request-line contains three pieces of information: the method, URI,
and version. The URI is encoded as a null-terminated UTF-8 string. Standard
request methods are encoded into a byte as follows:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Method         Code   ASCII Char
------------   ----   ----------
DELETE         0x44   D
GET            0x47   G
HEAD           0x48   H
OPTIONS        0x4F   O
POST           0x50   P
PUT (Update)   0x55   U
TRACE          0x54   T
</pre></div>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Response Format</h3>

<p>A normal HTTP response is composed of a status-line, response-headers, and
the message-body. This information is compressed in the following binary
format:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
response
{
  u2       magic  – ASCII "H6"
  u1       status-code
  header[] headers
  u1       zero byte end of headers
  u1[]     message-body
}
</pre></div>
<p>The HTTP status code is compressed into a single byte where the top 3-bits
represent the 100s decimal digit, and the bottom 5-bits represent the last two
decimal digits. Example of binary mappings:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
1xx  -&gt;  0x2X, b001x_xxxx
2xx  -&gt;  0x4X, b010x_xxxx
3xx  -&gt;  0x6X, b011x_xxxx
4xx  -&gt;  0x8X, b100x_xxxx
5xx  -&gt;  0xAX, b101x_xxxx
200  -&gt;  0x40  // OK
404  -&gt;  0x84  // Not Found
415  -&gt;  0x4F  // Unsupported Media Type
416  -&gt;  0x50  // Requested range not satisfiable
417  -&gt;  0x51  // Expectation Failed
</pre></div>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Compressed Headers</h3>

<p>Standardized HTTP request and response headers are compressed using
predefined binary codes. Compressed headers are encoded as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
header
{
  u1     header-code (high bit determines encoding of value)
  u2|str value (u2 or str based on header-code high bit)
}
</pre></div>
<p>Headers are encoded using a 8-bit header-code which represents the header
name. If the high bit (0x80) is clear in the header-code, then the value is
encoded as an unsigned 16-bit integer. If the high bit is set, then the value
is encoded as a null terminated UTF-8 string. The u2 value encoding allows
compression on a header-by-header basis. Refer to the table below how each
header utilizes a u2 value.
</p>
<p>If an HTTP header name does not have a standard binary encoding, then it MAY
be stripped at the proxy gateway, otherwise it can be passed using its string
name. Uncompressed header names are encoded as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
uncompressed-header
{
  u1      header-code is 0x7f (u2 val) or 0xff (str val)
  str     name encoded as null terminated string
  u2|str  value
}
</pre></div>
<p>The following table defines the header codes for standard HTTP
headers.  Each code has the high bit clear indicating a u2 value.  Mask
the code with 0x80 to obtain the str value code:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Header              Code  Notes
------------------  ----  -------------------------------------------
End-Of-Headers      0x00  zero indicates no more headers
Uncompressed        0x7F  name string, u2/string value
Accept              0x01  u2 val: mime type code
Accept-Charset      0x02
Accept-Encoding     0x03
Accept-Language     0x04
Accept-Ranges       0x05
Age                 0x06  u2 val: delta age in seconds
Allow               0x07
Authorization       0x08
Awake-Time          0x09  u2 val: seconds, used with check-in request
Cache-Control       0x0A  u2 val: max-age in seconds
Connection          0x0B  unsupported
Content-Encoding    0x0C
Content-Language    0x0D
Content-Length      0x0E  u2 val: bytes; omit to imply by packet size
Content-Location    0x0F
Content-MD5         0x10
Content-Type        0x11  u2 val: mime type code
Cookie              0x12
Date                0x13
ETag                0x14  u2 val: etag is 4 digit upper case hex str
Expect              0x15  u2 val: uncompressed code 100 is 0x64
Expires             0x16  should be avoided (use max-age)
From                0x17
Host                0x18
If-Match            0x19  u2 val: etag is 4 digit upper case hex str
If-Modified-Since   0x1A  should be avoided (use max-age)
If-None-Match       0x1B  u2 val: etag is 4 digit upper case hex str
If-Range            0x1C
If-Unmodified-Since 0x1D  should be avoided (use max-age)
Last-Modified       0x1E  should be avoided (use age, max-age)
Location            0x1F
Max-Forwards        0x20  u2 val: number of hops
Pragma              0x21  obsolete
Proxy-Authenticate  0x22
Proxy-Authorization 0x23
Range               0x24
Referer             0x25
Retry-After         0x26  u2 val: seconds, used with 202 responses
Server              0x27
Set-Cookie          0x28
Sleep-Time          0X29  u2 val: seconds, used for check-in requests
TE                  0x2A
Transaction-Id      0x2B  u2 val: same as 4 digit upper case hex str
Trailer             0x2C  unsupported
Transfer-Encoding   0x2D
Upgrade             0x2E
User-Agent          0x2F
Vary                0x30
Via                 0x31
Warning             0x32  u2 val: uncompressed code 111 is 0x6F
WWW-Authenticate    0x33
</pre></div>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Mime Type Codes</h3>

<p>The Accept and Content-Type headers may be compressed into an unsigned
16-bit type code using the following table:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Mime Type                 Code    Notes
------------------------  ------  -------------------------------
application/octet-stream  0xA001  used for arbitrary binary files
text/plain                0xB001  charset implied to be UTF-8
text/html                 0xB002  charset implied to be UTF-8
text/xml                  0xB003  charset implied to be UTF-8
text/csv                  0xB004  charset implied to be UTF-8
</pre></div>
<p>NOTE: we also need to give thought to what kind of information
models we use and how they are represented with existing or new MIME
types.  For example we might want to use ASN.1 MIBs, binary oBIX, 
etc...
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Example</h3>

<p>Assume the following HTTP request:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
GET /pt07 HTTP/1.1
Host: sensor2086.acme.com
Accept: text/plain
If-None-Match: "3A7F"
Cache-Control: max-age=900
</pre></div>
<p>The HTTP request above would be compressed into the following sequence of
hexadecimal bytes:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
68 36 47 2F 70 74 30 37 00 01 B0 01 1B 3A 7F 0A 03 84 00
^     ^  ^                 ^        ^        ^        ^
|     |  |                 |        |        |        +- End
|     |  +- URI            |        |        +- Cache-Control
|     +- GET               |        +- If-None-Match
+- magic                   +- Accept
</pre></div>
<p>Note that we stripped the Host header and compressed Accept, If-None-Match,
and Cache-Control into two byte header values.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
UDP Transmission</h3>

<p>One of the primary characteristics of Chopan is the ability to transmit HTTP
requests and responses over UDP. Since HTTP was originally designed to be run
over TCP, we must make some design trade-offs to layer the protocol over an
unreliable packet based transport.
</p>
<p>Chopin follows the standard HTTP request/response model. A client makes a
Chopan request to a server with a request message. When the server receives the
request, it sends the client back a response message.
</p>
<p>Both the request and response messages MUST fit within one UDP packet, as
such large message bodies are not supported. However, the Range header may be
used to chunk the transfer of resources which do not fit a single UDP
packet. When running over 6LoWPAN, messages SHOULD fit into a single
802.15.4 frame to avoid fragmentation.
</p>
<p>Because UDP is unreliable, there is no guarantee that a server receives a
request, nor that a client receives the response. If a client does not receive
a response to its request after a reasonable amount of time, then it SHOULD
retry the request up to three times before timing out. It is therefore possible
that the server might receive the same request multiple times. A request is
"retry safe" if it can be retried multiple times by the client without
compromising server state. Idempotent methods like GET and HEAD MUST be retry
safe. Methods such as PUT and DELETE should also be retry safe since they
atomically modify or delete the resource. Methods like POST are typically not
retry safe unless coupled with another mechanism. In the next section we
examine an extension to HTTP for making requests retry safe with the
Transaction-Id header.
</p>
<p>UDP does not guarantee message order. Therefore, it is the client’s
responsibility to impose message ordering if required. Message ordering can be
maintained by waiting for a response, before sending the next request. When
message ordering is not required, the client MAY have multiple simultaneous
outstanding requests. This can increase throughput on networks with high
latency. If performing concurrent requests, clients SHOULD use the
Transaction-Id header to match responses to requests.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Transaction-Id</h3>

<p>Due to the unreliable nature of UDP, requests and responses do not have
guaranteed delivery or ordering. This can particularly cause problems when a
non-idempotent request is received successfully by the server, but the response
packet is dropped. In this case the client’s expected behavior is to retry the
request which might cause the server to receive the same request multiple
times. For methods such as POST which are not implicitly retry-safe, we define
a new header called Transaction-Id.
</p>
<p>Transaction-Id is a unique identifier generated by the client. The tuple of
the client’s IP address, port number, and Transaction-Id should be globally
unique within the transaction’s temporal window. Any retries initiated by the
client MUST include the same transaction id in the retry requests.
</p>
<p>When a server receives a request with a Transaction-Id header, it MUST pass
the identifier back to the client via the response’s Transaction-Id header. The
server MAY also choose to utilize the Transaction-Id to implement
"at-most-once" semantics. It is a server local matter to decide how to apply
the transaction id for a given HTTP method and resource.
</p>
<p>If a client attempts to request a method on the resource which requires a
Transaction-Id header and fails to specify one, then the server SHOULD respond
with 400 Bad Request.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Caching</h3>

<p>6LoWPAN networks are typified by a gateway device which acts as a router or
bridge between the PAN and the external IP network. Often the external IP
network is physically connected by high a bandwidth technology such as Ethernet
or WiFi. The PAN itself typically has low bandwidth and is composed of resource
constrained nodes. Often times the nodes in a PAN are battery powered, and
spend most of their time sleeping.
</p>
<p>Because of this physical architecture, it is desirable for the more capable
nodes in the PAN to serve as caches for the more constrained devices. Effective
use of caching enables Chopan to optimize both bandwidth on the PAN and power on 
constrained devices. In the case of a sleeping node, it allows proxies to 
immediately return cached representations of resources.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Cache Control</h3>

<p><a class='info' href='#RFC2616'>HTTP<span> (</span><span class='info'>Fielding, R., &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a> [RFC2616] defines a sophisticated caching model in
sections 13 and 14.9. This model has multiple caching features, often with
overlapping functionality. Since Chopan is targeted for resource constrained
devices, this specification recommends use of a subset of the HTTP caching
model based on resource age and max-age.
</p>
<p>It is expected that most resources accessed by Chopan are representations of
sensor data. The nature of the sensor data determines its cache life. For
example a temperature sensor in a room is likely to change very slowly, so it
might have a cache life of fifteen minutes. But a temperature sensor in an oven
might have a cache life of only ten seconds before it is considered stale data.
Chopan uses existing HTTP caching features to give both the client and server a
say in cache management.
</p>
<p>When an origin server publishes a resource representation via a GET request,
it SHOULD specify the Age header. For example if a resource represents a
sensor, and that sensor was read 4 seconds ago, then the Age header should be
set to 4 seconds. If the resource has an age less than 1 second, then set the
Age header to 0. The Age header SHOULD be compressed into a two byte value if
less than 18.2 hours.
</p>
<p>In cases when the origin server has knowledge about the cache life of a
given resource, it SHOULD set the Cache-Control header with a Max-Age
directive. Note that the two byte value encoding of Cache-Control is implied to
be Max-Age as a number of seconds. When the server specifies Max-Age, it is
directing upstream proxies and clients how long to cache the resource. For
example if a resource specifies an Age of 4 seconds, and a Max-Age of 30
seconds, then the resource should be cached for 26 seconds before it is
considered stale.
</p>
<p>Clients MAY also specify the Cache-Control header with a Max-Age directive
on requests. In this case, the client is directing the maximum amount of
staleness which may be tolerated. For example if a client requests a resource
with a Max-Age of 10 seconds, and the resource has an age of 8 seconds, then
the server may respond with the cached resource. If however the resource has an
age older then 10 seconds, then the server should refresh its cache. In the
case of a proxy cache, this means contacting the origin server. In the case of
the origin server, it may require polling the sensor.
</p>
<p>A resource is considered stale if its Age is greater than either Max-Age
specified by the server or the Max-Age specified by the client. If a server
node has a cached version of a resource which is stale, it SHOULD always
attempt to refresh its cache. If the cache cannot be refreshed immediately
because of normal operation (for example the origin server is a sleeping node),
then the stale resource should be returned and the Warning header SHOULD be
specified with the 110 status code (response is stale). If cache refresh fails
abnormally (for example the origin server cannot be contacted), then the stale
resource SHOULD be returned and the Warning header specified with the 111
status code (revalidation failed).
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
ETag Validation</h3>

<p>Key to any caching strategy is cache validation, the mechanism used by a
client or proxy to refresh its cache with the origin server. Often even though
a cached resource has expired, the original resource hasn’t been modified. But
in order to avoid re-transmitting the entire resource the client and server
must define a mechanism to validate the cached copy. In HTTP this validation
may be negotiated using either timestamps or entity tags. Chopen discourages
the use of timestamps because often nodes do not support time clocks. Instead
entity tags SHOULD be used for cache validation.
</p>
<p>An entity tag is an opaque hash of a given resource’s version. It is defined
by the origin server using the ETag header. If possible, a two byte etag should
be used to allow for optimal compression. If an etag was specified for a cached
resource, then clients and proxies SHOULD specify the If-None-Match header on
cache refresh. The server SHOULD respond with a 304 (Not Modified) response if
the etag has been not modified.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Interception Proxy Caching</h3>

<p>In Chopan, caching is done transparently to the client via "interception
caching". Interception caching is a commonly used technique used to insert HTTP
caches between clients and origin servers, without requiring client
configuration. Clients send packets to the origin server directly, but as these
packets are routed into the PAN, one of the routing nodes processes the message
directly on behalf of the origin server. This architecture requires that
routing nodes in the PAN are actively examining the packets before they are
routed to their destination address.
</p>
<p>The downside to using interception caching, is that technically it breaks
the encapsulation of the IP stack - routing nodes must become aware of an
application level protocol. The upside to this design, is that client nodes do
not have be explicitly configured to know about the proxies for every PAN.
Since PANs have the potential to add billions of new nodes to the
Internet, it seems reasonable to trade-off the purity of IP routing within the
PAN to maintain the simplicity of the Internet at large.
</p>
<p>Interception caches SHOULD use a combination of the destination port and the
packet’s magic two byte marker to sniff Chopan packets. By default we assume
Chopan runs on UDP port 80, although proxies SHOULD make this configurable.
</p>
<p>The lifecycle of an interception cache request: 
</p>
<ol class="text">
<li>The client sends a request to the origin server
</li>
<li>The interception proxy traps the request
</li>
<li>If the request can be immediately fulfilled by a cached representation of
that resource in the proxy, then the proxy responds directly to client on
behalf of the origin server using the origin server’s IP address
</li>
<li>If the proxy has no cached representation of the resource (or the cache has
expired), then it makes its own request to the origin server for the resource
to update its cache, then performs step 3 to return the cached resource to the
client
</li>
<li>Cache might also be actively refreshed periodically (see Cache Refresh)
</li>
</ol><p>

</p>
<p>This lifecycle assumes that the origin server is a powered device which is
awake during normal operation. If the origin server is a battery powered device
then the origin server is mostly likely sleeping. This use case is discussed
further in Sleeping Nodes section.
</p>
<p>Interception proxies SHOULD be transparent to the client. However, when a
proxy communicates directly with the origin server it has a choice to forward
the client’s original packet (with the client’s IP address), or to initiate a
new request (with the proxy’s IP address). Proxy’s SHOULD initiate new requests
using the proxy’s own IP address. This means that origin servers are
effectively responding directly to the proxy with no knowledge of the original
client request. The disadvantage of this model is that it breaks end-to-end
communication principles of the Internet. However this model provides
significant advantages:
</p>
<ul class="text">
<li>On 6LoWPAN it keeps IP addressing to intra-PAN nodes which results in better
compression (since we don’t need to pass through the external IP address);
</li>
<li>It ensures that the response gets routed directly back to the proxy for
caching;
</li>
<li>Gateways which are translating TCP/HTTP into UDP/Chopan do not have UDP
packets from the client to begin with (rather they are translating from a TCP
stream)
</li>
<li>Sleeping nodes which require active cache refresh must be polled directly by
the proxy
</li>
</ul><p>

</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Sleeping Nodes</h3>

<p>PANs commonly include battery powered nodes which spend most of their time
sleeping to conserve power. These nodes periodically wake up to check sensors,
perform computation, and catch up on network communications. Because of their
nature, sleeping nodes do not make for reliable origin servers. Chopan handles
this use case by fronting all sleeping nodes with interception caches. This
allows all requests for resources on the sleeping nodes to be transparently
brokered by proxies. Proxies then synchronize their caches with the sleeping
nodes periodically during a "check-in" process.
</p>
<p>The lifecycle for interception caching of sleeping nodes follows the
standard interception model detailed above. However, when a request is made for
a resource the proxy doesn’t have in its cache, the request cannot be
immediately fulfilled. In this case the proxy SHOULD return a 202 Accepted
response indicating that background processing is required before the request
can be completed (waiting for the sleeping node to wake up). The Retry-After
header SHOULD be set indicating the number of seconds before the request should
be tried again. The retry time should be based on the time it will take the
sleeping node to wake up, check-in, and give the proxy a chance to refresh its
cache. The Retry-After header can be estimated from the Awake-Time and
Sleep-Time headers (see below).
</p>
<p>Sleeping nodes MUST be configured to check-in with their proxy or proxies
when they wake up. This is done by sending a POST request to the "/ci" URI of
each proxy. When a proxy node receives a check-in request, it SHOULD respond
with 200 OK response. The sleeping node SHOULD use standard retry/timeout
mechanism to ensure that the check-in is received by the proxy. After the
sleeping node has checked-in, then the proxy SHOULD poll for all the resources
in its cache which require refreshing. This will include all new pending
resources which resulted in 202 responses. After the sleeping node has given
the proxy a chance to refresh its cache, it can go back to sleep.
</p>
<p>Sleeping nodes SHOULD specify the Awake-Time and Sleep-Time headers in their
check-in request. The Awake-Time header specifies how long the node expects to
stay awake to give the proxy a chance for cache refresh. The Sleep-Time
indicates how long the node expects to sleep before the next check-in. A proxy
should expect the next check-in after the sum of Awake-Time and Sleep-Time has
elapsed - this period can then be used for estimating the proxy’s Retry-After
header.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Cache Refresh</h3>

<p>Chopan proxies can take an active or a passive approach to cache refresh. In
a passive model, stale resources are allowed to expire and are eventually
flushed from the cache. New requests for the resources are forwarded to the
origin server, and the response is used to refresh the cache. On the other
hand, the proxy can actively poll origin servers to refresh cached resources
independent of client requests.
</p>
<p>For sleeping nodes, proxies MUST actively refresh their cache. This is
required because there are only limited windows of opportunity while the node
is awake for the proxy to refresh resources.
</p>
<p>When the origin server is a powered node, either active or passive cache
refresh may be used. Using active refresh to proactively keep caches refreshed
can potentially decrease the latency of external requests.
</p>
<p>Cached resources can be in one of the following states:
</p>
<ul class="text">
<li>Pending: these are resources on sleeping nodes which have resulted in a 202
response. Eventually we expect to poll the node on check-in and turn them into
fresh resources or invalid resources.
</li>
<li>Fresh: these are resources with an Age less than both the client’s and
server’s configured Max-Age.
</li>
<li>Stale: these are resources with an Age which exceeds either the client’s or
server’s Max-Age. The proxy may continue to maintain stale resources in the
cache for some period of time.
</li>
<li>Flushed: resources may be flushed from a cache at any time. Normally stale
resources are flushed after a timeout period. However LRU caches may flush
fresh resources if buffer space is exceeded. 
</li>
<li>Invalid: some proxies may maintain a cached representation of a resource to
indicate an error condition. This is helpful when a proxy receives a request
for a sleeping node and returns 202, then after the check-in discovers the
origin server returns 404 for the resource. In this case the proxy SHOULD
temporarily cache an error return so that the client’s next poll will receive a
404 instead of another 202.
</li>
</ul><p>

</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;
Caching non-GET Methods</h3>

<p>In most circumstances, clients make GET requests to retrieve representations
of resources. In this case, proxies are caching the response which contains
that resource representation. However clients may also perform POST, PUT, or
DELETE requests. In the case where the origin server is a powered node, these
requests SHOULD always be immediately forwarded to the origin server.
</p>
<p>However in the case of sleeping nodes, the proxy MUST cache the request
itself until the node wakes up and checks-in. Without this functionality it
would be impossible to perform these HTTP methods on sleeping nodes. Non-GET
methods to sleeping nodes MUST use a Transaction-Id to associate the request
with a specified client IP address, port number, and transaction id.
</p>
<p>Let’s consider a transaction for a resource POST on a sleeping node:
</p>
<ol class="text">
<li>Client POSTs to origin server with a unique transaction id
</li>
<li>Proxy transparently intercepts the request, caches it, and returns 202
</li>
<li>Upon check-in the proxy forwards the request then caches the response
</li>
<li>Client waits for Retry-After, then resubmits POST request using same
transaction id
</li>
<li>Proxy transparently intercepts the request and returns cached response with
the transaction id
</li>
</ol><p>

</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
HTTP to Chopan Gateways</h3>

<p>Chopan leverages the HTTP standard in order to provide interoperability with
the World Wide Web. Interoperability is achieved by using standard HTTP
external to the PAN and using Chopan internal to the PAN. Nodes which perform
HTTP-Chopan translation are called Chopan gateways:
</p>
<ul class="text">
<li>Requests into the PAN are translated from HTTP to Chopan.
</li>
<li>Requests from inside the PAN to the external network are translated from Chopan to HTTP.
</li>
<li>Requests from inside the PAN to other nodes inside the PAN are Chopan end-to-end
</li>
</ul><p>

</p>
<p>Diagram of gateway translations:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
          &lt;= External  |  PAN =&gt;
Client -&gt; [HTTP] -&gt; Gateway -&gt; [Chopan] -&gt; Server
Server &lt;- [HTTP] &lt;- Gateway &lt;- [Chopan] &lt;- Client
</pre></div>
<p>Gateway translations SHOULD be performed transparently. Clients external the
PAN assume they are communicating HTTP directly to the origin server. Gateways
intercept these HTTP requests and translate them into Chopan requests. Likewise
responses are translated from Chopan back to HTTP.
</p>
<p>Because Chopan recommends that translation happens transparently, this means
that the gateway must be sniffing incoming packets for TCP/HTTP requests. This
design has all the same issues as detailed in Interception Proxy Caching. It is
expected that in most implementations the gateway will also perform
interception caching, although this specification does not require it.
</p>
<p>HTTP to Chopan is referred to as compression, and Chopan to HTTP is referred
to as decompression. During the compression process the text format of requests
and responses is encoded into Chopan’s binary message format. Each HTTP header
is examined and mapped into its binary encoding. Depending on the quality of
the PAN link layer, the compression process may strip out HTTP headers,
according to these priorities:
</p>
<ul class="text">
<li>Content type and cache-control headers SHOULD never be stripped
</li>
<li>Standard headers with u2 value encodings or short strings SHOULD be maintained
</li>
<li>Standard headers without u2 value encodings or with longer strings MAY be stripped
</li>
<li>Non-standard headers SHOULD be stripped (assuming typical PAN constraints)
</li>
</ul><p>

</p>
<p>The Chopan compression and stripping of headers is a gateway to origin
server matter. This does not free the gateway from faithfully implementing the
full HTTP specification and abiding by its conventions. In the cases where HTTP
headers or functionality is reduced to meet Chopan constraints, the gateway
should compensate so that the client’s perspective is communication with a
fully compliant HTTP origin server.
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security</h3>

<p>Ideally Internet protocols implement an end-to-end security model between
the two endpoint nodes. However it is difficult to implement end-to-end session
based security with unreliable packet protocols and sleeping nodes. Rather
Chopan, recommends that the security strategy is divided between internal and
external PAN nodes.
</p>
<p>Internally all PAN nodes should be fully trusted using link layer security
such as the AES encryption specified by 802.15.4.
</p>
<p>External to the PAN, the gateway should utilize full TCP/HTTP to enable the
well known security mechanisms associated with those protocols. This includes
TLS/HTTPS and the various HTTP authentication mechanisms.
</p>
<p>NOTE: A lot more to think about here...
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC0768">[RFC0768]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>,&rdquo; RFC&nbsp;768, August&nbsp;1980.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; RFC&nbsp;793, September&nbsp;1981.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2279">[RFC2279]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc2279">UTF-8, a transformation format of ISO 10646</a>,&rdquo; RFC&nbsp;2279, January&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text">Fielding, R., &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4944">[RFC4944]</a></td>
<td class="author-text">Montenegro, G., &ldquo;<a href="http://tools.ietf.org/html/rfc4944">Transmission of IPv6 Packets over IEEE 802.15.4 Networks</a>,&rdquo; RFC&nbsp;4944, September&nbsp;2007.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Brian Frank</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tridium, Inc</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Richmond, VA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:brian.tridium@gmail.com">brian.tridium@gmail.com</a></td></tr>
</table>
</body></html>
