





INTERNET DRAFT                                              James Kempf
Category: Informational                                     Pat Calhoun
Title: draft-ietf-aaa-diameter-api-00.txt                David Frascone
Date: April 2001                                 Sun Microsystems, Inc.



                           The DIAMETER API



                          Status of this Memo

   This document is a working group contribution for consideration by
   the AAA Working Group of the Internet Engineering Task Force.

   Distribution of this memo is unlimited.

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at:

      http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at:

      http://www.ietf.org/shadow.html.

   Copyright   (C) The Internet Society 2001.  All Rights Reserved.


Abstract

   The Diameter  authentication, authorization, and accounting (AAA)
   protocol provides support for peering AAA transactions across the
   Internet. This document describes a standardized API for the Diameter
   protocol. The API is defined in both the C and Java languages. The
   intent of the API is to foster source code portability across
   multiple programming platforms.



Kempf, Calhoun, Frascone expires September 2001                 [Page 1]

INTERNET DRAFT                                                April 2001


Table of Contents

   1.0   Introduction
   2.0   Binding Independent Considerations
     2.1 Multithreading
     2.2 Error Reporting
     2.3 String Format
     2.4 Handling Connections with Other Servers/Peers
     2.5 Callback Processing Order
   3.0   C API
     3.1 Constant Types
       3.1.1 IP Address and Port
       3.1.2 Command Code
       3.1.3 Vendor Identifier
       3.1.4 Extension Identifier
       3.1.5 Attribute/Value Pair Code
       3.1.6 Value Type Identifier
       3.1.7 Server Type
       3.1.8 Session Identifier
       3.1.9 Message Identifier
       3.1.10 Callback Handle
       3.1.11 Application Identifier
       3.1.12 API Return Codes
       3.1.13 Callback Location Codes
       3.1.14 AVP Data Type Codes
       3.1.15 AVP Flags
       3.1.16 Domain Interconnection Types
       3.1.17 Message Flags
       3.1.18 Result Codes
       3.1.19 Search Direction Type
     3.2 Structure Definitions
       3.2.1 Dictionary Entry Definition
       3.2.2 AVP Definition
       3.2.3 AVP List
       3.2.4 Message Definition
     3.3 Macros and Preprocessor Definitions
     3.4 Functions
       3.4.1 Initialization and Configuration
       3.4.2 Registering Commands
       3.4.3 Session and Server Management
       3.4.4 Dictionary Lookup
       3.4.5 Message Management
       3.4.6 Message Control
     3.5 Implementation Notes
       3.5.1 Grouped AVPs
       3.5.2 Information Hiding
       3.5.3 Avoiding AVP Copying
   4.0   Java API



Kempf, Calhoun, Frascone expires September 2001                 [Page 2]

INTERNET DRAFT                                                April 2001


     4.1 Introduction
       4.1.1 Client API Overview
       4.1.2 Server API Overview
       4.1.3 Reflection Classes Overview
       4.1.4 Packages and Properties
     4.2   Errors and Exceptions
       4.2.1 Class AAAException
       4.2.2 Class AAAMessageException
     4.3 Library Management and Dictionary Management
       4.3.1 Class AAA
       4.3.2 Class AAACommandDictionary
       4.3.3 Class AVPDescriptor
       4.3.4 Class AAACommandDescriptor
       4.2.5 Class AAAExtension
     4.3 Messages and AVPs
       4.3.1 Class AAAMessage
       4.3.2 Class AVP
       4.3.3 Class EncapsulatingAVP
     4.4 Session Management
       4.4.1 Class AAASessionManager
       4.4.2 Class AAAClientSessionManager
       4.4.3 Class AAAServerSessionManager
       4.4.4 Class UnsolicitedExceptionHandler
       4.4.5 Class AAAMessageListener
     4.5 Server API
       4.5.1 Class AAAServer
       4.5.2 Interface AAAMessageListenerFactory
     4.6 Implementation Considerations
       4.6.1 Dynamic Linking of Command Handling Classes
       4.6.2 State Machine Maintenance
       4.6.3 Server-side Access to Session Identifiers
       4.6.4 Server Proxy and Redirect Implementation
   5.0   Security Considerations
   6.0   References
   7.0   Authors' Addresses
   8.0   Full Copyright Statement


1.0  Introduction

   The Diameter authentication, authorization and accounting (AAA)
   protocol provides scalable AAA support for peering transactions
   across the Internet [1]. This document describes standardized APIs in
   C and Java for applications to access the Diameter protocol. While a
   standardized API is not strictly necessary for protocol
   interoperability, it does help to promote the use and deployment of a
   protocol by reducing the amount of work necessary to develop and
   access applications that use the protocol.



Kempf, Calhoun, Frascone expires September 2001                 [Page 3]

INTERNET DRAFT                                                April 2001


   The Diameter protocol provides a basic attribute/value pair (AVP)
   data format, which particular application profiles extend. Processing
   of the extensions is handled by code specific to the application
   profile. Application profile customizability is reflected into the
   API as callback functions for C.  The callbacks implement the
   application profile processing for incoming messages. For outgoing
   calls, the C API provides an asynchronous model, leaving processing
   of the return message to the callbacks.  In the Java API, the
   outgoing message and incoming reply are processed synchronously on
   the client side, and asynchronously on the server side.

   For the most part, the API hides the details of establishing peering
   and redirect connections, parsing and creating Diameter messages, and
   other work necessary to set up and maintain a redirect or peering
   session. The application profile code need only be concerned with
   processing of the AVPs defined in the application profile.

2.0 Binding Independent Considerations

   This section discusses a number of implementation considerations for
   both the C and Java language bindings with language specific notes
   where appropriate.


2.1 Multithreading

   Both C and Java APIs are expected to be thread-safe. Access to data
   structures shared among threads must be co-ordinated to avoid
   corruption or invalid access. In addition, API implementors are
   encouraged to provide the maximum amount of parallel processing
   within their library implementations by allowing multiple threads in
   the API library at once.


2.2 Error Reporting

   The APIs report errors resulting from client calls through language
   specific mechanisms. The functions in the C API return a error code,
   while the Java methods throw exceptions. API implementors are
   additionally encouraged to log errors using the appropriate platform
   specific error logging technique, especially for errors that result
   from network processing or other causes that are not directly related
   to an API function or method call. The Java API provides a callback
   to handle exceptions that occur during processing of unsolicited
   messages. This can be used on the server side to report errors
   occuring during message parsing to a log file, and on the client side
   to report errors in a client-specific way for unsolicited messages.
   Error messages received in response to a message are reported



Kempf, Calhoun, Frascone expires September 2001                 [Page 4]

INTERNET DRAFT                                                April 2001


   directly to the client application code in Java by means of an
   exception.


2.3 String Format

   C API clients are required to format strings as UTF-8 if the string
   contains 16 bit characters. Since the ASCII characters and the UTF-8
   8 bit characters have the same codes, ASCII can be used for UTF-8 if
   no wide characters are in the string.  All strings passed through the
   C API are standard null-terminated C strings.  Processing to remove
   the null terminator for transmission on the wire is done by the
   library. Strings passed through the Java API are Unicode strings. The
   library takes care of conversion to UTF-8.


2.4 Handling Connections with Other Servers/Peers

   Both the C and Java API contain support for making a connection with
   an arbitrary Diameter peer. The C API support allows an API client to
   set the server address in a message (AAASetServer()). The Java API
   allows the client to start a session with a specific server, and the
   session id is used to send messages (AAASessionManager.send()) If a
   message is not sent to a particular server in C, the API library is
   required to infer the servers by either looking in the configuration
   files or dynamically determining the servers that support the
   extension.  Dynamic determination is possible using means such as SLP
   [6].

3.0 C API

   The C language API is designed around callbacks. An application
   profile defines a collection of Diameter commands, and a library of
   callbacks for processing those commands. Each command is processed by
   a callback. Callbacks can also be defined that handle all commands.
   The API provides functions for managing callbacks, including
   registration and deregistration.

   When an incoming Diameter command arrives, the command is parsed and
   passed to the appropriate callback. The callback receives as a
   parameter the message struct, which contains the AVPs for the
   command. The callback code can process the command by stepping
   through the AVPs.

   For outgoing requests, the API provides functions for creating
   messages and adding AVPs. A collection of functions also provides
   access to the AVP dictionary.




Kempf, Calhoun, Frascone expires September 2001                 [Page 5]

INTERNET DRAFT                                                April 2001


   Unless otherwise noted, parameters to API functions and callbacks are
   non-NULL. Some parameters may have other restrictions. If a parameter
   fails to satisfy the restrictions on its value, the function returns
   AAA_ERR_PARAMETER.


3.1 Constant Types


3.1.1 IP Address and Port


3.1.1.1 Synopsis

      typedef sockaddr_storage IP_ADDR;

3.1.1.2 Description

   IP_ADDR provides a way of referring to an IPv4 address, IPv6 address,
   and IP port. The default implementation (shown here) is for the POSIX
   Sockets API.


3.1.2 Command Code


3.1.2.1 Synopsis

      typedef uint32_t AAACommandCode;


3.1.2.2 Description

   AAACommandCode provides a way of referring to the AAA command code of
   a command. It is used when registering callbacks, among others.


3.1.3 Vendor Identifier


3.1.3.1 Synopsis

      typedef uint32_t AAAVendorId;


3.1.3.2 Description

   AAAVendorId provides a way of referring to the vendor identification



Kempf, Calhoun, Frascone expires September 2001                 [Page 6]

INTERNET DRAFT                                                April 2001


   code. It is used when registering callbacks, among others. Note that
   vendor id 0 is reserved and is defined by the preprocessor constant
   AAA_NO_VENDOR_ID.


3.1.4 Extension Identifier


3.1.4.1 Synopsis

      typedef uint32_t AAAExtensionId;


3.1.4.2 Description

   AAAExtensionId provides a way of referring to an application profile
   extension, for registering callbacks and other purposes.


3.1.5 Attribute/Value Pair Code


3.1.5.1 Synopsis

      typedef uint32_t AAA_AVPCode;


3.1.5.2 Description

   AAA_AVPCode provides a way of referring to the code number of an AVP.
   It is used as a parameter to the dictionary functions, and a field in
   the AVP struct.


3.1.6 Value Type Identifier


3.1.6.1 Synopsis

      typedef int32_t AAAValue


3.1.6.2 Description

   AAAValue provides a way of referring to particular dictionary-defined
   values. It is used in the dictionary API.





Kempf, Calhoun, Frascone expires September 2001                 [Page 7]

INTERNET DRAFT                                                April 2001


3.1.7 Server Type


3.1.7.1 Synopsis

      typedef void AAAServer;


3.1.7.2 Description

   AAAServer is an identifier for a particular serving peer. It is used
   in the server access functions.


3.1.8 Session Identifier


3.1.8.1 Synopsis

      typedef void AAASessionId;


3.1.8.2 Description

   AAASessionId is an identifier for a particular AAA session. It is
   used in the session APIs and when a message is created.


3.1.9 Message Identifier


3.1.9.1 Synopsis

      typedef uint32_t AAAMsgIdentifier;


3.1.9.2 Description

   AAAMsgIdentifier is a unique identifier for an AAA message. Each
   individual message is marked with an identifier.


3.1.10 Callback Handle


3.1.10.1 Synopsis

      typedef void AAACallbackHandle;



Kempf, Calhoun, Frascone expires September 2001                 [Page 8]

INTERNET DRAFT                                                April 2001


3.1.10.2 Description

   AAACallbackHandle is a type for representing the callback handle
   returned to the client when a callback is registered.


3.1.11 Application Identifier


3.1.11.1 Synopsis

      typedef void* AAAApplicationId;


3.1.11.2 Definition

   AAAApplicationId identifies a particular client session to the API.
   The application id is passed to AAAStartSession(), and is attached to
   incoming messages, to indicate with which client session the message
   is associated.


3.1.12 API Return Codes

   The following status codes are returned by functions in the AAA API:

      typedef enum {
              AAA_ERR_NOT_FOUND =     -2,
              AAA_ERR_FAILURE =       -1,
              AAA_ERR_SUCCESS =        0,
              AAA_ERR_NOMEM,
              AAA_ERR_PROTO,
              AAA_ERR_SECURITY,
              AAA_ERR_PARAMETER,
              AAA_ERR_CONFIG,
              AAA_ERR_UNKNOWN_CMD,
              AAA_ERR_MISSING_AVP,
              AAA_ERR_ALREADY_INIT,
              AAA_ERR_TIMED_OUT,
              AAA_ERR_CANNOT_SEND_MSG,
              AAA_ERR_ALREADY_REGISTERED,
              AAA_ERR_CANNOT_REGISTER,
              AAA_ERR_NOT_INITIALIZED,
              AAA_ERR_NETWORK_ERROR,
      } AAAReturnCode;

   Note that these status codes are separate from the codes returned by
   remote AAA servers.



Kempf, Calhoun, Frascone expires September 2001                 [Page 9]

INTERNET DRAFT                                                April 2001


   The following is a description of the error codes and the reasons why
   they can be returned:

      AAA_ERR_NOT_FOUND - This code is returned if a handle or id was
                          not found.

      AAA_ERR_FAILURE - This code is returned if an unspecified failure
                        occurred during an AAA operation.

      AAA_ERR_SUCCESS - This code is returned if the AAA operation
                        succeeded.

      AAA_ERR_NOMEM - This code is returned if the operation caused
                      memory to be exhausted.

      AAA_ERR_PROTO - This code is returned if a AAA protocol error
                      occurred.

      AAA_ERR_SECURITY - This code is returned if a security check
                         failed or another security error occurred.

      AAA_ERR_PARAMETER - This code is returned if an invalid parameter
                          was passed to an AAA function.

      AAA_ERR_CONFIG - This code is returned if an error was encountered
                       in a configuration file during library
                       initialization.

      AAA_ERR_UNKNOWN_CMD - This code is returned if the library
                            received a AAA command that is not in the
                            set of registered AAA commands.

      AAA_ERR_MISSING_AVP - This code is returned if a command was
                            received without a required AVP.

      AAA_ERR_ALREADY_INIT - This code is returned if an attempt is made
                             to initialize the AAA library when it has
                             already been initialized.

      AAA_ERR_TIMED_OUT - This code is returned when a network operation
                          times out.

      AAA_ERR_CANNOT_SEND_MSG - This code is returned if the library
                                can't send a message. It is also of used
                                to application profile extensions that
                                encounter the same error condition.

      AAA_ERR_ALREADY_REGISTERED - This code is returned by the command



Kempf, Calhoun, Frascone expires September 2001                [Page 10]

INTERNET DRAFT                                                April 2001


                                   registration functions if the command
                                   was already registered.

      AAA_ERR_CANNOT_REGISTER - This code is returned by the command
                                registration functions if the command
                                could not be registered.

      AAA_ERR_NOT_INITIALIZED - This code is returned by any function in
                                the API except AAAOpen() if the library
                                hasn't been initialized.

      AAA_ERR_NETWORK_ERROR - This code is returned by any function if
                              an error in networking occurs.

   In addition to returning the error code, functions are required to
   log errors using the platform dependent logging facility.


3.1.13 Callback Location Codes

   The following are codes used to indicate where a callback should be
   installed in callback chain for processing:

      typedef enum {
              AAA_APP_INSTALL_FIRST,
              AAA_APP_INSTALL_ANYWHERE,
              AAA_APP_INSTALL_LAST
      } AAACallbackLocation;

   Callbacks installed with AAA_APP_INSTALL_FIRST and
   AAA_APP_INSTALL_LAST operate on all commands, callbacks installed
   with AAA_APP_INSTALL_ANYWHERE just operate on the command for which
   they are installed.

   The codes have the following semantics:

      AAA_APP_INSTALL_FIRST - Install this callback as the first
                              callback in the chain. If subsequent
                              callbacks are installed with this code,
                              the callback is moved down the list.

      AAA_APP_INSTALL_ANYWHERE - Install this callback anywhere in the
                                 callback chain.

      AAA_APP_INSTALL_LAST - Install this callback as the last callback
                             in the chain. If subsequent callbacks are
                             installed with this code, the callback is
                             moved up the list.



Kempf, Calhoun, Frascone expires September 2001                [Page 11]

INTERNET DRAFT                                                April 2001


3.1.14 AVP Data Type Codes

   The following are AVP data type codes. They correspond directly to
   the AVP data types outline in the Diameter specification [1]:

      typedef enum {
              AAA_AVP_DATA_TYPE,
              AAA_AVP_STRING_TYPE,
              AAA_AVP_ADDRESS_TYPE,
              AAA_AVP_INTEGER32_TYPE,
              AAA_AVP_INTEGER64_TYPE,
              AAA_AVP_TIME_TYPE,
      } AAA_AVPDataType;


3.1.15 AVP Flags

   The following are used for AVP header flags and for flags in the AVP
   wrapper struct and AVP dictionary definitions. The first six
   correspond to the AVP flags defined in the Diameter specification
   [1]. Some of these are also used in the wrapper struct and dictionary
   definitions also. The last four are used only in  AAA_AVP and
   AAADictionaryEntry:

      typedef enum {
          AAA_AVP_FLAG_NONE =                 0,
          AAA_AVP_FLAG_MANDATORY =            0x1,
          AAA_AVP_FLAG_RESERVED =             0x2,
          AAA_AVP_FLAG_VENDOR_SPECIFIC =      0x4,
          AAA_AVP_FLAG_END_TO_END_ENCRYPT =   0x10,
          AAA_AVP_FLAG_UNKNOWN =              0x10000,
          AAA_AVP_FLAG_ENCRYPT =              0x40000,
      } AAA_AVPFlag;

   The semantics of the flags are as follows:

      AAA_AVP_FLAG_NONE -Indicates that no AVP flags are set.

      AAA_AVP_FLAG_MANDATORY - Represents the 'M' flag in the Diameter
                               AVP header [1], meaning the AVP is
                               mandatory.

      AAA_AVP_FLAG_RESERVED - Represents the 'R' flag in the Diameter
                              AVP header [1]. This flag is reserved and
                              should not be set.

      AAA_AVP_FLAG_VENDOR_SPECIFIC - Represents the 'V' flag in the
                                     Diameter AVP header [1], meaning



Kempf, Calhoun, Frascone expires September 2001                [Page 12]

INTERNET DRAFT                                                April 2001


                                     that the AVP is vendor specific.
                                     If this flag is set, the header
                                     will contain a vendor identifier.

      AAA_AVP_FLAG_END_TO_END_ENCRYPT - Represents the 'P' flag in the
                                        Diameter AVP header [1], meaning
                                        that the AVP is end-to-end
                                        encrypted [3].

      AAA_AVP_FLAG_UNKNOWN - Indicates that the AVP was not located in
                             the AVP dictionary. This flag is only used
                             in AAA_AVP.

      AAA_AVP_FLAG_ENCRYPT - Indicates that the AVP was either marked as
                             AAA_AVP_FLAG_END_TO_END_ENCRYPT or that it
                             was hop-by-hop encrypted (and thus that the
                             AAA_AVP_FLAG_END_TO_END_ENCRYPT flag is not
                             set on in the AVP header). If the AVP is
                             not end-to-end encrypted, then it will be
                             either one of the two standard hop-by-hop
                             encrypted AVPs, Integrity-Check-Value and
                             Encrypted-Payload [1].  This flag is only
                             used in AAA_AVP.


3.1.16 Domain Interconnection Types

   The following domain interconnection types are returned by
   AAAGetDomainInternconnectType(). They indicate the type of domain
   interconnection:

      typedef enum {
          AAA_DOMAIN_LOCAL,
          AAA_DOMAIN_PROXY,
          AAA_DOMAIN_BROKER,
          AAA_DOMAIN_FORWARD
      } AAADomainInterconnect;

   The flags have the following semantics:

      AAA_DOMAIN_LOCAL - The domain name is for the local domain.

      AAA_DOMAIN_PROXY - The domain name is for a proxy domain. A proxy
                         is a server that simply forwards the request
                         based on the user's identity or through some
                         other means. The routing method used for a
                         proxy is the Proxy-State method, requiring
                         routing through a fixed chain of proxies [1].



Kempf, Calhoun, Frascone expires September 2001                [Page 13]

INTERNET DRAFT                                                April 2001


      AAA_DOMAIN_BROKER - The domain name is for a broker domain. A
                          broker is a server that provides redirect
                          services, allowing all servers in a roaming
                          consortium to interact directly.

      AAA_DOMAIN_FORWARD - The domain name is for a forwarding domain. A
                           forwarding domain is a proxy that uses
                           Destination-NAI routing. With Destination-NAI
                           routing, there is no set sequence of proxies
                           through which messages must be routed [1].


3.1.17 Message Flags

   The following type is for the AAA message flags. Currently, there are
   no message flags defined in the Diameter protocol [1]:

      typedef uint8_t AAAMsgFlag;


3.1.18 Result Codes

   The following are the result codes returned from remote servers as
   part of messages. They correspond directly to the result codes in the
   Diameter specification [1]:

      typedef enum {
          AAA_SUCCESS = 0,
          AAA_FAILURE,
          AAA_POOR_REQUEST,
          AAA_INVALID_AUTH,
          AAA_UNKNOWN_SESSION_ID,
          AAA_USER_UNKNOWN,
          AAA_COMMAND_UNSUPPORTED,
          AAA_TIMEOUT,
          AAA_AVP_UNSUPPORTED,
          AAA_REDIRECT_INDICATION,
          AAA_REALM_NOT_SERVED,
          AAA_UNSUPPORTED_TRANSFORM,
          AAA_AUTHENTICATION_REJECTED,
          AAA_AUTHORIZATION_REJECTED,
          AAA_INVALID_AVP_VALUE,
          AAA_MISSING_AVP,
          AAA_UNABLE_TO_DELIVER
      } AAAResultCode;


3.1.19 Search Direction Type



Kempf, Calhoun, Frascone expires September 2001                [Page 14]

INTERNET DRAFT                                                April 2001


   The following type allows the client to specify which direction to
   search for an AVP in the AVP list:

      typedef enum {
          AAA_FORWARD_SEARCH = 0,
          AAA_BACKWARD_SEARCH
      } AAASearchType;


3.2 Structure Definitions


3.2.1 Dictionary Entry Definition

   The following structure is returned by the dictionary entry lookup
   functions. It contains information about a particular AVP in the
   dictionary:

      typedef struct dictionaryEntry {
              AAA_AVPCode     avpCode;
              char*           avpName;
              AAA_AVPDataType avpType;
              AAAVendorId     vendorId;
              AAA_AVPFlag     flags;
      } AAADictionaryEntry;


3.2.2 AVP Definition

   The following structure contains a message AVP in parsed form:

      typedef struct avp {
              enum {
                      AAA_RADIUS,
                      AAA_DIAMETER
              } packetType;
              AAA_AVPCode code;
              uint16_t length;
              AAA_AVPFlag flags;
              AAA_AVPDataType type;
              AAAVendorId vendorId;
              void* data;
      } AAA_AVP;

   The fields have the following definitions:

      packetType - Indicates whether the message is for Diameter or for
                   Radius compatibility. If the AVP is for Radius, then



Kempf, Calhoun, Frascone expires September 2001                [Page 15]

INTERNET DRAFT                                                April 2001


                   the code, length, type, and data fields are the only
                   valid fields in the structure; the other fields are
                   all null.

      code - The AVP code. The type of the AVP can be determined by
             matching the AVP code with an AVP description from the
             dictionary.

      length - The length of the AVP's data field.

      flags - The AVP flags.

      type - The data type of the AVP's data.

      vendorId - The vendor id, if the AVP is vendor-specific.  If the
                 AVP is standardized, the vendorId field is set to
                 AAA_NO_VENDOR_ID.

      data - The AVP data, in host byte order.


3.2.3 AVP List

   The following structure is used for represnting lists of AVPs on the
   message:

      typedef struct avpList{
              AAA_AVP *head;
              AAA_AVP *tail;
      } AAA_AVP_LIST;

   AVPs are kept in ordered lists. The client can use a search direction
   to indicated in which direction to search when trying to find an AVP.


3.2.4 Message Definition

   The following structure contains the full AAA message:

      typedef struct message {
              AAAMsgFlag              flags;
              AAACommandCode          commandCode;
              AAAVendorId             vendorId;
              AAAResultCode           resultCode;
              IP_ADDR                 originator;
              IP_ADDR                 sender;
              AAA_AVP_LIST            *avpList;
              AAA_AVP                 *proxyAVP;



Kempf, Calhoun, Frascone expires September 2001                [Page 16]

INTERNET DRAFT                                                April 2001


              AAAMsgIdentifier        identifier;
              time_t                  secondsTillExpire;
              time_t                  startTime;
              void                    *appHandle;
      } AAAMessage;

   The fields have the following definition:

      flags - The message flags. Currently this field is always zero,
              since there are no flags defined for a Diameter message at
              this time.

      commandCode - The command's message code.

      vendorId - The vendor id of the vendor that defined the message.

      resultCode - Code indicating the result of the client's request.
                   This code is sent by the peer over the wire.

      originatorVersion - The IP version of the originator's address.

      originator - The IP address of the message's originator.

      senderVersion - The IP version of the sender's address.

      sender - The IP address of the message's previous hop sender. This
               is only the same as originator if no proxy or broker
               peers are being used.

      port - The port on which the message was received.

      avpList - The list of AVPs in the message.

      proxyAVP - The proxy's AVP, if any. Otherwise NULL.

      identifier - The message's unique identifier.

      secondsTillExpire - Number of seconds until the message expires.

      startTime - The number of seconds at which the message was
                  started.

      appHandle - An identifier indicating for which client session the
                  message is.


3.3 Macros and Preprocessor Definitions




Kempf, Calhoun, Frascone expires September 2001                [Page 17]

INTERNET DRAFT                                                April 2001


   The following definition reserves the vendor id of 0:

      #define AAA_NO_VENDOR_ID                                0


3.4 Functions


3.4.1 Initialization and Configuration

   This section contains definitions that perform initialization and
   configuration of the AAA library.


3.4.1.1 AAAOpen()

   The following function is used to open and configure the AAA library:

      AAAReturnCode AAAOpen(char *configFileName);

   This function must be called before any other AAA function is called.
   Some of the operations that may be performed by AAAOpen() are:
   opening and loading the AVP and vendor dictionaries, opening
   connections with Diameter peers, loading  Diameter extension
   libraries, and registering Diameter callbacks. After AAAOpen()
   returns, the library must be ready for the client to open a session.

   Parameters are:

       configFileName - The global configuration file name. If NULL or
                        the empty string, use the default for this
                        platform. The global configuration file must
                        contain the vendor and AVP dictionary file
                        names, and may contain other platform-specific
                        information needed to initialize and configure
                        the Diameter peer.

   Return values are:

      AAA_ERR_SUCCESS - If initialization succeeded.

      AAA_ERR_ALREADY_INIT - If the library is already initialized.

      AAA_ERR_NETWORK_ERROR - If the host name can't be determined.

      AAA_ERR_NOMEM - If no memory was available.

      AAA_ERR_CONFIG - If processing the dictionary or configuration



Kempf, Calhoun, Frascone expires September 2001                [Page 18]

INTERNET DRAFT                                                April 2001


                       information failed.


3.4.1.2 AAAClose()

   The following function closes the AAA library:

      AAAReturnCode AAAClose();

   After this function is called, all other AAA functions are no longer
   operative.

   Return values are:

      AAA_ERR_SUCCESS - If finalization succeeded.

      AAA_ERR_NOT_INIITIALIZED - If AAA was not initialized.


3.4.1.3 AAAGetDefaultConfigFileName()

   The following returns the default configuration file name on the
   platform:

      const char *AAAGetDefaultConfigFileName();

   The return value is a pointer to the full pathname for the file. The
   pointer value should not be deallocated because it is constant and
   does not change.


3.4.2 Registering Commands

   The functions in this section are used to register callback functions
   defined in a Diameter application profile extension library. The
   following typedef defines the interface between callback functions
   and the AAA library functions:

      typedef AAAReturnCode (*func)(AAAMessage *message) AAACallback;

      Authors of Diameter extensions must define command callback
      functions having this interface.

      Parameters are:

      message - The AAAMessage to be processed.

   The return value is a status code giving the operation status.



Kempf, Calhoun, Frascone expires September 2001                [Page 19]

INTERNET DRAFT                                                April 2001


3.4.2.1 AAARegisterCommandCallback()

   The following function is used to register command callbacks for
   processing AAA commands:

      AAACallbackHandle *
        AAARegisterCommandCallback(AAACommandCode commandCode,
                                   AAAVendorId vendorId,
                                   char *commandName,
                                   AAAExtensionId extensionId,
                                   AAACallback callback,
                                   AAACallbackLocation position);

   Parameters are:

      commandCode - The code of the command processed by the callback.

      vendorId - The vendor id of the command.

      commandName - A pointer to the name of the command.

      extensionId - The id of the extension to which this command
                    belongs.

      callback - The callback function to perform processing.

      position - The position of the callback in the chain.

   The return value is a handle used when deregistering the callback, or
   NULL if an error occurred while registering the callback.


3.4.2.2 AAARegisterNoncommandCallback()

   The following callback registers an AAA callback to process all
   messages. The callback is not associated with any command, but rather
   will process all messages as they come down the callback chain:

      AAACallbackHandle
        AAARegisterNoncommandCallback(AAACallback callback,
                                      AAACallbackLocation position);

   Parameters are:

      callback - The callback function to perform processing.

      position - The position of the callback in the chain.




Kempf, Calhoun, Frascone expires September 2001                [Page 20]

INTERNET DRAFT                                                April 2001


   The return value is a handle used when deregistering the callback, or
   NULL if an error occurred while registering the callback.


3.4.2.3 AAADeregisterCommandCallback()

   The following function deregisters a command callback:

      AAAReturnCode
        AAADeregisterCommandCallback(AAACallbackHandle *handle);

   Parameters are:

      handle - The handle returned when the callback was registered.

   The return values are:

      AAA_ERR_SUCCESS - Returned upon completion.

      AAA_ERR_FAILURE - if the callback is not registered.


3.4.2.4 AAADeregisterNoncommandCallback()

   The following function is used to deregister a noncommand callback:

      AAAReturnCode
        AAADeregisterNoncommandCallback(AAACallbackHandle *handle);

      handle - The handle returned when the callback was registered.

   Return values are:

      AAA_ERR_SUCCESS - Returned upon completion.

      AAA_ERR_FAILURE - If the callback is not registered.


3.4.2.5 AAARegisterExtension()

   The following function is used to register a Diameter extension id.
   This function is typically called when registering non-command
   specific callbacks. Extension ids for c ommand-specific callbacks are
   registered when the callback is registered:

      AAAReturnCode AAARegisterExtension(AAAExtensionId extensionId);

   The parameters are:



Kempf, Calhoun, Frascone expires September 2001                [Page 21]

INTERNET DRAFT                                                April 2001


      extensionId - The extension id.

   The return codes are:

      AAA_ERR_SUCCESS - If the registration was successful.


      AAA_ERR_NOMEM - if a memory allocation failure occurred.


3.4.3 Session and Server Management

   The functions in this section allow the client to open, close, and
   register sessions, and to obtain server identifiers.


3.4.3.1 AAAStartSession()

   The following function allows a client to start a session and
   identify it:

      AAAReturnCode AAAStartSession(AAASessionId **sessionId,
                                    AAAApplicationId appHandle,
                                    char *userName);

   Parameters are:

      sessionId - On return, a pointer to the session id for this
                  session.

      appHandle - An identifier for the client application starting the
                  session. This identifier is attached to messages so
                  that the client callbacks can tell which messages
                  belong to it.

      userName  - The NAI of the user.

   Return values are:

      AAA_ERR_SUCCESS - If the session was successfully started.

      AAA_ERR_NOMEM - If a memory allocation failure occurred.


3.4.3.2 AAARegisterPeerSession()

   The following function allows a client to register a peer session
   that it has discovered through some other means, for example, by



Kempf, Calhoun, Frascone expires September 2001                [Page 22]

INTERNET DRAFT                                                April 2001


   receiving an unsolicited message.

      AAAReturnCode AAARegisterPeerSession(AAASessionId **sessionId,
                                           AAAApplicationId *appHandle,
                                           AAAMessage *message,
                                           char *userName,
                                           char *hostName);

   The parameters are:

      sessionId - On return, a pointer to the local session id for the
                  session.

      appHandle - An identifier for the client application starting the
                  session. This identifier is attached to messages so
                  that the client callbacks can tell which messages
                  belong to it.

      message - The message from the peer containing the session id.

      userName  - The NAI of the user.

      hostName - The originator of the Diameter message

   Return values are:

      AAA_ERR_SUCCESS - If the session was successfully registered.

      AAA_ERR_NOMEM - If a memory allocation failure occurred.


3.4.3.3 AAAEndSession()

   The following function terminates a session:

      AAAReturnCode AAAEndSession(AAASessionId *sessionId);

   The parameters are:

      sessionId - A pointer to the session id for the session.

   Return values are:

      AAA_ERR_SUCCESS - If the session was successfully closed.

      AAA_ERR_NOT_FOUND - If the handle is invalid.





Kempf, Calhoun, Frascone expires September 2001                [Page 23]

INTERNET DRAFT                                                April 2001


3.4.3.4 AAALookupServer()

   The function looks up the AAA server based on IP address and port
   number.  Server connections are created from the configuration file:

      AAAServer *AAALookupServer(IP_ADDR ipAddr);

   The parameters are:

      ipAddr - The IP address/Port/Family of the server.

   The return value is either a valid server pointer or the NULL if the
   server can't be found.


3.4.3.5 AAASetSessionMessageTimeout()


   The following function sets the timeout, in seconds, for all
   AAAMessages in a particular session:

      AAAReturnCode AAASetSessionMessageTimeout(AAASessionId *id,
                                                time_t timeout);

   The parameters are:

      id - The session id for the session whose timeout should be
      changed.

      timeout - The session timeout. The default timeout is 120 seconds.

   The return values are:

      AAA_ERR_SUCCESS - If setting the timeout succeeded.

      AAA_ERR_FAILURE - If the setting the timeout failed.


3.4.3.6 AAAGetDomainInterconnectType()

   The following function returns the domain interconnect type for a
   particular domain name and type of service:

      AAAResultCode
         AAAGetDomainInterconnectType(AAAMessage *message, char *domainName,
                                      char *type);

   The parameters are:



Kempf, Calhoun, Frascone expires September 2001                [Page 24]

INTERNET DRAFT                                                April 2001


      domainName - The name of the domain.

      type - The type of service. This must be one of the strings
             "LOCAL", "PROXY", or "BROKER".


3.4.4 Dictionary Lookup

   The functions in this section are used to look up AVPs and commands
   in the dictionary. The client is responsible for supplying the
   structure memory into which the dictionary information is copied.


3.4.4.1 AAADictionaryEntryFromAVPCode()

   This function looks up a dictionary entry using a command code and a
   vendor id:

      AAAReturnCode
        AAADictionaryEntryFromAVPCode(AAA_AVPCode avpCode,
                                      AAAVendorId vendorId,
                                      AAADictionaryEntry *entry);

   The parameters are:

      avpCode - The code number of the AVP.

      vendorId - The vendor id of the AVP.

      entry - an AAADictionaryEntry structure for returning the entry.

   The return value is one of:

      AAA_ERR_SUCCESS - If the query succeeded.

      AAA_ERR_FAILURE - If no matching dictionary entry was found.


3.4.4.2 AAADictionaryEntryFromName()

   This function looks up a dictionary entry using command code name and
   vendor id:

      AAAReturnCode
        AAADictionaryEntryFromName(char *avpName,
                                  AAAVendorId vendorId,
                                  AAADictionaryEntry *entry);




Kempf, Calhoun, Frascone expires September 2001                [Page 25]

INTERNET DRAFT                                                April 2001


   The parameters are:

      avpName - The name of the AVP.

      vendorId - The vendor id of the AVP.

      entry - an AAADictionaryEntry structure for returning the entry.

   The return value is one of:

      AAA_ERR_SUCCESS - If the query succeeded.

      AAA_ERR_FAILURE - If no matching dictionary entry was found.


3.4.4.3 AAAValueFromName()

   This function looks up an AVP value using the AVP name and vendor
   name:

      AAAValue AAAValueFromName(char *avpName,
                                char *vendorName,
                                char *valueName);

   The parameters are:

      avpName - The name of the AVP.

      vendorName - The name of the vendor.

      valueName - The name of the value.

   The return value is the id of the AVP, or AAA_ERR_NOT_FOUND if no
   match was found.


3.4.4.4 AAAValueFromAVPCode()

   This function looks up an AVP value using the AVP id and vendor id,
   and the value name:

      AAAValue AAAValueFromAVPCode(AAA_AVPCode avpCode,
                                   AAAVendorId vendorId,
                                   char *valueName);

   The parameters are:

      avpCode - The code of the AVP.



Kempf, Calhoun, Frascone expires September 2001                [Page 26]

INTERNET DRAFT                                                April 2001


      vendorId - The id of the vendor.

      valueName - The name of the value.

   The return value is id of the AVP, or AAA_ERR_NOT_FOUND if no match
   was found.


3.4.4.5 AAALookupValueNameUsingValue()

   This function returns the AVP value name:

      const char *AAALookupValueNameUsingValue(AAA_AVPCode avpCode,
                                               AAAVendorId vendorId,
                                               AAAValue value);

   The parameters are:

      avpCode - The code of the AVP.

      vendorId - The id of the vendor.

      value - The value.

   The value name is returned, or NULL if no match occurred.


3.4.4.6 AAAGetCommandCode()

   This function returns the command code and vendor id based on a
   string:

      boolean_t AAAGetCommandCode(char *commandName,
                                  AAACommandCode *commandCode,
                                  AAAVendorId *vendorId);

   The parameters are:

      commandName - A string containing the command name.

      commandCode - Pointer that on return holds the command code if the
                    command was found.

      vendorId - Pointer that on return holds the vendor id if the
                 command was found.

   The return value is _B_TRUE if the command was found.




Kempf, Calhoun, Frascone expires September 2001                [Page 27]

INTERNET DRAFT                                                April 2001


3.4.5 Message Management

   The functions in this section allow the client to create messages,
   add AVPs, and traverse AVP lists.


3.4.5.1 AAANewMessage()

   This function allocates an AAAMessage and returns a pointer to it. If
   a command code is provided, this function adds the command code AVP
   and the Initialization-Vector AVP. If the session identifier handle
   is provided, the Session-Id AVP is also added. Lastly, if this
   message is allocated in response to a request, the request's message
   can be provided, and the new message is initialized to match the
   request, for fields such as the identifier, the server identifier,
   etc. If this is a new message, the request parameter is NULL:

      AAAMessage *AAANewMessage(AAACommandCode commandCode,
                                AAAVendorId vendorId,
                                AAASessionId *sessionId,
                                AAAExtensionId extensionId,
                                AAAMessage *request);

   The parameters are:

      commandCode - The command code.

      vendorId - The vendor identifier.

      sessionId - Session identifier.

      extensionId - The extension identifier.

      request - A pointer to a request message, if this message is being
                allocated in response to a request.

   The function returns a pointer to the message or NULL if a failure
   occurred.


3.4.5.2 AAAFreeMessage()

   This function frees a message allocated through AAANewMessage():

      AAAReturnCode  AAAFreeMessage(AAAMessage *message);

   The parameters are:




Kempf, Calhoun, Frascone expires September 2001                [Page 28]

INTERNET DRAFT                                                April 2001


      message - A pointer to the allocated message.

   The return value is the AAA status code AAA_ERR_SUCCESS.

3.4.5.3 AAARespondToMessage()

   This function is called to set the AAA Message to the appropriate
   values, and to inform the library that this message is a locally
   generated response


      AAAReturnCode AAARespondToMessage(AAAMessage* message,
                                        AAACommandCode commandCode,
                                        AAAVendorId vendorId,
                                        AAAResultCode resultCode);

   The parameters are:

      message - The AAAMessage to respond to.

      commandCode - The command code of the response.

      vendorId - The vendor identifier (of the command code).

      resultCode - The result code of the response.


   The function returns AAA_ERR_SUCCESS upon completion, or
   AAA_ERR_PARAMETER if a NULL pointer was provided.


3.4.5.4 AAAAddProxyState()

   This function will add a Proxy-State AVP to a message, that contains
   the FQDN of the source of the message.

      AAAReturnCode AAAAddProxyState(AAAMessage *message)


   The parameters are:

      message - The AAAMessage to add state to.


   The function returns AAA_ERR_SUCCESS upon completion, or
   AAA_ERR_FAILURE if an error occured.





Kempf, Calhoun, Frascone expires September 2001                [Page 29]

INTERNET DRAFT                                                April 2001


3.4.5.5 AAACreateAVP()

   This function creates an AVP and returns a pointer to it. The AVP is
   initialized from the arguments:

      AAAReturnCode AAACreateAVP(AAA_AVP **avp,
                                  AAA_AVPCode code,
                                  AAA_AVPFlag flags,
                                  AAAVendorId vendorId,
                                  char *data,
                                  size_t length);

   The parameters are:

      avp - On return, contains a pointer to the allocated AVP, or NULL
            if no AVP was allocated.

      code - The AVP's code.

      flags - Any AVP flags that must be passed.

      vendorId - The vendor id of the AVP. If no vendor id, then
                 AAA_NO_VENDOR_ID.

      data - A buffer containing the AVP data.

      length - The length of the data buffer.

   Return values are:

      AAA_ERR_SUCCESS - Upon success.

      AAA_ERR_PARAMETER - If an invalid parameter was passed.

      AAA_ERR_PROTO - If a protocol error occurred.

      AAA_ERR_NOMEM - Indicating  a memory failure.


3.4.5.6 AAACreateAndAddAVPToList()

   This function creates an AVP and adds it to an AVP list. It returns a
   pointer to the list in the avpList argument.  The AVP is initialized
   from the arguments:

      AAAReturnCode AAACreateAndAddAVPToList(AAA_AVP_LIST **avpList,
                                             AAA_AVPCode code,
                                             AAA_AVPFlag flags,



Kempf, Calhoun, Frascone expires September 2001                [Page 30]

INTERNET DRAFT                                                April 2001


                                             AAAVendorId vendorId,
                                             char *data,
                                             size_t length);

   The parameters are:

      avpList - The list to which the AVP should be added.

      code - The AVP's code.

      flags - Any AVP flags that must be passed.

      vendorId - The vendor id of the AVP. If no vendor id, then
                 AAA_NO_VENDOR_ID.

      data - A buffer containing the AVP data.

      length - The length of the data buffer.

   Return values are:

      AAA_ERR_SUCCESS - Upon success.

      AAA_ERR_PARAMETER - If an invalid parameter was passed.

      AAA_ERR_NOMEM - Indicating  a memory failure.


3.4.5.7 AAAAddAVPToList()

      AAAReturnCode AAAAddAVPToList(AAA_AVP_LIST **avpList,
                                    AAA_AVP *avp, AAA_AVP *position);

   Insert the AVP avp into this avpList after position. If position is
   NULL, the AVP is added to the beginning of the list.

   If *avpList is NULL, a list will be allocated, and *avpList will
   point to it.

   The parameters are:

      avpList - Pointer to a pointer for list. If *avpList is NULL, list
                memory is allocated.

      avp - AAA_AVP to add to list.

      position - AAA_AVP pointer to add data after, or NULL if the new
                 AVP should go at the end of the list.



Kempf, Calhoun, Frascone expires September 2001                [Page 31]

INTERNET DRAFT                                                April 2001


   The return value is one of:

      AAA_ERR_SUCCESS - Upon success.

      AAA_ERR_PARAMETER - If an invalid parameter was passed.

      AAA_ERR_NOMEM - Indicates a memory failure.


3.4.5.8 AAAFindMatchingAVP()

   This function finds an AVP with matching code and vendor id. If none
   match, the function returns NULL:

      AAA_AVP *AAAFindMatchingAVP(AAA_AVP_LIST *avpList,
                                  AAA_AVP *startAvp,
                                  AAA_AVPCode avpCode,
                                  AAAVendorId vendorId,
                                  AAASearchType searchType);

   The parameters are:

      avp - A pointer to the head of the AVP list.

      avpCode - The code of the sought after AVP.

      vendorId - The vendor id of the sought after AVP.

   The return value is a pointer to the found AVP, or NULL if none is
   found.


3.4.5.9 AAAJoinAVPLists()

   The following function joins together two AVP lists:

      AAAReturnCode AAAJoinAVPLists(AAA_AVP *dest,
                                    AAA_AVP *source);

   The parameters are:

      dest - The position of the join in the destination list.

      source - The position of the join in the source list.

   The return value is one of:

      AAA_ERR_SUCCESS - Upon success.



Kempf, Calhoun, Frascone expires September 2001                [Page 32]

INTERNET DRAFT                                                April 2001


      AAA_ERR_PARAMETER - If an invalid parameter was passed.


3.4.5.10 AAARemoveAVPFromList()

   This function removes an AVP from a list:

      AAAReturnCode AAARemoveAVPFromList(AAA_AVP_LIST *avpList,
                                         AAA_AVP *avp);


   The parameters are:

      avpList - The head of the list from which to remove the AVP.

      avp - Contains a pointer to the AVP to remove.

   The return value is one of:

      AAA_ERR_SUCCESS - Upon success.

      AAA_ERR_PARAMETER - If an invalid parameter was passed.


3.4.5.11 AAAFreeAVP()

   The function frees an AVP:

      AAAReturnCode AAAFreeAVP(AAA_AVP *avp);

   The parameters are:

      avp - Contains a pointer to the AVP to free.

   The return value is one of:

      AAA_ERR_SUCCESS - Upon success.

      AAA_ERR_PARAMETER - If an invalid parameter was passed.


3.4.5.12 AAAGetFirstAVP()

   This function returns a pointer to the first AVP in the list:

      AAA_AVP *AAAGetFirstAVP(AAA_AVP_LIST *avpList);

   The parameters are:



Kempf, Calhoun, Frascone expires September 2001                [Page 33]

INTERNET DRAFT                                                April 2001


      avpList - A pointer to the list.

   The return value is a pointer to the found AVP, or NULL if none is
   found.


3.4.5.13 AAAGetLastAVP()

   This function returns a pointer to the last AVP in the list:

      AAA_AVP *AAAGetLastAVP(AAA_AVP_LIST *avpList);

   The parameters are:

      avpList - A pointer to the list.

   The function returns a pointer to the found AVP, or NULL if none is
   found.


3.4.5.14 AAAGetNextAVP()

   This function returns a pointer to the next AVP in the list.

      AAA_AVP *AAAGetNextAVP(AAA_AVP *avp);

   The parameters are:

      avp - A pointer to the AVP prior to the one sought.

   The return value is the next AVP in the list, or NULL if the
   parameter is the last element in the list.


3.4.5.15 AAAGetPrevAVP()

   This function returns a pointer to the previous AVP in the list:

      AAA_AVP *AAAGetPrevAVP(AAA_AVP *avp);

   The parameters are:

      avp - A pointer to the AVP after the one sought.

   The return value is the previous AVP in the list or NULL if the
   parameter is the first element in the list.

3.4.5.16 AAAConvertAVPToString()



Kempf, Calhoun, Frascone expires September 2001                [Page 34]

INTERNET DRAFT                                                April 2001


   This function converts the data in the AVP to a format suitable for
   log or display functions.

      char *AAAConvertAVPToString(AAA_AVP *avp, char *dest, size_t destLen);

   The parameters are:

      avp - The AVP to display.
      dest - A used supplied destination buffer.
      destLen - The length of the user supplied buffer.

   The return value is the passed in destination buffer.


3.4.5.17 AAASetMessageResultCode()

   This function decapsulates an encapsulated AVP, and populates the
   list with the correct pointers.

      AAAResultCode AAASetMessageResultCode(AAAMessage *message,
                                            AAAResultCode resultCode);

   The parameters are:

      message - A pointer to the allocated message.

      resultCode - The AAA Result Code

   The return value is one of:

      AAA_ERR_SUCCESS - Upon success.

      AAA_ERR_PARAMETER - If an invalid parameter was passed.


3.4.6 Message Control

   The following functions allow the client to direct a message to a
   particular server, determine the server for a message, etc.


3.4.6.1 AAASetServer()

   This function sets the server to which the message is sent:

      AAAReturnCode AAASetServer(AAAMessage *message,
                                 IP_ADDR host);




Kempf, Calhoun, Frascone expires September 2001                [Page 35]

INTERNET DRAFT                                                April 2001


   The parameters are:

      message - The message to be sent.

      ipVersion - The version number of the IP address.

      host - The IP address / port / family of the server.

   The return value is

      AAA_ERR_SUCCESS - If the server was found.

      AAA_ERR_NOT_FOUND - If the server was not found.


3.4.6.2 AAASendMessage()

   The following function sends a message to the server assigned to the
   message by AAASetServer(). The message identifier is assigned to the
   message. If no server id has been assigned to the message, a server
   id is selected. If no servers are currently active, the message is
   queued for later sending.

      AAAReturnCode AAASendMessage(AAAMessage *message);

   The parameter is the message to send.

   The return codes are:

      AAA_ERR_SUCCESS - Upon completion.

      AAA_ERR_FAILURE - If an error occurred.


3.5 Implementation Notes

   The following are some implementation notes that library designers
   may want to keep in mind.


3.5.1 Grouped AVPs

   In order to create grouped AVPs, an application creates an
   AAA_AVP_LIST that is not attached to an AAAMessage structure (also
   known as an orphaned AAA_AVP_LIST). All of the necessary AVPs within
   the Group are added to the orphaned AAA_AVP_LIST using the existing
   list manipulation functions.  Lastly, the grouped AVP is added to the
   AAAMessage structure.



Kempf, Calhoun, Frascone expires September 2001                [Page 36]

INTERNET DRAFT                                                April 2001


   The following is an example that adds a Proxy-State Grouped AVP to an
   existing AAAMessage structure.

      int
      addProxyState(AAAMessage *message, ipaddr_t *ourAddress,
          void *state, size_t stateLen)
      {
              AAA_AVP_LIST *avpList = NULL;

              /*
               * Add the Proxy-Address AVP to the AAAList
               */
              if (AAACreateAndAddAVPToList(&avpList,
                  DIAM_AVP_PROXY_ADDRESS, AAA_AVPI_FLAG_NONE,
                  NO_VENDOR_ID, (char *) ourAddress,
                  sizeof (ipaddr_t))) {
                      loggerSyslog(LOG_AVP_PROBLEMS,
                          "Unable to add Proxy-Address AVP");
                      return (AAA_ERR_FAILURE);
              }
              /*
               * Now we add the Proxy-Info AVP to the AAAList
               */
              if (AAACreateAndAddAVPToList(&avpList,
                  DIAM_AVP_PROXY_INFO, AAA_AVPI_FLAG_NONE, NO_VENDOR_ID,
                  state, stateLen)) {
                      loggerSyslog(LOG_AVP_PROBLEMS,
                          "Unable to add Proxy-Info AVP");
                      return (AAA_ERR_FAILURE);
              }
              /*
               * Now the AAAList is added to the AAAMessage as
               * a Proxy-State AVP.
               */
              if (AAACreateAndAddAVPToList(&message->avpList,
                  DIAM_AVP_PROXY_STATE, AAA_AVPI_FLAG_NONE,
                  NO_VENDOR_ID, (char *)avpList,
                  AAA_AVP_GROUPED_LENGTH)) {
                      loggerSyslog(LOG_AVP_PROBLEMS,
                          "Unable to add Proxy-State AVP");
                      return (AAA_ERR_FAILURE);
              }

              return (AAA_ERR_SUCCESS);
      }

   As shown above, the procedures is to create a new AAA_AVP_LIST
   structure, adding all of the necessary AVPs that are within the



Kempf, Calhoun, Frascone expires September 2001                [Page 37]

INTERNET DRAFT                                                April 2001


   Grouped AVP, then calling AAACreateAndAddAVPToList() to add the
   AAA_AVP_LIST as a Grouped AVP to the AAAMessage.

   Note that the AAA_AVP_LIST pointed to by orphaned avpList MUST NOT be
   accessed by the application after the Grouped avp has been created.
   The list will be freed along with the AVP by the AAA Library.

   In order to parse a Grouped AVP, the AAA_AVP data field contains a
   pointer to an AAA_AVP_LIST, as shown below.

      boolean_t
      isProxyStateOurs(AAA_AVP *proxyState, ipaddr_t *ourAddress)
      {
              AAA_AVP_LIST *avpList;
              AAA_AVP *proxyAddress;
              AAA_AVP *proxyInfo;
              ipaddr_t *proxyAddress;

              /*
               * Get the pointer to the Grouped AAA_AVP_LIST
               */
              avpList = (AAA_AVP_LIST *)proxyState->data;

              /*
               * First, for the Proxy-Address, and see if it is ours.
               */
              if ((proxyAddress = AAAFindMatchingAVP(avpList, NULL,
                  DIAM_AVP_PROXY_ADDRESS, NO_VENDOR_ID,
                  AAA_FORWARD_SEARCH)) != NULL) {
                      /*
                       * Check if this one is ours.
                       */
                      address2 = (ipaddr_t *)proxyAddress->data;
                      if (*address2 == *address) {
                              /*
                               * This one is ours... return TRUE
                               */
                              return (B_TRUE);
                      }
              }

              return (B_FALSE);
      }


3.5.2 Extended AAA_AVP structure

   The AAA_AVP structure that is defined in this specification is a



Kempf, Calhoun, Frascone expires September 2001                [Page 38]

INTERNET DRAFT                                                April 2001


   subset of the structure used by the internal library. The internal
   structure, known as the extended AAA_AVP, may contain many private
   fields, such as pointers to AAA_AVPs. Applications do not directly
   access the next (and previous) AAA_AVP pointers directly, but instead
   access them via the AAAGetNextAVP() and AAAGetPreviousAVP()
   functions.

   The following is an example of an extended AAA_AVP structure:

      typedef struct {
              // API Public variables here
      } AAA_AVP;

      typedef struct xavp {
              AAA_AVP      avp;
              struct xavp *next;
              struct xavp *prev;
              int          privateFlags;
      } Extended_AAA_Avp;

   Of course, when AAACreateAVP is called, sufficient memory is
   allocated for the extended AAA_AVP structure, however the function
   returns a pointer to the AAA_AVP.


3.5.3 Avoiding AVP Copying

   The AAA_AVP struct does not provide an exact mapping to the Diameter
   protocol AVP packet format; however, library implementors can avoid
   having to copy the AVP data by putting a pointer to a packet format
   structure into a hidden part of the AAA_AVP struct. A pointer to the
   AVP data is then deposited into the AAA_AVP data field. This allows
   proper deallocation of the packet format structure when the AAA_AVP
   structure is deallocated.

3.5.4 Callback Processing Order

   The C API allows API clients to register message processors, or
   callbacks, that are invoked before and after the bulk of the
   processing functions for a message. Only one pre- or post-processor
   is allowed for all incoming messages, regardless of command or
   extension type. If the API client adds another, any existing pre- and
   post-processors are removed.

   Message processing can be best explained by the following diagram:

        +-------+     +-------+     +-------+     +-------+
        | First |     |  Any  |     |  Any  |     |  Last | Apps



Kempf, Calhoun, Frascone expires September 2001                [Page 39]

INTERNET DRAFT                                                April 2001


        +-------+     +-------+     +-------+     +-------+
            ^             ^             ^             ^
          1 |           2 |           3 |           4 |
        +-------------------------------------------------+
        |                   AAA Library                   |
        +-------------------------------------------------+
                                ^
                                | MSG


   In the above diagram, "First", "Any", and "Last" are added by the API
   client. The message processor labeled "First" is given access to the
   message before any other, the message processor "Last" after all
   others are finished. There is no guarantee on ordering for the other
   message processors. If the client adds a new "First" or "Last"
   message processor, the existing ones removed. There is one "First"
   and "Last" processor for all commands regardless of type; whereas,
   the "Any" processors are command-specific.

   If one of the "Any" processors completes successfully, the message is
   not passed on any further. A successful completion means the success
   return code is returned from the C API callback, but the callback is
   responsible for freeing the message before returning.

4.0 Java API

4.1 Introduction

   The Java API provides a synchronous message sending model for clients
   and an asynchronous model for servers. A collection of reflection
   classes provide information about defined Diameter extensions,
   commands, and AVPs. The next three sections provide an overview of
   these three aspects of the API.

4.1.1 Client API Overview

   The advantage of a synchronous approach for the client API is that
   the client application code sees RPC-like semantics when sending a
   Diameter message (i.e. send request, get response) which considerably
   simplifies reasoning about code and debugging.  However, because
   clients must maintain the session state machine in Section 11.1 of
   [1], and because it is possible for the client to receive an
   unsolicited message from the server (such as Session-Termination-Ind,
   Section 11.7.1 of [1]) at any time, the client API library
   implementation still needs to maintain at least one "hidden" thread
   per outstanding server connection to handle the state machine. Since
   most clients will likely only maintain a connection with their local
   AAA server, that thread is likely to be the only one the client



Kempf, Calhoun, Frascone expires September 2001                [Page 40]

INTERNET DRAFT                                                April 2001


   library must maintain, thus reducing the processing load for clients.

   Sessions with Diameter servers are initiated in the following way.
   The API supports a superclass, AAASessionManager, that includes
   methods for managing sessions and sending messages that are common to
   both clients and servers. The AAAClientSessionManager contains
   methods that are specific for client-side session management.  The
   AAAClientSessionManager implementation performs Diameter server
   discovery according to the procedure outlined in Section 2.3 of [1],
   guided by the properties described in Section 4.1.4 below.  These
   servers are made available to the the client via
   AAAClientSessionManager.getConfiguredHosts(). The client then opens a
   session with a Diameter server by calling the
   AAASessionManager.startSession() method, passing in the host address
   of the Diameter server to contact and a command dictionary object
   used to drive parsing of Diameter commands for the session. The
   client can also dynamically open a session with a server by instead
   passing the NAI to AAASessionManager.findServerAddress() to determine
   the address, then passing the result to
   AAASessionManager.startSession(). The session id is a small integer,
   and it maps to the Diameter user session id as described in Section
   11.2 of [1].  The integers only identify sessions within this
   instance of the Java virtual machine, a String containing the network
   format of the session identifier can be determined by passing the
   integer session identifier to the
   AAASessionManager.getNetworkSessionId() method.

   Once a session has been initiated, the client can construct and send
   Diameter messages.  The client application code constructs an
   AAAMessage for the Diameter command it wants to send.  The
   AAASessionManager class supports an instance method,
   AAASessionManager.send(), that synchronously sends the message, and
   waits until a reply message is received, returning the reply message
   to the client, or throwing an exception with an error reply message
   if an error message is returned. The client can also use the
   AAASessionManager.notify() method to asynchronously send a message,
   but this method is primarily for use by Diameter extensions in
   servers.

   The client application code registers a callback with
   AAAClientSessionManager only to handle unsolicited messages that
   arrive for a particular session.  This callback is called by the
   state machine thread handler when an unsolicited message arrives that
   is session-specific. For example, if the state machine thread handler
   receives a Session-Termination-Ind for a particular session, the
   message is passed to the callback for the identified session. Exactly
   how the client handles a session termination (terminating a thread,
   sending an error event notification, etc.) is up to the client. The



Kempf, Calhoun, Frascone expires September 2001                [Page 41]

INTERNET DRAFT                                                April 2001


   API libary is required to handle all non-session related unsolicited
   messages transparently to the API client.  The library is also
   required to handle redirects (Section 12.3 of [1]) transparently to
   the client.

4.1.2 Server API Overview

   The server API supports an asynchronous model of message processing.
   A Diameter server application extension registers AAAMessageListener
   objects to handle particular Diameter commands. A client with an open
   session to the server sends Diameter messages. These are parsed and
   processed by the appropriate AAAMessageListener. The registered
   AAAMessageListener objects return an AAAMessage object to the server
   message handling code, which is returned to the client. If the return
   value of the AAAMessageListener.processMessage() is null, no message
   is returned to the client. The server can also send an asynchronous
   message to the client, for example a Session-Termination-Ind, through
   the AAASessionManager.notify() method. This method sends the message
   and returns without waiting for the client to respond.

   The server uses the AAAServerSessionManager object to handle sessions
   with clients. Sessions are automatically created by incoming requests
   and registered in the AAAServerSessionManager. The server API also
   supports methods to load extension code when messages are received.
   This allows the server to start with the base Diameter protocol and
   grow only as needed to support clients.

4.1.3 Reflection Classes Overview

   The client and server APIs share a set of reflection classes that
   describe Diameter extensions, commands, and AVPs. The reflection
   classes are organized around AAACommandDictionary.  This class
   provides a dictionary of all defined commands that can be parsed by
   the Java APIs. Each AAACommandDescriptor object provides basic
   information on the command (command code and vendor id), information
   on the extension of which the command is part (name, code, and vendor
   id), and information on mandatory, optional and disallowed AVPs. The
   commands in the command dictionary determine what messages the client
   and server APIs can legally parse, but to actually make use of the
   commands, the client or server must naturally have code to process
   the commands. If the server library receives a command with a code
   that is not known, DIAMETER_COMMAND_UNSUPPORTED in a Device-Status-
   Ind message is returned to the client by the library. Note that it is
   not possible for a client to create a Diameter command that the local
   client can't parse, because AAAMessage creation requires an
   AAACommandDescriptor object for a defined command.

   Information on commands is obtained from a command descriptor file



Kempf, Calhoun, Frascone expires September 2001                [Page 42]

INTERNET DRAFT                                                April 2001


   when the AAACommandDictionary is created. This file is read and
   parsed to drive creation of the command dictionary. The syntax for
   the command dictionary file is in XML and a DTD described it is
   available in [7].  Support of the XML command dictionary is a
   required part of the Java API because Java code moves easily from
   machine to machine, and so having a standardized file format assures
   that the Java API will encounter the same dictionary format on each
   host operating system platform.  XML was selected as the definition
   language because XML is available as an extension to the standard
   Java APIs [8], simplifying implementation.

4.1.4 Packages and Properties

   All Java Diameter API classes are within the same package. The
   package name is org.ietf.aaa.  This follows the Java convention of
   prepending the name of the organization responsible for the API to
   the package.  A single package name for all Diameter API
   implementations precludes running multiple library implementations
   within a single Java virtual machine.

   The following Java properties (accessable through
   java.lang.System.getProperties()) are used for configuration.  These
   properties must be set before the API library is loaded, and remain
   valid throughout the session.  Typically, the properties are set in a
   platform-specific configuration file, or on the command line when the
   program begins executing:

      org.ietf.aaa.defaultCommandDictionaryFile - A String containing
                                           the platform specific default
                                           command dictionary file name.
                                           This property is used by the
                                           client library to initialize
                                           the command dictionary if no
                                           application-specific
                                           dictionary file name is
                                           supplied by the client
                                           application code when a
                                           command dictionary is
                                           created.  On the server side,
                                           this file name is used to
                                           create the command dictionary
                                           that drives input parsing of
                                           all AAA commands.

      org.ietf.aaa.maxWait - A String containing a positive integer
      giving the default maximum time the session manager must wait for
      a return value, in milliseconds. This value includes the time
      after the Diameter server indicates that it is busy by sending a



Kempf, Calhoun, Frascone expires September 2001                [Page 43]

INTERNET DRAFT                                                April 2001


      Device-Status-Ind with DIAMETER_STILL_WORKING status code. Client
      library implementations should use some fraction of
      org.ietf.aaa.maxWait when sending the Max-Wait-Time AVP value to
      the server.

      org.ietf.aaa.client.initServers - A String containing a comma
      separated list of statically configured Diameter servers along
      with their extensions, if known. The syntax of the string in ABNF
      [2] form is:

        server-list = server-rec / server-rec "," server-list
        server-rec  = host ":" ext-list / host
        ext-list    = ext-name / ext-name 1*sep ext-list
        sep         = " "
        host        = hostname / hostnumber
        hostname    = *( domainlabel "." ) toplabel
        alphanum    = ALPHA / DIGIT
        domainlabel = alphanum / alphanum *stdchar alphanum
        toplabel    = ALPHA / ALPHA *stdchar alphanum
        hostnumber  = ipv4-number / ipv6-number
        ipv4-number = 1*3DIGIT 3("." 1*3DIGIT)
        ipv6-addr   = "[" num-addr "]"
        num-addr    = ; Text represented IPv6 address syntax is as
                      ; specified in RFC 2373 [9], Section 2.2,
        ext-name    = 1*stdchar
        stdchar     = alphanum / "-"
        alphanum    = ALPHA / DIGIT

      For example:

        org.ietf.aaa.client.initServers =
          default-aaa,nas-sever.wireless:NASReq Accounting

      org.ietf.aaa.client.initExtensions - A String containing a comma
      separated list of Diameter extensions for which the library should
      perform dynamic SLP [4] discovery when it initializes. For
      example:

        org.ietf.aaa.client.initExtensions =
          NASReq,Mobile-IP,VoIP,Accounting

      org.ietf.aaa.client.initDomains - A String containing a comma
      separated list of fully qualified domain names for which the
      library should perform DNS SRV RR [5] discovery when it
      intializes. For example:

        org.ietf.aaa.client.initDomains = femeto.org,letmein.com




Kempf, Calhoun, Frascone expires September 2001                [Page 44]

INTERNET DRAFT                                                April 2001


      org.ietf.aaa.server.proxyMap - A String containing a comma
      separated list of proxy/client list pairs. The list has the
      following format:

        proxyMap = host / proxyMapList
        proxyMapList = proxyClientList / proxyClientList "," proxyMapList
        proxyClientList = proxy ":" clientList
        clientList = client / client 1*sep clientList
        sep = " "
        proxy = host
        client = host
        FQHN = ;see definition for org.ietf.aaa.client.initServers

      For example:

        org.ietf.aaa.server.proxyMap =
          out.femeto.org:client1 client2,out2.femeto.org:client3

        If only one host name appears on the proxy map list, that host
        is the proxy for all incoming clients.

      org.ietf.aaa.server.redirectMap - A String containing a comma
      separated list of redirect server/client pairs.  The format of the
      list is exactly the same as for the org.ietf.aaa.server.proxyMap
      property. The host name before the colon indicates the redirect
      server, the host names after indicate the clients who have that
      server as the redirect.

   The org.ietf.aaa.client.initServers, org.ietf.client.initExtensions,
   and org.ietf.client.initDomains properties are client side only
   properties, while org.ietf.aaa.server.proxyMap and
   org.ietf.aaa.server.redirectMap are server side only properties. Both
   of these need to be set prior to loading the libraries.

4.2 Errors and Exceptions

   If any fatal errors occur during API library intitialization, an
   AAAException is thrown with the INIT_FAILURE status code. Errors may
   include improperly set configuration properties, inability to perform
   service discovery, etc. An exception of this nature will typically
   cause termination of program execution.

   In general, parameters to API methods are required to be non-null and
   String parameters must be non-empty, but the API description
   indicates if a null parameter or empty String is acceptable.
   Parameters must be checked by the API library before use and a
   java.lang.IllegalArgumentException exception thrown if any parameter
   is not acceptable. Since this class is a subclass of



Kempf, Calhoun, Frascone expires September 2001                [Page 45]

INTERNET DRAFT                                                April 2001


   java.lang.RuntimeException, clients are reminded to check for
   IllegalArgumentException even though it is not listed in the method
   API description. The documentation below only lists
   IllegalArgumentException if it is returned for a reason other than a
   null parameter.

   Unlike most Java packages, the Diameter API does not encode every
   error condition into a separate subclass of java.lang.Exception. When
   there are a large number of exceptional conditions (as in the
   Diameter API), the result is a proliferation of exception classes. In
   the Diameter API, the exception conditions are represented by error
   codes that are defined as constants in the org.ietf.aaa.AAAException
   class.  The API also defines an AAAMessageException message that is
   thrown when the AAASessionManager.send() method receives a Device-
   Status-Ind (Section 9.1 of [1]) or Message-Reject-Ind (Section 10.1
   of [1]) that is not handled internally by the API library. The
   exception object contains the returned AAAMessage.

   The client API library is required to handle the following Diameter
   events received in Device-Status-Ind transparently to the client
   application code and must not throw an exception:
   DIAMETER_REDIRECT_INDICATION, and DIAMETER_TIME_INVALID.

   The client API library is required to handle a Device-Status-Ind with
   DIAMETER_STILL_WORKING by continuing to wait for the return value
   until one of the following occurs:

      - The return message is received. In this case, the message is
      returned to the client application code,

      - A Device-Status-Ind with DIAMETER_CANNOT_PROCESS_IN_TIME status
      is received. In this case, a AAAMessageException is thrown with
      the message object.

      - The session-specific timeout set through
      AAASessionManager.setSessionTimeout() or the library timeout
      specified by the org.ietf.aaa.maxWait property expires. An
      AAAException message is thrown with AAAException.NETWORK_TIMEOUT
      status code. In this case, the state machine thread handler may
      need to discard a return message, should one arrive after the
      exception is thrown.

4.2.1 Class AAAException

4.2.1.1 Synopsis

      public class AAAException extends java.lang.Exception




Kempf, Calhoun, Frascone expires September 2001                [Page 46]

INTERNET DRAFT                                                April 2001


4.2.1.2 Description

   The AAAException class is the class for returning AAA exceptions not
   associated with received Device-Status-Ind and Message-Reject-Ind
   messages. These messages are typically internal errors,
   initialization errors, networking errors, or errors in command
   parsing.  The error code indicates the exact nature of the exception,
   along with text in the exception message.

4.2.1.3 Fields

      public static final short FAILURE         = 1
      public static final short SECURITY        = 2
      public static final short MISSING_AVP     = 3
      public static final short DISALLOWED_AVP  = 4
      public static final short INIT_FAILURE    = 5
      public static final short NETWORK_TIMEOUT = 6
      public static final short NETWORK_ERROR   = 7
      public static final short SESSION_INVALID = 8
      public static final short PARSE_ERROR     = 9
      public static final short VERSION_ERROR   = 10
      public static final short MESSAGE_ERROR   = 11

   Note that these status codes are separate from the codes returned by
   remote AAA servers.

      FAILURE - This code indicates an unspecified failure occurred
      during an AAA operation.

      SECURITY - This code indicates a security check failed or another
      security error occurred.

      MISSING_AVP - This code indicates the client tried to send an AVP
      without a required AVP, or a command was received without a
      required AVP.

      DISALLOWED_AVP - This code indicates the client tried to send an
      AVP with a disallowed AVP, or a command was received with a
      disallowed AVP.

      INIT_FAILURE - This code indicates that a fatal error occured when
      the library was initialised after loading.

      NETWORK_TIMEOUT - This code indicates that a network timeout
      occured. The timeout can be either a transport layer timeout, or
      the org.ietf.aaa.maxWait Diameter processing timeout or a session
      timeout was exceeded.




Kempf, Calhoun, Frascone expires September 2001                [Page 47]

INTERNET DRAFT                                                April 2001


      NETWORK_ERROR - This code indicates that an error in networking
      occured, other than a timeout.

      PARSE_ERROR - This code indicates that a parse error occured
      during input deserialization of a message or AVP.

      VERSION_ERROR - This code indicates that the version number on an
      incoming message does not correspond to a version number that this
      library handles.

      MESSAGE_ERR - This code indicates that the exception is an
      AAAMessageException subclass. The exact nature of the error is
      determined by the message object contained in the exception.

4.2.1.4 Instance Methods

      public short getCode()

   Return the exception error code.

4.2.2 Class AAAMessageException

4.2.2.1 Synopsis

      public class AAAMessageException extends AAAException

4.2.2.2 Description

   The AAAMessageException class is thrown from the
   AAASessionHandler.send() method when a Device-Status-Ind or Message-
   Reject-Ind message is received that is not handled internally by the
   library. The message object is contained in the exception.

4.2.2.3 Fields

   The following constants correspond to the Diameter Device-Status-Ind
   and Message-Reject-Ind command Result-Code or Failed-Command-Code AVP
   values and indicate the result status of a command. No constants are
   provided for those messages which the library is expected to handle
   internally.

      public static short DSI_UNSUPPORTED_TRANSFORM           = 4002
      public static short DSI_INVALID_RECORD_ROUTE            = 5001
      public static short DSI_COMMAND_UNSUPPORTED             = 5002
      public static short DSI_UNABLE_TO_DELIVER               = 5003
      public static short DSI_REALM_NOT_SERVED                = 5004
      public static short DSI_ERROR_TOO_BUSY                  = 5005




Kempf, Calhoun, Frascone expires September 2001                [Page 48]

INTERNET DRAFT                                                April 2001


      public static short MRI_SUCCESS                         = 2001
      public static short MRI_AUTHENTICATION_REJECTED         = 4001
      public static short MRI_NO_END_2_END_SECURITY           = 4002
      public static short MRI_OUT_OF_SPACE                    = 4003
      public static short MRI_USER_UNKNOWN                    = 5001
      public static short MRI_AVP_UNSUPPORTED                 = 5002
      public static short MRI_UNKNOWN_SESSION_ID              = 5003
      public static short MRI_AUTHORIZATION_REJECTED          = 5004
      public static short MRI_INVALID_AVP_VALUE               = 5005
      public static short MRI_MISSING_AVP                     = 5006
      public static short MRI_INVALID_CMS_DATA                = 5007
      public static short MRI_LOOP_DETECTED                   = 5008
      public static short MRI_AUTHORIZATION_FAILED            = 5009
      public static short MRI_CONTRADICTING_AVPS              = 5010
      public static short MRI_AVP_NOT_ALLOWED                 = 5011
      public static short MRI_AVP_OCCURS_TOO_MANY_TIMES       = 5012

   More information on these command codes and recommended client
   application code responses can be found in Section 10 of [1].

4.2.2.4 Instance Methods

      AAAMessage getMessage()

   Return the AAAMessage object containing the status message.

4.3 Library Management and Dictionary Management

The Java API provides a set of reflective classes that model Diameter
extensions, commands, and AVP descriptions. These classes are used by
the API itself to perform checking, and they are available to the
clients that want to do additional checking or discover what commands
and extensions are available. The reflective class objects are available
through the AAACommandDictionary.

4.3.1 Class AAA

4.3.1.1 Synopsis

      abstract public class AAA extends java.lang.Object

4.3.1.2 Description

   The AAA class provides useful constants for the Diameter Java API.

4.3.1.3 Fields

      public static final int NO_SESSION_CODE = 0



Kempf, Calhoun, Frascone expires September 2001                [Page 49]

INTERNET DRAFT                                                April 2001


   A constant which will never be returned as a session code.

      public static final long NO_VENDOR_CODE = 0

   A constant which will never be returned as a vendor code.

      public static final long NO_COMMAND_CODE = 0

   A constant which will never be used as a command code code.

      public static final long NO_EXTENSION_CODE = 0

   A constant which will never be used as an extension code

      public static final long NO_AVP_CODE = 0

   A constant which will never be used as an AVP code.

4.3.2 Class AAACommandDictionary

4.3.2.1 Synopsis

      public class AAACommandDictionary extends java.lang.Object

4.3.2.2 Description

   The AAACommandDictionary class provides a complete reference for a
   collection of Diameter commands defined either through a command
   dictionary file or programmatically.  The AAACommandDescriptors
   contained in the dictionary describe their AVPs and the extension of
   which they are part. The dictionary is used by the API library to
   guide command parsing, and can be used by server extension code and
   client library code to construct return commands.

4.3.2.3 Class Methods

      public static AAACommandDictionary
        getAAACommandDictionary(String commandDictionaryFile)
        throws AAAException

   Return an command dictionary, using the given file name to intialize
   the dictionary. If the parameter is null or the empty string, use the
   default dictionary file name from
   org.ietf.aaa.defaultCommandDictionaryFile.  If the dictionary doesn't
   exist yet, create it.

   Parameters:




Kempf, Calhoun, Frascone expires September 2001                [Page 50]

INTERNET DRAFT                                                April 2001


      commandDictionaryFile - Name of the command dictionary file for
      the dictionary. Use null or the empty string for the global
      dictionary file.

   Returns the dictionary object.

   Exceptions are:

      AAAException - Thrown with code INIT_FAILURE if an
      exception occured parsing the file or the dictionary
      could not otherwise be initialized.

4.3.2.4 Instance Methods

      public AVPDescriptor findCommand(java.lang.String name)

   Return an AAACommandDescriptor for the command matching the name, or
   null if none.

   Parameters:

      name - The name of the command to match.

   The return value is the AAACommandDescriptor matching the name, or
   null if none.

      public AAACommandDescriptor findCommand(long code)

   Return an AAACommandDescriptor for the command matching the code, or
   null if none.

   Parameters:

      code - The code of the command to match.

   The return value is the AAACommandDescriptor matching the code, or
   null if none.

4.3.3 Class AVPDescriptor

4.3.3.1 Synopsis

      public class AVPDescriptor extends java.lang.Object

4.3.3.2 Description

   An AVPDescriptor object contains a description of an AVP.




Kempf, Calhoun, Frascone expires September 2001                [Page 51]

INTERNET DRAFT                                                April 2001


4.3.3.3 Fields

      public long code

   The AVP's code.

      public long vendorCode

   The AVP vendor's code. If global, then NO_VENDOR_CODE.

      public java.lang.String name

   The AVP's name.

      public java.lang.String vendorName

   The AVP's vendor name, If global, then the empty string ("").

      public java.lang.String type

   The name of the Java class for the AVP's type. This will be one of:

      "B[" - a byte array, corresponds to the Diameter OctetString type.

      "java.net.InetAddress" - An IP address, corresponds to the
      Diameter Address type.

      "java.lang.Integer" - A signed integer, corresponds to the
      Diameter Integer32 type.

      "java.lang.Long" - A signed long, corresponds to the Diameter
      Integer64 type.

      "org.ietf.aaa.UnsignedInteger" - An unsigned integer, corresponds
      to the Diameter Unsigned32 type.

      "org.ietf.aaa.UnsignedLong" - An unsigned long, corresponds to the
      Diameter Unsigned64 type.

      "java.lang.Float" - A floating point number, correspnds to the
      Diameter Float32 type.

      "java.lang.Double" - A double precision floating point number,
      corresponds to the Diameter Float64 type.

      "org.ietf.aaa.Quad" - A quadruple precision floating point number,
      corresponds to the Diameter Float128 type.




Kempf, Calhoun, Frascone expires September 2001                [Page 52]

INTERNET DRAFT                                                April 2001


      "java.util.Map" - The AVP is of Diameter type Grouped. The Map
      object contains a map of the contained AVPs with the AVP name as
      the key and the AVP as the value. If any of the contained AVPs are
      of type Grouped, the value is another Map object.

4.3.3.4 Constructor

      public AVPDescriptor(long code,
                           long vendorCode,
                           java.lang.String name,
                           java.lang.String vendorName,
                           java.lang.String type,
                           boolean isMandatory,
                           boolean isEndToEndEncrypted)

   Create an AVPDescriptor object with the given fields.

   Parameters are:

      code - The AVP's code.

      vendorCode - The AVP's vendor code.

      name - The AVP's name.

      vendorName - The AVP's vendor name.

      type - The AVP's type.

      isMandatory - True if the AVP is mandatory for the command.

      isEndToEndEncrypted - True if the AVP is end-to-end encrypted for
      the command.

4.3.3.5 Instance Methods

      public boolean isMandatory()

   Return true if this AVP is mandatory.

      public boolean isEndToEndEncrypted()

   Return true if this AVP is encrypted end-to-end.

      public java.lang.String toString()

   Return a nicely formatted string describing the object.




Kempf, Calhoun, Frascone expires September 2001                [Page 53]

INTERNET DRAFT                                                April 2001


4.3.4 Class AAACommandDescriptor

4.3.4.1 Synopsis

      public class AAACommandDescriptor
        extends java.lang.Object

4.3.4.2 Definition

   The AAACommandDescriptor class describes a Diameter command in an
   application profile extension. The AAACommandDescriptor maintains the
   singleton pattern. There is only one command descriptor object per
   registered command, and command descriptor objects can only be
   programmatically created through the AAAExtensionDescriptor object.

4.3.4.3 Fields

   The following fields indicate the kind of command, and correspond to
   flag settings described in Section 3.0 of [1]:

      static public byte INDICATION = 0
      static public byte REQUEST    = 1
      static public byte ANSWER     = 2
      static public byte QUERY      = 3
      static public byte REPLY      = 4

4.3.4.4 Instance Methods

      public String getName()

   Return the command's name.

      public long getCode()

   Return the command's code.

      public String getVendorName()

   Return the command's vendor name, or the empty string, "", if the
   command is global.

      public long getVendorCode()

   Return the command's vendor code, or NO_VENDOR_CODE if the command is
   global.

      public AAAExtensionDescriptor getExtension()




Kempf, Calhoun, Frascone expires September 2001                [Page 54]

INTERNET DRAFT                                                April 2001


   Return the extension descriptor with which the command is registered.

      public java.util.Map getAVPDictionary()

   Return a dictionary with String AVP names as keys and AVPDescriptor
   objects as values for AVPs in the command. If any of the AVPs is
   Grouped, then the value is a Map containing the descriptors for the
   AVPs in the Grouped.

      public java.util.Map getDisallowedAVPDictionary()

   Return a dictionary with String AVP names as keys and AVPDescriptor
   objects as values for disallowed AVPs in the command. If any of the AVPs is
   Grouped, then the value is a Map containing the descriptors for the AVPs
   in the Grouped.

      public java.lang.String toString()

   Return a nicely formatted string describing the object.

4.3.5 AAAExtensionDescriptor

4.3.5.1 Synopsis

      public class AAAExtensionDescriptor extends java.lang.Object

4.3.5.2 Description

   The AAAExtensionDescriptor class provides a model for an AAA
   application profile extension. AAAExtensionDescriptor maintains a
   singleton pattern, so there is only one instance of each
   AAAExtensionDescriptor object defined per virtual  machine.
   AAAExtensionDescriptor manages AAACommandDescriptor objects
   describing the messages that make up the extension.

4.3.5.3 Class Methods

      public static AAAExtensionDescriptor getExtension(java.lang.String name)

   Return the extension descriptor corresponding to the name, or null if
   none.

   Parameters are:

      name - The name of the extension to return.

      public static java.util.Iterator getRegisteredExtensions()




Kempf, Calhoun, Frascone expires September 2001                [Page 55]

INTERNET DRAFT                                                April 2001


   Return an iterator containing all the registered extension
   descriptors.

      public static
        AAAExtensionDescriptor registerExtension(long code,
                                                 long vendorCode,
                                                 java.lang.String name,
                                                 java.lang.String vendorName)

   Return an extension descriptor matching the parameters. The object is
   created if it does not yet exist.

   The parameters are:

      code - The Diameter extension code.

      vendorCode -The vendor code.

      name - The extension name.

      vendorName - Name of the vendor for this extension, or empty
      string if global.

4.3.6.4 Instance Methods

      public long getCode()

   Return the extension code for this extension.

      public long getVendorCode()

   Return the vendor code for this extension.

      public java.lang.String getName()

   Return the extension name.

      public java.lang.String getVendorName()

   Return the vendor name for this extension, or the empty string if the
   extension is global.

      public AAACommandDescriptor
        registerCommand(long code,
                        long vendorCode,
                        java.lang.String name,
                        java.util.Map AVPDictionary,
                        java.util.Map disallowedAVPDictionary)



Kempf, Calhoun, Frascone expires September 2001                [Page 56]

INTERNET DRAFT                                                April 2001


   Register the command with name and code, and having the AVP
   dictionary and disallowed AVP names, as belonging to this extension.
   Returns the AAACommandDescriptor object describing the command. If
   the command has already been registered, the existing object is
   returned. If not, the object is created. If there is an existing
   object, both the AVP dictionary and the disallowed AVP dictionary are
   checked and a new descriptor object is created if the parameters
   differ from the existing object.

   The parameter is:

      code - The  command code.

      vendorCode - The vendor code.

      name - String with the command's name.

      AVPDictonary - A Map of AVP name Strings to AVPDescriptor objects
      for required and allowed AVPs. Grouped AVPs are represented by
      Maps.  The dictionary has the AVP name as the key and the
      AVPDescriptor or Map as the value.

      disallowedAVPDictionary - A Map containing disallowed
      AVPDescriptor objects for disallowed AVPs.  Grouped AVPs are
      represented by Maps.  The dictionary has the AVP name as the key
      and the AVPDescriptor or Map as the value.

   The return value is the registered command object.

      public void deregisterCommand(java.lang.String name)

   Deregister the command object having the given name.  If no command
   having the given name is registered,
   java.lang.IllegalArgumentException is thrown.

   The parameter is:

      name - Name of the command to deregister

      Exceptions thrown:

      java.lang.IllegalArgumentException - Thrown if the name is not
      registered.

      public AAACommandDescriptor getCommand(java.lang.String name)

   Get the command descriptor object corresponding to the name. If no
   such command is registered, return null.



Kempf, Calhoun, Frascone expires September 2001                [Page 57]

INTERNET DRAFT                                                April 2001


   The parameter is:

      name - Name of the command.

   The return value is the command object, or null if none.

      public java.util.Iterator getRegisteredCommandNames()

   Return an iterator of names for registered commands. If no commands
   are registered, then return an empty Iterator.

      public java.lang.String toString()

   Return a nicely formatted description of the extension descriptor.

4.3.7 UnsignedInteger

4.3.7.1 Synopsis

      public UnsignedInteger extends java.lang.Number

4.3.7.2 Description

   UnsignedInteger represents a Diameter Unsigned32 type.  Since Java
   integers are signed, this class is necessary to distinguish the
   Unsigned32 from Integer32 Diameter types. The interface is exactly
   the same as the java.lang.Integer class, and most of the methods are
   simply passthroughs to an object of that class.  Note that it is
   possible to get the actual unsigned value by using the
   UnsignedInteger.getLong() method.

4.3.8 UnsignedLong

4.3.8.1 Synopsis

      public UnsignedLong extends java.lang.Number

4.3.8.2 Description

   UnsignedLong represents a Diameter Unsigned64 type.  Since Java longs
   are signed, this class is necessary to distinguish the Unsigned64
   from Integer64 Diameter types. The interface is exactly the same as
   the java.lang.Long class, and most of the methods are simply
   passthroughs to an object of that class.  Note that it is not
   possible to get an unsigned value because Java does not support
   integers any longer than 64 bits.

4.3.9 Quad



Kempf, Calhoun, Frascone expires September 2001                [Page 58]

INTERNET DRAFT                                                April 2001


4.3.9.1 Synopsis

      public Quad extends java.lang.Number

4.3.9.2 Description

   Quad represents a Diameter Float128 type.  This class is simply a
   passthrough to java.lang.Double, and is just used to indicate the
   Diameter type.  Since Java does not support 128 bit precision
   floating point, the Diameter command parser will indicate an error if
   a Float128 type is received that is longer that 64 bits.

4.3 Messages and AVPs

4.3.1 Class AAAMessage

4.3.1.1 Synopsis

      public class AAAMessage
        extends java.lang.Object implements java.io.Externalizable

4.3.1.2 Definition

   The AAAMessage object represents an incoming or outgoing message. An
   instance of an AAAMessage consists of a map with AVP names as keys
   and AVP objects as values. Accessors are also available for other
   information, including the AAACommandDescriptor that describes the
   message. The API library uses the java.io.Externalizable interface
   methods Externalizable.writeExternal() and
   Externalizable.readExternal() internally to serialize and deserialize
   the message in the proper Diameter format.

4.3.1.3 Constructor

      public AAAMessage(AAACommandDescriptor descriptor)

   Create an AAAMessage object. The message has an empty AVP map and the
   hop-by-hop and end-to-end identifiers are initialized to sequentially
   generated random values.

   Parameters are:

      descriptor - The AAACommandDescriptor object giving the message's
      command type.

4.3.1.4 Instance Methods

      public int getLength()



Kempf, Calhoun, Frascone expires September 2001                [Page 59]

INTERNET DRAFT                                                April 2001


   Return the message length.

      public int getHopByHopIdentifier()

   Return the message's hop-by-hop identifier.

      public int getEndToEndIdentifier()

   Return the message's end-to-end identifier.

      public String getDescriptor()

   Return the message's command descriptor.

      public java.util.Map getAVPMap()

   Return a Map of AVP objects for the message. Keys are the AVP String
   names, values are AVP objects.

      public java.lang.String toString()

   Return a nicely formatted string describing the object.

4.3.2 Class AVP

4.3.2.1 Synopsis

      public class AVP
        extends java.lang.Object implements java.io.Externalizable

4.3.2.2 Description

   The AVP class models a Diameter AVP (attribute/value pair) object. An
   AVP may be created with data having one of the types described in
   Section 4.3.3.

4.3.2.3 Constructor

      public AVP(AVPDescriptor descriptor,
                 java.lang.Object data)

   Create a new AVP object.


   Parameters are:

      descriptor - An AVPDescriptor object describing the AVP.




Kempf, Calhoun, Frascone expires September 2001                [Page 60]

INTERNET DRAFT                                                April 2001


      data - The AVP's data. If the type of data does not match the type
             of the AVP, java.lang.IllegalArgumentException is thrown.

   Exceptions thrown:

      java.lang.IllegalArgumentException - Thrown if either parameter is
      null, or if the data type does not match the descriptor's AVP
      type.

4.3.2.4 Instance Methods

      public AVPDescriptor getDescriptor()

   Return the AVP's descriptor.

      public java.lang.Object getData()

   Return the AVP data as the appropriate Java object.

      java.lang.String toString()

   Return a nicely formatted string describing the object.

4.4 Session Management

4.4.1 Class AAASessionManager

4.4.1.1 Synopsis

      abstract public class AAASessionManager extends java.lang.Object

4.4.1.2 Description

   The AAASessionManager class is the abstract superclass for client and
   server side session managers. It contains basic methods common to
   client and server side for managing sessions.

   An AAAMessage object is sent to the Diameter server using the
   AAASessionManager.send() method. The AAASessionManager.send() method
   is synchronous, and returns the reply message from the server, or an
   AAAException is thrown if the server does not reply within the
   session timeout. The AAASessionManager.notify() method is used to
   asynchronously send a message to the Diameter server, or to a client.
   It is primarily of interest to server side Diameter extensions.

4.4.1.3 Instance Methods

      public int



Kempf, Calhoun, Frascone expires September 2001                [Page 61]

INTERNET DRAFT                                                April 2001


        startSession(InetAddress host,AAACommandDictionary dictionary)

   Open a new AAA session. The session is established with the indicated
   host, and the command dictionary is used to drive command parsing and
   checking.  This method performs the necessary Diameter messaging for
   the state machine described in Section 8.0 of [1] in order to bring
   up a Diameter connection, in addition to standard network sockets
   bring up.

   Parameters:

      host - The host with which the session should be established.

      dictionary - The command dictionary to use when parsing and
      checking commands.

   Return value is the session code. If a session can't be opened,
   returns NO_SESSION_CODE.

   Exceptions thrown:

      java.lang.IllegalArgumentException - Thrown if the host already
      has a session already open or the parameter is null.

      public InetAddress findServerAddress(String NAI)

   Find the Diameter server address corresponding to the NAI.

   Parameters:

      NAI - The Network Access Identifier [6]

   Return value is the InetAddress object for the NAI realm's Diameter
   server, or null if no Diameter server is available.

   Exceptions thrown:

      AAAException - Thrown with the error code NETWORK_ERROR if an
      exception occurs during resolution of the Diameter server's name.

      public void endSession(int sessionCode)

   Close the indicated session. This message performs the necessary
   Diameter messaging according to the state machine in Section 8.0 of
   [1] to terminate the session, in addition to standard network sockets
   teardown.

   Parameters:



Kempf, Calhoun, Frascone expires September 2001                [Page 62]

INTERNET DRAFT                                                April 2001


      sessionId - The session code of the session to close.

   Exceptions thrown:

      java.lang.IllegalArgumentException - Thrown if sessionCode does
      not indicate a valid, open session.

      public int getSessionCode(InetAddress host)

   Return the session code corresponding to the host. If no session is
   currently active with the host, return NO_SESSION_CODE.

   Parameters:

      host - The host for which the session code is sought.

   Return value is the session code, or NO_SESSION_CODE if none.

      public String getNetworkSessionId(int sessionCode)

   Return the network session identifier (see Section 11.2 of [1])
   corresonding to the session code.

   Parameters are:

      sessionCode - The session code.

   Return value is the network session identifier, as a String.

   Exceptions thrown:

      java.lang.IllegalArgumentException - Thrown if sessionCode is
      invalid.

      public AAACommandDictionary
      getSessionDictionary(int sessionCode)

   Return the command dictionary being used to parse
   commands for this session.

   Parameters are:

      sessionCode - The session code.

      public void setSessionTimeout(int sessionCode,int timeout)

   Set the timeout on a particular session. The timeout determines how
   long the session manager waits for a reply before giving up.  By



Kempf, Calhoun, Frascone expires September 2001                [Page 63]

INTERNET DRAFT                                                April 2001


   default, the value in org.ietf.aaa.maxWait is used for the session
   timeout.

   Parameters are:

      sessionCode - The session code.

      timeout - The new timeout, in milliseconds.

      public AAAMessage send(int sessionCode,AAAMessage message)
        throws AAAException, AAAMessageException

   Send the message to the server having the session identified by the
   session code, wait for the return message, and return it.

   Note that the AAASessionManager.send() method is required to handle
   the details of redirection. If the return message is a Device-
   Status-Ind command with the DIAMETER_REDIRECT_INDICATION [1] DSI-
   Event status code set, then the API library must perform the
   redirection transparently to the API client. The API library may also
   update the session description associated with the session id in
   order to avoid incurring the overhead of a redirection on future
   attempts involving the session.

   Parameters are:

      sessionCode - The session code.

      message - The message to send.

   The return value is the returned message.

   Exceptions thrown:

      AAAException - Thrown with one of the following error codes:
      FAILURE, SECURITY, MISSING_AVP, DISALLOWED_AVP, NETWORK_TIMEOUT
      NETWORK_ERROR, SESSION_INVALID, PARSE_ERROR, VERSION_ERROR.

      AAAMessageException - Thrown with the returned error command
      object.

      public void notify(int sessionCode,AAAMessage message)
        throws AAAException

   Send the message to the server having the session identified by the
   session code, but do not wait for a response. Asynchronous message
   sending is primarily of interest to servers, but may be used by
   clients as well.



Kempf, Calhoun, Frascone expires September 2001                [Page 64]

INTERNET DRAFT                                                April 2001


   Parameters are:

      sessionCode - The session code.

      message - The message to send.

   Exceptions thrown:

      AAAException - Thrown with one of the following error codes:
      FAILURE, SECURITY, MISSING_AVP, DISALLOWED_AVP, NETWORK_TIMEOUT
      NETWORK_ERROR, SESSION_INVALID, PARSE_ERROR, VERSION_ERROR.

4.4.2 Class AAAClientSessionManager

4.4.2.1 Synopsis

      public class AAAClientSessionManager extends AAASessionManager

4.4.2.2 Description

   The AAAClientSessionManager class provides session management
   services for the client side API. A client can either establish a
   session with a server discovered during service discovery or with a
   server whose NAI was discovered during execution. The API allows
   clients to specify that a server must support particular extensions.

   Client application code can register unsolicited message handlers to
   handle unsolicited messages and an exception handler to handle
   exceptions during receipt of unsolicited messages. If no message
   handler or exception handler is registered, the behavior is defined
   by the library implementation, but the implementation should not
   terminate the application. Examples of acceptable behaviors include
   printing a message to the standard output or to a log file.

4.4.2.3 Class Methods

      public static AAAClientSessionManager getClientSessionManager()

   Return the distinguished session manager object for the Diameter
   client API library. There will be only one session manager object per
   virtual machine.

      public static
      registerUnsolictedExceptionHandler(UnsolicitedExceptionHandler handler)

   Register a handler for exceptions that occur during input of unsolicited
   messages, for example, parse errors. This handler is global for all
   sessions and all client application code in this executing instance of the



Kempf, Calhoun, Frascone expires September 2001                [Page 65]

INTERNET DRAFT                                                April 2001


   Java virtual machine.

   Parameters are:

      handler - The handler.

4.4.2.4 Instance Methods

      public void
        registerUnsolicitedMessageListener(int sessionCode,
                                           AAAMessageListener listener)

   Register a listener for handling unsolicited messages associated with
   a particular session. If a listener already exists for this session,
   replace it. The value returned by the listener is ignored.

   Parameters are:

      sessionCode - The session code.

      listener - The listener.

      public InetAddress[]
      getConfiguredHosts(java.util.Iterator supportedExtensions)

   Return an array of InetAddress objects for configured AAA servers.
   If the supportedExtensions parameter is not null, only return servers
   supporting the indicated extensions are returned. If no servers match
   the extensions or are configured, return an empty array.

   Parameters are:

      supportedExtensions - Iterator with Strings containing names of
      extensions that the the server must support.  If null or empty,
      return all configured servers.

   Return value is an array of InetAddress objects for servers, or an
   empty array if no servers match the extensions or are configured at
   all.

4.4.3 Class AAAServerSessionManager

4.4.3.1 Synopsis

      public class AAAServerSessionManager extends AAASessionManager

4.4.3.2 Description




Kempf, Calhoun, Frascone expires September 2001                [Page 66]

INTERNET DRAFT                                                April 2001


   The AAAServerSessionManager provides session management services to
   the server API. There are no additional methods required besides the
   methods provided by the base class.

4.4.3.3 Class Methods

      public static AAAServerSessionManager getServerSessionManager()

   Return the distinguished session manager object for the Diameter
   server API library. There will be only one session manager object per
   virtual machine.


4.4.4 Interface UnsolicitedExceptionHandler

4.4.4.1 Synopsis

      public interface UnsolicitedExceptionHandler

4.4.4.2 Description

   Instances of classes that implement the UnsolicitedExceptionHandler
   interface handle exceptions that occur during processing of
   unsolicited messages.

4.4.4.3 Instance Methods

      public void processUnsolicitedException(AAAException exception);

   Handle an exception that occured during processing of an unsolicited
   message.

   Parameters are:

      exception - The exception.

4.4.5 Interface AAAMessageListener

4.4.5.1 Synopsis

      public interface AAAMessageListener

4.4.5.2 Description

   Instances of classes that implement the AAAMessageListener interface
   handle incoming messages.

4.4.5.3 Instance Methods



Kempf, Calhoun, Frascone expires September 2001                [Page 67]

INTERNET DRAFT                                                April 2001


      public AAAMessage processMessage(int sessionCode,
                                       AAAMessage message);

   Process a message for a particular session.

   Parameters are:

      sessionCode - The session code.

      message - The message.

4.5 Server API

   The Diameter server API provides a way for Diameter extensions to
   register listeners for Diameter commands. Implementations of server
   API classes need not be present unless the Java virtual machine
   supports server capability. In addition to the AAAServer class, the
   AAAServerSessionManager is also included in the server API.

4.5.1 Class AAAServer

4.5.1.1 Synopsis

      abstract public AAAServer extends AAA

4.5.1.2 Description

   The AAAServer class provides a means to extend the Diameter server by
   registering listener objects to handle commands. The class also
   provides methods to allow dynamic linking of command class handling
   code when a command is received.

   In addition, the AAAServer class maintains the proxy and redirect
   maps. When the AAAServer class is loaded, it initializes the proxy
   and redirect maps from the properties org.ietf.aaa.server.proxyMap
   and org.ietf.aaa.server.redirectMap. If a command comes from a client
   that requires proxying or redirecting, the AAAServer class takes care
   of sending the proper commands to the client or proxy to cause the
   redirect or proxying to happen.

4.5.1.3 Class Methods

      public static void initialize(java.util.Iterator commandPackages)

   Initialize the server, and register the Iterator containing Strings
   with the package names to use when looking for the command handling
   class code. These names are concatenated with the command names to
   form a class name that is used to dynamically link code for handling



Kempf, Calhoun, Frascone expires September 2001                [Page 68]

INTERNET DRAFT                                                April 2001


   the command.

   Parameters are:

      commandPackages - an Iterator of String package names used to form
      class names from command names when dynamically linking command
      code.

      public static void loadCommand(String commandName)
        throws AAAException

   Form the command class name by concatenating the command name with
   one of the command packages passed in on initialization of the
   server, then dynamically link the class. If the command class
   supports the AAAMessageListenerFactory interface and a no-argument
   constructor, use the Class.new() method to create an instance of the
   AAAMessageListenerFactory and obtain a message listener from the
   factory. Register the message listener for the command. If the
   command class does not support the AAAMessageListenerFactory
   interface, the message listener must be registered by the loading
   code.

   Note that dyanmic loading and automatic listener registration
   requires the command descriptor to be available from the command
   dictionary, otherwise, the mapping between the command code and
   command name cannot be performed.

   Parameters are:

      commandName - The String name of the command

   Exceptions thrown:

      AAAException - Thrown with FAILURE if the code couldn't be loaded.

      public void registerCommandListener(AAACommandDescriptor descriptor,
                                          AAAMessageListener listener)

   Register a message listener for the command. If an existing listener
   is registered, replace it. To unregister a listener for a command,
   use null for the listener.

   Parameters are:

      descriptor - The command descriptor for the command for which the
      listener is registered.

      listener - The listener to register.



Kempf, Calhoun, Frascone expires September 2001                [Page 69]

INTERNET DRAFT                                                April 2001


      public static Map getProxyMap()

   Return the proxy map. The proxy map has client InetAddress objects as
   keys and the server InetAddress objects to which the client messages
   should be proxied as values. The calling code can modify the proxy
   behavior by modifying the map. The proxy map is initialized from the
   org.ietf.aaa.server.proxyMap property.

      public static Map getRedirectMap()

   Return the redirect map. The redirect map has client InetAddress
   objects as keys and the server InetAddress objects to which the
   client messages should be redirected as values. The calling code can
   modify the redirect behavior by modifying the map. The redirect map
   is initialized from the org.ietf.aaa.server.redirectMap property.

4.5.2 Interface AAAMessageListenerFactory

4.5.2.1 Synopsis

      public interface AAAMessageListenerFactory

4.5.2.2 Description

   The AAAMessageListenerFactory interface is supported by command
   handling classes to allow automatic registration of their message
   listeners upon dynamic linking.  A command handling class must
   support both the AAAMessageListenerFactory interface and a no-
   argument constructor in order to allow automatic registration.

4.5.2.3 Instance Methods

      AAAMessageListener getMessageListener()

   Return a message listener to handle the command messages.

4.6 Implementation Considerations

4.6.1 Dynamic Linking of Command Handling Classes

   The server side API is designed so command handling classes can be
   dynamically linked when the command arrives rather than having to be
   preloaded (though they may be preloaded to speed response time). The
   following design rules must be followed when writing the command
   handling class:

      1) The class must be defined in the dictionary file used to create
      the command dictionary. The name of the class must correspond to



Kempf, Calhoun, Frascone expires September 2001                [Page 70]

INTERNET DRAFT                                                April 2001


      the name of the command as defined in the dictionary file, and the
      class' package must be one of the packages used to initialize the
      server. In the server, the command dictionary is created from the
      org.ietf.aaa.defaultCommandDictionaryFile property.

      2) The class must support a no-argument constructor so the command
      handler loading procedure can construct an instance of the class
      by calling the Class.newInstance() method.

      3) The class must support the AAAMessageListenerFactory interface,
      so the command handler loading procedure can call the
      AAAMessageListenerFactory.getMessageListener() on the command
      handler object created by calling the Class.newInstance() method.

   If the command handler class does not abide by these design rules, it
   is up to the command handler itself to create and register the
   command listener in link time (class static) code. Note, however,
   that if the command is not defined in the command dictionary, the
   command handling code cannot even be linked because no mapping
   between the command code and command name is possible.

4.6.2 State Machine Maintenance

   The Diameter spec specifies two state machines, a peer state machine
   (Section 8.0 of [1]) and a session state machine (Section 11.1 of
   [1]).

   On the client side, AAAClientSessionManager maintains both the peer
   state machine and the session state machine. The peer state machine
   is started when the first session is created. Although implementation
   techniques may vary, a minimum of one thread per server is expected
   to be required to maintain a blocking receive on a socket for the
   server. This allows the server to send unsolicited messages.

   On the server side, AAAServer maintains the peer state machine while
   AAAServerSessionManager maintains session state machine for specific
   sessions.

4.6.3 Server-side Access to Session Identifiers

   On the server, application profile message listeners can obtain
   session identifiers through the AAAServerSessionManager object. These
   can be used to, for example, send unsolicited messages to clients.
   Normal request/response callback processing should not require the
   message listeners to actually send any messages to the client,
   because the message returned as the value of the callback is returned
   to the client.




Kempf, Calhoun, Frascone expires September 2001                [Page 71]

INTERNET DRAFT                                                April 2001


4.6.4 Server Proxy and Redirect Implementation

   The properties org.ietf.aaa.server.proxyMap and
   org.ietf.aaa.server.redirectMap contain maps of client addresses to
   proxy or redirect servers that can be used to implement proxy or
   redirect functionality. The server code can also programmatically
   modify the proxy and redirect maps by getting the maps from the
   AAAServer and modifying the maps directly.  The maps contain a client
   address as key with the proxy or redirect address as the value, for
   convenient use when processing a client message.

   A wildcard proxy or redirect (i.e. a proxy or redirect for all
   clients) can be indicated in the properties by including a single
   address in the property. This causes proxies or redirects for all
   clients. A wildcard proxy or redirect is indicated in the maps by a
   single address bound to null as the value. An empty Map indicates
   that there are no proxies or redirects for this server.

5.0 Security Considerations

   This document describes an API and therefore depends on the security
   mechanisms defined in the Diameter protocol [1].

6.0 References


[1]  Calhoun, P., et. al., "The DIAMETER Base Protocol," draft-ietf-
     aaa-diameter-01.txt, a work in progress.

[2]  Crocker, D. and Overell, P., "Augmented BNF Syntax Specifications:
     ABNF", RFC 2234, November, 1997.

[3]  Calhoun, P., Bulley, W., and Farrell, S. "DIAMETER Strong Security
     Extension", draft-calhoun-diameter-strong-crypto-07.txt, a work in
     progress.

[4]  Guttman, E., Perkins, C., Veizades, J., and Day, M., "Service Loca-
     tion Protocol, Version 2," RFC 2608, June, 1999.

[5]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for specifying
     the location of services (DNS SRV)", RFC 2782, February 2000.

[6]  Aboba, Beadles "The Network Access Identifier." RFC 2486. January
     1999.

[7]  http://www.diameter.org/diameter.xml

[8]  http://www.javasoft.com/xml/jaxp-docs-1.1/readme.html



Kempf, Calhoun, Frascone expires September 2001                [Page 72]

INTERNET DRAFT                                                April 2001


[9]  Hinden, R., Carpenter, B., "Format for Literal IPv6 Addresses in
     URL's", RFC 2732, December, 1999.

7.0  Authors' Addresses

   Questions about this memo can be directed to:

      James Kempf
      Sun Labs California
      Sun Microsystems, Inc.
      901 San Antonio Rd., UMPK15-214
      Palo Alto, CA, 94303
      USA

       Phone: +1 650 786 5890
         Fax: +1 650 786 6445
      E-Mail: james.kempf@sun.com

      Pat Calhoun
      Sun Labs California
      Sun Microsystems, Inc.
      901 San Antonio Rd., UMPK15-214
      Palo Alto, CA, 94303
      USA

       Phone: +1 650 786 7733
         Fax: +1 650 786 6445
      E-Mail: pat.calhoun@sun.com

      David Frascone
      Sun Labs California
      1600 North Dallas Parkway, Suite 700
      Dallas, TX 75248

      Phone: +1 972 386 1283
      E-Mail: codemonkey@sun.com


8.0  Full Copyright Statement

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

   This document and translations of it may be copied  and  furnished
   to others,  and  derivative works that comment on or otherwise
   explain it or assist in its implementation may be prepared, copied,
   published and distributed,  in  whole  or  in part, without restric-
   tion of any kind, provided that the  above  copyright  notice  and
   this  paragraph  are included on all such copies and derivative



Kempf, Calhoun, Frascone expires September 2001                [Page 73]

INTERNET DRAFT                                                April 2001


   works.  However, this docu- ment itself may not be modified in any
   way, such as  by  removing  the copyright notice or references to the
   Internet Society or other Inter- net organizations, except as needed
   for  the  purpose  of  developing Internet standards in which case
   the procedures for copyrights defined in the Internet Standards pro-
   cess must be followed, or as required  to translate it into languages
   other than   English.  The limited permis- sions granted above are
   perpetual and  will  not  be  revoked  by  the Internet  Society or
   its successors or assigns.  This document and the information con-
   tained herein is provided on an "AS IS" basis  and  THE INTERNET
   SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRAN-
   TIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY  WAR-
   RANTY  THAT  THE  USE  OF THE INFORMATION HEREIN WILL NOT INFRINGE
   ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
   FOR  A PARTICULAR PURPOSE."




































Kempf, Calhoun, Frascone expires September 2001                [Page 74]

