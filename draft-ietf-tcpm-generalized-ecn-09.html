<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>ECN++: Adding Explicit Congestion Notification (ECN) to TCP Control Packets</title>
<meta content="Marcelo Bagnulo" name="author">
<meta content="Bob Briscoe" name="author">
<meta content="
       This document describes an experimental modification to ECN when used
      with TCP. It allows the use of ECN on the following TCP packets: SYNs,
      pure ACKs, Window probes, FINs, RSTs and retransmissions. 
    " name="description">
<meta content="xml2rfc 3.12.0" name="generator">
<meta content="draft-ietf-tcpm-generalized-ecn-09" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.12.0
    Python 3.6.12
    appdirs 1.4.4
    ConfigArgParse 1.5.3
    google-i18n-address 2.5.0
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 2.11.3
    kitchen 1.2.6
    lxml 4.7.1
    pycountry 22.1.10
    pyflakes 2.4.0
    PyYAML 6.0
    requests 2.27.1
    setuptools 59.6.0
    six 1.16.0
    WeasyPrint 52.5
-->
<link href="/tmp/draft-ietf-tcpm-generalized-ecn-09-kbla70ia.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<script type="application/javascript">async function addMetadata(){try{const e=document.styleSheets[0].cssRules;for(let t=0;t<e.length;t++)if(/#identifiers/.exec(e[t].selectorText)){const a=e[t].cssText.replace("#identifiers","#external-updates");document.styleSheets[0].insertRule(a,document.styleSheets[0].cssRules.length)}}catch(e){console.log(e)}const e=document.getElementById("external-metadata");if(e)try{var t,a="",o=function(e){const t=document.getElementsByTagName("meta");for(let a=0;a<t.length;a++)if(t[a].getAttribute("name")===e)return t[a].getAttribute("content");return""}("rfc.number");if(o){t="https://www.rfc-editor.org/rfc/rfc"+o+".json";try{const e=await fetch(t);a=await e.json()}catch(e){t=document.URL.indexOf("html")>=0?document.URL.replace(/html$/,"json"):document.URL+".json";const o=await fetch(t);a=await o.json()}}if(!a)return;e.style.display="block";const s="",d="https://datatracker.ietf.org/doc",n="https://datatracker.ietf.org/ipr/search",c="https://www.rfc-editor.org/info",l=a.doc_id.toLowerCase(),i=a.doc_id.slice(0,3).toLowerCase(),f=a.doc_id.slice(3).replace(/^0+/,""),u={status:"Status",obsoletes:"Obsoletes",obsoleted_by:"Obsoleted By",updates:"Updates",updated_by:"Updated By",see_also:"See Also",errata_url:"Errata"};let h="<dl style='overflow:hidden' id='external-updates'>";["status","obsoletes","obsoleted_by","updates","updated_by","see_also","errata_url"].forEach(e=>{if("status"==e){a[e]=a[e].toLowerCase();var t=a[e].split(" "),o=t.length,w="",p=1;for(let e=0;e<o;e++)p<o?w=w+r(t[e])+" ":w+=r(t[e]),p++;a[e]=w}else if("obsoletes"==e||"obsoleted_by"==e||"updates"==e||"updated_by"==e){var g,m="",b=1;g=a[e].length;for(let t=0;t<g;t++)a[e][t]&&(a[e][t]=String(a[e][t]).toLowerCase(),m=b<g?m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>, ":m+"<a href='"+s+"/rfc/".concat(a[e][t])+"'>"+a[e][t].slice(3)+"</a>",b++);a[e]=m}else if("see_also"==e){var y,L="",C=1;y=a[e].length;for(let t=0;t<y;t++)if(a[e][t]){a[e][t]=String(a[e][t]);var _=a[e][t].slice(0,3),v=a[e][t].slice(3).replace(/^0+/,"");L=C<y?"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>, ":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>, ":"RFC"!=_?L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+_+" "+v+"</a>":L+"<a href='"+s+"/info/"+_.toLowerCase().concat(v.toLowerCase())+"'>"+v+"</a>",C++}a[e]=L}else if("errata_url"==e){var R="";R=a[e]?R+"<a href='"+a[e]+"'>Errata exist</a> | <a href='"+d+"/"+l+"'>Datatracker</a>| <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>":"<a href='"+d+"/"+l+"'>Datatracker</a> | <a href='"+n+"/?"+i+"="+f+"&submit="+i+"'>IPR</a> | <a href='"+c+"/"+l+"'>Info page</a>",a[e]=R}""!=a[e]?"Errata"==u[e]?h+=`<dt>More info:</dt><dd>${a[e]}</dd>`:h+=`<dt>${u[e]}:</dt><dd>${a[e]}</dd>`:"Errata"==u[e]&&(h+=`<dt>More info:</dt><dd>${a[e]}</dd>`)}),h+="</dl>",e.innerHTML=h}catch(e){console.log(e)}else console.log("Could not locate metadata <div> element");function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}}window.removeEventListener("load",addMetadata),window.addEventListener("load",addMetadata);</script>
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">ECN++</td>
<td class="right">January 2022</td>
</tr></thead>
<tfoot><tr>
<td class="left">Bagnulo &amp; Briscoe</td>
<td class="center">Expires 4 August 2022</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Network Working Group</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-tcpm-generalized-ecn-09</dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a href="https://www.rfc-editor.org/rfc/rfc5562" class="eref">5562</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2022-01-31" class="published">31 January 2022</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Experimental</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2022-08-04">4 August 2022</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">M. Bagnulo</div>
<div class="org">UC3M</div>
</div>
<div class="author">
      <div class="author-name">B. Briscoe</div>
<div class="org">Independent</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">ECN++: Adding Explicit Congestion Notification (ECN) to TCP Control Packets</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes an experimental modification to ECN when used
      with TCP. It allows the use of ECN on the following TCP packets: SYNs,
      pure ACKs, Window probes, FINs, RSTs and retransmissions.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 4 August 2022.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-3">
            This document may contain material from IETF Documents or IETF
            Contributions published or made publicly available before November
            10, 2008. The person(s) controlling the copyright in some of this
            material may not have granted the IETF Trust the right to allow
            modifications of such material outside the IETF Standards Process.
            Without obtaining an adequate license from the person(s)
            controlling the copyright in such materials, this document may not
            be modified outside the IETF Standards Process, and derivative
            works of it may not be created outside the IETF Standards Process,
            except to format it for publication as an RFC or to translate it
            into languages other than English.<a href="#section-boilerplate.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.  <a href="#name-motivation" class="xref">Motivation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="xref">1.2</a>.  <a href="#name-experiment-goals" class="xref">Experiment Goals</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="xref">1.3</a>.  <a href="#name-document-structure" class="xref">Document Structure</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-terminology" class="xref">Terminology</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-specification" class="xref">Specification</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-network-eg-firewall-behavio" class="xref">Network (e.g. Firewall) Behaviour</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-sender-behaviour" class="xref">Sender Behaviour</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.1">
                    <p id="section-toc.1-1.3.2.2.2.1.1"><a href="#section-3.2.1" class="xref">3.2.1</a>.  <a href="#name-syn-send" class="xref">SYN (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2">
                    <p id="section-toc.1-1.3.2.2.2.2.1"><a href="#section-3.2.2" class="xref">3.2.2</a>.  <a href="#name-syn-ack-send" class="xref">SYN-ACK (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.3">
                    <p id="section-toc.1-1.3.2.2.2.3.1"><a href="#section-3.2.3" class="xref">3.2.3</a>.  <a href="#name-pure-ack-send" class="xref">Pure ACK (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.4">
                    <p id="section-toc.1-1.3.2.2.2.4.1"><a href="#section-3.2.4" class="xref">3.2.4</a>.  <a href="#name-window-probe-send" class="xref">Window Probe (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.5">
                    <p id="section-toc.1-1.3.2.2.2.5.1"><a href="#section-3.2.5" class="xref">3.2.5</a>.  <a href="#name-fin-send" class="xref">FIN (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.6">
                    <p id="section-toc.1-1.3.2.2.2.6.1"><a href="#section-3.2.6" class="xref">3.2.6</a>.  <a href="#name-rst-send" class="xref">RST (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.7">
                    <p id="section-toc.1-1.3.2.2.2.7.1"><a href="#section-3.2.7" class="xref">3.2.7</a>.  <a href="#name-retransmissions-send" class="xref">Retransmissions (Send)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.8">
                    <p id="section-toc.1-1.3.2.2.2.8.1"><a href="#section-3.2.8" class="xref">3.2.8</a>.  <a href="#name-general-fall-back-for-any-c" class="xref">General Fall-back for any Control Packet or Retransmission</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.  <a href="#name-receiver-behaviour" class="xref">Receiver Behaviour</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.1">
                    <p id="section-toc.1-1.3.2.3.2.1.1"><a href="#section-3.3.1" class="xref">3.3.1</a>.  <a href="#name-receiver-behaviour-for-any-" class="xref">Receiver Behaviour for Any TCP Control Packet or Retransmission</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.2">
                    <p id="section-toc.1-1.3.2.3.2.2.1"><a href="#section-3.3.2" class="xref">3.3.2</a>.  <a href="#name-syn-receive" class="xref">SYN (Receive)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.3">
                    <p id="section-toc.1-1.3.2.3.2.3.1"><a href="#section-3.3.3" class="xref">3.3.3</a>.  <a href="#name-pure-ack-receive" class="xref">Pure ACK (Receive)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.4">
                    <p id="section-toc.1-1.3.2.3.2.4.1"><a href="#section-3.3.4" class="xref">3.3.4</a>.  <a href="#name-fin-receive" class="xref">FIN (Receive)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.5">
                    <p id="section-toc.1-1.3.2.3.2.5.1"><a href="#section-3.3.5" class="xref">3.3.5</a>.  <a href="#name-rst-receive" class="xref">RST (Receive)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.6">
                    <p id="section-toc.1-1.3.2.3.2.6.1"><a href="#section-3.3.6" class="xref">3.3.6</a>.  <a href="#name-retransmissions-receive" class="xref">Retransmissions (Receive)</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-rationale" class="xref">Rationale</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-the-reliability-argument" class="xref">The Reliability Argument</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-syns" class="xref">SYNs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="xref">4.2.1</a>.  <a href="#name-argument-1a-unrecognized-ce" class="xref">Argument 1a: Unrecognized CE on the SYN</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="xref">4.2.2</a>.  <a href="#name-argument-1b-ect-considered-" class="xref">Argument 1b: ECT Considered Invalid on the SYN</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.3">
                    <p id="section-toc.1-1.4.2.2.2.3.1"><a href="#section-4.2.3" class="xref">4.2.3</a>.  <a href="#name-caching-strategies-for-ect-" class="xref">Caching Strategies for ECT on SYNs</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.4">
                    <p id="section-toc.1-1.4.2.2.2.4.1"><a href="#section-4.2.4" class="xref">4.2.4</a>.  <a href="#name-argument-2-dos-attacks" class="xref">Argument 2: DoS Attacks</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-syn-acks" class="xref">SYN-ACKs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="xref">4.3.1</a>.  <a href="#name-possibility-of-unrecognized" class="xref">Possibility of Unrecognized CE on the SYN-ACK</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.2">
                    <p id="section-toc.1-1.4.2.3.2.2.1"><a href="#section-4.3.2" class="xref">4.3.2</a>.  <a href="#name-response-to-congestion-on-a" class="xref">Response to Congestion on a SYN-ACK</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.3">
                    <p id="section-toc.1-1.4.2.3.2.3.1"><a href="#section-4.3.3" class="xref">4.3.3</a>.  <a href="#name-fall-back-if-ect-syn-ack-fa" class="xref">Fall-Back if ECT SYN-ACK Fails</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-pure-acks" class="xref">Pure ACKs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="xref">4.4.1</a>.  <a href="#name-mechanisms-to-respond-to-ce" class="xref">Mechanisms to Respond to CE-Marked Pure ACKs</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.2">
                    <p id="section-toc.1-1.4.2.4.2.2.1"><a href="#section-4.4.2" class="xref">4.4.2</a>.  <a href="#name-summary-enabling-ecn-on-pur" class="xref">Summary: Enabling ECN on Pure ACKs</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-window-probes" class="xref">Window Probes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="xref">4.6</a>.  <a href="#name-fins" class="xref">FINs</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.7">
                <p id="section-toc.1-1.4.2.7.1"><a href="#section-4.7" class="xref">4.7</a>.  <a href="#name-rsts" class="xref">RSTs</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.8">
                <p id="section-toc.1-1.4.2.8.1"><a href="#section-4.8" class="xref">4.8</a>.  <a href="#name-retransmitted-packets" class="xref">Retransmitted Packets.</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.9">
                <p id="section-toc.1-1.4.2.9.1"><a href="#section-4.9" class="xref">4.9</a>.  <a href="#name-general-fall-back-for-any-co" class="xref">General Fall-back for any Control Packet</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-interaction-with-popular-va" class="xref">Interaction with popular variants or derivatives of TCP</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-iw10" class="xref">IW10</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-tfo" class="xref">TFO</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-l4s" class="xref">L4S</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.  <a href="#name-other-transport-protocols" class="xref">Other transport protocols</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-iana-considerations" class="xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-acknowledgments" class="xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-references" class="xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="xref">9.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#appendix-A" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">RFC 3168 <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> specifies support of Explicit
      Congestion Notification (ECN) in IP (v4 and v6). By using the ECN
      capability, network elements (e.g. routers, switches) performing
      Active Queue Management (AQM) can use ECN marks instead of packet drops
      to signal congestion to the endpoints of a communication. This results
      in lower packet loss and increased performance. RFC 3168 also specifies
      support for ECN in TCP, but solely on data packets. For various reasons
      it precludes the use of ECN on TCP control packets (TCP SYN, TCP
      SYN-ACK, pure ACKs, Window probes) and on retransmitted packets. RFC
      3168 is silent about the use of ECN on RST and FIN packets. RFC
      5562 <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span> is an experimental modification to
      ECN that enables ECN support for TCP SYN-ACK packets.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">This document defines an experimental modification to ECN <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> that shall be called ECN++. It enables ECN support on
      all the aforementioned types of TCP packet. RFC 5562 (which was called
      ECN+) is obsoleted by the present specification, because it has the same
      goal of enabling ECT, but on only one type of control packet. The
      mechanisms proposed in this document have been defined conservatively
      and with safety in mind, possibly in some cases at the expense of
      performance.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">ECN++ uses a sender-only deployment model. It works whether the two
      ends of the TCP connection use classic ECN feedback <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> or Accurate ECN feedback (AccECN <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span>), the two ECN feedback mechanisms
      for TCP being standardized at the time of writing.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">Using ECN on initial SYN packets provides significant benefits, as we
      describe in the next subsection. However, only AccECN provides a way to
      feed back whether the SYN was CE marked, and RFC 3168 does not.
      Therefore, implementers of ECN++ are RECOMMENDED to also implement
      AccECN. Conversely, if AccECN (or an equivalent safety mechanism) is not
      implemented with ECN++, this specification rules out ECN on the SYN.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">ECN++ is designed for compatibility with a number of latency
      improvements to TCP such as TCP Fast Open (TFO <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span>), initial window of 10 SMSS (IW10 <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>) and Low latency Low Loss Scalable Transport (L4S
      <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>), but they can all be
      implemented and deployed independently. <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> is a
      standards track procedural device that relaxes requirements in RFC 3168
      and other standards track RFCs that would otherwise preclude the
      experimental modifications needed for ECN++ and other ECN
      experiments.<a href="#section-1-5" class="pilcrow">¶</a></p>
<div id="genecn_sec_motivation">
<section id="section-1.1">
        <h3 id="name-motivation">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-motivation" class="section-name selfRef">Motivation</a>
        </h3>
<p id="section-1.1-1">The absence of ECN support on TCP control packets and
        retransmissions has a potential harmful effect. In any ECN deployment,
        non-ECN-capable packets suffer a penalty when they traverse a
        congested bottleneck. For instance, with a drop probability of 1%, 1%
        of connection attempts suffer a timeout of about 1 second before the
        SYN is retransmitted, which is highly detrimental to the performance
        of short flows. TCP control packets, particularly TCP SYNs and
        SYN-ACKs, are important for performance, so dropping them is best
        avoided.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">Not using ECN on control packets can be particularly detrimental to
        performance in environments where the ECN marking level is high. For
        example, <span>[<a href="#judd-nsdi" class="xref">judd-nsdi</a>]</span> shows that in a controlled private
        data centre (DC) environment where ECN is used (in conjunction with
        DCTCP <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>), the probability of being able to
        establish a new connection using a non-ECN SYN packet drops to close
        to zero even when there are only 16 ongoing TCP flows transmitting at
        full speed. The issue is that DCTCP exhibits a much more aggressive
        response to packet marking (which is why it is only applicable in
        controlled environments). This leads to a high marking probability for
        ECN-capable packets, and in turn a high drop probability for non-ECN
        packets. Therefore non-ECN SYNs are dropped aggressively, rendering it
        nearly impossible to establish a new connection in the presence of
        even mild traffic load.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<p id="section-1.1-3">Finally, there are ongoing experimental efforts to promote the
        adoption of a slightly modified variant of DCTCP (and similar
        congestion controls) over the Internet to achieve low latency, low
        loss and scalable throughput (L4S) for all communications <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>. In such an approach, L4S packets
        identify themselves using an ECN codepoint <span>[<a href="#I-D.ietf-tsvwg-ecn-l4s-id" class="xref">I-D.ietf-tsvwg-ecn-l4s-id</a>]</span>. With L4S, preventing TCP control
        packets from obtaining the benefits of ECN would not only expose them
        to the prevailing level of congestion loss, but it would also classify
        them into a different queue. Then only L4S data packets would be
        classified into the L4S queue that is expected to have lower latency,
        while the packets controlling and retransmitting these data packets
        would still get stuck behind the queue induced by non-L4S-enabled TCP
        traffic.<a href="#section-1.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-1.2">
        <h3 id="name-experiment-goals">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-experiment-goals" class="section-name selfRef">Experiment Goals</a>
        </h3>
<p id="section-1.2-1">The goal of the experimental modifications defined in this document
        is to allow the use of ECN on all TCP packets. Experiments are
        expected in the public Internet as well as in controlled environments
        to understand the following issues:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.2-2.1">How SYNs, Window probes, pure ACKs, FINs, RSTs and
            retransmissions that carry the ECT(0), ECT(1) or CE codepoints are
            processed by the TCP endpoints and the network (including routers,
            firewalls and other middleboxes). In particular we would like to
            learn if these packets are frequently blocked or if these packets
            are usually forwarded and processed.<a href="#section-1.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.2-2.2">The scale of deployment of the different flavours of ECN,
            including <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span>,
            <span>[<a href="#RFC3540" class="xref">RFC3540</a>]</span> and <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span>.<a href="#section-1.2-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.2-2.3">How much the performance of TCP communications is improved by
            allowing ECN marking of each packet type.<a href="#section-1.2-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.2-2.4">To identify any issues (including security issues) raised by
            enabling ECN marking of these packets.<a href="#section-1.2-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.2-2.5">To conduct the specific experiments identified in the text by
            the strings "EXPERIMENTATION NEEDED" or "MEASUREMENTS NEEDED".<a href="#section-1.2-2.5" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-1.2-3">The data gathered through the experiments described in this
        document, particularly under the first 2 bullets above, will help in
        the redesign of the final mechanism (if needed) for adding ECN support
        to the different packet types considered in this document.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
<p id="section-1.2-4">Success criteria: The experiment will be a success if we obtain
        enough data to have a clearer view of the deployability and benefits
        of enabling ECN on all TCP packets, as well as any issues. If the
        results of the experiment show that it is feasible to deploy such
        changes; that there are gains to be achieved through the changes
        described in this specification; and that no other major issues may
        interfere with the deployment of the proposed changes; then it would
        be reasonable to adopt the proposed changes in a standards track
        specification that would update RFC 3168.<a href="#section-1.2-4" class="pilcrow">¶</a></p>
</section>
<section id="section-1.3">
        <h3 id="name-document-structure">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-document-structure" class="section-name selfRef">Document Structure</a>
        </h3>
<p id="section-1.3-1">The remainder of this document is structured as follows. In <a href="#term" class="xref">Section 2</a>, we present the terminology used in the rest of the
        document. In <a href="#spec" class="xref">Section 3</a>, we specify the modifications to
        provide ECN support to TCP SYNs, pure ACKs, Window probes, FINs, RSTs
        and retransmissions. We describe both the network behaviour and the
        endpoint behaviour. <a href="#genecn_sec_variants" class="xref">Section 5</a> discusses
        variations of the specification that will be necessary to interwork
        with a number of popular variants or derivatives of TCP. RFC 3168
        provides a number of specific reasons why ECN support is not
        appropriate for each packet type. In <a href="#arguments" class="xref">Section 4</a>, we
        revisit each of these arguments for each packet type to justify why it
        is reasonable to conduct this experiment.<a href="#section-1.3-1" class="pilcrow">¶</a></p>
</section>
</section>
<div id="term">
<section id="section-2">
      <h2 id="name-terminology">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-terminology" class="section-name selfRef">Terminology</a>
      </h2>
<p id="section-2-1">The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
      SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
      document, are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> when and only when they appear in all capitals <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span>.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Pure ACK: A TCP segment with the ACK flag set and no data
      payload.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">SYN: A TCP segment with the SYN (synchronize) flag set.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Window probe: Defined in <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span>, a window probe is
      a TCP segment with only one byte of data sent to learn if the receive
      window is still zero.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">FIN: A TCP segment with the FIN (finish) flag set.<a href="#section-2-5" class="pilcrow">¶</a></p>
<p id="section-2-6">RST: A TCP segment with the RST (reset) flag set.<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">Retransmission: A TCP segment that has been retransmitted by the TCP
      sender.<a href="#section-2-7" class="pilcrow">¶</a></p>
<p id="section-2-8">TCP client: The initiating end of a TCP connection. Also called the
      initiator.<a href="#section-2-8" class="pilcrow">¶</a></p>
<p id="section-2-9">TCP server: The responding end of a TCP connection. Also called the
      responder.<a href="#section-2-9" class="pilcrow">¶</a></p>
<p id="section-2-10">ECT: ECN-Capable Transport. One of the two codepoints ECT(0) or
      ECT(1) in the ECN field <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> of the IP header (v4 or
      v6). An ECN-capable sender sets one of these to indicate that both
      transport end-points support ECN. When this specification says the
      sender sets an ECT codepoint, by default it means ECT(0). Optionally, it
      could mean ECT(1), which is in the process of being redefined for use by
      L4S experiments <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> <span>[<a href="#I-D.ietf-tsvwg-ecn-l4s-id" class="xref">I-D.ietf-tsvwg-ecn-l4s-id</a>]</span>.<a href="#section-2-10" class="pilcrow">¶</a></p>
<p id="section-2-11">Not-ECT: The ECN codepoint set by senders that indicates that the
      transport is not ECN-capable.<a href="#section-2-11" class="pilcrow">¶</a></p>
<p id="section-2-12">CE: Congestion Experienced. The ECN codepoint that an intermediate
      node sets to indicate congestion <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>. A node sets
      an increasing proportion of ECT packets to CE as the level of congestion
      increases.<a href="#section-2-12" class="pilcrow">¶</a></p>
</section>
</div>
<div id="spec">
<section id="section-3">
      <h2 id="name-specification">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-specification" class="section-name selfRef">Specification</a>
      </h2>
<p id="section-3-1">The experimental ECN++ changes to the specification of TCP over ECN
      <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> defined here primarily alter the behaviour of
      the sending host for each half-connection. However, there are
      subsections for forwarding elements and receivers below, which recommend
      that they accept the new packets - they should do already, but might
      not. This will allow implementers to check the receive side code while
      they are altering the send-side code. All changes can be deployed at
      each end-point independently of others and independent of any network
      behaviour.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">The feedback behaviour at the receiver depends on whether classic ECN
      TCP feedback <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> or Accurate ECN (AccECN) TCP
      feedback <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> has been
      negotiated. Nonetheless, neither receiver feedback behaviour is altered
      by the present specification.<a href="#section-3-2" class="pilcrow">¶</a></p>
<section id="section-3.1">
        <h3 id="name-network-eg-firewall-behavio">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-network-eg-firewall-behavio" class="section-name selfRef">Network (e.g. Firewall) Behaviour</a>
        </h3>
<p id="section-3.1-1">Previously the specification of ECN for TCP <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> required the sender to set not-ECT on TCP control
        packets and retransmissions. Some readers of RFC 3168 might have
        erroneously interpreted this as a requirement for firewalls, intrusion
        detection systems, etc. to check and enforce this behaviour. Section
        4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> updates RFC 3168 to remove this
        ambiguity. It requires firewalls or any intermediate nodes not to
        treat certain types of ECN-capable TCP segment differently (except
        potentially in one attack scenario). This is likely to only involve a
        firewall rule change in a fraction of cases (at most 0.4% of paths
        according to the tests reported in <a href="#genecn_sec_unexpected_ECN" class="xref">Section 4.2.2</a>).<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">In case a TCP sender encounters a middlebox blocking ECT on certain
        TCP segments, the specification below includes behaviour to fall back
        to non-ECN. However, this loses the benefit of ECN on control packets.
        So operators are RECOMMENDED to alter their firewall rules to comply
        with the requirement referred to above (section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>).<a href="#section-3.1-2" class="pilcrow">¶</a></p>
</section>
<section id="section-3.2">
        <h3 id="name-sender-behaviour">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-sender-behaviour" class="section-name selfRef">Sender Behaviour</a>
        </h3>
<p id="section-3.2-1">For each type of control packet or retransmission, the following
        sections detail changes to the sender's behaviour in two respects: i)
        whether it sets ECT; and ii) its response to congestion feedback.
        <a href="#genecn_tab_summary" class="xref">Table 1</a> summarises these two behaviours
        for each type of packet, but the relevant subsection below should be
        referred to for the detailed behaviour. The subsection on the SYN is
        more complex than the others, because it has to include fall-back
        behaviour if the ECT packet appears not to have got through, and
        caching of the outcome to detect persistent failures.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<span id="name-summary-of-sender-behaviour"></span><div id="genecn_tab_summary">
<table class="center" id="table-1">
          <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-summary-of-sender-behaviour" class="selfRef">Summary of sender behaviour. In each case the relevant section below should be referred to for the detailed behaviour</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">TCP packet type</th>
              <th class="text-left" rowspan="1" colspan="1">ECN field if AccECN f/b negotiated*</th>
              <th class="text-left" rowspan="1" colspan="1">ECN field if RFC3168 f/b negotiated*</th>
              <th class="text-left" rowspan="1" colspan="1">Congestion Response</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">SYN</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">not-ECT</td>
              <td class="text-left" rowspan="1" colspan="1">If AccECN, reduce IW</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">SYN-ACK</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">Reduce IW</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Pure ACK</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">not-ECT</td>
              <td class="text-left" rowspan="1" colspan="1">If AccECN, usual cwnd response and optionally <span>[<a href="#RFC5690" class="xref">RFC5690</a>]</span>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">W Probe</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">Usual cwnd response</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FIN</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">None or optionally <span>[<a href="#RFC5690" class="xref">RFC5690</a>]</span>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">RST</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Re-XMT</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">ECT</td>
              <td class="text-left" rowspan="1" colspan="1">Usual cwnd response</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-3.2-3" class="keepWithPrevious">Window probe and retransmission are abbreviated to W
          Probe an Re-XMT. * For a SYN, "negotiated" means
          "requested".<a href="#section-3.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2-4">It can be seen that we recommend against the sender setting ECT on
        the SYN if it is not requesting AccECN feedback. Therefore it is
        RECOMMENDED that the AccECN specification <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> is implemented, along with the
        ECN++ experiment, because it is expected that ECT on the SYN will give
        the most significant performance gain, particularly for short
        flows.<a href="#section-3.2-4" class="pilcrow">¶</a></p>
<p id="section-3.2-5">Nonetheless, this specification also caters for the case where an
        ECN++ TCP sender is not using AccECN. This could be because it does
        not support AccECN or because the other end of the TCP connection does
        not (AccECN can only be used for a connection if both ends support
        it).<a href="#section-3.2-5" class="pilcrow">¶</a></p>
<p id="section-3.2-6">Note that <a href="#genecn_tab_summary" class="xref">Table 1</a> does not imply any
        obligation to set any packet to ECT. ECN++ removes the restrictions
        that RFC 3168 places against setting ECT on these types of packets,
        and an implementation would normally be expected to take advantage of
        this, but it does not have to. Therefore, an implementation of the
        ECN++ experiment would be compliant if, for instance, it set ECT on
        some types of control packets but not others.<a href="#section-3.2-6" class="pilcrow">¶</a></p>
<div id="genecn_sec_SYN">
<section id="section-3.2.1">
          <h4 id="name-syn-send">
<a href="#section-3.2.1" class="section-number selfRef">3.2.1. </a><a href="#name-syn-send" class="section-name selfRef">SYN (Send)</a>
          </h4>
<div id="genecn_sec_ECT_SYN">
<section id="section-3.2.1.1">
            <h5 id="name-setting-ect-on-the-syn">
<a href="#section-3.2.1.1" class="section-number selfRef">3.2.1.1. </a><a href="#name-setting-ect-on-the-syn" class="section-name selfRef">Setting ECT on the SYN</a>
            </h5>
<p id="section-3.2.1.1-1">With classic <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> ECN feedback, the SYN was
            not expected to be ECN-capable, so the flag provided to feed back
            congestion was put to another use (it is used in combination with
            other flags to indicate that the responder supports ECN). In
            contrast, Accurate ECN (AccECN) feedback <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> provides a codepoint in the
            SYN-ACK for the responder to feed back whether the SYN arrived
            marked CE. Therefore the setting of the IP/ECN field on the SYN is
            specified separately for each case in the following two
            subsections.<a href="#section-3.2.1.1-1" class="pilcrow">¶</a></p>
<section id="section-3.2.1.1.1">
              <h6 id="name-ecn-tcp-client-also-support">
<a href="#section-3.2.1.1.1" class="section-number selfRef">3.2.1.1.1. </a><a href="#name-ecn-tcp-client-also-support" class="section-name selfRef">ECN++ TCP Client also Supports AccECN</a>
              </h6>
<p id="section-3.2.1.1.1-1">For the ECN++ experiment, if the SYN is requesting AccECN
              feedback, the TCP sender will also set ECT on the SYN. It can
              ignore the prohibition in section 6.1.1 of RFC 3168 against
              setting ECT on such a SYN, as per Section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-3.2.1.1.1-1" class="pilcrow">¶</a></p>
</section>
<section id="section-3.2.1.1.2">
              <h6 id="name-ecn-tcp-client-does-not-sup">
<a href="#section-3.2.1.1.2" class="section-number selfRef">3.2.1.1.2. </a><a href="#name-ecn-tcp-client-does-not-sup" class="section-name selfRef">ECN++ TCP Client does not Support AccECN</a>
              </h6>
<p id="section-3.2.1.1.2-1">If the SYN sent by a TCP initiator does not attempt to
              negotiate Accurate ECN feedback, or does not use an equivalent
              safety mechanism, it MUST still comply with RFC 3168, which says
              that a TCP initiator "MUST NOT set ECT on a SYN".<a href="#section-3.2.1.1.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2.1.1.2-2">The only envisaged examples of "equivalent safety mechanisms"
              are: a) some future TCP ECN feedback protocol, perhaps evolved
              from AccECN, that feeds back CE marking on a SYN; b) setting the
              initial window to 1 SMSS. IW=1 is NOT RECOMMENDED because it
              could degrade performance, but might be appropriate for certain
              lightweight TCP implementations.<a href="#section-3.2.1.1.2-2" class="pilcrow">¶</a></p>
<p id="section-3.2.1.1.2-3">See <a href="#genecn_sec_rationale_SYN" class="xref">Section 4.2</a> for discussion
              and rationale.<a href="#section-3.2.1.1.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2.1.1.2-4">If the TCP initiator does not set ECT on the SYN, the rest of
              <a href="#genecn_sec_SYN" class="xref">Section 3.2.1</a> does not apply.<a href="#section-3.2.1.1.2-4" class="pilcrow">¶</a></p>
</section>
</section>
</div>
<div id="genecn_sec_SYN_cache">
<section id="section-3.2.1.2">
            <h5 id="name-caching-where-to-use-ect-on">
<a href="#section-3.2.1.2" class="section-number selfRef">3.2.1.2. </a><a href="#name-caching-where-to-use-ect-on" class="section-name selfRef">Caching where to use ECT on SYNs</a>
            </h5>
<p id="section-3.2.1.2-1">This subsection only applies if the ECN++ TCP client set ECTs
            on the SYN and supports AccECN.<a href="#section-3.2.1.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2.1.2-2">Until AccECN servers become widely deployed, a TCP initiator
            that sets ECT on a SYN (which typically implies the same SYN also
            requests AccECN, as above) SHOULD also maintain a cache entry per
            server to record servers that it is not worth sending an ECT SYN
            to, e.g. because they do not support AccECN and therefore
            have no logic for congestion markings on the SYN. Mobile hosts MAY
            maintain a cache entry per access network to record 'non-ECT SYN'
            entries against proxies (see <a href="#genecn_sec_SYN_cache_rationale" class="xref">Section 4.2.3</a>). This cache can be
            implemented as part of the shared state across multiple TCP
            connections, following <span>[<a href="#RFC2140" class="xref">RFC2140</a>]</span>.<a href="#section-3.2.1.2-2" class="pilcrow">¶</a></p>
<p id="section-3.2.1.2-3">Subsequently the initiator will not set ECT on a SYN to such a
            server or proxy, but it can still always request AccECN support
            (because the response will state any earlier stage of ECN
            evolution that the server supports with no performance penalty).
            If a server subsequently upgrades to support AccECN, the initiator
            will discover this as soon as it next connects, then it can remove
            the server from its cache and subsequently always set ECT for that
            server.<a href="#section-3.2.1.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2.1.2-4">The client can limit the size of its cache of 'non-ECT SYN'
            servers. Then, while AccECN is not widely deployed, it will only
            cache the 'non-ECT SYN' servers that are most used and most
            recently used by the client. As the client accesses servers that
            have been expelled from its cache, it will simply use ECT on the
            SYN by default.<a href="#section-3.2.1.2-4" class="pilcrow">¶</a></p>
<p id="section-3.2.1.2-5">Servers that do not support ECN as a whole do not need to be
            recorded separately from non-support of AccECN because the
            response to a request for AccECN immediately states which stage in
            the evolution of ECN the server supports (AccECN <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span>, classic ECN <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> or no ECN).<a href="#section-3.2.1.2-5" class="pilcrow">¶</a></p>
<p id="section-3.2.1.2-6">The above strategy is named "optimistic ECT and cache
            failures". It is believed to be sufficient based on three
            measurement studies and assumptions detailed in <a href="#genecn_sec_SYN_cache_rationale" class="xref">Section 4.2.3</a>. However, <a href="#genecn_sec_SYN_cache_rationale" class="xref">Section 4.2.3</a> gives two other
            strategies and the choice between them depends on the
            implementer's goals and the deployment prevalence of ECN variants
            in the network and on servers, not to mention the prevalence of
            some significant bugs.<a href="#section-3.2.1.2-6" class="pilcrow">¶</a></p>
<p id="section-3.2.1.2-7">If the initiator times out without seeing a SYN-ACK, it will
            separately cache this fact (see fall-back in <a href="#genect_sec_fall-back-SYN" class="xref">Section 3.2.1.4</a> for details).<a href="#section-3.2.1.2-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genect_sec_SYN-response">
<section id="section-3.2.1.3">
            <h5 id="name-syn-congestion-response">
<a href="#section-3.2.1.3" class="section-number selfRef">3.2.1.3. </a><a href="#name-syn-congestion-response" class="section-name selfRef">SYN Congestion Response</a>
            </h5>
<p id="section-3.2.1.3-1">As explained above, this subsection only applies if the ECN++
            TCP client sets ECT on the initial SYN.<a href="#section-3.2.1.3-1" class="pilcrow">¶</a></p>
<p id="section-3.2.1.3-2">If the SYN-ACK returned to the TCP initiator confirms that the
            server supports AccECN, it will also be able to indicate whether
            or not the SYN was CE-marked. If the SYN was CE-marked, and if the
            initial window is greater than 1 MSS, then, the initiator MUST
            reduce its Initial Window (IW) and SHOULD reduce it to 1 SMSS
            (sender maximum segment size). The rationale is the same as that
            for the response to CE on a SYN-ACK (<a href="#rationale-syn-ack-congestion-resp" class="xref">Section 4.3.2</a>).<a href="#section-3.2.1.3-2" class="pilcrow">¶</a></p>
<p id="section-3.2.1.3-3">If the initiator has set ECT on the SYN and if the SYN-ACK
            shows that the server does not support feedback of a CE on the SYN
            (e.g. it does not support AccECN) and if the initial
            congestion window of the initiator is greater than 1 MSS, then the
            TCP initiator MUST conservatively reduce its Initial Window and
            SHOULD reduce it to 1 SMSS. A reduction to greater than 1 SMSS MAY
            be appropriate (see <a href="#genecn_sec_CE-missed" class="xref">Section 4.2.1</a>).
            Conservatism is necessary because the SYN-ACK cannot show whether
            the SYN was CE-marked.<a href="#section-3.2.1.3-3" class="pilcrow">¶</a></p>
<p id="section-3.2.1.3-4">If the TCP initiator (host A) receives a SYN from the remote
            end (host B) after it has sent a SYN to B, it indicates the
            (unusual) case of a simultaneous open. Host A will respond with a
            SYN-ACK. Host A will probably then receive a SYN-ACK in response
            to its own SYN, after which it can follow the appropriate one of
            the two paragraphs above.<a href="#section-3.2.1.3-4" class="pilcrow">¶</a></p>
<p id="section-3.2.1.3-5">In all the above cases, the initiator does not have to back off
            its retransmission timer as it would in response to a timeout
            following no response to its SYN <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>, because
            both the SYN and the SYN-ACK have been successfully delivered
            through the network. Also, the initiator does not need to exit
            slow start or reduce ssthresh, which is not even required when a
            SYN is lost <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>.<a href="#section-3.2.1.3-5" class="pilcrow">¶</a></p>
<p id="section-3.2.1.3-6">If an initial window of more than 3 segments is implemented
            (e.g. IW10 <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>), <a href="#genecn_sec_variants" class="xref">Section 5</a> gives additional
            recommendations.<a href="#section-3.2.1.3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genect_sec_fall-back-SYN">
<section id="section-3.2.1.4">
            <h5 id="name-fall-back-following-no-resp">
<a href="#section-3.2.1.4" class="section-number selfRef">3.2.1.4. </a><a href="#name-fall-back-following-no-resp" class="section-name selfRef">Fall-Back Following No Response to an ECT SYN</a>
            </h5>
<p id="section-3.2.1.4-1">As explained above, this subsection only applies if the ECN++
            TCP client also sets ECT on the initial SYN.<a href="#section-3.2.1.4-1" class="pilcrow">¶</a></p>
<p id="section-3.2.1.4-2">An ECT SYN might be lost due to an over-zealous path element
            (or server) blocking ECT packets that do not conform to RFC 3168.
            Some evidence of this was found in a 2014 study <span>[<a href="#ecn-pam" class="xref">ecn-pam</a>]</span>, but in a more recent study using 2017 data
            <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span> extensive measurements found no case
            where ECT on TCP control packets was treated any differently from
            ECT on TCP data packets. Loss is commonplace for numerous other
            reasons, e.g. congestion loss at a non-ECN queue on the
            forward or reverse path, transmission errors, etc. Alternatively,
            the cause of the loss might be the associated attempt to negotiate
            AccECN, or possibly other unrelated options on the SYN.<a href="#section-3.2.1.4-2" class="pilcrow">¶</a></p>
<p id="section-3.2.1.4-3">Therefore, if the timer expires after the TCP initiator has
            sent the first ECT SYN, it SHOULD make one more attempt to
            retransmit the SYN with ECT set (backing off the timer as usual).
            If the retransmission timer expires again, it SHOULD retransmit
            the SYN with the not-ECT codepoint in the IP header, to expedite
            connection set-up. If other experimental fields or options were on
            the SYN, it will also be necessary to follow their specifications
            for fall-back too. It would make sense to coordinate all the
            strategies for fall-back in order to isolate the specific cause of
            the problem.<a href="#section-3.2.1.4-3" class="pilcrow">¶</a></p>
<p id="section-3.2.1.4-4">If the TCP initiator is caching failed connection attempts, it
            SHOULD NOT give up using ECT on the first SYN of subsequent
            connection attempts until it is clear that a blockage persistently
            and specifically affects ECT on SYNs. This is because loss is so
            commonplace for other reasons. Even if it does eventually decide
            to give up setting ECT on the SYN, it will probably not need to
            give up on AccECN on the SYN. In any case, if a cache is used, it
            SHOULD be arranged to expire so that the initiator will
            infrequently attempt to check whether the problem has been
            resolved.<a href="#section-3.2.1.4-4" class="pilcrow">¶</a></p>
<p id="section-3.2.1.4-5">Other fall-back strategies MAY be adopted where applicable (see
            <a href="#genecn_sec_unexpected_ECN" class="xref">Section 4.2.2</a> for suggestions, and
            the conditions under which they would apply).<a href="#section-3.2.1.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="genecn_sec_SYN-ACK">
<section id="section-3.2.2">
          <h4 id="name-syn-ack-send">
<a href="#section-3.2.2" class="section-number selfRef">3.2.2. </a><a href="#name-syn-ack-send" class="section-name selfRef">SYN-ACK (Send)</a>
          </h4>
<p id="section-3.2.2-1"></p>
<section id="section-3.2.2.1">
            <h5 id="name-setting-ect-on-the-syn-ack">
<a href="#section-3.2.2.1" class="section-number selfRef">3.2.2.1. </a><a href="#name-setting-ect-on-the-syn-ack" class="section-name selfRef">Setting ECT on the SYN-ACK</a>
            </h5>
<p id="section-3.2.2.1-1">For the ECN++ experiment, the TCP implementation will set ECT
            on SYN-ACKs. It can ignore the requirement in section 6.1.1 of RFC
            3168 to set not-ECT on a SYN-ACK, as per Section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-3.2.2.1-1" class="pilcrow">¶</a></p>
</section>
<div id="genecn_sec_SYN-ACK_response">
<section id="section-3.2.2.2">
            <h5 id="name-syn-ack-congestion-response">
<a href="#section-3.2.2.2" class="section-number selfRef">3.2.2.2. </a><a href="#name-syn-ack-congestion-response" class="section-name selfRef">SYN-ACK Congestion Response</a>
            </h5>
<p id="section-3.2.2.2-1">A host that sets ECT on SYN-ACKs MUST reduce its initial window
            in response to any congestion feedback, whether using classic ECN
            or AccECN (see <a href="#genecn_sec_CE-missed-SYN-ACK" class="xref">Section 4.3.1</a>). It
            SHOULD reduce it to 1 SMSS. This is different to the behaviour
            specified in an earlier experiment that set ECT on the SYN-ACK
            <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span>. This is justified in <a href="#rationale-syn-ack-congestion-resp" class="xref">Section 4.3.2</a>.<a href="#section-3.2.2.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2.2.2-2">The responder does not have to back off its retransmission
            timer because the ECN feedback proves that the network is
            delivering packets successfully and is not severely overloaded.
            Also the responder does not have to leave slow start or reduce
            ssthresh, which is not even required when a SYN-ACK has been
            lost.<a href="#section-3.2.2.2-2" class="pilcrow">¶</a></p>
<p id="section-3.2.2.2-3">The congestion response to CE-marking on a SYN-ACK for a server
            that implements either the TCP Fast Open experiment (TFO <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span>) or experimentation with an initial window of
            more than 3 segments (e.g. IW10 <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>) is
            discussed in <a href="#genecn_sec_variants" class="xref">Section 5</a>.<a href="#section-3.2.2.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genect_sec_fall-back-SYN-ACK">
<section id="section-3.2.2.3">
            <h5 id="name-fall-back-following-no-respo">
<a href="#section-3.2.2.3" class="section-number selfRef">3.2.2.3. </a><a href="#name-fall-back-following-no-respo" class="section-name selfRef">Fall-Back Following No Response to an ECT SYN-ACK</a>
            </h5>
<p id="section-3.2.2.3-1">After the responder sends a SYN-ACK with ECT set, if its
            retransmission timer expires it SHOULD retransmit one more SYN-ACK
            with ECT set (and back-off its timer as usual). If the timer
            expires again, it SHOULD retransmit the SYN-ACK with not-ECT in
            the IP header. If other experimental fields or options were on the
            initial SYN-ACK, it will also be necessary to follow their
            specifications for fall-back. It would make sense to co-ordinate
            all the strategies for fall-back in order to isolate the specific
            cause of the problem.<a href="#section-3.2.2.3-1" class="pilcrow">¶</a></p>
<p id="section-3.2.2.3-2">This fall-back strategy attempts to use ECT one more time than
            the strategy for ECT SYN-ACKs in <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span> (which
            is made obsolete, being superseded by the present specification).
            Other fall-back strategies MAY be adopted if found to be more
            effective, e.g. fall-back to not-ECT on the first
            retransmission attempt.<a href="#section-3.2.2.3-2" class="pilcrow">¶</a></p>
<p id="section-3.2.2.3-3">The server MAY cache failed connection attempts, e.g. per
            client access network. A client-based alternative to caching at
            the server is given in <a href="#genecn_sec_Fall-Back_SYN-ACK" class="xref">Section 4.3.3</a>. If the TCP server is
            caching failed connection attempts, it SHOULD NOT give up using
            ECT on the first SYN-ACK of subsequent connection attempts until
            it is clear that the blockage persistently and specifically
            affects ECT on SYN-ACKs. This is because loss is so commonplace
            for other reasons (see <a href="#genect_sec_fall-back-SYN" class="xref">Section 3.2.1.4</a>).
            If a cache is used, it SHOULD be arranged to expire so that the
            server will infrequently attempt to check whether the problem has
            been resolved.<a href="#section-3.2.2.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="acks">
<section id="section-3.2.3">
          <h4 id="name-pure-ack-send">
<a href="#section-3.2.3" class="section-number selfRef">3.2.3. </a><a href="#name-pure-ack-send" class="section-name selfRef">Pure ACK (Send)</a>
          </h4>
<p id="section-3.2.3-1">A Pure ACK is an ACK packet that does not carry data, which
          includes the Pure ACK at the end of TCP's 3-way handshake.<a href="#section-3.2.3-1" class="pilcrow">¶</a></p>
<p id="section-3.2.3-2">For the ECN++ experiment, whether a TCP implementation sets ECT
          on a Pure ACK depends on whether or not Accurate ECN TCP feedback
          <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> has been successfully
          negotiated for a particular TCP connection, as specified in the
          following two subsections.<a href="#section-3.2.3-2" class="pilcrow">¶</a></p>
<section id="section-3.2.3.1">
            <h5 id="name-pure-ack-without-accecn-fee">
<a href="#section-3.2.3.1" class="section-number selfRef">3.2.3.1. </a><a href="#name-pure-ack-without-accecn-fee" class="section-name selfRef">Pure ACK without AccECN Feedback</a>
            </h5>
<p id="section-3.2.3.1-1">If AccECN has not been successfully negotiated for a
            connection, ECT MUST NOT be set on Pure ACKs by either end.<a href="#section-3.2.3.1-1" class="pilcrow">¶</a></p>
</section>
<section id="section-3.2.3.2">
            <h5 id="name-pure-ack-with-accecn-feedba">
<a href="#section-3.2.3.2" class="section-number selfRef">3.2.3.2. </a><a href="#name-pure-ack-with-accecn-feedba" class="section-name selfRef">Pure ACK with AccECN Feedback</a>
            </h5>
<p id="section-3.2.3.2-1">For the ECN++ experiment, if AccECN has been successfully
            negotiated, either end of the connection will set ECT on Pure
            ACKs. They can ignore the requirement in section 6.1.4 of RFC 3168
            to set not-ECT on a pure ACK, as per Section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-3.2.3.2-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.2.3.2-2.1">MEASUREMENTS NEEDED: Measurements are needed to learn how
                the deployed base of network elements and RFC 3168 servers
                react to pure ACKs marked with the ECT(0)/ECT(1)/CE
                codepoints, i.e. whether they are dropped, codepoint
                cleared or processed and the congestion indication fed back on
                a subsequent packet.<a href="#section-3.2.3.2-2.1" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-3.2.3.2-3">See <a href="#genecn_sec_rcv_ACK" class="xref">Section 3.3.3</a> for the implications if
            a host receives a CE-marked Pure ACK.<a href="#section-3.2.3.2-3" class="pilcrow">¶</a></p>
<section id="section-3.2.3.2.1">
              <h6 id="name-pure-ack-congestion-respons">
<a href="#section-3.2.3.2.1" class="section-number selfRef">3.2.3.2.1. </a><a href="#name-pure-ack-congestion-respons" class="section-name selfRef">Pure ACK Congestion Response</a>
              </h6>
<p id="section-3.2.3.2.1-1">As explained above, this subsection only applies if AccECN
              has been successfully negotiated for the TCP connection.<a href="#section-3.2.3.2.1-1" class="pilcrow">¶</a></p>
<p id="section-3.2.3.2.1-2">A host that sets ECT on pure ACKs SHOULD respond to the
              congestion signal resulting from pure ACKs being marked with the
              CE codepoint. The specific response will need to be defined as
              an update to each congestion control specification. Possible
              responses to congestion feedback include reducing the congestion
              window (CWND) and/or regulating the pure ACK rate (see <a href="#genecn_sec_cwnd_response_pure_ACK" class="xref">Section 4.4.1.1</a>).<a href="#section-3.2.3.2.1-2" class="pilcrow">¶</a></p>
<p id="section-3.2.3.2.1-3">Note that, in comparison, TCP Congestion Control <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span> does not require a TCP to detect or respond
              to loss of pure ACKs at all; it requires no reduction in
              congestion window or ACK rate.<a href="#section-3.2.3.2.1-3" class="pilcrow">¶</a></p>
</section>
</section>
</section>
</div>
<section id="section-3.2.4">
          <h4 id="name-window-probe-send">
<a href="#section-3.2.4" class="section-number selfRef">3.2.4. </a><a href="#name-window-probe-send" class="section-name selfRef">Window Probe (Send)</a>
          </h4>
<p id="section-3.2.4-1">For the ECN++ experiment, the TCP sender will set ECT on window
          probes. It can ignore the prohibition in section 6.1.6 of RFC 3168
          against setting ECT on a window probe, as per Section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-3.2.4-1" class="pilcrow">¶</a></p>
<p id="section-3.2.4-2">A window probe contains a single octet, so it is no different
          from a regular TCP data segment. Therefore a TCP receiver will feed
          back any CE marking on a window probe as normal (either using
          classic ECN feedback or AccECN feedback). The sender of the probe
          will then reduce its congestion window as normal.<a href="#section-3.2.4-2" class="pilcrow">¶</a></p>
<p id="section-3.2.4-3">A receive window of zero indicates that the application is not
          consuming data fast enough and does not imply anything about network
          congestion. Once the receive window opens, the congestion window
          might become the limiting factor, so it is correct that CE-marked
          probes reduce the congestion window. This complements cwnd
          validation <span>[<a href="#RFC7661" class="xref">RFC7661</a>]</span>, which reduces cwnd as more time
          elapses without having used available capacity. However, CE-marking
          on window probes does not reduce the rate of the probes themselves.
          This is unlikely to present a problem, given the duration between
          window probes doubles <span>[<a href="#RFC1122" class="xref">RFC1122</a>]</span> as long as the
          receiver is advertising a zero window (currently minimum 1 second,
          maximum at least 1 minute <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>).<a href="#section-3.2.4-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.2.4-4.1">MEASUREMENTS NEEDED: Measurements are needed to learn how the
              deployed base of network elements and servers react to Window
              probes marked with the ECT(0)/ECT(1)/CE codepoints,
              i.e. whether they are dropped, codepoint cleared or
              processed.<a href="#section-3.2.4-4.1" class="pilcrow">¶</a>
</li>
          </ul>
</section>
<section id="section-3.2.5">
          <h4 id="name-fin-send">
<a href="#section-3.2.5" class="section-number selfRef">3.2.5. </a><a href="#name-fin-send" class="section-name selfRef">FIN (Send)</a>
          </h4>
<p id="section-3.2.5-1">A TCP implementation can set ECT on a FIN.<a href="#section-3.2.5-1" class="pilcrow">¶</a></p>
<p id="section-3.2.5-2">See <a href="#genecn_sec_rcv_FIN" class="xref">Section 3.3.4</a> for the implications if a
          host receives a CE-marked FIN.<a href="#section-3.2.5-2" class="pilcrow">¶</a></p>
<p id="section-3.2.5-3">A congestion response to a CE-marking on a FIN is not
          required.<a href="#section-3.2.5-3" class="pilcrow">¶</a></p>
<p id="section-3.2.5-4">After sending a FIN, the endpoint will not send any more data in
          the connection. Therefore, even if the FIN-ACK indicates that the
          FIN was CE-marked (whether using classic or AccECN feedback),
          reducing the congestion window will not affect anything.<a href="#section-3.2.5-4" class="pilcrow">¶</a></p>
<p id="section-3.2.5-5">After sending a FIN, a host might send one or more pure ACKs. If
          it is using one of the techniques in <a href="#acks" class="xref">Section 3.2.3</a> to
          regulate the delayed ACK ratio for pure ACKs, it could equally be
          applied after a FIN. But this is not required.<a href="#section-3.2.5-5" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.2.5-6.1">MEASUREMENTS NEEDED: Measurements are needed to learn how the
              deployed base of network elements and servers react to FIN
              packets marked with the ECT(0)/ECT(1)/CE codepoints,
              i.e. whether they are dropped, codepoint cleared or
              processed.<a href="#section-3.2.5-6.1" class="pilcrow">¶</a>
</li>
          </ul>
</section>
<div id="genecn_sec_ECT_RST">
<section id="section-3.2.6">
          <h4 id="name-rst-send">
<a href="#section-3.2.6" class="section-number selfRef">3.2.6. </a><a href="#name-rst-send" class="section-name selfRef">RST (Send)</a>
          </h4>
<p id="section-3.2.6-1">A TCP implementation can set ECT on a RST.<a href="#section-3.2.6-1" class="pilcrow">¶</a></p>
<p id="section-3.2.6-2">See <a href="#genecn_sec_rcv_RST" class="xref">Section 3.3.5</a> for the implications if a
          host receives a CE-marked RST.<a href="#section-3.2.6-2" class="pilcrow">¶</a></p>
<p id="section-3.2.6-3">A congestion response to a CE-marking on a RST is not required
          (and actually not possible).<a href="#section-3.2.6-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.2.6-4.1">MEASUREMENTS NEEDED: Measurements are needed to learn how the
              deployed base of network elements and servers react to RST
              packets marked with the ECT(0)/ECT(1)/CE codepoints,
              i.e. whether they are dropped, codepoint cleared or
              processed.<a href="#section-3.2.6-4.1" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.2.6-5">Implementers SHOULD ensure that RST packets (and control packets
          generally) are always sent out with the same ECN field regardless of
          the TCP state machine. Otherwise the ECN field could reveal internal
          TCP state. For instance, the ECN field on a RST ought not to reveal
          any distinction between a non-listening port, a recently in-use
          port, and a closed session port.<a href="#section-3.2.6-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genect_sec_ECT_reXMT">
<section id="section-3.2.7">
          <h4 id="name-retransmissions-send">
<a href="#section-3.2.7" class="section-number selfRef">3.2.7. </a><a href="#name-retransmissions-send" class="section-name selfRef">Retransmissions (Send)</a>
          </h4>
<p id="section-3.2.7-1">For the ECN++ experiment, the TCP sender will set ECT on
          retransmitted segments. It can ignore the prohibition in section
          6.1.5 of RFC 3168 against setting ECT on retransmissions, as per
          Section 4.3 of <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-3.2.7-1" class="pilcrow">¶</a></p>
<p id="section-3.2.7-2">See <a href="#genecn_sec_rcv_reXMT" class="xref">Section 3.3.6</a> for the implications if
          a host receives a CE-marked retransmission.<a href="#section-3.2.7-2" class="pilcrow">¶</a></p>
<p id="section-3.2.7-3">If the TCP sender receives feedback that a retransmitted packet
          was CE-marked, it will react as it would to any feedback of
          CE-marking on a data packet.<a href="#section-3.2.7-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.2.7-4.1">MEASUREMENTS NEEDED: Measurements are needed to learn how the
              deployed base of network elements and servers react to
              retransmissions marked with the ECT(0)/ECT(1)/CE codepoints,
              i.e. whether they are dropped, codepoint cleared or
              processed.<a href="#section-3.2.7-4.1" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="genect_sec_gen_fall-back">
<section id="section-3.2.8">
          <h4 id="name-general-fall-back-for-any-c">
<a href="#section-3.2.8" class="section-number selfRef">3.2.8. </a><a href="#name-general-fall-back-for-any-c" class="section-name selfRef">General Fall-back for any Control Packet or Retransmission</a>
          </h4>
<p id="section-3.2.8-1">Extensive measurements in fixed and mobile networks <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span> have found no evidence of blockages due to
          ECT being set on any type of TCP control packet.<a href="#section-3.2.8-1" class="pilcrow">¶</a></p>
<p id="section-3.2.8-2">In case traversal problems arise in future, fall-back measures
          have been specified above, but only for the cases where ECT on the
          initial packet of a half-connection (SYN or SYN-ACK) is persistently
          failing to get through.<a href="#section-3.2.8-2" class="pilcrow">¶</a></p>
<p id="section-3.2.8-3">Fall-back measures for blockage of ECT on other TCP control
          packets MAY be implemented. However they are not specified here
          given the lack of any evidence they will be needed. <a href="#genect_sec_gen_fall-back_justify" class="xref">Section 4.9</a> justifies this advice in
          more detail.<a href="#section-3.2.8-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
<section id="section-3.3">
        <h3 id="name-receiver-behaviour">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-receiver-behaviour" class="section-name selfRef">Receiver Behaviour</a>
        </h3>
<p id="section-3.3-1">The present ECN++ specification primarily concerns the behaviour
        for sending TCP control packets or retransmissions. Below are a few
        changes to the receive side of an implementation that are recommended
        while updating its send side. Nonetheless, where deployment is
        concerned, ECN++ is still a sender-only deployment, because it does
        not depend on receivers complying with any of these
        recommendations.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<div id="genecn_sec_rcv_general">
<section id="section-3.3.1">
          <h4 id="name-receiver-behaviour-for-any-">
<a href="#section-3.3.1" class="section-number selfRef">3.3.1. </a><a href="#name-receiver-behaviour-for-any-" class="section-name selfRef">Receiver Behaviour for Any TCP Control Packet or Retransmission</a>
          </h4>
<p id="section-3.3.1-1">RFC8311 is a standards track update to RFC 3168 in order to
          (amongst other things) "...allow the use of ECT codepoints on SYN
          packets, pure acknowledgement packets, window probe packets, and
          retransmissions of packets..., provided that the changes from RFC
          3168 are documented in an Experimental RFC in the IETF document
          stream."<a href="#section-3.3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.3.1-2">Section 4.3 of RFC 8311 amends every statement in RFC 3168 that
          precludes the use of ECT on control packets and retransmissions to
          add "unless otherwise specified by an Experimental RFC in the IETF
          document stream". The present specification is such an Experimental
          RFC. Therefore, In order for the present RFC 8311 experiment to be
          useful, TCP receivers will need to satisfy the following
          requirements:<a href="#section-3.3.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.3.1-3.1">Any TCP implementation SHOULD accept receipt of any valid TCP
              control packet or retransmission irrespective of its IP/ECN
              field. If any existing implementation does not, it SHOULD be
              updated to do so.<a href="#section-3.3.1-3.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.3.1-3.2">A TCP implementation taking part in the experiments proposed
              here MUST accept receipt of any valid TCP control packet or
              retransmission irrespective of its IP/ECN field.<a href="#section-3.3.1-3.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.3.1-4">The following sections give further requirements specific
          to each type of control packet.<a href="#section-3.3.1-4" class="pilcrow">¶</a></p>
<p id="section-3.3.1-5">These measures are derived from the robustness principle of "...
          be liberal in what you accept from others", not only to ensure
          compatibility with the present experimental specification, but also
          any future protocol changes that allow ECT on any TCP packet.<a href="#section-3.3.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_rcv_SYN">
<section id="section-3.3.2">
          <h4 id="name-syn-receive">
<a href="#section-3.3.2" class="section-number selfRef">3.3.2. </a><a href="#name-syn-receive" class="section-name selfRef">SYN (Receive)</a>
          </h4>
<p id="section-3.3.2-1">RFC 3168 negotiates the use of ECN for the connection end-to-end
          using the ECN flags in the TCP header. RFC 3168 originally said that
          "A host MUST NOT set ECT on SYN ... packets." but it was silent as
          to what a TCP server ought to do if it receives a SYN packet with a
          non-zero IP/ECN field anyway.<a href="#section-3.3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.3.2-2">For the avoidance of doubt, the normative statements for all TCP
          control packets in <a href="#genecn_sec_rcv_general" class="xref">Section 3.3.1</a> are
          interpreted for the specific case when a SYN is received as
          follows:<a href="#section-3.3.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.3.2-3.1">Any TCP server implementation SHOULD accept receipt of a
              valid SYN that requests ECN support for the connection,
              irrespective of the IP/ECN field of the SYN. If any existing
              implementation does not, it SHOULD be updated to do so.<a href="#section-3.3.2-3.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.3.2-3.2">A TCP implementation taking part in the ECN++ experiment MUST
              accept receipt of a valid SYN, irrespective of its IP/ECN
              field.<a href="#section-3.3.2-3.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.3.2-3.3">If the SYN is CE-marked and the server has no logic to feed
              back a CE mark on a SYN-ACK (e.g. it does not support
              AccECN), it has to ignore the CE-mark (the client detects this
              case and behaves conservatively in mitigation - see <a href="#genect_sec_SYN-response" class="xref">Section 3.2.1.3</a>).<a href="#section-3.3.2-3.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.3.2-4">Rationale: At the time of the writing, some implementations of
          TCP servers (see <a href="#genecn_sec_unexpected_ECN_Server" class="xref">Section 4.2.2.2</a>)
          assume that, if a host receives a SYN with a non-zero IP/ECN field,
          it must be due to network mangling, and they disable ECN for the
          rest of the connection. <a href="#genecn_sec_unexpected_ECN_Server" class="xref">Section 4.2.2.2</a> cites a measurement
          study run in 2017 that found no occurrence of this type of network
          mangling. However, a year earlier, when ECN was enabled on
          connections from Apple clients, there was a case of a whole network
          that re-marked the ECN field of every packet to CE (it was rapidly
          fixed).<a href="#section-3.3.2-4" class="pilcrow">¶</a></p>
<p id="section-3.3.2-5">When ECN was not allowed on SYNs, it made sense to look for a
          non-zero ECN field on the SYN to detect this type of network
          mangling. But now that ECN is being allowed on a SYN, detection
          needs to be more nuanced. A server needs to disable the test on the
          SYN alone for AccECN SYNs (which was done for Linux RFC 3168 servers
          in 2019 <span>[<a href="#relax-strict-ecn" class="xref">relax-strict-ecn</a>]</span>) and for RFC 3168 SYNs it
          needs to watch for three or four packets all set to CE at the start
          of a flow. If such mangling is indeed now so rare, it would also be
          preferable to log each case detected and manually report it to the
          responsible network, so that the problem will eventually be
          eliminated.<a href="#section-3.3.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_rcv_ACK">
<section id="section-3.3.3">
          <h4 id="name-pure-ack-receive">
<a href="#section-3.3.3" class="section-number selfRef">3.3.3. </a><a href="#name-pure-ack-receive" class="section-name selfRef">Pure ACK (Receive)</a>
          </h4>
<p id="section-3.3.3-1">For the avoidance of doubt, the normative statements for all TCP
          control packets in <a href="#genecn_sec_rcv_general" class="xref">Section 3.3.1</a> are
          interpreted for the specific case when a Pure ACK is received as
          follows:<a href="#section-3.3.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.3.3-2.1">Any TCP implementation SHOULD accept receipt of a pure ACK
              with a non-zero ECN field, despite current RFCs precluding the
              sending of such packets.<a href="#section-3.3.3-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.3.3-2.2">A TCP implementation taking part in the ECN++ experiment MUST
              accept receipt of a pure ACK with a non-zero ECN field.<a href="#section-3.3.3-2.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.3.3-3">The question of whether and how the receiver of pure ACKs is
          required to feed back any CE marks on them is outside the scope of
          the present specification because it is a matter for the relevant
          feedback specification (<span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> or <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span>). AccECN feedback is required
          to count CE marking of any control packet including pure ACKs.
          Whereas RFC 3168 is silent on this point, so feedback of CE-markings
          might be implementation specific (see <a href="#genecn_sec_cwnd_response_pure_ACK" class="xref">Section 4.4.1.1</a>).<a href="#section-3.3.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_rcv_FIN">
<section id="section-3.3.4">
          <h4 id="name-fin-receive">
<a href="#section-3.3.4" class="section-number selfRef">3.3.4. </a><a href="#name-fin-receive" class="section-name selfRef">FIN (Receive)</a>
          </h4>
<p id="section-3.3.4-1">The TCP data receiver MUST ignore the CE codepoint on incoming
          FINs that fail any validity check. The validity check in section 5.2
          of <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span> is RECOMMENDED.<a href="#section-3.3.4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_rcv_RST">
<section id="section-3.3.5">
          <h4 id="name-rst-receive">
<a href="#section-3.3.5" class="section-number selfRef">3.3.5. </a><a href="#name-rst-receive" class="section-name selfRef">RST (Receive)</a>
          </h4>
<p id="section-3.3.5-1">The "challenge ACK" approach to checking the validity of RSTs
          (section 3.2 of <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span> is RECOMMENDED at the data
          receiver.<a href="#section-3.3.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_rcv_reXMT">
<section id="section-3.3.6">
          <h4 id="name-retransmissions-receive">
<a href="#section-3.3.6" class="section-number selfRef">3.3.6. </a><a href="#name-retransmissions-receive" class="section-name selfRef">Retransmissions (Receive)</a>
          </h4>
<p id="section-3.3.6-1">The TCP data receiver MUST ignore the CE codepoint on incoming
          segments that fail any validity check. The validity check in section
          5.2 of <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span> is RECOMMENDED. This will
          effectively mitigate an attack that uses spoofed data packets to
          fool the receiver into feeding back spoofed congestion indications
          to the sender, which in turn would be fooled into continually
          reducing its congestion window.<a href="#section-3.3.6-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</section>
</div>
<div id="arguments">
<section id="section-4">
      <h2 id="name-rationale">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-rationale" class="section-name selfRef">Rationale</a>
      </h2>
<p id="section-4-1">This section is informative, not normative. It presents
      counter-arguments against the justifications in the RFC series for
      disabling ECN on TCP control segments and retransmissions. It also gives
      rationale for why ECT is safe on control segments that have not, so far,
      been mentioned in the RFC series. First it addresses over-arching
      arguments used for most packet types, then it addresses the specific
      arguments for each packet type in turn.<a href="#section-4-1" class="pilcrow">¶</a></p>
<div id="reliability">
<section id="section-4.1">
        <h3 id="name-the-reliability-argument">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-the-reliability-argument" class="section-name selfRef">The Reliability Argument</a>
        </h3>
<p id="section-4.1-1">Section 5.2 of RFC 3168 states:<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.1-2.1">"To ensure the reliable delivery of the congestion indication
            of the CE codepoint, an ECT codepoint MUST NOT be set in a packet
            unless the loss of that packet [at a subsequent node] in the
            network would be detected by the end nodes and interpreted as an
            indication of congestion."<a href="#section-4.1-2.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.1-3">We believe this argument is misplaced. TCP does not deliver most
        control packets reliably. So it is more important to allow control
        packets to be ECN-capable, which greatly improves reliable delivery of
        the control packets themselves (see motivation in <a href="#genecn_sec_motivation" class="xref">Section 1.1</a>). ECN also improves the reliability
        and latency of delivery of any congestion notification on control
        packets, particularly because TCP does not detect the loss of most
        types of control packet anyway. Both these points outweigh by far the
        concern that a CE marking applied to a control packet by one node
        might subsequently be dropped by another node.<a href="#section-4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.1-4">The principle to determine whether a packet can be ECN-capable
        ought to be "do no extra harm", meaning that the reliability of a
        congestion signal's delivery ought to be no worse with ECN than
        without. In particular, setting the CE codepoint on the very same
        packet that would otherwise have been dropped fulfills this criterion,
        since either the packet is delivered and the CE signal is delivered to
        the endpoint, or the packet is dropped and the original congestion
        signal (packet loss) is delivered to the endpoint.<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1-5">The concern about a CE marking being dropped at a subsequent node
        might be motivated by the idea that ECN-marking a packet at the first
        node does not remove the packet, so it could go on to worsen
        congestion at a subsequent node. However, it is not useful to reason
        about congestion by considering single packets. The departure rate
        from the first node will generally be the same (fully utilized) with
        or without ECN, so this argument does not apply.<a href="#section-4.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_rationale_SYN">
<section id="section-4.2">
        <h3 id="name-syns">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-syns" class="section-name selfRef">SYNs</a>
        </h3>
<p id="section-4.2-1">RFC 5562 presents two arguments against ECT marking of SYN packets
        (quoted verbatim):<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.2-2.1">"First, when the TCP SYN packet is sent, there are no
            guarantees that the other TCP endpoint (node B in Figure 2) is
            ECN-Capable, or that it would be able to understand and react if
            the ECN CE codepoint was set by a congested router.<a href="#section-4.2-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal ulEmpty" id="section-4.2-2.2">Second, the ECN-Capable codepoint in TCP SYN packets could be
            misused by malicious clients to "improve" the well-known TCP SYN
            attack. By setting an ECN-Capable codepoint in TCP SYN packets, a
            malicious host might be able to inject a large number of TCP SYN
            packets through a potentially congested ECN-enabled router,
            congesting it even further."<a href="#section-4.2-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.2-3">The first point actually describes two subtly different
        issues. So below three arguments are countered in turn.<a href="#section-4.2-3" class="pilcrow">¶</a></p>
<div id="genecn_sec_CE-missed">
<section id="section-4.2.1">
          <h4 id="name-argument-1a-unrecognized-ce">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-argument-1a-unrecognized-ce" class="section-name selfRef">Argument 1a: Unrecognized CE on the SYN</a>
          </h4>
<p id="section-4.2.1-1">This argument certainly applied at the time RFC 5562 was written,
          when no ECN responder mechanism had any logic to recognize a CE
          marking on a SYN and, even if logic were added, there was no field
          in the SYN-ACK to feed it back. The problem was that, during the
          3WHS, the flag in the TCP header for ECN feedback (called Echo
          Congestion Experienced) had been overloaded to negotiate the use of
          ECN itself.<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1-2">The accurate ECN (AccECN) protocol <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> has since been designed to
          solve this problem. Two features are important here:<a href="#section-4.2.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1-3">
<li id="section-4.2.1-3.1">An AccECN server uses the 3 'ECN' bits in the TCP header of
              the SYN-ACK to respond to the client. 4 of the possible 8
              codepoints provide enough space for the server to feed back
              which of the 4 IP/ECN codepoints was on the incoming SYN
              (including CE of course).<a href="#section-4.2.1-3.1" class="pilcrow">¶</a>
</li>
            <li id="section-4.2.1-3.2">If any of these 4 codepoints are in the SYN-ACK, it confirms
              that the server supports AccECN and, if another codepoint is
              returned, it confirms that the server doesn't support
              AccECN.<a href="#section-4.2.1-3.2" class="pilcrow">¶</a>
</li>
          </ol>
<p id="section-4.2.1-4">This still does not seem to allow a client to set ECT on a SYN,
          it only finds out whether the server would have supported it
          afterwards. The trick the client uses for ECN++ is to set ECT on the
          SYN optimistically then, if the SYN-ACK reveals that the server
          wouldn't have understood CE on the SYN, the client responds
          conservatively as if the SYN was marked with CE.<a href="#section-4.2.1-4" class="pilcrow">¶</a></p>
<p id="section-4.2.1-5">The recommended conservative congestion response is to reduce the
          initial window, which does not affect the performance of very
          popular protocols such as HTTP, since it is extremely rare for an
          HTTP client to send more than one packet as its initial request
          anyway (for data on HTTP/1 &amp; HTTP/2 request sizes see Fig 3 in
          <span>[<a href="#Manzoor17" class="xref">Manzoor17</a>]</span>). Any clients that do frequently use a
          larger initial window for their first message to the server can
          cache which servers will not understand ECT on a SYN (see <a href="#genecn_sec_SYN_cache_rationale" class="xref">Section 4.2.3</a> below). If caching is not
          practical, such clients could reduce the initial window to say IW2
          or IW3.<a href="#section-4.2.1-5" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.2.1-6.1">EXPERIMENTATION NEEDED: Experiments will be needed to
              determine any better strategy for reducing IW in response to
              congestion on a SYN, when the server does not support congestion
              feedback on the SYN-ACK (whether cached or discovered
              explicitly).<a href="#section-4.2.1-6.1" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="genecn_sec_unexpected_ECN">
<section id="section-4.2.2">
          <h4 id="name-argument-1b-ect-considered-">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-argument-1b-ect-considered-" class="section-name selfRef">Argument 1b: ECT Considered Invalid on the SYN</a>
          </h4>
<p id="section-4.2.2-1">Given, until now, ECT-marked SYN packets have been prohibited, it
          cannot be assumed they will be accepted, by TCP middleboxes or
          servers.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<section id="section-4.2.2.1">
            <h5 id="name-ect-on-syn-considered-inval">
<a href="#section-4.2.2.1" class="section-number selfRef">4.2.2.1. </a><a href="#name-ect-on-syn-considered-inval" class="section-name selfRef">ECT on SYN Considered Invalid by Middleboxes</a>
            </h5>
<p id="section-4.2.2.1-1">According to a study using 2014 data <span>[<a href="#ecn-pam" class="xref">ecn-pam</a>]</span>
            from a limited range of fixed vantage points, for the top 1M Alexa
            web sites, adding the ECN capability to SYNs was increasing
            connection establishment failures by about 0.4%.<a href="#section-4.2.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2.1-2">From a wider range of fixed and mobile vantage points, a more
            recent study in Jan-May 2017 <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span> found no
            occurrences of blocking of ECT on SYNs. However, in more than half
            the mobile networks tested it found wiping of the ECN codepoint at
            the first hop.<a href="#section-4.2.2.1-2" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.2.2.1-3.1">MEASUREMENTS NEEDED: As wiping at the first hop is
                remedied, measurements will be needed to check whether SYNs
                with ECT are sometimes blocked deeper into the path.<a href="#section-4.2.2.1-3.1" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.2.2.1-4">Silent failures introduce a retransmission timeout delay
            (default 1 second) at the initiator before it attempts any fall
            back strategy (whereas explicit RSTs can be dealt with
            immediately). Ironically, making SYNs ECN-capable is intended to
            avoid the timeout when a SYN is lost due to congestion.
            Fortunately, if there is any discard of ECN-capable SYNs due to
            policy, it will occur predictably, not randomly like congestion.
            So the initiator should be able to avoid it by caching those sites
            that do not support ECN-capable SYNs (see the last paragraph of
            <a href="#genecn_sec_SYN_cache" class="xref">Section 3.2.1.2</a>).<a href="#section-4.2.2.1-4" class="pilcrow">¶</a></p>
</section>
<div id="genecn_sec_unexpected_ECN_Server">
<section id="section-4.2.2.2">
            <h5 id="name-ect-on-syn-considered-invali">
<a href="#section-4.2.2.2" class="section-number selfRef">4.2.2.2. </a><a href="#name-ect-on-syn-considered-invali" class="section-name selfRef">ECT on SYN Considered Invalid by Servers</a>
            </h5>
<p id="section-4.2.2.2-1">A study conducted in Nov 2017 <span>[<a href="#Kuehlewind18" class="xref">Kuehlewind18</a>]</span>
            found that, of the 82% of the Alexa top 50k web servers that
            supported ECN, 84% disabled ECN if the IP/ECN field on the SYN was
            ECT0, CE or either. Given most web servers use Linux, this
            behaviour can most likely be traced to a patch contributed in May
            2012 that was first distributed in v3.5 of the Linux kernel <span>[<a href="#strict-ecn" class="xref">strict-ecn</a>]</span>. The comment says "RFC3168 : 6.1.1 SYN
            packets must not have ECT/ECN bits set. If we receive a SYN packet
            with these bits set, it means a network is playing bad games with
            TOS bits. In order to avoid possible false congestion
            notifications, we disable TCP ECN negociation." Of course, some of
            the 84% might be due to similar code in other OSs.<a href="#section-4.2.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-2">For brevity we shall call this the "over-strict" ECN test,
            because it is over-conservative with what it accepts, contrary to
            Postel's robustness principle. A robust protocol will not usually
            assume network mangling without comparing with the value
            originally sent, and one packet is not sufficient to make an
            assumption with such irreversible consequences anyway.<a href="#section-4.2.2.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-3">Ironically, networks rarely seem to alter the IP/ECN field on a
            SYN from zero to non-zero anyway. In a study conducted in Jan-May
            2017 over millions of paths from vantage points in a few dozen
            mobile and fixed networks <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span>, no such
            transition was observed. With such a small or non-existent
            incidence of this sort of network mangling, it would be preferable
            to report any residual problem paths so that they can be
            fixed.<a href="#section-4.2.2.2-3" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-4">Whatever, the widespread presence of this 'over-strict' test
            proves that RFC 5562 was correct to expect that ECT would be
            considered invalid on SYNs. Nonetheless, it is not an
            insurmountable problem - the over-strict test in Linux was patched
            in Apr 2019 <span>[<a href="#relax-strict-ecn" class="xref">relax-strict-ecn</a>]</span> and caching can work
            round it where previous versions of Linux are running. The
            prevalence of these "over-strict" ECN servers makes it challenging
            to cache them all. However, <a href="#genecn_sec_SYN_cache_rationale" class="xref">Section 4.2.3</a> below explains how a
            cache of limited size can alleviate this problem for a client's
            most popular sites.<a href="#section-4.2.2.2-4" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-5">For the future, <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span> updates RFC 3168 to
            clarify that the IP/ECN field does not have to be zero on a SYN if
            documented in an experimental RFC such as the present ECN++
            specification.<a href="#section-4.2.2.2-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="genecn_sec_SYN_cache_rationale">
<section id="section-4.2.3">
          <h4 id="name-caching-strategies-for-ect-">
<a href="#section-4.2.3" class="section-number selfRef">4.2.3. </a><a href="#name-caching-strategies-for-ect-" class="section-name selfRef">Caching Strategies for ECT on SYNs</a>
          </h4>
<p id="section-4.2.3-1">Given the server handling of ECN on SYNs outlined in <a href="#genecn_sec_unexpected_ECN_Server" class="xref">Section 4.2.2.2</a> above, an initiator
          might combine AccECN with three candidate caching strategies for
          setting ECT on a SYN:<a href="#section-4.2.3-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="olPercent" id="section-4.2.3-2">
<dt>(S1):</dt>
<dd id="section-4.2.3-2.1">
              <p id="section-4.2.3-2.1.1">Pessimistic ECT and cache successes: The initiator always
              requests AccECN, but by default without ECT on the SYN. Then it
              caches those servers that confirm that they support AccECN as
              'ECT SYN OK'. On a subsequent connection to any server that
              supports AccECN, the initiator can then set ECT on the SYN. When
              connecting to other servers (non-ECN or classic ECN) it will not
              set ECT on the SYN, so it will not fail the 'over-strict' ECN
              test.<a href="#section-4.2.3-2.1.1" class="pilcrow">¶</a></p>
<p id="section-4.2.3-2.1.2">Longer term, as servers upgrade to
              AccECN, the initiator is still requesting AccECN, so it will add
              them to the cache and use ECT on subsequent SYNs to those
              servers. However, assuming it has to cap the size of the cache,
              the client will not have the benefit of ECT SYNs to those less
              frequently used AccECN servers expelled from its cache.<a href="#section-4.2.3-2.1.2" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt>(S2):</dt>
<dd id="section-4.2.3-2.2">
              <p id="section-4.2.3-2.2.1">Optimistic ECT: The initiator always requests AccECN and by
              default sets ECT on the SYN. Then, if the server response shows
              it has no AccECN logic (so it cannot feed back a CE mark), the
              initiator conservatively behaves as if the SYN was CE-marked, by
              reducing its initial window.<a href="#section-4.2.3-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="a" class="normal type-a" id="section-4.2.3-2.2.2">
<li id="section-4.2.3-2.2.2.1">No cache.<a href="#section-4.2.3-2.2.2.1" class="pilcrow">¶</a>
</li>
                <li id="section-4.2.3-2.2.2.2">
                  <p id="section-4.2.3-2.2.2.2.1">Cache failures: The optimistic ECT strategy can be
                  improved by caching solely those servers that do not support
                  AccECN as 'ECT SYN NOK'. This would include non-ECN servers
                  and all Classic ECN servers whether 'over-strict' or not. On
                  subsequent connections to these non-AccECN servers, the
                  initiator will still request AccECN but not set ECT on the
                  SYN. Then, the connection can still fall back to Classic
                  ECN, if the server supports it, and the initiator can use
                  its full initial window (if it has enough request data to
                  need it).<a href="#section-4.2.3-2.2.2.2.1" class="pilcrow">¶</a></p>
<p id="section-4.2.3-2.2.2.2.2">Longer term, as servers
                  upgrade to AccECN, the initiator will remove them from the
                  cache and use ECT on subsequent SYNs to that server.<a href="#section-4.2.3-2.2.2.2.2" class="pilcrow">¶</a></p>
<p id="section-4.2.3-2.2.2.2.3">Where an access network operator mediates
                  Internet access via a proxy that does not support AccECN,
                  the optimistic ECT strategy will always fail. This scenario
                  is more likely in mobile networks. Therefore, a mobile host
                  could cache lack of AccECN support per attached access
                  network operator. Whenever it attached to a new operator, it
                  could check a well-known AccECN test server and, if it found
                  no AccECN support, it would add a cache entry for the
                  attached operator. It would only use ECT when neither
                  network nor server were cached. It would only populate its
                  per server cache when not attached to a non-AccECN
                  proxy.<a href="#section-4.2.3-2.2.2.2.3" class="pilcrow">¶</a></p>
</li>
              </ol>
</dd>
            <dd class="break"></dd>
<dt>(S3):</dt>
<dd id="section-4.2.3-2.3">ECT by configuration: In a controlled environment, the
              administrator can make sure that servers support ECN-capable SYN
              packets. Examples of controlled environments are single-tenant
              DCs, and possibly multi-tenant DCs if it is assumed that each
              tenant mostly communicates with its own VMs.<a href="#section-4.2.3-2.3" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.2.3-3">For unmanaged environments like the public Internet,
          pragmatically the choice is between strategies (S1), (S2A) and
          (S2B). The normative specification for ECT on a SYN in <a href="#genecn_sec_SYN" class="xref">Section 3.2.1</a> recommends the "optimistic ECT and cache
          failures" strategy (S2B) but the choice depends on the implementer's
          motivation for using ECN++, and the deployment prevalence of
          different technologies and bug-fixes.<a href="#section-4.2.3-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.3-4.1">The "pessimistic ECT and cache successes" strategy (S1)
              suffers from exposing the initial SYN to the prevailing loss
              level, even if the server supports ECT on SYNs, but only on the
              first connection to each AccECN server. If AccECN becomes widely
              deployed on servers, SYNs to those AccECN servers that are less
              frequently used by the client and therefore don't fit in the
              cache will not benefit from ECN protection at all.<a href="#section-4.2.3-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.2.3-4.2">The "optimistic ECT without a cache" strategy (S2A) is the
              simplest. It would satisfy the goal of an implementer who is
              solely interested in low latency using AccECN and ECN++ and is
              not concerned about fall-back to Classic ECN.<a href="#section-4.2.3-4.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.2.3-4.3">The "optimistic ECT and cache failures" strategy (S2B)
              exploits ECT on SYNs from the very first attempt. But if the
              server turns out to be 'over-strict' it will disable ECN for the
              connection, but only for the first connection if it's one of the
              client's more popular servers that fits in the cache. If the
              server turns out not to support AccECN, the initiator has to
              conservatively limit its initial window, but again only for the
              first connection if it's one of the client's more popular
              servers (and anyway this rarely makes any difference when most
              client requests fit in a single packet).<a href="#section-4.2.3-4.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.2.3-5">Note that, if AccECN deployment grows, caching successes (S1)
          starts off small then grows, while caching failures (S2B) becomes
          large at first, then shrinks. At half-way, the size of the cache has
          to be capped with either approach, so the default behaviour for all
          the servers that do not fit in the cache is as important as the
          behaviour for the popular servers that do fit.<a href="#section-4.2.3-5" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.2.3-6.1">MEASUREMENTS NEEDED: Measurements are needed to determine
              which strategy would be sufficient for any particular client,
              whether a particular client would need different strategies in
              different circumstances and how many occurrences of problems
              would be masked by how few cache entries.<a href="#section-4.2.3-6.1" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.2.3-7">Another strategy would be to send a not-ECT SYN a short delay
          (below the typical lowest RTT) after an ECT SYN and only accept the
          non-ECT connection if it returned first. This would reduce the
          performance penalty for those deploying ECT SYN support. However,
          this 'happy eyeballs' approach becomes complex when multiple
          optional features are all tried on the first SYN (or on multiple
          SYNs), so it is not recommended.<a href="#section-4.2.3-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genecn_sec_SYN_DOS">
<section id="section-4.2.4">
          <h4 id="name-argument-2-dos-attacks">
<a href="#section-4.2.4" class="section-number selfRef">4.2.4. </a><a href="#name-argument-2-dos-attacks" class="section-name selfRef">Argument 2: DoS Attacks</a>
          </h4>
<p id="section-4.2.4-1"><span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span> says that ECT SYN packets could be
          misused by malicious clients to augment "the well-known TCP SYN
          attack". It goes on to say "a malicious host might be able to inject
          a large number of TCP SYN packets through a potentially congested
          ECN-enabled router, congesting it even further."<a href="#section-4.2.4-1" class="pilcrow">¶</a></p>
<p id="section-4.2.4-2">We assume this is a reference to the TCP SYN flood attack (see
          https://en.wikipedia.org/wiki/SYN_flood), which is an attack against
          a responder end point. We assume the idea of this attack is to use
          ECT to get more packets through an ECN-enabled router in preference
          to other non-ECN traffic so that they can go on to use the SYN
          flooding attack to inflict more damage on the responder end point.
          This argument could apply to flooding with any type of packet, but
          we assume SYNs are singled out because their source address is
          easier to spoof, whereas floods of other types of packets are easier
          to block.<a href="#section-4.2.4-2" class="pilcrow">¶</a></p>
<p id="section-4.2.4-3">Mandating Not-ECT in an RFC does not stop attackers using ECT for
          flooding. Nonetheless, if a standard says SYNs are not meant to be
          ECT it would make it legitimate for firewalls to discard them.
          However this would negate the considerable benefit of ECT SYNs for
          compliant transports and seems unnecessary because RFC 3168 already
          provides the means to address this concern. In section 7, RFC 3168
          says "During periods where ... the potential packet marking rate
          would be high, our recommendation is that routers drop packets
          rather then set the CE codepoint..." and this advice is repeated in
          <span>[<a href="#RFC7567" class="xref">RFC7567</a>]</span> (section 4.2.1). This makes it harder for
          flooding packets to gain from ECT.<a href="#section-4.2.4-3" class="pilcrow">¶</a></p>
<p id="section-4.2.4-4"><span>[<a href="#ecn-overload" class="xref">ecn-overload</a>]</span> showed that ECT can only slightly
          augment flooding attacks relative to a non-ECT attack. It was hard
          to overload the link without causing the queue to grow, which in
          turn caused the AQM to disable ECN and switch to drop, thus negating
          any advantage of using ECT. This was true even with the switch-over
          point set to 25% drop probability (i.e. the arrival rate was
          133% of the link rate).<a href="#section-4.2.4-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="genecn_sec_argue_SYN-ACK">
<section id="section-4.3">
        <h3 id="name-syn-acks">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-syn-acks" class="section-name selfRef">SYN-ACKs</a>
        </h3>
<p id="section-4.3-1">The proposed approach in <a href="#genecn_sec_SYN-ACK" class="xref">Section 3.2.2</a> for
        experimenting with ECN-capable SYN-ACKs is effectively identical to
        the scheme called ECN+ <span>[<a href="#ECN-PLUS" class="xref">ECN-PLUS</a>]</span>. In 2005, the ECN+
        paper demonstrated that it could reduce the average Web response time
        by an order of magnitude. It also argued that adding ECT to SYN-ACKs
        did not raise any new security vulnerabilities.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<div id="genecn_sec_CE-missed-SYN-ACK">
<section id="section-4.3.1">
          <h4 id="name-possibility-of-unrecognized">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-possibility-of-unrecognized" class="section-name selfRef">Possibility of Unrecognized CE on the SYN-ACK</a>
          </h4>
<p id="section-4.3.1-1">The feedback behaviour by the initiator in response to a
          CE-marked SYN-ACK from the responder depends on whether classic ECN
          feedback <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> or AccECN feedback <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span> has been negotiated. In either
          case no change is required to RFC 3168 or the AccECN
          specification.<a href="#section-4.3.1-1" class="pilcrow">¶</a></p>
<p id="section-4.3.1-2">Some classic ECN client implementations might ignore a CE-mark on
          a SYN-ACK, or even ignore a SYN-ACK packet entirely if it is set to
          ECT or CE. This is a possibility because an RFC 3168 implementation
          would not necessarily expect a SYN-ACK to be ECN-capable. This issue
          already came up when the IETF first decided to experiment with ECN
          on SYN-ACKs <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span> and it was decided to go ahead
          without any extra precautionary measures. This was because the
          probability of encountering the problem was believed to be low and
          the harm if the problem arose was also low (see Appendix B of RFC
          5562).<a href="#section-4.3.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="rationale-syn-ack-congestion-resp">
<section id="section-4.3.2">
          <h4 id="name-response-to-congestion-on-a">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-response-to-congestion-on-a" class="section-name selfRef">Response to Congestion on a SYN-ACK</a>
          </h4>
<p id="section-4.3.2-1">The IETF has already specified an experiment with ECN-capable
          SYN-ACK packets <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span>. It was inspired by the
          ECN+ paper, but it specified a much more conservative congestion
          response to a CE-marked SYN-ACK, called ECN+/TryOnce. This required
          the server to reduce its initial window to 1 segment (like ECN+),
          but then the server had to send a second SYN-ACK and wait for its
          ACK before it could continue with its initial window of 1 SMSS. The
          second SYN-ACK of this 5-way handshake had to carry no data, and had
          to disable ECN, but no justification was given for these last two
          aspects.<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<p id="section-4.3.2-2">The present ECN++ experimental specification obsoletes RFC 5562
          because it uses the ECN+ congestion response, not ECN+/TryOnce.
          First we argue against the rationale for ECN+/TryOnce given in
          sections 4.4 and 6.2 of <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span>. It starts with a
          rather too literal interpretation of the requirement in RFC 3168
          that says TCP's response to a single CE mark has to be "essentially
          the same as the congestion control response to a *single* dropped
          packet." TCP's response to a dropped initial (SYN or SYN-ACK) packet
          is to wait for the retransmission timer to expire (currently 1s).
          However, this long delay assumes the worst case between two possible
          causes of the loss: a) heavy overload; or b) the normal
          capacity-seeking behaviour of other TCP flows. When the network is
          still delivering CE-marked packets, it implies that there is an AQM
          at the bottleneck and that it is not overloaded. This is because an
          AQM under overload will disable ECN (as recommended in section 7 of
          RFC 3168 and repeated in section 4.2.1 of RFC 7567). So scenario (a)
          can be ruled out. Therefore, TCP's response to a CE-marked SYN-ACK
          can be similar to its response to the loss of <em>any</em>
          packet, rather than backing off as if the special <em>initial</em> packet of a flow has been lost.<a href="#section-4.3.2-2" class="pilcrow">¶</a></p>
<p id="section-4.3.2-3">How TCP responds to the loss of any single packet depends what it
          has just been doing. But there is not really a precedent for TCP's
          response when it experiences a CE mark having sent only one (small)
          packet. If TCP had been adding one segment per RTT, it would have
          halved its congestion window, but it hasn't established a congestion
          window yet. If it had been exponentially increasing it would have
          exited slow start, but it hasn't started exponentially increasing
          yet so it hasn't established a slow-start threshold.<a href="#section-4.3.2-3" class="pilcrow">¶</a></p>
<p id="section-4.3.2-4">Therefore, we have to work out a reasoned argument for what to
          do. If an AQM is CE-marking packets, it implies there is already a
          queue and it is probably already somewhere around the AQM's
          operating point - it is unlikely to be well below and it might be
          well above. So, the more data packets that the client sends in its
          IW, the more likely at least one will be CE marked, leading it to
          exit slow-start early. On the other hand, it is highly unlikely that
          the SYN-ACK itself pushed the AQM into congestion, so it will be
          safe to introduce another single segment immediately (1 RTT after
          the SYN-ACK). Therefore, starting to probe for capacity with a slow
          start from an initial window of 1 segment seems appropriate to the
          circumstances. This is the approach adopted in <a href="#genecn_sec_SYN-ACK" class="xref">Section 3.2.2</a>.<a href="#section-4.3.2-4" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.3.2-5.1">EXPERIMENTATION NEEDED: Experiments will be needed to check
              the above reasoning and determine any better strategy for
              reducing IW in response to congestion on a SYN-ACK (or a
              SYN).<a href="#section-4.3.2-5.1" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="genecn_sec_Fall-Back_SYN-ACK">
<section id="section-4.3.3">
          <h4 id="name-fall-back-if-ect-syn-ack-fa">
<a href="#section-4.3.3" class="section-number selfRef">4.3.3. </a><a href="#name-fall-back-if-ect-syn-ack-fa" class="section-name selfRef">Fall-Back if ECT SYN-ACK Fails</a>
          </h4>
<p id="section-4.3.3-1">An alternative to the server caching failed connection attempts
          would be for the server to rely on the client caching failed
          attempts (on the basis that the client would cache a failure whether
          ECT was blocked on the SYN or the SYN-ACK). This strategy cannot be
          used if the SYN does not request AccECN support. It works as
          follows: if the server receives a SYN that requests AccECN support
          but is set to not-ECT, it replies with a SYN-ACK also set to
          not-ECT. If a middlebox only blocks ECT on SYNs, not SYN-ACKs, this
          strategy might disable ECN on a SYN-ACK when it did not need to, but
          at least it saves the server from maintaining a cache.<a href="#section-4.3.3-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="genecn_sec_argue_pure_ACK">
<section id="section-4.4">
        <h3 id="name-pure-acks">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-pure-acks" class="section-name selfRef">Pure ACKs</a>
        </h3>
<p id="section-4.4-1">Section 5.2 of RFC 3168 gives the following arguments for not
        allowing the ECT marking of pure ACKs (ACKs not piggy-backed on data):<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.4-2.1">"To ensure the reliable delivery of the congestion indication
            of the CE codepoint, an ECT codepoint MUST NOT be set in a packet
            unless the loss of that packet in the network would be detected by
            the end nodes and interpreted as an indication of congestion.<a href="#section-4.4-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal ulEmpty" id="section-4.4-2.2">Transport protocols such as TCP do not necessarily detect all
            packet drops, such as the drop of a "pure" ACK packet; for
            example, TCP does not reduce the arrival rate of subsequent ACK
            packets in response to an earlier dropped ACK packet. Any proposal
            for extending ECN-Capability to such packets would have to address
            issues such as the case of an ACK packet that was marked with the
            CE codepoint but was later dropped in the network. We believe that
            this aspect is still the subject of research, so this document
            specifies that at this time, "pure" ACK packets MUST NOT indicate
            ECN-Capability."<a href="#section-4.4-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.4-3">Later on, in section 6.1.4 it reads:<a href="#section-4.4-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.4-4.1">"For the current generation of TCP congestion control
            algorithms, pure acknowledgement packets (e.g., packets that do
            not contain any accompanying data) MUST be sent with the not-ECT
            codepoint. Current TCP receivers have no mechanisms for reducing
            traffic on the ACK-path in response to congestion notification.
            Mechanisms for responding to congestion on the ACK-path are areas
            for current and future research. (One simple possibility would be
            for the sender to reduce its congestion window when it receives a
            pure ACK packet with the CE codepoint set). For current TCP
            implementations, a single dropped ACK generally has only a very
            small effect on the TCP's sending rate."<a href="#section-4.4-4.1" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.4-5">We next address each of the arguments presented above.<a href="#section-4.4-5" class="pilcrow">¶</a></p>
<p id="section-4.4-6">The first argument is a specific instance of the reliability
        argument for the case of pure ACKs. This has already been addressed by
        countering the general reliability argument in <a href="#reliability" class="xref">Section 4.1</a>.<a href="#section-4.4-6" class="pilcrow">¶</a></p>
<p id="section-4.4-7">The second argument says that ECN ought not to be enabled unless
        there is a mechanism to respond to it. This argument actually
        comprises three sub-arguments:<a href="#section-4.4-7" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.4-8">
          <dt id="section-4.4-8.1">Mechanism feasibility:</dt>
          <dd style="margin-left: 1.5em" id="section-4.4-8.2">If ECN is enabled on Pure
            ACKs, are there, or could there be, suitable mechanisms to detect,
            feed back and respond to ECN-marked Pure ACKs?<a href="#section-4.4-8.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.4-8.3">Do no extra harm:</dt>
          <dd style="margin-left: 1.5em" id="section-4.4-8.4">There has never been a mechanism
            to respond to loss of non-ECN Pure ACKs. So it seems that adding
            ECN without a response mechanism will do no extra harm to others,
            while improving a connection's own performance (because loss of an
            ACK holds back new data). However, if the end systems have no
            response mechanism, ECN Pure ACKs do slightly more harm than
            non-ECN, because the AQM doesn't immediately clear ECT packets
            from the queue until it reaches overload and disables ECN.<a href="#section-4.4-8.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.4-8.5">Standards policy:</dt>
          <dd style="margin-left: 1.5em" id="section-4.4-8.6">Even if there were no harm to
            others, does it set an undesirable precedent to allow a flow to
            use ECN to protect its Pure ACKs from loss, when there is no
            mechanism to respond to ECN-marking?<a href="#section-4.4-8.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-4.4-9">The last two arguments involve value judgements, but they both
        depend on the concrete technical question of mechanism feasibility,
        which will therefore be addressed first in <a href="#genecn_sec_mechanism_pure_ACK" class="xref">Section 4.4.1</a> below. Then <a href="#genecn_sec_summary_pure_ACK" class="xref">Section 4.4.2</a> draws conclusions by addressing
        the value judgements in the other two questions.<a href="#section-4.4-9" class="pilcrow">¶</a></p>
<div id="genecn_sec_mechanism_pure_ACK">
<section id="section-4.4.1">
          <h4 id="name-mechanisms-to-respond-to-ce">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-mechanisms-to-respond-to-ce" class="section-name selfRef">Mechanisms to Respond to CE-Marked Pure ACKs</a>
          </h4>
<p id="section-4.4.1-1">The question of whether the receiver of pure ACKs is required to
          detect and feed back any CE-marking is outside the scope of the
          present specification - it is a matter for the relevant feedback
          specification (classic ECN <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> and AccECN <span>[<a href="#I-D.ietf-tcpm-accurate-ecn" class="xref">I-D.ietf-tcpm-accurate-ecn</a>]</span>). The response to congestion
          feedback is also out of scope, because it would be defined in the
          base TCP congestion control specification <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>
          or its variants.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">Nonetheless, in order to decide whether the present ECN++
          experimental specification should require a host to set ECT on pure
          ACKs, we only need to know whether a response mechanism would be
          feasible - we do not have to standardize it. So the bullets below
          assess, for each type of feedback, whether the three stages of the
          congestion response mechanism could all work.<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.4.1-3">
            <dt id="section-4.4.1-3.1">Detection:</dt>
            <dd style="margin-left: 1.5em" id="section-4.4.1-3.2">
              <p id="section-4.4.1-3.2.1">Can the receiver of a pure ACK detect a
              CE marking on it?:<a href="#section-4.4.1-3.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4.1-3.2.2.1">Classic feedback: RFC 3168 is silent on this point. The
                  implementer of the receiver would not expect CE marks on
                  pure ACKs, but the implementation might happen to check for
                  CE marks before it looks for the data. So detection will be
                  implementation-dependent.<a href="#section-4.4.1-3.2.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.4.1-3.2.2.2">AccECN feedback: the AccECN specification requires the
                  receiver of any TCP packets to count any CE marks on them
                  (whether or not it sends ECN-capable control packets
                  itself).<a href="#section-4.4.1-3.2.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</dd>
            <dd class="break"></dd>
<dt id="section-4.4.1-3.3">Feedback:</dt>
            <dd style="margin-left: 1.5em" id="section-4.4.1-3.4">
              <p id="section-4.4.1-3.4.1">As a general rule, TCP does not ACK a
              pure ACK. However, even if the receiver of a CE-mark on a pure
              ACK does not feed it back immediately, it could still include it
              within subsequent feedback, for instance when it later sends a
              data segment (if it ever does):<a href="#section-4.4.1-3.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4.1-3.4.2.1">Classic feedback: RFC 3168 is silent on this point, so
                  feedback of CE-markings might be implementation specific. If
                  the receiver (of the pure ACKs) did generate feedback, it
                  would set the echo congestion experienced (ECE) flag in the
                  TCP header of subsequent packets in the round, as it would
                  to feed back CE on data packets.<a href="#section-4.4.1-3.4.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.4.1-3.4.2.2">AccECN feedback: the receiver continually feeds back a
                  count of the number of CE-marked packets that it has
                  received and, optionally, a count of CE-marked bytes. For
                  either metric, AccECN takes into account all types of
                  packets, including pure ACKs. CE-marked pure ACKs will
                  solely increment the packet counter; not any byte counter,
                  because by definition they contain no bytes of data.<a href="#section-4.4.1-3.4.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</dd>
            <dd class="break"></dd>
<dt id="section-4.4.1-3.5">Congestion response:</dt>
            <dd style="margin-left: 1.5em" id="section-4.4.1-3.6">In either case (classic or
              AccECN feedback), if the TCP sender does receive feedback about
              CE-markings on pure ACKs, it will be able to reduce the
              congestion window (cwnd) and/or the ACK rate.<a href="#section-4.4.1-3.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.4.1-4">Therefore a congestion response mechanism is clearly
          feasible if AccECN has been negotiated, but the position is unknown
          for the installed base of classic ECN feedback.<a href="#section-4.4.1-4" class="pilcrow">¶</a></p>
<div id="genecn_sec_cwnd_response_pure_ACK">
<section id="section-4.4.1.1">
            <h5 id="name-congestion-window-response-">
<a href="#section-4.4.1.1" class="section-number selfRef">4.4.1.1. </a><a href="#name-congestion-window-response-" class="section-name selfRef">Congestion Window Response to CE-Marked Pure ACKs</a>
            </h5>
<p id="section-4.4.1.1-1">This subsection explores issues that congestion control
            designers will need to consider when defining a cwnd response to
            CE-marked Pure ACKs.<a href="#section-4.4.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1.1-2">A CE-mark on a Pure ACK does not mean that only Pure ACKs are
            causing congestion. It only means that the marked Pure ACK is part
            of an aggregate that is collectively causing a bottleneck queue to
            randomly CE-mark a fraction of the packets. A CE-mark on a Pure
            ACK might be due to data packets in other flows through the same
            bottleneck, due to data packets interspersed between Pure ACKs in
            the same half-connection, or just due to the rate of Pure ACKs
            alone. (RFC 3168 only considered the last possibility, which led
            to the argument that ECN-enabled Pure ACKs had to be deferred,
            because ACK congestion control was a research issue.)<a href="#section-4.4.1.1-2" class="pilcrow">¶</a></p>
<p id="section-4.4.1.1-3">If a host has been sending a mix of Pure ACKs and data, it
            doesn't need to work out whether a particular CE mark was on a
            Pure ACK or not; it just needs to respond to congestion feedback
            as a whole by reducing its congestion window (cwnd), which limits
            the data it can launch into flight through the congested
            bottleneck. If it is purely receiving data and sending only Pure
            ACKs, reducing cwnd will have caused it no harm, having no effect
            on its ACK rate (the next subsection addresses that).<a href="#section-4.4.1.1-3" class="pilcrow">¶</a></p>
<p id="section-4.4.1.1-4">However, when a host is sending data as well as Pure ACKs, it
            would not be right for CE-marks on Pure ACKs and on data packets
            to induce the same reduction in cwnd. A possible way to address
            this issue would be to weight the response by the size of the
            marked packets (assuming the congestion control supports a
            weighted response, e.g. <span>[<a href="#RFC8257" class="xref">RFC8257</a>]</span>). For
            instance, one could calculate the fraction of CE-marked bytes
            (headers and data) over each round trip (say) as follows:<a href="#section-4.4.1.1-4" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.4.1.1-5.1">(CE-marked header bytes + CE-marked data bytes) / (all
                header bytes + all data bytes)<a href="#section-4.4.1.1-5.1" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.4.1.1-6">Header bytes can be calculated by multiplying a packet
            count by a nominal header size, which is possible with AccECN
            feedback, because it gives a count of CE-marked packets (as well
            as CE-marked bytes). The above simple aggregate calculation caters
            for the full range of scenarios; from all Pure ACKs to just a few
            interspersed with data packets.<a href="#section-4.4.1.1-6" class="pilcrow">¶</a></p>
<p id="section-4.4.1.1-7">Note that any mechanism that reduces cwnd due to CE-marked Pure
            ACKs would need to be integrated with the congestion window
            validation mechanism <span>[<a href="#RFC7661" class="xref">RFC7661</a>]</span>, which already
            conservatively reduces cwnd over time because cwnd becomes stale
            if it is not used to fill the pipe.<a href="#section-4.4.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-4.4.1.2">
            <h5 id="name-ack-rate-response-to-ce-mar">
<a href="#section-4.4.1.2" class="section-number selfRef">4.4.1.2. </a><a href="#name-ack-rate-response-to-ce-mar" class="section-name selfRef">ACK Rate Response to CE-Marked Pure ACKs</a>
            </h5>
<p id="section-4.4.1.2-1">Reducing the congestion window will have no effect on the rate
            of pure ACKs. The worst case here is if the bottleneck is
            congested solely with pure ACKs, but it could also be problematic
            if a large fraction of the load was from unresponsive ACKs,
            leaving little or no capacity for the load from responsive
            data.<a href="#section-4.4.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1.2-2">Since RFC 3168 was published, experimental Acknowledgement
            Congestion Control (AckCC) techniques have been documented in
            <span>[<a href="#RFC5690" class="xref">RFC5690</a>]</span> (informational). So any pair of TCP
            end-points can choose to agree to regulate the delayed ACK ratio
            in response to lost or CE-marked pure ACKs. However, the protocol
            has a number of open issues concerning deployment (e.g. it
            requires support from both ends, it relies on two new TCP options,
            one of which is required on the SYN where option space is at a
            premium and, if either option is blocked by a middlebox, no
            fall-back behaviour is specified).<a href="#section-4.4.1.2-2" class="pilcrow">¶</a></p>
<p id="section-4.4.1.2-3">The new TCP options address two problems, namely that TCP had:
            i) no mechanism to allow ECT to be set on pure ACKs; and ii) no
            mechanism to feed back loss or CE-marking of pure ACKs. A
            combination of the present specification and AccECN addresses both
            these problems, at least for CE-marking. So it might now be
            possible to design an ECN-specific ACK congestion control scheme
            without the extra TCP options proposed in RFC 5690. However, such
            a mechanism is out of scope of the present document.<a href="#section-4.4.1.2-3" class="pilcrow">¶</a></p>
<p id="section-4.4.1.2-4">Setting aside the practicality of RFC 5690, the need for AckCC
            has not been conclusively demonstrated. It has been argued that
            the Internet has survived so far with no mechanism to even detect
            loss of pure ACKs. However, it has also been argued that ECN is
            not the same as loss. Packet discard can naturally thin the ACK
            load to whatever the bottleneck can support, whereas ECN marking
            does not (it queues the ACKs instead). Nonetheless, RFC 3168
            (section 7) recommends that an AQM switches over from ECN marking
            to discard when the marking probability becomes high. Therefore
            discard can still be relied on to thin out ECN-enabled pure ACKs
            as a last resort.<a href="#section-4.4.1.2-4" class="pilcrow">¶</a></p>
</section>
</section>
</div>
<div id="genecn_sec_summary_pure_ACK">
<section id="section-4.4.2">
          <h4 id="name-summary-enabling-ecn-on-pur">
<a href="#section-4.4.2" class="section-number selfRef">4.4.2. </a><a href="#name-summary-enabling-ecn-on-pur" class="section-name selfRef">Summary: Enabling ECN on Pure ACKs</a>
          </h4>
<p id="section-4.4.2-1">In the case when AccECN has been negotiated, it provides a
          feasible congestion response mechanism, so the arguments for ECT on
          pure ACKs heavily outweigh those against. ECN is always more and
          never less reliable for delivery of congestion notification. A cwnd
          reduction needs to be considered by congestion control designers as
          a response to congestion on pure ACKs. Separately, AckCC (or an
          improved variant exploiting AccECN) could optionally be used to
          regulate the spacing between pure ACKs. However, it is not clear
          whether AckCC is justified. If it is not, packet discard will still
          act as the "congestion response of last resort" by thinning out the
          traffic. In contrast, not setting ECT on pure ACKs is certainly
          detrimental to performance, because when a pure ACK is lost it can
          prevent the release of new data.<a href="#section-4.4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.4.2-2">In the case when Classic ECN has been negotiated, the argument
          for ECT on pure ACKs is less clear-cut. Some of the installed base
          of RFC 3168 implementations might happen to (unintentionally)
          provide a feedback mechanism to support a cwnd response. For those
          that did not, setting ECT on pure ACKs would be better for the
          flow's own performance than not setting it. However, where there was
          no feedback mechanism, setting ECT could do slightly more harm than
          not setting it. AckCC could provide a complementary response
          mechanism, because it is designed to work with RFC 3168 ECN, but it
          has deployment challenges. In summary, a congestion response
          mechanism is unlikely to be feasible with the installed base of
          classic ECN.<a href="#section-4.4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.4.2-3">This specification uses a safe approach. Allowing hosts to set
          ECT on Pure ACKs without a feasible response mechanism could result
          in risk. It would certainly improve the flow's own performance, but
          it would slightly increase potential harm to others. Morevoer, if
          would set an undesirable precedent for setting ECT on packets with
          no mechanism to respond to any resulting congestion signals.
          Therefore, <a href="#acks" class="xref">Section 3.2.3</a> allows ECT on Pure ACKs if AccECN
          feedback has been negotiated, but not with classic RFC 3168 ECN
          feedback.<a href="#section-4.4.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<section id="section-4.5">
        <h3 id="name-window-probes">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-window-probes" class="section-name selfRef">Window Probes</a>
        </h3>
<p id="section-4.5-1">Section 6.1.6 of RFC 3168 presents only the reliability argument
        for prohibiting ECT on Window probes:<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.5-2.1">"If a window probe packet is dropped in the network, this loss
            is not detected by the receiver. Therefore, the TCP data sender
            MUST NOT set either an ECT codepoint or the CWR bit on window
            probe packets.<a href="#section-4.5-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal ulEmpty" id="section-4.5-2.2">However, because window probes use exact sequence numbers, they
            cannot be easily spoofed in denial-of-service attacks. Therefore,
            if a window probe arrives with the CE codepoint set, then the
            receiver SHOULD respond to the ECN indications."<a href="#section-4.5-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-4.5-3">The reliability argument has already been addressed in <a href="#reliability" class="xref">Section 4.1</a>.<a href="#section-4.5-3" class="pilcrow">¶</a></p>
<p id="section-4.5-4">Allowing ECT on window probes could considerably improve
        performance because, once the receive window has reopened, if a window
        probe is lost the sender will stall until the next window probe
        reaches the receiver, which might be after the maximum retransmission
        timeout (at least 1 minute <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>).<a href="#section-4.5-4" class="pilcrow">¶</a></p>
<p id="section-4.5-5">On the bright side, RFC 3168 at least specifies the receiver
        behaviour if a CE-marked window probe arrives, so changing the
        behaviour ought to be less painful than for other packet types.<a href="#section-4.5-5" class="pilcrow">¶</a></p>
</section>
<section id="section-4.6">
        <h3 id="name-fins">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-fins" class="section-name selfRef">FINs</a>
        </h3>
<p id="section-4.6-1">RFC 3168 is silent on whether a TCP sender can set ECT on a FIN. A
        FIN is considered as part of the sequence of data, and the rate of
        pure ACKs sent after a FIN could be controlled by a CE marking on the
        FIN. Therefore there is no reason not to set ECT on a FIN.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
</section>
<section id="section-4.7">
        <h3 id="name-rsts">
<a href="#section-4.7" class="section-number selfRef">4.7. </a><a href="#name-rsts" class="section-name selfRef">RSTs</a>
        </h3>
<p id="section-4.7-1">RFC 3168 is silent on whether a TCP sender can set ECT on a RST.
        The host generating the RST message does not have an open connection
        after sending it (either because there was no such connection when the
        packet that triggered the RST message was received or because the
        packet that triggered the RST message also triggered the closure of
        the connection).<a href="#section-4.7-1" class="pilcrow">¶</a></p>
<p id="section-4.7-2">Moreover, the receiver of a CE-marked RST message can either: i)
        accept the RST message and close the connection; ii) emit a so-called
        challenge ACK in response (with suitable throttling) <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span> and otherwise ignore the RST (e.g. because the
        sequence number is in-window but not the precise number expected
        next); or iii) discard the RST message (e.g. because the sequence
        number is out-of-window). In the first two cases there is no point in
        echoing any CE mark received because the sender closed its connection
        when it sent the RST. In the third case it makes sense to discard the
        CE signal as well as the RST.<a href="#section-4.7-2" class="pilcrow">¶</a></p>
<p id="section-4.7-3">Although a congestion response following a CE-marking on a RST does
        not appear to make sense, the following factors have been considered
        before deciding whether the sender ought to set ECT on a RST
        message:<a href="#section-4.7-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.7-4.1">As explained above, a congestion response by the sender of a
            CE-marked RST message is not possible;<a href="#section-4.7-4.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-4.7-4.2">So the only reason for the sender setting ECT on a RST would be
            to improve the reliability of the message's delivery;<a href="#section-4.7-4.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-4.7-4.3">
            <p id="section-4.7-4.3.1">RST messages are used to both mount and mitigate attacks:<a href="#section-4.7-4.3.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.7-4.3.2.1">Spoofed RST messages are used by attackers to terminate
                ongoing connections, although the mitigations in RFC 5961 have
                considerably raised the bar against off-path RST attacks;<a href="#section-4.7-4.3.2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.7-4.3.2.2">Legitimate RST messages allow endpoints to inform their
                peers to eliminate existing state that correspond to non
                existing connections, liberating resources e.g. in DoS
                attacks scenarios;<a href="#section-4.7-4.3.2.2" class="pilcrow">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-4.7-4.4">
            <p id="section-4.7-4.4.1">AQMs are advised to disable ECN marking during persistent
            overload, so:<a href="#section-4.7-4.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.7-4.4.2.1">it is harder for an attacker to exploit ECN to intensify an
                attack;<a href="#section-4.7-4.4.2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.7-4.4.2.2">it is harder for a legitimate user to exploit ECN to more
                reliably mitigate an attack<a href="#section-4.7-4.4.2.2" class="pilcrow">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-4.7-4.5">Prohibiting ECT on a RST would deny the benefit of ECN to
            legitimate RST messages, but not to attackers who can disregard
            RFCs;<a href="#section-4.7-4.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-4.7-4.6">
            <p id="section-4.7-4.6.1">If ECT were prohibited on RSTs<a href="#section-4.7-4.6.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.7-4.6.2.1">it would be easy for security middleboxes to discard all
                ECN-capable RSTs;<a href="#section-4.7-4.6.2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.7-4.6.2.2">However, unlike a SYN flood, it is already easy for a
                security middlebox (or host) to distinguish a RST flood from
                legitimate traffic <span>[<a href="#RFC5961" class="xref">RFC5961</a>]</span>, and even if a
                some legitimate RSTs are accidentally removed as well,
                legitimate connections still function.<a href="#section-4.7-4.6.2.2" class="pilcrow">¶</a>
</li>
            </ul>
</li>
        </ul>
<p id="section-4.7-5">So, on balance, it has been decided that it is worth
        experimenting with ECT on RSTs. During experiments, if the ECN
        capability on RSTs is found to open a vulnerability that is hard to
        close, this decision can be reversed, before it is specified for the
        standards track.<a href="#section-4.7-5" class="pilcrow">¶</a></p>
</section>
<div id="genecn_sec_reXMT">
<section id="section-4.8">
        <h3 id="name-retransmitted-packets">
<a href="#section-4.8" class="section-number selfRef">4.8. </a><a href="#name-retransmitted-packets" class="section-name selfRef">Retransmitted Packets.</a>
        </h3>
<p id="section-4.8-1">RFC 3168 says the sender "MUST NOT" set ECT on retransmitted
        packets. The rationale for this consumes nearly 2 pages of RFC 3168,
        so the reader is referred to section 6.1.5 of RFC 3168, rather than
        quoting it all here. There are essentially three arguments, namely:
        reliability; DoS attacks; and over-reaction to congestion. We address
        them in order below.<a href="#section-4.8-1" class="pilcrow">¶</a></p>
<p id="section-4.8-2">The reliability argument has already been addressed in <a href="#reliability" class="xref">Section 4.1</a>.<a href="#section-4.8-2" class="pilcrow">¶</a></p>
<p id="section-4.8-3">Protection against DoS attacks is not afforded by prohibiting ECT
        on retransmitted packets. An attacker can set CE on spoofed
        retransmissions whether or not it is prohibited by an RFC. Protection
        against the DoS attack described in section 6.1.5 of RFC 3168 is
        solely afforded by the requirement that "the TCP data receiver SHOULD
        ignore the CE codepoint on out-of-window packets". Therefore in <a href="#genect_sec_ECT_reXMT" class="xref">Section 3.2.7</a> the sender is allowed to set ECT on
        retransmitted packets, in order to reduce the chance of them being
        dropped. We also strengthen the receiver's requirement from "SHOULD
        ignore" to "MUST ignore". And we generalize the receiver's requirement
        to include failure of any validity check, not just out-of-window
        checks, in order to include the more stringent validity checks in RFC
        5961 that have been developed since RFC 3168.<a href="#section-4.8-3" class="pilcrow">¶</a></p>
<p id="section-4.8-4">A consequence is that, for those retransmitted packets that arrive
        at the receiver after the original packet has been properly received
        (so-called spurious retransmissions), any CE marking will be ignored.
        There is no problem with that because the fact that the original
        packet has been delivered implies that the sender's original
        congestion response (when it deemed the packet lost and retransmitted
        it) was unnecessary.<a href="#section-4.8-4" class="pilcrow">¶</a></p>
<p id="section-4.8-5">Finally, the third argument is about over-reacting to congestion.
        The argument goes that, if a retransmitted packet is dropped, the
        sender will not detect it, so it will not react again to congestion
        (it would have reduced its congestion window already when it
        retransmitted the packet). Whereas, if retransmitted packets can be CE
        tagged instead of dropped, senders could potentially react more than
        once to congestion. However, we argue that it is legitimate to respond
        again to congestion if it still persists in subsequent round
        trip(s).<a href="#section-4.8-5" class="pilcrow">¶</a></p>
<p id="section-4.8-6">Therefore, in all three cases, it is not incorrect to set ECT on
        retransmissions.<a href="#section-4.8-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="genect_sec_gen_fall-back_justify">
<section id="section-4.9">
        <h3 id="name-general-fall-back-for-any-co">
<a href="#section-4.9" class="section-number selfRef">4.9. </a><a href="#name-general-fall-back-for-any-co" class="section-name selfRef">General Fall-back for any Control Packet</a>
        </h3>
<p id="section-4.9-1">Extensive experiments have found no evidence of any traversal
        problems with ECT on any TCP control packet <span>[<a href="#Mandalari18" class="xref">Mandalari18</a>]</span>. Nonetheless, Sections <a href="#genect_sec_fall-back-SYN" class="xref">3.2.1.4</a> and <a href="#genect_sec_fall-back-SYN-ACK" class="xref">3.2.2.3</a> specify fall-back measures if
        ECT on the first packet of each half-connection (SYN or SYN-ACK)
        appears to be blocking progress. Here, the question of fall-back
        measures for ECT on other control packets is explored. It supports the
        advice given in <a href="#genect_sec_gen_fall-back" class="xref">Section 3.2.8</a>; until
        there's evidence that something's broken, don't fix it.<a href="#section-4.9-1" class="pilcrow">¶</a></p>
<p id="section-4.9-2">If an implementation has had to disable ECT to ensure the first
        packet of a flow (SYN or SYN-ACK) gets through, the question arises
        whether it ought to disable ECT on all subsequent control packets
        within the same TCP connection. Without evidence of any such problems,
        this seems unnecessarily cautious. Particularly given it would be hard
        to detect loss of most other types of TCP control packets that are not
        ACK'd. And particularly given that unnecessarily removing ECT from
        other control packets could lead to performance problems, e.g. by
        directing them into another queue <span>[<a href="#I-D.ietf-tsvwg-ecn-l4s-id" class="xref">I-D.ietf-tsvwg-ecn-l4s-id</a>]</span> or over a different path, because
        some broken multipath equipment (erroneously) routes based on all 8
        bits of the Diffserv field.<a href="#section-4.9-2" class="pilcrow">¶</a></p>
<p id="section-4.9-3">In the case where a connection starts without ECT on the SYN
        (perhaps because problems with previous connections had been cached),
        there will have been no test for ECT traversal in the client-server
        direction until the pure ACK that completes the handshake. It is
        possible that some middlebox might block ECT on this pure ACK or on
        later retransmissions of lost packets. Similarly, after a route
        change, the new path might include some middlebox that blocks ECT on
        some or all TCP control packets. However, without evidence of such
        problems, the complexity of a fix does not seem worthwhile.<a href="#section-4.9-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.9-4.1">MORE MEASUREMENTS NEEDED (?): If further two-ended measurements
            do find evidence for these traversal problems, measurements would
            be needed to check for correlation of ECT traversal problems
            between different control packets. It might then be necessary to
            introduce a catch-all fall-back rule that disables ECT on certain
            subsequent TCP control packets based on some criteria developed
            from these measurements.<a href="#section-4.9-4.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="genecn_sec_variants">
<section id="section-5">
      <h2 id="name-interaction-with-popular-va">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-interaction-with-popular-va" class="section-name selfRef">Interaction with popular variants or derivatives of TCP</a>
      </h2>
<p id="section-5-1">The following subsections discuss any interactions between setting
      ECT on all packets and using the following popular variants of TCP: IW10
      and TFO. It also briefly notes the possibility that the principles
      applied here should translate to protocols derived from TCP. This
      section is informative not normative, because no interactions have been
      identified that require any change to specifications. The subsection on
      IW10 discusses potential changes to specifications but recommends that
      no changes are needed.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">The designs of the following TCP variants have also been assessed and
      found not to interact adversely with ECT on TCP control packets: SYN
      cookies (see Appendix A of <span>[<a href="#RFC4987" class="xref">RFC4987</a>]</span> and section 3.1 of
      <span>[<a href="#RFC5562" class="xref">RFC5562</a>]</span>), TCP Fast Open (TFO <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span>)
      and L4S <span>[<a href="#I-D.ietf-tsvwg-l4s-arch" class="xref">I-D.ietf-tsvwg-l4s-arch</a>]</span>.<a href="#section-5-2" class="pilcrow">¶</a></p>
<div id="genecn_sec_IW10">
<section id="section-5.1">
        <h3 id="name-iw10">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-iw10" class="section-name selfRef">IW10</a>
        </h3>
<p id="section-5.1-1">IW10 is an experiment to determine whether it is safe for TCP to
        use an initial window of 10 SMSS <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1-2">This subsection does not recommend any additions to the present
        specification in order to interwork with IW10. The specifications as
        they stand are safe, and there is only a corner-case with ECT on the
        SYN where performance could be occasionally improved, as explained
        below.<a href="#section-5.1-2" class="pilcrow">¶</a></p>
<p id="section-5.1-3">As specified in <a href="#genecn_sec_ECT_SYN" class="xref">Section 3.2.1.1</a>, a TCP
        initiator will typically only set ECT on the SYN if it requests AccECN
        support. If, however, the SYN-ACK tells the initiator that the
        responder does not support AccECN, <a href="#genecn_sec_ECT_SYN" class="xref">Section 3.2.1.1</a>
        advises the initiator to conservatively reduce its initial window,
        preferably to 1 SMSS because, if the SYN was CE-marked, the SYN-ACK
        has no way to feed that back.<a href="#section-5.1-3" class="pilcrow">¶</a></p>
<p id="section-5.1-4">If the initiator implements IW10, it seems rather over-conservative
        to reduce IW from 10 to 1 just in case a congestion marking was
        missed. Nonetheless, a reduction to 1 SMSS will rarely harm
        performance, because:<a href="#section-5.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-5.1">as long as the initiator is caching failures to negotiate
            AccECN, subsequent attempts to access the same server will not use
            ECT on the SYN anyway, so there will no longer be any need to
            conservatively reduce IW;<a href="#section-5.1-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.1-5.2">currently, at least for web sessions, it is extremely rare for
            a TCP initiator (client) to have more than one data segment to
            send at the start of a TCP connection (see Fig 3 in <span>[<a href="#Manzoor17" class="xref">Manzoor17</a>]</span>) - IW10 is primarily exploited by TCP
            servers.<a href="#section-5.1-5.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-5.1-6">If a responder receives feedback that the SYN-ACK was CE-marked,
        <a href="#genecn_sec_SYN-ACK_response" class="xref">Section 3.2.2.2</a> recommends that it
        reduces its initial window, preferably to 1 SMSS. When the responder
        also implements IW10, it might again seem rather over-conservative to
        reduce IW from 10 to 1. But in this case the rationale is somewhat
        different:<a href="#section-5.1-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-7.1">Feedback that the SYN-ACK was CE-marked is an explicit
            indication that the queue has been building, not just uncertainty
            due to absence of feedback;<a href="#section-5.1-7.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.1-7.2">Given it is now likely that a queue already exists, the more
            data packets that the server sends in its IW, the more likely at
            least one will be CE marked, leading it to exit slow-start
            early.<a href="#section-5.1-7.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-5.1-8">Experimentation will be needed to determine the best
        strategy. It should be noted that experience from recent congestion
        avoidance experiments where the window is reduced by less than half is
        not necessarily applicable to a flow start scenario. Reducing cwnd by
        less is one thing. Reducing an increase in cwnd by less is
        another.<a href="#section-5.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-5.2">
        <h3 id="name-tfo">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-tfo" class="section-name selfRef">TFO</a>
        </h3>
<p id="section-5.2-1">TCP Fast Open (TFO <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span>) is an experiment to
        remove the round trip delay of TCP's 3-way hand-shake (3WHS). A TFO
        initiator caches a cookie from a previous connection with a
        TFO-enabled server. Then, for subsequent connections to the same
        server, any data included on the SYN can be passed directly to the
        server application, which can then return up to an initial window of
        response data on the SYN-ACK and on data segments straight after it,
        without waiting for the ACK that completes the 3WHS.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">The TFO experiment and the present experiment to add ECN-support
        for TCP control packets can be combined without altering either
        specification, which is justified as follows:<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-3.1">The handling of ECN marking on a SYN is no different whether or
            not it carries data.<a href="#section-5.2-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.2-3.2">In response to any CE-marking on the SYN-ACK, the responder
            adopts the normal response to congestion, as discussed in Section
            7.2 of <span>[<a href="#RFC7413" class="xref">RFC7413</a>]</span>.<a href="#section-5.2-3.2" class="pilcrow">¶</a>
</li>
        </ul>
</section>
<section id="section-5.3">
        <h3 id="name-l4s">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-l4s" class="section-name selfRef">L4S</a>
        </h3>
<p id="section-5.3-1">A Low Latency Low Loss Scalable throughput (L4S) variant of TCP
        such as TCP Prague <span>[<a href="#PragueLinux" class="xref">PragueLinux</a>]</span> is mandated to
        negotiate AccECN feedback, and strongly recommended to use ECN++ <span>[<a href="#I-D.ietf-tsvwg-ecn-l4s-id" class="xref">I-D.ietf-tsvwg-ecn-l4s-id</a>]</span>.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">The L4S experiment and the present ECN++ experiment can be combined
        without altering any of the specifications. The only difference would
        be in the recommendation of the best SYN cache strategy.<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<p id="section-5.3-3">The normative specification for ECT on a SYN in <a href="#genecn_sec_SYN" class="xref">Section 3.2.1</a> recommends the "optimistic ECT and cache
        failures" strategy (S2B defined in <a href="#genecn_sec_SYN_cache_rationale" class="xref">Section 4.2.3</a>) for the general Internet.
        However, if a user's Internet access bottleneck supported L4S ECN but
        not Classic ECN, the "optimistic ECT without a cache" strategy (S2A)
        would make most sense, because there would be little point trying to
        avoid the 'over-strict' test and negotiate Classic ECN, if L4S ECN but
        not Classic ECN was available on that user's access link (as is the
        case with Low Latency DOCSIS <span>[<a href="#DOCSIS3.1" class="xref">DOCSIS3.1</a>]</span>).<a href="#section-5.3-3" class="pilcrow">¶</a></p>
<p id="section-5.3-4">Strategy (S2A) is the simplest, because it requires no cache. It
        would satisfy the goal of an implementer who is solely interested in
        ultra-low latency using AccECN and ECN++ (e.g. accessing L4S
        servers) and is not concerned about fall-back to Classic ECN
        (e.g. when accessing other servers).<a href="#section-5.3-4" class="pilcrow">¶</a></p>
</section>
<section id="section-5.4">
        <h3 id="name-other-transport-protocols">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-other-transport-protocols" class="section-name selfRef">Other transport protocols</a>
        </h3>
<p id="section-5.4-1">Experience from experiments on adding ECN support to all TCP
        packets ought to be directly transferable between TCP and other
        transport protocols, like SCTP or QUIC.<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<p id="section-5.4-2">Stream Control Transmission Protocol (SCTP <span>[<a href="#RFC4960" class="xref">RFC4960</a>]</span>) is a standards track transport protocol derived
        from TCP. SCTP currently does not include ECN support, but Appendix A
        of RFC 4960 broadly describes how it would be supported and a
        (long-expired) draft on the addition of ECN to SCTP has been produced
        <span>[<a href="#I-D.stewart-tsvwg-sctpecn" class="xref">I-D.stewart-tsvwg-sctpecn</a>]</span>. This draft avoided setting
        ECT on control packets and retransmissions, closely following the
        arguments in RFC 3168.<a href="#section-5.4-2" class="pilcrow">¶</a></p>
<p id="section-5.4-3">QUIC <span>[<a href="#RFC9000" class="xref">RFC9000</a>]</span> is another standards track transport
        protocol offering similar services to TCP but intended to exploit some
        of the benefits of running over UDP. Building on the arguments in the
        current draft, a QUIC sender sets ECT(0) on all packets.<a href="#section-5.4-3" class="pilcrow">¶</a></p>
</section>
</section>
</div>
<section id="section-6">
      <h2 id="name-security-considerations">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-6-1"><a href="#genecn_sec_ECT_RST" class="xref">Section 3.2.6</a> considers the question of whether
      ECT on RSTs will allow RST attacks to be intensified. There are several
      security arguments presented in RFC 3168 for preventing the ECN marking
      of TCP control packets and retransmitted segments. We believe all of
      them have been properly addressed in <a href="#arguments" class="xref">Section 4</a>,
      particularly <a href="#genecn_sec_SYN_DOS" class="xref">Section 4.2.4</a> and <a href="#genecn_sec_reXMT" class="xref">Section 4.8</a> on DoS attacks using spoofed ECT-marked SYNs
      and spoofed CE-marked retransmissions.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2"><a href="#genecn_sec_ECT_RST" class="xref">Section 3.2.6</a> on sending TCP RSTs points out
      that implementers need to take care to ensure that the ECN field on a
      RST does not depend on TCP's state machine. Otherwise the internal
      information revealed could be of use to potential attackers. This point
      applies more generally to all control packets, not just RSTs.<a href="#section-6-2" class="pilcrow">¶</a></p>
</section>
<section id="section-7">
      <h2 id="name-iana-considerations">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-7-1">There are no IANA considerations in this memo.<a href="#section-7-1" class="pilcrow">¶</a></p>
</section>
<section id="section-8">
      <h2 id="name-acknowledgments">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="section-8-1">Thanks to Mirja Kuehlewind, David Black, Padma Bhooma, Gorry
      Fairhurst, Michael Scharf, Yuchung Cheng and Christophe Paasch for their
      useful reviews. Richard Scheffenegger provided useful advice gained from
      implementing ECN++ for FreeBSD.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">The work of Marcelo Bagnulo has been performed in the framework of
      the H2020-ICT-2014-2 project 5G NORMA. His contribution reflects the
      consortium's view, but the consortium is not liable for any use that may
      be made of any of the information contained therein.<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">Bob Briscoe's contribution was partly funded by the Research Council
      of Norway through the TimeIn project, partly by CableLabs and partly by
      the Comcast Innovation Fund. The views expressed here are solely those
      of the authors.<a href="#section-8-3" class="pilcrow">¶</a></p>
</section>
<section id="section-9">
      <h2 id="name-references">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-9.1">
        <h3 id="name-normative-references">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5961">[RFC5961]</dt>
        <dd>
<span class="refAuthor">Ramaiah, A.</span>, <span class="refAuthor">Stewart, R.</span>, and <span class="refAuthor">M. Dalal</span>, <span class="refTitle">"Improving TCP's Robustness to Blind In-Window Attacks"</span>, <span class="seriesInfo">RFC 5961</span>, <span class="seriesInfo">DOI 10.17487/RFC5961</span>, <time datetime="2010-08" class="refDate">August 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5961">https://www.rfc-editor.org/info/rfc5961</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tcpm-accurate-ecn">[I-D.ietf-tcpm-accurate-ecn]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Kühlewind, M.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"More Accurate ECN Feedback in TCP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-accurate-ecn-15</span>, <time datetime="2021-07-12" class="refDate">12 July 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-15">https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-15</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8311">[RFC8311]</dt>
        <dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time datetime="2018-01" class="refDate">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC0793">[RFC0793]</dt>
      <dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Transmission Control Protocol"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 793</span>, <span class="seriesInfo">DOI 10.17487/RFC0793</span>, <time datetime="1981-09" class="refDate">September 1981</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-9.2">
        <h3 id="name-informative-references">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC1122">[RFC1122]</dt>
        <dd>
<span class="refAuthor">Braden, R., Ed.</span>, <span class="refTitle">"Requirements for Internet Hosts - Communication Layers"</span>, <span class="seriesInfo">STD 3</span>, <span class="seriesInfo">RFC 1122</span>, <span class="seriesInfo">DOI 10.17487/RFC1122</span>, <time datetime="1989-10" class="refDate">October 1989</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1122">https://www.rfc-editor.org/info/rfc1122</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3540">[RFC3540]</dt>
        <dd>
<span class="refAuthor">Spring, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">D. Ely</span>, <span class="refTitle">"Robust Explicit Congestion Notification (ECN) Signaling with Nonces"</span>, <span class="seriesInfo">RFC 3540</span>, <span class="seriesInfo">DOI 10.17487/RFC3540</span>, <time datetime="2003-06" class="refDate">June 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3540">https://www.rfc-editor.org/info/rfc3540</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4960">[RFC4960]</dt>
        <dd>
<span class="refAuthor">Stewart, R., Ed.</span>, <span class="refTitle">"Stream Control Transmission Protocol"</span>, <span class="seriesInfo">RFC 4960</span>, <span class="seriesInfo">DOI 10.17487/RFC4960</span>, <time datetime="2007-09" class="refDate">September 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4960">https://www.rfc-editor.org/info/rfc4960</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4987">[RFC4987]</dt>
        <dd>
<span class="refAuthor">Eddy, W.</span>, <span class="refTitle">"TCP SYN Flooding Attacks and Common Mitigations"</span>, <span class="seriesInfo">RFC 4987</span>, <span class="seriesInfo">DOI 10.17487/RFC4987</span>, <time datetime="2007-08" class="refDate">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4987">https://www.rfc-editor.org/info/rfc4987</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5562">[RFC5562]</dt>
        <dd>
<span class="refAuthor">Kuzmanovic, A.</span>, <span class="refAuthor">Mondal, A.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">K. Ramakrishnan</span>, <span class="refTitle">"Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets"</span>, <span class="seriesInfo">RFC 5562</span>, <span class="seriesInfo">DOI 10.17487/RFC5562</span>, <time datetime="2009-06" class="refDate">June 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5562">https://www.rfc-editor.org/info/rfc5562</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5690">[RFC5690]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Arcia, A.</span>, <span class="refAuthor">Ros, D.</span>, and <span class="refAuthor">J. Iyengar</span>, <span class="refTitle">"Adding Acknowledgement Congestion Control to TCP"</span>, <span class="seriesInfo">RFC 5690</span>, <span class="seriesInfo">DOI 10.17487/RFC5690</span>, <time datetime="2010-02" class="refDate">February 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5690">https://www.rfc-editor.org/info/rfc5690</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6298">[RFC6298]</dt>
        <dd>
<span class="refAuthor">Paxson, V.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Chu, J.</span>, and <span class="refAuthor">M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6928">[RFC6928]</dt>
        <dd>
<span class="refAuthor">Chu, J.</span>, <span class="refAuthor">Dukkipati, N.</span>, <span class="refAuthor">Cheng, Y.</span>, and <span class="refAuthor">M. Mathis</span>, <span class="refTitle">"Increasing TCP's Initial Window"</span>, <span class="seriesInfo">RFC 6928</span>, <span class="seriesInfo">DOI 10.17487/RFC6928</span>, <time datetime="2013-04" class="refDate">April 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6928">https://www.rfc-editor.org/info/rfc6928</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7413">[RFC7413]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Chu, J.</span>, <span class="refAuthor">Radhakrishnan, S.</span>, and <span class="refAuthor">A. Jain</span>, <span class="refTitle">"TCP Fast Open"</span>, <span class="seriesInfo">RFC 7413</span>, <span class="seriesInfo">DOI 10.17487/RFC7413</span>, <time datetime="2014-12" class="refDate">December 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7567">[RFC7567]</dt>
        <dd>
<span class="refAuthor">Baker, F., Ed.</span> and <span class="refAuthor">G. Fairhurst, Ed.</span>, <span class="refTitle">"IETF Recommendations Regarding Active Queue Management"</span>, <span class="seriesInfo">BCP 197</span>, <span class="seriesInfo">RFC 7567</span>, <span class="seriesInfo">DOI 10.17487/RFC7567</span>, <time datetime="2015-07" class="refDate">July 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7567">https://www.rfc-editor.org/info/rfc7567</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7661">[RFC7661]</dt>
        <dd>
<span class="refAuthor">Fairhurst, G.</span>, <span class="refAuthor">Sathiaseelan, A.</span>, and <span class="refAuthor">R. Secchi</span>, <span class="refTitle">"Updating TCP to Support Rate-Limited Traffic"</span>, <span class="seriesInfo">RFC 7661</span>, <span class="seriesInfo">DOI 10.17487/RFC7661</span>, <time datetime="2015-10" class="refDate">October 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7661">https://www.rfc-editor.org/info/rfc7661</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8257">[RFC8257]</dt>
        <dd>
<span class="refAuthor">Bensley, S.</span>, <span class="refAuthor">Thaler, D.</span>, <span class="refAuthor">Balasubramanian, P.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">G. Judd</span>, <span class="refTitle">"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers"</span>, <span class="seriesInfo">RFC 8257</span>, <span class="seriesInfo">DOI 10.17487/RFC8257</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2140">[RFC2140]</dt>
        <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refTitle">"TCP Control Block Interdependence"</span>, <span class="seriesInfo">RFC 2140</span>, <span class="seriesInfo">DOI 10.17487/RFC2140</span>, <time datetime="1997-04" class="refDate">April 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2140">https://www.rfc-editor.org/info/rfc2140</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-ecn-l4s-id">[I-D.ietf-tsvwg-ecn-l4s-id]</dt>
        <dd>
<span class="refAuthor">Schepper, K. D.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Explicit Congestion Notification (ECN) Protocol for Very Low Queuing Delay (L4S)"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-ecn-l4s-id-23</span>, <time datetime="2021-12-24" class="refDate">24 December 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-l4s-id-23">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-l4s-id-23</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-l4s-arch">[I-D.ietf-tsvwg-l4s-arch]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Schepper, K. D.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Low Latency, Low Loss, Scalable Throughput (L4S) Internet Service: Architecture"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-l4s-arch-15</span>, <time datetime="2021-12-24" class="refDate">24 December 2021</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4s-arch-15">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4s-arch-15</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.stewart-tsvwg-sctpecn">[I-D.stewart-tsvwg-sctpecn]</dt>
        <dd>
<span class="refAuthor">Stewart, R. R.</span>, <span class="refAuthor">Tuexen, M.</span>, and <span class="refAuthor">X. Dong</span>, <span class="refTitle">"ECN for Stream Control Transmission Protocol (SCTP)"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-stewart-tsvwg-sctpecn-05</span>, <time datetime="2014-01-15" class="refDate">15 January 2014</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05">https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="judd-nsdi">[judd-nsdi]</dt>
        <dd>
<span class="refAuthor">Judd, G.J.</span>, <span class="refTitle">"Attaining the promise and avoiding the pitfalls of TCP in the Datacenter"</span>, <span class="seriesInfo">USENIX Symposium on Networked Systems Design and Implementation (NSDI'15) pp.145-157</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://www.usenix.org/node/188966">https://www.usenix.org/node/188966</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ecn-pam">[ecn-pam]</dt>
        <dd>
<span class="refAuthor">Trammell, B.</span>, <span class="refAuthor">Kühlewind, M.</span>, <span class="refAuthor">Boppart, D.</span>, <span class="refAuthor">Learmonth, I.</span>, <span class="refAuthor">Fairhurst, G.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"Enabling Internet-Wide Deployment of Explicit Congestion Notification"</span>, <span class="seriesInfo">Int'l Conf. on Passive and Active Network Measurement (PAM'15) pp193-205</span>, <time datetime="2015" class="refDate">2015</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-319-15509-8_15">https://link.springer.com/chapter/10.1007/978-3-319-15509-8_15</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ECN-PLUS">[ECN-PLUS]</dt>
        <dd>
<span class="refAuthor">Kuzmanovic, A.</span>, <span class="refTitle">"The Power of Explicit Congestion Notification"</span>, <span class="seriesInfo">ACM SIGCOMM 35(4):61--72</span>, <time datetime="2005" class="refDate">2005</time>, <span>&lt;<a href="http://dl.acm.org/citation.cfm?id=1080100">http://dl.acm.org/citation.cfm?id=1080100</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Mandalari18">[Mandalari18]</dt>
        <dd>
<span class="refAuthor">Mandalari, A.</span>, <span class="refAuthor">Lutu, A.</span>, <span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">Ö. Alay</span>, <span class="refTitle">"Measuring ECN++: Good News for ++, Bad News for ECN over Mobile"</span>, <span class="seriesInfo">IEEE Communications Magazine </span>, <time datetime="2018-03" class="refDate">March 2018</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8316790">https://ieeexplore.ieee.org/document/8316790</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Manzoor17">[Manzoor17]</dt>
        <dd>
<span class="refAuthor">Manzoor, J.</span>, <span class="refAuthor">Drago, I.</span>, and <span class="refAuthor">R. Sadre</span>, <span class="refTitle">"How HTTP/2 is changing Web traffic and how to detect it"</span>, <span class="seriesInfo">In Proc: Network Traffic Measurement and Analysis Conference (TMA) 2017 pp.1-9</span>, <time datetime="2017-06" class="refDate">June 2017</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8002899">https://ieeexplore.ieee.org/document/8002899</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Kuehlewind18">[Kuehlewind18]</dt>
        <dd>
<span class="refAuthor">Kühlewind, M.</span>, <span class="refAuthor">Walter, M.</span>, <span class="refAuthor">Learmonth, I.</span>, and <span class="refAuthor">B. Trammell</span>, <span class="refTitle">"Tracing Internet Path Transparency"</span>, <span class="seriesInfo">In Proc: Network Traffic Measurement and Analysis Conference (TMA) 2018 </span>, <time datetime="2018-06" class="refDate">June 2018</time>, <span>&lt;<a href="http://tma.ifip.org/2018/wp-content/uploads/sites/3/2018/06/tma2018_paper12.pdf">http://tma.ifip.org/2018/wp-content/uploads/sites/3/2018/06/tma2018_paper12.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="strict-ecn">[strict-ecn]</dt>
        <dd>
<span class="refAuthor">Dumazet, E.</span>, <span class="refTitle">"tcp: be more strict before accepting ECN negociation"</span>, <span class="seriesInfo">Linux netdev patch list </span>, <time datetime="2012-05-04" class="refDate">4 May 2012</time>, <span>&lt;<a href="https://patchwork.ozlabs.org/patch/156953/">https://patchwork.ozlabs.org/patch/156953/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="relax-strict-ecn">[relax-strict-ecn]</dt>
        <dd>
<span class="refAuthor">Tilmans, O.</span>, <span class="refTitle">"tcp: Accept ECT on SYN in the presence of RFC8311"</span>, <span class="seriesInfo">Linux netdev patch list </span>, <time datetime="2019-04-03" class="refDate">3 April 2019</time>, <span>&lt;<a href="https://lore.kernel.org/patchwork/patch/1057812/">https://lore.kernel.org/patchwork/patch/1057812/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ecn-overload">[ecn-overload]</dt>
        <dd>
<span class="refAuthor">Steen, H.</span>, <span class="refTitle">"Destruction Testing: Ultra-Low Delay using Dual Queue Coupled Active Queue Management"</span>, <span class="seriesInfo">Masters Thesis, Uni Oslo </span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.duo.uio.no/bitstream/handle/10852/57424/thesis-henrste.pdf?sequence=1">https://www.duo.uio.no/bitstream/handle/10852/57424/thesis-henrste.pdf?sequence=1</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PragueLinux">[PragueLinux]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Albisser, O.</span>, <span class="refAuthor">Misund, J.</span>, <span class="refAuthor">Tilmans, O.</span>, <span class="refAuthor">Kühlewind, M.</span>, and <span class="refAuthor">A.S. Ahmed</span>, <span class="refTitle">"Implementing the `TCP Prague' Requirements for Low Latency Low Loss Scalable Throughput (L4S)"</span>, <span class="seriesInfo">Proc. Linux Netdev 0x13 </span>, <time datetime="2019-03" class="refDate">March 2019</time>, <span>&lt;<a href="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s">https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DOCSIS3.1">[DOCSIS3.1]</dt>
      <dd>
<span class="refAuthor">CableLabs</span>, <span class="refTitle">"MAC and Upper Layer Protocols Interface (MULPI) Specification, CM-SP-MULPIv3.1"</span>, <span class="seriesInfo">Data-Over-Cable Service Interface Specifications DOCSIS® 3.1 Version i17 or later</span>, <time datetime="2019-01-21" class="refDate">21 January 2019</time>, <span>&lt;<a href="https://specification-search.cablelabs.com/CM-SP-MULPIv3.1">https://specification-search.cablelabs.com/CM-SP-MULPIv3.1</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="authors-addresses">
<section id="appendix-A">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Marcelo Bagnulo</span></div>
<div dir="auto" class="left"><span class="org">Universidad Carlos III de Madrid</span></div>
<div dir="auto" class="left"><span class="street-address">Av. Universidad 30</span></div>
<div dir="auto" class="left">
<span class="postal-code">28911</span> <span class="locality">Leganes</span> <span class="region">Madrid</span>
</div>
<div dir="auto" class="left"><span class="country-name">Spain</span></div>
<div class="tel">
<span>Phone:</span>
<a href="tel:34%2091%206249500" class="tel">34 91 6249500</a>
</div>
<div class="email">
<span>Email:</span>
<a href="mailto:marcelo@it.uc3m.es" class="email">marcelo@it.uc3m.es</a>
</div>
<div class="url">
<span>URI:</span>
<a href="http://www.it.uc3m.es" class="url">http://www.it.uc3m.es</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Bob Briscoe</span></div>
<div dir="auto" class="left"><span class="org">Independent</span></div>
<div dir="auto" class="left"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ietf@bobbriscoe.net" class="email">ietf@bobbriscoe.net</a>
</div>
<div class="url">
<span>URI:</span>
<a href="http://bobbriscoe.net/" class="url">http://bobbriscoe.net/</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
