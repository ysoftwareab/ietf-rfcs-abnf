<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The OAuth Security Model for Delegated Authorization</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The OAuth Security Model for Delegated Authorization">
<meta name="keywords" content="oauth, authorization, www">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">OAuth</td><td class="header">R. Barnes</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">M. Lepinski</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">BBN Technologies</td></tr>
<tr><td class="header">Expires: January 9, 2010</td><td class="header">July 08, 2009</td></tr>
</table></td></tr></table>
<h1><br />The OAuth Security Model for Delegated Authorization<br />draft-barnes-oauth-model-01</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 9, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document describes the security model for the OAuth authorization system, which allows a party that holds some authorization to delegate a subset of that authorization to another party, without requiring either party to disclose its credentials to the other.  In this document, we describe a set of design constraints, a high-level work flow for establishing authorizations subject to those constraints, and set of security requirements for protocols that implement this model.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro-sec">1.</a>&nbsp;
Introduction<br />
<a href="#def-sec">2.</a>&nbsp;
Definitions<br />
<a href="#req-sec">3.</a>&nbsp;
Requirements and design goals<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trust-sec">3.1.</a>&nbsp;
Trust assumptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#threat-sec">3.2.</a>&nbsp;
Threat model<br />
<a href="#authz-flow-sec">4.</a>&nbsp;
Authorization flow<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#req-assm-sec">4.1.</a>&nbsp;
General Requirements and Assumptions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#req-t-iss-sec">4.2.</a>&nbsp;
Request token issuance<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authz-req-sec">4.3.</a>&nbsp;
Authorization of the request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#req-authz-sec">4.3.1.</a>&nbsp;
Request for authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ver-t-iss-sec">4.3.2.</a>&nbsp;
Verification token issuance<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#not-authz-sec">4.3.3.</a>&nbsp;
Notification of authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#acc-t-iss-sec">4.4.</a>&nbsp;
Access token issuance<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#acc-res-sec">4.5.</a>&nbsp;
Accessing protected resources<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authz-sum-sec">4.6.</a>&nbsp;
Summary<br />
<a href="#sec-anal-sec">5.</a>&nbsp;
Security analysis<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#out-int-sec">5.1.</a>&nbsp;
Protection from outside interference<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mal-act-sec">5.2.</a>&nbsp;
Protection from malicious actors within the model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#col-act-sec">5.3.</a>&nbsp;
Protection from colluding actors<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dos-sec">5.4.</a>&nbsp;
Protection from denial of service<br />
<a href="#ack-sec">6.</a>&nbsp;
Acknowledgements<br />
<a href="#iana-sec">7.</a>&nbsp;
IANA Considerations<br />
<a href="#sec-cons-sec">8.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">9.</a>&nbsp;
Normative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="intro-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>It is an almost universal situation in the Internet today that users make use of many Internet applications, some of which store data for the user and some of which consume user data.  There is increasing interest in bringing these two types of application together, i.e., in allowing certain applications that consume user data to access data that is stored by other applications.
</p>
<p>However, in order to maintain the security of user data, applications that store data typically require an entity requesting private resources to authenticate that they own those resources (i.e., to authenticate as the owner of the resources).  Enabling a second application to access private resources would thus require the user who ones the resources to enable that application to authenticate as the user.  This situation is clearly undesirable, since it allows the consuming application to impersonate the user: To access any and all data the user owns, or to take actions as the user.
</p>
<p>This situation has created a need for a mechanism for delegating authorization.  In such a system, the owner of a set of resources can delegate access to some of those resources to a designated client application, without enabling the client application to impersonate the user.
</p>
<p>There are two basic prerequisites of such a delegation mechanism: First, applications that store user data must have separate notions of ownership and access permissions; this, of course, is not subject to standardization.  Second, there must be a way for client applications to request access, and for users to instruct servers to grant such access.  This second aspect is the subject of this document.
</p>
<p>This document describes a security model for the OAuth delegated authorization system.  In particular, we provide an abstract message flow that defines how parameters are exchanged between OAuth entities, and what the security requirements are for these exchanges.  The definition of protocol mechanisms for conveying parameters in compliance with these requirements is left to future documents.
</p>
<p>[[ Editor's note: This document is essentially an abstraction and security analysis of the OAuth Core protocol, defined in <a class='info' href='#I-D.hammer-oauth'>[1]<span> (</span><span class='info'>Hammer-Lahav, E., &ldquo;The OAuth 1.0 Protocol,&rdquo; February&nbsp;2010.</span><span>)</span></a>.  While the current OAuth protocol should map more or less directly to this model, there may be slight difference, e.g., in where authentication is required. ]]
</p>
<a name="def-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Definitions</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [2].
</p>
<p>The focus of this document is the secure delegation of access to resources.  In this document, we use the term "resources" broadly, to include actual data (e.g., files, streams) as well as permissions to take particular actions.
</p>
<p>There are three roles involved in the OAuth process.  These roles are not mutually exclusive; a single party may act in more than one role.
        </p>
<blockquote class="text"><dl>
<dt>Resource Owner (RO): </dt>
<dd>The entity that has authorization at the beginning of the OAuth process, who delegates authorization to the Client 
</dd>
<dt>Client: </dt>
<dd>The entity to which authorization is delegated by the Resource Owner
</dd>
<dt>Server: </dt>
<dd>The entity that enforces the authorizations in question (e.g., the server that stores a protected resource)
</dd>
</dl></blockquote><p>
      
</p>
<p>[[ Editor's note: These three roles correspond to the User, the Consumer, and the Service Provider in OAuth 1.0, available at http://oauth.net/ ]]
</p>
<p>An OAuth Server issues three types of opaque tokens in the course of the authorization process.  These values are random values that are unique within a defined scope.   
        </p>
<blockquote class="text"><dl>
<dt>Request token: </dt>
<dd>A temporary identifier for a specific Client for the duration of a single OAuth authorization transaction.  An RO that requests a verification token using that request token indicates that the corresponding Client is the entity to be authorized.  
</dd>
<dt>Verification token: </dt>
<dd>A temporary identifier for an authorization, including the authorized Client, the authorizing RO, and the resources to which access is to be granted.  A Client that requests an access token using a given verification token indicates that the RO has granted the corresponding authorization.
</dd>
<dt>Access token: </dt>
<dd>A long-lived identifier for an authorization.  A Client that requests access to resources using a given access token indicates that it has been authorized via the OAuth process to access those resources.
</dd>
</dl></blockquote><p>
        Many of the security properties of the OAuth process require protocol participants to associate, or "bind", certain other data to tokens, then subsequently verify these associations/bindings.  In the below, when an entity is required to use the value "bound to a token" or "associated with a token", it is implied that the value in question is the one associated by the entity at hand.
      
</p>
<a name="req-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Requirements and design goals</h3>

<p>The fundamental goal of the OAuth model is to allow the Resource Owner to grant the Client authorization to access selected resources on the Server, while maintaining strict authentication and access control.  The requirement for strict authentication means that no party should be able to authenticate as any other, whether a protocol participant (e.g., the Client authenticating as the RO) or a third party.  The requirement for access control means that the delegation process should not grant the Client (or any other party) access to anything other than the resources designated for access by the Resource Owner.
</p>
<p>The OAuth model must also ensure that the authorization process is followed: In order for an authorization to be delegated by a Resource Owner to a Client, it must be requested by the Client and authorized by the Resource Owner.  In particular, the RO cannot unilaterally grant authorization to a Client without a request (since the Client may not be able to use that authorization), and of course, no authorization can be granted without the approval of the RO.  In addition, the security model should prevent the Client from further delegating access without going through the same OAuth process.
</p>
<p>It should be clear that these requirements already rule out the simplest models for delegating authorization.  For example, a model in which the RO simply provides its authentication credentials to the Client is unacceptable for several reasons: It allows the Client to access all resources (not only any selected subset), and it requires the Client to authenticate as the RO. 
</p>
<p>Note also that this document defines only the security model for OAuth, i.e., how security-relevant data flow through the system, and what the security requirements are for these flows.  In particular, this document does not define protocol mechanisms for carrying data (e.g., tokens) or providing security features (e.g., authentication, confidentiality).  Such mechanisms should be defined in protocol-specific documents (e.g., a realization of OAuth in HTTP or XMPP).
</p>
<a name="trust-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Trust assumptions</h3>

<p>In the OAuth architecture, the Server is a trusted entity, in the sense of RFC 4949 <a class='info' href='#RFC4949'>[3]<span> (</span><span class='info'>Shirey, R., &ldquo;Internet Security Glossary, Version 2,&rdquo; August&nbsp;2007.</span><span>)</span></a>: Since the Server is clearly capable of providing anyone access to the protected resources, no further analysis of the risks it presents is necessary; we assume it behaves as specified.
</p>
<p>The Resource Owner for a set of protected resources is also trusted in the sense that it can authorize any request from a Client; we assume that genuine ROs will only tell the server to authorize requests from Clients that it genuinely intends to authorize.  We do not assume that any entity acting as an RO is the genuine RO for the protected resources.  It will be necessary for the OAuth system to provide the Client and Server assurance that the RO in the process is the genuine owner of the resources in question.  (The Server can verify this directly, with standard authentication mechanisms; the Client will rely on an authenticated assertion by the Server.)
</p>
<p>All parties are assumed to maintain the security of their private authentication keys (the long-lived credentials that enable to authenticate to other protocol entities).  Beyond that minimal assumption, we make no security assumptions about the behavior of the Client.
</p>
<a name="threat-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Threat model</h3>

<p>The authorization system here is designed to protect against four classes of threats:
	  </p>
<ol class="text">
<li>Outside intervention in an otherwise honest transaction
</li>
<li>Malicious actors within the authorization process
</li>
<li>Collusion among actors within the authorization process
</li>
<li>Denial of service against the authorization process
</li>
</ol><p>
	
</p>
<p>The basic goal of the authorization system is to allow an honest Client, Server, and RO to delegate authorization even in the presence of external bad actors.  This goal is mainly accomplished by requiring authentication at critical points of the protocol to assure that the parties are always talking among themselves, and not to some outside actor.
</p>
<p>OAuth is also intended to prevent the abuse of the authorization process by legitimate participants in it, especially Clients.  This goal is addressed by a set of mechanisms that allow the Server and the Resource Owner to validate that the authorization process is conducted faithfully.
</p>
<p>A more advanced class of attack is when two or more participants collude in order to gain false access.  The primary example of this sort of attack is when two Clients collude so that the one more trusted by the RO can obtain access on behalf of the other.  This class of attack is addressed by assuring that the Client is consistently identified throughout the OAuth process.
</p>
<p>Finally, there are several points in the OAuth process where the injection of false information would cause the process to fail, even in the absence of other problems.  This threat can be minimized by ensuring that only authentic protocol participants can contribute information to the process.
</p>
<a name="authz-flow-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Authorization flow</h3>

<p>The OAuth authorization process is the process by which a Resource Owner can grant a Client permission to access resources protected by a Server.  This process occurs in four high-level steps, illustrated in <a class='info' href='#proc-flow-fig'>Figure&nbsp;1<span> (</span><span class='info'>High-level OAuth process flow</span><span>)</span></a>: 
        </p>
<ol class="text">
<li>The Client obtains a Request Token from the Server
</li>
<li>The Client requests authorization from the Resource Owner
</li>
<li>The Resource Owner validates the request and grants authorization
</li>
<li>The Client exchanges the Request Token for an Access Token
</li>
</ol><p>
      If the process fails at any point, no authorization is granted.
      
</p><br /><hr class="insert" />
<a name="proc-flow-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |    Issue Req. Token    |                        |
     |&lt;----------------------&gt;|                        |
     |                        |                        |
     |                        | Request authorization  |
     |------------------------------------------------&gt;|
     |                        |                        |
     |                        |    Issue Ver. Token    |
     |                        |&lt;----------------------&gt;|
     |                        |                        |
     |   Grant authorization  |                        |
     |&lt;------------------------------------------------|
     |                        |                        |
     |    Issue Acc. Token    |                        |
     |&lt;----------------------&gt;|                        |
     |                        |                        |
     ~                        ~                        ~
     |    Access Resources    |                        |
     |&lt;----------------------&gt;|                        |
     |                        |                        |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: High-level OAuth process flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="req-assm-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
General Requirements and Assumptions</h3>

<p>There are a number of authentication relationships that need to be in place before OAuth can be used to delegate authorization.  Client authentication is critical for preventing unauthorized parties from gaining access: The Client MUST be able to authenticate to both the Server and the Resource Owner.  Moreover, the Client MUST be able to authenticate the same identifier to both parties (e.g., using the same certificate in the context of HTTPS), so that the Server and the Resource Owner can verify that the Client that the RO authorizes is the same one that the Server will enable to access the protected resources.
</p>
<p>Likewise the Resource Owner MUST be able to authenticate both to Server and to the Client, and it MUST be able to authenticate the same identifier to both (it may have other identifiers with each).  The Server MUST be able to authenticate both to the Client and the RO, but it is not required to use the same identity for both.
</p>
<p>[[ Editor's note: The requirements that the Client and RO use the same identifiers across multiple relationships can be onerous, but is required to combat the Client and RO collusion attacks discussed in <a class='info' href='#col-act-sec'>Section&nbsp;5.3<span> (</span><span class='info'>Protection from colluding actors</span><span>)</span></a>, as are the identity checks by the RO and the Client that take advantage of these identifiers (in <a class='info' href='#not-authz-sec'>Section&nbsp;4.3.3<span> (</span><span class='info'>Notification of authorization</span><span>)</span></a> and <a class='info' href='#acc-t-iss-sec'>Section&nbsp;4.4<span> (</span><span class='info'>Access token issuance</span><span>)</span></a>).  If WG discussions indicate that either or both of these attacks are not to be addressed by this model, then the identity requirements and the corresponding checks can be removed; for now, they are listed as MUST-level requirements. ]]
</p>
<p>All messages in this process SHOULD be integrity- and confidentiality-protected; ones that MUST be so protected are noted below.  The security of the authorization process relies only on the authentication relationships above, but access to some parameters passed between OAuth entities could allow third parties to disrupt the OAuth process.
</p>
<a name="req-t-iss-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Request token issuance</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |   req-token-request    |                        |
1.   |-----------------------&gt;|                        |
     |                        |                        |
     |   req-token-issue      |                        |
     |       (req-t)          |                        |
2.   |&lt;-----------------------|                        |
     |                        |                        |

</pre></div>
<p>The OAUth process is initiated by a Client that wishes to access a given set of resources on the Server.  The authorization flow begins when the Client sends a request for a Request Token to the Server.  In response to this request, the Server MUST authenticate the Client.  If authentication is unsuccessful, the process fails.  If authentication succeeds, the Server MUST generate a random request token and store a binding between the request token and authenticated identity of the Client (denoted Cl-ID below).  During this transaction, the Client and the Server MAY negotiate the resources to which access is to be granted.
</p>
<p>Upon receiving a request token from the Server, the Client MUST authenticate the Server and store a binding between the Server's authenticated identity and the request token.
</p>
<p>The Request Token identifies a Client's request for authorization to access resources on the Server.  At issuance, the token is bound to a Client identity and a Server identity.  To uniquely identify an authorization transaction, the Server MUST ensure that each Request Token is unique within the set of such tokens that it issues.  Token values SHOULD be difficult for an outside entity to guess.  In order to avoid resource exhaustion at the Server, it is RECOMMENDED that Request Tokens have a limited lifetime.
</p>
<a name="authz-req-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Authorization of the request</h3>

<p>Before the Client can access protected resources, it must be authorized to access those resources: The Client must request authorization, the Resource Owner must notify the Server that it intends to grant access, and then the Resource Owner must actually grant access to the Client.  In addition, before the Resource Owner grants access, it must assure that the Client's request is authentic by validating it with the Server.
</p>
<a name="req-authz-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Request for authorization</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |                        |     request-authz      |
     |                        |        (req-t)         |
3.   |------------------------------------------------&gt;|
     |                        |                        |

</pre></div>
<p>The Client requests authorization to access resources by sending a message to the Resource Owner that contains an unused request token.  After sending a request token in an authorization request, the Client MUST mark that request token as used, and MUST NOT use the request token in any subsequent authorization request.
</p>
<p>If the Client wishes to verify that the RO that it interacts with on this step is the same entity that it interacts with later, then it MUST authenticate the RO and store a binding between the request token and the RO's authenticated identity (in addition to the binding to the Server's identity recorded earlier).  It should be noted however, that these steps are purely optional.  They provide no additional security guarantees with respect to the authorizations granted; they only allow the Client to track which request tokens have been used. (In the presence of session continuity mechanisms, such as HTTP cookies, this authentication may be used as the basis for the authentication required at the time of notification of authorization, described in <a class='info' href='#not-authz-sec'>Section&nbsp;4.3.3<span> (</span><span class='info'>Notification of authorization</span><span>)</span></a>.)
</p>
<p>Note that this transaction does not require the RO to authenticate the Client.  The Client will be authenticated in a later step, after the RO is told by the Server which Client identity is bound to the request token.
</p>
<a name="ver-t-iss-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Verification token issuance</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |                        |   ver-token-request    |
     |                        |        (req-t)         |
4.   |                        |&lt;-----------------------|
     |                        |                        |
     |                        |    ver-token-issue     |
     |                        |  (ver-t,cl-id,scope)   |
5.   |                        |-----------------------&gt;|
     |                        |                        |

</pre></div>
<p>The Resource Owner validates the request for authorization and obtains the ability to grant authorization by requesting a verification token from the Server.  This request MUST include the request token provided by the Client.  Before sending this request, the RO SHOULD authenticate the Server, since a false Server can disrupt the authorization process (but not cause unintended authorization to be granted).
</p>
<p>When the Server receives a request for a verification token, it MUST take the following actions, in order:
	    </p>
<ol class="text">
<li>Authenticate the Resource Owner and verify that the RO owns the resources subject to authorization
</li>
<li>Verify that the request token has not been used in a prior request.  If so, the process fails; if not, the request token is marked as used.
</li>
<li>Generate a random verification token that is unique in the scope of such tokens
</li>
<li>Store a binding between the verification token, the Client identity bound to the request token, and the RO's authenticated identity
</li>
<li>Establish an integrity- and confidentiality-protected channel to the RO (if one does not already exist, e.g., the channel used the request)
</li>
<li>Send a message to the RO containing the following information:
	        
<ul class="text">
<li>The verification token
</li>
<li>The Client identity bound to the request token
</li>
<li>The scope of the authorization to be provided (i.e., the set of resources)
</li>
</ul>
	      
</li>
</ol><p>
	    The Server and the RO MAY also perform further negotiation of the scope of the authorization at this point.
	  
</p>
<p>It should be emphasized that the Server MUST NOT transmit the verification token over any channel that is not authenticated, integrity-protected, and confidentiality-protected, since the verification token is highly sensitive information: Any third party that intercepts the verification token is capable of granting the Client access to the protected resources, and any party that can inject or modify a verification token can cause the RO to grant unintended accesses.
</p>
<p>Upon receiving the Server's message (authenticating the Server again, if necessary), the RO stores a binding between the verification token and the Client identity provided by the Server.
</p>
<p>Some might note that there is an asymmetry to the security requirements for the two halves of this transaction: The request for a verification token is only authenticated, while the response also needs to be confidentiality- and integrity-protected.  This is because the injection of a false request token can only cause the process to fail (since the Client identity provided by the server will be wrong), while leakage of the verification token can cause used to grant an unintended authorization.  For simplicity, it is RECOMMENDED that the same channel (with full protections) be used for the request and the response.
</p>
<p>Note that at this point in the process, no authorization has been granted.  The Server has only issued the Resource Owner a verification token so that the RO can grant authorization if desired.  The Server MUST NOT provide the Client access to protected resources until the RO has provided the verification token to the Client, and Client has exchanged the verification token for an access token, as described below.
</p>
<a name="not-authz-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Notification of authorization</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |    authz-notify        |                        |
     |    (ver-t,req-t)       |                        |
6.   |&lt;------------------------------------------------|
     |                        |                        |

</pre></div>
<p>If the Resource Owner decides to authorize the Client to access protected resources (the set bound to the verification token), then it signals this by sending a message to the Client containing the verification token.  Before sending such a message, the RO MUST authenticate the Client and establish an integrity- and confidentiality-protected (i.e., encrypted) channel to the authenticated Client.  If the authenticated identity of the Client does not match the Client identity bound to the verification token, or if the authentication fails, then the process fails and the RO MUST NOT send the verification token to the Client.  As above, the RO MUST NOT transmit the verification token over any channel that is not authenticated, integrity-protected, and confidentiality-protected.
</p>
<p>Upon receipt of an authorization notification message, the Client MUST authenticate the RO and store a binding between the RO's authenticated identity and the verification token.  The Client MUST also store a binding between the verification token and the Server identity bound to the request token.   The Client MAY verify that the RO's authenticated identity matches the one bound earlier to the request token.
</p>
<a name="acc-t-iss-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Access token issuance</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |   acc-token-request    |                        |
     |        (ver-t)         |                        |
7.   |-----------------------&gt;|                        |
     |                        |                        |
     |    acc-token-issue     |                        |
     |     (acc-t,ro-id)      |                        |
8.   |&lt;-----------------------|                        |
     |                        |                        |

</pre></div>
<p>The Client obtains access to the designated resources by exchanging a verification token that it has received for an access token.  To request an access token, the Client sends the verification token to the Server.  Before sending this message, the Client MUST authenticate the Server and verify that the authenticated Server identity is the one bound to the verification token (i.e., the Server identity that the Client originally bound to the request token).
</p>
<p>Upon receiving a request for an access token, the Server MUST authenticate the Client and verify (1) that the verification token provided is one that it issued, and (2) that the Client's authenticated identity matches the identity bound to the verification token.  If both criteria are satisfied, then the Server MUST generate a random access token (unique within the scope of such tokens) and store a binding between the access token, the Client's authenticated identity, the RO identity bound to the verification token, and the resources bound to the verification token.
</p>
<p>The Server completes the authorization process by sending to the Client a message containing (1) the access token and (2) an identifier for the RO to which the verification token was issued. The Client MUST authenticate the Server prior to accepting such a message and verify that the Server's identity matches that bound to the request token and verification token.  The Client MUST also verify that the RO identity returned by the Server matches the RO identity bound to the verification token.  If both verifications succeed, then the Client stores a binding between the access token and the protected resources.
</p>
<p>Note that because the Client received the verification token over a confidentiality-protected channel, the Server's acceptance of the verification token provides the Client assurance that the entity that provided the verification token was authorized (at the Server) to grant the specified authorization.
</p>
<a name="acc-res-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Accessing protected resources</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |    acc-res-request     |                        |
     |        (acc-t)         |                        |
9.   |-----------------------&gt;|                        |
     |                        |                        |
     |       resources        |                        |
     |&lt;-----------------------|                        |
     |                        |                        |

</pre></div>
<p>Finally, once a Client is authorized to access resources on the Server, it accesses them using the corresponding access token.  When a Client wishes to access resources, it sends a request to the Server containing the access token.  The Server MUST authenticate the Client and verify that the access token presented belongs to the authenticated Client before responding with the requested resources.
</p>
<a name="authz-sum-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Summary</h3>

<p>All of the interactions above are summarized in <a class='info' href='#msg-flow-fig'>Figure&nbsp;4<span> (</span><span class='info'>OAuth message flow</span><span>)</span></a>, below.  <a class='info' href='#req-tok-life-fig'>Figure&nbsp;2<span> (</span><span class='info'>Life cycle of a request token</span><span>)</span></a> and <a class='info' href='#ver-tok-life-fig'>Figure&nbsp;3<span> (</span><span class='info'>Life cycle of a verification token</span><span>)</span></a> illustrate the life-cycles of the request token and the verification token, respectively.
</p><br /><hr class="insert" />
<a name="req-tok-life-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  1. Issues token  +--------+              +--------+  2. Uses token
  4. Provides info | Server |-------------&gt;| Client |     request authz
     to validate   +--------+              +--------+
     (Client ID)      | ^                      |
                      | |     +----------+     |
                      | +-----| Resource |&lt;----+
                      +------&gt;|   Owner  |
                              +----------+
                           3. Uses token to request
                              verification token
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Life cycle of a request token&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="ver-tok-life-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  1. Issues token  +--------+              +--------+  2. Uses token
  4. Provides info | Server |&lt;-------------| Client |     request
     to validate   +--------+-------------&gt;+--------+     access tok.
     (RO ID)            |                      ^
                        |     +----------+     |
                        +----&gt;| Resource |-----+
                              |   Owner  |
                              +----------+
                           3. Uses token to
                              grant authz
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Life cycle of a verification token&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<a name="msg-flow-fig"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Client                   Server               Resource Owner
     |                        |                        |
     |   req-token-request    |                        |
1.   |-----------------------&gt;|                        |
     |                        |                        |
     |   req-token-issue      |                        |
     |       (req-t)          |                        |
2.   |&lt;-----------------------|                        |
     |                        |                        |
     |                        |     request-authz      |
     |                        |        (req-t)         |
3.   |------------------------------------------------&gt;|
     |                        |                        |
     |                        |   ver-token-request    |
     |                        |        (req-t)         |
4.   |                        |&lt;-----------------------|
     |                        |                        |
     |                        |    ver-token-issue     |
     |                        |  (ver-t,cl-id,scope)   |
5.   |                        |-----------------------&gt;|
     |                        |                        |
     |     authz-notify       |                        |
     |     (ver-t,req-t)      |                        |
6.   |&lt;------------------------------------------------|
     |                        |                        |
     |   acc-token-request    |                        |
     |        (ver-t)         |                        |
7.   |-----------------------&gt;|                        |
     |                        |                        |
     |    acc-token-issue     |                        |
     |     (acc-t,ro-id)      |                        |
8.   |&lt;-----------------------|                        |
     |                        |                        |
     ~                        ~                        ~
     |    acc-res-request     |                        |
     |        (acc-t)         |                        |
9.   |-----------------------&gt;|                        |
     |                        |                        |
     |       resources        |                        |
     |&lt;-----------------------|                        |
     |                        |                        |

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: OAuth message flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec-anal-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security analysis</h3>

<p>As described in the design goals above, the OAuth model aims to protect against four general classes of threat:
	  </p>
<ol class="text">
<li>Outside intervention in an otherwise honest transaction
</li>
<li>Malicious actors within the authorization process
</li>
<li>Collusion among actors within the authorization process
</li>
<li>Denial of service against the authorization process
</li>
</ol><p>
      In this section, we discuss how the model described above addresses each class of threat.
</p>
<a name="out-int-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Protection from outside interference</h3>

<p>The authentication requirements of the OAuth process prevent outside entities from interfering with the process.  This property means that if each party assumes that the other authenticated parties behave as the process specifies, all three parties are assured that the genuine RO has authorized the Client to access the specified resources on the Server, i.e., that no outside actors have corrupted the process.  (The next section discusses how the parties can be sure that misbehaving actors cannot create unintended authorizations.)
</p>
<p>The Server's assurance comes from its knowledge of the token bindings and its confidence in the authenticated identities of the Client and the RO.  The Server is assured of the Client's identity because the Client authenticated that identity when it requested the request token and when it exchanged the verification token for the access token.  The Server is assured that the genuine RO authorized the Client because it received the verification token from the Client, and because it knows that it only issued the verification token to the genuine RO (and because it trusts that the RO only gives the verification token to parties it intends to authorize).
</p>
<p>The RO is assured that it knows the real identity of the authorized Client because it has verified that the identity that the Server will provide access to (provided by the server with the verification token) is the same as the authenticated identity of the Client that the RO gave the verification token to.  The RO is also assured that no other Client has received the verification token because it transmitted that token only over an authenticated, confidentiality-protected channel.  (Of course, the RO knows that it is the genuine owner of the subject resources.)
</p>
<p>The Client is assured that the Server from which it will receive resources is the same as the Server it requested authorization from by the persistence of the Server's identity between the requests for the request token and the access token (and subsequent requests for resources).  The Client knows that the RO is the genuine RO because it has verified that the authenticated identity of the RO matches the genuine RO identity provided by the Server.  The Client knows that it is the intended recipient of the authorization because the Server accepts the verification token in a request authenticated with the Client's identity (i.e., because the Server only accepts verification tokens submitted with the identity bound to the verification token).
</p>
<a name="mal-act-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Protection from malicious actors within the model</h3>

<p>The OAuth model ensures that the process fails (i.e., no authorization is granted) if any actor in the process acts improperly.  Here we consider the avenues for misbehavior available to each role, and discuss how the model prevents them from having ill effects.  Of course, since the Server is trusted, it can subvert the process by granting access to any party, so we do not consider its behavior in any further detail.
</p>
<p>The RO performs two actions in the protocol that it might attempt to exploit to create unauthorized accesses: First it sends request tokens to the server to obtain verification tokens, and second, it sends verification tokens to the Client to grant access.  Because the Server verifies that the RO owns the subject resources before it issues a verification token, a RO cannot obtain a verification token for resources it does not own.  Moreover, once an RO has obtained a verification token for resources, that token can only be used by the Client that requested the request token; the RO cannot use it to grant access to any other Client.  So a malicious RO cannot use the OAuth process to grant access beyond its ownership, or beyond the intended Client.
</p>
<p>In order to obtain access to protected resources, a Client needs to obtain a verification token bound to its identity and the protected resources.  However, verification tokens are only issued to the genuine RO, and only bound to the Client identity that the Server associates with a request token.  So the only way for a Client to obtain access without violating the authentication constraints of the model (i.e., forging an authentication or obtaining another Client's private authentication key) is to obtain a request token with its own Client identity, and convince the genuine RO to authorize this request token -- namely, to go through the proper OAuth procedure.  So the only risk from misbehaving Clients is from social engineering attacks against the RO (e.g., phishing).
</p>
<a name="col-act-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Protection from colluding actors</h3>

<p>It is possible for multiple actors within the OAuth process to collude in order to subvert the process.  There are six possible combinations of roles, including multiple actors in the same role:
	  </p>
<ol class="text">
<li>Server -- Server
</li>
<li>Server -- Client
</li>
<li>Server -- RO
</li>
<li>Client -- RO
</li>
<li>Client -- Client
</li>
<li>RO -- RO
</li>
</ol><p>
	Of these, we need only consider the latter three, since collusion with the Server is irrelevant (the Server can simply provide the desired accesses or resources). 
</p>
<p>Since a legitimate Client and RO can already allow the Client access to the RO's resources, the only remaining objective for such a collusion would be to convince the Server that access was really being granted to another Client.  This attack, however, is prevented by the requirement that the Client authenticate all its interactions with the Server: The RO can only grant access to a Client identity bound to a request token, and that binding is established by a transaction in which the Client's identity is authenticated.
</p>
<p>Two Clients cannot by themselves obtain any access, so two colluding, unauthorized Clients do no damage (neither can present a request token that will result in an authorization).  However, if one Client is authorized (say C1), the other (C2) might try to use it to gain access, in the following way: C2 could register a token for itself, pass that token to C1, and have C1 request authorization.  If the RO fails to verify that the Client identity bound to the request token (provided by the Server) matches the identity of the requesting Client, then the RO will return the verification token to C1.  C1 can then pass the verification token to C2, who can then obtain an access token and access resources.  On the other hand, if the Client does perform the specified verification that the two identities match, then the risk that this collusion will result in unintended access is removed.
</p>
<p>In a similar vein, the major risk from colluding ROs is that they convince the Client that any given colluding RO is the proper owner of resources than any other colluding RO owns. (It is a given that they can grant access to their own resources, and there are no attacks available against the Server, since it has authoritative knowledge.)  To accomplish this attack, when the Client requests authorization from one RO (say RO1), that RO passes the request token to another RO (RO2).  RO2 then acquires a verification token and passes it back to RO1, who uses it to notify the Client.  If the Client fails to compare RO1's authenticated identity to the identity bound to the verification token (provided by the Server), then the Client will think that RO1 is the owner of resources that actually belong to RO2.  On the other hand, if the client does perform this check (as required), then this risk is eliminated.
</p>
<a name="dos-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Protection from denial of service</h3>

<p>The successful completion of the OAuth process is dependent on using tokens to communicate bindings between identities and authorizations.  Entities that can inject false tokens of any type can therefore cause the process to fail (false in the sense that they are not bound to any identity at the server).  The model is secured against this type of denial of service attack because senders of information are authenticated where necessary, and because messages are integrity-protected to prevent tampering en route.
</p>
<p>The OAuth process allows the Client and the RO to force the Server to maintain state, in the form of bindings between request and verification tokens and other information.  The requirement for the server to maintain this state information makes it vulnerable to resource exhaustion attacks.  The Server can mitigate this risk by imposing a limited life-time on request tokens and verification tokens, at the risk that an OAuth process that is not completed within the life-time of the appropriate tokens will fail.
</p>
<a name="ack-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Acknowledgements</h3>

<p>This document is essentially an abstraction and security analysis of the current OAuth protocol <a class='info' href='#I-D.hammer-oauth'>[1]<span> (</span><span class='info'>Hammer-Lahav, E., &ldquo;The OAuth 1.0 Protocol,&rdquo; February&nbsp;2010.</span><span>)</span></a>.  We are thus deeply in debt to the authors of that protocol, especially Eran Hammer-Lahav, who provided several helpful explanations of the current OAuth protocol specification as this document was being developed.
</p>
<a name="iana-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This memo makes no request to IANA.
</p>
<a name="sec-cons-sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>This document describes a security model for delegated authorization, especially in the World Wide Web context.  As such, security considerations are discussed in detail throughout.
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.hammer-oauth">[1]</a></td>
<td class="author-text">Hammer-Lahav, E., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-hammer-oauth-10.txt">The OAuth 1.0 Protocol</a>,&rdquo; draft-hammer-oauth-10 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-hammer-oauth-10.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[2]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4949">[3]</a></td>
<td class="author-text">Shirey, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>,&rdquo; RFC&nbsp;4949, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4949.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Richard Barnes</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BBN Technologies</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">9861 Broken Land Parkway</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Columbia, MD  21046</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 410 290 6169</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rbarnes@bbn.com">rbarnes@bbn.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Matthew Lepinski</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BBN Technologies</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">10 Moulton St</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cambridge, MA  02138</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 617 873 5939</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mlepinski@bbn.com">mlepinski@bbn.com</a></td></tr>
</table>
</body></html>
