split = 1 + (((range - 1) * probability)]] >> 8)

c = 4;
retval = 1;
retval = 0;
v = (v << 1) + read_bool( d, 128);
v = -1;
v = (v << 1) + read_bool( d, 128);
num_uv_modes = B_PRED,  /* first four modes apply to chroma */
H_PRED = "101" */
B_PRED = "111" */
V_PRED = "101" */
TM_PRED = "111" */
TM_PRED = "111" */
Ymode = (intra_mbmode) treed_read( d, ymode_tree,
     pretend_its_huffman);

yac_qi     = L(7);           /* Y ac index always specified */
ydc_delta  = F? delta(): 0;  /* Y dc delta specified if
                                   flag is true */

y2dc_delta = F? delta(): 0;  /* Y2 dc delta specified if
                                   flag is true */
y2ac_delta = F? delta(): 0;  /* Y2 ac delta specified if
                                   flag is true */

uvdc_delta = F? delta(): 0;  /* chroma dc delta specified
                                   if flag is true */
uvac_delta = F? delta(): 0;  /* chroma ac delta specified
                                   if flag is true */

num_uv_modes = B_PRED,  /* first four modes apply to chroma */
V_PRED = "101" */
TM_PRED = "111" */
Ymode = (intra_mbmode) treed_read( d, kf_ymode_tree, kf_ymode_prob);

B_VR_PRED = "111011" */
HU = "11111111" */
Bmode = (intra_bmode) treed_read( d, bmode_tree, kf_bmode_prob
     [A] [L]);

TM_PRED = "111" */
uv_mode = (intra_mbmode) treed_read( d, uv_mode_tree,
     kf_uv_mode_prob);

X_ij = L_i + A_j - P (i, j=0, 1, 2, 3)

i = 0;  do {    /* fill prediction buffer with constant DC
                              value */
               int j = 0;  do { B[i][j] = v;}  while( ++j < 4);
v = avg3p( L + r);  /* upper 3 rows use average of
                                      3 pixels */
cat2 = "111101" */
cat4 = "1111101" */
cat4 = "1111111" */
v = -v;

ctx2 = coef_bands[i];
probTable = coef_probs[plane][ctx2][ctx3];

token = treed_read ( d, **coef_tree_without_eob**,
             probTable );
token = treed_read ( d, coef_tree, probTable );

currentBlockHasCoeffs = true;
extraBits = DCTextra( token );
absValue =
             categoryBase[**token_to_cat_index(token)**] +
absValue = **token_to_abs_value(token)**;
sign = read_bool(d, 128);
           block[i] = sign ? -absValue : absValue;
       }
       else
       {
absValue = 0;
prevCoeffWasZero = true;
a1 = ip[0] + ip[12];
b1 = ip[4] + ip[8];
c1 = ip[4] - ip[8];
d1 = ip[0] - ip[12];
ip = output;
op = output;
a1 = ip[0] + ip[3];
b1 = ip[1] + ip[2];
c1 = ip[1] - ip[2];
d1 = ip[0] - ip[3];

a2 = a1 + b1;
b2 = c1 + d1;
c2 = a1 - b1;
d2 = d1 - c1;

a1 = ((input[0] + 3)>>3);

a1 = ip[0]+ip[8];
b1 = ip[0]-ip[8];

temp1 = (ip[4] * sinpi8sqrt2)>>16;
temp2 = ip[12]+((ip[12] * cospi8sqrt2minus1)>>16);
c1 = temp1 - temp2;

temp1 = ip[4] + ((ip[4] * cospi8sqrt2minus1)>>16);
temp2 = (ip[12] * sinpi8sqrt2)>>16;
d1 = temp1 + temp2;

ip = output;
op = output;
a1 = ip[0]+ip[2];
b1 = ip[0]-ip[2];

temp1 = (ip[1] * sinpi8sqrt2)>>16;
temp2 = ip[3]+((ip[3] * cospi8sqrt2minus1)>>16);
c1 = temp1 - temp2;

temp1 = ip[1] + ((ip[1] * cospi8sqrt2minus1)>>16);
temp2 = (ip[3] * sinpi8sqrt2)>>16;
d1 = temp1 + temp2;

a = c( a + 4) >> 3;

p0 = u2s(*P0);
q3 = u2s(*Q3);

p0 = u2s(*P0);
q3 = u2s(*Q3);

a = c( (18*w + 63) >> 7);

a = c( (9*w + 63) >> 7);

interior_limit = 9 - sharpness_level;
interior_limit = 1;

hev_threshold = 2;
hev_threshold = 1;
hev_threshold = 3;
hev_threshold = 2;
hev_threshold = 1;
H_PRED = "101" */
B_PRED = "111" */
mv_nearest = num_ymodes, /* use "nearest" motion vector
                                   for entire MB */
num_mv_refs = mv_split + 1 - mv_nearest
xmv = x->mbmi.mv.as_mv;
tmp = cnt[CNT_NEAREST];
tmp = near_mvs[CNT_NEAREST].as_int;
mvr = (mv_ref) treed_read( d, mv_ref_tree, mv_ref_p);

left_right = "111" */
part = (MVpartition) treed_read( d, mvpartition_tree,
     mvpartition_probs);

LEFT4x4 = num_intra_bmodes,   /* use already-coded MV to
                                        my left */
sub_ref = (sub_mv_ref) treed_read( d, sub_mv_ref_tree,
         sub_mv_ref_prob[context]);

MVPbits = MVPshort + 7,      /* 8 long value bits
                                       w/independent probs */

MVPcount = MVPbits + 10      /* 19 probabilities in total */
i = 9;
A = treed_read( d, small_mvtree, p + MVPshort);

x = x & (~7);
y = y & (~7);

tmp = (c[2] << 16) | (c[1] << 8) | c[0];

key_frame = tmp & 0x1;
version = (tmp >> 1) & 0x7;
show_frame = (tmp >> 4) & 0x1;
first_part_size = (tmp >> 5) & 0x7FFFF;


tmp = (c[1] << 8) | c[0];

width = tmp & 0x3FFF;
horizontal_scale = tmp >> 14;

tmp = (c[3] << 8) | c[2];

height = tmp & 0x3FFF;
vertical_scale = tmp >> 14;

retval = 1;
retval = 0;
FRAME_HEADER_SZ = 3,
KEYFRAME_HEADER_SZ = 7
update = last_q != hdr->q_index;
q = quant_hdr->q_index;

q = (!seg->abs) ? q + seg->quant_idx[i]
                               : seg->quant_idx[i];

partition = 0;
raw = data[0] | (data[1] << 8) | (data[2] << 16);
raw = data[6] | (data[7] << 8)
                 | (data[8] << 16) | (data[9] << 24);
MB_FEATURE_TREE_PROBS = 3,
MAX_MB_SEGMENTS = 4
BLOCK_CONTEXTS = 4
MAX_PARTITIONS = 8
BLOCK_TYPES        = 4,
PREV_COEF_CONTEXTS = 3,
COEF_BANDS         = 8,
ENTROPY_NODES      = 11,
MV_PROB_CNT = 2 + 8 - 1 + 10 /* from entropymv.h */
B_DC_PRED = 0, B_TM_PRED, B_VE_PRED, B_HE_PRED, B_LD_PRED,
a = 3 * (q0 - p0);

a = saturate_int8(a);

f1 = ((a + 4 > 127) ? 127 : a + 4) >> 3;
f2 = ((a + 3 > 127) ? 127 : a + 3) >> 3;

p0 = saturate_uint8(p0 + f2);
q0 = saturate_uint8(q0 - f1);

a = (f1 + 1) >> 1;
p1 = saturate_uint8(p1 + a);
q1 = saturate_uint8(q1 - a);
w = saturate_int8(saturate_int8(p1 - q1) + 3 * (q0 - p0));

a = (27 * w + 63) >> 7;
p0 = saturate_uint8(p0 + a);
q0 = saturate_uint8(q0 - a);

a = (18 * w + 63) >> 7;
p1 = saturate_uint8(p1 + a);
q1 = saturate_uint8(q1 - a);

a = (9 * w + 63) >> 7;
p2 = saturate_uint8(p2 + a);
q2 = saturate_uint8(q2 - a);

filter_level = ctx->loopfilter_hdr.level;

filter_level =
                   ctx->segment_hdr.lf_level[mbi->base.segment_id];
filter_level = 63;
filter_level = 0;

filter_level = 63;
filter_level = 0;

interior_limit = filter_level;

interior_limit = 9 - ctx->loopfilter_hdr.sharpness;
interior_limit = 1;

hev_threshold = (filter_level >= 15);

stride    = ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_Y];
uv_stride = ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_U];
y = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_Y];
u = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_U];
v = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_V];
mbi = ctx->mb_info_rows[row] + start_col;

stride    = ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_Y];
y = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_Y];
mbi = ctx->mb_info_rows[row] + start_col;

a1 = ip[0] + ip[12];
b1 = ip[4] + ip[8];
c1 = ip[4] - ip[8];
d1 = ip[0] - ip[12];

ip = output;
op = output;

a1 = ip[0] + ip[3];
b1 = ip[1] + ip[2];
c1 = ip[1] - ip[2];
d1 = ip[0] - ip[3];

a2 = a1 + b1;
b2 = c1 + d1;
c2 = a1 - b1;
d2 = d1 - c1;

a1 = ip[0] + ip[8];
b1 = ip[0] - ip[8];

temp1 = (ip[4] * sinpi8sqrt2 + rounding) >> 16;
temp2 = ip[12] +
               ((ip[12] * cospi8sqrt2minus1 + rounding) >> 16);
c1 = temp1 - temp2;

temp1 = ip[4] +
               ((ip[4] * cospi8sqrt2minus1 + rounding) >> 16);
temp2 = (ip[12] * sinpi8sqrt2 + rounding) >> 16;
d1 = temp1 + temp2;

coeffs = tmp;

a1 = coeffs[0] + coeffs[2];
b1 = coeffs[0] - coeffs[2];

temp1 = (coeffs[1] * sinpi8sqrt2 + rounding) >> 16;
temp2 = coeffs[3] +
               ((coeffs[3] * cospi8sqrt2minus1 + rounding) >> 16);
c1 = temp1 - temp2;

temp1 = coeffs[1] +
               ((coeffs[1] * cospi8sqrt2minus1 + rounding) >> 16);
temp2 = (coeffs[3] * sinpi8sqrt2 + rounding) >> 16;
d1 = temp1 + temp2;

y_mode = bool_read_tree(bool, kf_y_mode_tree, kf_y_mode_probs);

b = bool_read_tree(bool, b_mode_tree,
                                  kf_b_mode_probs[a][l]);
uv_mode = bool_read_tree(bool, uv_mode_tree, kf_uv_mode_probs);

y_mode = bool_read_tree(bool, y_mode_tree, hdr->y_mode_probs);

b = bool_read_tree(bool, b_mode_tree,
                                  default_b_mode_probs);
uv_mode = bool_read_tree(bool, uv_mode_tree, hdr->uv_mode_probs);

LONG_WIDTH = 10};
x = bool_read_tree(bool, small_mv_tree, mvc + SHORT);

x = -x;

ctx = SUBMVREF_LEFT_ABOVE_ZED;
ctx = SUBMVREF_LEFT_ABOVE_SAME;
ctx = SUBMVREF_ABOVE_ZED;
ctx = SUBMVREF_LEFT_ZED;

CNT_BEST = 0,
CNT_ZEROZERO = 0,
tmp = cnt[CNT_NEAREST];
tmp = near_mvs[CNT_NEAREST].raw;
partition_id = bool_read_tree(bool, split_mv_tree,
                                     split_mv_probs);
partition = mv_partitions[partition_id];
left_mv = left_block_mv(this, left, k);
above_mv = above_block_mv(this, above, k);
subblock_mode = submv_ref(bool, left_mv,  above_mv);

mv = left_mv;
mv = above_mv;
r = w - (l + b_w);
b = h - (t + b_w);

x = (-bounds->to_left - 128) >> 3;
y = (-bounds->to_top - 128) >> 3;
w = ctx->mb_cols * 16;
h = ctx->mb_rows * 16;

clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
this = ctx->mb_info_rows[row] + start_col;
above = ctx->mb_info_rows[row - 1] + start_col;

mbi_w = ctx->mb_cols + 1; /* For left border col */
mbi_h = ctx->mb_rows + 1; /* For above border row */

mbi = ctx->mb_info_storage + 1;

BORDER_PIXELS     = 16,
dc = (dc + 16) >> 5;
dc = (dc + 8) >> 4;
dc = (dc + 4) >> 3;
stride = stride / sizeof(unsigned int);
tmp = *copy;
temp = (reference[-2] * filter[0]) +
                      (reference[-1] * filter[1]) +
                      (reference[ 0] * filter[2]) +
                      (reference[ 1] * filter[3]) +
                      (reference[ 2] * filter[4]) +
                      (reference[ 3] * filter[5]) +
                      64;
temp = (reference[-2*reference_stride] * filter[0]) +
                      (reference[-1*reference_stride] * filter[1]) +
                      (reference[ 0*reference_stride] * filter[2]) +
                      (reference[ 1*reference_stride] * filter[3]) +
                      (reference[ 2*reference_stride] * filter[4]) +
                      (reference[ 3*reference_stride] * filter[5]) +
                      64;
mx = mv->d.x & 7;
my = mv->d.y & 7;
reference = output;
predict = filter_block(output, reference, stride, mv, filters);
temp = mbi->split.mvs[b].d.x +
              mbi->split.mvs[b+1].d.x +
              mbi->split.mvs[b+4].d.x +
              mbi->split.mvs[b+5].d.x;

temp = mbi->split.mvs[b].d.y +
              mbi->split.mvs[b+1].d.y +
              mbi->split.mvs[b+4].d.y +
              mbi->split.mvs[b+5].d.y;

ref_row = src - x - y * stride;

left = x < 0 ? -x : 0;
left = b_w;

right = x + b_w - w;

right = b_w;

copy = b_w - left - right;

reference = emul_block + 2 * stride + 2;
predict = filter_block(output, reference, stride, mv, filters);
x = mb_col * 16;
y = mb_row * 16;
w = ctx->mb_cols * 16;
h = ctx->mb_rows * 16;
output = img->y;
reference_offset = ctx->ref_frame_offsets[mbi->base.ref_frame];
reference = output + reference_offset;

uvmv = mbi->base.mv;
ymv = &mbi->base.mv;
ymv = mbi->split.mvs + b;

x = mb_col * 16;
y = mb_row * 16;

uvmv = mbi->base.mv;
reference_offset = ctx->ref_frame_offsets[mbi->base.ref_frame];

ymv = &mbi->base.mv;
ymv = mbi->split.mvs + b;
this_frame_base = ctx->ref_frames[CURRENT_FRAME]->img.img_data;

mbi = ctx->mb_info_rows[row] + start_col;
coeffs = ctx->tokens[row &
           (ctx->token_hdr.partitions - 1)].coeffs +
           25 * 16 * start_col;

v = (bool_get_bit(bool) ? -value_to_sign \
                               : value_to_sign) * dqf[!!c];

prob = type_probs; \
prob = type_probs + (ENTROPY_NODES*2); \
eob_mask = 0;

i = 24;
stop = 24;
type = 1;
b_tokens = tokens + 24 * 16;
dqf = factor[TOKEN_BLOCK_Y2];
i = 0;
stop = 16;
type = 3;
b_tokens = tokens;
dqf = factor[TOKEN_BLOCK_Y1];
type_probs = probs[type][0][0];

t = left[left_context_index[i]] + above[above_context_index[i]];
c = !type; /* all blocks start at 0 except type 0, which starts
                   * at 1. */

prob = type_probs;
val = extrabits[DCT_VAL_CATEGORY6].min_val;
bits_count = extrabits[DCT_VAL_CATEGORY6].length;

val = extrabits[DCT_VAL_CATEGORY5].min_val;
val = extrabits[DCT_VAL_CATEGORY4].min_val;
val = extrabits[DCT_VAL_CATEGORY3].min_val;
val = extrabits[DCT_VAL_CATEGORY2].min_val;
val = extrabits[DCT_VAL_CATEGORY1].min_val;
prob = type_probs + ENTROPY_NODES;

t = (c != !type);   // any nonzero data?
type = 0;
i = 0;
stop = 16;
type_probs = probs[type][0][0];
b_tokens = tokens;
dqf = factor[TOKEN_BLOCK_Y1];
type = 2;
type_probs = probs[type][0][0];
stop = 24;
dqf = factor[TOKEN_BLOCK_UV];
dqf = ctx->dequant_factors  + mbi->base.segment_id;
VPX_DEC_OK = VPX_CODEC_OK,

VPX_DEC_ERROR = VPX_CODEC_ERROR,

VPX_DEC_MEM_ERROR = VPX_CODEC_MEM_ERROR,

VPX_DEC_ABI_MISMATCH = VPX_CODEC_ABI_MISMATCH,

VPX_DEC_UNSUP_BITSTREAM = VPX_CODEC_UNSUP_BITSTREAM,

VPX_DEC_UNSUP_FEATURE = VPX_CODEC_UNSUP_FEATURE,

VPX_DEC_CORRUPT_FRAME = VPX_CODEC_CORRUPT_FRAME,

VPX_DEC_INVALID_PARAM = VPX_CODEC_INVALID_PARAM,

VPX_DEC_LIST_END = VPX_CODEC_LIST_END

stride_align = 1;

bps = 32;
bps = 24;
bps = 16;
bps = 12;
bps = 16;
xcs = 1;
xcs = 0;
ycs = 1;
ycs = 0;
align = (1 << xcs) - 1;
w = (d_w + align) & ~align;
align = (1 << ycs) - 1;
h = (d_h + align) & ~align;
s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
s = (s + stride_align - 1) & ~(stride_align - 1);

img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));

data = img->img_data;

VPX_IMG_FMT_YV12    = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 1, /**< planar YVU */
VPX_IMG_FMT_I420    = VPX_IMG_FMT_PLANAR | 2,
VPX_IMG_FMT_VPXYV12 = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 3, /** < planar 4:2:0 format with
                                            vpx color space */
VPX_IMG_FMT_VPXI420 = VPX_IMG_FMT_PLANAR | 4   /** < planar
             4:2:0 format with vpx color space */
