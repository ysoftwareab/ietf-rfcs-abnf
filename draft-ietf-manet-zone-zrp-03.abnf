A  ===> B      information passed from protocol A to protocol B

my_link_changed = FALSE;
link_source = MY_ID;
pk_source   = MY_ID;
state_id    = MY_LINK_STATE_ID;
radius      = MY_ROUTING_ZONE_RADIUS;

full_link_state = 0;
current_update  = COMPLETE;
all_updates     = COMPLETE;

link_status = UP;
link_status = DOWN;

my_link_changed = TRUE;
status = add(Link_State_Table, link_source, link_dest, mask,
                     radius, link_metric, state_id, flags);

cum_status = UPDATE_IN_PROGRESS;
cum_status == UPDATE_IN_PROGRESS)
rebuild = TRUE;
rebuild = update(Link_State_Table);
cum_status = UPDATE_COMPLETE;

num_dests = |dests|
num_nodes = |routes|
repair_link = FALSE;
removal_timer = ROUTE_QUERY_TIMEOUT;
repair_link = TRUE;
removal_timer = 0;
dests = lost_node;
TTL = MAX_REPAIR_HOPS;
TTL = MAX_FULL_QUERY_HOPS;
 
source    = MY_ID
query_id  = MY_QUERY_ID++;
type      = ROUTE_QUERY;
hop_count = 0;
route     = NULL;
current_hop_ptr = 0;

prev_hops = route(1 : current_hop_ptr);
metrics = compress(metrics, 
                                  get_metrics(prev_hops|prev_hop|,MY_ID));
find_all  =  flags(0);
find_any  = !flags(0);
found_any = FALSE;
found_all = TRUE;

DESTS     = dests;
METRICS   = metrics;
found_any       = TRUE;
dests           = dest;
type            = QUERY_EXTENSION;
prev_hops       = NULL;
next_hops       = Routing_Table[dest].route;
route           = {prev_hops,MY_ID,next_hops};
current_hop_ptr = |prev_hops|+1;
type            = ROUTE_REPLY;
reply_node      = MY_ID;
reply_id        = MY_REPLY_ID++;                            
next_hops       = Routing_Table[dest].route;
prev_hops   = inject_loopfree_path(next_hops,
                                        Temp_Query_Cache[source,query_id]);
metrics         = NULL;
route           = {prev_hops,MY_ID,next_hops};
current_hop_ptr = |prev_hops|+1;
found_all = found_all && found_any;
dests           = DESTS;
metrics         = METRICS;
prev_hops       = NULL;
next_hops       = NULL;
route           = {prev_hops, MY_ID, next_hops};
current_hop_ptr = |prev_hops|+1;
prev_hops = route(1 : current_hop_ptr);
next_hops = route(current_hop_ptr+1 : |route|);
metrics   = compress(metrics, 
                                  get_metrics(prev_hops|prev_hop|,MY_ID));
prev_hops = NULL;
next_hops = Routing_Table[dest].route;
route           = {prev_hops, MY_ID, next_hops};
current_hop_ptr = |prev_hops|+1;
prev_hops = route(1 : current_hop_ptr-1);
next_hops = route(current_hop_ptr : |route|);
metrics = {metrics,get_metrics(MY_ID,next_hops(1))};
prev_hops  = inject_loopfree_path(next_hops,
                                       Temp_Query_Cache[source,query_id]);
route           = {prev_hops, MY_ID, next_hops};
current_hop_ptr = |prev_hops|+1;
BRP_cache_ID == NULL.

prev_bcast = Detected_Messages[source,message_id
                                               ,BRP_cache_ID].prev_bcast;
out_neighbors = Detected_Message
                             [source,message_id,BRP_cache_ID].out_neighbors;
prev_bcast = MY_ID;
out_neighbors = Bordercast_Tree[MY_ID].downstream_neighbors; 
source     = MY_ID;
message_id = MY_BORDERCAST_ID++; 
discard = !Bordercast_Tree[prev_bcast].member;
a = MY_ID (BELONGS TO) 
                        Bordercast_Tree[queried_node]
                                            .downstream_peripheral_nodes;
b = is_interior_node(queried_node,MY_ID);
discard = discard || (a || b);
prev_bcast = MY_ID;
out_neighbors = {};
drop_neighbor = TRUE;
leaves = Bordercast_Tree[prev_bcast,neighbor
                                           ].downstream_peripheral_nodes;
failed_leaf = TRUE;
a = leaf_node (BELONGS TO) 
                                Bordercast_Tree[queried_node]
                                            .downstream_peripheral_nodes;
b = is_interior_node(queried_node,leaf_node);
failed_leaf = failed_leaf || (a || b);
drop_neighbor = drop_neighbor && failed_leaf;
out_neighbors = {out_neighbors, neighbor};
