Network Working Group                                         Lou Berger
Internet Draft                                        FORE Systems, Inc.
Expiration Date: September 1999
                                                             Der-Hwa Gan
                                                  Juniper Networks, Inc.

                                                          George Swallow
                                                     Cisco Systems, Inc.

                                                              March 1999


                   RSVP Refresh Reduction Extensions


                draft-berger-rsvp-refresh-reduct-00.txt

Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of Section 10 of RFC2026.  Internet-Drafts are working
   documents of the Internet Engineering Task Force (IETF), its areas,
   and its working groups.  Note that other groups may also distribute
   working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   To view the current status of any Internet-Draft, please check the
   "1id-abstracts.txt" listing contained in an Internet-Drafts Shadow
   Directory, see http://www.ietf.org/shadow.html.

Abstract

   This document describes a number of mechanisms that reduce the
   refresh overhead of RSVP.  The extensions can be used to reduce
   processing requirements of refresh messages, eliminate the state
   synchronization latency incurred when an RSVP message is lost and,
   when desired, suppress the generation of refresh messages.  An
   extension to support detection of when an RSVP neighbor resets its
   state is also defined.  These extension present no backwards
   compatibility issues.







Berger, et al.                                                  [Page 1]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999




Contents

    1      Introduction and Background  ............................   3
    2      RSVP Aggregate Message  .................................   4
    2.1    Aggregate Header  .......................................   4
    2.2    Message Formats  ........................................   5
    2.3    Sending RSVP Aggregate Messages  ........................   6
    2.4    Receiving RSVP Aggregate Messages  ......................   7
    2.5    Forwarding RSVP Aggregate Messages  .....................   7
    2.6    Aggregate-Capable Bit  ..................................   7
    3      MESSAGE_ID Extension  ...................................   8
    3.1    MESSAGE_ID Object  ......................................   9
    3.2    Ack Message Format  .....................................  10
    3.3    MESSAGE_ID Object Usage  ................................  10
    3.4    MESSAGE_ID ACK Object Usage  ............................  12
    3.5    Multicast Considerations  ...............................  13
    3.6    Compatibility  ..........................................  14
    4      Hello Extension  ........................................  15
    4.1    Hello Message Format  ...................................  16
    4.2    HELLO Object  ...........................................  16
    4.3    Hello Message Usage  ....................................  17
    4.4    Compatibility  ..........................................  17
    5      Acknowledgments  ........................................  18
    6      Security Considerations  ................................  18
    7      References  .............................................  18
    8      Authors' Addresses  .....................................  18























Berger, et al.                                                  [Page 2]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


1. Introduction and Background

   The extensions described in this document were motivated by MPLS
   traffic engineering requirements as described in [Awduche].  These
   extensions may be generally useful and may be supported independent
   of other MPLS related RSVP extensions or LSP tunnels.

   The resource requirements (in terms of cpu processing and memory) for
   running RSVP on a router increases proportionally with the number of
   sessions.  Supporting a large number of sessions can present scaling
   problems.

   This document describes mechanisms to help alleviate one set of
   scaling issues.  RSVP Path and Resv messages must be periodically
   refreshed to maintain state.  The approach described effectively
   reduces the volume of messages which must be periodically sent and
   received.

   The described mechanisms also address issues of latency and
   reliability of RSVP Signaling.  The latency and reliability problem
   occurs when a non-refresh RSVP message is lost in transmission.
   Standard RSVP [RFC2205] maintains state via the generation of RSVP
   refresh messages.  In the face of transmission loss of RSVP messages,
   the end-to-end latency of RSVP signaling is tied to the refresh
   interval of the node(s) experiencing the loss.  When end-to-end
   signaling is limited by the refresh interval, the establishment or
   change of a reservation may be beyond the range of what is acceptable
   for some applications.

   One way to address the refresh volume problem is to increase the
   refresh timer R.  Increasing the value of R provides linear
   improvement on transmission overhead, but at the cost of increasing
   refresh timeout.

   One way to address the latency and reliability of RSVP Signaling is
   to decrease the refresh timer R.  Decreasing the value of R provides
   increased probability that state will be installed in the face of
   message loss, but at the cost of increasing refresh message rate and
   associated processing requirements.

   The extensions defined in this document address both the refresh
   volume and the reliability issues with mechanisms other than
   adjusting refresh rate.  An aggregate message is defined to reduce
   overall message handing load.  A Message_ID object is defined to
   reduce refresh message processing by allowing the receiver to more
   readily identify an unchanged message.  A Message_ACK object is
   defined which can be used to detect message loss and, when used in
   combination with the Message_ID object, can be used to suppress



Berger, et al.                                                  [Page 3]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


   refresh messages altogether.  Finally, a hello protocol is defined to
   allow detection of the loss of a neighbor node or a reset of it's
   RSVP state information.


2. RSVP Aggregate Message

   An RSVP aggregate message consists of an aggregate header followed by
   a body consisting of a variable number of standard RSVP messages.
   The following subsections define the formats of the aggregate header
   and the rules for including standard RSVP messages as part of the
   message.


2.1. Aggregate Header

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |   Msg type    |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The format of the aggregate header is identical to the format of the
   RSVP common header [RFC2205].  The fields in the header are as
   follows:

      Vers: 4 bits

         Protocol version number.  This is version 1.

      Flags: 4 bits

         0x01: Aggregate capable

           If set, indicates to RSVP neighbors that this node is willing
           and  capable  of  receiving  aggregate messages.  This bit is
           meaningful only between adjacent RSVP neighbors.

         0x02-0x08: Reserved

      Msg type: 8 bits

         12 = Aggregate






Berger, et al.                                                  [Page 4]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


      RSVP checksum: 16 bits

         The one's complement of the one's complement sum of the  entire
         message,  with the checksum field replaced by zero for the pur-
         pose of computing the checksum.  An all-zero value  means  that
         no  checksum  was transmitted.  Because individual sub-messages
         carry their own checksum as well as the  INTEGRITY  object  for
         authentication, this field MAY be set to zero.

      Send_TTL: 8 bits

         The IP TTL value with which the message was sent.  This is used
         by  RSVP  to detect a non-RSVP hop by comparing the IP TTL that
         an Aggregate message sent to the TTL in the received message.

      RSVP length: 16 bits

         The total length of this RSVP aggregate message in  bytes,  in-
         cluding the aggregate header and the sub-messages that follow.


2.2. Message Formats

   An RSVP aggregate message must contain at least one sub-message.  A
   sub-message is one of the RSVP Path, PathTear, PathErr, Resv,
   ResvTear, ResvErr, ResvConf, Ack or Hello messages.

   Empty RSVP aggregate messages should not be sent.  It is illegal to
   include another RSVP aggregate message as a sub-message.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | Vers  | Flags |    12         |         RSVP checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   First sub-message                         //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      //                   More sub-messages..                       //
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






Berger, et al.                                                  [Page 5]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


2.3. Sending RSVP Aggregate Messages

   RSVP Aggregate messages are sent hop by hop between RSVP-capable
   neighbors as "raw" IP datagrams with protocol number 46.  Raw IP
   datagrams are also intended to be used between an end system and the
   first/last hop router, although it is also possible to encapsulate
   RSVP messages as UDP datagrams for end-system communication that
   cannot perform raw network I/O.

   RSVP Aggregate messages MUST not be used if the next hop RSVP
   neighbor does not support RSVP Aggregate messages.  Methods for
   discovering such information include: (1) manual configuration and
   (2) observing the Aggregate-capable bit (see the description that
   follows) in the received RSVP messages.

   Support for RSVP Aggregate messages is optional.  While message
   aggregation helps in scaling RSVP, and in reducing processing
   overhead and bandwidth consumption, a node is not required to
   transmit every standard RSVP message in an Aggregate message.  A node
   MUST always be ready to receive standard RSVP messages.

   The IP source address is local to the system that originated the
   Aggregate message.  The IP destination address is the next hop node
   for which the sub-messages are intended.  These addresses need not be
   identical to those used if the sub-messages were sent as standard
   RSVP messages.

   For example, the IP source address of Path and PathTear messages is
   the address of the sender it describes, while the IP destination
   address is the DestAddress for the session.  These end-to-end
   addresses are overridden by hop-by-hop addresses while encapsulated
   in an Aggregate message.  These addresses can easily be restored from
   the SENDER_TEMPLATE and SESSION objects within Path and PathTear
   messages.  For Path and PathTear messages, the next hop node can be
   identified either via a received ACK or from a received corresponding
   Resv message.  Path and PathTear messages for multicast sessions MUST
   NOT be sent in Aggregate messages.

   RSVP Aggregate messages SHOULD NOT be sent with the Router Alert IP
   option in their IP headers.  This is because Aggregate messages are
   addressed directly to RSVP neighbors.

   Each RSVP Aggregate message MUST occupy exactly one IP datagram.  If
   it exceeds the MTU, the datagram is fragmented by IP and reassembled
   at the recipient node.  A single RSVP Aggregate message MUST NOT
   exceed the maximum IP datagram size, which is approximately 64K
   bytes.




Berger, et al.                                                  [Page 6]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


2.4. Receiving RSVP Aggregate Messages

   If the local system does not recognize or does not wish to accept an
   Aggregate message, the received messages shall be discarded without
   further analysis.

   The receiver next compares the IP TTL with which an Aggregate message
   is sent to the TTL with which it is received.  If a non-RSVP hop is
   detected, the number of non-RSVP hops is recorded.  It is used later
   in processing of sub-messages.

   Next, the receiver verifies the version number and checksum of the
   RSVP aggregate message and discards the message if any mismatch is
   found.

   The receiver then starts decapsulating individual sub-messages.  Each
   sub-message has its own complete message length and authentication
   information.  Each sub-message is processed per standard RSVP.


2.5. Forwarding RSVP Aggregate Messages

   When an RSVP router receives an Aggregate messages which is not
   addressed to one of it's IP addresses, it SHALL forward the message.
   Non-RSVP routers will treat RSVP Aggregate messages as any other IP
   datagram.

   When individual sub-messages are being forwarded, they MAY be
   encapsulated in another aggregate message before sending to the next
   hop neighbor.  The Send_TTL field in the sub-messages should be
   decremented properly before transmission.


2.6. Aggregate-Capable Bit

   To support message aggregation, an additional capability bit is added
   to the common RSVP header, which is defined in [RFC2205].

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Vers | Flags |   Msg Type    |         RSVP Checksum         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Send_TTL    |  (Reserved)   |         RSVP Length           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






Berger, et al.                                                  [Page 7]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


      Flags: 4 bits

         0x01: Aggregate capable

           If set, indicates to RSVP neighbors that this node is willing
           and  capable  of  receiving  aggregate messages.  This bit is
           meaningful only between adjacent RSVP neighbors.


3. MESSAGE_ID Extension

   Two new objects are defined as part of the MESSAGE_ID extension.  The
   two object types are the MESSAGE_ID object and the MESSAGE_ID ACK
   object.  The objects are used to support acknowledgments and, when
   used in conjunction with the Hello Extension described in Section 4,
   to indicate when refresh messages are not needed after an
   acknowledgment.  When refreshes are normally generated, the
   MESSAGE_ID object can also be used to simply provide a shorthand
   indication of when a message represents new state.  Such information
   can be used on the receiving node to reduce refresh processing
   requirements.

   Message identification and acknowledgment is done on a hop-by-hop
   basis.  Acknowledgment is handled independent of SESSION or message
   type.  Both types of MESSAGE_ID objects contain a message identifier.
   The identifier MUST be unique on a per source IP address basis across
   messages sent by an RSVP node and received by a particular node.  No
   more than one MESSAGE_ID object may be included in an RSVP message.
   Each message containing an MESSAGE_ID object may be acknowledged via
   a MESSAGE_ID ACK object.  MESSAGE_ID ACK objects may be sent
   piggybacked in unrelated RSVP messages or in RSVP ACK messages

   Either type of MESSAGE_ID object may be included in an aggregate
   sub-message.  When included, the object is treated as if it were
   contained in a standard, unaggregated, RSVP message.  Only one
   MESSAGE_ID object MAY be included in a (sub)message and it MUST
   follow any present MESSAGE_ID ACK objects.  When no MESSAGE_ID ACK
   objects are present, the MESSAGE_ID object MUST immediately follow
   the INTEGRITY object.  When no INTEGRITY object is present, the
   MESSAGE_ID object MUST immediately follow the (sub)message header.

   When present, one or more MESSAGE_ID ACK objects MUST immediately
   follow the INTEGRITY object.  When no INTEGRITY object is present,
   the MESSAGE_ID ACK objects MUST immediately follow the the
   (sub)message header.  An MESSAGE_ID ACK object may only be included
   in a message when the message's IP destination address matches the
   unicast address of the node that generated the message(s) being
   acknowledged.



Berger, et al.                                                  [Page 8]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999



3.1. MESSAGE_ID Object

   MESSAGE_ID Class =  166  (Value  to  be  assigned  by  IANA  of  form
   10bbbbbb)

   MESSAGE_ID object

      Class = MESSAGE_ID Class, C_Type = 1

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Flags     |                  Message ID                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Flags: 8 bits

            0x80 = ACK_Desired flag

             Indicates that the sender is willing to accept a message
             acknowledgment.  Acknowledgments MUST be silently ignored
             when they are sent in response to messages whose
             ACK_Desired flag is not set.  This flag MUST be set when
             the Last_Refresh flag is set.

            0x40 = Last_Refresh flag

             Used in Resv and Path refresh messages to indicate that the
             sender will not be sending further refreshes.  When set,
             the ACK_Desired flag MUST also be set.  This flag MUST NOT
             be set when the HELLO messages are not being exchanged with
             the neighboring RSVP node.

         Message ID: 24 bits

            a 24-bit identifier.  When combined with the message
            generator's IP address, uniquely identifies a message.

   MESSAGE_ID ACK object

      Class = MESSAGE_ID Class, C_Type = 2

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Reserved    |                  Message ID                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



Berger, et al.                                                  [Page 9]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


         Reserved

            This field is reserved.  It MUST be set to zero on transmis-
            sion and MUST be ignored on receipt.

          Message ID: 24 bits

            a 24-bit identifier.  When combined with the message
            generator's IP address, uniquely identifies a message.


3.2. Ack Message Format

   Ack messages carry one or more MESSAGE_ID ACK objects.  They MUST NOT
   contain any MESSAGE_ID objects.  Ack messages are sent hop-by-hop
   between RSVP nodes.  The IP destination address of an Ack message is
   the unicast address of the node that generated the message(s) being
   acknowledged.  For Path, PathTear, Resv, and RervErr messages this is
   taken from the RSVP_HOP Object.  For PathErr and ResvErr messages
   this is taken from the message's source address.  The IP source
   address is an address of the node that sends the Ack message.

   The Ack message format is as follows:

     <ACK Message> ::= <Common Header> [ <INTEGRITY> ]
                           <MESSAGE_ID ACK>
                           [ <MESSAGE_ID ACK> ... ]

   For Ack messages, the Msg Type field of the Common Header MUST be set
   to 13 (Value to be assigned by IANA).


3.3. MESSAGE_ID Object Usage

   The MESSAGE_ID object may be included in any RSVP message other than
   the Ack message.  The MESSAGE_ID object is always generated and
   processed hop-by-hop.  The IP address of the object generator is
   represented in a per RSVP message type specific fashion.  For Path
   and PathTear messages the generator's IP address is contained in the
   RSVP_HOP.  For Resv, ResvTear, PathErr, ResvErr, ResvConf and
   Aggregate messages the generator's IP address is the source address
   in the IP header.

   The Message ID field contains a generator selected value.  This
   value, when combined with the generator's IP address, identifies a
   particular RSVP message and the specific state information it
   represents.  When a node is sending a refresh message with a
   MESSAGE_ID object, it SHOULD use the same Message ID value that was



Berger, et al.                                                 [Page 10]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


   used in the RSVP message that first advertised the state being
   refreshed.  When a node is sending a message that represents new or
   changed state, the Message ID value MUST have a value that is not
   otherwise in use.  A value is considered to be in use when it has
   been used in the most recent advertisement or refresh of any state
   using the associated IP address.  Care must also be taken to avoid
   reuse of a previously used value during times of network loss.  At
   such times, the use of new values may not be noticed by receivers.
   There is no requirement for Message ID values to be increasing or
   ordered.

   The ACK_Desired flag is set when the MESSAGE_ID object generator is
   capable of accepting MESSAGE_ID ACK objects.  Such information can be
   used to ensure reliable delivery of error and confirm messages and to
   support fast refreshes in the face of network loss.  Nodes setting
   the ACK_Desired flag SHOULD retransmit unacknowledged messages at a
   faster interval than the standard refresh time until the message is
   acknowledged or a "fast" retry limit is reached.  Note that nodes
   setting the ACK_Desired flag for unicast sessions, do not need to
   track the identify of the next hop since all that is expected is an
   ACK, not an ACK from a specific next hop.  Issues relate to multicast
   sessions are covered in a later section.

   The Last_Refresh flag may be set in Path and Resv messages when the
   MESSAGE_ID object generator is exchanging Hello messages, described
   in Section 4, with the next hop RSVP node.  When a refresh message
   with the Last_Refresh flag set is generated, normal refresh
   generation MUST continue until the message containing the
   Last_Refresh flag is acknowledged.  Although, messages removing state
   advertised in such messages MUST be retransmit until acknowledged or
   a maximum retry limit is reached in order to cover certain packet
   loss conditions.  Messages removing state include PathTear and
   ResvTear.

   When sending MESSAGE_ID objects with the Last_Refresh flag set,
   special care must be taken to properly advertise state.
   Specifically, refresh processing MUST continue per standard RSVP
   processing until after a acknowledgment is received.  Suppression of
   refresh processing MAY ONLY occur after an acknowledgment is received
   for a MESSAGE_ID object with the Last_Refresh flag set.  Note that
   the Last_Refresh flag MAY ONLY be set when the RSVP next hop is
   exchanging Hello messages with the message generator.

   When a Path message for a new session arrives, the RSVP next hop may
   not always be known.  When the RSVP next hop is not known, the
   Last_Refresh flag MUST NOT be set.  Once the next hop of a unicast
   session is identified, only then may the Last_Refresh flag be set.
   (Issues relate to multicast sessions are covered in a later section.)



Berger, et al.                                                 [Page 11]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


   There are several ways to identify the RSVP next hop of a new unicast
   session.  Some are more conservative than other, e.g., waiting for a
   Resv message versus checking if the other end of a PPP link supports
   Hello messages.  Since there are no interoperability issues, the
   specific mechanism used to identify the RSVP next hop of a new
   session is a specific implementation choice.  In most
   implementations, it is expected that an advertiser of Path state will
   do standard refresh processing until either an ACK is received for a
   Path message advertising a new session, or a corresponding Resv
   message is received.

   Nodes receiving messages containing MESSAGE_ID objects SHOULD use the
   information in the objects to aid in determining if a message
   represents new state or a state refresh.  Note that state is only
   refreshed in Path and Resv messages.  If a Path or Resv message
   contains the same Message_ID value that was used in the most recently
   received message for the same session and, for Path messages,
   SENDER_TEMPLATE then the receiver SHOULD treat the message as a state
   refresh.  If the Message ID value differs from the most recently
   received value, the receiver MUST fully processes the message.

   Nodes receiving a message containing a MESSAGE_ID object with the
   ACK_Desired flag set, SHOULD respond with a MESSAGE_ID ACK object.
   If a node supports the Hello extension it MUST also check the
   Last_Refresh flag of received Resv and Path messages.  If the flag is
   set, the receiver MUST NOT timeout state associated with associated
   message.  The receiver MUST also be prepared to properly process
   refresh messages.  Messages containing a MESSAGE_ID ACK object with
   the Last_Refresh flag set MUST NOT be acknowledged when either the
   receiving node doesn't support the Hello extension or Hello messages
   aren't being exchanged with the message generator.


3.4. MESSAGE_ID ACK Object Usage

   The MESSAGE_ID ACK object is used to acknowledge receipt of messages
   containing MESSAGE_ID objects that were sent with the ACK_Desired
   flag set.  The Message ID field of a MESSAGE_ID ACK object MUST have
   the same value as was received.  A MESSAGE_ID ACK object MUST NOT be
   generated in response to a received MESSAGE_ID object when the
   ACK_Desired flag is not set.

   A MESSAGE_ID ACK object MAY be sent in any RSVP message that has an
   IP destination address matching the generator of the associated
   MESSAGE_ID object.  The MESSAGE_ID ACK object will not typically be
   included in the non hop-by-hop Path, PathTear and ResvConf messages.
   When no appropriate message is available, one or more MESSAGE_ID ACK
   objects SHOULD be sent in an Ack message.  Implementations SHOULD



Berger, et al.                                                 [Page 12]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


   include MESSAGE_ID ACK objects in standard RSVP messages when
   possible.

   Upon receiving a MESSAGE_ID ACK object for a message generated with a
   MESSAGE_ID object with the Last_Refresh flag set, normal refresh
   generation SHOULD be suppressed for the associated state.  As
   previously mentioned, special care must be taken to properly
   advertise state when sending MESSAGE_ID objects with the Last_Refresh
   flag set, see section 3.3.


3.5. Multicast Considerations

   Path and PathTear messages may be sent to IP multicast destination
   addresses.  When the destination is a multicast address, it is
   possible that a single message containing a single MESSAGE_ID object
   will be received by multiple RSVP next hops.  When the ACK_Desired
   flag is set in this case, acknowledgment processing is more complex.
   There are a number of issues to be addressed including ACK implosion,
   number acknowledgments to be expected and handling of new receivers.

   ACK implosion occurs when each receiver responds to the MESSAGE_ID
   object at approximately the same time.  This can lead to a
   potentially large number of MESSAGE_ID ACK objects being
   simultaneously delivered to the message generator.  To address this
   case, the receiver MUST wait a random interval prior to acknowledging
   a MESSAGE_ID object received in a message destined to a multicast
   address.  The random interval SHOULD be between zero (0) and a
   configured maximum time.  The configured maximum SHOULD be set in
   proportion to the refresh and "fast" retransmission interval.

   A more fundamental issue is the number of acknowledgments that the
   upstream node, i.e., the message generator, should expect.  The
   number of acknowledgments that should be expected is the same as the
   number of RSVP next hops.  In the router-to-router case, the number
   of next hops can usually be obtained from routing.  When hosts are
   either the upstream node or the next hops, the number of next hops
   will typically not be readily available.  When the number of next
   hops is not known, the message generator SHOULD only expect a single
   response and MUST NOT set the Last_Refresh flag in MESSAGE_ID
   objects.  The result of this behavior will be special retransmission
   handling until the message is delivered to at least one next hop,
   then followed by standard RSVP refreshes.  Standard refresh messages
   will synchronize state with any next hops that don't receive the
   original message.

   Another issue is handling new receivers.  It is possible that after
   sending a Path message and handling of expected number of



Berger, et al.                                                 [Page 13]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


   acknowledgments that a new receiver joins the group.  In this case a
   new Path message must be sent to the new receiver.  When normal
   refresh processing is occurring, there is no issue.  When normal
   refresh processing is suppressed, a Path message must still be
   generated.  In the router-to-router case, the identification of new
   next hops can usually be obtained from routing.  When hosts are
   either the upstream node or the next hops, the identification of new
   next hops will typically not be possible.  When identification of new
   next hops is not possible, the message generator SHOULD only expect a
   single response and MUST NOT set the Last_Refresh flag in MESSAGE_ID
   objects.  The result of this behavior will be special retransmission
   handling until the message is delivered to at least one next hop,
   then followed by standard RSVP refreshes.  Standard refresh messages
   will synchronize state with any next hops that don't receive the
   original message either due to loss or not yet being a group member.

   There is one additional minor issue with multiple next hops.  The
   issue is handling a combination of standard-refresh and non-refresh
   next hops, i.e., Hello messages are being exchanged with some
   neighboring nodes but not with others.  When this case occurs,
   refreshes MUST be generated per standard RSVP and the Last_Refresh
   flag MUST NOT be set.


3.6. Compatibility

   There are no backward compatibility issues raised by the MESSAGE_ID
   Class.  The MESSAGE_ID Class has an assigned value whose form is
   10bbbbbb.  Per RSVP [RFC2205], classes with values of this form must
   be ignored and not forwarded by nodes not supporting the class.  When
   the receiver of a MESSAGE_ID object does not support the class, the
   object will be silently ignored.  The generator of the MESSAGE_ID
   object will not see any acknowledgments and therefore refresh
   messages per standard RSVP.  Lastly, since the MESSAGE_ID ACK object
   can only be issued in response to the MESSAGE_ID object, there are no
   possible issues with this object or Ack messages.

   Implementations supporting Path and Resv state refresh suppression
   via the MESSAGE_ID object's Last_Refresh flag MUST also support the
   Hello extension.











Berger, et al.                                                 [Page 14]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


4. Hello Extension

   The RSVP Hello extension enables RSVP nodes to detect a loss of a
   neighboring node's state information.  In standard RSVP, such
   detection occurs as a consequence of RSVP's soft state model.  When
   refresh message generation is suppressed via the previously discussed
   Last_Refresh flag processing, the Hello extension is needed to
   address this failure case.  The Hello extensions is not intended to
   provide a link failure detection mechanism, particularly in the case
   of multiple parallel unnumbered links.

   The Hello extension is specifically designed so that one side can use
   the mechanism while the other side does not.  Neighbor RSVP state
   tracking may be initiated at any time.  This includes when neighbors
   first learn about each other, or just when neighbors are sharing Resv
   or Path state.  As previously stated, all implementations supporting
   state refresh suppression MUST also support the Hello Extension.
   Such implementations SHOULD initiate Hello processing and MUST be
   able to respond to Hello messages.

   The Hello extension is composed of a Hello message, a HELLO REQUEST
   object and a HELLO ACK object.  Hello processing between two
   neighbors supports independent selection of, typically configured,
   failure detection intervals.  Each neighbor can autonomously issue
   HELLO REQUEST objects.  Each request is answered by an
   acknowledgment.  Hello Messages also contain enough information so
   that one neighbor can suppress issuing hello requests and still
   perform neighbor failure detection.  A Hello message may be included
   as a sub-message within an aggregate message.

   Neighbor state tracking is accomplished by collecting and storing a
   neighbor's state "instance" value.  If a change in value is seen,
   then the neighbor is presumed to have reset it's RSVP state.  The
   HELLO objects provide a mechanism for polling for and providing an
   RSVP state instance value.  A poll request also includes the sender's
   instance value.  This allows the receiver of a poll to optionally
   treat the poll as an implicit poll response.  This optional handling
   is an optimization that can reduce the total number of polls and
   responses processed by a pair of neighbors.  In all cases, when both
   sides support the optimization the result will be only one set of
   polls and responses per failure detection interval.  Depending on
   selected intervals, the same benefit can occur even when only one
   neighbor supports the optimization.








Berger, et al.                                                 [Page 15]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


4.1. Hello Message Format

   Hello Messages are always sent between two RSVP neighbors.  The IP
   source address is the IP address of the sending node.  The IP
   destination address is the IP address of the neighbor node.

   The Hello message format is as follows:

     <Hello Message> ::= <Common Header> [ <INTEGRITY> ]
                             <HELLO>

   For Hello messages, the Msg Type field of the Common Header MUST be
   set to 14 (Value to be assigned by IANA).


4.2. HELLO Object

   HELLO Class =  22 (Value to be assigned by IANA of form 0bbbbbbb)

   HELLO REQUEST object

      Class = HELLO Class, C_Type = 1

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Instance                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   HELLO ACK object
      Class = HELLO Class, C_Type = 2

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Instance                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Instance: 32 bits

         a 32 bit value that represents the sender's RSVP agent's state.
         This value must change when the agent is reset or the node
         reboots and otherwise remains the same.  This field MUST NOT be
         set to zero (0).







Berger, et al.                                                 [Page 16]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


4.3. Hello Message Usage

   A Hello message containing a HELLO REQUEST object MUST be generated
   for each neighbor who's state is being tracked.  When generating a
   message containing a HELLO REQUEST object, the sender fills in the
   Instance field with a value representing it's RSVP agent state.  This
   value MUST NOT change while the agent is maintaining any RSVP state.
   The generation of a message SHOULD be skipped when a HELLO REQUEST
   object was received from the destination node within the failure
   detection interval.

   On receipt of a message containing a HELLO REQUEST object, the
   receiver MUST generate a Hello message containing a HELLO ACK object.
   The receiver SHOULD also verify that the neighbor has not reset.
   This is done by comparing the sender's Instance field value with the
   previously received value.  If the value differs, than the neighbor
   has reset and all state associated with the neighbor MUST be
   "expired" and cleaned up per standard RSVP processing.  Additionally,
   all Path state advertised to the neighbor MUST be refreshed.

   On receipt of a message containing a HELLO ACK object, the receiver
   MUST verify that the neighbor has not reset.  This is done by
   comparing the sender's Instance field value with the previously
   received value.  If the value differs, than the neighbor has reset
   and all state associated with the neighbor MUST be "expired" and
   cleaned up per standard RSVP processing.  Additionally, all Path
   state advertised to the neighbor MUST be refreshed.


4.4. Compatibility

   The Hello extension is fully backwards compatible.  The Hello class
   is assigned a class value of the form 0bbbbbbb.  Depending on the
   implementation, implementations that don't support the extension will
   either silently discard Hello messages or will respond with an
   "Unknown Object Class" error.  In either case the sender will fail to
   see an acknowledgment for the issued Hello.  When a Hello sender does
   not receive an acknowledgment, it MUST NOT send MESSAGE_ID objects
   with the Last_Refresh flag set.  This restriction will preclude
   neighbors from getting out of RSVP state synchronization.

   Implementations supporting the Hello extension MUST also support the
   MESSAGE_ID extension and refresh suppression.








Berger, et al.                                                 [Page 17]

Internet Draft  draft-berger-rsvp-refresh-reduct-00.txt       March 1999


5. Acknowledgments

   This document represents ideas and comments from the MPLS-TE design
   team.  Thanks to Yoram Bernet and Fred Baker for the good feedback.

6. Security Considerations

   No new security issues are raised in this document.  See [RFC2205]
   for a general discussion on RSVP security issues.

7. References

[Awduche] Awduche, D. et al. Requirements for Traffic Engineering
          over MPLS,  Internet Draft,
          draft-awduche-mpls-traffic-eng-00.txt, April 1998.

[RFC2119] Bradner, S., "Key words for use in RFCs to Indicate
          Requirement Levels," RFC 2119.

[RFC2205] Braden, R. Ed. et al, "Resource ReserVation Protocol
           -- Version 1 Functional Specification", RFC 2205,
           September 1997.

8. Authors' Addresses

   Lou Berger
   FORE Systems
   1595 Spring Hill Road,  Suite 500
   Vienna, VA 22182
   Voice:  +1 703 245 4527
   Email:  lberger@fore.com

   Der-Hwa Gan
   Juniper Networks, Inc.
   385 Ravendale Drive
   Mountain View, CA 94043
   Voice:  +1 650 526 8074
   Email:  dhg@juniper.net

   George Swallow
   Cisco Systems, Inc.
   250 Apollo Drive
   Chelmsford, MA 01824
   Voice:  +1 978 244 8143
   Email:  swallow@cisco.com






Berger, et al.                                                 [Page 18]
