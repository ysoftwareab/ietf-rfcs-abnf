nonce-type = bstr .size (8..64)


ueid-type = bstr .size (7..33)

sueids-type = {
       + tstr => ueid-type
oemid-pen = int

oemid-ieee = bstr .size 3

oemid-random = bstr .size 16


oemid-label =>
           oemid-random / oemid-ieee / oemid-pen
chip-version-label => hw-version-type
board-version-label => hw-version-type
device-version-label => hw-version-type
hw-version-type = [
       version:  tstr,
       scheme:  $version-scheme
sw-version-type = [
       version:  tstr,
       scheme:  $version-scheme / As defined by CoSWID /
security-level-label =>
           security-level-cbor-type /
           security-level-json-type
security-level-cbor-type = &(
       unrestricted: 1,
       restricted: 2,
       secure-restricted: 3,
       hardware: 4
security-level-json-type =
       "unrestricted" /
       "restricted" /
       "secure-restricted" /
       "hardware"

debug-status-label =>
           debug-status-cbor-type / debug-status-json-type
debug-status-cbor-type = &(
       enabled: 0,
       disabled: 1,
       disabled-since-boot: 2,
       disabled-permanently: 3,
       disabled-fully-and-permanently: 4
debug-status-json-type =
       "enabled" /
       "disabled" /
       "disabled-since-boot" /
       "disabled-permanently" /
       "disabled-fully-and-permanently"

location-type = {
latitude => number,
longitude => number,
latitude = 1 / "latitude"
longitude = 2 / "longitude"
altitude = 3 / "altitude"
accuracy = 4 / "accuracy"
altitude-accuracy = 5 / "altitude-accuracy"
heading = 6 / "heading"
speed = 7 / "speed"
timestamp = 8 / "timestamp"
age = 9 / "age"


intended-use-label =>
           intended-use-cbor-type / intended-use-json-type
intended-use-cbor-type = &(
       generic: 1,
       registration: 2,
       provisioning: 3,
       csr: 4,
       pop: 5
intended-use-json-type =
       "generic" /
       "registration" /
       "provisioning" /
       "csr" /
       "pop"


oid = #6.4000(bstr) ; TODO: Replace with CDDL from OID RFC
dloas-label => [ + dloa-type ]
dloa-type = [
       dloa_registrar: ~uri
       dloa_platform_label: text
       ? dloa_application_label: text
manifests-label => manifests-type
manifests-type = [+ $$manifest-formats]

coswid-that-is-a-cbor-tag-xx = tagged-coswid<concise-swid-tag>

swevidence-label => swevidence-type
swevidence-type = [+ $$swevidence-formats]

coswid-that-is-a-cbor-tag = tagged-coswid<concise-swid-tag>
verification-result-cbor-type = &(
       verification-not-run: 1,
       verification-indeterminate: 2,
       verification-failed: 3,
       fully-verified: 4,
       partially-verified: 5,
verification-result-json-type =
       "verification-not-run" /
       "verification-indeterminate" /
       "verification-failed" /
       "fully-verified" /
       "partially-verified"


verification-objective-cbor-type = &(
       all: 1,
       firmware: 2,
       kernel: 3,
       privileged: 4,
       system-libs: 5,
       partial: 6,
verification-objective-json-type =
       "all" /
       "firmware" /
       "kernel" /
       "privileged" /
       "system-libs" /
       "partial"


swresult-type = [
       verification-system: tstr,
       objective: verification-objective-cbor-type /
           verification-objective-json-type,
       result: verification-result-cbor-type /
           verification-result-json-type,
       ? objective-name: tstr
Nested-Token =
       tstr / ; A JSON-encoded Nested-Token (see json-nested-token.cddl)
       bstr .cbor Tagged-CBOR-Token



Nested-Token = [
      type : "JWT" / "CBOR" / "UJCS" / "DEB",
      nested-token : JWT-Message /
                     B64URL-Tagged-CBOR-Token /
                     DEB-JSON-Message /
                     UJCS-Message
B64URL-Tagged-CBOR-Token = tstr .regexp "[A-Za-z0-9_=-]+"

Submodule = Claims-Set / Nested-Token / Detached-Submodule-Digest


Detached-Submodule-Digest = [
      algorithm : int / text,
      digest : bstr
Detached-EAT-Bundle = [
       main-token : Nested-Token,
       detached-claims-sets: {
           + tstr => cbor-wrapped-claims-set / json-wrapped-claims-set
       }
json-wrapped-claims-set = tstr .regexp "[A-Za-z0-9_=-]+"


cbor-wrapped-claims-set = bstr .cbor Claims-Set



string-or-uri = tstr

time-int = #6.1(int)

Claims-Set = {
       * $$claims-set-claims,
       * Claim-Label .feature "extended-label" => any
Claim-Label = int / text
string-or-uri = tstr

time-int = #6.1(int)
nonce-type = bstr .size (8..64)

ueid-type = bstr .size (7..33)
sueids-type = {
       + tstr => ueid-type
oemid-pen = int

oemid-ieee = bstr .size 3

oemid-random = bstr .size 16


oemid-label =>
           oemid-random / oemid-ieee / oemid-pen
chip-version-label => hw-version-type
board-version-label => hw-version-type
device-version-label => hw-version-type
hw-version-type = [
       version:  tstr,
       scheme:  $version-scheme
security-level-label =>
           security-level-cbor-type /
           security-level-json-type
security-level-cbor-type = &(
       unrestricted: 1,
       restricted: 2,
       secure-restricted: 3,
       hardware: 4
security-level-json-type =
       "unrestricted" /
       "restricted" /
       "secure-restricted" /
       "hardware"
debug-status-label =>
           debug-status-cbor-type / debug-status-json-type
debug-status-cbor-type = &(
       enabled: 0,
       disabled: 1,
       disabled-since-boot: 2,
       disabled-permanently: 3,
       disabled-fully-and-permanently: 4
debug-status-json-type =
       "enabled" /
       "disabled" /
       "disabled-since-boot" /
       "disabled-permanently" /
       "disabled-fully-and-permanently"
location-type = {
latitude => number,
longitude => number,
latitude = 1 / "latitude"
longitude = 2 / "longitude"
altitude = 3 / "altitude"
accuracy = 4 / "accuracy"
altitude-accuracy = 5 / "altitude-accuracy"
heading = 6 / "heading"
speed = 7 / "speed"
timestamp = 8 / "timestamp"
age = 9 / "age"

intended-use-label =>
           intended-use-cbor-type / intended-use-json-type
intended-use-cbor-type = &(
       generic: 1,
       registration: 2,
       provisioning: 3,
       csr: 4,
       pop: 5
intended-use-json-type =
       "generic" /
       "registration" /
       "provisioning" /
       "csr" /
       "pop"

dloas-label => [ + dloa-type ]
dloa-type = [
       dloa_registrar: ~uri
       dloa_platform_label: text
       ? dloa_application_label: text
oid = #6.4000(bstr) ; TODO: Replace with CDDL from OID RFC

manifests-label => manifests-type
manifests-type = [+ $$manifest-formats]

coswid-that-is-a-cbor-tag-xx = tagged-coswid<concise-swid-tag>

swevidence-label => swevidence-type
swevidence-type = [+ $$swevidence-formats]

coswid-that-is-a-cbor-tag = tagged-coswid<concise-swid-tag>
verification-result-cbor-type = &(
       verification-not-run: 1,
       verification-indeterminate: 2,
       verification-failed: 3,
       fully-verified: 4,
       partially-verified: 5,
verification-result-json-type =
       "verification-not-run" /
       "verification-indeterminate" /
       "verification-failed" /
       "fully-verified" /
       "partially-verified"


verification-objective-cbor-type = &(
       all: 1,
       firmware: 2,
       kernel: 3,
       privileged: 4,
       system-libs: 5,
       partial: 6,
verification-objective-json-type =
       "all" /
       "firmware" /
       "kernel" /
       "privileged" /
       "system-libs" /
       "partial"


swresult-type = [
       verification-system: tstr,
       objective: verification-objective-cbor-type /
           verification-objective-json-type,
       result: verification-result-cbor-type /
           verification-result-json-type,
       ? objective-name: tstr
Submodule = Claims-Set / Nested-Token / Detached-Submodule-Digest


Detached-Submodule-Digest = [
      algorithm : int / text,
      digest : bstr
Detached-EAT-Bundle = [
       main-token : Nested-Token,
       detached-claims-sets: {
           + tstr => cbor-wrapped-claims-set / json-wrapped-claims-set
       }
json-wrapped-claims-set = tstr .regexp "[A-Za-z0-9_=-]+"


cbor-wrapped-claims-set = bstr .cbor Claims-Set



CBOR-Token = Tagged-CBOR-Token / Untagged-CBOR-Token


Tagged-CBOR-Token  = CWT-Tagged-Message
Untagged-CBOR-Token  = CWT-Untagged-Message
CWT-Tagged-Message = COSE_Tagged_Message
CWT-Untagged-Message = COSE_Untagged_Message


UCCS-Message = UCCS-Tagged-Message / UCCS-Untagged-Message
UCCS-Tagged-Message = #6.601(UCCS-Untagged-Message)

UCCS-Untagged-Message = Claims-Set


DEB-Tagged-Message = #6.602(DEB-Untagged-Message)

DEB-Untagged-Message = Detached-EAT-Bundle


Nested-Token =
    tstr / ; A JSON-encoded Nested-Token (see json-nested-token.cddl)
    bstr .cbor Tagged-CBOR-Token


iss-label = 1
sub-label = 2
aud-label = 3
exp-label = 4
nbf-label = 5
iat-label = 6
cti-label = 7; The following Claim Keys (labels) are pre-assigned by IANA.
nonce-label = 10
ueid-label = 11
oemid-label = 13
security-level-label = 14
secure-boot-label = 15
debug-status-label = 16
location-label = 17
profile-label = 18
submods-label = 20

sueids-label = <TBD25>
chip-version-label = <TBD26>
board-version-label = <TBD27>
device-version-label = <TBD28>
sw-name-label = <TBD29>
sw-version-label = <TBD30>
uptime-label = <TBD31>
boot-seed-label = <TBD32>
intended-use-label = <TBD33>
dloas-label = <TBD34>
manifests-label = <TBD35>
swevidence-label = <TBD36>
swresults-label = <TBD37>

JWT-Message = text .regexp [A-Za-z0-9_=-]+\.[A-Za-z0-9_=-]+\.[A-Za-z0-9_=-]+


UJCS-Message = Claims-Set

Nested-Token = [
   type : "JWT" / "CBOR" / "UJCS" / "DEB",
   nested-token : JWT-Message /
                  B64URL-Tagged-CBOR-Token /
                  DEB-JSON-Message /
                  UJCS-Message
B64URL-Tagged-CBOR-Token = tstr .regexp "[A-Za-z0-9_=-]+"
iss-label = "iss"
sub-label = "sub"
aud-label = "aud"
exp-label = "exp"
nbf-label = "nbf"
iat-label = "iat"
cti-label = "cti"; The following are claim names for JSON encoded tokens.

p = 1 - e^{-k^2/(2n)}

p = k^2 / 2n

t = 1 / ((k / 10) * p)

