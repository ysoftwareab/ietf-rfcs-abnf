<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Common Interface to Cryptographic Modules (CICM) Module Management </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Definition Language">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Conformance and Extension Language">
<link href="#rfc.section.2" rel="Chapter" title="2 CICM Dependencies">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Namespaces">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Types">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Interfaces">
<link href="#rfc.section.3" rel="Chapter" title="3 Hardware Access Tokens">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Token Management Identifiers">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Interface CICM::TokenManager">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 CICM::TokenManager Attributes">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 CICM::TokenManager Methods">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Interface CICM::TokenAssnIterator">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 CICM::TokenAssnIterator Inheritance">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 CICM::TokenAssnIterator Methods">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Interface CICM::ModuleAssnIterator">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 CICM::ModuleAssnIterator Inheritance">
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 CICM::ModuleAssnIterator Methods">
<link href="#rfc.section.4" rel="Chapter" title="4 Users">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 User Management Identifiers">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Interface CICM::UserManager">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 CICM::UserManager Attributes">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 CICM::UserManager Methods">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Interface CICM::UserIdIterator">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 CICM::UserIdIterator Inheritance">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 CICM::UserIdIterator Methods">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Interface CICM::RoleIdIterator">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 CICM::RoleIdIterator Inheritance">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 CICM::RoleIdIterator Methods">
<link href="#rfc.section.5" rel="Chapter" title="5 Login">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Interface CICM::LoginManager">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 CICM::LoginManager Methods">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Interface CICM::Login">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 CICM::Login Methods">
<link href="#rfc.section.6" rel="Chapter" title="6 Software Packages">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Package Management Identifier">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Interface CICM::PackageManager">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 CICM::PackageManager Attributes">
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 CICM::PackageManager Methods">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Interface CICM::PackageImporter">
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 CICM::PackageImporter Methods">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Interface CICM::Package">
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 CICM::Package Types and Constants">
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 CICM::Package Attributes">
<link href="#rfc.section.6.4.3" rel="Chapter" title="6.4.3 CICM::Package Methods">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Interface CICM::PackageIterator">
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 CICM::PackageIterator Inheritance">
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 CICM::PackageIterator Methods">
<link href="#rfc.section.7" rel="Chapter" title="7 Logs">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Interface CICM::LogManager">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 CICM::LogManager Attributes">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 CICM::LogManager Methods">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Interface CICM::LogEntry">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 CICM::LogEntry Attributes">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 CICM::LogEntry Methods">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Interface CICM::LogEntryIterator">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 CICM::LogEntryIterator Inheritance">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 CICM::LogEntryIterator Methods">
<link href="#rfc.section.8" rel="Chapter" title="8 Tests">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Interface CICM::TestManager">
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 CICM::TestManager Types and Constants">
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 CICM::TestManager Methods">
<link href="#rfc.section.9" rel="Chapter" title="9 Module Events">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Interface CICM::ModuleEventManager">
<link href="#rfc.section.9.1.1" rel="Chapter" title="9.1.1 CICM::ModuleEventManager Methods">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Interface CICM::ModuleEventListener">
<link href="#rfc.section.9.2.1" rel="Chapter" title="9.2.1 CICM::ModuleEventListener Types and Constants">
<link href="#rfc.section.9.2.2" rel="Chapter" title="9.2.2 CICM::ModuleEventListener Methods">
<link href="#rfc.section.10" rel="Chapter" title="10 IANA Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 Security Considerations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Unauthorized Usage">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Inappropriate Usage">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Denial of Service">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A IDL Definitions">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="[RFC Editor: Please update the RFC references prior to publication.]" />
  <meta name="description" content="[RFC Editor: Please update the RFC references prior to publication.]" />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">D. Lanz</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">L. Novikov</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">MITRE</td>
</tr>
<tr>
<td class="left">Expires: January 26, 2012</td>
<td class="right">July 25, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Common Interface to Cryptographic Modules (CICM) Module Management <br />
  <span class="filename">draft-lanz-cicm-mm-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>[RFC Editor: Please update the RFC references prior to publication.]</p>
<p>This memo defines a programming interface for high-level management of cryptographic modules as outlined in draft-lanz-cicm-model-00 and required by draft-lanz-cicm-02 including managing the module authentication, software, logs, built-in tests, and responding to module events.</p>
<p>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 26, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Definition Language</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Conformance and Extension Language</a>
</li>
<li>2.   <a href="#rfc.section.2">CICM Dependencies</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Namespaces</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Types</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Interfaces</a>
</li>
<li>3.   <a href="#rfc.section.3">Hardware Access Tokens</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Token Management Identifiers</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Interface CICM::TokenManager</a>
</li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">CICM::TokenManager Attributes</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">CICM::TokenManager Methods</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Interface CICM::TokenAssnIterator</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">CICM::TokenAssnIterator Inheritance</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">CICM::TokenAssnIterator Methods</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Interface CICM::ModuleAssnIterator</a>
</li>
<li>3.4.1.   <a href="#rfc.section.3.4.1">CICM::ModuleAssnIterator Inheritance</a>
</li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">CICM::ModuleAssnIterator Methods</a>
</li>
<li>4.   <a href="#rfc.section.4">Users</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">User Management Identifiers</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Interface CICM::UserManager</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">CICM::UserManager Attributes</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">CICM::UserManager Methods</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Interface CICM::UserIdIterator</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">CICM::UserIdIterator Inheritance</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">CICM::UserIdIterator Methods</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Interface CICM::RoleIdIterator</a>
</li>
<li>4.4.1.   <a href="#rfc.section.4.4.1">CICM::RoleIdIterator Inheritance</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">CICM::RoleIdIterator Methods</a>
</li>
<li>5.   <a href="#rfc.section.5">Login</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Interface CICM::LoginManager</a>
</li>
<li>5.1.1.   <a href="#rfc.section.5.1.1">CICM::LoginManager Methods</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Interface CICM::Login</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">CICM::Login Methods</a>
</li>
<li>6.   <a href="#rfc.section.6">Software Packages</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Package Management Identifier</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Interface CICM::PackageManager</a>
</li>
<li>6.2.1.   <a href="#rfc.section.6.2.1">CICM::PackageManager Attributes</a>
</li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">CICM::PackageManager Methods</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Interface CICM::PackageImporter</a>
</li>
<li>6.3.1.   <a href="#rfc.section.6.3.1">CICM::PackageImporter Methods</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Interface CICM::Package</a>
</li>
<li>6.4.1.   <a href="#rfc.section.6.4.1">CICM::Package Types and Constants</a>
</li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">CICM::Package Attributes</a>
</li>
<li>6.4.3.   <a href="#rfc.section.6.4.3">CICM::Package Methods</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Interface CICM::PackageIterator</a>
</li>
<li>6.5.1.   <a href="#rfc.section.6.5.1">CICM::PackageIterator Inheritance</a>
</li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">CICM::PackageIterator Methods</a>
</li>
<li>7.   <a href="#rfc.section.7">Logs</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Interface CICM::LogManager</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">CICM::LogManager Attributes</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">CICM::LogManager Methods</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Interface CICM::LogEntry</a>
</li>
<li>7.2.1.   <a href="#rfc.section.7.2.1">CICM::LogEntry Attributes</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">CICM::LogEntry Methods</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Interface CICM::LogEntryIterator</a>
</li>
<li>7.3.1.   <a href="#rfc.section.7.3.1">CICM::LogEntryIterator Inheritance</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">CICM::LogEntryIterator Methods</a>
</li>
<li>8.   <a href="#rfc.section.8">Tests</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Interface CICM::TestManager</a>
</li>
<li>8.1.1.   <a href="#rfc.section.8.1.1">CICM::TestManager Types and Constants</a>
</li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">CICM::TestManager Methods</a>
</li>
<li>9.   <a href="#rfc.section.9">Module Events</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">Interface CICM::ModuleEventManager</a>
</li>
<li>9.1.1.   <a href="#rfc.section.9.1.1">CICM::ModuleEventManager Methods</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Interface CICM::ModuleEventListener</a>
</li>
<li>9.2.1.   <a href="#rfc.section.9.2.1">CICM::ModuleEventListener Types and Constants</a>
</li>
<li>9.2.2.   <a href="#rfc.section.9.2.2">CICM::ModuleEventListener Methods</a>
</li>
<li>10.   <a href="#rfc.section.10">IANA Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">Security Considerations</a>
</li>
<li>11.1.   <a href="#rfc.section.11.1">Unauthorized Usage</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">Inappropriate Usage</a>
</li>
<li>11.3.   <a href="#rfc.section.11.3">Denial of Service</a>
</li>
<li>12.   <a href="#rfc.references">References</a>
</li>
<li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">IDL Definitions</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document defines the module management functions for the Common Interface to Cryptographic Modules (CICM) as defined in <a href="#CICM">[CICM]</a>. The underlying logical model and terminology are defined in <a href="#CICM-LM">[CICM-LM]</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Definition Language</h1>
<p id="rfc.section.1.2.p.1">This document uses the Interface Definition Language (IDL) <a href="#IDL">[IDL]</a> to specify language-neutral interfaces and is not intended to prescribe or preclude a particular communications protocol such as General Inter-ORB Protocol (GIOP) <a href="#CORBA">[CORBA]</a> between programs in different address spaces or on different devices. See Definition Language in <a href="#CICM">[CICM]</a> for more information.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Conformance and Extension Language</h1>
<p id="rfc.section.1.3.p.1">This document contains definitions for several opaque data parameters whose format is not defined by CICM. Instead, implementers are required to create an Implementation Conformance Statement which MUST reference a standard format or define a module developer-specific format implemented by the module for these datatypes. See Conformance and Extensions in <a href="#CICM">[CICM]</a> for more details.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> CICM Dependencies</h1>
<p id="rfc.section.2.p.1">This document depends on type definitions and interfaces that are defined in other CICM documents.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Namespaces</h1>
<p id="rfc.section.2.1.p.1">The CICM namespace is defined in <a href="#CICM">[CICM]</a>.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Types</h1>
<p id="rfc.section.2.2.p.1">The following type definitions are defined in <a href="#CICM">[CICM]</a>: </p>

<ul class="empty">
<li>CICM::UInt32</li>
<li>CICM::CharString</li>
<li>CICM::Buffer</li>
<li>CICM::Status (including all return values)</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Interfaces</h1>
<p id="rfc.section.2.3.p.1">The interface CICM::Iterator is defined in <a href="#CICM">[CICM]</a>; the CICM::SymKey interface is defined in <a href="#CICM-KM">[CICM-KM]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Hardware Access Tokens</h1>
<p id="rfc.section.3.p.1">Cryptographic modules may rely upon hardware access tokens for two primary functions: to allow subjects (e.g., administrators or users in possession of a token) to be identified and authenticated so that privileges can be enforced and audit log entries can identify the subject; and to unlock all or some subset of cryptographic services. A hardware access token may be associated with a number of specific modules, and a module may likewise be associated with a number of specific tokens. The token management functions below enable tokens and modules to be associated with and disassociated from one another, and allow existing associations to be listed.</p>
<p id="rfc.section.3.p.2">The removal of an association between a token and a module is straightforward if both the token and the module are available.  However, if either the token or module are unavailable, or if a different module than the one originally associated with the token is used to remove an association from a token, the disassociation is less straightforward.</p>
<p id="rfc.section.3.p.3">If a module requires that an administrative token be inserted prior to the token to which the association/disassociation will apply, the methods below may return an CICM::S_TOKEN_NOT_PRESENT or CICM::S_TOKEN_ADMIN_NOT_PRESENT status.</p>
<p id="rfc.section.3.p.4">Modules that do not support hardware tokens may instead provide similar support via CICM::LoginManager. Modules may use CICM::LoginManager in tandem with tokens to support multi-factor authentication. See Managing Module Authentication in <a href="#CICM-LM">[CICM-LM]</a> for additional information.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Token Management Identifiers</h1>
<div id="#rfc.figure.1"></div>
<p>Type CICM::TokenRecord</p>
<pre>typedef CICM::CharString TokenRecord;</pre>
<p>Unique token association record.</p>
<div id="#rfc.figure.2"></div>
<p>Type CICM::ModuleRecord</p>
<pre>typedef CICM::CharString ModuleRecord;</pre>
<p>Unique module association record.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Interface CICM::TokenManager</h1>
<div id="#rfc.figure.3"></div>
<p>Interface CICM::TokenManager</p>
<pre>interface TokenManager {</pre>
<p>CICM::TokenManager supports associating and disassociating modules and tokens. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::token_manager attribute. CICM::TokenManager constructs the CICM::ModuleAssnIterator and CICM::TokenAssnIterator interfaces.</p>
<div id="#rfc.figure.4"></div>
<p>Example (C++):</p>
<pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::tokenManager tokenManager;

// Retrieve reference to the token manager.
tokenManager = device._get_token_manager();

// Associate the current token with the module.
sCode = tokenManager.associate();

// Assume that some time later the token is lost or destroyed.

// Disassociate the token from the module.
CICM::TokenUniqueId tokenId = new CICM::TokenUniqueId("TOKEN1426864");
sCode = tokenManager.disassociate_missing_token(tokenId);
</pre>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> CICM::TokenManager Attributes</h1>
<div id="#rfc.figure.5"></div>
<p>Attribute CICM::TokenManager::module_association_iterator</p>
<pre>readonly attribute CICM::ModuleAssnIterator
	module_association_iterator;</pre>
<p>Returns an iterator to enable each module identifier associated with the current token to be retrieved.</p>
<p id="rfc.section.3.2.1.p.1">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<div id="#rfc.figure.6"></div>
<p>Attribute CICM::TokenManager::token_association_iterator</p>
<pre>readonly attribute CICM::TokenAssnIterator
	token_association_iterator;</pre>
<p>Returns an iterator to enable each token identifier associated with the current module to be retrieved.</p>
<p id="rfc.section.3.2.1.p.2">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> CICM::TokenManager Methods</h1>
<div id="#rfc.figure.7"></div>
<p>Method CICM::TokenManager::associate()</p>
<pre>CICM::Status associate(
	out CICM::ModuleRecord module_rec,
	out CICM::TokenRecord token_rec
);</pre>
<p>Associate the module and currently-inserted hardware access token.</p>
<p id="rfc.section.3.2.2.p.1">Remarks: </p>

<ul class="empty">
<li>The module and token record identifiers should be recorded for use in the disassociation process in the event that either the module or the token are no longer available or usable.</li>
<li>The formats of the module and token records are not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for these datatypes.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.2.p.2">Parameters: </p>

<ul class="empty">
<li>[in] module_rec Module record identifier of the newly associated module.</li>
<li>[in] token_rec Token record identifier of the newly associated token.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS, S_TOKEN_RESOURCES, S_TOKEN_ASSOC_EXISTS, S_TOKEN_ASSOC_AT_MODULE, S_TOKEN_ASSOC_AT_TOKEN, S_TOKEN_ASSOC_GENERAL, S_TOKEN_TIMEOUT</li></ul>

<p> </p>
<div id="#rfc.figure.8"></div>
<p>Method CICM::TokenManager::disassociate()</p>
<pre>CICM::Status disassociate();</pre>
<p>Disassociate the module and currently-inserted hardware access token when the associated module and token are both present and both recognize the association.</p>
<p id="rfc.section.3.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS, S_TOKEN_ASSOC_NOT_EXIST, S_TOKEN_DISASSOC_GENERAL, S_TOKEN_TIMEOUT, S_TOKEN_LAST_ASSOCIATED</li></ul>

<p> </p>
<div id="#rfc.figure.9"></div>
<p>Method CICM::TokenManager::disassociate_missing_module()</p>
<pre>CICM::Status disassociate_missing_module(
	in  CICM::ModuleRecord module_rec
);</pre>
<p>Remove association information from the currently-inserted hardware access token when the associated module is not present.</p>
<p id="rfc.section.3.2.2.p.5">Remarks: </p>

<ul class="empty">
<li>The module on which this method is being executed is used as a surrogate to perform the disassociation (it is not the module that performed the initial association). The specific module to disassociate from the token is identified by a unique module identifier (e.g., a module serial number). Use CICM::ModuleAssnIterator to retrieve module record identifiers corresponding to modules associated with the inserted token.</li>
<li>The format of the module record is not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.2.p.6">Parameters: </p>

<ul class="empty"><li>[in] module_rec Identifies the module for which module identification information should be removed from the currently-inserted hardware access token.</li></ul>

<p> </p>
<p id="rfc.section.3.2.2.p.7">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS, S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND, S_TOKEN_TIMEOUT</li></ul>

<p> </p>
<div id="#rfc.figure.10"></div>
<p>Method CICM::TokenManager::disassociate_missing_token()</p>
<pre>CICM::Status disassociate_missing_token(
	in  CICM::TokenRecord token_rec
);</pre>
<p>Remove association information from the module on which this method is being executed when the associated token is not present.</p>
<p id="rfc.section.3.2.2.p.8">Remarks: </p>

<ul class="empty">
<li>The specific token to disassociate from the module is identified by a unique token identifier (e.g., a token serial number). Use CICM::TokenAssnIterator to retrieve token record identifiers corresponding to associated tokens from the module.</li>
<li>The format of the token record is not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.2.p.9">Parameters: </p>

<ul class="empty"><li>[in] token_rec Identifies the hardware access token for which token identification information should be removed from the module.</li></ul>

<p> </p>
<p id="rfc.section.3.2.2.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ASSOC_NOT_EXIST, S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND, S_TOKEN_TIMEOUT</li></ul>

<p> </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Interface CICM::TokenAssnIterator</h1>
<div id="#rfc.figure.11"></div>
<p>Interface CICM::TokenAssnIterator</p>
<pre>interface TokenAssnIterator : CICM::Iterator {</pre>
<p>CICM::TokenAssnIterator supports retrieving each token record from the token association list in the module.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> CICM::TokenAssnIterator Inheritance</h1>
<p id="rfc.section.3.3.1.p.1">CICM::TokenAssnIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> CICM::TokenAssnIterator Methods</h1>
<div id="#rfc.figure.12"></div>
<p>Method CICM::TokenAssnIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::TokenRecord token_rec_ref
);</pre>
<p>Returns a reference to the next token.</p>
<p id="rfc.section.3.3.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.3.3.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] token_rec_ref Reference to next token.</li></ul>

<p> </p>
<p id="rfc.section.3.3.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Interface CICM::ModuleAssnIterator</h1>
<div id="#rfc.figure.13"></div>
<p>Interface CICM::ModuleAssnIterator</p>
<pre>interface ModuleAssnIterator : CICM::Iterator {</pre>
<p>CICM::ModuleAssnIterator supports retrieving each module record from the module association list in the token.</p>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> CICM::ModuleAssnIterator Inheritance</h1>
<p id="rfc.section.3.4.1.p.1">CICM::ModuleAssnIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.3.4.2">
<a href="#rfc.section.3.4.2">3.4.2.</a> CICM::ModuleAssnIterator Methods</h1>
<div id="#rfc.figure.14"></div>
<p>Method CICM::ModuleAssnIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::ModuleRecord module_rec_ref
);</pre>
<p>Returns a reference to the next module record from the module association list in the token.</p>
<p id="rfc.section.3.4.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.3.4.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] module_rec_ref  Reference to next module record.</li></ul>

<p> </p>
<p id="rfc.section.3.4.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Users</h1>
<p id="rfc.section.4.p.1">These interfaces enable the management of users in support of password-based login. See the Managing Module Authentication in <a href="#CICM-LM">[CICM-LM]</a> for additional information.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> User Management Identifiers</h1>
<div id="#rfc.figure.15"></div>
<p>Type CICM::UserId</p>
<pre>typedef CICM::CharString UserId;</pre>
<p>Unique user identifier.</p>
<div id="#rfc.figure.16"></div>
<p>Type CICM::RoleId</p>
<pre>typedef CICM::CharString RoleId;</pre>
<p>Unique role identifier.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Interface CICM::UserManager</h1>
<div id="#rfc.figure.17"></div>
<p>Interface CICM::UserManager</p>
<pre>interface UserManager {</pre>
<p>CICM::UserManager supports adding a user/password, modifying a user's password, and removing users; and associating and disassociating users from a role. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::user_manager attribute. CICM::UserManager constructs the CICM::UserIdIterator and CICM::RoleIdIterator interfaces.</p>
<div id="#rfc.figure.18"></div>
<p>Example (C++):</p>
<pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::UserManager userManager;

// Retrieve reference to the user manager.
userManager = device._get_user_manager();

// Create the user.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = userManager.add(userId, password);

// Associate the user with a pre-defined module role.
CICM::RoleUniqueId roleId = "administrator";
sCode = userManager.associate(userId, roleId);

// Destroy the user.
sCode = userManager.remove(userId);</pre>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> CICM::UserManager Attributes</h1>
<div id="#rfc.figure.19"></div>
<p>Attribute CICM::UserManager::user_iterator</p>
<pre>readonly attribute CICM::UserIdIterator user_iterator;</pre>
<p>Returns an iterator to enable an identifier for each user in the module user database to be retrieved.</p>
<p id="rfc.section.4.2.1.p.1">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<div id="#rfc.figure.20"></div>
<p>Attribute CICM::UserManager::role_iterator</p>
<pre>readonly attribute CICM::RoleIdIterator role_iterator;</pre>
<p>Returns an iterator to enable an identifier for each role supported by the module to be retrieved.</p>
<p id="rfc.section.4.2.1.p.2">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> CICM::UserManager Methods</h1>
<div id="#rfc.figure.21"></div>
<p>Method CICM::UserManager::add()</p>
<pre>CICM::Status add(
	in  CICM::UserId user,
	in  CICM::CharString password
);</pre>
<p>Add a user to the module user database.</p>
<p id="rfc.section.4.2.2.p.1">Parameters: </p>

<ul class="empty">
<li>[in] user New user to add.</li>
<li>[in] password New user's password.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_USERNAME_INVALID, S_USER_EXISTS, S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN</li></ul>

<p> </p>
<div id="#rfc.figure.22"></div>
<p>Method CICM::UserManager::modify()</p>
<pre>CICM::Status modify(
	in  CICM::UserId user,
	in  CICM::CharString password
);</pre>
<p>Change the password of a user in the module user database.</p>
<p id="rfc.section.4.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[in] user User to modify.</li>
<li>[in] password User's new password.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.2.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN</li></ul>

<p> </p>
<div id="#rfc.figure.23"></div>
<p>Method CICM::UserManager::remove()</p>
<pre>CICM::Status remove(
	in  CICM::UserId user
);</pre>
<p>Remove a user from the module user database.</p>
<p id="rfc.section.4.2.2.p.5">Parameters: </p>

<ul class="empty"><li>[in] user User to remove.</li></ul>

<p> </p>
<p id="rfc.section.4.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.24"></div>
<p>Method CICM::UserManager::associate()</p>
<pre>CICM::Status associate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);</pre>
<p>Associate a role with the specified user.</p>
<p id="rfc.section.4.2.2.p.7">Parameters: </p>

<ul class="empty">
<li>[in] user User to associate.</li>
<li>[in] role Role to associate with the user.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.2.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID, S_ROLE_ASSOCIATED, S_ROLE_MAX</li></ul>

<p> </p>
<div id="#rfc.figure.25"></div>
<p>Method CICM::UserManager::disassociate()</p>
<pre>CICM::Status disassociate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);</pre>
<p>Disassociate a role from the specified user.</p>
<p id="rfc.section.4.2.2.p.9">Parameters: </p>

<ul class="empty">
<li>[in] user User to disassociate.</li>
<li>[in] role Role to disassociate from the user.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.2.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID, S_ROLE_NOT_ASSOCIATED</li></ul>

<p> </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Interface CICM::UserIdIterator</h1>
<div id="#rfc.figure.26"></div>
<p>Interface CICM::UserIdIterator</p>
<pre>interface UserIdIterator : CICM::Iterator {</pre>
<p>CICM::UserIdIterator supports retrieving each user configured on a module.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> CICM::UserIdIterator Inheritance</h1>
<p id="rfc.section.4.3.1.p.1">CICM::UserIdIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> CICM::UserIdIterator Methods</h1>
<div id="#rfc.figure.27"></div>
<p>Method CICM::UserIdIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::UserId user_id
);</pre>
<p>Returns the next user identifier.</p>
<p id="rfc.section.4.3.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.4.3.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] user_id Next user identifier.</li></ul>

<p> </p>
<p id="rfc.section.4.3.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Interface CICM::RoleIdIterator</h1>
<div id="#rfc.figure.28"></div>
<p>Interface CICM::RoleIdIterator</p>
<pre>interface RoleIdIterator : CICM::Iterator {</pre>
<p>CICM::RoleIdIterator supports retrieving each role available on a module.</p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> CICM::RoleIdIterator Inheritance</h1>
<p id="rfc.section.4.4.1.p.1">CICM::RoleIdIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> CICM::RoleIdIterator Methods</h1>
<div id="#rfc.figure.29"></div>
<p>Method CICM::RoleIdIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::RoleId role_id
);</pre>
<p>Returns the next role identifier.</p>
<p id="rfc.section.4.4.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.4.4.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] role_id Reference to next role identifier.</li></ul>

<p> </p>
<p id="rfc.section.4.4.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Login</h1>
<p id="rfc.section.5.p.1">These interfaces support a user configured on a module to login to a module using a password and, optionally, additional authentication data. See the Managing Module Authentication in <a href="#CICM-LM">[CICM-LM]</a> for additional information.</p>
<p id="rfc.section.5.p.2">Modules that support hardware tokens may use the login manager in tandem with the CICM::TokenManager to support multi-factor authentication.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Interface CICM::LoginManager</h1>
<div id="#rfc.figure.30"></div>
<p>Interface CICM::LoginManager</p>
<pre>interface LoginManager {</pre>
<p>CICM::LoginManager supports user login to a module. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::login_manager attribute. CICM::LoginManager constructs the CICM::Login interface. The LoginManager relies upon the CICM::UserManager to manage the users that are specified to the login methods.</p>
<div id="#rfc.figure.31"></div>
<p>Example (C++):</p>
<pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LoginManager loginManager;
CICM::Login loginRef;
// Retrieve reference to the login manager.
loginManager = device._get_login_manager();
// Login to the module.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = loginManager.add(userId, password, &amp;loginRef);
// Logout from the module.
sCode = loginRef.logout();</pre>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> CICM::LoginManager Methods</h1>
<div id="#rfc.figure.32"></div>
<p>Method CICM::LoginManager::login()</p>
<pre> CICM::Status login(
	in  CICM::UserId user,
	in  CICM::CharString password,
	out CICM::Login login_ref
);</pre>
<p>Login to the module with username/password.</p>
<p id="rfc.section.5.1.1.p.1">Parameters: </p>

<ul class="empty">
<li>[in] user User attempting to login.</li>
<li>[in] password User's password.</li>
<li>[out] login_ref Reference to state resulting from successful user login enabling the user to later logout.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_AUTHENTICATION_FAILED, S_USER_AUTHENTICATED</li></ul>

<p> </p>
<div id="#rfc.figure.33"></div>
<p>Method CICM::LoginManager::login_auth_data()</p>
<pre>CICM::Status login_auth_data(
	in  CICM::UserId user,
	in  CICM::CharString password,
	in  CICM::Buffer auth_data,
	out CICM::Login login_ref
);</pre>
<p>Login to the module with username/password, but provide additional (potentially host-stored) authentication data to the module for use in the authentication process.</p>
<p id="rfc.section.5.1.1.p.3">Remarks: </p>

<ul class="empty">
<li>This may be used in cases where the host supports a virtual token.</li>
<li>The format of the authentication data is not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.1.p.4">Parameters: </p>

<ul class="empty">
<li>[in] user User attempting to login.</li>
<li>[in] password User's password.</li>
<li>[in] auth_data Additional host-stored authentication data.</li>
<li>[out] login_ref Reference to state resulting from successful user login enabling the user to later logout.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.1.p.5">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_AUTHENTICATION_FAILED, S_USER_AUTHENTICATED</li></ul>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Interface CICM::Login</h1>
<div id="#rfc.figure.34"></div>
<p>Interface CICM::Login</p>
<pre>interface Login {</pre>
<p>CICM::Login results from a successful user login to a module and enables the user to log out from the module.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> CICM::Login Methods</h1>
<div id="#rfc.figure.35"></div>
<p>Method CICM::Login::logout()</p>
<pre>CICM::Status logout();</pre>
<p>Logout of the module.</p>
<p id="rfc.section.5.2.1.p.1">Remarks: </p>

<ul class="empty"><li>This may be equivalent to disconnecting a hardware access token from a module in certain systems.</li></ul>

<p> </p>
<p id="rfc.section.5.2.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Software Packages</h1>
<p id="rfc.section.6.p.1">These interfaces support software, FPGA images, policy databases, configuration parameters, or other types of executable or interpretable code to be imported into and removed from a module.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Package Management Identifier</h1>
<div id="#rfc.figure.36"></div>
<p>Type CICM::PackageId</p>
<pre>typedef CICM::CharString PackageId;</pre>
<p>Unique package identifier.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Interface CICM::PackageManager</h1>
<div id="#rfc.figure.37"></div>
<p>Interface CICM::PackageManager</p>
<pre>interface PackageManager {</pre>
<p>CICM::PackageManager supports the management of module software packages. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::package_manager attribute. CICM::PackageManager constructs the CICM::PackageImporter, CICM::PackageIterator, and CICM::Package interfaces.</p>
<div id="#rfc.figure.38"></div>
<p>Example (C++):</p>
<pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::PackageManager packageManager;
CICM::PackageImporter packageImporter;
// Retrieve reference to the package manager.
packageManager = device._get_package_manager();

// Initialize the import process.
sCode = packageManager.import_package(
	CICM::Package::C_PACKAGE_FPGA_IMAGE, &amp;packageImporter);

// Assume FPGA image data in [fpgaData].
CICM::Buffer fpgaData;
sCode = packageImporter.import_segment(fpgaData);

// Assume all segments are imported.
// Complete the import process.

CICM::Package fpgaPackage;
sCode = packageImporter.complete(&amp;fpgaPackage);
// If successful, [fpgaPackage] is a reference to the imported package.
// Activate the package.
sCode = fpgaPackage.activate();</pre>
<h1 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> CICM::PackageManager Attributes</h1>
<div id="#rfc.figure.39"></div>
<p>Attribute CICM::PackageManager::package_iterator</p>
<pre>readonly attribute CICM::PackageIterator package_iterator;</pre>
<p>Returns an iterator to enable a reference to each package loaded on the module to be retrieved.</p>
<p id="rfc.section.6.2.1.p.1">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<h1 id="rfc.section.6.2.2">
<a href="#rfc.section.6.2.2">6.2.2.</a> CICM::PackageManager Methods</h1>
<div id="#rfc.figure.40"></div>
<p>Method CICM::PackageManager::import_package()</p>
<pre>CICM::Status import_package(
	in  CICM::Package::PackageType package_type,
	out CICM::PackageImporter importer_ref
);</pre>
<p>Initiate the process of importing a package into the module.</p>
<p id="rfc.section.6.2.2.p.1">Remarks: </p>

<ul class="empty"><li>The CICM::PackageImporter that results from this call is used to import package segments into the module. It is the responsibility of the caller to break a package into segments, import each individual segment, and then call CICM::PackageImporter::complete to receive a reference to the resulting package. Note that the key required to decrypt any encrypted package segments MUST be referenced within the package and MUST be available to the module; the key MAY be explicitly specified by using the CICM::PackageManager::import_package_with_key version of the call.</li></ul>

<p> </p>
<p id="rfc.section.6.2.2.p.2">Parameters: </p>

<ul class="empty">
<li>[in] package_type Type of the package being imported.</li>
<li>[out] importer_ref Reference to package importer interface which enables a package to be imported segment by segment.</li>
</ul>

<p> </p>
<p id="rfc.section.6.2.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID, S_PACKAGE_KEY_NOT_AVAILABLE, S_PACKAGE_KEY_NOT_SPECIFIED</li></ul>

<p> </p>
<div id="#rfc.figure.41"></div>
<p>Method CICM::PackageManager::import_package_with_key()</p>
<pre>CICM::Status import_package_with_key(
	in  CICM::Package::PackageType package_type,
	in  CICM::SymKey key_ref,
	out CICM::PackageImporter importer_ref
);</pre>
<p>Initiate the process of importing a package into the module, specifying a reference to the key that will be used by CICM::PackageImporter to decrypt each package segment.</p>
<p id="rfc.section.6.2.2.p.4">Remarks: </p>

<ul class="empty"><li>The CICM::PackageImporter that results from this call is used to import package segments into the module. It is the responsibility of the caller to break a package into segments, import each individual segment, and then call CICM::PackageImporter::complete to receive a reference to the resulting package.</li></ul>

<p> </p>
<p id="rfc.section.6.2.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] package_type Type of the package being imported.</li>
<li>[in] key_ref Reference to key to decrypt package segments.</li>
<li>[out] importer_ref Reference to package importer interface which enables a package to be imported segment by segment.</li>
</ul>

<p> </p>
<p id="rfc.section.6.2.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.42"></div>
<p>Method CICM::PackageManager::get_package_by_id()</p>
<pre>CICM::Status get_package_by_id(
	in  CICM::PackageId package_id,
	out CICM::Package package_ref
);</pre>
<p>Retrieve a reference to a package based upon a unique identifier associated with that package.</p>
<p id="rfc.section.6.2.2.p.7">Parameters: </p>

<ul class="empty">
<li>[in] package_id Package identifier.</li>
<li>[out] package_ref Reference to package corresponding to the specified identifier.</li>
</ul>

<p> </p>
<p id="rfc.section.6.2.2.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.43"></div>
<p>Method CICM::PackageManager::reencrypt_software()</p>
<pre>CICM::Status reencrypt_software();</pre>
<p>Re-encrypt module software with a key managed by the module.</p>
<p id="rfc.section.6.2.2.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Interface CICM::PackageImporter</h1>
<div id="#rfc.figure.44"></div>
<p>Interface CICM::PackageImporter</p>
<pre>interface PackageImporter {</pre>
<p>CICM::PackageImporter supports importing software packages, segment by segment. CICM::PackageImporter is constructed by the CICM::PackageManager::import_package and CICM::PackageManager::import_package_with_key methods and cannot be instantiated independently. CICM::PackageImporter constructs the CICM::Package interface.</p>
<h1 id="rfc.section.6.3.1">
<a href="#rfc.section.6.3.1">6.3.1.</a> CICM::PackageImporter Methods</h1>
<div id="#rfc.figure.45"></div>
<p>Method CICM::PackageImporter::import_segment()</p>
<pre>CICM::Status import_segment(
	in  CICM::Buffer package_data
);</pre>
<p>Import one segment of a package.</p>
<p id="rfc.section.6.3.1.p.1">Remarks: </p>

<ul class="empty">
<li>It is the responsibility of the caller to break a package into segments, import each individual segment, and then call CICM::PackageImporter::complete to receive a reference to the resulting package.</li>
<li>CICM does not specify the structure of the binary data that constitutes the package being imported. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.6.3.1.p.2">Parameters: </p>

<ul class="empty"><li>[in] package_data Contents of the package.</li></ul>

<p> </p>
<p id="rfc.section.6.3.1.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.46"></div>
<p>Method CICM::PackageImporter::complete()</p>
<pre>CICM::Status complete(
	out CICM::Package package_ref
);</pre>
<p>Declare the package import complete and retrieve a reference to the resulting package object.</p>
<p id="rfc.section.6.3.1.p.4">Remarks: </p>

<ul class="empty"><li>If this method is called before the package is fully loaded, the CICM::S_PACKAGE_INVALID status results.</li></ul>

<p> </p>
<p id="rfc.section.6.3.1.p.5">Parameters: </p>

<ul class="empty"><li>[out] package_ref Reference to resulting imported package.</li></ul>

<p> </p>
<p id="rfc.section.6.3.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.47"></div>
<p>Method CICM::PackageImporter::abort()</p>
<pre>CICM::Status abort();</pre>
<p>Abort a package import, resetting this CICM::PackageImporter instance, allowing a new package import session to begin.</p>
<p id="rfc.section.6.3.1.p.7">Remarks: </p>

<ul class="empty"><li>Segments already imported are discarded.</li></ul>

<p> </p>
<p id="rfc.section.6.3.1.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Interface CICM::Package</h1>
<div id="#rfc.figure.48"></div>
<p>Interface CICM::Package</p>
<pre>interface Package {</pre>
<p>CICM::Package serves as a reference to a package previously loaded into a module, and supports activating, deactivating, and deleting the package. CICM::Package is constructed by the CICM::PackageManager::get_package_by_id and CICM::PackageImporter::complete methods and cannot be instantiated independently.</p>
<h1 id="rfc.section.6.4.1">
<a href="#rfc.section.6.4.1">6.4.1.</a> CICM::Package Types and Constants</h1>
<div id="#rfc.figure.49"></div>
<p>Type CICM::Package::PackageType</p>
<pre>typedef CICM::UInt32 PackageType;</pre>
<p>Supported package types.</p>
<div id="#rfc.figure.50"></div>
<p>Constant CICM::Package::C_PACKAGE_ALGORITHM</p>
<pre>const CICM::Package::PackageType
	C_PACKAGE_ALGORITHM = 0x00006054;</pre>
<p>Algorithm package type.</p>
<div id="#rfc.figure.51"></div>
<p>Constant CICM::Package::C_PACKAGE_CONFIG_PARAMS</p>
<pre>const CICM::Package::PackageType
	C_PACKAGE_CONFIG_PARAMS = 0x00006057;</pre>
<p>Configuration parameter package type.</p>
<div id="#rfc.figure.52"></div>
<p>Constant CICM::Package::C_PACKAGE_FPGA_IMAGE</p>
<pre>const CICM::Package::PackageType
	C_PACKAGE_FPGA_IMAGE = 0x00006058;</pre>
<p>FPGA image package type.</p>
<div id="#rfc.figure.53"></div>
<p>Constant CICM::Package::C_PACKAGE_POLICY_DB</p>
<pre>const CICM::Package::PackageType
	C_PACKAGE_POLICY_DB = 0x0000605B;</pre>
<p>Policy database package type.</p>
<div id="#rfc.figure.54"></div>
<p>Constant CICM::Package::C_PACKAGE_SOFTWARE</p>
<pre>const CICM::Package::PackageType
	C_PACKAGE_SOFTWARE = 0x0000605D;</pre>
<p>Software package type.</p>
<h1 id="rfc.section.6.4.2">
<a href="#rfc.section.6.4.2">6.4.2.</a> CICM::Package Attributes</h1>
<div id="#rfc.figure.55"></div>
<p>Attribute CICM::Package::id</p>
<pre>readonly attribute CICM::PackageId id;</pre>
<p>Unique package identifier of this package.</p>
<h1 id="rfc.section.6.4.3">
<a href="#rfc.section.6.4.3">6.4.3.</a> CICM::Package Methods</h1>
<div id="#rfc.figure.56"></div>
<p>Method CICM::Package::activate()</p>
<pre>CICM::Status activate();</pre>
<p>Activate a specific package on the module.</p>
<p id="rfc.section.6.4.3.p.1">Remarks: </p>

<ul class="empty"><li>It may be necessary to reset the module before the specified package is activated in place of the currently activated package.</li></ul>

<p> </p>
<p id="rfc.section.6.4.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVATABLE, S_PACKAGE_ACTIVATED, S_PACKAGE_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.57"></div>
<p>Method CICM::Package::deactivate()</p>
<pre>CICM::Status deactivate();</pre>
<p>Deactivate a specific package on the module.</p>
<p id="rfc.section.6.4.3.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVE, S_PACKAGE_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.58"></div>
<p>Method CICM::Package::delete()</p>
<pre>CICM::Status delete();</pre>
<p>Delete a package from the module.</p>
<p id="rfc.section.6.4.3.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_ACTIVATED, S_PACKAGE_INVALID</li></ul>

<p> </p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> Interface CICM::PackageIterator</h1>
<div id="#rfc.figure.59"></div>
<p>Interface CICM::PackageIterator</p>
<pre>interface PackageIterator : CICM::Iterator {</pre>
<p>CICM::PackageIterator supports retrieving a reference to each software package available on a module. CICM::PackageIterator constructs the CICM::Package interface.</p>
<h1 id="rfc.section.6.5.1">
<a href="#rfc.section.6.5.1">6.5.1.</a> CICM::PackageIterator Inheritance</h1>
<p id="rfc.section.6.5.1.p.1">CICM::PackageIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.6.5.2">
<a href="#rfc.section.6.5.2">6.5.2.</a> CICM::PackageIterator Methods</h1>
<div id="#rfc.figure.60"></div>
<p>Method CICM::PackageIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::Package package_ref
);</pre>
<p>Returns a reference to the next software package.</p>
<p id="rfc.section.6.5.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.6.5.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] package_ref Reference to next software package.</li></ul>

<p> </p>
<p id="rfc.section.6.5.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Logs</h1>
<p id="rfc.section.7.p.1">These interfaces support the retrieval and removal of log entries.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Interface CICM::LogManager</h1>
<div id="#rfc.figure.61"></div>
<p>Interface CICM::LogManager</p>
<pre>interface LogManager {</pre>
<p>CICM::LogManager supports retrieving or destroying an entire module log, or retrieving or deleting individual log entries. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::log_manager attribute. CICM::LogManager constructs the CICM::LogEntryIterator interface.</p>
<div id="#rfc.figure.62"></div>
<p>Example (C++):</p>
<pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LogManager logManager;

// Retrieve reference to the log manager.
logManager = device._get_log_manager();

// Retrieve reference to a log entry iterator.
CICM::LogEntryIterator iter;
iter = logManager._get_log_entry_iterator();
CICM::Iterator::Status status;
CICM::LogEntry entry;

// Confirm that there are log entries.
sCode = iter.hasNext(&amp;status);

// Iterate over the log entries.
while( CICM::Iterator::C_ITERATOR_HAS_NEXT == status ) {
        sCode = iter.get_next(&amp;entry);
		// Perform an operation on [entry].
        sCode = iter.hasNext(&amp;status);
}
// Delete all of the log entries.
sCode = logManager.destroy();</pre>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> CICM::LogManager Attributes</h1>
<div id="#rfc.figure.63"></div>
<p>Attribute CICM::LogManager::log_entry_iterator</p>
<pre>readonly attribute CICM::LogEntryIterator log_entry_iterator;</pre>
<p>Returns an iterator to enable a reference to each module CICM::LogEntry to be retrieved.</p>
<p id="rfc.section.7.1.1.p.1">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> CICM::LogManager Methods</h1>
<div id="#rfc.figure.64"></div>
<p>Method CICM::LogManager::retrieve()</p>
<pre> CICM::Status retrieve(
	out CICM::Buffer log_ref
);</pre>
<p>Retrieve a reference to the entire module log.</p>
<p id="rfc.section.7.1.2.p.1">Parameters: </p>

<ul class="empty"><li>[out] log_ref Reference to entire module log.</li></ul>

<p> </p>
<p id="rfc.section.7.1.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.65"></div>
<p>Method CICM::LogManager::destroy()</p>
<pre>CICM::Status destroy();</pre>
<p>Destroy all entries in the module log.</p>
<p id="rfc.section.7.1.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Interface CICM::LogEntry</h1>
<div id="#rfc.figure.66"></div>
<p>Interface CICM::LogEntry</p>
<pre>interface LogEntry {</pre>
<p>CICM::LogEntry serves as a reference to an individual log entry in the module log, and supports retrieving information about an individual log entry and deleting an individual log entry.</p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> CICM::LogEntry Attributes</h1>
<div id="#rfc.figure.67"></div>
<p>Attribute CICM::LogEntry::user_id</p>
<pre>readonly attribute CICM::UserId user_id;</pre>
<p>User initiating the module action resulting in this log entry.</p>
<div id="#rfc.figure.68"></div>
<p>Attribute CICM::LogEntry::role_id</p>
<pre>readonly attribute CICM::RoleId role_id;</pre>
<p>Role under which the module action resulting in this log entry was initiated.</p>
<div id="#rfc.figure.69"></div>
<p>Attribute CICM::LogEntry::message</p>
<pre>readonly attribute CICM::CharString message;</pre>
<p>Log message associated with this log entry.</p>
<div id="#rfc.figure.70"></div>
<p>Attribute CICM::LogEntry::date_time</p>
<pre>readonly attribute CICM::CharString date_time;</pre>
<p>Date/time of creation of this log entry.</p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> CICM::LogEntry Methods</h1>
<div id="#rfc.figure.71"></div>
<p>Method CICM::LogEntry::delete()</p>
<pre>CICM::Status delete();</pre>
<p>Remove the current entry from the module log.</p>
<p id="rfc.section.7.2.2.p.1">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_LOG_ENTRY_INVALID</li></ul>

<p> </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Interface CICM::LogEntryIterator</h1>
<div id="#rfc.figure.72"></div>
<p>Interface CICM::LogEntryIterator</p>
<pre>interface LogEntryIterator : CICM::Iterator {</pre>
<p>CICM::LogEntryIterator supports retrieving a reference to each log entry in the module log. CICM::LogEntryIterator constructs the CICM::LogEntry interface.</p>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> CICM::LogEntryIterator Inheritance</h1>
<p id="rfc.section.7.3.1.p.1">CICM::LogEntryIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> CICM::LogEntryIterator Methods</h1>
<div id="#rfc.figure.73"></div>
<p>Method CICM::LogEntryIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::LogEntry log_entry_ref
);</pre>
<p>Returns a reference to the next log entry.</p>
<p id="rfc.section.7.3.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.7.3.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] log_entry_ref Reference to next log entry.</li></ul>

<p> </p>
<p id="rfc.section.7.3.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Tests</h1>
<p id="rfc.section.8.p.1">These interfaces support the initiation of module internal tests by client programs.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Interface CICM::TestManager</h1>
<div id="#rfc.figure.74"></div>
<p>Interface CICM::TestManager</p>
<pre>interface TestManager {</pre>
<p>CICM::TestManager supports initiating client program-invoked module built-in tests. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::test_manager attribute.</p>
<h1 id="rfc.section.8.1.1">
<a href="#rfc.section.8.1.1">8.1.1.</a> CICM::TestManager Types and Constants</h1>
<div id="#rfc.figure.75"></div>
<p>Type CICM::TestManager::Status</p>
<pre>typedef CICM::UInt32 Status;</pre>
<p>Test state at completion.</p>
<div id="#rfc.figure.76"></div>
<p>Constant CICM::TestManager::C_TEST_SUCCESS</p>
<pre>const CICM::TestManager::Status
	C_TEST_SUCCESS = 0x00006062;</pre>
<p>The test completed successfully.</p>
<div id="#rfc.figure.77"></div>
<p>Constant CICM::TestManager::C_TEST_FAILURE</p>
<pre>const CICM::TestManager::Status
	C_TEST_FAILURE = 0x00006064;</pre>
<p>The test failed.</p>
<h1 id="rfc.section.8.1.2">
<a href="#rfc.section.8.1.2">8.1.2.</a> CICM::TestManager Methods</h1>
<div id="#rfc.figure.78"></div>
<p>Method CICM::TestManager::run_test()</p>
<pre>CICM::Status run_test(
	in  CICM::Buffer test_parameters,
	out CICM::TestManager::Status status
);</pre>
<p>Run module built-in tests specifying module-specific test parameters.</p>
<p id="rfc.section.8.1.2.p.1">Remarks: </p>

<ul class="empty">
<li>This method can only initiate tests that a client program can explicitly request (e.g., this method does not apply to a series of tests automatically initiated during a module's start-up sequence). Running built-in tests on some modules may result in an alarm if an error is encountered during the test run.</li>
<li>The format of the test parameters value is not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.8.1.2.p.2">Parameters: </p>

<ul class="empty">
<li>[in] test_parameters Module-specific test parameters.</li>
<li>[out] status Status of test at completion.</li>
</ul>

<p> </p>
<p id="rfc.section.8.1.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE, S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.8.1.2.p.4">See also: </p>

<ul class="empty"><li>CICM::TestManager::run_test_get_results for the version of this method that returns test results.</li></ul>

<p> </p>
<div id="#rfc.figure.79"></div>
<p>Method CICM::TestManager::run_test_get_results()</p>
<pre>CICM::Status run_test_get_results(
	in  CICM::Buffer test_parameters,
	out CICM::Buffer test_results
);</pre>
<p>Run module built-in tests specifying module-specific test parameters and receiving module-specific results or data for later evaluation from the test run.</p>
<p id="rfc.section.8.1.2.p.5">Remarks: </p>

<ul class="empty">
<li>This method can only initiate tests that a client program can explicitly request (e.g., this method does not apply to a series of tests automatically initiated during a module's start-up sequence). Running built-in tests on some modules may result in an alarm if an error is encountered during the test run.</li>
<li>The formats of the test parameters and test results values are not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for these datatypes.</li>
</ul>

<p> </p>
<p id="rfc.section.8.1.2.p.6">Parameters: </p>

<ul class="empty">
<li>[in] test_parameters Module-specific test parameters.</li>
<li>[out] test_results Results of the test.</li>
</ul>

<p> </p>
<p id="rfc.section.8.1.2.p.7">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE, S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.8.1.2.p.8">See also: </p>

<ul class="empty"><li>CICM::TestManager::run_test for the version of this Method that returns a simple test status value.</li></ul>

<p> </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Module Events</h1>
<p id="rfc.section.9.p.1">In certain cases it may be necessary for a module to asynchronously notify a client program of an event.  Client programs can register to receive module notifications using CICM::ModuleEventManager. This manager enables a client program to register a listener (callback) method designed to handle a specific condition. The event method prototype provided by the client program is defined in CICM::ModuleEventListener.  CICM::ModuleEventListener also defines the conditions that may result in a notification, including: hardware requires attention, alarm, key expired, and health test failure.</p>
<p id="rfc.section.9.p.2">In certain cases, a single event on a module may result in the generation of multiple notification messages. For example, CICM::ModuleEventListener::C_MODULE_ALARM may be followed by a CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> Interface CICM::ModuleEventManager</h1>
<div id="#rfc.figure.80"></div>
<p>Interface CICM::ModuleEventManager</p>
<pre>interface ModuleEventManager {</pre>
<p>CICM::ModuleEventManager supports registering and unregistering user-defined module event listeners (CICM::ModuleEventListener) for specific module events. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::event_manager attribute.</p>
<h1 id="rfc.section.9.1.1">
<a href="#rfc.section.9.1.1">9.1.1.</a> CICM::ModuleEventManager Methods</h1>
<div id="#rfc.figure.81"></div>
<p>Method CICM::ModuleEventManager::register()</p>
<pre>CICM::Status register(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::ModuleEventListener listener
);</pre>
<p>Registers the listener for a specific module event.</p>
<p id="rfc.section.9.1.1.p.1">Remarks: </p>

<ul class="empty"><li>The provided listener applies only to the client program from which the registration is initiated.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.2">Parameters: </p>

<ul class="empty">
<li>[in] event Event for which this listener is being registered.</li>
<li>[in] listener Listener that will receive a notification about the specified event.</li>
</ul>

<p> </p>
<p id="rfc.section.9.1.1.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_REGISTERED, S_EVENT_NOT_SUPPORTED</li></ul>

<p> </p>
<div id="#rfc.figure.82"></div>
<p>Method CICM::ModuleEventManager::unregister()</p>
<pre>CICM::Status unregister(
	in  CICM::ModuleEventListener::ModuleEvent event
);</pre>
<p>Unregisters the listener associated with the specified event.</p>
<p id="rfc.section.9.1.1.p.4">Remarks: </p>

<ul class="empty"><li>The listener associated with the specified event is only unregistered from the client program from which this method is called.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.5">Parameters: </p>

<ul class="empty"><li>[in] event Event that will no longer have a listener associated with it.</li></ul>

<p> </p>
<p id="rfc.section.9.1.1.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_NOT_REGISTERED</li></ul>

<p> </p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> Interface CICM::ModuleEventListener</h1>
<div id="#rfc.figure.83"></div>
<p>Interface CICM::ModuleEventListener</p>
<pre>interface ModuleEventListener {</pre>
<p>CICM::ModuleEventListener is unlike other CICM interfaces in that the interface is implemented by the developer of the client program to service a specific module event and is then registered via the CICM::ModuleEventManager.</p>
<h1 id="rfc.section.9.2.1">
<a href="#rfc.section.9.2.1">9.2.1.</a> CICM::ModuleEventListener Types and Constants</h1>
<div id="#rfc.figure.84"></div>
<p>Type CICM::ModuleEventListener::ModuleEvent</p>
<pre>typedef CICM::UInt32 ModuleEvent;</pre>
<p>Events for which a ModuleEventListener can be notified.</p>
<div id="#rfc.figure.85"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_INSERTED</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;</pre>
<p>Access token has been inserted.</p>
<div id="#rfc.figure.86"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_REMOVED</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;</pre>
<p>Access token has been removed.</p>
<div id="#rfc.figure.87"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_ALARM</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ALARM = 0x00002004;</pre>
<p>Module has entered an alarm state.</p>
<div id="#rfc.figure.88"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_FAILURE</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_FAILURE = 0x00002007;</pre>
<p>Non-critical module failure detected.</p>
<div id="#rfc.figure.89"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_INSUFFICIENT_ENTROPY</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;</pre>
<p>Insufficient entropy available to a cryptographic operation that requires it.</p>
<div id="#rfc.figure.90"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_HARD</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_HARD =	0x0000200B;</pre>
<p>Specific key has expired; the module can optionally include identifying information about the specific key that expired in the event_data buffer that is provided with the event itself.</p>
<div id="#rfc.figure.91"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_SOFT</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;</pre>
<p>Specific key is within some system-defined delta of hard expiration; the module can optionally include identifying information about the specific key that is about to expire in the event_data buffer that is provided with the event itself.</p>
<div id="#rfc.figure.92"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_COMPLETE</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;</pre>
<p>Key fill is complete.</p>
<div id="#rfc.figure.93"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_CONNECTED</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_CONNECTED = 0x00002010;</pre>
<p>Key fill device has been connected.</p>
<div id="#rfc.figure.94"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_INITIATED</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_INITIATED = 0x00002013;</pre>
<p>Key fill has been initiated.</p>
<div id="#rfc.figure.95"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_MEMORY</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_MEMORY = 0x00002015;</pre>
<p>Out of internal key memory condition.</p>
<div id="#rfc.figure.96"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;</pre>
<p>Key protocol message is available; see the Key Protocol Management documentation for additional information.</p>
<div id="#rfc.figure.97"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_LOG_FULL</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_FULL = 0x00002019;</pre>
<p>Module log is full.</p>
<div id="#rfc.figure.98"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_LOG_NEAR_FULL</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_NEAR_FULL = 0x0000201A;</pre>
<p>Module log is nearly full.</p>
<div id="#rfc.figure.99"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_LOGIN_FAILURE</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOGIN_FAILURE = 0x0000201C;</pre>
<p>Attempted login failed.</p>
<div id="#rfc.figure.100"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;</pre>
<p>Module is not able to process traffic.</p>
<div id="#rfc.figure.101"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_ENTER</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
C_MODULE_POWER_MGMT_ENTER = 0x00002020;</pre>
<p>Module has entered power management state.</p>
<div id="#rfc.figure.102"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_EXIT</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_MGMT_EXIT = 0x00002023;</pre>
<p>Module has exited power management state.</p>
<div id="#rfc.figure.103"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF = 0x00002025;</pre>
<p>Change in module power state to OFF detected.</p>
<div id="#rfc.figure.104"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF_FAILURE</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF_FAILURE = 0x00002026;</pre>
<p>Disorderly change in module power state to OFF detected.</p>
<div id="#rfc.figure.105"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_ON</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_ON = 0x00002029;</pre>
<p>Change in module power state to ON detected.</p>
<div id="#rfc.figure.106"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_READY_FOR_TRAFFIC</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;</pre>
<p>Module is ready to process traffic.</p>
<div id="#rfc.figure.107"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_REKEY_REQUEST</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_REKEY_REQUEST = 0x0000202C;</pre>
<p>Rekey of a specific key is required; the module can optionally include identifying information about the specific key to be rekeyed in the event_data buffer that is provided with the event itself.</p>
<div id="#rfc.figure.108"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_TEST_FAILURE</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_TEST_FAILURE = 0x0000202F;</pre>
<p>Module internal test has failed; the module can optionally include identifying information about the specific test that failed in the event_data buffer that is provided with the event itself.</p>
<div id="#rfc.figure.109"></div>
<p>Constant CICM::ModuleEventListener::C_MODULE_ZEROIZED</p>
<pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ZEROIZED = 0x00002031;</pre>
<p>Module has been zeroized.</p>
<h1 id="rfc.section.9.2.2">
<a href="#rfc.section.9.2.2">9.2.2.</a> CICM::ModuleEventListener Methods</h1>
<div id="#rfc.figure.110"></div>
<p>Method CICM::ModuleEventListener::event_occurred()</p>
<pre>void event_occurred(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::Buffer event_data
);</pre>
<p>Method implemented by client program that is called by the host runtime system to notify that a specific module event has occurred.</p>
<p id="rfc.section.9.2.2.p.1">Remarks: </p>

<ul class="empty">
<li>An opaque data field with additional information about the event in a module-specific format MAY optionally be provided with the event itself. This field MAY be of length zero.</li>
<li>The format of the event data value is not defined in this specification. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module-specific format for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.9.2.2.p.2">Note: </p>

<ul class="empty"><li>Because this method is called by the runtime system and not a client program, it does not return a status value.</li></ul>

<p> </p>
<p id="rfc.section.9.2.2.p.3">Parameters: </p>

<ul class="empty">
<li>[in] event Event that occurred.</li>
<li>[in] event_data Opaque data associated with the event (e.g., specific test that failed, key that will expire).</li>
</ul>

<p> </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> IANA Considerations</h1>
<p id="rfc.section.10.p.1">[RFC Editor: Please remove this section prior to publication.]</p>
<p id="rfc.section.10.p.2">This document has no IANA actions.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> Security Considerations</h1>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> Unauthorized Usage</h1>
<p id="rfc.section.11.1.p.1">A cryptographic module is typically a controlled resource which requires appropriate authorization to use. Specific implementations may use a combination of hardware access tokens, usernames and passwords, access control lists, or other means.</p>
<p id="rfc.section.11.1.p.2">CICM defines the TokenManager, UserManager, and LoginManager interfaces to facilitate with the management of authorized users and to provide authentication capabilities.</p>
<h1 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> Inappropriate Usage</h1>
<p id="rfc.section.11.2.p.1">Although CICM does not define audit logs as a separate concept, the LogManager interface can conceivably provide enough information to act as a means for tracking inappropriate usage which is especially important for the operations that manage the module itself: managing users, updating the module software, and running the built-in tests. Additionally, manipulation of the module logs may undermine the value of the auditing countermeasure.</p>
<h1 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> Denial of Service</h1>
<p id="rfc.section.11.3.p.1">As suggested by <a href="#RFC3552">[RFC3552]</a>, implementers are advised to include mechanisms that mitigate against denial of service attacks.  This is primarily an issue for modules that authenticate using a user name and password, although this may also be an issue for hardware access tokens.</p>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="CICM">[CICM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-KM">[CICM-KM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Key Management [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="IDL">[IDL]</b></td>
<td class="top">
<a>International Standards Organization</a>, "<a>Information technology &#8212; Open Distributed Processing &#8212; Interface Definition Language</a>", ISO/IEC 14750:1999(E), March 1999.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3552">[RFC3552]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-LM">[CICM-LM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Logical Model [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CORBA">[CORBA]</b></td>
<td class="top">
<a>Object Management Group</a>, "<a>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</a>", January 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#idl-code" id="idl-code">IDL Definitions</a>
</h1>
<div id="#rfc.figure.111"></div>
<pre>module CICM {
  typedef CICM::CharString TokenRecord;
  typedef CICM::CharString ModuleRecord;

  interface TokenAssnIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::TokenRecord token_rec_ref );
  };

  interface ModuleAssnIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::ModuleRecord module_rec_ref );
  };

  interface TokenManager {
    readonly attribute CICM::ModuleAssnIterator
      module_association_iterator;

    readonly attribute CICM::TokenAssnIterator
      token_association_iterator;

    CICM::Status associate(
      out CICM::ModuleRecord module_rec,
      out CICM::TokenRecord token_rec );

    CICM::Status disassociate();

    CICM::Status disassociate_missing_module(
      in  CICM::ModuleRecord module_rec );

    CICM::Status disassociate_missing_token(
      in  CICM::TokenRecord token_rec );
  };

  typedef CICM::CharString UserId;
  typedef CICM::CharString RoleId;

  interface UserIdIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::UserId user_id );
  };

  interface RoleIdIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::RoleId role_id );
  };

  interface UserManager {
    readonly attribute CICM::UserIdIterator user_iterator;
    readonly attribute CICM::RoleIdIterator role_iterator;

    CICM::Status add(
      in  CICM::UserId user,
      in  CICM::CharString password );

    CICM::Status modify(
      in  CICM::UserId user,
      in  CICM::CharString password );

    CICM::Status remove(
      in  CICM::UserId user );

    CICM::Status associate(
      in  CICM::UserId user,
      in  CICM::RoleId role );

    CICM::Status disassociate(
      in  CICM::UserId user,
      in  CICM::RoleId role );
  };

  interface Login {
    CICM::Status logout();
  };

  interface LoginManager {
     CICM::Status login(
      in  CICM::UserId user,
      in  CICM::CharString password,
      out CICM::Login login_ref );

    CICM::Status login_auth_data(
      in  CICM::UserId user,
      in  CICM::CharString password,
      in  CICM::Buffer auth_data,
      out CICM::Login login_ref );
  };

  typedef CICM::CharString PackageId;

  interface Package {
    typedef CICM::UInt32 PackageType;
    const CICM::Package::PackageType
      C_PACKAGE_ALGORITHM = 0x00006054;

    const CICM::Package::PackageType
      C_PACKAGE_CONFIG_PARAMS = 0x00006057;

    const CICM::Package::PackageType
      C_PACKAGE_FPGA_IMAGE = 0x00006058;

    const CICM::Package::PackageType
      C_PACKAGE_POLICY_DB = 0x0000605B;

    const CICM::Package::PackageType
      C_PACKAGE_SOFTWARE = 0x0000605D;

    readonly attribute CICM::PackageId id;

    CICM::Status activate();
    CICM::Status deactivate();
    CICM::Status delete();
  };

  interface PackageIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::Package package_ref );
  };

  interface PackageImporter {
    CICM::Status import_segment(
      in  CICM::Buffer package_data );

    CICM::Status complete(
      out CICM::Package package_ref );

    CICM::Status abort();
  };

  interface PackageManager {
    readonly attribute CICM::PackageIterator package_iterator;

    CICM::Status import_package(
      in  CICM::Package::PackageType package_type,
      out CICM::PackageImporter importer_ref );

    CICM::Status import_package_with_key(
      in  CICM::Package::PackageType package_type,
      in  CICM::SymKey key_ref,
      out CICM::PackageImporter importer_ref );

    CICM::Status get_package_by_id(
      in  CICM::PackageId package_id,
      out CICM::Package package_ref );

    CICM::Status reencrypt_software();
  };

  interface LogEntry {
    readonly attribute CICM::UserId user_id;
    readonly attribute CICM::RoleId role_id;
    readonly attribute CICM::CharString message;
    readonly attribute CICM::CharString date_time;

    CICM::Status delete();
  };

  interface LogEntryIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::LogEntry log_entry_ref );
  };

  interface LogManager {
    readonly attribute CICM::LogEntryIterator log_entry_iterator;

    CICM::Status retrieve(
      out CICM::Buffer log_ref );

    CICM::Status destroy();
  };

  interface TestManager {
    typedef CICM::UInt32 Status;
    const CICM::TestManager::Status C_TEST_SUCCESS = 0x00006062;
    const CICM::TestManager::Status C_TEST_FAILURE = 0x00006064;

    CICM::Status run_test(
      in  CICM::Buffer test_parameters,
      out CICM::TestManager::Status status );

    CICM::Status run_test_get_results(
      in  CICM::Buffer test_parameters,
      out CICM::Buffer test_results );
  };

  interface ModuleEventListener {
    typedef CICM::UInt32 ModuleEvent;
    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ALARM = 0x00002004;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_FAILURE = 0x00002007;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_EXPIRED_HARD = 0x0000200B;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_CONNECTED = 0x00002010;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_INITIATED = 0x00002013;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_MEMORY = 0x00002015;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOG_FULL = 0x00002019;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOG_NEAR_FULL = 0x0000201A;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOGIN_FAILURE = 0x0000201C;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_MGMT_ENTER = 0x00002020;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_MGMT_EXIT = 0x00002023;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_OFF = 0x00002025;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_OFF_FAILURE = 0x00002026;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_ON = 0x00002029;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_REKEY_REQUEST = 0x0000202C;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_TEST_FAILURE = 0x0000202F;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ZEROIZED = 0x00002031;

    void event_occurred(
      in  CICM::ModuleEventListener::ModuleEvent event,
      in  CICM::Buffer event_data );
  };

  interface ModuleEventManager {
    CICM::Status register(
      in  CICM::ModuleEventListener::ModuleEvent event,
      in  CICM::ModuleEventListener listener );

    CICM::Status unregister(
      in  CICM::ModuleEventListener::ModuleEvent event );
  };
};</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Daniel J. Lanz</span> 
	  <span class="n hidden">
		<span class="family-name">Lanz</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Lev Novikov</span> 
	  <span class="n hidden">
		<span class="family-name">Novikov</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></span>

  </address>
</div>

</body>
</html>