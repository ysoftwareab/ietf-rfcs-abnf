ESK =HKDF-Extract(salt=0s,PSK) = HMAC(salt=0s,PSK) 
    
BSK = Derive-Secret(ESK, "ext binder", "") 
    
DSK= Derive-Secret(ESK, "derived", "") 
    
FEK = KDF-Expand-Label(BSK, "finished", "", Hash.length) 
    


 
                 Identity Module for TLS Version 1.3    January 2021 
 
ESK= HMAC(salt=0s,PSK) 
DSK= HMAC(ESK,HL16||0d746c7331332064657269766564||HL8||H0||01) 
BSK= HMAC(ESK,HL16||10746c733133206578742062696e646572||HL8||H0||01) 
FEK= HMAC(BSK,HL16||0E746C7331332066696E69736865640001) 
    
    
Length= 2 + Salt-Length + PSK-Length 
    
PSK=0102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F20 
    
ESK= HMAC-SHA256(0,PSK) 
ESK= 23499E7EDF0FBE6BAA137DF0F23BECAEF722AD19FC262855409DE8CD8B3C897 
    
DSK= HMAC-SHA256(ESK,0020 0d746c7331332064657269766564 20 
DSK=E8E7AC087158FC8440E41A12989F9194783764CD5FC36564028037F2C8206E96 
    
BSK = HMAC-SHA256(ESK,0020 10746c733133206578742062696e646572 20 
BSK=4351F8A53AA85AC394AB04C516464CAB96E9340C269632D09899537887EE651F 
    
FEK= HMAC-256(BSK, 0020 0E746C7331332066696E6973686564 00 01) 
FEK=FCA24690D17DDE3F727D29D2186A5F83E1AEBD4889A4841793139168A65BFCB0 
    
Length = 2 + Messages-Length 
Message= NULL = 0s 
Length = 2 + Messages-Length 
Message= NULL = 0s 
DHE=NULL=0s 
Data=NULL=0s 
CLA=00 INS=20 P1=00 P2=00 P3=04 30 30 30 30 
    
adr = Util.makeShort(P1,P2)       ; 
len = Util.makeShort((byte)0,P3)  ; 
    
readCount = apdu.setIncomingAndReceive(); 
readCount = apdu.setIncomingAndReceive(); 
readCount = apdu.setIncomingAndReceive() ; 
readCount = apdu.setIncomingAndReceive(); 
len = Util.makeShort((byte)0,buffer[(short)4]);  
    
readCount = apdu.setIncomingAndReceive();   
index= Util.makeShort((byte)0,P2); 
len= EccSign(ECCkp[index],buffer,P1) ; 
index= Util.makeShort((byte)0,P2); 
index= Util.makeShort((byte)0,P2); 
len=this.GenECCkp(ECCkp[index]); 
index= Util.makeShort((byte)0,P2); 
len= ((ECPublicKey)ECCkp[index].getPublic()) 
                .getA(buffer,(short)(2)); 
len= ((ECPublicKey) ECCkp[index].getPublic()) 
                .getB(buffer,(short)(2)); 
len= ((ECPublicKey) ECCkp[index].getPublic()) 
                .getField(buffer,(short)(2)); 
len= ((ECPublicKey)ECCkp[index].getPublic()) 
                 .getG(buffer,(short)(2)); 
len= ((ECPublicKey) ECCkp[index].getPublic()).getK(); 
len= ((ECPublicKey) ECCkp[index].getPublic()) 
                .getR(buffer,(short)(2)); 
len= ((ECPublicKey) ECCkp[index].getPublic()) 
                .getW(buffer,(short)(2)); 
len= ((ECPrivateKey)ECCkp[index].getPrivate()) 
                .getS(buffer,(short)(2)); 
readCount = apdu.setIncomingAndReceive();  
    
index= Util.makeShort((byte)0,P2); 
index= Util.makeShort((byte)0,P2); 
len= Util.makeShort((byte)0,buf[4]); 
sLen = ECCsig.signPreComputedHash(buf,(short)2,len buf, 
                (short)(2+len)); 
sLen = ECCsig.sign(buf, (short)2, len, buf, (short)(2+len)); 
x = Util.makeShort((byte)0,buffer[4]); 
DIGESTSIZE=(short)md.getLength(); 
lk = DIGESTSIZE ; 
status = (short)0; 
ECCkp  = new KeyPair[N_KEYS]; 
UserPin   = new OwnerPIN((byte)3,(byte)8);  // 3 tries, 4=Max Size 
AdminPin  = new OwnerPIN((byte)10,(byte)8); // 10 tries 8=Max Size 
status =(short)(status + (short)1); 
ECCsig =  
status =(short)(status | (short)0x0100); 
sha256 = 
status =(short)(status | (short)0x2000); 
DB = JCSystem.makeTransientByteArray(DBSIZE, 
                                          JCSystem.CLEAR_ON_DESELECT); 
