H_0 = H^(64)(LE32(p), LE32(T), LE32(m), LE32(t), LE32(v),
                     LE32(y), LE32(length(P)), P, LE32(length(S)), S,
                     LE32(length(K)), K, LE32(length(X)), X)

                              H_0 generation

C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]

                                Final block

r = ceil(T/32)-2
V_1 = H^(64)(LE32(T)||X)
V_2 = H^(64)(V_1)
V_r = H^(64)(V_{r-1})
J_1 = int32(extract(B[i][j-1], 1))
J_2 = int32(extract(B[i][j-1], 2))

                         Deriving J1,J2 in Argon2d

x = J_1^2 / 2^(32)
y = (|W| * x) / 2^(32)
z = |W| - 1 - y

                           Computing J1, part 2

a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
d = (d XOR a) >>> 32
c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
b = (b XOR c) >>> 24

a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
d = (d XOR a) >>> 16
c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
b = (b XOR c) >>> 63

                               Details of GB

Argon2_d  = 0,
Argon2_i  = 1,
Argon2_id = 2
ARGON2_VERSION_10     = 0x10,
ARGON2_VERSION_13     = 0x13,
ARGON2_VERSION_NUMBER = ARGON2_VERSION_13
memory_blocks = context->m_cost;
memory_blocks = 2 * ARGON2_SYNC_POINTS * context->lanes;
segment_length = memory_blocks / (context->lanes *
                                         ARGON2_SYNC_POINTS);
memory_blocks = segment_length * (context->lanes *
                                         ARGON2_SYNC_POINTS);

result = initialize(&instance, context);
result = fill_memory_blocks(&instance);
out = malloc(hashlen);
result = argon2_ctx(&context, type);
ARGON2_BLOCK_SIZE            = 1024,
ARGON2_QWORDS_IN_BLOCK       = ARGON2_BLOCK_SIZE / 8,
ARGON2_OWORDS_IN_BLOCK       = ARGON2_BLOCK_SIZE / 16,
ARGON2_HWORDS_IN_BLOCK       = ARGON2_BLOCK_SIZE / 32,

ARGON2_ADDRESSES_IN_BLOCK    = 128,

ARGON2_PREHASH_DIGEST_LENGTH = 64,
ARGON2_PREHASH_SEED_LENGTH   = 72
reference_area_size =
                position->index - 1; /* all but the previous */
reference_area_size =
                    position->slice * instance->segment_length +
                    position->index - 1;
reference_area_size =
                    position->slice * instance->segment_length +
                    ((position->index == 0) ? (-1) : 0);
reference_area_size = instance->lane_length -
                                  instance->segment_length +
                                  position->index - 1;
reference_area_size = instance->lane_length -
                                  instance->segment_length +
                                  ((position->index == 0) ? (-1) : 0);
relative_position = pseudo_rand;
relative_position = relative_position * relative_position >> 32;
relative_position = reference_area_size - 1 -
                        (reference_area_size * relative_position >> 32);

start_position = 0;

start_position = (position->slice == ARGON2_SYNC_POINTS - 1)
                             ? 0
                             : (position->slice + 1) *
                             instance->segment_length;
absolute_position = (start_position + relative_position) %
                        instance->lane_length; /* absolute position */
result = allocate_memory((uint8_t **)&(instance->memory),
                             instance->memory_blocks, sizeof(block));
block_tmp = ref_block + prev_block + next_block */
data_independent_addressing =
        (instance->type == Argon2_i) ||
        (instance->type == Argon2_id && (position.pass == 0) &&
         (position.slice < ARGON2_SYNC_POINTS / 2));

starting_index = 0;

starting_index = 2;

curr_offset = position.lane * instance->lane_length +
                  position.slice * instance->segment_length +
                  starting_index;

prev_offset = curr_offset + instance->lane_length - 1;
prev_offset = curr_offset - 1;
prev_offset = curr_offset - 1;
pseudo_rand = address_block.v[i %
                                          ARGON2_ADDRESSES_IN_BLOCK];
pseudo_rand = instance->memory[prev_offset].v[0];
ref_lane = ((pseudo_rand >> 32)) % instance->lanes;

ref_lane = position.lane;
ref_index = index_alpha(instance, &position, pseudo_rand &
                                0xFFFFFFFF, ref_lane == position.lane);

ref_block =
            instance->memory + instance->lane_length * ref_lane +
            ref_index;
curr_block = instance->memory + curr_offset;
pwdlen = strlen(pwd);
saltlen = strlen(salt);

out = malloc(outlen + 1);
result = argon2_hash(t_cost, m_cost, threads, pwd, pwdlen, salt,
                          saltlen, out, outlen, type, version);
ret = statement;                  \
toproduce = (uint32_t)outlen - BLAKE2B_OUTBYTES / 2;

a = fBlaMka(a, b);        \
d = rotr64(d ^ a, 32);    \
c = fBlaMka(c, d);        \
b = rotr64(b ^ c, 24);    \
a = fBlaMka(a, b);        \
d = rotr64(d ^ a, 16);    \
c = fBlaMka(c, d);        \
b = rotr64(b ^ c, 63);    \
