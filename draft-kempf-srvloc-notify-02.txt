Service Location                                        James Kempf
INTERNET DRAFT                                          Sun Microsystems
January 7, 2000                                         Jason Goldschmidt
                                                        Bucknell University




                Notification and Subscription for SLP
                   draft-kempf-srvloc-notify-02.txt

                        Status of This Memo

This document is an Internet-Draft and is in full conformance with
all provisions of Section 10 of RFC2026. Internet-Drafts are work-
ing documents of the Internet Engineering Task Force (IETF), its
areas, and its working groups. Note that other groups may also dis-
tribute working documents as Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six
months and may be updated, replaced, or obsoleted by other documents
at any time. It is inappropriate to use Internet-Drafts as reference
material or to cite them other than as "work in progress."

The list of current Internet-Drafts can be accessed at:

http://www.ietf.org/ietf/1id-abstracts.txt

The list of Internet-Draft Shadow Directories can be accessed at:

http://www.ietf.org/shadow.html.

                               Abstract

The Service Location Protocol provides mechanisms whereby service agent
clients can advertise and user agent clients can query for services.
The design is very much demand-driven, so that user agents only obtain
service information when they specifically ask for it. There exists
another class of user agent applications, however, that requires
notification when a new service appears or disappears and update when
the attributes of the service change. In the RFC 2608 design, these
applications are forced to poll the network to catch changes. In this
document, we describe a protocol for allowing such clients to be
notified when a change occurs, removing the need for polling.

1. Introduction

The Service Location Protocol (SLP)[1] provides a mechanism



Kempf, Goldschmidt         expires June 2000                    [Page 1]

INTERNET DRAFT                                              January 2000


for service agent (SA) clients to advertise network services and for
user agent (UA) clients to find them. The mechanism is demand-driven.
UAs obtain service information by actively querying for it, and do not
obtain any information unless they do so. While this design satisfies
the requirements for most applications, there are some applications
that require more timely information about changes in the services of
interest.

In particular, these applications require notification of the following
events:

        1. Appearance of a new advertisement for a particular kind of
           service.

        2. Disappearance of an advertisement for a particular kind of
           service.

        3. Change in attributes in the advertisement for a particular
           kind of service.

Ideally, these applications would like to be notified when a new service
comes up, when a service disappears or when a service advertisement
times out in a DA, and when an service adds, deletes, or changes the
value of its attributes. In order to obtain this information with SLP
as described in RFC 2608, such applications must poll the network to
periodically refresh their local cache of available service
advertisements.

An example of such a client is a printer that wants to dynamically
advertise a state change in order that administrative applications
can receive up-to-the-minute information about the state of devices
they are administering. Another example is a desktop GUI that wants
to display network service icons as soon as they appear to provide
users with an accurate picture of all services available to them.

Because polling is inefficient and wasteful of network and processor
resources, we would like to provide these applications a mechanism
whereby they can be explicitly notified of changes. In this document,
we describe a scalable mechanism allowing UAs to be notified of changes
in service types of interest.

2. Notation Conventions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in
this document are to be interpreted as described in RFC 2119 [2].

3. Terminology



Kempf, Goldschmidt         expires June 2000                    [Page 2]

INTERNET DRAFT                                              January 2000


In this section, we present some additional terminology beyond
that in [1] and [3].

Notification - A message sent to an interested agent informing that
               agent of a change in state involving another agent.

Subscription - A request to be informed about changes in state for a
               particular service type and scopes.

4. Design Considerations

The primary design consideration in a notification protocol for SLP
is that we would like it to exhibit the same high degree of scalability
and robustness that the base SLP protocol exhibits. Notification should
work in small networks with only a few SAs, as well as large enterprise
networks with thousands of SAs and hundreds of DAs. Small networks
should not be required to deploy DAs in order to receive the benefits
of notification. We also want to assure that notification in large
networks does not cause heavy processing loads to fall on any one
particular SLP agent. This requires that the task of notification be
distributed rather than centralized, to avoid loading down one agent
with doing all the notification work. Finally, we would like the
notification scheme to be robust in the face of DA failures, just as
the base SLP design is.

An important consideration is that the UA clients obtain notifications
of SA events in a timely fashion. If a UA has subscribed to notification
for a particular service type, the UA should receive such notification
regardless of the state of intervening DAs. SLP is transparent
with respect to DAs supporting a particular scope; that is, a UA can
use any DA with a particular scope and expect to get the same service
advertisements. Notifications should exhibit the same property. Whether
or not a UA receives a notification should not depend on the DA to
which they happen to connect. This preserves the DAs' identity as a pure
cache.

Another consideration, related to the scalability goal, is to keep the
granularity of subscription high enough that notification messages
don't become a burden on the network or the individual agents. For
example, we could design the notification mechanism such that a
notification message is sent for a change on a single attribute.
However, this would cause a flood of notification messages when an
SA changed a few attributes.

A related goal is that the notification messages contain enough
information about the triggering event that the UA can determine
whether or not it is of interest in the large majority of cases without
having to issue another SLP request a priori. The UA may, of course,



Kempf, Goldschmidt         expires June 2000                    [Page 3]

INTERNET DRAFT                                              January 2000


issue an SLP request for related reasons, but it should not have to
issue a request to obtain more information on the event that triggered
the notification in most cases. This reduces the amount of network
traffic related to the event.

In order to simplify implementation, we would like to use similar
mechanisms for notification in large and small networks. The mechanisms
are not identical, obviously, but we want to avoid having radically
different mechanisms that require completely separate implementations.
Having similar mechanisms reduces the amount of code in UA and SA
clients.

A minor goal is to make use of existing SLP message types and mechanisms
wherever possible. This reduces the amount of code necessary to
implement the notification mechanism, because much code can be reused
between the base SLP and the notification mechanism. In particular, we
expect to make use of the SLP extension mechanism in certain cases
to support subscription.

An explicit nongoal of the design is to support periodic updates
with a very short time constant, on the order of seconds. Such
updates have proven problematic in earlier, proprietary service
discovery systems, because they tend to generate large amounts of
network traffic. We would like notification to be dynamic but we
expect the periodicity of update to be more than a minute, although
the design incorporates no explicit restrictions. Applications that
require notification at higher frequencies should use an application
specific protocol designed for higher frequency notification.

5. Notification Design Overview

In order to support scalability, we split the design into two parts. A
small network design is used when no DAs are present in the network.
A large network design is used in networks with DAs. The following
subsections describe the two designs.

5.1 Small Network Design

In networks without DAs, UAs are notified by an SA when the SA
initially appears, if any change occurs in attributes, and
when the SA disappears. This allows UAS to know about the
list of service types the SA supports. In small networks, there
is no centralized agent available to administer subscriptions for
newly appearing SAs. This rules out any kind of subscription design
in which a UA subscribes to notifications for a particular service
type in particular scopes of interest, because a newly appearing SA
can't tell whether or not there are any  subscriptions without a
centralizing agent to tell it.



Kempf, Goldschmidt         expires June 2000                    [Page 4]

INTERNET DRAFT                                              January 2000


As a result, SAs perform notification on every state change regardless
of their scope or service type, if they are capable of performing
notification. This means that a UA receives notification of all types
of changes for all scopes and service types, and consequently must be
prepared to filter out those changes in which it is not interested
(other scopes, other service types, or advertisements that are not of
interest because the attributes don't match attributes in which the UA
is interested).

The design requires SAs to perform notification by IP multicasting
(or broadcasting if multicast is not available) one or several SLP
SrvReg or SrvDereg messages describing their state change using the
multicast transmit algorithm described in Section 9.0. The multicast is
performed on the SLP multicast address (239.255.255.253, default TTL
255) and is administratively scoped in the same manner as SLP [4]. The
port number for notifications is not the default SLP port, because that
port is only accessible to privileged users, but rather the port <*to
be assigned by IANA*>. UAs interested in notification join the
multicast group 239.255.255.253 and listen on port <*to be assigned
by IANA*>.

5.2 Large Network Design

In networks with DAs, a DA supporting a particular scope can act as
an intermediary for administering UA subscriptions. A UA interested
in being notified about changes in a particular service type attaches
the Subscribe extension to a SrvRqst message sent to the DA. The DA
obtains multicast group addresses based on the algorithm described
in Section 8.0 and puts them into a NotifyAt extension which it
attaches to the SrvRply. The UA listens on the group addresses in the
reply for notifications.

When a new subscription comes in, the DA compares the service type
and scopes in the new subscription against a list of existing
subscriptions. If no previous subscription was seen having the same
service type and scopes, the DA multicasts DAAdverts using the multi-
cast transmit algorithm described in Section 9.0 including the
NotifyAt extension. A DA MUST keep a list of active subscriptions
in each scope it supports. A subscription consists of a service
type and scope. A DA MUST keep track of subscriptions it has
arranged as well as subscriptions arranged by other DAs in any
scopes with which the DA is configured. If a subscription request
is made which matches an existing request, the DA does not perform
the multicast NotifyAt, but it does inform new SAs having a service
type and scopes corresponding to the subscription by including
the NotifyAt in the the reply to their registrations.

The NotifyAt that is multicast when a subscription has not been



Kempf, Goldschmidt         expires June 2000                    [Page 5]

INTERNET DRAFT                                              January 2000


seen before informs existing SAs that a UA has requested a subscription
to events involving their service type. If the service type and scopes
match a registration when an SA registers with the DA, the NotifyAt
MUST be included in the SrvAck. The SrvAck MUST be included whenever a
SrvReg matching a subscription is received. If the SAs don't support
notification, they simply ignore the extension. The DA itself must also
perform notification, according to the multicast transmit algorithm,
when a service advertisement times out. Time-out of a service
advertisement results in the DA multicasting a SrvDereg for the
deregistered URL.

As in small networks, notification is performed primarily by SAs.
If an SA receives a DAAdvert or SrvAck with a NotifyAt extension
and the following conditions are met:

        1. The SA supports notification.

        2. The SA's service type matches the service type in the
           NotifyAt extension.

        3. The SA's scopes match one of the scopes of the NotifyAt
           extension.

then the SA saves the multicast addresses that correspond to the scopes
and service types it supports. The SA MUST perform notification
immediately after the SA has performed the SrvReg or SrvDereg with the
DA. An SA that has detected a DA in its scopes MUST NOT multicast
any notifications unless it receives a NotifyAt extension
with service type and scopes matching the SAs service type and
scopes.

6. Subscribe Extension

The Subscribe extension has the following format:

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    Extension Type = <TBD>     |        Extension Length       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Ex. Len. (cnt)| Abs. Type Fl. |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

The scope list and service type of the extension are taken from the
accompanying SrvRqst. The abstract type flag indicates whether the
UA is interested in hearing from all SAs advertising concrete
instances of a abstract particular type [3]. If the flag is 1, The
UA is interested in hearing from all SAs advertising concrete types



Kempf, Goldschmidt         expires June 2000                    [Page 6]

INTERNET DRAFT                                              January 2000


having the same abstract type as the type of the SrvRqst. If the
flag is 0, the UA is only interested in hearing from SAs supporting
the particular concrete or simple type in the SrvRqst.

When a DA receives a Subscribe extension for a scopes/service type
that it has not previously seen and the extension is not a
resubscription from an existing subscriber, it determines the multicast
addresses to use based on the algorithm described in Section 8.0.
The multicast addresses are then bundled into a NotifyAt along with
the scopes and service type. The DA also includes a lifetime in the
NotifyAt, informing subscribing UAs and notifying SAs how long the
subscription is active. The lifetime is included to prevent old
subscriptions from hanging around after the UA making the subscription
has exited. The NotifyAt is then multicast as part of a DAAdvert
according to the multicast transmission algorithm, and is included in
the SrvRply to the requesting UA.

If the scopes/service type have previously been seen, the DA does
not perform immediate multicast, but waits until new SAs register,
because all existing SAs have been informed of the subscription
previously.

The DA itself is required to perform notification if a service
advertisement times out. This informs the UA that the service
advertisement is no longer valid.

7. NotifyAt Extension

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    Extension Type = <TBD>     |        Extension Length       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Subscription Lifetime        |    Length of Scope/Group List |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                      Scope/Group List                         \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Length of Service Type Name  |        Service Type Name      \
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

The service type name is in the same format as in the SrvRqst. The
scope/group list is a list of scope names and multicast group
addresses, in IPv4 dotted decimal notation. The following ABNF [5]
syntax describes the list:

        sglist          = sgitem / sgitem "," sglist
        sgitem          = scope-name ":" ipv4-number
        sccope-name     =  ; See RFC 2608 for the format of scope names.



Kempf, Goldschmidt         expires June 2000                    [Page 7]

INTERNET DRAFT                                              January 2000


        ipv4-number     =  1*3DIGIT 3("." 1*3DIGIT)

An example of a scope/group list is:

        eng:239.255.255.42,corp:239.255.255.43

The scope/group list gives the multicast addresses to use for
notifications involving the service type for the given scopes.

The service type name can be a simple type name, an abstract type
name, or a concrete type name. If the name is an abstract type name,
all SAs advertising concrete instances of the abstract type MUST
notify. If the name is a concrete or simple type name, ONLY those SAs
advertising the simple or concrete type MUST notify. A DA that receives
a subscription with the abstract type flag set, MUST include the
abstract type name in all the NotifyAt messages it sends. If
the DA receives a subscription with the abstract type flag not set,
the DA MUST NOT include the abstract type, but rather must include
the concrete type name. If the type name in the SrvRqst is a simple
type, then the abstract type flag in the Subscribe extension MUST
be ignored.

There are three cases in which an agent may receive a NotifyAt
extension: in a SrvRply returned to a UA, in a multicast DAAdvert, and
in a SrvAck returned to an SA. The three subsections below describe
the response in each of these cases.

7.1 NotifyAt received with SrvRply

When a UA sends a SrvRqst with a Subscribe extension, the DA responds
with a SrvRply including a NotifyAt. The DA MUST NOT unicast a
NotifyAt to a UA with any other message and MUST NOT send a
NotifyAt unless a SrvRqst with a Subscribe extension was received.

The UA responds by setting up a multicast listener to the group
addresses included in the extension on the SLP notification port
<*to be assigned by IANA*>. The UA MAY also want to note the expiration
lifetime of the subscription assigned by the DA, and reissue a
subscription before the lifetime expires.

7.2 NotifyAt received with multicast DAAdvert

The DA multicasts a NotifyAt with a DAAdvert using the multicast
transmit algorithm when a UA has requested notification and the scopes
and service type in the subscription were not previously seen. This
message informs existing SAs having the service type and scopes in the
announcement that they should multicast notifications upon state
changes.



Kempf, Goldschmidt         expires June 2000                    [Page 8]

INTERNET DRAFT                                              January 2000


A receiving SA participating in notification responds by noting the
multicast address if the service type and scopes match. When a
state change (change in attributes, deregistration) occurs, the SA MUST
first inform all its DAs of the change, then it MUST multicast the same
message sent to the DAs according to the multicast transmit algorithm.
The SA MUST cease performing notification when the lifetime expires,
unless a subsequent NotifyAt is received prolonging the subscription.

A UA that is performing passive DA detection will naturally also receive
the extension, but the UA SHOULD ignore the extension.

7.3 NotifyAt received with SrvAck

An SA can receive a NotifyAt with a SrvAck when it first comes up
and registers itself with a DA. If the DA has any subscriptions from
UAs for the service type and scopes represented by the SA, it MUST
return a NotifyAt with the SrvAck.

The SA upon receiving the NotifyAt takes exactly the same actions as
when it receives a NotifyAt along with a multicast DAAdvert.
Additionally, it MUST immediately perform a multicast notification of
its SrvReg if the scopes and service type of the NotifyAt
apply.

8. Multicast Address Allocation

Enterprise networks that allow SLP notification SHOULD deploy the
Multicast Address Allocation Architecture (MAAA) including
administratively scoped multicast and Multicast Address Dynamic
Client AllocationProtocol (MADCAP) [6].

If it is not possible to obtain a multicast address for use in
SLP notifications, the SLP multicast address is used.

If the MAAA infrastructure is deployed, DAs and SAs obtain their scope
configuration from MADCAP, because the SLP scopes are the same as the
MADCAP scopes. Each SLP scope MUST correspond to a multicast scope name,
in the sense of [6]. In such a case, a DA allocates, using MADCAP, a
new group for each new service type/scope pair to which a UA
subscribes. The allocation is made by MADCAP from the multicast address
range for the scope. In this way, only those UAs interested in the
service type and scopes in the subscription receive the multicast
notification. The DA sets up the lease on the multicast address to
correspond with the duration of the subscription. If the MADCAP server
runs out of addresses, the SLP multicast group is used as a last resort.

For example, if the scope has an address range of 239.1.0.0 through
239.1.255.255, the notification group address for service type X in



Kempf, Goldschmidt         expires June 2000                    [Page 9]

INTERNET DRAFT                                              January 2000


scope A is 239.1.0.42 and for service type Y in scope B is 239.1.42.42.

9. Multicast Transmit Algorithm

The DA and SAs use a multicast transmit algorithm similar to that used
for discovering services in SLP, described in RFC 2608 [1], except
the agent performing the notification doesn't wait for replies.
The agent performing the notification transmits a notification message
once, or at most, a very few times, backing off exponentially in time.
Subsequent multicasts of notification have very small TTLs. The TTL on
each retransmission is divided by the corresponding number in the
sequence 16, 8, 2, so that the sequence of TTLs is 255, 16, 2, 1 with
4 messages.

A notification message is either a SrvReg or a SrvDereg message,
depending on whether the SA is registering a new service or adding
attributes to an existing service, or deregistering a service or
deleting attributes from an existing service. When a new service is
registered, the notification message MUST have the fresh bit set in the
SLP header of the multicast SrvReg message, and not set if the
notification is for an update. In either case, the entire list of
attributes for the service SHOULD be included. The SA MUST refrain from
transmitting a notification when refreshing a registration due to a
time out. Notifications for refreshes are unnecessary because UAs
typically track advertisement time outs, and can perform an active
query when one is detected.

Since SrvReg and SrvDereg could contain attribute lists of arbitrary
length, the message could potentially overflow the packet MTU for UDP.
If an attribute list causes a packet MTU overflow, the transmitting
agent MUST set the overflow bit in the SLP header. The attribute list
in the notification message MUST be formatted so that a UA can use the
attributes even if an overflow occurs. If a UA needs more attributes
than are transmitted in the notification message, it can contact the
SA (if no DA is present) or the DA for the attributes it needs.

A DA also multicasts a DAAdvert when a subscription comes in for
containing a service type and scopes that do not match any on the
DA's list of known subscriptions. The same algorithm should be
used. If the combination of the DA attributes and the NotifyAt
message cause the DAAdvert to overflow a UDP packet, DA attributes
MUST be truncated to allow the NotifyAt to fit and the overflow
bit must be set in the header. Multiple DAAdvert messages MUST NOT be
multicast. An SA knows that the purpose of the message is to inform it
of a new subscription rather than for passive advertisement, because
of the extension, and it can therefore ignore the DA attribute list
field if the overflow bit is set in the header. A DA also transmits a
SrvDereg message when a service advertisement is deregistered due to



Kempf, Goldschmidt         expires June 2000                   [Page 10]

INTERNET DRAFT                                              January 2000


timeout.

10.0 DA Disappearance

Robustness to DA failure is an important goal of the design.
When a DA disappears due to unforeseen circumstances, subscription
information from UAs is lost. UAs continue to get notifications from
existing SAs. However, new SAs will not be informed of the subscription
unless other DAs also have the subscription information. Because a UA
may not discover a new DA until it tries to perform an active request,
the UA could potentially miss the appearence of new services. For this
reason, UAs that are concerned about receiving notification of
absolutely every service that appears SHOULD issue subscriptions to
every newly discovered DA that supports the scopes it supports.
Similarly, if a DA disappears through a controlled shutdown, a UA
performing passive discovery can detect the shutdown and reissue
the subscriptions to an alternate DA. To avoid multiple multicast
NotifyAt messages, a DA MUST wait a random amount of time, uniformly
distributed between 0 and 3 seconds before they send the multicast
DAAdvert with NotifyAt. During this period, the DA MUST listen
for NotifyAt messges that match the one from the new subscription.
If a matching NotifyAt is detected, the DA MUST not multicast.

On the SA side, when a DA goes down, existing SAs continue to notify
until the subscription expires. Before ceasing to notify, an SA MUST
determine that the DA is still active and, if not, verify with another
DA whether the subscription has been extended. If no other DA is
available, the SA MUST ignore the subscription expiration time and
continue notifying until a new DA is discovered. When a new DA
is discovered the SA must send a new SrvReg to the DA, according
to RFC 2608 [1]. The replying SrvAck contains a NotifyAt extension
if the UA has renewed its subscription with the DA. If the SrvAck does
not contain a NotifyAt message the SA MUST continue to notify until the
subscription expires. If a UA is interested in continuing the
notification, it renews the subscription prior to the expiration
of the old one, and so the SA is informed to continue notifying.

Note that this procedure still leaves new SAs that come up before
the UA has renewed the old subscription with the newly booted DA
uninformed about UA subscriptions. If this situation is of concern,
multiple DAs can be used to assure that all subscriptions are covered
when a DA goes down.

11. Network Administration Considerations

In SLP networks with DAs as described in RFC 2608, the only multicast
is the SrvRqst for DAAdverts performed during active DA discovery, and
unsolicited DAAdverts sent periodically by the DA for passive



Kempf, Goldschmidt         expires June 2000                   [Page 11]

INTERNET DRAFT                                              January 2000


discovery. There is no multicast involved in UA queries or SA
registrations. This allows network administrators to set up DAs for a
particular collection of IP subnets and confine all service discovery
traffic to unicast between the SA and UA clients and the DA.
Administratively scoped multicast can additionally be used to limit
the extent of active DA discovery and passive DA advertising. The
amount of multicast involved is not high and DHCP DA and scope
configuration can be used to limit which the DAs a particular UA or SA
client sees, or to inhibit multicast entirely so that UAs and SAs only
use configured DAs.

With notification, however, multicast traffic involving events in SAs
becomes available. Because DAs request multicast addresses based on
scope and service type, the multicast associated with particular events
should only propagate to those subnets in which UAs and SAs of the same
scope are interacting. Routers should be configured with administrative
multicast scoping to limit multicast. If DAs are not deployed (or the
MAAA is not deployed), however, the amount of multicast on the SLP
multicast address when notifications are being used could quickly
become very large. Therefore, it is crucial that DAs supporting
notification be deployed in large networks where UA clients are
interested in notification.

12. Security Considerations

The SrvReg and SrvDereg messages contain authentication blocks for
all SLP SPIs supported by the DAs with which the SA registers. Since
these SPIs are necessarily the same as those that UAs can verify,
a UA receiving a multicast notification is in a position to verify
the notification. It does so by selecting the authentication block
or blocks that it can verify. If authentication fails, either due
to lack of an authentication block, or lack of the proper SPI, the
UA simply discards the notification. In a network without DAs,
the SPIs of the UA and SA must also match.

13. Acknowledgements

The authors would like to thank Charles Perkins, of Nokia, and
Erik Guttman and Jonathan Wood, of Sun Microsystems, for their
stimulating discussion and suggestions during the initial phases
of the subscription/notification design. We would also like to
thank Erik for his intense scrutiny of the specification during
the later phases. His comments were instrumental in refining the
design.

14. References

[1] E. Guttman, C. Perkins, J. Veizades, and M. Day.



Kempf, Goldschmidt         expires June 2000                   [Page 12]

INTERNET DRAFT                                              January 2000


Service Location Protocol.
RFC 2608, July 1999.

[2] S. Bradner.
Key Words for Use in RFCs to Indicate Requirement Levels.
RFC 2119, March 1997.

[3] E. Guttman, C. Perkins, J. Kempf
Service Templates and service:  Schemes.
RFC 2609, July 1999.

[4] D. Meyer.
Administratively Scoped IP Multicast.
RFC 2365, July 1998.

[5] D. Crocker and P. Overell.
Augmented BNF for Syntax Specifications: ABNF.
RFC 2234, November 1997.

[6] Hanna, S., B. Patel, M. Shah
Multicast Address Dynamic Client Allocation Protocol (MADCAP).
draft-ietf-malloc-madcap-XX.txt, A work in progress.

[7] http://www.iana.org/in-notes/iana/assignments/multicast-addresses

15. Full Copyright Statement}

Copyright (C) The Internet Society (1997).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an
"AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING



Kempf, Goldschmidt         expires June 2000                   [Page 13]

INTERNET DRAFT                                              January 2000


TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE."

16. Author's Addresses

             James Kempf               Jason Goldschmidt
             Sun Microsystems          C0318 Bucknell University
             UMPK15-214                Lewisburg, PA, 17837
             901 San Antonio Rd.       USA
             Palo Alto, CA 94040
             USA

   Phone:    +1 650 786 5890           +1 570 577 5624
   Email:    james.kempf@sun.com       jgoldsch@acm.org



































Kempf, Goldschmidt         expires June 2000                   [Page 14]

