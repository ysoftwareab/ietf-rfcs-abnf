pii = (
                               age: int,
                               name: tstr,
                               employer: tstr,
person = {(
                               age: int,
                               name: tstr,
                               employer: tstr,
person = {
                                  pii
person = {
                               age: int,
                               name: tstr,
                               employer: tstr,
person = {
                            age: int,
                            name: tstr,
                            employer: tstr,
dog = {
                            age: int,
                            name: tstr,
                            leash-length: float,
person = {
                            identity,
                            employer: tstr,
dog = {
                            identity,
                            leash-length: float,
identity = (
                            age: int,
                            name: tstr,
attire = "bow tie" / "necktie" / "Internet attire"
protocol = 6 / 17

address = { delivery }

delivery = (
city = (
device-address = byte
max-byte = 255
byte = 0..max-byte ; inclusive range
first-non-byte = 256
byte1 = 0...first-non-byte ; byte1 is equivalent to byte

terminal-color = &basecolors
basecolors = (
                black: 0, red: 1,  green: 2,  yellow: 3,
                blue: 4,  magenta: 5,  cyan: 6,  white: 7,
extended-color = &(
                basecolors,
                orange: 8,  pink: 9,  purple: 10,  brown: 11,
my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!
breakfast = cereal / porridge
cereal = #6.998(tstr)
porridge = #6.999([liquid, solid])
liquid = milk / water
milk = 0
water = 1
solid = tstr

person = { g }

g = (
                      "name": tstr,
                      age: int,  ; "age" is a bareword
apartment = {
     kitchen: size,
     * bedroom: size,
size = float ; in m2

unlimited-people = [* person]
one-or-two-people = [1*2 person]
at-least-two-people = [2* person]
person = (
                         name: tstr,
                         age: uint,
Geography = [
           city           : tstr,
           gpsCoordinates : GpsCoordinates,
GpsCoordinates = {
           longitude      : uint,            ; multiplied by 10^7
           latitude       : uint,            ; multiplied by 10^7
located-samples = {
                             sample-point: int,
                             samples: [+ float],
located-samples = {
                           "sample-point" => int,
                           "samples" => [+ float],
located-samples = {
               sample-point: int,
               samples: [+ float],
               * equipment-type => equipment-tolerances,
equipment-type = [name: tstr, manufacturer: tstr]
equipment-tolerances = [+ [float, float]]

PersonalData = {
                            ? displayName: tstr,
                            NameComponents,
                            ? age: uint,
NameComponents = (
                            ? firstName: tstr,
                            ? familyName: tstr,
PersonalData = {
                            ? displayName: tstr,
                            NameComponents,
                            ? age: uint,
                            * tstr => any
NameComponents = (
                            ? firstName: tstr,
                            ? familyName: tstr,
square-roots = {* x => y}
x = int
y = float

tostring = {* mynumber => tstr}
mynumber = int / float

biguint = #6.2(bstr)

buuid = #6.37(bstr)

my_uri = #6.32(tstr) / tstr

full-address = [[+ label], ip4, ip6]
ip4 = bstr .size 4
ip6 = bstr .size 16
label = bstr .size (1..63)

audio_sample = uint .size 3 ; 24-bit, equivalent to 0..16777215

              Figure 7: Annotation for integer size in bytes

tcpflagbytes = bstr .bits flags
flags = &(
                        fin: 8,
                        syn: 9,
                        rst: 10,
                        psh: 11,
                        ack: 12,
                        urg: 13,
                        ece: 14,
                        cwr: 15,
                        ns: 0,
rwxbits = uint .bits rwx
rwx = &(r: 2, w: 1, x: 0)

nai = tstr .regexp "\\w+@\\w+(\\.\\w+)+"

                  Figure 9: Annotation with a PCRE regexp

message = $message .within message-structure
message-structure = [message_type, *message_option]
message_type = 0..255
message_option = any

speed = number .ge 0  ; unit: m/s

timer = {
     time: uint,
     ? displayed-step: (number .gt 0) .default 1
tcp-header = {seq: uint, ack: uint, * $$tcp-option}

PersonalData = {
                       ? displayName: tstr,
                       NameComponents,
                       ? age: uint,
                       * $$personaldata-extensions
NameComponents = (
                       ? firstName: tstr,
                       ? familyName: tstr,
t = [group1]
group1 = (a / b // c / d)
a = 1 b = 2 c = 3 d = 4

t = {group2}
group2 = (? ab: a / b // cd: c / d)
a = 1 b = 2 c = 3 d = 4

t = [group3]
group3 = (+ a / b / c)
a = 1 b = 2 c = 3

t = [group4]
group4 = (+ a // b / c)
a = 1 b = 2 c = 3

t = [group4a]
group4a = ((+ a) // (b / c))
a = 1 b = 2 c = 3

fruitlist = [* Fruit]

Fruit = {
      name                 : tstr,
      colour               : [* color],
      avg_weight           : float16,
      price                : uint,
      international_names  : International,
      rfu                  : bstr,           ; reserved for future use
International = {
      "DE"                 : tstr,           ; German
      "EN"                 : tstr,           ; English
      "FR"                 : tstr,           ; French
      "NL"                 : tstr,           ; Dutch
      "ZH-HANS"            : tstr,           ; Chinese
color = &(
      black: 0, red: 1,  green: 2,  yellow: 3,
      blue: 4,  magenta: 5,  cyan: 6,  white: 7,
reputation-object = {
                   reputation-context,
                   reputon-list
reputation-context = (
                   application: text
reputon-list = (
                   reputons: reputon-array
reputon-array = [* reputon]

reputon = {
                   rater-value,
                   assertion-value,
                   rated-value,
                   rating-value,
                   ? conf-value,
                   ? normal-value,
                   ? sample-value,
                   ? gen-value,
                   ? expire-value,
                   * ext-value,
rater-value = ( rater: text )
assertion-value = ( assertion: text )
rated-value = ( rated: text )
rating-value = ( rating: float16 )
conf-value = ( confidence: float16 )
normal-value = ( normal-rating: float16 )
sample-value = ( sample-size: uint )
gen-value = ( generated: uint )
expire-value = ( expires: uint )
ext-value = ( text => any )

reputation-object = {
                          application: text
                          reputons: [* reputon]
reputon = {
                          rater: text
                          assertion: text
                          rated: text
                          rating: float16
                          ? confidence: float16
                          ? normal-rating: float16
                          ? sample-size: uint
                          ? generated: uint
                          ? expires: uint
                          * text => any
root = [2*2 {
                              precision: text,
                              Latitude: float,
                              Longitude: float,
                              Address: text,
                              City: text,
                              State: text,
                              Zip: text,
                              Country: text
root = { image }

image = (
                               Image: {
                                 size,
                                 Title: text,
                                 thumbnail,
                                 IDs: [* int]
                               }
size = (
                               Width: 0..1280
                               Height: 0..1024
thumbnail = (
                               Thumbnail: {
                                 size,
                                 Url: uri
                               }
root = {
                      Image: {
                        size, Title: text,
                        Thumbnail: { size, Url: uri },
                        IDs: [* int]
                      }
size = (
                      Width: 0..1280,
                      Height: 0..1024,
messages = message<"reboot", "now"> / message<"sleep", 1..100>
parameter = argument).

cddl = S 1*rule
rule = typename [genericparm] S assign S type S
        / groupname [genericparm] S assign S grpent S

typename = id
groupname = id

assign = "=" / "/=" / "//="

genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"

type = type1 S *("/" S type1 S)

type1 = type2 [S (rangeop / annotator) S type2]
        / "#" "6" ["." uint] "(" S type S ")" ; note no space!
        / "#" DIGIT ["." uint]                ; major/ai
        / "#"                                 ; any
        / "{" S group S "}"
        / "[" S group S "]"
        / "&" S "(" S group S ")"
        / "&" S groupname [genericarg]

type2 = value
         / typename [genericarg]
         / "(" type ")"

rangeop = "..." / ".."

annotator = "." id

group = grpchoice S *("//" S grpchoice S)

grpchoice = *grpent
grpent = [occur S] [memberkey S] type optcom
          / [occur S] groupname [genericarg] optcom ; preempted by above
          / [occur S] "(" S group S ")" optcom

memberkey = type1 S "=>"
             / bareword S ":"
             / value S ":"

bareword = id

optcom = S ["," S]

occur = [uint] "*" [uint]
         / "+"
         / "?"

uint = ["0x" / "0b"] "0"
        / ["0x" / "0b"] DIGIT1 *DIGIT

value = number
         / text
         / bytes

int = ["-"] uint

number = int ["." fraction] ["e" exponent ]
fraction = 1*DIGIT
exponent = int

text = %x22 *SCHAR %x22
SCHAR = %x20-21 / %x23-7E / SESC
SESC = "\" %x20-7E

bytes = [bsqual] %x27 *BCHAR %x27
BCHAR = %x20-26 / %x28-7E / SESC / CRLF
bsqual = %x68 ; "h"
          / %x62.36.34 ; "b64"

id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
ALPHA = %x41-5A / %x61-7A
EALPHA = %x41-5A / %x61-7A / "@" / "_" / "$"
DIGIT = %x30-39
DIGIT1 = %x31-39
S = *WS
WS = SP / NL
SP = %x20
NL = COMMENT / CRLF
COMMENT = ";" *(SP / VCHAR) CRLF
VCHAR = %x21-7E
CRLF = %x0A / %x0D.0A


                           Figure 13: CDDL ABNF

any = #

uint = #0
nint = #1
int = uint / nint

bstr = #2
bytes = bstr
tstr = #3
text = tstr

tdate = #6.0(tstr)
time = #6.1(number)
number = int / float
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
decfrac = #6.4([e10: int, m: integer])
bigfloat = #6.5([e2: int, m: integer])
eb64url = #6.21(any)
eb64legacy = #6.22(any)
eb16 = #6.23(any)
encoded-cbor = #6.24(bstr)
uri = #6.32(tstr)
b64url = #6.33(tstr)
b64legacy = #6.34(tstr)
regexp = #6.35(tstr)
mime-message = #6.36(tstr)
cbor-any = #6.55799(any)

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil
undefined = #7.23


                          Figure 14: CDDL Prelude
