R = Maximum Sustained Traffic Rate (bps)

P = Peak Traffic Rate (bps)

B = Maximum Traffic Burst (bytes)

drop_prob_ = 0;
qdelay_old_ = 0;
burst_reset_ = 0;
aqm_state_ = INACTIVE;
qdelay = queue_.byte_length() / PEAK_RATE;
qdelay = ((queue_.byte_length() - msrtokens()) / MSR \
                     +  msrtokens() / PEAK_RATE);
drop_prob_ = 0;
burst_allowance_ = max(0, burst_allowance_ - INTERVAL);
p = A * (qdelay - LATENCY_TARGET) + \
               B * (qdelay - qdelay_old_);
p = 0.02;
drop_prob_ = max(0, drop_prob_);
drop_prob_ = min(drop_prob_, \
                        PROB_LOW * MEAN_PKTSIZE/MIN_PKTSIZE);
quiet = (qdelay < 0.5 * LATENCY_TARGET)
               && (qdelay_old_ < 0.5 * LATENCY_TARGET)
               && (drop_prob_ == 0)
               && (burst_allowance_ == 0);

aqm_state_ = QUIESCENT;
burst_reset_ = 0;
burst_reset_ = 0;
aqm_state_ = INACTIVE;
burst_reset_ = 0;
qdelay_old_ = qdelay;

accu_prob_ = 0;
accu_prob_ = 0;
aqm_state_ = QUIESCENT;
p1 = drop_prob_ * packet.size() / MEAN_PKTSIZE;
p1 = min(p1, PROB_LOW);

drop = TRUE;                      // too slowly
drop = TRUE;
accu_prob_ = 0;

aqm_state_ = ACTIVE;
burst_allowance_ = MAX_BURST;
