<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>REsource LOcation And Discovery (RELOAD)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="REsource LOcation And Discovery (RELOAD)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">P2PSIP</td><td class="header">C. Jennings</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco</td></tr>
<tr><td class="header">Intended status:  Standards Track</td><td class="header">B. Lowekamp</td></tr>
<tr><td class="header">Expires:  January 16, 2009</td><td class="header">SIPeerior Technologies</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">E. Rescorla</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Network Resonance</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">S. Baset</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">H. Schulzrinne</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Columbia University</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 15, 2008</td></tr>
</table></td></tr></table>
<h1><br />REsource LOcation And Discovery (RELOAD)<br />draft-ietf-p2psip-reload-00</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 16, 2009.</p>

<h3>Abstract</h3>

<p>This document defines REsource LOcation And Discovery (RELOAD), a
      peer-to-peer (P2P) signaling protocol for use on the Internet. A P2P
      signaling protocol provides its clients with an abstract storage and
      messaging service between a set of cooperating peers that form the
      overlay network. RELOAD is designed to support a P2P Session Initiation
      Protocol (P2PSIP) network, but can be utilized by other applications
      with similar requirements by defining new usages that specify the kinds
      of data that must be stored for a particular application. RELOAD defines
      a security model based on a certificate enrollment service that provides
      unique identities. NAT traversal is a fundamental service of the
      protocol. RELOAD also allows access from "client" nodes which do not
      need to route traffic or store data for others.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Basic Setting<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Architecture<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.2.1.</a>&nbsp;
Usage Layer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.2.2.</a>&nbsp;
Routing Layer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.2.3.</a>&nbsp;
Storage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">1.2.4.</a>&nbsp;
Topology Plugin<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">1.2.5.</a>&nbsp;
Forwarding Layer<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">1.3.</a>&nbsp;
SIP Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">1.4.</a>&nbsp;
Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">1.5.</a>&nbsp;
Structure of This Document<br />
<a href="#anchor12">2.</a>&nbsp;
Terminology<br />
<a href="#anchor13">3.</a>&nbsp;
Overlay Management Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.overview.security">3.1.</a>&nbsp;
Security and Identification<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-shared-key">3.1.1.</a>&nbsp;
Shared-Key Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.2.</a>&nbsp;
Clients<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.2.1.</a>&nbsp;
Client Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.2.2.</a>&nbsp;
Client Behavior<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.2.2.1.</a>&nbsp;
Why Not Only Peers?<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.2.2.2.</a>&nbsp;
Minimum Functionality Requirements for Clients<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">3.2.2.3.</a>&nbsp;
Clients as Application-Level Agents<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">3.3.</a>&nbsp;
Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">3.3.1.</a>&nbsp;
Routing Alternatives<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">3.3.1.1.</a>&nbsp;
Iterative vs Recursive<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">3.3.1.2.</a>&nbsp;
Symmetric vs Forward response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">3.3.1.3.</a>&nbsp;
Direct Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">3.3.1.4.</a>&nbsp;
Relay Peers<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">3.3.1.5.</a>&nbsp;
Symmetric Route Stability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">3.4.</a>&nbsp;
Connectivity Management<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">3.5.</a>&nbsp;
Overlay Algorithm Support<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">3.5.1.</a>&nbsp;
Support for Pluggable Overlay Algorithms<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-join-leave-maint">3.5.2.</a>&nbsp;
Joining, Leaving, and Maintenance Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">3.6.</a>&nbsp;
First-Time Setup<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">3.6.1.</a>&nbsp;
Initial Configuration<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">3.6.2.</a>&nbsp;
Enrollment<br />
<a href="#anchor33">4.</a>&nbsp;
Application Support Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">4.1.</a>&nbsp;
Data Storage<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">4.1.1.</a>&nbsp;
Storage Permissions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-usages">4.1.2.</a>&nbsp;
Usages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">4.1.3.</a>&nbsp;
Replication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">4.2.</a>&nbsp;
Service Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">4.3.</a>&nbsp;
Application Connectivity<br />
<a href="#anchor39">5.</a>&nbsp;
P2PSIP Integration Overview<br />
<a href="#anchor40">6.</a>&nbsp;
Overlay Management Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">6.1.</a>&nbsp;
Message Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-request-origination">6.1.1.</a>&nbsp;
Request Origination<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-message-forwarding">6.1.2.</a>&nbsp;
Message Receipt and Forwarding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-responsible-id">6.1.2.1.</a>&nbsp;
Responsible ID<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-other-id">6.1.2.2.</a>&nbsp;
Other ID<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-private-Node-ID">6.1.2.3.</a>&nbsp;
Private ID<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-response-origination">6.1.3.</a>&nbsp;
Response Origination<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">6.2.</a>&nbsp;
Message Structure<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-presentation-language">6.2.1.</a>&nbsp;
Presentation Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-definitions">6.2.1.1.</a>&nbsp;
Common Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-forwarding-header">6.2.2.</a>&nbsp;
Forwarding Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">6.2.2.1.</a>&nbsp;
Destination and Via Lists<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-route-log">6.2.2.2.</a>&nbsp;
Route Logging<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-forwarding-options">6.2.2.3.</a>&nbsp;
Forwarding Options<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-contents">6.2.3.</a>&nbsp;
Message Contents Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-response-code">6.2.3.1.</a>&nbsp;
Response Codes and Response Errors<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-signature">6.2.4.</a>&nbsp;
Signature<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-overlay-topology">6.3.</a>&nbsp;
Overlay Topology<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">6.3.1.</a>&nbsp;
Topology Plugin Requirements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">6.3.2.</a>&nbsp;
Methods and types for use by topology plugins<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">6.3.2.1.</a>&nbsp;
Join<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">6.3.2.2.</a>&nbsp;
Leave<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">6.3.2.3.</a>&nbsp;
Update<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-route-query">6.3.2.4.</a>&nbsp;
Route_Query<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">6.4.</a>&nbsp;
Forwarding Layer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">6.4.1.</a>&nbsp;
Transports<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">6.4.1.1.</a>&nbsp;
Future Support for HIP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-reliability">6.4.1.2.</a>&nbsp;
Reliability for Unreliable Transports<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-frag-reass">6.4.1.3.</a>&nbsp;
Fragmentation and Reassembly<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor56">6.4.2.</a>&nbsp;
Connection Management Methods<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-connect-details">6.4.2.1.</a>&nbsp;
Attach<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor66">6.4.2.2.</a>&nbsp;
Ping<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-tunnel-details">6.4.2.3.</a>&nbsp;
Tunnel<br />
<a href="#anchor69">7.</a>&nbsp;
Data Storage Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-data-sig">7.1.</a>&nbsp;
Data Signature Computation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-kind-model">7.2.</a>&nbsp;
Data Models<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor70">7.2.1.</a>&nbsp;
Single Value<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor71">7.2.2.</a>&nbsp;
Array<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor72">7.2.3.</a>&nbsp;
Dictionary<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor73">7.3.</a>&nbsp;
Data Storage Methods<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-store">7.3.1.</a>&nbsp;
Store<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-store-req">7.3.1.1.</a>&nbsp;
Request Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor74">7.3.1.2.</a>&nbsp;
Response Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor75">7.3.2.</a>&nbsp;
Fetch<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor76">7.3.2.1.</a>&nbsp;
Request Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor77">7.3.2.2.</a>&nbsp;
Response Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor78">7.3.3.</a>&nbsp;
Remove<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor79">7.3.3.1.</a>&nbsp;
Single Value<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor80">7.3.3.2.</a>&nbsp;
Array<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor81">7.3.3.3.</a>&nbsp;
Dictionary<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor82">7.3.3.4.</a>&nbsp;
Response Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor83">7.3.4.</a>&nbsp;
Find<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor84">7.3.4.1.</a>&nbsp;
Request Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor85">7.3.4.2.</a>&nbsp;
Response Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor86">7.3.4.3.</a>&nbsp;
Defining New Kinds<br />
<a href="#sec-store-usage">8.</a>&nbsp;
Certificate Store Usage<br />
<a href="#sec-turn-server">9.</a>&nbsp;
TURN Server Usage<br />
<a href="#anchor87">10.</a>&nbsp;
SIP Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor88">10.1.</a>&nbsp;
Registering AORs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor89">10.2.</a>&nbsp;
Looking up an AOR<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor90">10.3.</a>&nbsp;
Forming a Direct Connection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-gruus">10.4.</a>&nbsp;
GRUUs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec.sip-reg-kind">10.5.</a>&nbsp;
SIP-REGISTRATION Kind Definition<br />
<a href="#anchor91">11.</a>&nbsp;
Diagnostic Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor92">11.1.</a>&nbsp;
Diagnostic Metrics for a P2PSIP Deployment<br />
<a href="#sec.chord-algorithm">12.</a>&nbsp;
Chord Algorithm <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor93">12.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor94">12.2.</a>&nbsp;
Routing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor95">12.3.</a>&nbsp;
Redundancy <br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor96">12.4.</a>&nbsp;
Joining<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor97">12.5.</a>&nbsp;
Routing Attaches<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor98">12.6.</a>&nbsp;
Updates<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor99">12.6.1.</a>&nbsp;
Sending Updates<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor100">12.6.2.</a>&nbsp;
Receiving Updates<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor101">12.6.3.</a>&nbsp;
Stabilization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor102">12.7.</a>&nbsp;
Route Query<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor103">12.8.</a>&nbsp;
Leaving<br />
<a href="#secEnrollment">13.</a>&nbsp;
Enrollment and Bootstrap<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-discovery">13.1.</a>&nbsp;
Discovery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-configuration">13.2.</a>&nbsp;
Overlay Configuration<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-credentials">13.3.</a>&nbsp;
Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor104">13.3.1.</a>&nbsp;
Self-Generated Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor105">13.4.</a>&nbsp;
Joining the Overlay Peer<br />
<a href="#anchor106">14.</a>&nbsp;
Message Flow Example<br />
<a href="#anchor107">15.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor108">15.1.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor109">15.2.</a>&nbsp;
Attacks on P2P Overlays<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor110">15.3.</a>&nbsp;
Certificate-based Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor111">15.4.</a>&nbsp;
Shared-Secret Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor112">15.5.</a>&nbsp;
Storage Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor113">15.5.1.</a>&nbsp;
Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor114">15.5.2.</a>&nbsp;
Distributed Quota<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor115">15.5.3.</a>&nbsp;
Correctness<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor116">15.5.4.</a>&nbsp;
Residual Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor117">15.6.</a>&nbsp;
Routing Security<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor118">15.6.1.</a>&nbsp;
Background<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor119">15.6.2.</a>&nbsp;
Admissions Control<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor120">15.6.3.</a>&nbsp;
Peer Identification and Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor121">15.6.4.</a>&nbsp;
Protecting the Signaling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor122">15.6.5.</a>&nbsp;
Residual Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.sip-issues">15.7.</a>&nbsp;
SIP-Specific Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor123">15.7.1.</a>&nbsp;
Fork Explosion<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-security-malicious-retargeting">15.7.2.</a>&nbsp;
Malicious Retargeting<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor124">15.7.3.</a>&nbsp;
Privacy Issues<br />
<a href="#anchor125">16.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor126">16.1.</a>&nbsp;
Overlay Algorithm Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor127">16.2.</a>&nbsp;
Data Kind-Id<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor128">16.3.</a>&nbsp;
Data Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor129">16.4.</a>&nbsp;
Message Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor130">16.5.</a>&nbsp;
Error Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor131">16.6.</a>&nbsp;
Route Log Extension Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor132">16.7.</a>&nbsp;
Transport Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor133">16.8.</a>&nbsp;
Forwarding Options<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor134">16.9.</a>&nbsp;
Ping Information Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-reload-uri">16.10.</a>&nbsp;
reload: URI Scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor135">16.10.1.</a>&nbsp;
URI Registration<br />
<a href="#anchor136">17.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">18.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">18.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">18.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document defines REsource LOcation And Discovery (RELOAD), a
      peer-to-peer (P2P) signaling protocol for use on the Internet. It
      provides a generic, self-organizing overlay network service, allowing
      nodes to efficiently route messages to other nodes and to efficiently
      store and retrieve data in the overlay. RELOAD provides several features
      that are critical for a successful P2P protocol for the Internet:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Security Framework:</dt>
<dd>A P2P network will often be
          established among a set of peers that do not trust each other.
          RELOAD leverages a central enrollment server to provide credentials
          for each peer which can then be used to authenticate each operation.
          This greatly reduces the possible attack surface.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Usage Model:</dt>
<dd>RELOAD is designed to support a variety
          of applications, including P2P multimedia communications with the
          Session Initiation Protocol <a class='info' href='#I-D.ietf-p2psip-concepts'>[I&#8209;D.ietf&#8209;p2psip&#8209;concepts]<span> (</span><span class='info'>Bryan, D., &ldquo;Concepts and Terminology for Peer to Peer SIP,&rdquo; July&nbsp;2007.</span><span>)</span></a>. RELOAD allows the
          definition of new application usages, each of which can define its
          own data types, along with the rules for their use. This allows
          RELOAD to be used with new applications through a simple
          documentation process that supplies the details for each
          application.
</dd>
<dt></dt>
<dd>
</dd>
<dt>NAT Traversal:</dt>
<dd>RELOAD is designed to function in
          environments where many if not most of the nodes are behind NATs or
          firewalls. Operations for NAT traversal are part of the base design,
          including using ICE to establish new RELOAD or application protocol
          connections as well as tunneling application protocols across the
          overlay.
</dd>
<dt></dt>
<dd>
</dd>
<dt>High Performance Routing:</dt>
<dd>The very nature of overlay
          algorithms introduces a requirement that peers participating in the
          P2P network route requests on behalf of other peers in the network.
          This introduces a load on those other peers, in the form of
          bandwidth and processing power. RELOAD has been defined with a
          simple, lightweight forwarding header, thus minimizing the amount of
          effort required by intermediate peers.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Pluggable overlay Algorithms:</dt>
<dd>RELOAD has been designed
          with an abstract interface to the overlay layer to simplify
          implementing a variety of structured (DHT) and unstructured overlay
          algorithms. This specification also defines how RELOAD is used with
          Chord, which is mandatory to implement. Specifying a default "must
          implement" overlay algorithm will allow interoperability, while the
          extensibility allows selection of overlay algorithms optimized for a
          particular application.
</dd>
</dl></blockquote>

<p>These properties were designed specifically to meet the requirements
      for a P2P protocol to support SIP, and this document defines a SIP Usage
      of RELOAD. However, RELOAD is not limited to usage by SIP and could
      serve as a tool for supporting other P2P applications with similar
      needs. RELOAD is also based on the concepts introduced in <a class='info' href='#I-D.ietf-p2psip-concepts'>[I&#8209;D.ietf&#8209;p2psip&#8209;concepts]<span> (</span><span class='info'>Bryan, D., &ldquo;Concepts and Terminology for Peer to Peer SIP,&rdquo; July&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Basic Setting</h3>

<p>In this section, we provide a brief overview of the operational
        setting for RELOAD. See the concepts document for more details. A
        RELOAD Overlay Instance consists of a set of nodes arranged in a
        partly connected graph. Each node in the overlay is assigned a numeric
        Node-ID which, together with the specific overlay algorithm in use,
        determines its position in the graph and the set of nodes it connects
        to. The figure below shows a trivial example which isn't drawn from
        any particular overlay algorithm, but was chosen for convenience of
        representation.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
          +--------+              +--------+              +--------+
          | Node 10|--------------| Node 20|--------------| Node 30|
          +--------+              +--------+              +--------+
              |                       |                       |
              |                       |                       |
          +--------+              +--------+              +--------+
          | Node 40|--------------| Node 50|--------------| Node 60|
          +--------+              +--------+              +--------+
              |                       |                       |
              |                       |                       |
          +--------+              +--------+              +--------+
          | Node 70|--------------| Node 80|--------------| Node 90|
          +--------+              +--------+              +--------+
                                      |
                                      |
                                  +--------+
                                  | Node 85|
                                  |(Client)|
                                  +--------+
</pre></div>
<p>Because the graph is not fully connected, when a node wants to send
        a message to another node, it may need to route it through the
        network. For instance, Node 10 can talk directly to nodes 20 and 40,
        but not to Node 70. In order to send a message to Node 70, it would
        first send it to Node 40 with instructions to pass it along to Node
        70. Different overlay algorithms will have different connectivity
        graphs, but the general idea behind all of them is to allow any node
        in the graph to efficiently reach every other node within a small
        number of hops.
</p>
<p>The RELOAD network is not only a messaging network. It is also a
        storage network. Records are stored under numeric addresses which
        occupy the same space as node identifiers. Nodes are responsible for
        storing the data associated with some set of addresses as determined
        by their Node-Id. For instance, we might say that every node is
        responsible for storing any data value which has an address less than
        or equal to its own Node-Id, but greater than the next lowest Node-Id.
        Thus, Node-20 would be responsible for storing values 11-20.
</p>
<p>RELOAD also supports clients. These are nodes which have Node-Ids
        but do not participate in routing or storage. For instance, in the
        figure above Node 85 is a client. It can route to the rest of the
        RELOAD network via Node 80, but no other node will route through it
        and Node 90 is still responsible for all addresses between 81-90. We
        refer to non-client nodes as peers.
</p>
<p>Other applications (for instance, SIP) can be defined on top of
        RELOAD and use these two basic RELOAD services to provide their own
        services.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Architecture</h3>

<p>Architecturally RELOAD is divided into several layers, as shown in
        the following figure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                 Application

            +-------+  +-------+
            | SIP   |  | XMPP  |  ...
            | Usage |  | Usage |
            +-------+  +-------+
          -------------------------------------- Message Routing API
            +------------------+   +---------+
            |                  |&lt;-&gt;| Storage |
            |                  |   +---------+
            |      Routing     |        ^
            |       Layer      |        v
            |                  |   +---------+
            |                  |&lt;-&gt;|Topology |
            |                  |   | Plugin  |
            +------------------+   +---------+
                      ^                 ^
                      v                 |
            +------------------+ &lt;------+
            |    Forwarding    |
            |       Layer      |
            +------------------+
          -------------------------------------- Transport API
             +-------+  +------+
             |TLS    |  |DTLS  |  ...
             +-------+  +------+
</pre></div>
<p>The major components of RELOAD are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Usage Layer:</dt>
<dd>Each application defines a RELOAD
            usage; a set of data kinds and behaviors which describe how to use
            the services provided by RELOAD. These usages all talk to RELOAD
            through a common Message Routing API.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Routing Layer:</dt>
<dd>The Routing Layer is responsible for
            routing messages through the overlay. It also manages request
            state for the usages and forwards Store and Fetch operations to
            the Storage component. It talks directly to the Topology Plugin,
            which is responsible for implementing the specific topology
            defined by the overlay algorithm being used.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Storage:</dt>
<dd>The Storage component is responsible for
            processing messages relating to the storage and retrieval of data.
            It talks directly to the Topology Plugin and the routing layer in
            order to send and receive messages and manage data replication and
            migration.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Topology Plugin:</dt>
<dd>The Topology Plugin is responsible
            for implementing the specific overlay algorithm being used. It
            talks directly to the Routing Layer to send and receive overlay
            management messages, to the Storage component to manage data
            replication, and directly to the Forwarding Layer to control
            hop-by-hop message forwarding.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Forwarding Layer:</dt>
<dd>The Forwarding Layer provides
            packet forwarding services between nodes. It also handles setting
            up connections across NATs using ICE.
</dd>
</dl></blockquote>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.1"></a><h3>1.2.1.&nbsp;
Usage Layer</h3>

<p>The top layer, called the Usage Layer, has application
          usages---such as the SIP Location Usage---that use the abstract
          Message Routing API provided by RELOAD. The goal of this layer is to
          implement application-specific usages of the generic overlay
          services provided by RELOAD. The usage defines how a specific
          application maps its data into something that can be stored in the
          overlay, where to store the data, how to secure the data, and
          finally how applications can retrieve and use the data.
</p>
<p>The architecture diagram shows both a SIP usage and an XMPP
          usage. A single application may require multiple usages, for example
          a SIP application may also require a voicemail usage. A usage may
          define multiple kinds of data that are stored in the overlay and may
          also rely on kinds originally defined by other usages.
</p>
<p>This draft also defines a Diagnostics Usage, which can be used to
          obtain diagnostic information about a peer in the overlay. The
          Diagnostics Usage is interesting both to administrators monitoring
          the overlay as well as to some overlay algorithms that base their
          decisions on capabilities and current load of nodes in the
          overlay.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.2"></a><h3>1.2.2.&nbsp;
Routing Layer</h3>

<p>The Routing Layer provides a generic message routing service for
          the overlay. Each peer is identified by its location in the overlay
          as determined by its Node-ID. A component which is a client of the
          Routing Layer can perform two basic functions:
</p>
<p></p>
<ul class="text">
<li>Send a message to a given peer, specified by Node-Id or
              Resource-Id.
</li>
<li>Receive messages that other peers sent to a Node-Id or
              Resource-Id for which this peer is responsible.
</li>
</ul>

<p>All usages are clients of the Routing Layer and use RELOAD's
          services by sending and receiving messages from peers. For instance,
          when a usage wants to store data, it does so by sending Store
          requests. Note that the Storage component and the Topology Plugin
          are themselves clients of the Routing Layer, because they need to
          send and receive messages from other peers.
</p>
<p>The Routing Layer provides a fairly generic interface that allows
          the topology plugin control the overlay and resource operations and
          messages. Since each overlay algorithm is defined and functions
          differently, we generically refer to the table of other peers that
          the overlay algorithm maintains and uses to route requests
          (neighbors) as a Routing Table. The Routing Layer component makes
          queries to the overlay algorithm to determine the next hop, then
          encodes and sends the message itself. Similarly, the overlay
          algorithm issues periodic update requests through the logic
          component to maintain and update its Routing Table.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.3"></a><h3>1.2.3.&nbsp;
Storage</h3>

<p>One of the major functions of RELOAD is to allow nodes to store
          data in the overlay and to retrieve data stored by other nodes or by
          themselves. The Storage component is responsible for processing data
          storage and retrieval messages. 
	  For instance, the
          Storage component might receive a Store request for a given resource
          from the Routing Layer. It would then store the data value(s) in its
          local data store and sends a response to the Routing Layer for
          delivery to the requesting peer.
	  Typically, these messages will
	  come for other nodes, but depending on the overlay topology,
	  a node might be responsible for storing data for itself as well,
	  especially if the overlay is small.
</p>
<p>The node's Node-ID determines the set of resources which it will
          be responsible for storing. However, the exact mapping between these
          is determined by the overlay algorithm used by the overlay,
          therefore the Storage component always the queries the topology
          plugin to determine where a particular resource should be
          stored.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.4"></a><h3>1.2.4.&nbsp;
Topology Plugin</h3>

<p>RELOAD is explicitly designed to work with a variety of overlay
          algorithms. In order to facilitate this, the overlay algorithm
          implementation is provided by a Topology Plugin so that each overlay
          can select an appropriate overlay algorithm that relies on the
          common RELOAD core protocols and code.
</p>
<p>The Topology Plugin is responsible for maintaining the overlay
          algorithm Routing Table, which is consulted by the Routing Layer
          before routing a message. When connections are made or broken, the
          Forwarding Layer notifies the Topology Plugin, which adjusts the
          routing table as appropriate. The Topology Plugin will also instruct
          the Forwarding Layer to form new connections as dictated by the
          requirements of the overlay algorithm Topology.
</p>
<p>As peers enter and leave, resources may be stored on different
          peers, so the Topology Plugin also keeps track of which peers are
          responsible for which resources. As peers join and leave, the
          Topology Plugin issues resource migration requests as appropriate,
          in order to ensure that other peers have whatever resources they are
          now responsible for. The Topology Plugin is also responsible for
          providing redundant data storage to protect against loss of
          information in the event of a peer failure and to protect against
          compromised or subversive peers.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.5"></a><h3>1.2.5.&nbsp;
Forwarding Layer</h3>

<p>The Forwarding Layer is responsible for getting a packet to the
          next peer, as determined by the Routing and Storage Layer. The
          Forwarding Layer establishes and maintains the network connections
          as required by the Topology Plugin. This layer is also responsible
          for setting up connections to other peers through NATs and firewalls
          using ICE, and it can elect to forward traffic using relays for NAT
          and firewall traversal.
</p>
<p>The Forwarding Layer sits on top of transport layer protocols
          which carry the actual traffic. This specification defines how to
          use DTLS and TLS to carry RELOAD messages.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
SIP Usage</h3>

<p>The SIP Usage of RELOAD allows SIP user agents to provide a
        peer-to-peer telephony service without the requirement for permanent
        proxy or registration servers. In such a network, the RELOAD overlay
        itself performs the registration and rendezvous functions ordinarily
        associated with such servers.
</p>
<p>
</p>
<p>The SIP Usage involves two basic functions: </p>
<blockquote class="text"><dl>
<dt>Registration: </dt>
<dd>SIP UAs can use the RELOAD data
            storage functionality to store a mapping from their AOR to their
            Node-Id in the overlay, and to retrieve the Node-Id of other
            UAs.
</dd>
<dt>Rendezvous: </dt>
<dd>Once a SIP UA has identified the
            Node-Id for an AOR it wishes to call, it can use the RELOAD
            message routing system to set up a direct connection which can be
            used to exchange SIP messages.
</dd>
</dl></blockquote>

<p>For instance, Bob could register his Node-Id, "1234", under his
        AOR, "sip:bob@dht.example.com". When Alice wants to call Bob, she
        queries the overlay for "sip:bob@dht.example.com" and gets back
        Node-Id 1234. She then uses the overlay to establish a direct
        connection with Bob and can use that direct connection to perform a
        standard SIP INVITE.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Security</h3>

<p>RELOAD's security model is based on each node having one or more
        public key certificates. In general, these certificates will be
        assigned by a central server which also assigns Node-Ids, although
        self-signed certificates can be used in closed networks. These
        credentials can be leveraged to provide communications security for
        RELOAD messages. RELOAD provides communications security at three
        levels:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Connection Level: </dt>
<dd>Connections between peers are
            secured with TLS or DTLS.
</dd>
<dt>Message Level: </dt>
<dd>Each RELOAD message must be
            signed.
</dd>
<dt>Object Level: </dt>
<dd>Stored objects must be signed by the
            storing peer.
</dd>
</dl></blockquote>

<p>These three levels of security work together to allow peers to
        verify the origin and correctness of data they receive from other
        peers, even in the face of malicious activity by other peers in the
        overlay. RELOAD also provides access control built on top of these
        communications security features. Because the peer responsible for
        storing a piece of data can validate the signature on the data being
        stored, the responsible peer can determine whether a given operation
        is permitted or not.
</p>
<p>RELOAD also provides a shared secret based admission control
        feature using shared secrets and TLS-PSK. In order to form a TLS
        connection to any node in the overlay, a new node needs to know the
        shared overlay key, thus restricting access to authorized users.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5"></a><h3>1.5.&nbsp;
Structure of This Document</h3>

<p>The remainder of this document is structured as follows.
</p>
<p></p>
<ul class="text">
<li>Section 2 provides definitions of terms used in this
            document.
</li>
<li>Section 3 provides an overview of the mechanisms used to
            establish and maintain the overlay.
</li>
<li>Section 4 provides an overview of the mechanism RELOAD provides
            to support other applications.
</li>
<li>Section 5 provides an overview of the SIP usage for RELOAD.
</li>
<li>Section 6 defines the protocol messages that RELOAD uses to
            establish and maintain the overlay.
</li>
<li>Section 7 defines the protocol messages that are used to store
            and retrieve data using RELOAD.
</li>
<li>Sections 8-10 define three Usages of RELOAD that provide
            certificate storage, SIP, and Diagnostics.
</li>
<li>Section 11 defines a specific Topology Plugin using Chord.
</li>
<li>Section 12 defines the mechanisms that new RELOAD nodes use to
            join the overlay for the first time.
</li>
<li>Section 13 provides an extended example.
</li>
<li>Sections 14 and 15 provide Security and IANA
            considerations.
</li>
</ul>

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate           Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<p>We use the terminology and definitions from the <a class='info' href='#I-D.ietf-p2psip-concepts'>Concepts and Terminology for Peer to
      Peer SIP<span> (</span><span class='info'>Bryan, D., &ldquo;Concepts and Terminology for Peer to Peer SIP,&rdquo; July&nbsp;2007.</span><span>)</span></a> [I&#8209;D.ietf&#8209;p2psip&#8209;concepts] draft extensively in this document. Other terms used in
      this document are defined inline when used and are also defined below
      for reference. Terms which are new to this document (and perhaps should
      be added to the concepts document) are marked with a (*).
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>DHT:</dt>
<dd>A distributed hash table. A DHT is an abstract
          hash table service realized by storing the contents of the hash
          table across a set of peers.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Overlay Algorithm:</dt>
<dd>An overlay algorithm defines the
          rules for determining which peers in an overlay store a particular
          piece of data and for determining a topology of interconnections
          amongst peers in order to find a piece of data.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Overlay Instance:</dt>
<dd>A specific overlay algorithm and the
          collection of peers that are collaborating to provide read and write
          access to it. There can be any number of overlay instances running
          in an IP network at a time, and each operates in isolation of the
          others.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Peer:</dt>
<dd>A host that is participating in the overlay.
          Peers are responsible for holding some portion of the data that has
          been stored in the overlay and also route messages on behalf of
          other hosts as required by the Overlay Algorithm.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Client:</dt>
<dd>A host that is able to store data in and
          retrieve data from the overlay but which is not participating in
          routing or data storage for the overlay.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Node:</dt>
<dd>We use the term "Node" to refer to a host that
          may be either a Peer or a Client. Because RELOAD uses the same
          protocol for both clients and peers, much of the text applies
          equally to both. Therefore we use "Node" when the text applies to
          both Clients and Peers and the more specific term when the text
          applies only to Clients or only to Peers.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Node-ID:</dt>
<dd>A 128-bit value that uniquely identifies a
          node. Node-IDs 0 and 2^128 - 1 are reserved and are invalid
          Node-IDs. A value of zero is not used in the wire protocol but can
          be used to indicate an invalid node in implementations and APIs. The
          Node-ID of 2^128-1 is used on the wire protocol as a wildcard.
          (*)
</dd>
<dt></dt>
<dd>
</dd>
<dt>Resource:</dt>
<dd>An object or group of objects associated
          with a string identifier see "Resource Name" below.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Resource Name:</dt>
<dd>The (potentially) human readable name
          by which a resource is identified. In unstructured P2P networks, the
          resource name is used directly as a Resource-Id. In structured P2P
          networks the resource name can be mapped into a Resource-ID by using
          the string as the input to hash function. A SIP resource, for
          example, is often identified by its AOR (see Resource Name
          below).(*)
</dd>
<dt></dt>
<dd>
</dd>
<dt>Resource-ID:</dt>
<dd>A value that identifies some resources
          and which is used as a key for storing and retrieving the resource.
          Often this is not human friendly/readable. One way to generate a
          Resource-ID is by applying a mapping function to some other unique
          name (e.g., user name or service name) for the resource. The
          Resource-ID is used by the distributed database algorithm to
          determine the peer or peers that are responsible for storing the
          data for the overlay. In structured P2P networks, resource-IDs are
          generally fixed length and are formed by hashing the resource
          identifier. In unstructured networks, resource identifiers may be
          used directly as resource-IDs and may have variable length.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Connection Table:</dt>
<dd>The set of peers to which a node is
          directly connected. This includes nodes with which Attach
          handshakes have been done but which have not sent any Updates.
          
</dd>
<dt></dt>
<dd>
</dd>
<dt>Routing Table:</dt>
<dd>The set of peers which a node can use
          to route overlay messages. In general, these peers will all be on
          the connection table but not vice versa, because some peers will
          have Attached but not sent updates. Peers may send messages
          directly to peers which are on the connection table but may only
          route messages to other peers through peers which are on the routing
          table. (*)
</dd>
<dt></dt>
<dd>
</dd>
<dt>Destination List:</dt>
<dd>A list of IDs through which a
          message is to be routed. A single Node-ID is a trivial form of
          destination list. (*)
</dd>
<dt></dt>
<dd>
</dd>
<dt>Usage:</dt>
<dd>A usage is an application that wishes to use
          the overlay for some purpose. Each application wishing to use the
          overlay defines a set of data kinds that it wishes to use. The SIP
          usage defines the location, certificate, STUN server and TURN server
          data kinds. (*)
</dd>
</dl></blockquote>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Overlay Management Overview</h3>

<p>The most basic function of RELOAD is as a generic overlay network.
      Nodes need to be able to join the overlay, form connections to other
      nodes, and route messages through the overlay to nodes to which they are
      not directly connected. This section provides an overview of the
      mechanisms that perform these functions.
</p>
<a name="sec.overview.security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Security and Identification</h3>

<p>Every node in the RELOAD overlay is identified by a 
        Node-ID. The Node-ID is used for three major purposes:
</p>
<p></p>
<ul class="text">
<li>To address the node itself.
</li>
<li>To determine its position in the overlay topology when the
            overlay is structured.
</li>
<li>To determine the set of resources for which the node is
            responsible.
</li>
</ul>

<p>Each node has a certificate <a class='info' href='#RFC3280'>[RFC3280]<span> (</span><span class='info'>Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;Internet X.509 Public Key Infrastructure Certificate and           Certificate Revocation List (CRL) Profile,&rdquo; April&nbsp;2002.</span><span>)</span></a>
        containing a Node-ID, which is globally unique.
</p>
<p>The certificate serves multiple purposes:
</p>
<p></p>
<ul class="text">
<li>It entitles the user to store data at specific locations in the
            Overlay Instance. Each data kind defines the specific rules for
            determining which certificates can access each resource-ID/kind-id
            pair. For instance, some kinds might allow anyone to write at a
            given location, whereas others might restrict writes to the owner
            of a single certificate.
</li>
<li>It entitles the user to operate a node that has a Node-ID found
            in the certificate. When the node forms a connection to another
            peer, it can use this certificate so that a node connecting to it
            knows it is connected to the correct node. In addition, the node
            can sign messages, thus providing integrity and authentication for
            messages which are sent from the node.
</li>
<li>It entitles the user to use the user name found in the
            certificate.
</li>
</ul>

<p>If a user has more than one device, typically they would get one
        certificate for each device. This allows each device to act as a
        separate peer.
</p>
<p>RELOAD supports two certificate issuance models. The first is based
        on a central enrollment process which allocates a unique name and
        Node-Id to the node a certificate for a public/private key pair for
        the user. All peers in a particular Overlay Instance have the
        enrollment server as a trust anchor and so can verify any other peer's
        certificate.
</p>
<p>In some settings, a group of users want to set up an overlay
        network but are not concerned about attack by other users in the
        network. For instance, users on a LAN might want to set up a short
        term ad hoc network without going to the trouble of setting up an
        enrollment server. RELOAD supports the use of self-generated and
        self-signed certificates. When self-signed certificates are used, the
        node also generates its own Node-Id and username. The Node-Id is
        computed as a digest of the public key, to prevent Node-Id theft,
        however this model is still subject to a number of known attacks (most
        notably Sybil attacks <a class='info' href='#Sybil'>[Sybil]<span> (</span><span class='info'>Douceur, J., &ldquo;The Sybil Attack,&rdquo; March&nbsp;2002.</span><span>)</span></a>) and can only be
        safely used in closed networks where users are mutually trusting.
</p>
<a name="sec-shared-key"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Shared-Key Security</h3>

<p>RELOAD also provides an admission control system based on shared
          keys. In this model, the peers all share a single key which is used
          to authenticate the peer-to-peer connections via
          TLS-PSK/TLS-SRP.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Clients</h3>

<p>RELOAD defines a single protocol that is used both as the peer
        protocol and the client protocol for the overlay. This simplifies
        implementation, particularly for devices that may act in either role,
        and allows clients to inject messages directly into the overlay.
</p>
<p>We use the term "peer" to identify a node in the overlay that
        routes messages for nodes other than those to which it is directly
        connected. Peers typically also have storage responsibilities. We use
        the term "client" to refer to nodes that do not have routing or
        storage responsibilities. When text applies to both peers and clients,
        we will simply refer to such a device as a "node."
</p>
<p>RELOAD's client support allows nodes that are not participating in
        the overlay as peers to utilize the same implementation and to benefit
        from the same security mechanisms as the peers. Clients possess and
        use certificates that authorize the user to store data at its
        locations in the overlay. The Node-ID in the certificate is used to
        identify the particular client as a member of the overlay and to
        authenticate its messages.
</p>
<p>The remainder of this section discusses how RELOAD supports clients
        in terms of routing issues specific to clients, minimum functionality
        requirements for clients, and alternatives for devices not capable of
        meeting those requirements.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Client Routing</h3>

<p>There are two routing options by which a client may be located in
          an overlay.
</p>
<p></p>
<ul class="text">
<li>Establish a connection to the peer responsible for the
              client's Node-ID in the overlay. Then requests may be sent
              from/to the client using its Node-ID in the same manner as if it
              were a peer, because the responsible peer in the overlay will
              handle the final step of routing to the client.
</li>
<li>Establish a connection with an arbitrary peer in the overlay
              (perhaps based on network proximity or an inability to establish
              a direct connection with the responsible peer). In this case,
              the client will rely on RELOAD's Destination List feature to
              ensure reachability. The client can initiate requests, and any
              node in the overlay that knows the Destination List to its
              current location can reach it, but the client is not directly
              reachable directly using only its Node-ID. The Destination List
              required to reach it must be learnable via other mechanisms,
              such as being stored in the overlay by a usage, if the client is
              to receive incoming requests from other members of the overlay.
             
</li>
</ul>

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Client Behavior</h3>

<p>There are a wide variety of reasons a node may act as a client
          rather than as a peer <a class='info' href='#I-D.pascual-p2psip-clients'>[I&#8209;D.pascual&#8209;p2psip&#8209;clients]<span> (</span><span class='info'>Pascual, V., Matuszewski, M., Shim, E., Zhang, H., and S. Yongchao, &ldquo;P2PSIP Clients,&rdquo; February&nbsp;2008.</span><span>)</span></a>. This section outlines
          some of those scenarios and how the client's behavior changes based
          on its capabilities.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2.1"></a><h3>3.2.2.1.&nbsp;
Why Not Only Peers?</h3>

<p>For a number of reasons, a particular node may be forced to act
            as a client even though it is willing to act as a peer. These
            include:
</p>
<p></p>
<ul class="text">
<li>The node does not have appropriate network
                connectivity---typically because it is behind an overly
                restrictive NAT, or it has a low-bandwidth network
                connection.
</li>
<li>The node may not have sufficient resources, such as
                computing power, storage space, or battery power.
</li>
<li>The overlay algorithm may dictate specific requirements for
                peer selection. These may include participation in the overlay
                to determine trustworthiness, control the number of peers in
                the overlay to reduce overly-long routing paths, or ensure
                minimum application uptime before a node can join as a
                peer.
</li>
</ul>

<p>The ultimate criteria for a node to become a peer are
            determined by the overlay algorithm and specific deployment. A
            node acting as a client that has a full implementation of RELOAD
            and the appropriate overlay algorithm is capable of locating its
            responsible peer in the overlay and using CONNECT to establish a
            direct connection to that peer. In that way, it may elect to be
            reachable under either of the routing approaches listed above.
            Particularly for overlay algorithms that elect nodes to serve as
            peers based on trustworthiness or population, the overlay
            algorithm may require such a client to locate itself at a
            particular place in the overlay.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2.2"></a><h3>3.2.2.2.&nbsp;
Minimum Functionality Requirements for Clients</h3>

<p>A node may act as a client simply because it does not have the
            resources or even an implementation of the topology plugin
            required to acts as a peer in the overlay. In order to exchange
            RELOAD messages with a peer, a client must meet a minimum level of
            functionality. Such a client must:
</p>
<p></p>
<ul class="text">
<li>Implement RELOAD's connection-management connections that
                are used to establish the connection with the peer.
</li>
<li>Implement RELOAD's data storage and retrieval methods (with
                client functionality).
</li>
<li>Be able to calculate Resource-IDs used by the overlay.
</li>
<li>Possess security credentials required by the overlay it is
                implementing.
</li>
</ul>

<p>A client speaks the same protocol as the peers, knows how to
            calculate Resource-IDs, and signs its requests in the same manner
            as peers. While a client does not necessarily require a full
            implementation of the overlay algorithm, calculating the
            Resource-ID requires an implementation of the appropriate
            algorithm for the overlay.
</p>
<p>RELOAD does not support a separate protocol for clients that do
            not meet these functionality requirements. Any such extension
            would either entail compromises on the features of RELOAD or
            require an entirely new protocol to reimplement the core features
            of RELOAD. Furthermore, for P2PSIP and many other applications, a
            native application-level protocol already exists that is
            sufficient for such a client, as described in the next
            section.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2.3"></a><h3>3.2.2.3.&nbsp;
Clients as Application-Level Agents</h3>

<p>SIP defines an extensive protocol for registration and security
            between a client and its registrar/proxy server(s). Any SIP device
            can act as a client of a RELOAD-based P2PSIP overlay if it
            contacts a peer that implements the server-side functionality
            required by the SIP protocol. In this case, the peer would be
            acting as if it were the user's peer, and would need the
            appropriate credentials for that user.
</p>
<p>Application-level support for clients is defined by a usage. A
            usage offering support for application-level clients should
            specify how the security of the system is maintained when the data
            is moved between the application and RELOAD layers.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Routing</h3>

<p>This section will discuss the requirements RELOAD's routing
        capabilities must meet, then describe the routing features in the
        protocol, and provide a brief overview of how they are used. The
        section will conclude by discussing some alternative designs and the
        tradeoffs that would be necessary to support them.
</p>
<p>RELOAD's routing capabilities must meet the following
        requirements:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>NAT Traversal: </dt>
<dd>RELOAD must support establishing and
            using connections between nodes separated by one or more NATs,
            including locating peers behind NATs for those overlays
            allowing/requiring it.
</dd>
<dt>Clients: </dt>
<dd>RELOAD must support requests from and to
            clients that do not participate in overlay routing.
</dd>
<dt>Client promotion:</dt>
<dd>RELOAD must support clients that
            become peers at a later point as determined by the overlay
            algorithm and deployment.
</dd>
<dt>Low state: </dt>
<dd>RELOAD's routing algorithms must not
            require significant state to be stored on intermediate peers.
</dd>
<dt>Return routability in unstable topologies: </dt>
<dd>At some
            points in times, different nodes may have inconsistent information
            about the connectivity of the routing graph. In all cases, the
            response to a request needs to delivered to the node that sent the
            request and not to some other node.
</dd>
</dl></blockquote>

<p>To meet these requirements, RELOAD's routing relies on two basic
        mechanisms:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Via Lists: </dt>
<dd>The forwarding header used by all RELOAD
            messages contains both a Via List (built hop-by-hop as the message
            is routed through the overlay) and a Destination List (providing
            source-routing capabilities for requests and return-path routing
            for responses).
</dd>
<dt>Route_Query: </dt>
<dd>The Route_Query method allows a node
            to query a peer for the next hop it will use to route a message.
            This method is useful for diagnostics and for iterative
            routing.
</dd>
</dl></blockquote>

<p>The basic routing mechanism used by RELOAD is Symmetric Recursive.
        We will first describe symmetric routing and then discuss its
        advantages in terms of the requirements discussed above.
</p>
<p>Symmetric recursive routing requires a message follow the path
        through the overlay to the destination without returning to the
        originating node: each peer forwards the message closer to its
        destination. The return path of the response is then the same path
        followed in reverse. For example, a message following a route from A
        to Z through B and X:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
A         B         X         Z
-------------------------------

----------&gt;
Dest=Z
          ----------&gt;
          Via=A
          Dest=Z
                    ----------&gt;
                    Via=A, B
                    Dest=Z


                    &lt;----------
                   Dest=X, B, A
          &lt;----------
            Dest=B, A
&lt;----------
     Dest=A
</pre></div>
<p>Note that the preceding Figure does not indicate whether A is a
        client or peer---A forwards its request to B and the response is
        returned to A in the same manner regardless of A's role in the
        overlay.
</p>
<p>This figure shows use of full via-lists by intermediate peers B and
        X. However, if B and/or X are willing to store state, then they may
        elect to truncate the lists, save that information internally (keyed
        by the transaction id), and return the response message along the path
        from which it was received when the response is received. This option
        requires greater state on intermediate peers but saves a small amount
        of bandwidth and reduces the need for modifying the message enroute.
        Selection of this mode of operation is a choice for the individual
        peer---the techniques are mutually interoperable even on a single
        message. The figure below shows B using full via lists but X
        truncating them and saving the state internally.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
A         B         X         Z
-------------------------------

----------&gt;
Dest=Z
          ----------&gt;
          Via=A
          Dest=Z
                    ----------&gt;
                    Dest=Z

                    &lt;----------
                         Dest=X
            &lt;----------
            Dest=B, A
&lt;----------
     Dest=A
</pre></div>
<p>For debugging purposes, a Route Log attribute is available that
        stores information about each peer as the message is forwarded.
</p>
<p>RELOAD also supports a basic Iterative routing mode (where the
        intermediate peers merely return a response indicating the next hop,
        but do not actually forward the message to that next hop themselves).
        Iterative routing is implemented using the Route_Query method, which
        requests this behavior. Note that iterative routing is selected only
        by the initiating node. RELOAD does not support an intermediate peer
        returning a response that it will not recursively route a normal
        request---the willingness to perform that operation is implicit in its
        role as a peer in the overlay.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
Routing Alternatives</h3>

<p>Significant discussion has been focused on the selection of a
          routing algorithm for P2PSIP. This section discusses the motivations
          for selection of symmetric recursive routing for RELOAD and
          describes the extensions that would be required to support
          additional routing algorithms.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.1"></a><h3>3.3.1.1.&nbsp;
Iterative vs Recursive</h3>

<p>Iterative routing has a number of advantages. It is easier to
            debug, consumes fewer resources on intermediate peers, and allows
            the querying peer to identify and route around misbehaving peers
            <a class='info' href='#stoica-non-transitive-worlds05'>[stoica&#8209;non&#8209;transitive&#8209;worlds05]<span> (</span><span class='info'>Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &ldquo;Non-Transitive Connectivity and DHTs,&rdquo; .</span><span>)</span></a>. However, in
            the presence of NATs iterative routing is intolerably expensive
            because a new connection must be established for each hop (using
            ICE) <a class='info' href='#bryan-design-hotp2p08'>[bryan&#8209;design&#8209;hotp2p08]<span> (</span><span class='info'>Bryan, D., Lowekamp, B., and M. Zangrilli, &ldquo;The Design of a Versatile, Secure P2PSIP Communications           Architecture for the Public Internet,&rdquo; .</span><span>)</span></a>.
</p>
<p>Iterative routing is supported through the Route_Query mechanism
            and is primarily intended for debugging.  It is also allows the
            querying peer to evaluate the routing decisions made by the peers at
            each hop, consider alternatives, and perhaps detect at what point
            the forwarding path fails.
           
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.2"></a><h3>3.3.1.2.&nbsp;
Symmetric vs Forward response</h3>

<p>An alternative to the symmetric recursive routing method used
            by RELOAD is Forward-Only routing, where the response is routed to
            the requester as if it is a new message initiating by the
            responder (in the previous example, Z sends the response to A as
            if it were sending a request). Forward-only routing requires no
            state in either the message or intermediate peers.
</p>
<p>The drawback of forward-only routing is that it does not work
            when the overlay is unstable. For example, if A is in the process
            of joining the overlay and is sending a Join request to Z, it is
            not yet reachable via forward routing. Even if it is established
            in the overlay, if network failures produce temporary instability,
            A may not be reachable (and may be trying to stabilize its network
            connectivity via Attach messages).
</p>
<p>Furthermore, forward-only responses are less likely to reach
            the querying peer than symmetric recursive because the forward
            path is more likely to have a failed peer than the request path
            (which was just tested to route the request) <a class='info' href='#stoica-non-transitive-worlds05'>[stoica&#8209;non&#8209;transitive&#8209;worlds05]<span> (</span><span class='info'>Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &ldquo;Non-Transitive Connectivity and DHTs,&rdquo; .</span><span>)</span></a>.
</p>
<p>An extension to RELOAD that supports forward-only routing but
            relies on symmetric responses as a fallback would be possible, but
            due to the complexities of determining when to use forward-only
            and when to fallback to symmetric, we have chosen not to include
            it as an option at this point.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.3"></a><h3>3.3.1.3.&nbsp;
Direct Response</h3>

<p>Another routing option is Direct Response routing, in which the
            response is returned directly to the querying node. In the
            previous example, if A encodes its IP address in the request, then
            Z can simply deliver the response directly to A. In the absence of
            NATs or other connectivity issues, this is the optimal routing
            technique.
</p>
<p>The challenge of implementing direct response is the presence
            of NATs. There are a number of complexities that must be
            addressed. In this discussion, we will continue our assumption
            that A issued the request and Z is generating the response.
</p>
<p></p>
<ul class="text">
<li>The IP address listed by A may be unreachable, either due
                to NAT or firewall rules. Therefore, a direct response
                technique must fallback to symmetric response <a class='info' href='#stoica-non-transitive-worlds05'>[stoica&#8209;non&#8209;transitive&#8209;worlds05]<span> (</span><span class='info'>Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &ldquo;Non-Transitive Connectivity and DHTs,&rdquo; .</span><span>)</span></a>. The
                hop-by-hop ACKs used by RELOAD allow Z to determine when A has
                received the message (and the TLS negotiation will provide
                earlier confirmation that A is reachable), but this fallback
                requires a timeout that will increase the response latency
                whenever A is not reachable from Z.
</li>
<li>Whenever A is behind a NAT it will have multiple candidate
                IP addresses, each of which must be advertised to ensure
                connectivity, therefore Z will need to attempt multiple
                connections to deliver the response.
</li>
<li>One (or all) of A's candidate addresses may route from Z to
                a different device on the Internet. In the worst case these
                nodes may actually be running RELOAD on the same port.
                Therefore, establishing a secure connection to authenticate A
                before delivering the response is absolutely necessary. This
                step diminishes the efficiency of direct response because
                multiple roundtrips are required before the message can be
                delivered.
</li>
<li>If A is behind a NAT and does not have a connection already
                established with Z, there are only two ways the direct
                response will work. The first is that A and Z are both behind
                the same NAT, in which case the NAT is not involved. In the
                more common case, when Z is outside A's NAT, the response will
                only be received if A's NAT implements endpoint-independent
                filtering. As the choice of filtering mode conflates
                application transparency with security <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for           Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>, and no clear recommendation is
                available, the prevalence of this feature in future devices
                remains unclear.
</li>
</ul>

<p>An extension to RELOAD that supports direct response routing
            but relies on symmetric responses as a fallback would be possible,
            but due to the complexities of determining when to use direct
            response and when to fallback to symmetric, and the reduced
            performance for responses to peers behind restrictive NATs, we
            have chosen not to include it as an option at this point.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.4"></a><h3>3.3.1.4.&nbsp;
Relay Peers</h3>

<p><a class='info' href='#I-D.jiang-p2psip-sep'>SEP<span> (</span><span class='info'>Jiang, X. and H. Zhang, &ldquo;Service Extensible P2P Peer Protocol,&rdquo; February&nbsp;2008.</span><span>)</span></a> [I&#8209;D.jiang&#8209;p2psip&#8209;sep] has proposed
            implementing a form of direct response by having A identify a
            peer, Q, that will be directly reachable by any other peer. A uses
            Attach to establish a connection with Q and advertises Q's IP
            address in the request sent to Z. Z sends the response to Q, which
            relays it to A. This then reduces the latency to two hops, plus Z
            negotiating a secure connection to Q.
</p>
<p>This technique relies on the relative population of nodes such
            as A that require relay peers and peers such as Q that are capable
            of serving as a relay peer. It also requires nodes to be able to
            identify which category they are in. This identification problem
            has turned out to be hard to solve and is still an open area of
            exploration.
</p>
<p>An extension to RELOAD that supports relay peers is possible,
            but due to the complexities of implementing such an alternative,
            we have not added such a feature to RELOAD at this point.
</p>
<p>A concept similar to relay peers, essentially choosing a relay
            peer at random, has previously been suggested to solve problems of
            pairwise non-transitivity <a class='info' href='#stoica-non-transitive-worlds05'>[stoica&#8209;non&#8209;transitive&#8209;worlds05]<span> (</span><span class='info'>Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &ldquo;Non-Transitive Connectivity and DHTs,&rdquo; .</span><span>)</span></a>, but deterministic
            filtering provided by NATs make random relay peers no more likely
            to work than the responding peer.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1.5"></a><h3>3.3.1.5.&nbsp;
Symmetric Route Stability</h3>

<p>A common concern about symmetric recursive routing has been
            that one or more peers along the request path may fail before the
            response is received. The significance of this problem essentially
            depends on the response latency of the overlay---an overlay that
            produces slow responses will be vulnerable to churn, whereas
            responses that are delivered very quickly are vulnerable only to
            failures that occur over that small interval.
</p>
<p>The other aspect of this issue is whether the request itself
            can be successfully delivered. Assuming typical connection
            maintenance intervals, the time period between the last
            maintenance and the request being sent will be orders of magnitude
            greater than the delay between the request being forwarded and the
            response being received. Therefore, if the path was stable enough
            to be available to route the request, it is almost certainly going
            to remain available to route the response.
</p>
<p>An overlay that is unstable enough to suffer this type of
            failure frequently is unlikely to be able to support reliable
            functionality regardless of the routing mechanism. However,
            regardless of the stability of the return path, studies show that
            in the event of high churn, iterative routing is a better solution
            to ensure request completion <a class='info' href='#ng-analytical-churn-ieeep2p06'>[ng&#8209;analytical&#8209;churn&#8209;ieeep2p06]<span> (</span><span class='info'>Wu, D., Tian, Y., and K. Ng, &ldquo;Analytical Study on Improving DHT Lookup Performance under           Churn,&rdquo; .</span><span>)</span></a> <a class='info' href='#stoica-non-transitive-worlds05'>[stoica&#8209;non&#8209;transitive&#8209;worlds05]<span> (</span><span class='info'>Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &ldquo;Non-Transitive Connectivity and DHTs,&rdquo; .</span><span>)</span></a>
</p>
<p>Finally, because RELOAD retries the end-to-end request, that
            retry will address the issues of churn that remain.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Connectivity Management</h3>

<p>In order to provide efficient routing, a peer needs to maintain a
        set of direct connections to other peers in the Overlay Instance. Due
        to the presence of NATs, these connections often cannot be formed
        directly. Instead, we use the Attach request to establish a
        connection. Attach uses ICE <a class='info' href='#I-D.ietf-mmusic-ice-tcp'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice&#8209;tcp]<span> (</span><span class='info'>Rosenberg, J., &ldquo;TCP Candidates with Interactive Connectivity Establishment           (ICE,&rdquo; March&nbsp;2007.</span><span>)</span></a> to establish the connection.
        It is assumed that the reader is familiar with ICE.
</p>
<p>Say that peer A wishes to form a direct connection to peer B. It
        gathers ICE candidates and packages them up in an Attach request which
        it sends to B through usual overlay routing procedures. B does its own
        candidate gathering and sends back a response with its candidates. A
        and B then do ICE connectivity checks on the candidate pairs. The
        result is a connection between A and B. At this point, A and B can add
        each other to their routing tables and send messages directly between
        themselves without going through other overlay peers.
</p>
<p>There is one special case in which Attach cannot be used: when a
        peer is joining the overlay and is not connected to any peers. In
        order to support this case, some small number of "bootstrap nodes"
        need to be publicly accessible so that new peers can directly connect
        to them. <a class='info' href='#secEnrollment'>Section&nbsp;13<span> (</span><span class='info'>Enrollment and Bootstrap</span><span>)</span></a> contains more detail on
        this.
</p>
<p>In general, a peer needs to maintain connections to all of the
        peers near it in the Overlay Instance and to enough other peers to
        have efficient routing (the details depend on the specific overlay).
        If a peer cannot form a connection to some other peer, this isn't
        necessarily a disaster; overlays can route correctly even without
        fully connected links. However, a peer should try to maintain the
        specified link set and if it detects that it has fewer direct
        connections, should form more as required. This also implies that
        peers need to periodically verify that the connected peers are still
        alive and if not try to reform the connection or form an alternate
        one.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Overlay Algorithm Support</h3>

<p>The Topology Plugin allows RELOAD to support a variety of overlay
        algorithms. This draft defines a DHT based on Chord <a class='info' href='#Chord'>[Chord]<span> (</span><span class='info'>Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, &ldquo;Chord: A Scalable Peer-to-peer Lookup Service for Internet           Applications,&rdquo; .</span><span>)</span></a>, which is mandatory to implement, but the base
        RELOAD protocol is designed to support a variety of overlay
        algorithms.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1"></a><h3>3.5.1.&nbsp;
Support for Pluggable Overlay Algorithms</h3>

<p>RELOAD defines three methods for overlay maintenance: Join,
          Update, and Leave. However, the contents of those messages, when
          they are sent, and their precise semantics are specified by the
          actual overlay algorithm; RELOAD merely provides a framework of
          commonly-needed methods that provides uniformity of notation (and
          ease of debugging) for a variety of overlay algorithms.
</p>
<a name="sec-join-leave-maint"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2"></a><h3>3.5.2.&nbsp;
Joining, Leaving, and Maintenance Overview</h3>

<p>When a new peer wishes to join the Overlay Instance, it must have
          a Node-ID that it is allowed to use. It uses the Node-ID in
          the certificate it received from the enrollment server. The details
          of the joining procedure are defined by the overlay algorithm, but
          the general steps for joining an Overlay Instance are:
</p>
<p></p>
<ul class="text">
<li>Forming connections to some other peers.
</li>
<li>Acquiring the data values this peer is responsible for
              storing.
</li>
<li>Informing the other peers which were previously responsible
              for that data that this peer has taken over responsibility.
</li>
</ul>

<p>The first thing the peer needs to do is form a connection to some
          "bootstrap node". Because this is the first connection the peer
          makes, these nodes must have public IP addresses and therefore can
          be connected to directly. Once a peer has connected to one or more
          bootstrap nodes, it can form connections in the usual way by routing
          Attach messages through the overlay to other nodes. Once a peer has
          connected to the overlay for the first time, it can cache the set of
          nodes it has connected to with public IP addresses for use as future
          bootstrap nodes.
</p>
<p>Once the peer has connected to a bootstrap node, it then needs to
          take up its appropriate place in the overlay. This requires two
          major operations:
</p>
<p></p>
<ul class="text">
<li>Forming connections to other peers in the overlay to populate
              its Routing Table.
</li>
<li>Getting a copy of the data it is now responsible for storing
              and assuming responsibility for that data.
</li>
</ul>

<p>The second operation is performed by contacting the Admitting
          Peer (AP), the node which is currently responsible for that section
          of the overlay.
</p>
<p>The details of this operation depend mostly on the overlay
          algorithm involved, but a typical case would be:
</p>
<p></p>
<ol class="text">
<li>JP (Joining Peer) sends a Join request to AP (Admitting Peer)
              announcing its intention to join.
</li>
<li>AP sends a Join response.
</li>
<li>AP does a sequence of Stores to JP to give it the data it
              will need.
</li>
<li>AP does Updates to JP and to other peers to tell it about its
              own routing table. At this point, both JP and AP consider JP
              responsible for some section of the Overlay Instance.
</li>
<li>JP makes its own connections to the appropriate peers in the
              Overlay Instance.
</li>
</ol>

<p>After this process is completed, JP is a full member of the
          Overlay Instance and can process Store/Fetch requests.
</p>
<p>
	    Note that the first node is a special case. When ordinary
	    nodes cannot form connections to the bootstrap nodes,
	    then they are not part of the overlay. However, the
	    first node in the overlay can obviously not
	    connect to others nodes. In order to support this case,
	    potential first nodes (which must also serve as 
	    bootstrap nodes initially) must somehow be instructed
	    (perhaps by configuration settings)
	    that they are the entire overlay, rather than not
	    part of it.
	  
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
First-Time Setup</h3>

<p>Previous sections addressed how RELOAD works once a node has
        connected. This section provides an overview of how users get
        connected to the overlay for the first time. RELOAD is designed so
        that users can start with the name of the overlay they wish to join
        and perhaps a username and password, and leverage that into having a
        working peer with minimal user intervention. This helps avoid the
        problems that have been experienced with conventional SIP clients
        where users are required to manually configure a large number of
        settings.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6.1"></a><h3>3.6.1.&nbsp;
Initial Configuration</h3>

<p>In the first phase of the process, the user starts out with the
          name of the overlay and uses this to download an initial set of
          overlay configuration parameters. The user does a DNS SRV lookup on
          the overlay name to get the address of a configuration server. It
          can then connect to this server with HTTPS to download a
          configuration document which contains the basic overlay
          configuration parameters as well as a set of bootstrap nodes which
          can be used to join the overlay.  
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6.2"></a><h3>3.6.2.&nbsp;
Enrollment</h3>

<p>If the overlay is using centralized enrollment, then a user needs
          to acquire a certificate before joining the overlay. The certificate
          attests both to the user's name within the overlay and to the
          node-ids which they are permitted to operate. In that case, the
          configuration document will contain the address of an enrollment
          server which can be used to obtain such a certificate. The
          enrollment server may (and probably will) require some sort of
          username and password before issuing the certificate. The enrollment
          server's ability to restrict attackers' access to certificates in
          the overlay is one of the cornerstones of RELOAD's security.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Application Support Overview</h3>

<p>RELOAD is not intended to be used alone, but rather as a substrate
      for other applications. These applications can use RELOAD for a variety
      of purposes:
</p>
<p></p>
<ul class="text">
<li>To store data in the overlay and retrieve data stored by other
          nodes.
</li>
<li>As a discovery mechanism for services such as TURN.
</li>
<li>To form direct connections which can be used to transmit
          application-level messages.
</li>
</ul>

<p>This section provides an overview of these services.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Data Storage</h3>

<p>RELOAD provides operations to Store, Fetch, and Remove data. Each
        location in the Overlay Instance is referenced by a Resource-ID.
        However, each location may contain data elements corresponding to
        multiple kinds (e.g., certificate, SIP registration). Similarly, there
        may be multiple elements of a given kind, as shown below:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                    +--------------------------------+
                    |            Resource-ID         |
                    |                                |
                    | +------------+  +------------+ |
                    | |   Kind 1   |  |   Kind 2   | |
                    | |            |  |            | |
                    | | +--------+ |  | +--------+ | |
                    | | | Value  | |  | | Value  | | |
                    | | +--------+ |  | +--------+ | |
                    | |            |  |            | |
                    | | +--------+ |  | +--------+ | |
                    | | | Value  | |  | | Value  | | |
                    | | +--------+ |  | +--------+ | |
                    | |            |  +------------+ |
                    | | +--------+ |                 |
                    | | | Value  | |                 |
                    | | +--------+ |                 |
                    | +------------+                 |
                    +--------------------------------+
</pre></div>
<p>Each kind is identified by a kind-id, which is a code point
        assigned by IANA. As part of the kind definition, protocol designers
        may define constraints, such as limits on size, on the values which
        may be stored. For many kinds, the set may be restricted to a single
        value; some sets may be allowed to contain multiple identical items
        while others may only have unique items. Note that a kind may be
        employed by multiple usages and new usages are encouraged to use
        previously defined kinds where possible. We define the following data
        models in this document, though other usages can define their own
        structures:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>single value:</dt>
<dd>There can be at most one item in the
            set and any value overwrites the previous item.
</dd>
<dt></dt>
<dd>
</dd>
<dt>array:</dt>
<dd>Many values can be stored and addressed by a
            numeric index.
</dd>
<dt></dt>
<dd>
</dd>
<dt>dictionary:</dt>
<dd>The values stored are indexed by a key.
            Often this key is one of the values from the certificate of the
            peer sending the Store request.
</dd>
</dl></blockquote>

<p>In order to protect stored data from tampering, by other nodes,
        each stored value is digitally signed by the node which created it.
        When a value is retrieved, the digital signature can be verified to
        detect tampering.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Storage Permissions</h3>

<p>A major issue in peer-to-peer storage networks is minimizing the
          burden of becoming a peer, and in particular minimizing the amount
          of data which any peer is required to store for other nodes. RELOAD
          addresses this issue by only allowing any given node to store data
          at a small number of locations in the overlay, with those locations
          being determined by the node's certificate. When a peer uses a Store
          request to place data at a location authorized by its certificate,
          it signs that data with the private key that corresponds to its
          certificate. Then the peer responsible for storing the 
	  data is able to verify that
          the peer issuing the request is authorized to make that request.
          Each data kind defines the exact rules for determining what
          certificate is appropriate.
</p>
<p>The most natural rule is that a certificate authorizes a user to
          store data keyed with their user name X. This rules is used for all
          the kinds defined in this specification. Thus, only a user with a
          certificate for "alice@example.org" could write to that location in
          the overlay. However, other usages can define any rules they choose,
          including publicly writable values.
</p>
<p>The digital signature over the data serves two purposes. First,
          it allows the peer responsible for storing the data to verify that
          this Store is authorized. Second, it provides integrity for the
          data. The signature is saved along with the data value (or values)
          so that any reader can verify the integrity of the data. Of course,
          the responsible peer can "lose" the value but it cannot undetectable
          modify it.
</p>
<p>The size requirements of the data being stored in the overlay are
          variable. For instance, a SIP AoR and voicemail differ widely in the
          storage size. RELOAD leaves it to the Usage and overlay configuration
	  to address the size
          imbalance of various kinds.
</p>
<a name="sec-usages"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Usages</h3>

<p>By itself, the distributed storage layer just provides
          infrastructure on which applications are built. In order to do
          anything useful, a usage must be defined. Each Usage specifies
          several things:
</p>
<p></p>
<ul class="text">
<li>Registers kind-id code points for any kinds that the Usage
              defines.
</li>
<li>Defines the data structure for each of the kinds.
</li>
<li>Defines access control rules for each kinds.
</li>
<li>Defines how the Resource Name is formed that is hashed to
              form the Resource-ID where each kind is stored.
</li>
<li>Describes how values will be merged after a network
              partition. Unless otherwise specified, the default merging rule
              is to act as if all the values that need to be merged were
              stored and that the order they were stored in corresponds to the
              stored time values associated with (and carried in) their
              values. Because the stored time values are those associated with
              the peer which did the writing, clock skew is generally not an
              issue. If two nodes are on different partitions, clocks, this
              can create merge conflicts. However because RELOAD deliberately
              segregates storage so that data from different users and peers
              is stored in different locations, and a single peer will
              typically only be in a single network partition, this case will
              generally not arise.
</li>
</ul>

<p>The kinds defined by a usage may also be applied to other usages.
          However, a need for different parameters, such as different size
          limits, would imply the need to create a new kind.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Replication</h3>

<p>Replication in P2P overlays can be used to provide:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>persistence: </dt>
<dd>if the responsible peer crashes
              and/or if the storing peer leaves the overlay
</dd>
<dt>security: </dt>
<dd>to guard against DoS attacks by the
              responsible peer or routing attacks to that responsible peer
</dd>
<dt>load balancing: </dt>
<dd>to balance the load of queries
              for popular resources.
</dd>
</dl></blockquote>

<p>A variety of schemes are used in P2P overlays to achieve some of
          these goals. Common techniques include replicating on neighbors of
          the responsible peer, randomly locating replicas around the overlay,
          or replicating along the path to the responsible peer.
</p>
<p>The core RELOAD specification does not specify a particular
          replication strategy. Instead, the first level of replication
          strategies are determined by the overlay algorithm, which can base
          the replication strategy on the its particular topology. For
          example, Chord places replicas on successor peers, which will take
          over responsibility should the responsible peer fail <a class='info' href='#Chord'>[Chord]<span> (</span><span class='info'>Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, &ldquo;Chord: A Scalable Peer-to-peer Lookup Service for Internet           Applications,&rdquo; .</span><span>)</span></a>.
</p>
<p>If additional replication is needed, for example if data
          persistence is particularly important for a particular usage, then
          that usage may specify additional replication, such as implementing
          random replications by inserting a different well known constant
          into the Resource Name used to store each replicated copy of the
          resource. Such replication strategies can be added independent of
          the underlying algorithm, and their usage can be determined based on
          the needs of the particular usage.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Service Discovery</h3>

<p>RELOAD does not currently define a generic service discovery
        algorithm as part of the base protocol--although a TURN-specific
	discovery mechanism is provided. A variety of service discovery
        algorithm can be implemented as extensions to the base protocol, such
        as ReDIR <a class='info' href='#opendht-sigcomm05'>[opendht&#8209;sigcomm05]<span> (</span><span class='info'>Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J., Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu, &ldquo;OpenDHT: A Public DHT and its Uses,&rdquo; .</span><span>)</span></a>.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Application Connectivity</h3>

<p>There is no requirement that a RELOAD usage must use RELOAD's
        primitives for establishing its own communication if it already
        possesses its own means of establishing connections. For example, one
        could design a RELOAD-based resource discovery protocol which used
        HTTP to retrieve the actual data.
</p>
<p>For more common situations, however, the overlay itself is used to
        establish a connection rather than an external authority such as DNS,
        RELOAD provides connectivity to applications using the same Attach
        method as is used for the overlay maintenance. For example, if a
        P2PSIP node wishes to establish a SIP dialog with another P2PSIP node,
        it will use Attach to establish a direct connection with the other
        node. This new connection is separate from the peer protocol
        connection, it is a dedicated UDP or TCP flow used only for the SIP
        dialog. Each usage specifies which types of connections can be
        initiated using Attach.
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
P2PSIP Integration Overview</h3>

<p>The SIP Usage of RELOAD allows SIP user agents to provide a
      peer-to-peer telephony service without the requirement for permanent
      proxy or registration servers. In such a network, the RELOAD overlay
      itself performs the registration and rendezvous functions ordinarily
      associated with such servers.
</p>
<p>The basic function of the SIP usage is to allow Alice to start with a
      SIP URI (e.g., "bob@dht.example.com") and end up with a connection which
      Alice's SIP UA can use to pass SIP messages back and forth to Bob's SIP
      UA. The way this works is as follows:
</p>
<p></p>
<ol class="text">
<li>Bob, operating Node-ID 1234, stores a mapping from his URI to his
          Node-ID in the overlay. I.e., "sip:bob@dht.example.com -&gt;
          1234".
</li>
<li>Alice, operating Node-ID 5678, decides to call Bob. She looks up
          "sip:bob@dht.example.com" in the overlay and retrieves "1234".
</li>
<li>Alice uses the overlay to route an Attach message to Bob's peer.
          Bob responds with his own Attach and they set up a direct
          connection, as shown below.
</li>
</ol>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

Alice       Peer1      Overlay     PeerN      Bob
(5678)                                     (1234)
-------------------------------------------------
Attach -&gt;
          Attach -&gt;
                      Attach -&gt;
                                   Attach -&gt;
                                       &lt;- Attach
                                &lt;- Attach
                   &lt;- Attach
         &lt;- Attach

&lt;------------------ ICE Checks -----------------&gt;
INVITE -----------------------------------------&gt;
&lt;--------------------------------------------- OK
ACK --------------------------------------------&gt;
&lt;------------ ICE Checks for media -------------&gt;
&lt;-------------------- RTP ----------------------&gt;

</pre></div>
<p>It is important to note that RELOAD's only role here is to set up the
      direct connection between Alice and Bob. As soon as the ICE checks
      complete and the connection is established, then ordinary SIP is used.
      In particular, the establishment of the media channel for the phone call
      happens via the usual SIP mechanisms, and RELOAD is not involved. Media
      never goes over the overlay. After the successful exchange of SIP
      messages, call peers run ICE connectivity checks for media.
</p>
<p>As well as allowing mappings from AORs to Node-IDs, the SIP Usage
      also allows mappings from AORs to other AORs. For instance, if Bob
      wanted his phone calls temporarily forwarded to Charlie, he could store
      the mapping "sip:bob@dht.example.com -&gt; sip:charlie@dht.example.com".
      When Alice wants to call Bob, she retrieves this mapping and can then
      fetch Charlie's AOR to retrieve his Node-ID.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Overlay Management Protocol</h3>

<p>This section defines the basic protocols used to create, maintain,
      and use the RELOAD overlay network. We start by defining how messages
      are transmitted, received, and routed in an existing overlay, then
      define the message structure, and then finally define the messages used
      to join and maintain the overlay.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Message Routing</h3>

<p>This section describes procedures used by nodes to route messages
        through the overlay.
</p>
<a name="sec-request-origination"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1"></a><h3>6.1.1.&nbsp;
Request Origination</h3>

<p>In order to originate a message to a given Node-ID or
          resource-id, a node constructs an appropriate destination list. The
          simplest such destination list is a single entry containing the peer
          or resource-id. The resulting message will use the normal overlay
          routing mechanisms to forward the message to that destination. The
          node can also construct a more complicated destination list for
          source routing.
</p>
<p>Once the message is constructed, the node sends the message to
          some adjacent peer. If the first entry on the destination list is
          directly connected, then the message MUST be routed down that
          connection. Otherwise, the topology plugin MUST be consulted to
          determine the appropriate next hop.
</p>
<p>Parallel searches for the resource are a common solution to
          improve reliability in the face of churn or of subversive peers.
          Parallel searches for usage-specified replicas are managed by the
          usage layer. However, a single request can also be routed through
          multiple adjacent peers, even when known to be sub-optimal, to
          improve reliability <a class='info' href='#vulnerabilities-acsac04'>[vulnerabilities&#8209;acsac04]<span> (</span><span class='info'>Srivatsa, M. and L. Liu, &ldquo;Vulnerabilities and Security Threats in Structured           Peer-to-Peer Systems: A Quantitative Analysis,&rdquo; .</span><span>)</span></a>.
          Such parallel searches MAY BE specified by the topology plugin.
</p>
<p>Because messages may be lost in transit through the overlay,
          RELOAD incorporates an end-to-end reliability mechanism. When an
          originating node transmits a request it MUST set a 3 second timer.
          If a response has not been received when the timer fires, the
          request is retransmitted with the same transaction identifier. The
          request MAY be retransmitted up to 4 times (for a total of 5
          messages). After the timer for the fifth transmission fires, the
          message SHALL be considered to have failed. Note that this
          retransmission procedure is not followed by intermediate nodes. They
          follow the hop-by-hop reliability procedure described in <a class='info' href='#sec-reliability'>Section&nbsp;6.4.1.2<span> (</span><span class='info'>Reliability for Unreliable Transports</span><span>)</span></a>.
</p>
<p>
	    The above algorithm can result in multiple requests being
	    delivered to a node. Receiving nodes MUST generate semantically
	    equivalent responses to retransmissions of the same request
	    (this can be determined by transaction id) if the request is
	    received within the maximum request lifetime (15 seconds).
	    For some requests (e.g., FETCH) this can be accomplished merely
	    by processing the request again. For other requests,
	    (e.g., STORE) it
	    may be necessary to maintain state for the duration of the
	    request lifetime.
	  
</p>
<a name="sec-message-forwarding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2"></a><h3>6.1.2.&nbsp;
Message Receipt and Forwarding</h3>

<p>When a peer receives a message, it first examines the overlay,
          version, and other header fields to determine whether the message is
          one it can process. If any of these are incorrect (e.g., the message
          is for an overlay in which the peer does not participate) it is an
          error. The peer SHOULD generate an appropriate error but if local
          policy can override this in which case the messages is silently
          dropped.
</p>
<p>Once the peer has determined that the message is correctly
          formatted, it examines the first entry on the destination list.
          There are three possible cases here:
</p>
<p></p>
<ul class="text">
<li>The first entry on the destination list is an id for which
              the peer is responsible.
</li>
<li>The first entry on the destination list is a an id for which
              another peer is responsible.
</li>
<li>The first entry on the destination list is a private id which
              is being used for destination list compression.
</li>
</ul>

<p>These cases are handled as discussed below.
</p>
<a name="sec-responsible-id"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.1"></a><h3>6.1.2.1.&nbsp;
Responsible ID</h3>

<p>If the first entry on the destination list is a ID for which
            the node is responsible, there are several sub-cases. </p>
<ul class="text">
<li>If the entry is a Resource-Id, then it MUST be the only
                entry on the destination list. If there are other entries, the
                message MUST be silently dropped. Otherwise, the message is
                destined for this node and it passes it up to the upper
                layers.
</li>
<li>If the entry is a Node-Id which belongs to this node, then
                the message is destined for this node. If this is the only
                entry on the destination list, the message is destined for
                this node and is passed up to the upper layers. Otherwise the
                entry is removed from the destination list and the message is
                passed it to the routing layer. If the message is a response
                and there is state for the transaction ID, the state is
                reinserted into the destination list first.
</li>
<li>If the entry is a Node-Id which is not equal to this node,
                then the node MUST drop the message silently unless the
                Node-Id corresponds to a node which is directly connected to
                this node (i.e., a client). In that case, it MUST forward the
                message to the destination node as described in the next
                section.
</li>
</ul>

<p>
	      Note that this implies that in order to address a message to
	      "the peer that controls region X", a sender sends to resource-id
	      X, not Node-ID X.
	    
</p>
<a name="sec-other-id"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.2"></a><h3>6.1.2.2.&nbsp;
Other ID</h3>

<p>If neither of the other two cases applies, then the peer MUST
            forward the message towards the first entry on the destination
            list. This means that it MUST select one of the peers to which it
            is connected and which is likely to be responsible for the first
            entry on the destination list. If the first entry on the
            destination list is in the peer's connection table, then it SHOULD
            forward the message to that peer directly. Otherwise, it consult
            the routing table to forward the message.
</p>
<p>Any intermediate peer which forwards a RELOAD message MUST
            arrange that if it receives a response to that message the
            response can be routed back through the set of nodes through which
            the request passed. This may be arranged in one of two ways:
</p>
<p></p>
<ul class="text">
<li>The peer MAY add an entry to the via list in the forwarding
                header that will enable it to determine the correct node.
</li>
<li>The peer MAY keep per-transaction state which will allow it
                to determine the correct node.
</li>
</ul>

<p>As an example of the first strategy, if node D receives a
            message from node C with via list (A, B), then D would forward to
            the next node (E) with via list (A, B, C). Now, if E wants to
            respond to the message, it reverses the via list to produce the
            destination list, resulting in (D, C, B, A). When D forwards the
            response to C, the destination list will contain (C, B, A).
</p>
<p>As an example of the second strategy, if node D receives a
            message from node C with transaction ID X and via list (A, B), it
            could store (X, C) in its state database and forward the message
            with the via list unchanged. When D receives the response, it
            consults its state database for transaction id X, determines that
            the request came from C, and forwards the response to C.
</p>
<p>Intermediate peer which modify the via list are not required to
            simply add entries. The only requirement is that the peer be able
            to reconstruct the correct destination list on the return route.
            RELOAD provides explicit support for this functionality in the
            form of private IDs, which can replace any number of via list
            entries. For instance, in the above example, Node D might send E a
            via list containing only the private ID (I). E would then use the
            destination list (D, I) to send its return message. When D
            processes this destination list, it would detect that I is a
            private ID, recover the via list (A, B, C), and reverse that to
            produce the correct destination list (C, B, A) before sending it
            to C. This feature is called List Compression. I MAY either be a
            compressed version of the original via list or an index into a
            state database containing the original via list.
</p>
<p>Note that if an intermediate peer exits the overlay, then on
            the return trip the message cannot be forwarded and will be
            dropped. The ordinary timeout and retransmission mechanisms
            provide stability over this type of failure.
</p>
<a name="sec-private-Node-ID"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2.3"></a><h3>6.1.2.3.&nbsp;
Private ID</h3>

<p>If the first entry on the destination list is a private id
            (e.g., a compressed via list), the peer MUST that entry with the
            original via list that it replaced indexes and then re-examine the
            destination list to determine which case now applies.
</p>
<a name="sec-response-origination"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.3"></a><h3>6.1.3.&nbsp;
Response Origination</h3>

<p>When a peer sends a response to a request, it MUST construct the
          destination list by reversing the order of the entries on the via
          list. This has the result that the response traverses the same peers
          as the request traversed, except in reverse order (symmetric
          routing). Note that this rule will need to be relaxed if other
          routing algorithms are supported.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Message Structure</h3>

<p>RELOAD is a message-oriented request/response protocol. The
        messages are encoded using binary fields. All integers are represented
        in network byte order. The general philosophy behind the design was to
        use Type, Length, Value fields to allow for extensibility. However,
        for the parts of a structure that were required in all messages, we
        just define these in a fixed position as adding a type and length for
        them is unnecessary and would simply increase bandwidth and introduces
        new potential for interoperability issues.
</p>
<p>Each message has three parts, concatenated as shown below:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   +-------------------------+
   |    Forwarding Header    |
   +-------------------------+
   |    Message Contents     |
   +-------------------------+
   |       Signature         |
   +-------------------------+

</pre></div>
<p>The contents of these parts are as follows: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Forwarding Header:</dt>
<dd>Each message has a generic header
            which is used to forward the message between peers and to its
            final destination. This header is the only information that an
            intermediate peer (i.e., one that is not the target of a message)
            needs to examine.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Message Contents:</dt>
<dd>The message being delivered
            between the peers. From the perspective of the forwarding layer,
            the contents is opaque, however, it is interpreted by the higher
            layers.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Signature:</dt>
<dd>A digital signature over the message
            contents and parts of the header of the message. Note that this
            signature can be computed without parsing the message
            contents.
</dd>
</dl></blockquote>

<p>The following sections describe the format of each part of the
        message.
</p>
<a name="sec-presentation-language"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
Presentation Language</h3>

<p>The structures defined in this document are
          defined using a C-like syntax based on the presentation language
          used to define TLS. Advantages of this style include:
</p>
<p></p>
<ul class="text">
<li>It is easy to write and familiar enough looking that most
              readers can grasp it quickly.
</li>
<li>The ability to define nested structures allows a separation
              between high-level and low level message structures.
</li>
<li>It has a straightforward wire encoding that allows quick
              implementation, but the structures can be comprehended without
              knowing the encoding.
</li>
<li>The ability to mechanically (compile) encoders and
	      decoders.
</li>
</ul><p>
          
</p>
<p> This presentation is to some extent a placeholder. We
          consider it an open question what the final protocol definition
          method and encodings use. We expect this to be a question for the WG
          to decide. 
</p>
<p>Several idiosyncrasies of this language are worth noting.
</p>
<p></p>
<ul class="text">
<li>All lengths are denoted in bytes, not objects.
</li>
<li>Variable length values are denoted like arrays with angle
              brackets.
</li>
<li>"select" is used to indicate variant structures.
</li>
</ul>

<p>For instance, "uint16 array&lt;0..2^8-2&gt;;" represents up to
          254 bytes but only up to 127 values of two bytes (16 bits)
          each..
</p>
<a name="sec-definitions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1.1"></a><h3>6.2.1.1.&nbsp;
Common Definitions</h3>

<p>The following definitions are used throughout RELOAD and so are
            defined here. They also provide a convenient introduction to how
            to read the presentation language.
</p>
<p>An enum represents an enumerated type. The values associated
            with each possibility are represented in parentheses and the
            maximum value is represented as a nameless value, for purposes of
            describing the width of the containing integral type. For
            instance, Boolean represents a true or false:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       enum { false (0), true(1), (255)} Boolean;

</pre></div>
<p>A boolean value is either a 1 or a 0 and is represented as a
            single byte on the wire.
</p>
<p>The NodeId, shown below, represents a single Node-ID.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

           typedef opaque       NodeId[16];

</pre></div>
<p>A NodeId is a fixed-length 128-bit structure represented as a
            series of bytes, most significant byte first. Note: the use of
            "typedef" here is an extension to the TLS language, but its
            meaning should be relatively obvious.
</p>
<p>A ResourceId, shown below, represents a single resource-id.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

           typedef opaque       ResourceId&lt;0..2^8-1&gt;;

</pre></div>
<p>Like a NodeId, a resource-id is an opaque string of bytes, but
            unlike Node-IDs, resource-ids are variable length, up to 255 bytes
            (2048 bits) in length. On the wire, each ResourceId is preceded by
            a single length byte (allowing lengths up to 255). Thus, the
            3-byte value "Foo" would be encoded as: 03 46 4f 4f.
</p>
<p>A more complicated example is IpAddressPort, which represents a
            network address and can be used to carry either an IPv6 or IPv4
            address:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      enum {reserved_addr(0), ipv4_address (1), ipv6_address (2),
           (255)} AddressType;

      struct  {
        uint32                  addr;
        uint16                  port;
      } IPv4AddrPort;

      struct  {
        uint128                 addr;
        uint16                  port;
      } IPv6AddrPort;


      struct {
        AddressType             type;
        uint8                   length;

        select (type) {
          case ipv4_address:
             IPv4AddrPort       v4addr_port;

          case ipv6_address:
             IPv6AddrPort       v6addr_port;

          /* This structure can be extended */

       } IpAddressPort;

</pre></div>
<p>The first two fields in the structure are the same no matter
            what kind of address is being represented:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>type </dt>
<dd>
</dd>
<dt></dt>
<dd>the type of address (v4 or v6).
</dd>
<dt></dt>
<dd>
</dd>
<dt>length </dt>
<dd>
</dd>
<dt></dt>
<dd>the length of the rest of the structure.
</dd>
</dl></blockquote>

<p>By having the type and the length appear at the beginning of
            the structure regardless of the kind of address being represented,
            an implementation which does not understand new address type X can
            still parse the IpAddressPort field and then discard it if it is
            not needed.
</p>
<p>The rest of the IpAddressPort structure is either an
            IPv4AddrPort or an IPv6AddrPort. Both of these simply consist of
            an address represented as an integer and a 16-bit port. As an
            example, here is the wire representation of the IPv4 address
            "192.0.2.1" with port "6100".
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           01           ; type    = IPv4
           06           ; length  = 6
           c0 00 02 01  ; address = 192.0.2.1
           17 d4        ; port    = 6100
</pre></div>
<a name="sec-forwarding-header"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
Forwarding Header</h3>

<p>The forwarding header is defined as a ForwardingHeader
	  structure, as shown below.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      struct {
        uint32             relo_token;
        uint32             overlay;
        uint8              ttl;
        uint8              reserved;
        uint16             fragment;
        uint8              version;
        uint24             length;
        uint64             transaction_id;
        uint16             flags;

        uint16             via_list_length;
        uint16             destination_list_length;
        uint16             route_log_length;
        uint16             options_length;
        Destination        via_list[via_list_length];
        Destination        destination_list
                             [destination_list_length];
        RouteLogEntry      route_log[route_log_length];
        ForwardingOptions  options[options_length];
      } ForwardingHeader;
</pre></div>
<p>
	    The contents of the structure are:
	  
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>relo_token</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The first four bytes identify this message as a RELOAD message.
	    The message is easy to demultiplex from STUN messages by looking at
	    the first bit. This field MUST contain the value 
	    0xc2454c4f (the string 'RELO' with the high bit of the first
	    byte set.).
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>overlay</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The 32 bit checksum/hash of the overlay
	    being used. The variable length string representing the overlay name
	    is hashed with SHA-1 and the low order 32 bits are used. The purpose
	    of this field is to allow nodes to participate in multiple overlays
	    and to detect accidental misconfiguration. This is not a security
	    critical function.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>ttl</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    An 8 bit field indicating the number of
	    iterations, or hops, a message can experience before it is
	    discarded. The TTL value MUST be decremented by one at every hop
	    along the route the message traverses. If the TTL is 0, the message
	    MUST NOT be propagated further and MUST be discarded. The initial
	    value of the TTL should be TBD.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>fragment</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    This field is used to handle fragmentation. The high order
	    two bits are used to indicate the fragmentation status:
	    If the high bit (0x8000) is set, it indicates that the message is
	    a fragment. If the next bit (0x4000) is set, it indicates that this is the
	    last fragment.
	  
</dd>
<dt></dt>
<dd>
	    The remainder of the field is used to indicate the fragment
	      offset.
	      [[Open Issue: This is conceptually clear, but the details are
	      still lacking. Need to define the fragment offset and total length
	      be encoded in the header. Right now we have 14 bits reserved with
	      the intention that they be used for fragmenting, though additional
	      bytes in the header might be needed for fragmentation.]]
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>version</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The version of the RELOAD  protocol being used.
	    This document describes version 0.1, with a value of 0x01.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>length</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The count in bytes of the size of the
	    message, including the header.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>transaction_id</dt>
<dd>
</dd>
<dt></dt>
<dd> 
	    A unique 64 bit number that identifies this
	    transaction and also serves as a salt to randomize the request and
	    the response. Responses use the same Transaction ID as the request
	    they correspond to. Transaction IDs are also used for fragment
	    reassembly.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>flags</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The flags word contains control flags. Which are ORed together.
	    There is two currently
	    defined flags: ROUTE-LOG (0x1) and RESPONSE-ROUTE-LOG (0x2).
	    These flags indicate that the route log should be
	    included (see <a class='info' href='#sec-route-log'>Section&nbsp;6.2.2.2<span> (</span><span class='info'>Route Logging</span><span>)</span></a>.).
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>via_list_length</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The length of the via list in bytes. Note that in this field
	    and the following two length fields we depart from the usual
	    variable-length convention of having the length immediately
	    precede the value in order to make it easier for hardware
	    decoding engines to quickly determine the length of the header.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>destination_list_length</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The length of the destination list in bytes.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>route_log_length</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The length of the route log in bytes.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>options_length</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The length of the header options in bytes.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>via_list</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The via_list contains the sequence of destinations through which
	    the message has passed. The via_list starts out empty and grows as
	    the message traverses each peer.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>destination_list</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    The destination_list contains a sequence of destinations which
	    the message should pass through. The destination list is constructed
	    by the message originator. The first element in the destination list
	    is where the message goes next. The list shrinks as the message
	    traverses each listed peer.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>route_log</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    Contains a series of route log entries. See 
	    <a class='info' href='#sec-route-log'>Section&nbsp;6.2.2.2<span> (</span><span class='info'>Route Logging</span><span>)</span></a>.
	  
</dd>
<dt></dt>
<dd>
</dd>
<dt>options</dt>
<dd>
</dd>
<dt></dt>
<dd>
	    Contains a series of ForwardingOptions entries.
	    See <a class='info' href='#sec-forwarding-options'>Section&nbsp;6.2.2.3<span> (</span><span class='info'>Forwarding Options</span><span>)</span></a>.
	  
</dd>
</dl></blockquote><p>
	
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.1"></a><h3>6.2.2.1.&nbsp;
Destination and Via Lists</h3>

<p>The destination list and via lists are sequences of Destination
            values:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      enum {reserved(0), peer(1), resource(2), compressed(3), (255) }
           DestinationType;


      select (destination_type) {
        case peer:
           NodeId               node_id;

        case resource:
           ResourceId           resource_id;

        case compressed:
           opaque               compressed_id&lt;0..2^8-1&gt;;

        /* This structure may be extended with new types */

      } DestinationData;


      struct {
        DestinationType         type;
        uint8                   length;
        DestinationData         destination_data;
      } Destination;
</pre></div>
<p>This is a TLV structure with the following contents: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>type </dt>
<dd>
</dd>
<dt></dt>
<dd>The type of the DestinationData PDU. This may be one of
                "peer", "resource", or "compressed".
</dd>
<dt></dt>
<dd>
</dd>
<dt>length </dt>
<dd>
</dd>
<dt></dt>
<dd>The length of the destination_data.
</dd>
<dt></dt>
<dd>
</dd>
<dt>destination_value </dt>
<dd>
</dd>
<dt></dt>
<dd>The destination value itself, which is an encoded
                DestinationData structure, depending on the value of
                "type".
</dd>
</dl></blockquote>

<p></p>
<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>This structure encodes a type, length,
                value. The length field specifies the length of the
                DestinationData values, which allows the addition of new
                DestinationTypes. This allows an implementation which does not
                understand a given DestinationType to skip over it.
</dd>
</dl></blockquote>

<p>A DestinationData can be one of three types: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>peer</dt>
<dd>
</dd>
<dt></dt>
<dd>A Node-ID.
</dd>
<dt></dt>
<dd>
</dd>
<dt>compressed</dt>
<dd>
</dd>
<dt></dt>
<dd>A compressed list of Node-IDs and/or resources. Because
                this value was compressed by one of the peers, it is only
                meaningful to that peer and cannot be decoded by other peers.
                Thus, it is represented as an opaque string.
</dd>
<dt></dt>
<dd>
</dd>
<dt>resource</dt>
<dd>
</dd>
<dt></dt>
<dd>The Resource-ID of the resource which is desired. This type
                MUST only appear in the final location of a destination list
                and MUST NOT appear in a via list. It is meaningless to try to
                route through a resource.
</dd>
</dl></blockquote>

<a name="sec-route-log"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.2"></a><h3>6.2.2.2.&nbsp;
Route Logging</h3>

<p>The route logging feature provides diagnostic information about
            the path taken by the message so far and in this manner it is
            similar in function to <a class='info' href='#RFC3261'>SIP's<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., and J. Peterson, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a> [RFC3261] Via
            header field. If the ROUTE-LOG flag is set in the Flags word, at
            each hop peers MUST append a route log entry to the route log
            element in the header or reject the request. The order of the route
            log entry elements in the message is determined by the order of the
            peers were traversed along the path. The first route log entry
            corresponds to the peer at the first hop along the path, and each
            subsequent entry corresponds to the peer at the next hop along the
            path. If the ROUTE-LOG flag is set, the route log entries in the
            request MUST be copied to the response or the request rejected.  If,
            and only if, the ROUTE-LOG-RESPONSE flag is set in a request, the
            ROUTE-LOG flag MUST be set in the response.
</p>
<p>
            Note that use of the ROUTE-LOG-RESPONSE flag means that the response
            will grow on the return path, which may potentially mean that it
            gets dropped due to becoming too large for some intermediate
            hop. Thus, this option must be used with care.
</p>
<p>The route log is defined as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>


    enum { (255) } RouteLogExtensionType;

    struct {
      RouteLogExtensionType     type;
      uint16                    length;

      select (type){
        /* Extension values go here */
      } extension;
    } RouteLogExtension;

    enum { reserved(0), tcp_tls(1),  udp_dtls(2),  (255)}  Transport;

    struct {
      opaque                 version&lt;0..2^8-1&gt;;    /* A string */
      Transport              transport;            /* TCP or UDP */
      NodeId                 id;
      uint32                 uptime;
      IpAddressPort          address;
      opaque                 certificate&lt;0..2^16-1&gt;;
      RouteLogExtension      extensions&lt;0..2^16-1&gt;;
    } RouteLogEntry;

    struct {
       RouteLogEntry         entries&lt;0..2^16-1&gt;;
    } RouteLog;

</pre></div>
<p>The route log consists of an arbitrary number of RouteLogEntry
            values, each representing one node through which the message has
            passed.
</p>
<p>Each RouteLogEntry consists of the following values:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>version </dt>
<dd>
</dd>
<dt></dt>
<dd>A textual representation of the software version
</dd>
<dt></dt>
<dd>
</dd>
<dt>transport </dt>
<dd>
</dd>
<dt></dt>
<dd>The transport type, currently either "tcp_tls" or
                "udp_dtls".
</dd>
<dt></dt>
<dd>
</dd>
<dt>id </dt>
<dd>
</dd>
<dt></dt>
<dd>The Node-ID of the peer.
</dd>
<dt></dt>
<dd>
</dd>
<dt>uptime </dt>
<dd>
</dd>
<dt></dt>
<dd>The uptime of the peer in seconds.
</dd>
<dt></dt>
<dd>
</dd>
<dt>address </dt>
<dd>
</dd>
<dt></dt>
<dd>The address and port of the peer.
</dd>
<dt></dt>
<dd>
</dd>
<dt>certificate </dt>
<dd>
</dd>
<dt></dt>
<dd>The peer's certificate. Note that this may be omitted by
                setting the length to zero.
</dd>
<dt></dt>
<dd>
</dd>
<dt>extensions </dt>
<dd>
</dd>
<dt></dt>
<dd>Extensions, if any.
</dd>
</dl></blockquote>

<p>Extensions are defined using a RouteLogExtension structure. New
            extensions are defined by defining a new code point for
            RouteLogExtensionType and adding a new arm to the
            RouteLogExtension structure. The contents of that structure
            are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>type</dt>
<dd>
</dd>
<dt></dt>
<dd>The type of the extension.
</dd>
<dt></dt>
<dd>
</dd>
<dt>length</dt>
<dd>
</dd>
<dt></dt>
<dd>The length of the rest of the structure.
</dd>
<dt></dt>
<dd>
</dd>
<dt>extension</dt>
<dd>
</dd>
<dt></dt>
<dd>The extension value.
</dd>
</dl></blockquote>

<a name="sec-forwarding-options"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.3"></a><h3>6.2.2.3.&nbsp;
Forwarding Options</h3>

<p>
	      The Forwarding header can be extended with forwarding
	      header options, which are a series of ForwardingOptions
	      structures:
	    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    enum { (255) } ForwardingOptionsType;

    struct {
      ForwardingOptionsType     type;
      uint8                     flags;
      uint16                    length;
      select (type) {
        /* Option values go here */
      } option;
    } ForwardingOption;

</pre></div>
<p>
	      Each ForwardingOption consists of the following values:
	    
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>type</dt>
<dd>
</dd>
<dt></dt>
<dd>The type of the option.
</dd>
<dt></dt>
<dd>
</dd>
<dt>length</dt>
<dd>
</dd>
<dt></dt>
<dd>The length of the rest of the structure.
</dd>
<dt></dt>
<dd>
</dd>
<dt>flags</dt>
<dd>
</dd>
<dt></dt>
<dd> Three flags are defined FORWARD_CRITICAL(0x01),
	      DESTINATION_CRITICAL(0x02), and RESPONSE_COPY(0x04). These flags
	      MUST not be set in a response.

              If the FORWARD_CRITICAL flag is set, any node that would forward
              the message but does not understand this options MUST reject the
              request with an 757 error resonse.

              If the DESTINATION_CRITICAL flag is set, any node generates a
              response to the message but does not understand the forwarding
              option MUST reject the request with an 757 error resonse.

              If the RESPONSE_COPY flag is set, any node generating a response
              MUST copy the option from the request to the response and clear
              the RESPONSE_COPY, FORWARD_CRITICAL and DESTINATION_CRITICAL
              flags.  
</dd>
<dt></dt>
<dd>
</dd>
<dt>option</dt>
<dd>
</dd>
<dt></dt>
<dd>The option value.
</dd>
</dl></blockquote><p>
	    
</p>
<a name="sec-contents"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.3"></a><h3>6.2.3.&nbsp;
Message Contents Format</h3>

<p>The second major part of a RELOAD message is the contents part,
          which is defined by MessageContents:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       struct {
         MessageCode            message_code;
         opaque                 payload&lt;0..2^24-1&gt;;
       } MessageContents;

</pre></div>
<p>The contents of this structure are as follows: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>message_code </dt>
<dd>
</dd>
<dt></dt>
<dd>This indicates the message that is being sent. The code space
              is broken up as follows. 
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>0</dt>
<dd>Reserved
</dd>
<dt></dt>
<dd>
</dd>
<dt>1 .. 0x7fff</dt>
<dd>Requests and responses. These code
                  points are always paired, with requests being odd and the
                  corresponding response being the request code plus 1. Thus,
                  "ping_request" (the Ping request) has value 1 and
                  "ping_answer" (the Ping response) has value 2
</dd>
<dt></dt>
<dd>
</dd>
<dt>0xffff</dt>
<dd>Error
</dd>
</dl></blockquote>
</dd>
<dt></dt>
<dd>
</dd>
<dt>message_body </dt>
<dd>
</dd>
<dt></dt>
<dd>The message body itself, represented as a variable-length
              string of bytes. The bytes themselves are dependent on the code
              value. See the sections describing the various RELOAD methods
              (Join, Update, Attach, Store, Fetch, etc.) for the definitions
              of the payload contents.
</dd>
</dl></blockquote>

<a name="sec-response-code"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.3.1"></a><h3>6.2.3.1.&nbsp;
Response Codes and Response Errors</h3>

<p>A peer processing a request returns its status in the
            message_code field. If the request was a success, then the message
            code is the response code that matches the request (i.e., the next
            code up). The response payload is then as defined in the
            request/response descriptions.
</p>
<p>If the request failed, then the message code is set to 0xffff
            (error) and the payload MUST be an error_response PDU, as shown
            below.
</p>
<p>When the message code is 0xffff, the payload MUST be an
            ErrorResponse.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       public struct {
         uint16             error_code;
         opaque             reason_phrase&lt;0..2^8-1&gt;;  /* String*/
         opaque             error_info&lt;0..2^16-1&gt;;
       } ErrorResponse;

</pre></div>
<p>The contents of this structure are as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>error_code </dt>
<dd>
</dd>
<dt></dt>
<dd>A numeric error code indicating the error that
                occurred.
</dd>
<dt></dt>
<dd>
</dd>
<dt>reason_phrase </dt>
<dd>
</dd>
<dt></dt>
<dd>A free form text string indicating the reason for the
                response. The reason phrase SHOULD BE as indicated in the
                error code list below (e.g., "Moved Temporarily"). [[Open
                Issue: These reason phrases are pretty useless. Like the rest
                of this error system, They're a holdover from SIP. Should we
                remove?]]
</dd>
<dt></dt>
<dd>
</dd>
<dt>error_info </dt>
<dd>
</dd>
<dt></dt>
<dd>Payload specific error information. This MUST be empty
                (zero length) except as specified below.
</dd>
</dl></blockquote>

<p>The following error code values are defined. [[TODO: These are
            currently semi-aligned with SIP codes. that's probably bad and we
            need to fix.]
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>302 (Moved Temporarily):</dt>
<dd>The requesting peer
                SHOULD retry the request at the new address specified in the
                302 response message.
</dd>
<dt></dt>
<dd>
</dd>
<dt>401 (Unauthorized):</dt>
<dd>The requesting peer needs to
                sign and provide a certificate. [[TODO: The semantics here
                don't seem quite right.]]
</dd>
<dt></dt>
<dd>
</dd>
<dt>403 (Forbidden):</dt>
<dd>The requesting peer does not
                have permission to make this request.
</dd>
<dt></dt>
<dd>
</dd>
<dt>404 (Not Found):</dt>
<dd>The resource or peer cannot be
                found or does not exist.
</dd>
<dt></dt>
<dd>
</dd>
<dt>408 (Request Timeout):</dt>
<dd>A response to the request
                has not been received in a suitable amount of time. The
                requesting peer MAY resend the request at a later time.
</dd>
<dt></dt>
<dd>
</dd>
<dt>412 (Precondition Failed):</dt>
<dd>A request can't be
                completed because some precondition was incorrect. For
                instance, the wrong generation counter was provided
</dd>
<dt></dt>
<dd>
</dd>
<dt>498 (Incompatible with Overlay)</dt>
<dd>A peer receiving
                the request is using a different overlay, overlay algorithm,
                or hash algorithm. [[Open Issue: What is the best error number
                and reason phrase to use?]]
</dd>
<dt></dt>
<dd>
</dd>
<dt>757 (Unsupported Forwarding Option)</dt>
<dd>A peer receiving
                the request with a forwarnding options flaged as critical but the peer does not support this option. See section <a class='info' href='#sec-forwarding-options'>Section&nbsp;6.2.2.3<span> (</span><span class='info'>Forwarding Options</span><span>)</span></a>. [[Open Issue: What is the best error number
                and reason phrase to use?]]
</dd>
</dl></blockquote>

<a name="sec-signature"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.4"></a><h3>6.2.4.&nbsp;
Signature</h3>

<p>The third part of a RELOAD message is the signature, represented
          by a Signature structure. The message signature is computed over the
          payload and parts of forwarding header. The payload, in case of a
          Store, may contain an additional signature computed over a StoreReq
          structure. All signatures are formatted using the Signature element.
          This element is also used in other contexts where signatures are
          needed. The input structure to the signature computation varies
          depending on the data element being signed.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>


       enum {reserved(0), signer_identity_peer (1),
             signer_identity_name (2), signer_identity_certificate (3),
             (255)} SignerIdentityType;

       select (identity_type) {
         case signer_identity_peer:
           NodeId               id;

         case signer_identity_name:
           opaque               name&lt;0..2^16-1&gt;;

         case signer_identity_certificate:
           opaque               certificate&lt;0..2^16-1&gt;;

         /* This structure may be extended with new types */
       } SignerIdentityValue;


       struct {
         SignerIdentityType     identity_type;
         uint16                 length;
         SignerIdentityValue    identity[SignerIdentity.length];
       } SignerIdentity;


       struct  {
          SignatureAndHashAlgorithm     algorithm;
          SignerIdentity                identity;
          opaque                        signature_value&lt;0..2^16-1&gt;;
       } Signature;


</pre></div>
<p>The signature construct contains the following values:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>algorithm </dt>
<dd>
</dd>
<dt></dt>
<dd>The signature algorithm in use. The algorithm definitions are
              found in the IANA TLS SignatureAlgorithm Registry.
</dd>
<dt></dt>
<dd>
</dd>
<dt>identity </dt>
<dd>
</dd>
<dt></dt>
<dd>The identity or certificate used to form the signature
</dd>
<dt></dt>
<dd>
</dd>
<dt>signature_value </dt>
<dd>
</dd>
<dt></dt>
<dd>The value of the signature
</dd>
</dl></blockquote>

<p>A number of possible identity formats are permitted. The current
          possibilities are: a Node-ID, a user name, and a certificate.
</p>
<p>For signatures over messages the input to the signature is
          computed over:
</p>
<p></p>
<blockquote class="text">
<p>overlay + transaction_id + MessageContents +
              SignerIdentity
</p>
</blockquote>

<p>Where overlay and transaction_id come from the forwarding header
          and + indicates concatenation.
</p>
<p>[[TODO: Check the inputs to this carefully.]]
</p>
<p>The input to signatures over data values is different, and is
          described in <a class='info' href='#sec-data-sig'>Section&nbsp;7.1<span> (</span><span class='info'>Data Signature Computation</span><span>)</span></a>.
</p>
<a name="sec-overlay-topology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Overlay Topology</h3>

<p>As discussed in previous sections, RELOAD does not itself implement
        any overlay topology. Rather, it relies on Topology Plugins, which
        allow a variety of overlay algorithms to be used while maintaining the
        same RELOAD core. This section describes the requirements for new
        topology plugins and the methods that RELOAD provides for overlay
        topology maintenance.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.1"></a><h3>6.3.1.&nbsp;
Topology Plugin Requirements</h3>

<p>When specifying a new overlay algorithm, at least the following
          need to be described:
</p>
<p></p>
<ul class="text">
<li>Joining procedures, including the contents of the Join
              message.
</li>
<li>Stabilization procedures, including the contents of the
              Update message, the frequency of topology probes and keepalives,
              and the mechanism used to detect when peers have
              disconnected.
</li>
<li>Exit procedures, including the contents of the Leave
              message.
</li>
<li>The length of the Resource-IDs and Node-IDs. For DHTs, the
              hash algorithm to compute the hash of an identifier.
</li>
<li>The procedures that peers use to route messages.
</li>
<li>The replication strategy used to ensure data redundancy.
</li>
</ul>

<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2"></a><h3>6.3.2.&nbsp;
Methods and types for use by topology plugins</h3>

<p>This section describes the methods that topology plugins use to
          join, leave, and maintain the overlay.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.1"></a><h3>6.3.2.1.&nbsp;
Join</h3>

<p>A new peer (but which already has credentials) uses the JoinReq
            message to join the overlay. The JoinReq is sent to the
            responsible peer depending on the routing mechanism described in
            the topology plugin. This notifies the responsible peer that the
            new peer is taking over some of the overlay and it needs to
            synchronize its state.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       struct {
          NodeId                joining_peer_id;
          opaque                overlay_specific_data&lt;0..2^16-1&gt;;
       } JoinReq;

</pre></div>
<p>The minimal JoinReq contains only the Node-ID which the sending
            peer wishes to assume. Overlay algorithms MAY specify other data
            to appear in this request.
</p>
<p>If the request succeeds, the responding peer responds with a
            JoinAns message, as defined below:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       struct {
          opaque                overlay_specific_data&lt;0..2^16-1&gt;;
       } JoinAns;
</pre></div>
<p>If the request succeeds, the responding peer MUST follow up by
            executing the right sequence of Stores and Updates to transfer the
            appropriate section of the overlay space to the joining peer. In
            addition, overlay algorithms MAY define data to appear in the
            response payload that provides additional info.
</p>
<p>
	      In general,
	      nodes which cannot form connections SHOULD report an
	      error. However, implementations MUST provide some
	      mechanism whereby nodes can determine they are
	      potentially the first node and take responsibility
	      for the overlay. This specification does not mandate
	      any particular mechanism, but a configuration flag
	      or setting seems appropriate.
	    
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.2"></a><h3>6.3.2.2.&nbsp;
Leave</h3>

<p>The LeaveReq message is used to indicate that a node is exiting
            the overlay. A node SHOULD send this message to each peer with
            which it is directly connected prior to exiting the overlay.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       public struct {
          NodeId                leaving_peer_id;
          opaque                overlay_specific_data&lt;0..2^16-1&gt;;
       } LeaveReq;

</pre></div>
<p>LeaveReq contains only the Node-ID of the leaving
            peer. Overlay algorithms MAY specify other data to appear in this
            request.
</p>
<p>Upon receiving a Leave request, a peer MUST update its own
            routing table, and send the appropriate Store/Update sequences to
            re-stabilize the overlay.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.3"></a><h3>6.3.2.3.&nbsp;
Update</h3>

<p>Update is the primary overlay-specific maintenance message. It
            is used by the sender to notify the recipient of the sender's view
            of the current state of the overlay (its routing state) and it is
            up to the recipient to take whatever actions are appropriate to
            deal with the state change.
</p>
<p>The contents of the UpdateReq message are completely
            overlay-specific. The UpdateAns response is expected to be either
            success or an error.
</p>
<a name="sec-route-query"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.4"></a><h3>6.3.2.4.&nbsp;
Route_Query</h3>

<p>The Route_Query request allows the sender to ask a peer where
            they would route a message directed to a given destination. In
            other words, a RouteQuery for a destination X requests the Node-ID
            where the receiving peer would next route to get to X. A
            RouteQuery can also request that the receiving peer initiate an
            Update request to transfer his routing table.
</p>
<p>One important use of the RouteQuery request is to support
            iterative routing. The sender selects one of the peers in its
            routing table and sends it a RouteQuery message with the
            destination_object set to the Node-ID or Resource-ID it wishes to
            route to. The receiving peer responds with information about the
            peers to which the request would be routed. The sending peer MAY
            then Attaches to that peer(s), and repeats the RouteQuery.
            Eventually, the sender gets a response from a peer that is closest
            to the identifier in the destination_object as determined by the
            topology plugin. At that point, the sender can send messages
            directly to that peer.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.4.1"></a><h3>6.3.2.4.1.&nbsp;
Request Definition</h3>

<p>A RouteQueryReq message indicates the peer or resource that
              the requesting peer is interested in. It also contains a
              "send_update" option allowing the requesting peer to request a
              full copy of the other peer's routing table.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       struct {
         Boolean                send_update;
         Destination            destination;
         opaque                 overlay_specific_data&lt;0..2^16-1&gt;;
       } RouteQueryReq;

</pre></div>
<p>The contents of the RouteQueryReq message are as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>send_update </dt>
<dd>
</dd>
<dt></dt>
<dd>A single byte. This may be set to "true" to indicate that
                  the requester wishes the responder to initiate an Update
                  request immediately. Otherwise, this value MUST be set to
                  "false".
</dd>
<dt></dt>
<dd>
</dd>
<dt>destination </dt>
<dd>
</dd>
<dt></dt>
<dd>The destination which the requester is interested in.
                  This may be any valid destination object, including a
                  Node-ID, compressed ids, or resource-id.
</dd>
<dt></dt>
<dd>
</dd>
<dt>overlay_specific_data </dt>
<dd>
</dd>
<dt></dt>
<dd>Other data as appropriate for the overlay.
</dd>
</dl></blockquote>

<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.2.4.2"></a><h3>6.3.2.4.2.&nbsp;
Response Definition</h3>

<p>A response to a successful RouteQueryReq request is a
              RouteQueryAns message. This is completely overlay specific.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Forwarding Layer</h3>

<p>Each node maintains connections to a set of other nodes defined by
        the topology plugin. 
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1"></a><h3>6.4.1.&nbsp;
Transports</h3>

<p>RELOAD can use multiple transports to send its messages. Because
          ICE is used to establish connections (see <a class='info' href='#sec-ice-reload'>Section&nbsp;6.4.2.1.3<span> (</span><span class='info'>Using ICE With RELOAD</span><span>)</span></a>), RELOAD nodes are able to detect
          which transports are offered by other nodes and establish
          connections between each other. Any transport protocol needs to be
          able to establish a secure, authenticated connection, and provide
          data origin authentication and message integrity for individual data
          elements. RELOAD currently supports two transport protocols:
</p>
<p></p>
<ul class="text">
<li>TLS [REF] over TCP
</li>
<li>DTLS <a class='info' href='#RFC4347'>[RFC4347]<span> (</span><span class='info'>Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security,&rdquo; April&nbsp;2006.</span><span>)</span></a> over UDP
</li>
</ul>

<p>Note that although UDP does not properly have "connections", both
          TLS and DTLS have a handshake which establishes a stateful
          association, a similar stateful construct, and we simply refer to
          these as "connections" for the purposes of this document.
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1.1"></a><h3>6.4.1.1.&nbsp;
Future Support for HIP</h3>

<p>The P2PSIP Working Group has expressed interest in supporting a
            HIP-based transport. Such support would require specifying such
            details as:
</p>
<p></p>
<ul class="text">
<li>How to issue certificates which provided identities
                meaningful to the HIP base exchange. We anticipate that this
                would require a mapping between ORCHIDs and NodeIds.
</li>
<li>How to carry the HIP I1 and I2 messages. We anticipate that
                this would require defining a HIP Tunnel usage.
</li>
<li>How to carry RELOAD messages over HIP.
</li>
</ul>

<p>We leave this work as a topic for another draft.
</p>
<a name="sec-reliability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1.2"></a><h3>6.4.1.2.&nbsp;
Reliability for Unreliable Transports</h3>

<p>When RELOAD is carried over DTLS or another unreliable
            transport, it needs to be used with a reliability and congestion
            control mechanism, which is provided on a hop-by-hop basis,
            matching the semantics if TCP were used. The basic principle is
            that each message, regardless of if it carries a request or
            responses, will get an ACK and be reliably retransmitted. The
            receiver's job is very simple, limited to just sending ACKs. All
            the complexity is at the sender side. This allows the sending
            implementation to trade off performance versus implementation
            complexity without affecting the wire protocol.
</p>
<p>In order to support unreliable transport, each message is
            wrapped in a very simple framing layer (FramedMessage) which is
            only used for each hop. This layer contains a sequence number
            which can then be used for ACKs.
</p>
<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1.2.1"></a><h3>6.4.1.2.1.&nbsp;
Framed Message Format</h3>

<p>The definition of FramedMessage is:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      enum {data (128), ack (129), (255)} FramedMessageType;

      struct {
        FramedMessageType       type;

        select (type) {
          case data:
            uint24              sequence;
            opaque              message&lt;0..2^24-1&gt;;

          case ack:
            uint24              ack_sequence;
            uint32              received;
        };
      } FramedMessage;


</pre></div>
<p>The type field of the PDU is set to indicate whether the
              message is data or an acknowledgement. Note that these values
              have been set to force the first bit to be high, thus allowing
              easy demultiplexing with STUN. All FramedMessageType values must
              be &gt; 128.
</p>
<p>If the message is of type "data", then the remainder of the
              PDU is as follows: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>sequence </dt>
<dd>
</dd>
<dt></dt>
<dd>the sequence number
</dd>
<dt></dt>
<dd>
</dd>
<dt>message </dt>
<dd>
</dd>
<dt></dt>
<dd>the original message that is being transmitted.
</dd>
</dl></blockquote>

<p>Each connection has it own sequence number. Initially the
              value is zero and it increments by exactly one for each message
              sent over that connection.
</p>
<p>When the receiver receive a message, it SHOULD immediately
              send an ACK message. The receiver MUST keep track of the 32 most
              recent sequence numbers received on this association in order to
              generate the appropriate ack.
</p>
<p>If the PDU is of type "ack", the contents are as follows:
              </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>ack_sequence </dt>
<dd>
</dd>
<dt></dt>
<dd>The sequence number of the message being
                  acknowledged.
</dd>
<dt></dt>
<dd>
</dd>
<dt>received </dt>
<dd>
</dd>
<dt></dt>
<dd>A bitmask indicating whether or not each of the previous
                  32 packets has been received before the sequence number in
                  ack_sequence. The high order bit represents the first packet
                  in the sequence space.
</dd>
</dl></blockquote>

<p>The received field bits in the ACK provide a very high degree
              of redundancy for the sender to figure out which packets the
              receiver received and can then estimate packet loss rates. If
              the sender also keeps track of the time at which recent sequence
              numbers were sent, the RTT can be estimated.
</p>
<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1.2.2"></a><h3>6.4.1.2.2.&nbsp;
Retransmission and Flow Control</h3>

<p>Because the receiver's role is limited to providing packet
              acknowledgements, a wide variety of congestion control
              algorithms can be implemented on the sender side while using the
              same basic wire protocol. It is RECOMMENDED that senders
              implement TFRC-SP <a class='info' href='#RFC4828'>[RFC4828]<span> (</span><span class='info'>Floyd, S. and E. Kohler, &ldquo;TCP Friendly Rate Control (TFRC): The Small-Packet (SP)           Variant,&rdquo; April&nbsp;2007.</span><span>)</span></a> and use the
              received bitmask to allow the sender to compute packet loss
              event rates. Senders MUST implement a retransmission and
              congestion control scheme no more aggressive then TFRC-SP.
</p>
<a name="sec-frag-reass"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1.3"></a><h3>6.4.1.3.&nbsp;
Fragmentation and Reassembly</h3>

<p>In order to allow transport over datagram protocols, RELOAD
            messages may be fragmented. If a message is too large for a peer
            to transmit to the next peer it MUST fragment the message. Note
            that this implies that intermediate peers may re-fragment messages
            if the incoming and outgoing paths have different maximum datagram
            sizes. Intermediate peers SHOULD NOT reassemble fragments.
</p>
<p>Upon receipt of a fragmented message by the intended peer, the
            peer holds the fragments in a holding buffer until the entire
            message has been received. The message is then reassembled into a
            single unfragmented message and processed. In order to mitigate
            denial of service attacks, receivers SHOULD time out incomplete
            fragments. [[TODO: Describe algorithm]]
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2"></a><h3>6.4.2.&nbsp;
Connection Management Methods</h3>

<p>This section defines the methods RELOAD uses to form and maintain
          connections between nodes in the overlay. Three methods are
          defined:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Attach: </dt>
<dd>used to form connections between nodes.
              When node A wants to connect to node B, it sends an Attach
              message to node B through the overlay. The Attach contains A's
              ICE parameters. B responds with its ICE parameters and the two
              nodes perform ICE to form connection.
</dd>
<dt>Ping: </dt>
<dd>is a simple request/response which is used
              to verify connectivity (analogous to the UNIX ping command)
              along a path and to gather a small amount of information about
              the resources held by the target peer
</dd>
<dt>Tunnel: </dt>
<dd>in some cases, it will be too expensive
              for an application layer protocol to set up a connection in
              order to send a small number of messages. The Tunnel message
              allows applications to route individual application layer
              protocol messages through the overlay.
</dd>
</dl></blockquote>

<a name="sec-connect-details"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1"></a><h3>6.4.2.1.&nbsp;
Attach</h3>

<p>A node sends an Attach request when it wishes to establish a
            direct TCP or UDP connection to another node for the purposes of
            sending RELOAD messages or application layer protocol messages,
            such as SIP. Detailed procedures for the Attach and its response
            are described in <a class='info' href='#sec-connect-details'>Section&nbsp;6.4.2.1<span> (</span><span class='info'>Attach</span><span>)</span></a>.
</p>
<p>An Attach in and of itself does not result in updating the
            routing table of either node. That function is performed by
            Updates. If node A has Attached to node B, but not received any
            Updates from B, it MAY route messages which are directly addressed
            to B through that channel but MUST NOT route messages through B to
            other peers via that channel. The process of Attaching is
            separate from the process of becoming a peer (using Update) to
            prevent half-open states where a node has started to form
            connections but is not really ready to act as a peer.
</p>
<a name="sec-connect-request"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.1"></a><h3>6.4.2.1.1.&nbsp;
Request Definition</h3>

<p>An AttachReq message contains the requesting peer's ICE
              connection parameters formatted into a binary structure.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      typedef opaque            IceCandidate&lt;0..2^16-1&gt;;

      struct  {
        opaque                  ufrag&lt;0..2^8-1&gt;;
        opaque                  password&lt;0..2^8-1&gt;;
        uint16                  application;
        opaque                  role&lt;0..2^8-1&gt;;
        IceCandidate            candidates&lt;0..2^16-1&gt;;
      } AttachReqAns;

</pre></div>
<p>The values contained in AttachReq and AttachAns are: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>ufrag </dt>
<dd>
</dd>
<dt></dt>
<dd>The username fragment (from ICE)
</dd>
<dt></dt>
<dd>
</dd>
<dt>password </dt>
<dd>
</dd>
<dt></dt>
<dd>The ICE password.
</dd>
<dt></dt>
<dd>
</dd>
<dt>application </dt>
<dd>
</dd>
<dt></dt>
<dd>A 16-bit port number. This port number represents the
                  IANA registered port of the protocol that is going to be
                  sent on this connection. For SIP, this is 5060 or 5061, and
                  for RELOAD is TBD. By using the IANA registered port, we
                  avoid the need for an additional registry and allow RELOAD
                  to be used to set up connections for any existing or future
                  application protocol.
</dd>
<dt></dt>
<dd>
</dd>
<dt>role </dt>
<dd>
</dd>
<dt></dt>
<dd>An active/passive/actpass attribute from RFC 4145 <a class='info' href='#RFC4145'>[RFC4145]<span> (</span><span class='info'>Yon, D. and G. Camarillo, &ldquo;TCP-Based Media Transport in the Session Description Protocol           (SDP),&rdquo; September&nbsp;2005.</span><span>)</span></a>.
</dd>
<dt></dt>
<dd>
</dd>
<dt>candidates </dt>
<dd>
</dd>
<dt></dt>
<dd>One or more ICE candidate values in the string
		  representation used in ordinary ICE. [[OPEN ISSUE:
		  This is convenient for stacks, but unaesthetic.]]
		  Each candidate has an
                  IP address, IP address family, port, transport protocol,
                  priority, foundation, component ID, STUN type and related
                  address. The candidate_list is a list of string candidate
                  values from ICE.
</dd>
</dl></blockquote>

<p>These values should be generated using the procedures
              described in <a class='info' href='#sec-ice-reload'>Section&nbsp;6.4.2.1.3<span> (</span><span class='info'>Using ICE With RELOAD</span><span>)</span></a>.
</p>
<a name="sec-connect-response"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.2"></a><h3>6.4.2.1.2.&nbsp;
Response Definition</h3>

<p>If a peer receives an Attach request, it SHOULD follow the
              process the request and generate its own response with a
              AttachReqAns. It should then begin ICE checks. When a peer
              receives an Attach response, it SHOULD parse the response and
              begin its own ICE checks.
</p>
<a name="sec-ice-reload"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.3"></a><h3>6.4.2.1.3.&nbsp;
Using ICE With RELOAD</h3>

<p>This section describes the profile of ICE that is used with
              RELOAD. RELOAD implementations MUST implement full ICE. Because
              RELOAD always tries to use TCP and then UDP as a fallback, there
              will be multiple candidates of the same IP version, which
              requires full ICE.
</p>
<p>In ICE as defined by <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for           Network Address Translator (NAT) Traversal for Offer/Answer           Protocols,&rdquo; June&nbsp;2007.</span><span>)</span></a>, SDP is used to carry the
              ICE parameters. In RELOAD, this function is performed by a
              binary encoding in the Attach method. This encoding is more
              restricted than the SDP encoding because the RELOAD environment
              is simpler:
</p>
<p></p>
<ul class="text">
<li>Only a single media stream is supported.
</li>
<li>In this case, the "stream" refers not to RTP or other
                  types of media, but rather to a connection for RELOAD itself
                  or for SIP signaling.
</li>
<li>RELOAD only allows for a single offer/answer exchange.
                  Unlike the usage of ICE within SIP, there is never a need to
                  send a subsequent offer to update the default candidates to
                  match the ones selected by ICE.
</li>
</ul>

<p>An agent follows the ICE specification as described in <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for           Network Address Translator (NAT) Traversal for Offer/Answer           Protocols,&rdquo; June&nbsp;2007.</span><span>)</span></a> and <a class='info' href='#I-D.ietf-mmusic-ice-tcp'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice&#8209;tcp]<span> (</span><span class='info'>Rosenberg, J., &ldquo;TCP Candidates with Interactive Connectivity Establishment           (ICE,&rdquo; March&nbsp;2007.</span><span>)</span></a> with the changes and
              additional procedures described in the subsections below.
</p>
<a name="sec-collect"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.4"></a><h3>6.4.2.1.4.&nbsp;
Collecting STUN Servers</h3>

<p>ICE relies on the node having one or more STUN servers to
              use. In conventional ICE, it is assumed that nodes are
              configured with one or more STUN servers through some
              out-of-band mechanism. This is still possible in RELOAD but
              RELOAD also learns STUN servers as it connects to other peers.
              Because all RELOAD peers implement ICE and use STUN keepalives,
              every peer is a STUN server <a class='info' href='#I-D.ietf-behave-rfc3489bis'>[I&#8209;D.ietf&#8209;behave&#8209;rfc3489bis]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Session Traversal Utilities for (NAT) (STUN),&rdquo; March&nbsp;2007.</span><span>)</span></a>. Accordingly, any
              peer a node knows will be willing to be a STUN server -- though
              of course it may be behind a NAT.
</p>
<p>A peer on a well-provisioned wide-area overlay will be
              configured with one or more bootstrap peers. These peers make an
              initial list of STUN servers. However, as the peer forms
              connections with additional peers, it builds more peers it can
              use as STUN servers.
</p>
<p>Because complicated NAT topologies are possible, a peer may
              need more than one STUN server. Specifically, a peer that is
              behind a single NAT will typically observe only two IP addresses
              in its STUN checks: its local address and its server reflexive
              address from a STUN server outside its NAT. However, if there
              are more NATs involved, it may discover that it learns
              additional server reflexive addresses (which vary based on where
              in the topology the STUN server is). To maximize the chance of
              achieving a direct connection, a peer SHOULD group other peers
              by the peer-reflexive addresses it discovers through them. It
              SHOULD then select one peer from each group to use as a STUN
              server for future connections.
</p>
<p>Only peers to which the peer currently has connections may be
              used. If the connection to that host is lost, it MUST be removed
              from the list of stun servers and a new server from the same
              group SHOULD be selected.
</p>
<a name="sec-gather"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.5"></a><h3>6.4.2.1.5.&nbsp;
Gathering Candidates</h3>

<p>When a node wishes to establish a connection for the purposes
              of RELOAD signaling or SIP signaling (or any other application
              protocol for that matter), it follows the process of gathering
              candidates as described in Section 4 of ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for           Network Address Translator (NAT) Traversal for Offer/Answer           Protocols,&rdquo; June&nbsp;2007.</span><span>)</span></a>. RELOAD utilizes a single
              component, as does SIP. Consequently, gathering for these
              "streams" requires a single component.
</p>
<p>An agent MUST implement ICE-tcp <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for           Network Address Translator (NAT) Traversal for Offer/Answer           Protocols,&rdquo; June&nbsp;2007.</span><span>)</span></a>, and MUST gather at least
              one UDP and one TCP host candidate for RELOAD and for SIP.
</p>
<p>The ICE specification assumes that an ICE agent is configured
              with, or somehow knows of, TURN and STUN servers. RELOAD
              provides a way for an agent to learn these by querying the
              overlay, as described in <a class='info' href='#sec-collect'>Section&nbsp;6.4.2.1.4<span> (</span><span class='info'>Collecting STUN Servers</span><span>)</span></a> and
              <a class='info' href='#sec-turn-server'>Section&nbsp;9<span> (</span><span class='info'>TURN Server Usage</span><span>)</span></a>.
</p>
<p>The agent SHOULD prioritize its TCP-based candidates over its
              UDP-based candidates in the prioritization described in Section
              4.1.2 of ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for           Network Address Translator (NAT) Traversal for Offer/Answer           Protocols,&rdquo; June&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The default candidate selection described in Section 4.1.3 of
              ICE is ignored; defaults are not signaled or utilized by
              RELOAD.
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.6"></a><h3>6.4.2.1.6.&nbsp;
Encoding the Attach Message</h3>

<p>Section 4.3 of ICE describes procedures for encoding the SDP
              for conveying RELOAD or SIP ICE candidates. Instead of actually
              encoding an SDP, the candidate information (IP address and port
              and transport protocol, priority, foundation, component ID, type
              and related address) is carried within the attributes of the
              Attach request or its response. Similarly, the username
              fragment and password are carried in the Attach message or its
              response. <a class='info' href='#sec-connect-details'>Section&nbsp;6.4.2.1<span> (</span><span class='info'>Attach</span><span>)</span></a> describes
              the detailed attribute encoding for Attach. The Attach request
              and its response do not contain any default candidates or the
              ice-lite attribute, as these features of ICE are not used by
              RELOAD. The Attach request and its response also contain a
              application attribute, with a value of SIP or RELOAD, which
              indicates what protocol is to be run over the connection. The
              RELOAD Attach request MUST only be utilized to set up
              connections for application protocols that can be multiplexed
              with STUN.
</p>
<p>Since the Attach request contains the candidate information
              and short term credentials, it is considered as an offer for a
              single media stream that happens to be encoded in a format
              different than SDP, but is otherwise considered a valid offer
              for the purposes of following the ICE specification. Similarly,
              the Attach response is considered a valid answer for the
              purposes of following the ICE specification.
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.7"></a><h3>6.4.2.1.7.&nbsp;
Verifying ICE Support</h3>

<p>An agent MUST skip the verification procedures in Section 5.1
              and 6.1 of ICE. Since RELOAD requires full ICE from all agents,
              this check is not required.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.8"></a><h3>6.4.2.1.8.&nbsp;
Role Determination</h3>

<p>The roles of controlling and controlled as described in
              Section 5.2 of ICE are still utilized with RELOAD. However, the
              offerer (the entity sending the Attach request) will always be
              controlling, and the answerer (the entity sending the Attach
              response) will always be controlled. The connectivity checks
              MUST still contain the ICE-CONTROLLED and ICE-CONTROLLING
              attributes, however, even though the role reversal capability
              for which they are defined will never be needed with RELOAD.
              This is to allow for a common codebase between ICE for RELOAD
              and ICE for SDP.
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.9"></a><h3>6.4.2.1.9.&nbsp;
Connectivity Checks</h3>

<p>The processes of forming check lists in Section 5.7 of ICE,
              scheduling checks in Section 5.8, and checking connectivity
              checks in Section 7 are used with RELOAD without change.
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.10"></a><h3>6.4.2.1.10.&nbsp;
Concluding ICE</h3>

<p>The controlling agent MUST utilize regular nomination. This
              is to ensure consistent state on the final selected pairs
              without the need for an updated offer, as RELOAD does not
              generate additional offer/answer exchanges.
</p>
<p>The procedures in Section 8 of ICE are followed to conclude
              ICE, with the following exceptions:
</p>
<p></p>
<ul class="text">
<li>The controlling agent MUST NOT attempt to send an updated
                  offer once the state of its single media stream reaches
                  Completed.
</li>
<li>Once the state of ICE reaches Completed, the agent can
                  immediately free all unused candidates. This is because
                  RELOAD does not have the concept of forking, and thus the
                  three second delay in Section 8.3 of ICE does not apply.
</li>
</ul>

<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.11"></a><h3>6.4.2.1.11.&nbsp;
Subsequent Offers and Answers</h3>

<p>An agent MUST NOT send a subsequent offer or answer. Thus,
              the procedures in Section 9 of ICE MUST be ignored.
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.12"></a><h3>6.4.2.1.12.&nbsp;
Media Keepalives</h3>

<p>STUN MUST be utilized for the keepalives described in Section
              10 of ICE.
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.13"></a><h3>6.4.2.1.13.&nbsp;
Sending Media</h3>

<p>The procedures of Section 11 apply to RELOAD as well.
              However, in this case, the "media" takes the form of application
              layer protocols (RELOAD or SIP for example) over TLS or DTLS.
              Consequently, once ICE processing completes, the agent will
              begin TLS or DTLS procedures to establish a secure connection.
	      The node which sent the Attach request MUST be the TLS server.
	      The other node MUST be the TLS client.
              The nodes MUST verify that the certificate presented in the
              handshake matches the identity of the other peer as found in the
              Attach message. Once the TLS or DTLS signaling is complete, the
              application protocol is free to use the connection.
</p>
<p>The concept of a previous selected pair for a component does
              not apply to RELOAD, since ICE restarts are not possible with
              RELOAD.
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.1.14"></a><h3>6.4.2.1.14.&nbsp;
Receiving Media</h3>

<p>An agent MUST be prepared to receive packets for the
              application protocol (TLS or DTLS carrying RELOAD, SIP or
              anything else) at any time. The jitter and RTP considerations in
              Section 11 of ICE do not apply to RELOAD or SIP.
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.2"></a><h3>6.4.2.2.&nbsp;
Ping</h3>

<p>Ping provides a number of primitive "exploration" services:
	    (1) it is used to test connectivity along a path (2) it allows
	     node to determine which resources another node is responsible
	     for (3) it allows some discovery services in multicast settings.
	     A ping can be
            addressed to a specific Node-ID, the peer controlling a given
            location (by using a resource ID) or to the broadcast Node-ID (all
            1s). In either case, the target Node-IDs respond with a simple
            response containing some status information.
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.2.1"></a><h3>6.4.2.2.1.&nbsp;
Request Definition</h3>

<p>The PingReq message contains a list (potentially empty) of
              the pieces of status information that the requester would like
              the responder to provide.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      enum { responsible_set(1), num_resources(2), (255)}
           PingInformationType;

      struct {
        PingInformationType     requested_info&lt;0..2^8-1&gt;;
      } PingReq

</pre></div>
<p>The two currently defined values for PingInformation are:
</p>
<p>  </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>responsible_set</dt>
<dd>
</dd>
<dt></dt>
<dd>indicates that the peer should Respond with the fraction of
                the overlay for which the responding peer is responsible.
</dd>
<dt></dt>
<dd>
</dd>
<dt>num_resources</dt>
<dd>
</dd>
<dt></dt>
<dd>indicates that the peer should Respond with the number of
                resources currently being stored by the peer.
</dd>
</dl></blockquote><p> 
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.2.2"></a><h3>6.4.2.2.2.&nbsp;
Response Definition</h3>

<p>A successful PingAns response contains the information
              elements requested by the peer.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       struct {
         PingInformationType    type;

         select (type) {
           case responsible_set:
             uint32             responsible_ppb;

           case num_resources:
             uint32             num_resources;

           /* This type may be extended */

         };
       } PingInformation;

       struct {
         uint64                 response_id;
         PingInformation        ping_info&lt;0..2^16-1&gt;;
       } PingAns;


</pre></div>
<p>A PingAns message contains the following elements: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>response_id </dt>
<dd>
</dd>
<dt></dt>
<dd>A randomly generated 64-bit response ID. This is used to
                  distinguish Ping responses in cases where the Ping request
                  is multicast.
</dd>
<dt></dt>
<dd>
</dd>
<dt>ping_info </dt>
<dd>
</dd>
<dt></dt>
<dd>A sequence of PingInformation structures, as shown
                  below.
</dd>
</dl></blockquote>

<p>Each of the current possible Ping information types is a
              32-bit unsigned integer. For type "responsible_ppb", it is the
              fraction of the overlay for which the peer is responsible in
              parts per billion. For type "num_resources", it is the number of
              resources the peer is storing.
</p>
<p>The responding peer SHOULD include any values that the
              requesting peer requested and that it recognizes. They SHOULD be
              returned in the requested order. Any other values MUST NOT be
              returned.
</p>
<a name="sec-tunnel-details"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.3"></a><h3>6.4.2.3.&nbsp;
Tunnel</h3>

<p>A node sends a Tunnel request when it wishes to exchange
            application-layer protocol messages without the expense of
            establishing a direct connection via Attach or when ICE is unable
            to establish a direct connection via Attach and a TURN relay is
            not available. The application-level protocols that are routed via
            the Tunnel request are defined by that application's usage.
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Note:</dt>
<dd>The decision of whether to route
                application-level traffic across the overlay or to open a
                direct connection requires careful consideration of the
                overhead involved in each transaction. Establishing a direct
                connection requires greater initial setup costs, but after
                setup, communication is faster and imposes no overhead on the
                overlay. For example, for the SIP usage, an INVITE request to
                establish a voice call might be routed over the overlay, a
                SUBSCRIBE with regular updates would be better used with a
                Attach, and media would both impose too great a load on the
                overlay and likely receive unacceptable performance. However,
                there may be a tradeoff between locating TURN servers and
                relying on Tunnel for packet routing.
</dd>
</dl></blockquote>

<p>When a usage requires the Tunnel method, it must specify the
            specific application protocol(s) that will be Tunneled and for
            each protocol, specify:
</p>
<p></p>
<ul class="text">
<li>An application attribute that indicates the protocol being
                tunneled. This the IANA-registered port of the application
                protocol.
</li>
<li>The conditions under which the application will be Tunneled
                over the overlay rather than using a direct Attach.
</li>
<li>A mechanism for moving future application-level
                communication from Tunneling on the overlay to a direct
                Connection, or an explanation why this is unnecessary.
</li>
<li>A means of associating messages together as required for
                dialog-oriented or request/response-oriented protocols.
</li>
<li>How the Tunneled message (and associated responses) will be
                delivered to the correct application. This is particularly
                important if there might be multiple instances of the
                application on or behind a single peer.
</li>
</ul>

<a name="sec-tunnel-request"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.3.1"></a><h3>6.4.2.3.1.&nbsp;
Request Definition</h3>

<p>The TunnelReq message contains the application PDU that the
              requesting peer wishes to transmit, along with some control
              information identifying the handling of the PDU.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       struct  {
         uint16                 application;
         opaque                 dialog_id&lt;0..2^8-1&gt;;
         opaque                 application_pdu&lt;0..2^24-1&gt;;
       } TunnelReq;

</pre></div>
<p>The values contained in the TunnelReq are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>application </dt>
<dd>
</dd>
<dt></dt>
<dd>A 16-bit port number. This port number represents the
                  IANA registered port of the protocol that is going to be
                  sent on this connection. For SIP, this is 5060 or 5061, and
                  for RELOAD is TBD. By using the IANA registered port, we
                  avoid the need for an additional registry and allow RELOAD
                  to be used to set up connections for any existing or future
                  application protocol.
</dd>
<dt></dt>
<dd>
</dd>
<dt>dialog_id </dt>
<dd>
</dd>
<dt></dt>
<dd>An arbitrary string providing an application-defined way
                  of associating related Tunneled messages. This attribute may
                  also encode sequence information as required by the
                  application protocol.
</dd>
<dt></dt>
<dd>
</dd>
<dt>application_pdu </dt>
<dd>
</dd>
<dt></dt>
<dd>An application PDU in the format specified by the
                  application.
</dd>
</dl></blockquote>

<a name="sec-tunnel-response"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2.3.2"></a><h3>6.4.2.3.2.&nbsp;
Response Definition</h3>

<p>A TunnelAns message serves as confirmation that the message
              was received by the destination peer. It implies nothing about
              the processing of the application. If the application protocol
              specifies an acknowledgement or confirmation, that must be sent
              with a separate Tunnel request. The TunnelAns message is empty
              (has a zero length payload)
</p>
<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Data Storage Protocol</h3>

<p>RELOAD provides a set of generic mechanisms for storing and
      retrieving data in the Overlay Instance. These mechanisms can be used
      for new applications simply by defining new code points and a small set
      of rules. No new protocol mechanisms are required.
</p>
<p>The basic unit of stored data is a single StoredData structure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      struct {
        uint32                  length;
        uint64                  storage_time;
        uint32                  lifetime;
        StoredDataValue         value;
        Signature               signature;
      } StoredData;


</pre></div>
<p>The contents of this structure are as follows: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>length </dt>
<dd>
</dd>
<dt></dt>
<dd>The length of the rest of the structure in octets.
</dd>
<dt></dt>
<dd>
</dd>
<dt>storage_time </dt>
<dd>
</dd>
<dt></dt>
<dd>The time when the data was stored in absolute time, represented
          in seconds since the Unix epoch. Any attempt to store a data value
          with a storage time before that of a value already stored at this
          location MUST generate a 412 error. This prevents rollback attacks.
          Note that this does not require synchronized clocks: the receiving
          peer uses the storage time in the previous store, not its own
          clock.
</dd>
<dt></dt>
<dd>
</dd>
<dt>lifetime </dt>
<dd>
</dd>
<dt></dt>
<dd>The validity period for the data, in seconds, starting from the
          time of store.
</dd>
<dt></dt>
<dd>
</dd>
<dt>value </dt>
<dd>
</dd>
<dt></dt>
<dd>The data value itself, as described in <a class='info' href='#sec-kind-model'>Section&nbsp;7.2<span> (</span><span class='info'>Data Models</span><span>)</span></a>.
</dd>
<dt></dt>
<dd>
</dd>
<dt>signature </dt>
<dd>
</dd>
<dt></dt>
<dd>A signature over the data value. <a class='info' href='#sec-data-sig'>Section&nbsp;7.1<span> (</span><span class='info'>Data Signature Computation</span><span>)</span></a> describes the signature computation.
          The element is formatted as described in <a class='info' href='#sec-signature'>Section&nbsp;6.2.4<span> (</span><span class='info'>Signature</span><span>)</span></a>
</dd>
</dl></blockquote>

<p>Each resource-id specifies a single location in the Overlay Instance.
      However, each location may contain multiple StoredData values
      distinguished by kind-id. The definition of a kind describes both the
      data values which may be stored and the data model of the data. Some
      data models allow multiple values to be stored under the same kind-id.
      Section <a class='info' href='#sec-kind-model'>Section&nbsp;7.2<span> (</span><span class='info'>Data Models</span><span>)</span></a> describes the available
      data models. Thus, for instance, a given resource-id might contain a
      single-value element stored under kind-id X and an array containing
      multiple values stored under kind-id Y.
</p>
<a name="sec-data-sig"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Data Signature Computation</h3>

<p>Each StoredData element is individually signed. However, the
        signature also must be self-contained and cover the kind-id and
        resource-id even though they are not present in the StoredData
        structure. The input to the signature algorithm is:
</p>
<p></p>
<blockquote class="text">
<p>resource_id + kind + StoredData
</p>
</blockquote>

<p>Where these values are: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>resource </dt>
<dd>
</dd>
<dt></dt>
<dd>The resource ID where this data is stored.
</dd>
<dt></dt>
<dd>
</dd>
<dt>kind </dt>
<dd>
</dd>
<dt></dt>
<dd>The kind-id for this data.
</dd>
<dt></dt>
<dd>
</dd>
<dt>StoredData </dt>
<dd>
</dd>
<dt></dt>
<dd>The contents of the stored data value, as described in the
            previous sections.
</dd>
</dl></blockquote>

<p>[OPEN ISSUE: Should we include the identity in the string that
        forms the input to the signature algorithm?.]
</p>
<p>Once the signature has been computed, the signature is represented
        using a signature element, as described in <a class='info' href='#sec-signature'>Section&nbsp;6.2.4<span> (</span><span class='info'>Signature</span><span>)</span></a>.
</p>
<a name="sec-kind-model"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Data Models</h3>

<p>The protocol currently defines the following data models:
</p>
<p></p>
<ul class="text">
<li>single value
</li>
<li>array
</li>
<li>dictionary
</li>
</ul>

<p>These are represented with the StoredDataValue structure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

      enum { reserved(0), single_value(1), array(2),
             dictionary(3), (255)} DataModel;

      struct {
        Boolean                exists;
        opaque                 value&lt;0..2^32-1&gt;;
      } DataValue;


      struct {
        DataModel                 model;

        select (model) {
          case single_value:
            DataValue             single_value_entry;

          case array:
            ArrayEntry            array_entry;

          case dictionary:
            DictionaryEntry       dictionary_entry;


          /* This structure may be extended */
        } ;
      } StoredDataValue;

</pre></div>
<p>We now discuss the properties of each data model in turn:
</p>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.1"></a><h3>7.2.1.&nbsp;
Single Value</h3>

<p>A single-value element is a simple, opaque sequence of bytes.
          There may be only one single-value element for each resource-id,
          kind-id pair.
</p>
<p>A single value element is represented as a DataValue, which
          contains the following two elements:
</p>
<p>

	  </p>
<blockquote class="text"><dl>
<dt>exists</dt>
<dd>
</dd>
<dt></dt>
<dd>This value indicates whether the value exists at all. If it
              is set to False, it means that no value is present. If it is
              True, that means that a value is present. This gives the
              protocol a mechanism for indicating nonexistence as opposed to
              emptiness.
</dd>
<dt></dt>
<dd>
</dd>
<dt>value</dt>
<dd>
</dd>
<dt></dt>
<dd>The stored data.
</dd>
</dl></blockquote>

<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.2"></a><h3>7.2.2.&nbsp;
Array</h3>

<p>An array is a set of opaque values addressed by an integer index.
          Arrays are zero based. Note that arrays can be sparse. For instance,
          a Store of "X" at index 2 in an empty array produces an array with
          the values [ NA, NA, "X"]. Future attempts to fetch elements at
          index 0 or 1 will return values with "exists" set to False.
</p>
<p>A array element is represented as an ArrayEntry:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       struct {
         uint32                  index;
         DataValue               value;
       } ArrayEntry;


</pre></div>
<p>The contents of this structure are: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>index</dt>
<dd>
</dd>
<dt></dt>
<dd>The index of the data element in the array.
</dd>
<dt></dt>
<dd>
</dd>
<dt>value</dt>
<dd>
</dd>
<dt></dt>
<dd>The stored data.
</dd>
</dl></blockquote>

<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.3"></a><h3>7.2.3.&nbsp;
Dictionary</h3>

<p>A dictionary is a set of opaque values indexed by an opaque key
          with one value for each key. single dictionary entry is represented
          as follows
</p>
<p>A dictionary element is represented as a DictionaryEntry:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       typedef opaque           DictionaryKey&lt;0..2^16-1&gt;;

       struct {
         DictionaryKey          key;
         DataValue              value;
       } DictionaryEntry;


</pre></div>
<p>The contents of this structure are: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>key</dt>
<dd>
</dd>
<dt></dt>
<dd>The dictionary key for this value.
</dd>
<dt></dt>
<dd>
</dd>
<dt>value</dt>
<dd>
</dd>
<dt></dt>
<dd>The stored data.
</dd>
</dl></blockquote>

<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Data Storage Methods</h3>

<p>RELOAD provides several methods for storing and retrieving
        data:
</p>
<p></p>
<ul class="text">
<li>Store values in the overlay
</li>
<li>Fetch values from the overlay
</li>
<li>Remove values from the overlay
</li>
<li>Find the values stored at an individual peer
</li>
</ul>

<p>These methods are each described in the following sections.
</p>
<a name="sec-store"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1"></a><h3>7.3.1.&nbsp;
Store</h3>

<p>The Store method is used to store data in the overlay. The format
          of the Store request depends on the data model which is determined
          by the kind.
</p>
<a name="sec-store-req"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1.1"></a><h3>7.3.1.1.&nbsp;
Request Definition</h3>

<p>A StoreReq message is a sequence of StoreKindData values, each
            of which represents a sequence of stored values for a given kind.
            The same kind-id MUST NOT be used twice in a given store request.
            Each value is then processed in turn. These operations MUST be
            atomic. If any operation fails, the state MUST be rolled back to
            before the request was received.
</p>
<p>The store request is defined by the StoreReq structure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     struct {
         KindId                 kind;
         DataModel              data_model;
         uint64                 generation_counter;
         StoredData             values&lt;0..2^32-1&gt;;
     } StoreKindData;

     struct {
         ResourceId             resource;
         uint8                  replica_number;
         StoreKindData          kind_data&lt;0..2^32-1&gt;;
     } StoreReq;

</pre></div>
<p>A single Store request stores data of a number of kinds to a
            single resource location. The contents of the structure are: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>resource </dt>
<dd>
</dd>
<dt></dt>
<dd>The resource to store at.
</dd>
<dt></dt>
<dd>
</dd>
<dt>replica_number </dt>
<dd>
</dd>
<dt></dt>
<dd>The number of this replica. When a storing peer saves
                replicas to other peers each peer is assigned a replica number
                starting from 1 and sent in the Store message. This field is
                set to 0 when a node is storing its own data. This allows
                peers to distinguish replica writes from original writes.
</dd>
<dt></dt>
<dd>
</dd>
<dt>kind_data </dt>
<dd>
</dd>
<dt></dt>
<dd>A series of elements, one for each kind of data to be
                stored.
</dd>
</dl></blockquote>

<p>If the replica number is zero, then the peer MUST check that it
            is responsible for the resource and if not reject the request. If
            the replica number is nonzero, then the peer MUST check that it
            expects to be a replica for the resource and if not reject the
            request.
</p>
<p>Each StoreKindData element represents the data to be stored for
            a single kind-id. The contents of the element are: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>kind </dt>
<dd>
</dd>
<dt></dt>
<dd>The kind-id. Implementations SHOULD reject requests
                corresponding to unknown kinds unless specifically configured
                otherwise.
</dd>
<dt></dt>
<dd>
</dd>
<dt>data_model </dt>
<dd>
</dd>
<dt></dt>
<dd>The data model of the data. The kind defines what this has
                to be so this is redundant in the case where the software
                interpreting the messages understands the kind.
</dd>
<dt></dt>
<dd>
</dd>
<dt>generation </dt>
<dd>
</dd>
<dt></dt>
<dd>The expected current state of the generation counter
                (approximately the number of times this object has been
                written, see below for details).
</dd>
<dt></dt>
<dd>
</dd>
<dt>values </dt>
<dd>
</dd>
<dt></dt>
<dd>The value or values to be stored. This may contain one or
                more stored_data values depending on the data model associated
                with each kind.
</dd>
</dl></blockquote>

<p>The peer MUST perform the following checks:
</p>
<p></p>
<ul class="text">
<li>The kind_id is known and supported.
</li>
<li>The data_model matches the kind_id.
</li>
<li>The signatures over each individual data element (if any)
                are valid.
</li>
<li>Each element is signed by a credential which is authorized
                to write this kind at this resource-id
</li>
<li>For original (non-replica) stores, the peer MUST check that
                if the generation-counter is non-zero, it equals the current
                value of the generation-counter for this kind. This feature
                allows the generation counter to be used in a way similar to
                the HTTP Etag feature.
</li>
<li>The storage time values are greater than that of any value
                which would be replaced by this Store. [[OPEN ISSUE: do peers
                need to save the storage time of Removes to prevent
                reinsertion?]]
</li>
</ul>

<p>If all these checks succeed, the peer MUST attempt to store the
            data values. For non-replica stores, if the store succeeds and the
            data is changed, then the peer must increase the generation
            counter by at least one. If there are multiple stored values in a
            single StoreKindData, it is permissible for the peer to increase
            the generation counter by only 1 for the entire kind-id, or by 1
            or more than one for each value. Accordingly, all stored data
            values must have a generation counter of 1 or greater. 0 is used
            by other nodes to indicate that they are indifferent to the
            generation counter's current value. For replica Stores, the peer
            MUST set the generation counter to match the generation_counter in
            the message. Replica Stores MUST NOT use a generation counter of
            0.
</p>
<p>The properties of stores for each data model are as follows:
            </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Single-value:</dt>
<dd>
</dd>
<dt></dt>
<dd>A store of a new single-value element creates the element
                if it does not exist and overwrites any existing value. with
                the new value.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Array:</dt>
<dd>
</dd>
<dt></dt>
<dd>A store of an array entry replaces (or inserts) the given
                value at the location specified by the index. Because arrays
                are sparse, a store past the end of the array extends it with
                nonexistent values (exists=False) as required. A store at
                index 0xffffffff places the new value at the end of the array
                regardless of the length of the the array. The resulting
                StoredData has the correct index value when it is subsequently
                fetched.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Dictionary:</dt>
<dd>
</dd>
<dt></dt>
<dd>A store of a dictionary entry replaces (or inserts) the
                given value at the location specified by the dictionary 
                key.
</dd>
</dl></blockquote>

<p>The following figure shows the relationship between these
            structures for an example store which stores the following values
            at resource "1234"
</p>
<p></p>
<ul class="text">
<li>The value "abc" in the single value slot for kind X
</li>
<li>The value "foo" at index 0 in the array for kind Y
</li>
<li>The value "bar" at index 1 in the array for kind Y
</li>
</ul>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                  Store
                              resource=1234
                                 /      \
                                /        \
                    StoreKindData        StoreKindData
                       kind=X               kind=Y
                 model=Single-Value       model=Array
                         |                    /\
                         |                   /  \
                     StoredData             /    \
                         |                 /      \
                         |           StoredData  StoredData
                  StoredDataValue        |           |
                   value="abc"           |           |
                                         |           |
                                StoredDataValue  StoredDataValue
                                      index=0      index=1
                                   value="foo"    value="bar"

</pre></div>
<a name="anchor74"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1.2"></a><h3>7.3.1.2.&nbsp;
Response Definition</h3>

<p>In response to a successful Store request the peer MUST return
            a StoreAns message containing a series of StoreKindResponse
            elements containing the current value of the generation counter
            for each kind-id, as well as a list of the peers where the data
            was replicated.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      struct {
        KindId                  kind;
        uint64                  generation_counter;
        NodeId                  replicas&lt;0..2^16-1&gt;;
      } StoreKindResponse;


      struct {
        StoreKindResponse       kind_responses&lt;0..2^16-1&gt;;
      } StoreAns;

</pre></div>
<p>The contents of each StoreKindResponse are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>kind </dt>
<dd>
</dd>
<dt></dt>
<dd>The kind-id being represented.
</dd>
<dt></dt>
<dd>
</dd>
<dt>generation </dt>
<dd>
</dd>
<dt></dt>
<dd>The current value of the generation counter for that
                kind-id.
</dd>
<dt></dt>
<dd>
</dd>
<dt>replicas </dt>
<dd>
</dd>
<dt></dt>
<dd>The list of other peers at which the data was/will-be
                replicated. In overlays and applications where the responsible
                peer is intended to store redundant copies, this allows the
                storing peer to independently verify that the replicas were in
                fact stored by doing its own Fetch.
</dd>
</dl></blockquote>

<p>The response itself is just StoreKindResponse values packed
            end-to-end.
</p>
<p>If any of the generation counters in the request precede the
            corresponding stored generation counter, then the peer MUST fail
            the entire request and respond with a 412 error. The error_info in
            the ErrorResponse MUST be a StoreAns response containing the
            correct generation counter for each kind and empty replicas
            lists.
</p>
<a name="anchor75"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2"></a><h3>7.3.2.&nbsp;
Fetch</h3>

<p>The Fetch request retrieves one or more data elements stored at a
          given resource-id. A single Fetch request can retrieve multiple
          different kinds.
</p>
<a name="anchor76"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2.1"></a><h3>7.3.2.1.&nbsp;
Request Definition</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      struct {
        int32            first;
        int32            last;
      } ArrayRange;

      struct {
        KindId                  kind;
        DataModel               model;
        uint64                  generation;
        uint16                  length;

        select (model) {
          case single_value: ;    /* Empty */

          case array:
               ArrayRange       indices&lt;0..2^16-1&gt;;

          case dictionary:
               DictionaryKey    keys&lt;0..2^16-1&gt;;

          /* This structure may be extended */

        } model_specifier;
      } StoredDataSpecifier;

      struct {
        ResourceId              resource;
        StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
      } FetchReq;

</pre></div>
<p>The contents of the Fetch requests are as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>resource </dt>
<dd>
</dd>
<dt></dt>
<dd>The resource ID to fetch from.
</dd>
<dt></dt>
<dd>
</dd>
<dt>specifiers </dt>
<dd>
</dd>
<dt></dt>
<dd>A sequence of StoredDataSpecifier values, each specifying
                some of the data values to retrieve.
</dd>
</dl></blockquote>

<p>Each StoredDataSpecifier specifies a single kind of data to
            retrieve and (if appropriate) the subset of values that are to be
            retrieved. The contents of the StoredDataSpecifier structure are
            as follows:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>kind </dt>
<dd>
</dd>
<dt></dt>
<dd>The kind-id of the data being fetched. Implementations
                SHOULD reject requests corresponding to unknown kinds unless
                specifically configured otherwise.
</dd>
<dt></dt>
<dd>
</dd>
<dt>model </dt>
<dd>
</dd>
<dt></dt>
<dd>The data model of the data. This must be checked against
                the kind-id.
</dd>
<dt></dt>
<dd>
</dd>
<dt>generation </dt>
<dd>
</dd>
<dt></dt>
<dd>The last generation counter that the requesting peer saw.
                This may be used to avoid unnecessary fetches or it may be set
                to zero.
</dd>
<dt></dt>
<dd>
</dd>
<dt>length </dt>
<dd>
</dd>
<dt></dt>
<dd>The length of the rest of the structure, thus allowing
                extensibility.
</dd>
<dt></dt>
<dd>
</dd>
<dt>model_specifier </dt>
<dd>
</dd>
<dt></dt>
<dd>A reference to the data value being requested within the
                data model specified for the kind. For instance, if the data
                model is "array", it might specify some subset of the
                values.
</dd>
</dl></blockquote>

<p>The model_specifier is as follows:
</p>
<p></p>
<ul class="text">
<li>If the data is of data model single value, the specifier is
                empty.
</li>
<li>If the data is of data model array, the specifier contains
                of a list of ArrayRange elements, each of which contains two
                integers. two integers. The first integer is the beginning of
                the range and the second is the end of the range. 0 is used to
                indicate the first element and 0xffffffff is used to indicate
                the final element. The beginning of the range MUST be earlier
                in the array then the end. The ranges MUST be
                non-overlapping.
</li>
<li>If the data is of data model dictionary then the specifier
                contains a list of the dictionary keys being requested. If no
                keys are specified, than this is a wildcard fetch and all
                key-value pairs are returned. [[TODO: We really need a way to
                return only the keys. We'll need to modify this.]]
</li>
</ul>

<p>The generation-counter is used to indicate the requester's
            expected state of the storing peer. If the generation-counter in
            the request matches the stored counter, then the storing peer
            returns a response with no StoredData values.
</p>
<p>Note that because the certificate for a user is typically
            stored at the same location as any data stored for that user, a
            requesting peer which does not already have the user's certificate
            should request the certificate in the Fetch as an
            optimization.
</p>
<a name="anchor77"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2.2"></a><h3>7.3.2.2.&nbsp;
Response Definition</h3>

<p>The response to a successful Fetch request is a FetchAns
            message containing the data requested by the requester.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       struct {
         KindId                 kind;
         uint64                 generation;
         StoredData             values&lt;0..2^32-1&gt;;
       } FetchKindResponse;

       struct {
         FetchKindResponse      kind_responses&lt;0..2^32-1&gt;;
       } FetchAns;

</pre></div>
<p>The FetchAns structure contains a series of FetchKindResponse
            structures. There MUST be one FetchKindResponse element for each
            kind-id in the request.
</p>
<p>The contents of the FetchKindResponse structure are as follows:
            </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>kind </dt>
<dd>
</dd>
<dt></dt>
<dd>the kind that this structure is for.
</dd>
<dt></dt>
<dd>
</dd>
<dt>generation </dt>
<dd>
</dd>
<dt></dt>
<dd>the generation counter for this kind.
</dd>
<dt></dt>
<dd>
</dd>
<dt>values </dt>
<dd>
</dd>
<dt></dt>
<dd>the relevant values. If the generation counter in the
                request matches the generation-counter in the stored data,
                then no StoredData values are returned. Otherwise, all
                relevant data values MUST be returned. A nonexistent value is
                represented with "exists" set to False.
</dd>
</dl></blockquote>

<p>There is one subtle point about signature computation on
            arrays. If the storing node uses the append feature (where the
            index=0xffffffff), then the index in the StoredData that is
            returned will not match that used by the storing node, which would
            break the signature. In order to avoid this issue, the index value
            in array is set to zero before the signature is computed. This
            implies that malicious storing nodes can reorder array entries
            without being detected. [[OPEN ISSUE: We've considered a number of
            alternate designs here that would preserve security against this
            attack if the storing node did not use the append feature.
            However, they are more complicated for one or both sides. If this
            attack is considered serious, we can introduce one of them.]]
</p>
<a name="anchor78"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.3"></a><h3>7.3.3.&nbsp;
Remove</h3>

<p>The Remove request is used to remove a stored element or elements
          from the storing peer. Any successful remove of an existing element
          for a given kind MUST increment the generation counter by at least
          1.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      struct {
        ResourceId              resource;
        StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
      } RemoveReq;


</pre></div>
<p>A RemoveReq has exactly the same syntax as a Fetch request except
          that each entry represents a set of values to be removed rather than
          returned. The same kind-id MUST NOT be used twice in a given
          RemoveReq. Each specifier is then processed in turn. These
          operations MUST be atomic. If any operation fails, the state MUST be
          rolled back to before the request was received.
</p>
<p>Before processing the Remove request, the peer MUST perform the
          following checks.
</p>
<p></p>
<ul class="text">
<li>The kind-id is known.
</li>
<li>The signature over the message is valid or (depending on
              overlay policy) no signature is required.
</li>
<li>The signer of the message has permissions which permit him to
              remove this kind of data. Although each kind defines its own
              access control requirements, in general only the original signer
              of the data should be allowed to remove it.
</li>
<li>If the generation-counter is non-zero, it must equal the
              current value of the generation-counter for this kind. This
              feature allows the generation counter to be used in a way
              similar to the HTTP Etag feature.
</li>
</ul>

<p>Assuming that the request is permitted, the operations proceed as
          follows.
</p>
<a name="anchor79"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.3.1"></a><h3>7.3.3.1.&nbsp;
Single Value</h3>

<p>A Remove of a single value element causes it not to exist. If
            no such element exists, then this is a silent success.
</p>
<a name="anchor80"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.3.2"></a><h3>7.3.3.2.&nbsp;
Array</h3>

<p>A Remove of an array element (or element range) replaces those
            elements with null elements. Note that this does not cause the
            array to be packed. An array which contains ["A", "B", "C"] and
            then has element 0 removed produces an array containing [NA, "B",
            "C"]. Note, however, that the removal of the final element of the
            array shortens the array, so in the above case, the removal of
            element 2 makes the array ["A", "B"].
</p>
<a name="anchor81"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.3.3"></a><h3>7.3.3.3.&nbsp;
Dictionary</h3>

<p>A Remove of a dictionary element (or elements) replaces those
            elements with null elements. If no such elements exist, then this
            is a silent success.
</p>
<a name="anchor82"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.3.4"></a><h3>7.3.3.4.&nbsp;
Response Definition</h3>

<p>The response to a successful Remove simply contains a list of
            the new generation counters for each kind-id, using the same
            syntax as the response to a Store request. Note that if the
            generation counter does not change, that means that the requested
            items did not exist. However, if the generation counter does
            change, that does not mean that the items existed.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      struct {
        StoreKindResponse          kind_responses&lt;0..2^16-1&gt;;
      } RemoveAns;

</pre></div>
<a name="anchor83"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.4"></a><h3>7.3.4.&nbsp;
Find</h3>

<p>The Find request can be used to explore the Overlay Instance. A
          Find request for a resource-id R and a kind-id T retrieves the
          resource-id (if any) of the resource of kind T known to the target
          peer which is closes to R. This method can be used to walk the
          Overlay Instance by interactively fetching R_n+1=nearest(1 +
          R_n).
</p>
<a name="anchor84"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.4.1"></a><h3>7.3.4.1.&nbsp;
Request Definition</h3>

<p>The FindReq message contains a series of resource-IDs and
            kind-ids identifying the resource the peer is interested in.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   struct {
     ResourceID                 resource;
     KindId                     kinds&lt;0..2^8-1&gt;;
   } FindReq;

</pre></div>
<p>The request contains a list of kind-ids which the Find is for, as
          indicated below: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>resource </dt>
<dd>
</dd>
<dt></dt>
<dd>The desired resource-id
</dd>
<dt></dt>
<dd>
</dd>
<dt>kinds </dt>
<dd>
</dd>
<dt></dt>
<dd>The desired kind-ids. Each value MUST only appear once.
</dd>
</dl></blockquote>

<a name="anchor85"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.4.2"></a><h3>7.3.4.2.&nbsp;
Response Definition</h3>

<p>A response to a successful Find request is a FindAns message
            containing the closest resource-id for each kind specified in the
            request.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  struct {
    KindId                      kind;
    ResourceID                  closest;
  } FindKindData;

  struct {
    FindKindData                results&lt;0..2^16-1&gt;;
  } FindAns;

</pre></div>
<p>If the processing peer is not responsible for the specified
            resource-id, it SHOULD return a 404 error.
</p>
<p>For each kind-id in the request the response MUST contain a
            FindKindData indicating the closest resource-id for that kind-id
            unless the kind is not allowed to be used with Find in which case
            a FindKindData for that kind-id MUST NOT be included in the
            response. If a kind-id is not known, then the corresponding
            resource-id MUST be 0. Note that different kind-ids may have
            different closest resource-ids.
</p>
<p>The response is simply a series of FindKindData elements, one
            per kind, concatenated end-to-end. The contents of each element
            are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>kind </dt>
<dd>
</dd>
<dt></dt>
<dd>The kind-id.
</dd>
<dt></dt>
<dd>
</dd>
<dt>closest </dt>
<dd>
</dd>
<dt></dt>
<dd>The closest resource ID to the specified resource ID. This
                is 0 if no resource ID is known.
</dd>
</dl></blockquote>

<p>Note that the response does not contain the contents of the
            data stored at these resource-ids. If the requester wants this, it
            must retrieve it using Fetch.
</p>
<a name="anchor86"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.4.3"></a><h3>7.3.4.3.&nbsp;
Defining New Kinds</h3>

<p>A new kind MUST define:
</p>
<p></p>
<ul class="text">
<li>The meaning of the data to be stored.
</li>
<li>The kind-id.
</li>
<li>The data model (single value, array, dictionary, etc.)
</li>
<li>Access control rules for indicating what credentials are
                allowed to read and write that kind-id at a given
                location.
</li>
</ul>

<p>While each kind MUST define what data model is used for its
            data, that does not mean that it must define new data models.
            Where practical, kinds SHOULD use the built-in data models.
            However, they MAY define any new required data models. The
            intention is that the basic data model set be sufficient for most
            applications/usages.
</p>
<a name="sec-store-usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Certificate Store Usage</h3>

<p>The Certificate Store usage allows a peer to store its certificate in
      the overlay, thus avoiding the need to send a certificate in each
      message - a reference may be sent instead.
</p>
<p>A user/peer MUST store its certificate at resource-ids derived from
      two Resource Names:
</p>
<p></p>
<ul class="text">
<li>The user name in the certificate.
</li>
<li>The Node-ID in the certificate.
</li>
</ul>

<p>Note that in the second case the certificate is not stored at the
      peer's Node-ID but rather at a hash of the peer's Node-ID. The intention
      here (as is common throughout RELOAD) is to avoid making a peer
      responsible for its own data.
</p>
<p>A peer MUST ensure that the user's certificates are stored in the
      Overlay Instance. New certificates are stored at the end of the list.
      This structure allows users to store and old and new certificate the
      both have the same node-id which allows for migration of certificates
      when they are renewed.
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Kind IDs</dt>
<dd>This usage defines the CERTIFICATE kind-id to
          store a peer or user's certificate.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Data Model</dt>
<dd>The data model for CERTIFICATE data is
          array.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Access Control</dt>
<dd>The CERTIFICATE MUST contain a Node-ID
          or user name which, when hashed, maps to the resource-id at which
          the value is being stored.
</dd>
</dl></blockquote>

<a name="sec-turn-server"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
TURN Server Usage</h3>

<p>The TURN server usage allows a RELOAD peer to advertise that it is
      prepared to be a TURN server as defined in <a class='info' href='#I-D.ietf-behave-turn'>[I&#8209;D.ietf&#8209;behave&#8209;turn]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Obtaining Relay Addresses from Simple Traversal Underneath           NAT (STUN),&rdquo; March&nbsp;2007.</span><span>)</span></a>. When a node starts up, it joins the
      overlay network and forms several connection in the process. If the ICE
      stage in any of these connection return a reflexive address that is not
      the same as the peers perceived address, then the peers is behind a NAT
      and not an candidate for a TURN server. Additionally, if the peers IP
      address is in the private address space range, then it is not a
      candidate for a TURN server. Otherwise, the peer SHOULD assume it is a
      potential TURN server and follow the procedures below.
</p>
<p>If the node is a candidate for a TURN server it will insert some
      pointers in the overlay so that other peers can find it. The overlay
      configuration file specifies a turnDensity parameter that indicates how
      many times each TURN server should record itself in the overlay.
      Typically this should be set to the reciprocal of the estimate of what
      percentage of peers will act as TURN servers. For each value, called d,
      between 1 and turnDensity, the peer forms a Resource Name by
      concatenating its peer-ID and the value d. This Resource Name is hashed
      to form a Resource-ID. The address of the peer is stored at that
      Resource-ID using type TURN-SERVICE and the TurnServer object:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      struct {
        uint8                   iteration;
        IpAddressAndPort        server_address;
      } TurnServer;

</pre></div>
<p>The contents of this structure are as follows: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>iteration</dt>
<dd>
</dd>
<dt></dt>
<dd>the d value
</dd>
<dt></dt>
<dd>
</dd>
<dt>server_address</dt>
<dd>
</dd>
<dt></dt>
<dd>the address at which the TURN server can be contacted.
</dd>
</dl></blockquote>

<p></p>
<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>Correct functioning of this algorithm depends
          critically on having turnDensity be an accurate estimate of the true
          density of TURN servers. If turnDensity is too high, then the
          process of finding TURN servers becomes extremely expensive as
          multiple candidate resource-ids must be probed.
</dd>
</dl></blockquote>

<p>Peers peers that provide this service need to support the TURN
      extensions to STUN for media relay of both UDP and TCP traffic as
      defined in [I-D.ietf-behave-turn] and [I-D.ietf-behave-tcp].
</p>
<p>[[OPEN ISSUE: This structure only works for TURN servers that have
      public addresses. It may be possible to use TURN servers that are behind
      well-behaved NATs by first ICE connecting to them. If we decide we want
      to enable that, this structure will need to change to either be a
      peer-id or include that as an option.]]
</p>
<p></p>
<blockquote class="text"><dl>
<dt>Kind IDs</dt>
<dd>This usage defines the TURN-SERVICE kind-id
          to indicate that a peer is willing to act as a TURN server. The Find
          command MUST return results for the TURN-SERVICE kind-id.
</dd>
<dt>Data Model</dt>
<dd>The TURN-SERVICE stores a single value for
          each resource-id.
</dd>
<dt>Access Control</dt>
<dd>If certificate-based access control is
          being used, stored data of kind TURN-SERVICE MUST be authenticated
          by a certificate which contains a peer-id which when hashed with the
          iteration counter produces the resource-id being stored at.
</dd>
</dl></blockquote>

<p>Peers can find other servers by selecting a random Resource-ID and
      then doing a Find request for the appropriate server type with that
      Resource-ID. The Find request gets routed to a random peer based on the
      Resource-ID. If that peer knows of any servers, they will be returned.
      The returned response may be empty if the peer does not know of any
      servers, in which case the process gets repeated with some other random
      Resource-ID. As long as the ratio of servers relative to peers is not
      too low, this approach will result in finding a server relatively
      quickly.
</p>
<a name="anchor87"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
SIP Usage</h3>

<p>The SIP usage allows a RELOAD overlay to be used as a distributed SIP
      registrar/proxy network augmenting the functionality of <a class='info' href='#RFC3263'>[RFC3263]<span> (</span><span class='info'>Rosenberg, J. and H. Schulzrinne, &ldquo;Session Initiation Protocol (SIP): Locating SIP           Servers,&rdquo; June&nbsp;2002.</span><span>)</span></a>. This entails three primary operations:
</p>
<p></p>
<ul class="text">
<li>Registering one's own AOR with the overlay.
</li>
<li>Looking up a given AOR in the overlay.
</li>
<li>Forming a direct connection to a given peer.
</li>
</ul>

<a name="anchor88"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
Registering AORs</h3>

<p>In ordinary SIP, a UA registers its AOR and location with a
        registrar. In RELOAD, this registrar function is provided by the
        overlay as a whole. To register its location, a RELOAD peer stores a
        SipRegistration structure under its own AOR. This uses the
        SIP-REGISTRATION kind-id, which is formally defined in <a class='info' href='#sec.sip-reg-kind'>Section&nbsp;10.5<span> (</span><span class='info'>SIP-REGISTRATION Kind Definition</span><span>)</span></a>. </p>
<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>GRUUs are handled via a separate mechanism, as
            described in <a class='info' href='#sec-gruus'>Section&nbsp;10.4<span> (</span><span class='info'>GRUUs</span><span>)</span></a>.
</dd>
</dl></blockquote>

<p>As a simple example, if Alice's AOR were
        "sip:alice@dht.example.com" and her Node-ID were "1234", she might
        store the mapping "sip:alice@example.org -&gt; 1234". This would tell
        anyone who wanted to call Alice to contact node "1234".
</p>
<p>RELOAD peers MAY store two kinds of SIP mappings:
</p>
<p></p>
<ul class="text">
<li>From AORs to destination lists (a single Node-ID is just a
            trivial destination list.)
</li>
<li>From AORs to other AORs.
</li>
</ul>

<p>The meaning of the first kind of mapping is "in order to contact
        me, form a connection with this peer." The meaning of the second kind
        of mapping is "in order to contact me, dereference this AOR". This
        allows for forwarding. For instance, if Alice wants calls to her to be
        forwarded to her secretary, Sam, she might insert the following
        mapping "sip:alice@dht.example.org -&gt; sip:sam@dht.example.org".
</p>
<p>The contents of a SipRegistration structure are as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

       enum {sip_registration_uri (1), sip_registration_route (2),
          (255)} SipRegistrationType;

       select (SipRegistration.type) {
         case sip_registration_uri:
           opaque               uri&lt;0..2^16-1&gt;;

         case sip_registration_route:
           opaque               contact_prefs&lt;0..2^16-1&gt;;
           Destination          destination_list&lt;0..2^16-1&gt;;

         /* This type can be extended */

       } SipRegistrationData;

       struct {
          SipRegistrationType   type;
          uint16                length;
          SipRegistrationData   data;
      } SipRegistration;


</pre></div>
<p>The contents of the SipRegistration PDU are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>type </dt>
<dd>
</dd>
<dt></dt>
<dd>the type of the registration
</dd>
<dt></dt>
<dd>
</dd>
<dt>length </dt>
<dd>
</dd>
<dt></dt>
<dd>the length of the rest of the PDU
</dd>
<dt></dt>
<dd>
</dd>
<dt>data </dt>
<dd>
</dd>
<dt></dt>
<dd>the registration data
</dd>
</dl></blockquote>

<p></p>
<ul class="text">
<li>If the registration is of type "sip_registration_uri", then the
            contents are an opaque string containing the URI.
</li>
<li>If the registration is of type "sip_registration_route", then
            the contents are an opaque string containing the callee's contact
            preferences and a destination list for the peer.
</li>
</ul>

<p>RELOAD explicitly supports multiple registrations for a single AOR.
        The registrations are stored in a Dictionary with the dictionary keys
        being Node-IDs. Consider, for instance, the case where Alice has two
        peers:
</p>
<p></p>
<ul class="text">
<li>her desk phone (1234)
</li>
<li>her cell phone (5678)
</li>
</ul>

<p>Alice might store the following in the overlay at resource
        "sip:alice@dht.example.com".
</p>
<p></p>
<ul class="text">
<li>A SipRegistration of type "sip_registration_route" with
            dictionary key "1234" and value "1234".
</li>
<li>A SipRegistration of type "sip_registration_route" with
            dictionary key "5678" and value "5678".
</li>
</ul>

<p>Note that this structure explicitly allows one Node-ID to forward
        to another Node-ID. For instance, Alice could set calls to her desk
        phone to ring at her cell phone. It's not clear that this is useful in
        this case, but may be useful if Alice has two AORs.
</p>
<p>In order to prevent hijacking, registrations are subject to access
        control rules. Before a Store is permitted, the storing peer MUST
        check that:
</p>
<p></p>
<ul class="text">
<li>The certificate contains a username that is a SIP AOR that
            hashes to the resource-id being stored at.
</li>
<li>The certificate contains a Node-ID that is the same as the
            dictionary key being stored at.
</li>
</ul>

<p>Note that these rules permit Alice to forward calls to Bob without
        his permission. However, they do not permit Alice to forward Bob's
        calls to her. See <a class='info' href='#sec-security-malicious-retargeting'>Section&nbsp;15.7.2<span> (</span><span class='info'>Malicious Retargeting</span><span>)</span></a> for more on this
        point.
</p>
<a name="anchor89"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
Looking up an AOR</h3>

<p>When a RELOAD user wishes to call another user, starting with a
        non-GRUU AOR, he follows the following procedure. (GRUUs are discussed
        in <a class='info' href='#sec-gruus'>Section&nbsp;10.4<span> (</span><span class='info'>GRUUs</span><span>)</span></a>).
</p>
<p></p>
<ol class="text">
<li>Check to see if the domain part of the AOR matches the domain
            name of an overlay of which he is a member. If not, then this is
            an external AOR, and he MUST do one of the following: 
<ul class="text">
<li>Fail the call.
</li>
<li>Use ordinary SIP procedures.
</li>
<li>Attempt to become a member of the overlay indicated by the
                domain part (only possible if the enrollment procedure defined
                in <a class='info' href='#sec-discovery'>Section&nbsp;13.1<span> (</span><span class='info'>Discovery</span><span>)</span></a> indicates that this is
                a RELOAD overlay.)
</li>
</ul>
</li>
<li>Perform a Fetch for kind SIP-REGISTRATION at the resource-id
            corresponding to the AOR. This Fetch SHOULD NOT indicate any
            dictionary keys, which will result in fetching all the stored
            values.
</li>
<li>If any of the results of the Fetch are non-GRUU AORs, then
            repeat step 1 for that AOR.
</li>
<li>Once only GRUUs and destination lists remain, the peer removes
            duplicate destination lists and GRUUs from the list and forms a
            SIP connection to the appropriate peers as described in the
            following sections. If there are also external AORs, the peer
            follows the appropriate procedure for contacting them as well.
</li>
</ol>

<a name="anchor90"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
Forming a Direct Connection</h3>

<p>Once the peer has translated the AOR into a set of destination
        lists, it then uses the overlay to route Attach messages to each of
        those peers. The "application" field MUST be 5060 to indicate SIP. If
        certificate-based authentication is in use, the responding peer MUST
        present a certificate with a Node-ID matching the terminal entry in
        the route list. Note that it is possible that the peers already have a
        RELOAD connection between them. This MUST NOT be used for SIP
        messages. However, if a SIP connection already exists, that MAY be
        used. Once the Attach succeeds, the peer sends SIP messages over the
        connection as in normal SIP.
</p>
<a name="sec-gruus"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
GRUUs</h3>

<p>GRUUs do not require storing data in the Overlay Instance. Rather,
        they are constructed by embedding a base64-encoded destination list in
        the gr URI parameter of the GRUU. The base64 encoding is done with the
        alphabet specified in table 1 of RFC 4648 with the exception that ~ is
        used in place of =. An example GRUU is
        "sip:alice@example.com;gr=MDEyMzQ1Njc4OTAxMjM0NTY3ODk~". When a peer
        needs to route a message to a GRUU in the same P2P network, it simply
        uses the destination list and connects to that peer.
</p>
<p>Because a GRUU contains a destination list, it MAY have the same
        contents as a destination list stored elsewhere in the resource
        dictionary.
</p>
<p>Anonymous GRUUs are done in roughly the same way but require either
        that the enrollment server issue a different Node-ID for each
        anonymous GRUU required or that a destination list be used that
        includes a peer that compresses the destination list to stop the
        Node-ID from being revealed.
</p>
<a name="sec.sip-reg-kind"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
SIP-REGISTRATION Kind Definition</h3>

<p>The first mapping is provided using the SIP-REGISTRATION
        kind-id:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>Kind IDs</dt>
<dd>The Resource Name for the SIP-REGISTRATION
            kind-id is the AOR of the user. The data stored is a
            SipRegistrationData, which can contain either another URI or a
            destination list to the peer which is acting for the user.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Data Model</dt>
<dd>The data model for the SIP-REGISTRATION
            kind-id is dictionary. The dictionary key is the Node-ID of the
            storing peer. This allows each peer (presumably corresponding to a
            single device) to store a single route mapping.
</dd>
<dt></dt>
<dd>
</dd>
<dt>Access Control</dt>
<dd>If certificate-based access control
            is being used, stored data of kind-id SIP-REGISTRATION must be
            signed by a certificate which (1) contains user name matching the
            storing URI used as the Resource Name for the resource-id and (2)
            contains a Node-ID matching the storing dictionary key.
</dd>
</dl></blockquote>

<p>Data stored under the SIP-REGISTRATION kind is of type
        SipRegistration. This comes in two varieties: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>sip_registration_uri </dt>
<dd>
</dd>
<dt></dt>
<dd>a URI which the user can be reached at.
</dd>
<dt></dt>
<dd>
</dd>
<dt>sip_registration_route </dt>
<dd>
</dd>
<dt></dt>
<dd>a destination list which can be used to reach the user's
            peer.
</dd>
</dl></blockquote>

<a name="anchor91"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Diagnostic Usage</h3>

<p>The Diagnostic Usage allows a node to report various statistics about
      itself that may be useful for diagnostics or performance management. It
      can be used to discover information such as the software version,
      uptime, routing table, stored resource-objects, and performance
      statistics of a peer. The usage defines several new kinds which can be
      retrieved to get the statistics and also allows to retrieve other kinds
      that a node stores. In essence, the usage allows querying a node's state
      such as storage and network to obtain the relevant information.
</p>
<p>The access control model for all kinds is a local policy defined by
      the peer or the overlay policy. The peer may be configured with a list
      of users that it is willing to return the information for and restrict
      access to users with that name. Unless specific policy overrides it,
      data SHOULD NOT be returned for users not on the list. The access
      control can also be determined on a per kind basis - for example, a node
      may be willing to return the software version to any users while
      specific information about performance may not be returned.
</p>
<p>The following kinds are defined:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>ROUTING_TABLE_SIZE</dt>
<dd>A single value element containing
          an unsigned 32-bit integer representing the number of peers in the
          peer's routing table.
</dd>
<dt></dt>
<dd>
</dd>
<dt>SOFTWARE_VERSION</dt>
<dd>A single value element containing a
          US-ASCII string that identifies the manufacture, model, and version
          of the software.
</dd>
<dt></dt>
<dd>
</dd>
<dt>MACHINE_UPTIME</dt>
<dd>A single value element containing an
          unsigned 64-bit integer specifying the time the nodes has been up in
          seconds.
</dd>
<dt></dt>
<dd>
</dd>
<dt>APP_UPTIME</dt>
<dd>A single value element containing an
          unsigned 64-bit integer specifying the time the p2p application has
          been up in seconds.
</dd>
<dt></dt>
<dd>
</dd>
<dt>MEMORY_FOOTPRINT</dt>
<dd>A single value element containing an
          unsigned 32-bit integer representing the memory footprint of the
          peer program in kilo bytes.
</dd>
<dt></dt>
<dd>
<blockquote class="text"><dl>
<dt>Note:</dt>
<dd>What's a kilo byte? 1000 or 1024? --
              Cullen
</dd>
<dt>Note:</dt>
<dd>Good question. 1000 seems like not quite
              enough room but 1024 is too much? -- EKR
</dd>
</dl></blockquote>
</dd>
<dt></dt>
<dd>
</dd>
<dt>DATASIZE_STORED</dt>
<dd>An unsigned 64-bit integer
          representing the number of bytes of data being stored by this
          node.
</dd>
<dt></dt>
<dd>
</dd>
<dt>INSTANCES_STORED</dt>
<dd>An array element containing the
          number of instances of each kind stored. The array is index by
          kind-id. Each entry is an unsigned 64-bit integer.
</dd>
<dt></dt>
<dd>
</dd>
<dt>MESSAGES_SENT_RCVD</dt>
<dd>An array element containing the
          number of messages sent and received. The array is indexed by method
          code. Each entry in the array is a pair of unsigned 64-bit integers
          (packed end to end) representing sent and received.
</dd>
<dt></dt>
<dd>
</dd>
<dt>EWMA_BYTES_SENT</dt>
<dd>A single value element containing an
          unsigned 32-bit integer representing an exponential weighted average
          of bytes sent per second by this peer.
</dd>
<dt></dt>
<dd>sent = alpha x sent_present + (1 - alpha) x sent
</dd>
<dt></dt>
<dd>where sent_present represents the bytes sent per second since the
          last calculation and sent represents the last calculation of bytes
          sent per second. A suitable value for alpha is 0.8. This value is
          calculated every five seconds.
</dd>
<dt></dt>
<dd>
</dd>
<dt>EWMA_BYTES_RCVD</dt>
<dd>A single value element containing an
          unsigned 32-bit integer representing an exponential weighted average
          of bytes received per second by this peer. Same calculation as
          above.
</dd>
</dl></blockquote>

<p>[[TODO: We would like some sort of bandwidth measurement, but we're
      kind of unclear on the units and representation.]]
</p>
<a name="anchor92"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
Diagnostic Metrics for a P2PSIP Deployment</h3>

<p>(OPEN QUESTION: any other metrics?)
</p>
<p>Below, we sketch how these metrics can be used. A peer can use
        EWMA_BYTES_SENT and EWMA_BYTES_RCVD of another peer to infer whether
        it is acting as a media relay. It may then choose not to forward any
        requests for media relay to this peer. Similarly, among the various
        candidates for filling up routing table, a peer may prefer a peer with
        a large UPTIME value, small RTT, and small LAST_CONTACT value.
</p>
<a name="sec.chord-algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Chord Algorithm </h3>

<p>This algorithm is assigned the name chord-128-2-16+ to indicate it is
      based on Chord, uses SHA-1 then truncates that to 128 bit for the hash
      function, stores 2 redundant copies of all data, and has finger tables
      with at least 16 entries.
</p>
<a name="anchor93"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.1"></a><h3>12.1.&nbsp;
Overview</h3>

<p>The algorithm described here is a modified version of the Chord
        algorithm. Each peer keeps track of a finger table of 16 entries and a
        neighborhood table of 6 entries. The neighborhood table contains the 3
        peers before this peer and the 3 peers after it in the DHT ring. The
        first entry in the finger table contains the peer half-way around the
        ring from this peer; the second entry contains the peer that is 1/4 of
        the way around; the third entry contains the peer that is 1/8th of the
        way around, and so on. Fundamentally, the chord data structure can be
        thought of a doubly-linked list formed by knowing the successors and
        predecessor peers in the neighborhood table, sorted by the Node-ID. As
        long as the successor peers are correct, the DHT will return the
        correct result. The pointers to the prior peers are kept to enable
        inserting of new peers into the list structure. Keeping multiple
        predecessor and successor pointers makes it possible to maintain the
        integrity of the data structure even when consecutive peers
        simultaneously fail. The finger table forms a skip list, so that
        entries in the linked list can be found in O(log(N)) time instead of
        the typical O(N) time that a linked list would provide.
</p>
<p>A peer, n, is responsible for a particular Resource-ID k if k is
        less than or equal to n and k is greater than p, where p is the peer
        id of the previous peer in the neighborhood table. Care must be taken
        when computing to note that all math is modulo 2^128.
</p>
<a name="anchor94"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.2"></a><h3>12.2.&nbsp;
Routing</h3>

<p>If a peer is not responsible for a Resource-ID k, but is directly
        connected to a node with Node-Id k, then it routes the message to that
        node. Otherwise, it routes the request to the peer in the routing
        table that has the largest Node-ID that is in the interval between the
        peer and k.
</p>
<a name="anchor95"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.3"></a><h3>12.3.&nbsp;
Redundancy </h3>

<p>When a peer receives a Store request for Resource-ID k, and it is
        responsible for Resource-ID k, it stores the data and returns a
        success response. [[Open Issue: should it delay sending this success
        until it has successfully stored the redundant copies?]]. It then
        sends a Store request to its successor in the neighborhood table and
        to that peers successor. Note that these Store requests are addressed
        to those specific peers, even though the Resource-ID they are being
        asked to store is outside the range that they are responsible for. The
        peers receiving these check they came from an appropriate predecessor
        in their neighborhood table and that they are in a range that this
        predecessor is responsible for, and then they store the data. They do
        not themselves perform further Stores because they can determine that
        they are not responsible for the resource-ID.
</p>
<p>Note that a malicious node can return a success response but not
        store the data locally or in the replica set. Requesting peers which
        wish to ensure that the replication actually occurred SHOULD contact
        each peer listed in the replicas field of the Store response and
        retrieve a copy of the data. [[TODO: Do we want to have some
        optimization in Fetch where they can retrieve just a digest instead of
        the data values?]]
</p>
<a name="anchor96"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.4"></a><h3>12.4.&nbsp;
Joining</h3>

<p>The join process for a joining party (JP) with Node-ID n is as
        follows.
</p>
<p></p>
<ol class="text">
<li>JP connects to its chosen bootstrap node.
</li>
<li>JP uses a series of Pings to populate its routing table.
</li>
<li>JP sends Attach requests to initiate connections to each of
            the peers in the connection table as well as to the desired finger
            table entries. Note that this does not populate their routing
            tables, but only their connection tables, so JP will not get
            messages that it is expected to route to other nodes.
</li>
<li>JP enters all the peers it contacted into its routing
            table.
</li>
<li>JP sends a Join to its immediate successor, the admitting peer
            (AP) for Node-ID n. The AP sends the response to the Join.
</li>
<li>AP does a series of Store requests to JP to store the data that
            JP will be responsible for.
</li>
<li>AP sends JP an Update explicitly labeling JP as its
            predecessor. At this point, JP is part of the ring and responsible
            for a section of the overlay. AP can now forget any data which is
            assigned to JP and not AP.
</li>
<li>AP sends an Update to all of its neighbors with the new values
            of its neighbor set (including JP).
</li>
<li>JP sends UpdateS to all the peers in its routing table.
</li>
</ol>

<p>In order to populate its routing table, JP sends a Ping via the
        bootstrap node directed at resource-id n+1 (directly after its own
        resource-id). This allows it to discover its own successor. Call that
        node p0. It then sends a ping to p0+1 to discover its successor (p1).
        This process can be repeated to discover as many successors as
        desired. The values for the two peers before p will be found at a
        later stage when n receives an Update.
</p>
<p>In order to set up its neighbor table entry for peer i, JP simply
        sends an Attach to peer (n+2^(numBitsInNodeId-i). This will be routed
        to a peer in approximately the right location around the ring.
</p>
<a name="anchor97"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.5"></a><h3>12.5.&nbsp;
Routing Attaches</h3>

<p>When a peer needs to Attach to a new peer in its neighborhood
        table, it MUST source-route the Attach request through the peer from
        which it learned the new peer's Node-ID. Source-routing these requests
        allows the overlay to recover from instability.
</p>
<p>All other Attach requests, such as those for new finger table
        entries, are routed conventionally through the overlay.
</p>
<p>If a peer is unable to successfully Attach with a peer that should
        be in its neighborhood, it MUST locate either a TURN server or another
        peer in the overlay, but not in its neighborhood, through which it can
        exchange messages with its neighbor peer
</p>
<a name="anchor98"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.6"></a><h3>12.6.&nbsp;
Updates</h3>

<p>A chord Update is defined as
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      enum { reserved (0),
             peer_ready(1), neighbors(2), full(3), (255) }
           ChordUpdateType;


      struct {
        ChordUpdateType         type;

        select(type){
          case peer_ready:                   /* Empty */
            ;

          case neighbors:
            NodeId              predecessors&lt;0..2^16-1&gt;;
            NodeId              successors&lt;0..2^16-1&gt;;

          case full:
            NodeId              predecessors&lt;0..2^16-1&gt;;
            NodeId              successors&lt;0..2^16-1&gt;;
            NodeId              fingers&lt;0..2^16-1&gt;;
        };
      } ChordUpdate;

</pre></div>
<p>The "type" field contains the type of the update, which depends on
        the reason the update was sent.
</p>
<p></p>
<blockquote class="text"><dl>
<dt>peer_ready: </dt>
<dd>this peer is ready to receive messages.
            This message is used to indicate that a node which has Attached
            is a peer and can be routed through. It is also used as a
            connectivity check to non-neighbor pers.
</dd>
<dt>neighbors: </dt>
<dd>this version is sent to members of the
            Chord neighbor table.
</dd>
<dt>full: </dt>
<dd>this version is sent to peers which request
            an Update with a RouteQueryReq.
</dd>
</dl></blockquote>

<p>If the message is of type "neighbors", then the contents of the
        message will be:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>predecessors </dt>
<dd>
</dd>
<dt></dt>
<dd>The predecessor set of the Updating peer.
</dd>
<dt></dt>
<dd>
</dd>
<dt>successors </dt>
<dd>
</dd>
<dt></dt>
<dd>The successor set of the Updating peer.
</dd>
</dl></blockquote>

<p>If the message is of type "full", then the contents of the message
        will be:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>predecessors </dt>
<dd>
</dd>
<dt></dt>
<dd>The predecessor set of the Updating peer.
</dd>
<dt></dt>
<dd>
</dd>
<dt>successors </dt>
<dd>
</dd>
<dt></dt>
<dd>The successor set of the Updating peer.
</dd>
<dt></dt>
<dd>
</dd>
<dt>fingers </dt>
<dd>
</dd>
<dt></dt>
<dd>The finger table if the Updating peer, in numerically
            ascending order.
</dd>
</dl></blockquote>

<p>A peer MUST maintain an association (via Attach) to every member
        of its neighbor set. A peer MUST attempt to maintain at least three
        predecessors and three successors. However, it MUST send its entire
        set in any Update message sent to neighbors.
</p>
<a name="anchor99"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.6.1"></a><h3>12.6.1.&nbsp;
Sending Updates</h3>

<p>Every time a connection to a peer in the neighborhood set is lost
          (as determined by connectivity pings or failure of some request),
          the peer should remove the entry from its neighborhood table and
          replace it with the best match it has from the other peers in its
          routing table. It then sends an Update to all its remaining
          neighbors. The update will contain all the Node-IDs of the current
          entries of the table (after the failed one has been removed). Note
          that when replacing a successor the peer SHOULD delay the creation
          of new replicas for 30 seconds after removing the failed entry from
          its neighborhood table in order to allow a triggered update to
          inform it of a better match for its neighborhood table.
</p>
<p>If connectivity is lost to all three of the peers that succeed
          this peer in the ring, then this peer should behave as if it is
          joining the network and use Pings to find a peer and send it a Join.
          If connectivity is lost to all the peers in the finger table, this
          peer should assume that it has been disconnected from the rest of
          the network, and it should periodically try to join the DHT.
</p>
<a name="anchor100"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.6.2"></a><h3>12.6.2.&nbsp;
Receiving Updates</h3>

<p>When a peer, N, receives an Update request, it examines the
          Node-IDs in the UpdateReq and at its neighborhood table and decides
          if this UpdateReq would change its neighborhood table. This is done
          by taking the set of peers currently in the neighborhood table and
          comparing them to the peers in the update request. There are three
          major cases:
</p>
<p></p>
<ul class="text">
<li>The UpdateReq contains peers that would not change the
              neighbor set because they match the neighborhood table.
</li>
<li>The UpdateReq contains peers closer to N than those in its
              neighborhood table.
</li>
<li>The UpdateReq defines peers that indicate a neighborhood
              table further away from N than some of its neighborhood table.
              Note that merely receiving peers further away does not
              demonstrate this, since the update could be from a node far away
              from N. Rather, the peers would need to bracket N.
</li>
</ul>

<p>In the first case, no change is needed.
</p>
<p>In the second case, N MUST attempt to Attach to the new peers
          and if it is successful it MUST adjust its neighbor set accordingly.
          Note that it can maintain the now inferior peers as neighbors, but
          it MUST remember the closer ones.
</p>
<p>The third case implies that a neighbor has disappeared, most
          likely because it has simply been disconnected but perhaps because
          of overlay instability. N MUST Ping the questionable peers to
          discover if they are indeed missing and if so, remove them from its
          neighborhood table.
</p>
<p>After any Pings and Attaches are done, if the neighborhood table
          changes, the peer sends an Update request to each of its neighbors
          that was in either the old table or the new table. These Update
          requests are what ends up filling in the predecessor/successor
          tables of peers that this peer is a neighbor to. A peer MUST NOT
          enter itself in its successor or predecessor table and instead
          should leave the entries empty.
</p>
<p>If peer N which is responsible for a resource-id R discovers that
          the replica set for R (the next two nodes in its successor set) has
          changed, it MUST send a Store for any data associated with R to any
          new node in the replica set. It SHOULD not delete data from peers
          which have left the replica set.
</p>
<p>When a peer N detects that it is no longer in the replica set for
          a resource R (i.e., there are three predecessors between N and R),
          it SHOULD delete all data associated with R from its local
          store.
</p>
<a name="anchor101"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.6.3"></a><h3>12.6.3.&nbsp;
Stabilization</h3>

<p>There are four components to stabilization: </p>
<ol class="text">
<li>exchange Updates with all peers in its routing table to
              exchange state
</li>
<li>search for better peers to place in its finger table
</li>
<li>search to determine if the current finger table size is
              sufficiently large
</li>
<li>search to determine if the overlay has partitioned and needs
              to recover
</li>
</ol>

<p>A peer MUST periodically send an Update request to every peer in
          its routing table. The purpose of this is to keep the predecessor
          and successor lists up to date and to detect connection failures.
          The default time is about every ten minutes, but the enrollment
          server SHOULD set this in the configuration document using the
          "chord-128-2-16+-update-frequency" element (denominated in seconds.)
          A peer SHOULD randomly offset these Update requests so they do not
          occur all at once. If an Update request fails or times out, the peer
          MUST mark that entry in the neighbor table invalid and attempt to
          reestablish a connection. If no connection can be established, the
          peer MUST attempt to establish a new peer as its neighbor and do
          whatever replica set adjustments are required.
</p>
<p>Periodically a peer should select a random entry i from the
          finger table and do a Ping to resource (n+2^(numBitsInNodeId-i). The
          purpose of this is to find a more accurate finger table entry if
          there is one. This is done less frequently than the connectivity
          checks in the previous section because forming new connections is
          somewhat expensive and the cost needs to be balanced against the
          cost of not having the most optimal finger table entries. The
          default time is about every hour, but the enrollment server SHOULD
          set this in the configuration document using the
          "chord-128-2-16+-ping-frequency" element (denominated in seconds).
          If this returns a different peer than the one currently in this
          entry of the peer table, then a new connection should be formed to
          this peer and it should replace the old peer in the finger
          table.
</p>
<p>As an overlay grows, more than 16 entries may be required in the
          finger table for efficient routing. To determine if its finger table
          is sufficiently large, one an hour the peer should perform a Ping to
          determine whether growing its finger table by four entries would
          result in it learning at least two peers that it does not already
          have in its neighbor table. If so, then the finger table SHOULD be
          grown by four entries. Similarly, if the peer observes that its
          closest finger table entries are also in its neighbor table, it MAY
          shrink its finger table to the minimum size of 16 entries. [[OPEN
          ISSUE: there are a variety of algorithms to gauge the population of
          the overlay and select an appropriate finger table size. Need to
          consider which is the best combination of effectiveness and
          simplicity.]]
</p>
<p>To detect that a partitioning has occurred and to heal the
          overlay, a peer P MUST periodically repeat the discovery process
          used in the initial join for the overlay to locate an appropriate
          bootstrap peer, B. If an overlay has multiple mechanisms for
          discovery it should randomly select a method to locate a bootstrap
          peer. P should then send a Ping for its own Node-ID routed through
          B. If a response is received from a peer S', which is not P's
          successor, then the overlay is partitioned and P should send a
          Attach to S' routed through B, followed by an Update sent to S'.
          (Note that S' may not be in P's neighborhood table once the overlay
          is healed, but the connection will allow S' to discover appropriate
          neighbor entries for itself via its own stabilization.)
</p>
<a name="anchor102"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.7"></a><h3>12.7.&nbsp;
Route Query</h3>

<p>For this topology plugin, the RouteQueryReq contains no additional
        information. The RouteQueryAns contains the single node ID of the next
        peer to which the responding peer would have routed the request
        message in recursive routing:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

    struct {
       NodeId                  next_id;
    } ChordRouteQueryAns;
</pre></div>
<p>The contents of this structure are as follows: </p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>next_peer </dt>
<dd>
</dd>
<dt></dt>
<dd>The peer to which the responding peer would route the message
            to in order to deliver it to the destination listed in the
            request.
</dd>
</dl></blockquote>

<p>If the requester set the send_update flag, the responder SHOULD
        initiate an Update immediately after sending the RouteQueryAns.
</p>
<a name="anchor103"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12.8"></a><h3>12.8.&nbsp;
Leaving</h3>

<p>Peers SHOULD send a Leave request prior to exiting the Overlay
        Instance. Any peer which receives a Leave for a peer n in its neighbor
        set must remove it from the neighbor set, update its replica sets as
        appropriate (including Stores of data to new members of the replica
        set) and send Updates containing its new predecessor and successor
        tables.
</p>
<a name="secEnrollment"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
Enrollment and Bootstrap</h3>

<a name="sec-discovery"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.1"></a><h3>13.1.&nbsp;
Discovery</h3>

<p>When a peer first joins a new overlay, it starts with a discovery
        process to find an enrollment server. Related work to the approach
        used here is described in <a class='info' href='#I-D.garcia-p2psip-dns-sd-bootstrapping'>[I&#8209;D.garcia&#8209;p2psip&#8209;dns&#8209;sd&#8209;bootstrapping]<span> (</span><span class='info'>Garcia, G., &ldquo;P2PSIP bootstrapping using DNS-SD,&rdquo; October&nbsp;2007.</span><span>)</span></a> and <a class='info' href='#I-D.matthews-p2psip-bootstrap-mechanisms'>[I&#8209;D.matthews&#8209;p2psip&#8209;bootstrap&#8209;mechanisms]<span> (</span><span class='info'>Cooper, E., &ldquo;Bootstrap Mechanisms for P2PSIP,&rdquo; February&nbsp;2007.</span><span>)</span></a>. The peer
        first determines the overlay name. This value is provided by the user
        or some other out of band provisioning mechanism. If the name is an IP
        address, that is directly used otherwise the peer MUST do a DNS SRV
        query using a Service name of "p2p_enroll" and a protocol of tcp to
        find an enrollment server.
</p>
<p>If the overlay name ends in .local, then a DNS SRV lookup using
        implement <a class='info' href='#I-D.cheshire-dnsext-dns-sd'>[I&#8209;D.cheshire&#8209;dnsext&#8209;dns&#8209;sd]<span> (</span><span class='info'>Krochmal, M. and S. Cheshire, &ldquo;DNS-Based Service Discovery,&rdquo; August&nbsp;2006.</span><span>)</span></a> with a
        Service name of "p2p_menroll" can also be tried to find an enrollment
        server. If they implement this, the user name MAY be used as the
        Instance Identifier label.
</p>
<p>Once an address for the enrollment servers is determined, the peer
        forms an HTTPS connection to that IP address. The certificate MUST
        match the overlay name as described in <a class='info' href='#RFC2818'>[RFC2818]<span> (</span><span class='info'>Rescorla, E., &ldquo;HTTP Over TLS,&rdquo; May&nbsp;2000.</span><span>)</span></a>.
        The peer then performs a GET to the URL formed by appending a path of
        "/p2psip/enroll" to the overlay name. For example, if the overlay name
        was example.com, the URL would be
        "https://example.com/p2psip/enroll".
</p>
<p>The result is an XML configuration file with the syntax described
        in the following section.
</p>
<a name="sec-configuration"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.2"></a><h3>13.2.&nbsp;
Overlay Configuration</h3>

<p>This specification defines a new content type
        "application/p2p-overlay+xml" for an MIME entity that contains overlay
        information. This information is fetched from the enrollment server,
        as described above. An example document is shown below.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
     &lt;overlay instance-name="chord.example.com" expiration="86400"&gt;
       &lt;toplogy-plugin algorithm-name="chord-128-2-16+"/&gt;
       &lt;root-cert&gt;[PEM encoded certificate here]&lt;/root-cert&gt;
       &lt;required-kind name="SIP-REGISTRATION" max-values="10"
        max-size="1000"/&gt;
       &lt;credential-server url="https://www.example.com/csr"/&gt;
       &lt;bootstrap-peer address="192.0.2.2" port="5678"/&gt;
       &lt;bootstrap-peer address="192.0.2.3" port="5678"/&gt;
       &lt;bootstrap-peer address="192.0.2.4" port="5678"/&gt;
       &lt;multicast-bootstrap="192.0.2.99" port="5678"/&gt;
     &lt;/overlay&gt;
</pre></div>
<p>The file MUST be a well formed XML document and it SHOULD contain
        an encoding declaration in the XML declaration. If the charset
        parameter of the MIME content type declaration is present and it is
        different from the encoding declaration, the charset parameter takes
        precedence. Every application conferment to this specification MUST
        accept the UTF-8 character encoding to ensure minimal
        interoperability. The namespace for the elements defined in this
        specification is urn:ietf:params:xml:ns:p2p:overlay.
</p>
<p>The file can contain multiple "overlay" elements where each one
        contains the configuration information for a different overlay. Each
        "overlay" has the following attributes:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>instance-name:</dt>
<dd>name of the overlay
</dd>
<dt></dt>
<dd>
</dd>
<dt>expiration:</dt>
<dd>time in future at which this overlay
            configuration is not longer valid and need to be retrieved again.
            This is expressed in seconds from the current time.
</dd>
</dl></blockquote>

<p>Inside each overlay element, the following elements can occur:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>topology-plugin</dt>
<dd>
</dd>
<dt></dt>
<dd>This element has an attribute called algorithm-name that
            describes the overlay-algorithm being used.
</dd>
<dt></dt>
<dd>
</dd>
<dt>root-cert </dt>
<dd>
</dd>
<dt></dt>
<dd>This element contains a PEM encoded X.509v3 certificate that is
            the root trust store used to sign all certificates in this
            overlay. There can be more than one of these.
</dd>
<dt></dt>
<dd>
</dd>
<dt>required-kinds </dt>
<dd>
</dd>
<dt></dt>
<dd>This element indicates the kinds that members must support. It
            has three attributes: 
<ul class="text">
<li>name: a string representing the kind.
</li>
<li>max-count: the maximum number of values which members of
                the overlay must support.
</li>
<li>max-size: the maximum size of individual values.
</li>
</ul> For instance, the example above indicates that members
            must support SIP-REGISTRATION with a maximum of 10 values of up to
            1000 bytes each. Multiple required-kinds elements MAY be
            present.
</dd>
<dt></dt>
<dd>
</dd>
<dt>credential-server </dt>
<dd>
</dd>
<dt></dt>
<dd>This element contains the URL at which the credential server
            can be reached in a "url" element. This URL MUST be of type
            "https:". More than one credential-server element may be
            present.
</dd>
<dt></dt>
<dd>
</dd>
<dt>self-signed-permitted </dt>
<dd>
</dd>
<dt></dt>
<dd>This element indicates whether self-signed certificates are
            permitted. If it is set to "TRUE", then self-signed certificates
            are allowed, in which case the credential-server and root-cert
            elements may be absent. Otherwise, it SHOULD be absent, but MAY be
            set "FALSE". This element also contains an attribute "digest"
            which indicates the digest to be used to compute the Node-ID.
            Valid values for this parameter are "SHA-1" and "SHA-256".
</dd>
<dt></dt>
<dd>
</dd>
<dt>bootstrap-peer </dt>
<dd>
</dd>
<dt></dt>
<dd>This elements represents the address of one of the bootstrap
            peers. It has an attribute called "address" that represents the IP
            address (either IPv4 or IPv6, since they can be distinguished) and
            an attribute called "port" that represents the port. More than one
            bootstrap-peer element may be present.
</dd>
<dt></dt>
<dd>
</dd>
<dt>multicast-bootstrap </dt>
<dd>
</dd>
<dt></dt>
<dd>This element represents the address of a multicast address and
            port that may be used for bootstrap and that peers SHOULD listen
            on to enable bootstrap. It has an attributed called "address" that
            represents the IP address and an attribute called "port" that
            represents the port. More than one "multicast-bootstrap" element
            may be present.
</dd>
<dt></dt>
<dd>
</dd>
<dt>clients-permitted </dt>
<dd>
</dd>
<dt></dt>
<dd>This element represents whether clients are permitted or
            whether all nodes must be peers. If it is set to "TRUE" or absent,
            this indicates that clients are permitted. If it is set to "FALSE"
            then nodes MUST join as peers.
</dd>
<dt></dt>
<dd>
</dd>
<dt>chord-128-2-16+-update-frequency </dt>
<dd>
</dd>
<dt></dt>
<dd>The update frequency for the Chord-128-2-16+ topology plugin
            (see <a class='info' href='#sec.chord-algorithm'>Section&nbsp;12<span> (</span><span class='info'>Chord Algorithm </span><span>)</span></a>).
</dd>
<dt></dt>
<dd>
</dd>
<dt>chord-128-2-16+-ping-frequency </dt>
<dd>
</dd>
<dt></dt>
<dd>The ping frequency for the Chord-128-2-16+ topology plugin (see
            <a class='info' href='#sec.chord-algorithm'>Section&nbsp;12<span> (</span><span class='info'>Chord Algorithm </span><span>)</span></a>).
</dd>
<dt></dt>
<dd>
</dd>
<dt>credential-server</dt>
<dd>
</dd>
<dt></dt>
<dd>Base URL for credential server.
</dd>
<dt></dt>
<dd>
</dd>
<dt>shared-secret</dt>
<dd>
</dd>
<dt></dt>
<dd>If shared secret mode is used, this contains the shared
            secret.
</dd>
</dl></blockquote>

<p>[[TODO: Do a RelaxNG grammar.]]
</p>
<a name="sec-credentials"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3"></a><h3>13.3.&nbsp;
Credentials</h3>

<p>If the configuration document contains a credential-server element,
        credentials are required to join the Overlay Instance. A peer which
        does not yet have credentials MUST contact the credential server to
        acquire them.
</p>
<p>In order to acquire credentials, the peer generates an asymmetric
        key pair and then generates a "Simple Enrollment Request" (as defined
        in <a class='info' href='#I-D.ietf-pkix-2797-bis'>[I&#8209;D.ietf&#8209;pkix&#8209;2797&#8209;bis]<span> (</span><span class='info'>Myers, M. and J. Schaad, &ldquo;Certificate Management Messages over CMS,&rdquo; March&nbsp;2006.</span><span>)</span></a>) and sends this over
        HTTPS as defined in <a class='info' href='#I-D.ietf-pkix-cmc-trans'>[I&#8209;D.ietf&#8209;pkix&#8209;cmc&#8209;trans]<span> (</span><span class='info'>Schaad, J. and M. Myers, &ldquo;Certificate Management over CMS (CMC) Transport           Protocols,&rdquo; May&nbsp;2006.</span><span>)</span></a> to
        the URL in the credential-server element. The subjectAltName in the
        request MUST contain the required user name.
</p>
<p>The credential server MUST authenticate the request using the
        provided user name and password. If the authentication succeeds and
        the requested user name is acceptable, the server and returns a
        certificate. The SubjectAltName field in the certificate contains the
        following values:
</p>
<p></p>
<ul class="text">
<li>One or more Node-IDs which MUST be cryptographically random
            <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>. These MUST be chosen by the
            credential server in such a way that they are unpredictable to the
            requesting user. These are of type URI and MUST contain RELOAD
            URIs as described in <a class='info' href='#sec-reload-uri'>Section&nbsp;16.10<span> (</span><span class='info'>reload: URI Scheme</span><span>)</span></a> and
            MUST contain a Destination list with a single entry of type
            "node_id".
</li>
<li>The names this user is allowed to use in the overlay, using
            type rfc822Name.
</li>
</ul>

<p>The certificate is returned in a "Simple Enrollment Response".
        [[TODO: REF]]
</p>
<p>The client MUST check that the certificate returned was signed by
        one of the certificates received in the "root-cert" list of the
        overlay configuration data. The peer then reads the certificate to
        find the Node-IDs it can use.
</p>
<a name="anchor104"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.3.1"></a><h3>13.3.1.&nbsp;
Self-Generated Credentials</h3>

<p>If the "self-signed-permitted" element is present and set to
          "TRUE", then a node MUST generate its own self-signed certificate to
          join the overlay. The self-signed certificate MAY contain any user
          name of the users choice. Users SHOULD make some attempt to make it
          unique but this document does not specify any mechanisms for
          that.
</p>
<p>The Node-Id MUST be computed by applying the digest specified in
          the self-signed-permitted element to the DER representation of the
          user's public key. When accepting a self-signed certificate, nodes
          MUST check that the Node-ID and public keys match. This prevents
          Node-ID theft.
</p>
<p>Once the node has constructed a self-signed certificate, it MAY
          join the overlay. Before storing its certificate in the overlay
          (<a class='info' href='#sec-store-usage'>Section&nbsp;8<span> (</span><span class='info'>Certificate Store Usage</span><span>)</span></a>) it SHOULD look to see if
          the user name is already taken and if so choose another user name.
          Note that this only provides protection against accidental name
          collisions. Name theft is still possible. If protection against name
          theft is desired, then the enrollment service must be used.
</p>
<a name="anchor105"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13.4"></a><h3>13.4.&nbsp;
Joining the Overlay Peer</h3>

<p>In order to join the overlay, the peer MUST contact a peer.
        Typically this means contacting the bootstrap peers, since they are
        guaranteed to have public IP addresses (the system should not
        advertise them as bootstrap peers otherwise). If the peer has cached
        peers it SHOULD contact them first by sending a Ping request to the
        known peer address with the destination Node-ID set to that peer's
        Node-ID.
</p>
<p>If no cached peers are available, then the peer SHOULD send a Ping
        request to the address and port found in the broadcast-peers element
        in the configuration document. This MAY be a multicast or anycast
        address. The Ping should use the wildcard Node-ID as the destination
        Node-ID.
</p>
<p>The responder peer that receives the Ping request SHOULD check that
        the overlay name is correct and that the requester peer sending the
        request has appropriate credentials for the overlay before responding
        to the Ping request even if the response is only an error.
</p>
<p>When the requester peer finally does receive a response from some
        responding peer, it can note the Node-ID in the response and use this
        Node-ID to start sending requests to join the Overlay Instance as
        described in <a class='info' href='#sec-overlay-topology'>Section&nbsp;6.3<span> (</span><span class='info'>Overlay Topology</span><span>)</span></a>.
</p>
<p>After a peer has successfully joined the overlay network, it SHOULD
        periodically look at any peers to which it has managed to form direct
        connections. Some of these peers MAY be added to the cached-peers list
        and used in future boots. Peers that are not directly connected MUST
        NOT be cached. The RECOMMENDED number of peers to cache is 10.
</p>
<a name="anchor106"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;
Message Flow Example</h3>

<p>In the following example, we assume that JP has formed a connection
      to one of the bootstrap peers. JP then sends an Attach through that peer
      to the admitting peer (AP) to initiate a connection. When AP responds,
      JP and AP use ICE to set up a connection and then set up TLS.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         JP        PPP       PP        AP        NP        NNP       BP
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |Attach Dest=JP     |         |         |         |         |
          |----------------------------------------------------------&gt;|
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |Attach Dest=JP     |         |         |
          |         |         |&lt;--------------------------------------|
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |Attach Dest=JP     |         |         |
          |         |         |--------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |AttachAns          |         |         |
          |         |         |&lt;--------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |AttachAns          |         |         |
          |         |         |--------------------------------------&gt;|
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |AttachAns          |         |         |         |         |
          |&lt;----------------------------------------------------------|
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |TLS      |         |         |         |         |         |
          |.............................|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |

</pre></div>
<p>Once JP has connected to AP, it needs to populate its Routing Table.
      In Chord, this means that it needs to populate its neighbor table and
      its finger table. To populate its neighbor table, it needs the successor
      of AP, NP. It sends an Attach to the Resource-IP AP+1, which gets routed
      to NP. When NP responds, JP and NP use ICE and TLS to set up a
      connection.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         JP        PPP       PP        AP        NP        NNP       BP
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |Attach AP+1        |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |Attach AP+1        |         |
          |         |         |         |--------&gt;|         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |AttachAns          |         |
          |         |         |         |&lt;--------|         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |AttachAns          |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |Attach   |         |         |         |         |         |
          |--------------------------------------&gt;|         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |TLS      |         |         |         |         |         |
          |.......................................|         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |

</pre></div>
<p>JP also needs to populate its finger table (for Chord). It issues a
      Attach to a variety of locations around the overlay. The diagram below
      shows it sending an Attach halfway around the Chord ring the JP +
      2^127.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         JP        NP        XX        TP
          |         |         |         |
          |         |         |         |
          |         |         |         |
          |Attach JP+2&lt;&lt;126   |         |
          |--------&gt;|         |         |
          |         |         |         |
          |         |         |         |
          |         |Attach JP+2&lt;&lt;126   |
          |         |--------&gt;|         |
          |         |         |         |
          |         |         |         |
          |         |         |Attach JP+2&lt;&lt;126
          |         |         |--------&gt;|
          |         |         |         |
          |         |         |         |
          |         |         |AttachAns|
          |         |         |&lt;--------|
          |         |         |         |
          |         |         |         |
          |         |AttachAns|         |
          |         |&lt;--------|         |
          |         |         |         |
          |         |         |         |
          |AttachAns|         |         |
          |&lt;--------|         |         |
          |         |         |         |
          |         |         |         |
          |TLS      |         |         |
          |.............................|
          |         |         |         |
          |         |         |         |
          |         |         |         |
          |         |         |         |

</pre></div>
<p>Once JP has a reasonable set of connections he is ready to take his
      place in the DHT. He does this by sending a Join to AP. AP does a series
      of Store requests to JP to store the data that JP will be responsible
      for. AP then sends JP an Update explicitly labeling JP as its
      predecessor. At this point, JP is part of the ring and responsible for a
      section of the overlay. AP can now forget any data which is assigned to
      JP and not AP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         JP        PPP       PP        AP        NP        NNP       BP
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |JoinReq  |         |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |JoinAns  |         |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |StoreReq Data A    |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |StoreAns |         |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |StoreReq Data B    |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |StoreAns |         |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateReq|         |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateAns|         |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |

</pre></div>
<p>In Chord, JP's neighbor table needs to contain its own predecessors.
      It couldn't connect to them previously because Chord has no way to route
      immediately to your predecessors. However, now that it has received an
      Update from AP, it has APs predecessors, which are also its own, so it
      sends Attaches to them. Below it is shown connecting to its closest
      predecessor, PP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         JP        PPP       PP        AP        NP        NNP       BP
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |Attach Dest=PP     |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |Attach Dest=PP     |         |         |
          |         |         |&lt;--------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |AttachAns|         |         |         |
          |         |         |--------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |AttachAns|         |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |TLS      |         |         |         |         |         |
          |...................|         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateReq|         |         |         |         |         |
          |------------------&gt;|         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateAns|         |         |         |         |         |
          |&lt;------------------|         |         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateReq|         |         |         |         |         |
          |----------------------------&gt;|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateAns|         |         |         |         |         |
          |&lt;----------------------------|         |         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateReq|         |         |         |         |         |
          |--------------------------------------&gt;|         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
          |UpdateAns|         |         |         |         |         |
          |&lt;--------------------------------------|         |         |
          |         |         |         |         |         |         |
          |         |         |         |         |         |         |
</pre></div>
<p>Finally, now that JP has a copy of all the data and is ready to route
      messages and receive requests, it sends Updates to everyone in its
      Routing Table to tell them it is ready to go. Below, it is shown sending
      such an update to TP.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

         JP        NP        XX        TP
          |         |         |         |
          |         |         |         |
          |         |         |         |
          |Update   |         |         |
          |----------------------------&gt;|
          |         |         |         |
          |         |         |         |
          |UpdateAns|         |         |
          |&lt;----------------------------|
          |         |         |         |
          |         |         |         |
          |         |         |         |
          |         |         |         |
</pre></div>
<a name="anchor107"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;
Security Considerations</h3>

<a name="anchor108"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.1"></a><h3>15.1.&nbsp;
Overview</h3>

<p>RELOAD provides a generic storage service, albeit one designed to
        be useful for P2PSIP. In this section we discuss security issues that
        are likely to be relevant to any usage of RELOAD. In <a class='info' href='#section.sip-issues'>Section&nbsp;15.7<span> (</span><span class='info'>SIP-Specific Issues</span><span>)</span></a> we describe issues that are
        specific to SIP.
</p>
<p>In any Overlay Instance, any given user depends on a number of
        peers with which they have no well-defined relationship except that
        they are fellow members of the Overlay Instance. In practice, these
        other nodes may be friendly, lazy, curious, or outright malicious. No
        security system can provide complete protection in an environment
        where most nodes are malicious. The goal of security in RELOAD is to
        provide strong security guarantees of some properties even in the face
        of a large number of malicious nodes and to allow the overlay to
        function correctly in the face of a modest number of malicious
        nodes.
</p>
<p>P2PSIP deployments require the ability to authenticate both peers
        and resources (users) without the active presence of a trusted entity
        in the system. We describe two mechanisms. The first mechanism is
        based on public key certificates and is suitable for general
        deployments. The second is an admission control mechanism based on an
	overlay-wide shared symmetric
        key.
</p>
<a name="anchor109"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.2"></a><h3>15.2.&nbsp;
Attacks on P2P Overlays</h3>

<p>The two basic functions provided by overlay nodes are storage and
        routing: some node is responsible for storing a peer's data and for
        allowing a peer to fetch other peer's data. Some other set of nodes
        are responsible for routing messages to and from the storing nodes.
        Each of these issues is covered in the following sections.
</p>
<p>P2P overlays are subject to attacks by subversive nodes that may
        attempt to disrupt routing, corrupt or remove user registrations, or
        eavesdrop on signaling. The certificate-based security algorithms we
        describe in this draft are intended to protect overlay routing and
        user registration information in RELOAD messages.
</p>
<p>To protect the signaling from attackers pretending to be valid
        peers (or peers other than themselves), the first requirement is to
        ensure that all messages are received from authorized members of the
        overlay. For this reason, RELOAD transports all messages over a secure
        channel (TLS and DTLS are defined in this document) which provides
        message integrity and authentication of the directly communicating
        peer. In addition, 
        messages and data are digitally signed with the sender's private key,
        providing end-to-end security for communications.
</p>
<a name="anchor110"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.3"></a><h3>15.3.&nbsp;
Certificate-based Security</h3>

<p>This specification stores users' registrations and possibly other
        data in an overlay network. This requires a solution to securing this
        data as well as securing, as well as possible, the routing in the
        overlay. Both types of security are based on requiring that every
        entity in the system (whether user or peer) authenticate
        cryptographically using an asymmetric key pair tied to a
        certificate.
</p>
<p>When a user enrolls in the Overlay Instance, they request or are
        assigned a unique name, such as "alice@dht.example.net". These names
        are unique and are meant to be chosen and used by humans much like a
        SIP Address of Record (AOR) or an email address. The user is also
        assigned one or more Node-IDs by the central enrollment authority.
        Both the name and the peer ID are placed in the certificate, along
        with the user's public key.
</p>
<p>Each certificate enables an entity to act in two sorts of
        roles:
</p>
<p></p>
<ul class="text">
<li>As a user, storing data at specific Resource-IDs in the Overlay
            Instance corresponding to the user name.
</li>
<li>As a overlay peer with the peer ID(s) listed in the
            certificate.
</li>
</ul>

<p>Note that since only users of this Overlay Instance need to
        validate a certificate, this usage does not require a global PKI.
        Instead, certificates are signed by require a central enrollment
        authority which acts as the certificate authority for the Overlay
        Instance. This authority signs each peer's certificate. Because each
        peer possesses the CA's certificate (which they receive on enrollment)
        they can verify the certificates of the other entities in the overlay
        without further communication. Because the certificates contain the
        user/peer's public key, communications from the user/peer can be
        verified in turn.
</p>
<p>If self-signed certificates are used, then the security provided is
        significantly decreased, since attackers can mount Sybil attacks. In
        addition, attackers cannot trust the user names in certificates
        (though they can trust the Node-Ids because they are cryptographically
        verifiable). This scheme is only appropriate for small deployments,
        such as a small office or ad hoc overlay set up among participants in
        a meeting. Some additional security can be provided by using the
        shared secret admission control scheme as well.
</p>
<p>Because all stored data is signed by the owner of the data the
        storing peer can verify that the storer is authorized to perform a
        store at that resource-id and also allows any consumer of the data to
        verify the provenance and integrity of the data when it retrieves
        it.
</p>
<p>All implementations MUST implement certificate-based security.
</p>
<a name="anchor111"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.4"></a><h3>15.4.&nbsp;
Shared-Secret Security</h3>

<p>RELOAD also supports a shared secret admission control scheme that
        relies on a single key that is shared among all members of the
        overlay. It is appropriate for small groups that wish to form a
        private network without complexity. In shared secret mode, all the
        peers share a single symmetric key which is used to key TLS-PSK <a class='info' href='#RFC4279'>[RFC4279]<span> (</span><span class='info'>Eronen, P. and H. Tschofenig, &ldquo;Pre-Shared Key Ciphersuites for Transport Layer Security           (TLS),&rdquo; December&nbsp;2005.</span><span>)</span></a> or TLS-SRP <a class='info' href='#I-D.ietf-tls-srp'>[I&#8209;D.ietf&#8209;tls&#8209;srp]<span> (</span><span class='info'>Taylor, D., &ldquo;Using SRP for TLS Authentication,&rdquo; June&nbsp;2007.</span><span>)</span></a> mode. A peer which does not know the
        key cannot form TLS connections with any other peer and therefore
        cannot join the overlay.
</p>
<p>One natural approach to a shared-secret scheme is to use a
        user-entered password as the key. The difficulty with this is that in
        TLS-PSK mode, such keys are very susceptible to dictionary attacks. If
        passwords are used as the source of shared-keys, then TLS-SRP is a
        superior choice because it is not subject to dictionary attacks.
</p>
<a name="anchor112"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5"></a><h3>15.5.&nbsp;
Storage Security</h3>

<p>When certificate-based security is used in RELOAD, any given
        Resource-ID/kind-id pair (a slot) is bound to some small set of
        certificates. In order to write data in a slot, the writer must prove
        possession of the private key for one of those certificates. Moreover,
        all data is stored signed by the certificate which authorized its
        storage. This set of rules makes questions of authorization and data
        integrity - which have historically been thorny for overlays -
        relatively simple.
</p>
<a name="anchor113"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5.1"></a><h3>15.5.1.&nbsp;
Authorization</h3>

<p>When a client wants to store some value in a slot, it first
          digitally signs the value with its own private key. It then sends a
          Store request that contains both the value and the signature towards
          the storing peer (which is defined by the Resource Name construction
          algorithm for that particular kind of value).
</p>
<p>When the storing peer receives the request, it must determine
          whether the storing client is authorized to store in this slot. In
          order to do so, it executes the Resource Name construction algorithm
          for the specified kind based on the user's certificate information.
          It then computes the Resource-ID from the Resource Name and verifies
          that it matches the slot which the user is requesting to write to.
          If it does, the user is authorized to write to this slot, pending
          quota checks as described in the next section.
</p>
<p>For example, consider the certificate with the following
          properties:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        User name: alice@dht.example.com
        Node-ID:   013456789abcdef
        Serial:    1234
</pre></div>
<p>If Alice wishes to Store a value of the "SIP Location" kind, the
          Resource Name will be the SIP AOR "sip:alice@dht.example.com". The
          Resource-ID will be determined by hashing the Resource Name. When a
          peer receives a request to store a record at Resource-ID X, it takes
          the signing certificate and recomputes the Resource Name, in this
          case "alice@dht.example.com". If H("alice@dht.example.com")=X then
          the Store is authorized. Otherwise it is not. Note that the Resource
          Name construction algorithm may be different for other kinds.
</p>
<a name="anchor114"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5.2"></a><h3>15.5.2.&nbsp;
Distributed Quota</h3>

<p>Being a peer in a Overlay Instance carries with it the
          responsibility to store data for a given region of the Overlay
          Instance. However, if clients were allowed to store unlimited
          amounts of data, this would create unacceptable burdens on peers, as
          well as enabling trivial denial of service attacks. RELOAD addresses
          this issue by requiring configurations to define maximum sizes for each
          kind of stored data. Attempts to store values exceeding this size
          MUST be rejected (if peers are inconsistent about this, then strange
          artifacts will happen when the zone of responsibility shifts and a
          different peer becomes responsible for overlarge data). Because each
          slot is bound to a small set of certificates, these size
          restrictions also create a distributed quota mechanism, with the
          quotas administered by the central enrollment server.
</p>
<p>Allowing different kinds of data to have different size
          restrictions allows new usages the flexibility to define limits that
          fit their needs without requiring all usages to have expansive
          limits.
</p>
<a name="anchor115"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5.3"></a><h3>15.5.3.&nbsp;
Correctness</h3>

<p>Because each stored value is signed, it is trivial for any
          retrieving peer to verify the integrity of the stored value. Some
          more care needs to be taken to prevent version rollback attacks.
          Rollback attacks on storage are prevented by the use of store times
          and lifetime values in each store. A lifetime represents the latest
          time at which the data is valid and thus limits (though does not
          completely prevent) the ability of the storing node to perform a
          rollback attack on retrievers. In order to prevent a rollback attack
          at the time of the Store request, we require that storage times be
          monotonically increasing. Storing peers MUST reject Store requests
          with storage times smaller than or equal to those they are currently
          storing. In addition, a fetching node which receives a data value
          with a storage time older than the result of the previous fetch
          knows a rollback has occurred.
</p>
<a name="anchor116"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.5.4"></a><h3>15.5.4.&nbsp;
Residual Attacks</h3>

<p>The mechanisms described here provide a high degree of security,
          but some attacks remain possible. Most simply, it is possible for
          storing nodes to refuse to store a value (i.e., reject any request).
          In addition, a storing node can deny knowledge of values which it
          previously accepted. To some extent these attacks can be ameliorated
          by attempting to store to/retrieve from replicas, but a retrieving
          client does not know whether it should try this or not, since there
          is a cost to doing so.
</p>
<p>Although the certificate-based authentication scheme prevents a
          single peer from being able to forge data owned by other peers.
          Furthermore, although a subversive peer can refuse to return data
          resources for which it is responsible it cannot return forged data
          because it cannot provide authentication for such registrations.
          Therefore parallel searches for redundant registrations can mitigate
          most of the affects of a compromised peer. The ultimate reliability
          of such an overlay is a statistical question based on the
          replication factor and the percentage of compromised peers.
</p>
<p>In addition, when a kind is is multivalued (e.g., an array data
          model), the storing node can return only some subset of the values,
          thus biasing its responses. This can be countered by using single
          values rather than sets, but that makes coordination between
          multiple storing agents much more difficult. This is a tradeoff that
          must be made when designing any usage.
</p>
<a name="anchor117"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6"></a><h3>15.6.&nbsp;
Routing Security</h3>

<p>Because the storage security system guarantees (within limits) the
        integrity of the stored data, routing security focuses on stopping the
        attacker from performing a DOS attack on the system by misrouting
        requests in the overlay. There are a few obvious observations to make
        about this. First, it is easy to ensure that an attacker is at least a
        valid peer in the Overlay Instance. Second, this is a DOS attack only.
        Third, if a large percentage of the peers on the Overlay Instance are
        controlled by the attacker, it is probably impossible to perfectly
        secure against this.
</p>
<a name="anchor118"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6.1"></a><h3>15.6.1.&nbsp;
Background</h3>

<p>In general, attacks on DHT routing are mounted by the attacker
          arranging to route traffic through or two nodes it controls. In the
          Eclipse attack <a class='info' href='#Eclipse'>[Eclipse]<span> (</span><span class='info'>Singh, A., Ngan, T., Druschel, T., and D. Wallach, &ldquo;Eclipse Attacks on Overlay Networks: Threats and           Defenses,&rdquo; April&nbsp;2006.</span><span>)</span></a> the attacker tampers
          with messages to and from nodes for which it is on-path with respect
          to a given victim node. This allows it to pretend to be all the
          nodes that are reachable through it. In the Sybil attack <a class='info' href='#Sybil'>[Sybil]<span> (</span><span class='info'>Douceur, J., &ldquo;The Sybil Attack,&rdquo; March&nbsp;2002.</span><span>)</span></a>, the attacker registers a large number of
          nodes and is therefore able to capture a large amount of the traffic
          through the DHT.
</p>
<p>Both the Eclipse and Sybil attacks require the attacker to be
          able to exercise control over her peer IDs. The Sybil attack
          requires the creation of a large number of peers. The Eclipse attack
          requires that the attacker be able to impersonate specific peers. In
          both cases, these attacks are limited by the use of centralized,
          certificate-based admission control.
</p>
<a name="anchor119"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6.2"></a><h3>15.6.2.&nbsp;
Admissions Control</h3>

<p>Admission to an RELOAD Overlay Instance is controlled by
          requiring that each peer have a certificate containing its peer ID.
          The requirement to have a certificate is enforced by using
          certificate-based mutual authentication on each connection. Thus,
          whenever a peer connects to another peer, each side automatically
          checks that the other has a suitable certificate. These peer IDs are
          randomly assigned by the central enrollment server. This has two
          benefits:
</p>
<p></p>
<ul class="text">
<li>It allows the enrollment server to limit the number of peer
              IDs issued to any individual user.
</li>
<li>It prevents the attacker from choosing specific peer IDs.
</li>
</ul>

<p>The first property allows protection against Sybil attacks
          (provided the enrollment server uses strict rate limiting policies).
          The second property deters but does not completely prevent Eclipse
          attacks. Because an Eclipse attacker must impersonate peers on the
          other side of the attacker, he must have a certificate for suitable
          peer IDs, which requires him to repeatedly query the enrollment
          server for new certificates which only will match by chance. From
          the attacker's perspective, the difficulty is that if he only has a
          small number of certificates the region of the Overlay Instance he
          is impersonating appears to be very sparsely populated by comparison
          to the victim's local region.
</p>
<a name="anchor120"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6.3"></a><h3>15.6.3.&nbsp;
Peer Identification and Authentication</h3>

<p>In general, whenever a peer engages in overlay activity that
          might affect the routing table it must establish its identity. This
          happens in two ways. First, whenever a peer establishes a direct
          connection to another peer it authenticates via certificate-based
          mutual authentication. All messages between peers are sent over this
          protected channel and therefore the peers can verify the data origin
          of the last hop peer for requests and responses without further
          cryptography.
</p>
<p>In some situations, however, it is desirable to be able to
          establish the identity of a peer with whom one is not directly
          connected. The most natural case is when a peer Updates its state.
          At this point, other peers may need to update their view of the
          overlay structure, but they need to verify that the Update message
          came from the actual peer rather than from an attacker. To prevent
          this, all overlay routing messages are signed by the peer that
          generated them.
</p>
<p>[OPEN ISSUE: this allows for replay attacks on requests. There
          are two basic defenses here. The first is global clocks and loose
          anti-replay. The second is to refuse to take any action unless you
          verify the data with the relevant node. This issue is
          undecided.]
</p>
<p>[TODO: I think we are probably going to end up with generic
          signatures or at least optional signatures on all overlay
          messages.]
</p>
<a name="anchor121"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6.4"></a><h3>15.6.4.&nbsp;
Protecting the Signaling</h3>

<p>The goal here is to stop an attacker from knowing who is
          signaling what to whom. An attacker being able to observe the
          activities of a specific individual is unlikely given the
          randomization of IDs and routing based on the present peers
          discussed above. Furthermore, because messages can be routed using
          only the header information, the actual body of the RELOAD message
          can be encrypted during transmission.
</p>
<p>There are two lines of defense here. The first is the use of TLS
          or DTLS for each communications link between peers. This provides
          protection against attackers who are not members of the overlay. The
          second line of defense, if certificate-based security is used, is to
          digitally sign each message. This prevents adversarial peers from
          modifying messages in flight, even if they are on the routing
          path.
</p>
<a name="anchor122"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.6.5"></a><h3>15.6.5.&nbsp;
Residual Attacks</h3>

<p>The routing security mechanisms in RELOAD are designed to contain
          rather than eliminate attacks on routing. It is still possible for
          an attacker to mount a variety of attacks. In particular, if an
          attacker is able to take up a position on the overlay routing
          between A and B it can make it appear as if B does not exist or is
          disconnected. It can also advertise false network metrics in attempt
          to reroute traffic. However, these are primarily DoS attacks.
</p>
<p>The certificate-based security scheme secures the namespace, but
          if an individual peer is compromised or if an attacker obtains a
          certificate from the CA, then a number of subversive peers can still
          appear in the overlay. While these peers cannot falsify responses to
          resource queries, they can respond with error messages, effecting a
          DoS attack on the resource registration. They can also subvert
          routing to other compromised peers. To defend against such attacks,
          a resource search must still consist of parallel searches for
          replicated registrations.
</p>
<a name="section.sip-issues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7"></a><h3>15.7.&nbsp;
SIP-Specific Issues</h3>

<a name="anchor123"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7.1"></a><h3>15.7.1.&nbsp;
Fork Explosion</h3>

<p>Because SIP includes a forking capability (the ability to
          retarget to multiple recipients), fork bombs are a potential DoS
          concern. However, in the SIP usage of RELOAD, fork bombs are a much
          lower concern because the calling party is involved in each
          retargeting event and can therefore directly measure the number of
          forks and throttle at some reasonable number.
</p>
<a name="sec-security-malicious-retargeting"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7.2"></a><h3>15.7.2.&nbsp;
Malicious Retargeting</h3>

<p>Another potential DoS attack is for the owner of an attractive
          number to retarget all calls to some victim. This attack is
          difficult to ameliorate without requiring the target of a SIP
          registration to authorize all stores. The overhead of that
          requirement would be excessive and in addition there are good use
          cases for retargeting to a peer without there explicit
          cooperation.
</p>
<a name="anchor124"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.15.7.3"></a><h3>15.7.3.&nbsp;
Privacy Issues</h3>

<p>All RELOAD SIP registration data is public. Methods of providing
          location and identity privacy are still being studied.
</p>
<a name="anchor125"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16"></a><h3>16.&nbsp;
IANA Considerations</h3>

<p>This section contains the new code points registered by this
      document.
</p>
<p>[[TODO - add IANA registration for p2p_enroll SRV and
      p2p_menroll]]
</p>
<a name="anchor126"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.1"></a><h3>16.1.&nbsp;
Overlay Algorithm Types</h3>

<p>IANA SHALL create/(has created) a "RELOAD Overlay Algorithm Type"
        Registry. Entries in this registry are strings denoting the names of
        overlay algorithms. The registration policy for this registry is
        RFC 5226 IETF Review.
</p>
<p>The initial contents of this registry are:
</p>
<p></p>
<blockquote class="text"><dl>
<dt></dt>
<dd>
</dd>
<dt>chord-128-2-16+ </dt>
<dd>
</dd>
<dt></dt>
<dd>The algorithm defined in <a class='info' href='#sec.chord-algorithm'>Section&nbsp;12<span> (</span><span class='info'>Chord Algorithm </span><span>)</span></a> of this document.
</dd>
</dl></blockquote>

<a name="anchor127"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.2"></a><h3>16.2.&nbsp;
Data Kind-Id</h3>

<p>IANA SHALL create/(has created) a "RELOAD Data Kind-Id" Registry.
        Entries in this registry are 32-bit integers denoting data kinds, as
        described in <a class='info' href='#sec-usages'>Section&nbsp;4.1.2<span> (</span><span class='info'>Usages</span><span>)</span></a>. Code points
	in the range 0x00000000 to 0x7fffffff SHALL be registered via RFC 5226
	Standards Action. Code points in the range 0x8000000 to 0xffffffff
	SHALL be registered via RFC 5226 Expert Review.
</p>
<p>The initial contents of this registry are:
</p>
<p>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="right">
<tr><th align="left">Kind</th><th align="right">Kind-Id</th></tr>
<tr>
<td align="left">SIP-REGISTRATION</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">TURN_SERVICE</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">CERTIFICATE</td>
<td align="right">3</td>
</tr>
<tr>
<td align="left">ROUTING_TABLE_SIZE</td>
<td align="right">4</td>
</tr>
<tr>
<td align="left">SOFTWARE_VERSION</td>
<td align="right">5</td>
</tr>
<tr>
<td align="left">MACHINE_UPTIME</td>
<td align="right">6</td>
</tr>
<tr>
<td align="left">APP_UPTIME</td>
<td align="right">7</td>
</tr>
<tr>
<td align="left">MEMORY_FOOTPRINT</td>
<td align="right">8</td>
</tr>
<tr>
<td align="left">DATASIZE_StoreD</td>
<td align="right">9</td>
</tr>
<tr>
<td align="left">INSTANCES_StoreD</td>
<td align="right">10</td>
</tr>
<tr>
<td align="left">MESSAGES_SENT_RCVD</td>
<td align="right">11</td>
</tr>
<tr>
<td align="left">EWMA_BYTES_SENT</td>
<td align="right">12</td>
</tr>
<tr>
<td align="left">EWMA_BYTES_RCVD</td>
<td align="right">13</td>
</tr>
<tr>
<td align="left">LAST_CONTACT</td>
<td align="right">14</td>
</tr>
<tr>
<td align="left">RTT</td>
<td align="right">15</td>
</tr>
</table>
<br clear="all" />

<a name="anchor128"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.3"></a><h3>16.3.&nbsp;
Data Model</h3>

<p>IANA SHALL create/(has created) a "RELOAD Data Model" Registry.
        Entries in this registry are 8-bit integers denoting data models, as
	described in <a class='info' href='#sec-kind-model'>Section&nbsp;7.2<span> (</span><span class='info'>Data Models</span><span>)</span></a>. Code points in
	this registry SHALL be registered via RFC 5226 IETF Review.
</p>
<p>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="right">
<tr><th align="left">Data Model</th><th align="right">Identifier</th></tr>
<tr>
<td align="left">SINGLE_VALUE</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">ARRAY</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">DICTIONARY</td>
<td align="right">3</td>
</tr>
</table>
<br clear="all" />

<a name="anchor129"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.4"></a><h3>16.4.&nbsp;
Message Codes</h3>

<p>IANA SHALL create/(has created) a "RELOAD Message Code" Registry.
        Entries in this registry are 16-bit integers denoting method codes as
        described in <a class='info' href='#sec-contents'>Section&nbsp;6.2.3<span> (</span><span class='info'>Message Contents Format</span><span>)</span></a>. These codes SHALL
	be registred via RFC 5226 Standards Track.
</p>
<p>The initial contents of this registry are:
</p>
<p>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="right">
<tr><th align="left">Message Code Name</th><th align="right">Code Value</th></tr>
<tr>
<td align="left">reserved</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">ping_req</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">ping_ans</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">attach_req</td>
<td align="right">3</td>
</tr>
<tr>
<td align="left">attach_ans</td>
<td align="right">4</td>
</tr>
<tr>
<td align="left">tunnel_req</td>
<td align="right">5</td>
</tr>
<tr>
<td align="left">tunnel_ans</td>
<td align="right">6</td>
</tr>
<tr>
<td align="left">store_req</td>
<td align="right">7</td>
</tr>
<tr>
<td align="left">store_ans</td>
<td align="right">8</td>
</tr>
<tr>
<td align="left">fetch_req</td>
<td align="right">9</td>
</tr>
<tr>
<td align="left">fetch_ans</td>
<td align="right">10</td>
</tr>
<tr>
<td align="left">remove_req</td>
<td align="right">11</td>
</tr>
<tr>
<td align="left">remove_ans</td>
<td align="right">12</td>
</tr>
<tr>
<td align="left">find_req</td>
<td align="right">13</td>
</tr>
<tr>
<td align="left">find_ans</td>
<td align="right">14</td>
</tr>
<tr>
<td align="left">join_req</td>
<td align="right">15</td>
</tr>
<tr>
<td align="left">join_ans</td>
<td align="right">16</td>
</tr>
<tr>
<td align="left">leave_req</td>
<td align="right">17</td>
</tr>
<tr>
<td align="left">leave_ans</td>
<td align="right">18</td>
</tr>
<tr>
<td align="left">update_req</td>
<td align="right">19</td>
</tr>
<tr>
<td align="left">update_ans</td>
<td align="right">20</td>
</tr>
<tr>
<td align="left">route_query_req</td>
<td align="right">21</td>
</tr>
<tr>
<td align="left">route_query_ans</td>
<td align="right">22</td>
</tr>
<tr>
<td align="left">reserved</td>
<td align="right">0x8000..0xfffe</td>
</tr>
<tr>
<td align="left">error</td>
<td align="right">0xffff</td>
</tr>
</table>
<br clear="all" />

<a name="anchor130"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.5"></a><h3>16.5.&nbsp;
Error Codes</h3>

<p>IANA SHALL create/(has created) a "RELOAD Error Code" Registry.
        Entries in this registry are 16-bit integers denoting error codes.
	New entries SHALL be defined via RFC 5226 Standards Track.
</p>
<a name="anchor131"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.6"></a><h3>16.6.&nbsp;
Route Log Extension Types</h3>

<p>IANA SHALL create/(has created) a "RELOAD Route Log Extension Type
        Registry. This registry is currently empty. New entries SHALL be 
	defined via RFC 5226 Expert Review.
</p>
<a name="anchor132"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.7"></a><h3>16.7.&nbsp;
Transport Types</h3>

<p>IANA shall create/(has created) a "RELOAD Transport Type Registry."
	This registry SHALL be initially populated with the following
	values:
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
            reserved     0
            tcp_tls      1
            udp_dtls     2
</pre></div>
<p>
	  New entries SHALL be defined via RFC 5226 Standards Action.
	
</p>
<a name="anchor133"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.8"></a><h3>16.8.&nbsp;
Forwarding Options</h3>

<p>IANA shall create/(has created) a "RELOAD Forwarding Option Registry".
	Entries in this registry between 0 and 127 SHALL be defined via RFC
	5226 Standards Track. Entries in this registry between 128 and
	255 SHALL be defined via RFC 5226 Specification Required.
	
</p>
<a name="anchor134"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.9"></a><h3>16.9.&nbsp;
Ping Information Types</h3>

<p>IANA shall create/(has created) a "RELOAD Ping Information Type
	Registry". This registry SHALL be initially populated with the
	following values:
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
            responsible_set  1
            requested_info   2
</pre></div>
<p>
	  Entries in this registry SHALL be defined via RFC 5226 Standards Track.
	
</p>
<a name="sec-reload-uri"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.10"></a><h3>16.10.&nbsp;
reload: URI Scheme</h3>

<p>This section describes the scheme for a reload: URI, which can be
        used to refer to either: 
</p>
<p> </p>
<ul class="text">
<li>A peer.
</li>
<li>A resource inside a peer.
</li>
</ul><p> 
</p>
<p> The reload: URI is defined using a subset of the URI
        schema specified in Appendix A. of RFC 3986 [REF] and the associated
        URI Guidelines [REF: RFC4395] per the following ABNF syntax: 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    RELOAD-URI = "reload://" destination "@" overlay "/"
             [specifier]

          destination = 1 * HEXDIG
    overlay = reg-name
    specifier = 1*HEXDIG

</pre></div>
<p> The definitions of these productions are as follows: 
</p>
<p> </p>
<blockquote class="text"><dl>
<dt>destination: </dt>
<dd>a hex-encoded Destination List
            object.
</dd>
<dt></dt>
<dd>
</dd>
<dt>overlay: </dt>
<dd>the name of the overlay.
</dd>
<dt></dt>
<dd>
</dd>
<dt>specifier :</dt>
<dd>a hex-encoded StoredDataSpecifier
            indicating the data element.
</dd>
</dl></blockquote>

<p>If no specifier is present than this URI addresses the peer which
        can be reached via the indicated destination list at the indicated
        overlay name. If a specifier is present, then the URI addresses the
        data value.
</p>
<a name="anchor135"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.16.10.1"></a><h3>16.10.1.&nbsp;
URI Registration</h3>

<p>The following summarizes the information necessary to register
          the reload: URI. [NOTE TO IANA/RFC-EDITOR: Please replace XXXX with
          the RFC number for this specification in the following list.]
</p>
<p></p>
<blockquote class="text"><dl>
<dt>URI Scheme Name: </dt>
<dd>reload
</dd>
<dt>Status: </dt>
<dd>permanent
</dd>
<dt>URI Scheme Syntax: </dt>
<dd>see <a class='info' href='#sec-reload-uri'>Section&nbsp;16.10<span> (</span><span class='info'>reload: URI Scheme</span><span>)</span></a>.
</dd>
<dt>URI Scheme Semantics: </dt>
<dd>The reload: URI is intended
              to be used as a reference to a RELOAD peer or resource.
</dd>
<dt>Encoding Considerations: </dt>
<dd>The reload: URI is not
              intended to be human-readable text, therefore they are encoded
              entirely in US-ASCII.
</dd>
<dt>Applications/protocols that use this URI scheme: </dt>
<dd>The
              RELOAD protocol described in RFC XXXX.
</dd>
<dt></dt>
<dd>TBD for the rest of this template.
</dd>
</dl></blockquote>

<a name="anchor136"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.17"></a><h3>17.&nbsp;
Acknowledgments</h3>

<p>This draft is a merge of the "REsource LOcation And Discovery
      (RELOAD)" draft by David A. Bryan, Marcia Zangrilli and Bruce B.
      Lowekamp, the "Address Settlement by Peer to Peer" draft by Cullen
      Jennings, Jonathan Rosenberg, and Eric Rescorla, the "Security
      Extensions for RELOAD" draft by Bruce B. Lowekamp and James Deverick,
      the "A Chord-based DHT for Resource Lookup in P2PSIP" by Marcia
      Zangrilli and David A. Bryan, and the Peer-to-Peer Protocol (P2PP) draft
      by Salman A. Baset, Henning Schulzrinne, and Marcin Matuszewski.
</p>
<p>Thanks to the many people who contributed including: Michael Chen,
      TODO - fill in.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.18"></a><h3>18.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>18.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate
          Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[I-D.ietf-mmusic-ice]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-16.txt">Interactive Connectivity Establishment (ICE): A Protocol for
          Network Address Translator (NAT) Traversal for Offer/Answer
          Protocols</a>,&rdquo; draft-ietf-mmusic-ice-16 (work in progress), June&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-16.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-rfc3489bis">[I-D.ietf-behave-rfc3489bis]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-06.txt">Session Traversal Utilities for (NAT) (STUN)</a>,&rdquo; draft-ietf-behave-rfc3489bis-06 (work in progress), March&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-turn">[I-D.ietf-behave-turn]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-03.txt">Obtaining Relay Addresses from Simple Traversal Underneath
          NAT (STUN)</a>,&rdquo; draft-ietf-behave-turn-03 (work in progress), March&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-pkix-cmc-trans">[I-D.ietf-pkix-cmc-trans]</a></td>
<td class="author-text">Schaad, J. and M. Myers, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-pkix-cmc-trans-05.txt">Certificate Management over CMS (CMC) Transport
          Protocols</a>,&rdquo; draft-ietf-pkix-cmc-trans-05 (work in progress), May&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-pkix-cmc-trans-05.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-pkix-2797-bis">[I-D.ietf-pkix-2797-bis]</a></td>
<td class="author-text">Myers, M. and J. Schaad, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-pkix-2797-bis-04.txt">Certificate Management Messages over CMS</a>,&rdquo; draft-ietf-pkix-2797-bis-04 (work in progress), March&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-pkix-2797-bis-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4279">[RFC4279]</a></td>
<td class="author-text">Eronen, P. and H. Tschofenig, &ldquo;<a href="http://tools.ietf.org/html/rfc4279">Pre-Shared Key Ciphersuites for Transport Layer Security
          (TLS)</a>,&rdquo; RFC&nbsp;4279, December&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4279.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tls-srp">[I-D.ietf-tls-srp]</a></td>
<td class="author-text">Taylor, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-srp-14.txt">Using SRP for TLS Authentication</a>,&rdquo; draft-ietf-tls-srp-14 (work in progress), June&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-srp-14.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice-tcp">[I-D.ietf-mmusic-ice-tcp]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-tcp-03.txt">TCP Candidates with Interactive Connectivity Establishment
          (ICE</a>,&rdquo; draft-ietf-mmusic-ice-tcp-03 (work in progress), March&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-tcp-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3261">[RFC3261]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., and J. Peterson, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3263">[RFC3263]</a></td>
<td class="author-text">Rosenberg, J. and H. Schulzrinne, &ldquo;<a href="http://tools.ietf.org/html/rfc3263">Session Initiation Protocol (SIP): Locating SIP
          Servers</a>,&rdquo; RFC&nbsp;3263, June&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3263.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4347">[RFC4347]</a></td>
<td class="author-text">Rescorla, E. and N. Modadugu, &ldquo;<a href="http://tools.ietf.org/html/rfc4347">Datagram Transport Layer Security</a>,&rdquo; RFC&nbsp;4347, April&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4347.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4828">[RFC4828]</a></td>
<td class="author-text">Floyd, S. and E. Kohler, &ldquo;<a href="http://tools.ietf.org/html/rfc4828">TCP Friendly Rate Control (TFRC): The Small-Packet (SP)
          Variant</a>,&rdquo; RFC&nbsp;4828, April&nbsp;2007 (<a href="ftp://ftp.isi.edu/in-notes/rfc4828.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>18.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-tcp">[I-D.ietf-behave-tcp]</a></td>
<td class="author-text">Guha, S., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-tcp-07.txt">NAT Behavioral Requirements for TCP</a>,&rdquo; draft-ietf-behave-tcp-07 (work in progress), April&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-tcp-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-p2psip-concepts">[I-D.ietf-p2psip-concepts]</a></td>
<td class="author-text">Bryan, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-p2psip-concepts-00.txt">Concepts and Terminology for Peer to Peer SIP</a>,&rdquo; draft-ietf-p2psip-concepts-00 (work in progress), July&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-p2psip-concepts-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4145">[RFC4145]</a></td>
<td class="author-text">Yon, D. and G. Camarillo, &ldquo;<a href="http://tools.ietf.org/html/rfc4145">TCP-Based Media Transport in the Session Description Protocol
          (SDP)</a>,&rdquo; RFC&nbsp;4145, September&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4145.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2818">[RFC2818]</a></td>
<td class="author-text">Rescorla, E., &ldquo;<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>,&rdquo; RFC&nbsp;2818, May&nbsp;2000 (<a href="ftp://ftp.isi.edu/in-notes/rfc2818.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text">Eastlake, D., Schiller, J., and S. Crocker, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>,&rdquo; BCP&nbsp;106, RFC&nbsp;4086, June&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4086.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3280">[RFC3280]</a></td>
<td class="author-text">Housley, R., Polk, W., Ford, W., and D. Solo, &ldquo;<a href="http://tools.ietf.org/html/rfc3280">Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;3280, April&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3280.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Sybil">[Sybil]</a></td>
<td class="author-text">Douceur, J., &ldquo;<a href="http://www.cs.rice.edu/Conferences/IPTPS02/101.pdf">The Sybil Attack</a>,&rdquo; IPTPS&nbsp;02, March&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="Eclipse">[Eclipse]</a></td>
<td class="author-text">Singh, A., Ngan, T., Druschel, T., and D. Wallach, &ldquo;Eclipse Attacks on Overlay Networks: Threats and
          Defenses,&rdquo; INFOCOM&nbsp;2006, April&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.cheshire-dnsext-multicastdns">[I-D.cheshire-dnsext-multicastdns]</a></td>
<td class="author-text">Cheshire, S. and M. Krochmal, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-multicastdns-06.txt">Multicast DNS</a>,&rdquo; draft-cheshire-dnsext-multicastdns-06 (work in progress), August&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-multicastdns-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.cheshire-dnsext-dns-sd">[I-D.cheshire-dnsext-dns-sd]</a></td>
<td class="author-text">Krochmal, M. and S. Cheshire, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-04.txt">DNS-Based Service Discovery</a>,&rdquo; draft-cheshire-dnsext-dns-sd-04 (work in progress), August&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.matthews-p2psip-bootstrap-mechanisms">[I-D.matthews-p2psip-bootstrap-mechanisms]</a></td>
<td class="author-text">Cooper, E., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-matthews-p2psip-bootstrap-mechanisms-00.txt">Bootstrap Mechanisms for P2PSIP</a>,&rdquo; draft-matthews-p2psip-bootstrap-mechanisms-00 (work in progress), February&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-matthews-p2psip-bootstrap-mechanisms-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.garcia-p2psip-dns-sd-bootstrapping">[I-D.garcia-p2psip-dns-sd-bootstrapping]</a></td>
<td class="author-text">Garcia, G., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-garcia-p2psip-dns-sd-bootstrapping-00.txt">P2PSIP bootstrapping using DNS-SD</a>,&rdquo; draft-garcia-p2psip-dns-sd-bootstrapping-00 (work in progress), October&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-garcia-p2psip-dns-sd-bootstrapping-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.camarillo-hip-bone">[I-D.camarillo-hip-bone]</a></td>
<td class="author-text">Camarillo, G., Nikander, P., and J. Hautakorpi, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-camarillo-hip-bone-00.txt">HIP BONE: Host Identity Protocol (HIP) Based Overlay
          Networking Environment</a>,&rdquo; draft-camarillo-hip-bone-00 (work in progress), December&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-camarillo-hip-bone-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.pascual-p2psip-clients">[I-D.pascual-p2psip-clients]</a></td>
<td class="author-text">Pascual, V., Matuszewski, M., Shim, E., Zhang, H., and S. Yongchao, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-pascual-p2psip-clients-01.txt">P2PSIP Clients</a>,&rdquo; draft-pascual-p2psip-clients-01 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-pascual-p2psip-clients-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4787">[RFC4787]</a></td>
<td class="author-text">Audet, F. and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for
          Unicast UDP</a>,&rdquo; BCP&nbsp;127, RFC&nbsp;4787, January&nbsp;2007 (<a href="ftp://ftp.isi.edu/in-notes/rfc4787.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.jiang-p2psip-sep">[I-D.jiang-p2psip-sep]</a></td>
<td class="author-text">Jiang, X. and H. Zhang, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-jiang-p2psip-sep-01.txt">Service Extensible P2P Peer Protocol</a>,&rdquo; draft-jiang-p2psip-sep-01 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-jiang-p2psip-sep-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="stoica-non-transitive-worlds05">[stoica-non-transitive-worlds05]</a></td>
<td class="author-text">Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &ldquo;Non-Transitive Connectivity and DHTs,&rdquo; &nbsp;WORLDS'05.</td></tr>
<tr><td class="author-text" valign="top"><a name="stoica-geometry-sigcomm03">[stoica-geometry-sigcomm03]</a></td>
<td class="author-text">Gummadi, K., Gummadi, R., Gribble, S., Ratnasamy, S., Shenker, S., and I. Stoica, &ldquo;The Impact of DHT Routing Geometry on Resilience and
          Proximity,&rdquo; &nbsp;SIGCOMM'03.</td></tr>
<tr><td class="author-text" valign="top"><a name="ng-analytical-churn-ieeep2p06">[ng-analytical-churn-ieeep2p06]</a></td>
<td class="author-text">Wu, D., Tian, Y., and K. Ng, &ldquo;Analytical Study on Improving DHT Lookup Performance under
          Churn,&rdquo; &nbsp;IEEE P2P'06.</td></tr>
<tr><td class="author-text" valign="top"><a name="bryan-design-hotp2p08">[bryan-design-hotp2p08]</a></td>
<td class="author-text">Bryan, D., Lowekamp, B., and M. Zangrilli, &ldquo;The Design of a Versatile, Secure P2PSIP Communications
          Architecture for the Public Internet,&rdquo; &nbsp;Hot-P2P'08.</td></tr>
<tr><td class="author-text" valign="top"><a name="opendht-sigcomm05">[opendht-sigcomm05]</a></td>
<td class="author-text">Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J., Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu, &ldquo;OpenDHT: A Public DHT and its Uses,&rdquo; &nbsp;SIGCOMM'05.</td></tr>
<tr><td class="author-text" valign="top"><a name="Chord">[Chord]</a></td>
<td class="author-text">Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, &ldquo;<a href="http://pdos.csail.mit.edu/chord/papers/paper-ton.pdf">Chord: A Scalable Peer-to-peer Lookup Service for Internet
          Applications</a>,&rdquo; IEEE/ACM Transactions on Networking&nbsp;Volume 11, Issue 1, 17-32, Feb 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="vulnerabilities-acsac04">[vulnerabilities-acsac04]</a></td>
<td class="author-text">Srivatsa, M. and L. Liu, &ldquo;Vulnerabilities and Security Threats in Structured
          Peer-to-Peer Systems: A Quantitative Analysis,&rdquo; &nbsp;ACSAC 2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.zheng-p2psip-diagnose">[I-D.zheng-p2psip-diagnose]</a></td>
<td class="author-text">Yongchao, S., Zhang, H., and X. Jiang, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-zheng-p2psip-diagnose-02.txt">Diagnose P2PSIP Overlay Network Failures</a>,&rdquo; draft-zheng-p2psip-diagnose-02 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-zheng-p2psip-diagnose-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.song-p2psip-security-eval">[I-D.song-p2psip-security-eval]</a></td>
<td class="author-text">Yongchao, S., Zhao, B., Jiang, X., and J. Haifeng, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-song-p2psip-security-eval-00.txt">P2PSIP Security Analysis and Evaluation</a>,&rdquo; draft-song-p2psip-security-eval-00 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-song-p2psip-security-eval-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.matthews-p2psip-id-loc">[I-D.matthews-p2psip-id-loc]</a></td>
<td class="author-text">Cooper, E., Johnston, A., and P. Matthews, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-matthews-p2psip-id-loc-01.txt">An ID/Locator Architecture for P2PSIP</a>,&rdquo; draft-matthews-p2psip-id-loc-01 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-matthews-p2psip-id-loc-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.zheng-p2psip-client-protocol">[I-D.zheng-p2psip-client-protocol]</a></td>
<td class="author-text">Yongchao, S., Jiang, X., Zhang, H., and H. Deng, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-zheng-p2psip-client-protocol-01.txt">P2PSIP Client Protocol</a>,&rdquo; draft-zheng-p2psip-client-protocol-01 (work in progress), February&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-zheng-p2psip-client-protocol-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.hardie-p2poverlay-pointers">[I-D.hardie-p2poverlay-pointers]</a></td>
<td class="author-text">Hardie, T., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-hardie-p2poverlay-pointers-00.txt">Mechanisms for use in pointing to overlay networks, nodes, or resources</a>,&rdquo; draft-hardie-p2poverlay-pointers-00 (work in progress), January&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-hardie-p2poverlay-pointers-00.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cullen Jennings</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">170 West Tasman Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">MS: SJC-21/2</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95134</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 408 421-9990</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:fluffy@cisco.com">fluffy@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bruce B. Lowekamp</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">SIPeerior Technologies</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">3000 Easter Circle</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Williamsburg, VA  23188</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 757 565 0101</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lowekamp@sipeerior.com">lowekamp@sipeerior.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Eric Rescorla</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Network Resonance</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">2064 Edgewood Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, CA  94303</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 650 320-8549</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ekr@networkresonance.com">ekr@networkresonance.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Salman A. Baset</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Columbia University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1214 Amsterdam Avenue</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">New York, NY</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:salman@cs.columbia.edu">salman@cs.columbia.edu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Henning Schulzrinne</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Columbia University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1214 Amsterdam Avenue</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">New York, NY</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hgs@cs.columbia.edu">hgs@cs.columbia.edu</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
