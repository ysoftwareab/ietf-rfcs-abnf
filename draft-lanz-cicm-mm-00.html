<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Common Interface to Cryptographic Modules (CICM) Module Management</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Common Interface to Cryptographic Modules (CICM) Module Management">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Internet Engineering Task Force</td><td class="header">D. Lanz</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">L. Novikov</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">MITRE</td></tr>
<tr><td class="header">Expires: July 12, 2011</td><td class="header">January 8, 2011</td></tr>
</table></td></tr></table>
<h1><br />Common Interface to Cryptographic Modules (CICM) Module Management<br />draft-lanz-cicm-mm-00</h1>

<h3>Abstract</h3>

<p>[RFC Editor: Please update the RFC references prior to publication.]
</p>
<p>This memo defines a programming interface for high-level management of
      cryptographic modules as outlined in draft-lanz-cicm-model-00
      and required by draft-lanz-cicm-02 including managing the module authentication,
      software, logs, built-in tests, and responding to module events.
</p>
<p>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on July 12, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2011 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Definition Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Conformance and Extension Language<br />
<a href="#anchor5">2.</a>&nbsp;
CICM Dependencies<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.1.</a>&nbsp;
Namespaces<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.</a>&nbsp;
Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.</a>&nbsp;
Interfaces<br />
<a href="#anchor9">3.</a>&nbsp;
Hardware Access Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.1.</a>&nbsp;
Token Management Identifiers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.2.</a>&nbsp;
Interface CICM::TokenManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.3.</a>&nbsp;
Interface CICM::TokenAssnIterator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.4.</a>&nbsp;
Interface CICM::ModuleAssnIterator<br />
<a href="#anchor20">4.</a>&nbsp;
Users<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.1.</a>&nbsp;
User Management Identifiers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.2.</a>&nbsp;
Interface CICM::UserManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">4.3.</a>&nbsp;
Interface CICM::UserIdIterator<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">4.4.</a>&nbsp;
Interface CICM::RoleIdIterator<br />
<a href="#anchor31">5.</a>&nbsp;
Login<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">5.1.</a>&nbsp;
Interface CICM::LoginManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">5.2.</a>&nbsp;
Interface CICM::Login<br />
<a href="#anchor36">6.</a>&nbsp;
Software Packages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">6.1.</a>&nbsp;
Package Management Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">6.2.</a>&nbsp;
Interface CICM::PackageManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">6.3.</a>&nbsp;
Interface CICM::PackageImporter<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">6.4.</a>&nbsp;
Interface CICM::Package<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">6.5.</a>&nbsp;
Interface CICM::PackageIterator<br />
<a href="#anchor50">7.</a>&nbsp;
Logs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">7.1.</a>&nbsp;
Interface CICM::LogManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor54">7.2.</a>&nbsp;
Interface CICM::LogEntry<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">7.3.</a>&nbsp;
Interface CICM::LogEntryIterator<br />
<a href="#anchor60">8.</a>&nbsp;
Tests<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor61">8.1.</a>&nbsp;
Interface CICM::TestManager<br />
<a href="#anchor64">9.</a>&nbsp;
Module Events<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor65">9.1.</a>&nbsp;
Interface CICM::ModuleEventManager<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor67">9.2.</a>&nbsp;
Interface CICM::ModuleEventListener<br />
<a href="#anchor70">10.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor71">11.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor72">11.1.</a>&nbsp;
Unauthorized Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor73">11.2.</a>&nbsp;
Inappropriate Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor74">11.3.</a>&nbsp;
Denial of Service<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#idl-code">Appendix&nbsp;A.</a>&nbsp;
IDL Definitions<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document defines the module management functions for the Common Interface to
      Cryptographic Modules (CICM) as defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>. The underlying logical
      model and terminology are defined in <a class='info' href='#CICM-LM'>[CICM&#8209;LM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Logical Model           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Definition Language</h3>

<p>This document uses the Interface Definition Language (IDL) <a class='info' href='#IDL'>[IDL]<span> (</span><span class='info'>International Standards Organization, &ldquo;Information technology — Open Distributed Processing — Interface Definition Language,&rdquo; March&nbsp;1999.</span><span>)</span></a> to
        specify language-neutral interfaces and is not intended to prescribe or preclude a particular
        communications protocol such as General Inter-ORB Protocol (GIOP) <a class='info' href='#CORBA'>[CORBA]<span> (</span><span class='info'>Object Management Group, &ldquo;Common Object Request Broker Architecture (CORBA) Specification, Version 3.1,&rdquo; January&nbsp;2008.</span><span>)</span></a>
        between programs in different address spaces or on different devices. See Definition Language 
        in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for more information.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Conformance and Extension Language</h3>

<p>This document contains definitions for several opaque data parameters whose
        format is not defined by CICM. Instead, implementers are required to create an
        Implementation Conformance Statement which MUST reference a standard format or
        define a module developer-specific format implemented by the module for these
        datatypes. See Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for more details.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
CICM Dependencies</h3>

<p>This document depends on type definitions and interfaces that
      are defined in other CICM documents.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Namespaces</h3>

<p>The CICM namespace is defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Types</h3>

<p>The following type definitions are defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>:
          </p>
<blockquote class="text">
<p>CICM::UInt32
</p>
<p>CICM::CharString
</p>
<p>CICM::Buffer
</p>
<p>CICM::Status (including all return values)
</p>
</blockquote><p>
        
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Interfaces</h3>

<p>The interface CICM::Iterator is defined in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>; the CICM::SymKey
        interface is defined in <a class='info' href='#CICM-KM'>[CICM&#8209;KM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Key Management           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Hardware Access Tokens</h3>

<p>Cryptographic modules may rely upon hardware
      access tokens for two primary functions: to allow subjects (e.g.,
      administrators or users in possession of a token) to be identified
      and authenticated so that privileges can be enforced and audit log
      entries can identify the subject; and to unlock all or some subset
      of cryptographic services. A hardware access token may be
      associated with a number of specific modules, and a module may
      likewise be associated with a number of specific tokens. The token
      management functions below enable tokens and modules to be
      associated with and disassociated from one another, and allow
      existing associations to be listed.
</p>
<p>The removal of an association between a token and a module is
      straightforward if both the token and the module are available.
      However, if either the token or module are unavailable, or if a
      different module than the one originally associated with the token
      is used to remove an association from a token, the disassociation
      is less straightforward.
</p>
<p>If a module requires that an administrative token be inserted
      prior to the token to which the association/disassociation will
      apply, the methods below may return an CICM::S_TOKEN_NOT_PRESENT or
      CICM::S_TOKEN_ADMIN_NOT_PRESENT status.
</p>
<p>Modules that do not support hardware tokens may instead provide
      similar support via CICM::LoginManager. Modules may use
      CICM::LoginManager in tandem with tokens to support multi-factor
      authentication. See Managing Module Authentication
      in <a class='info' href='#CICM-LM'>[CICM&#8209;LM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Logical Model           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for additional information.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Token Management Identifiers</h3>

<p>Type CICM::TokenRecord
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString TokenRecord;</pre></div>
<p>Unique token association record.
</p>
<p>Type CICM::ModuleRecord
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString ModuleRecord;</pre></div>
<p>Unique module association record.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Interface CICM::TokenManager</h3>

<p>Interface CICM::TokenManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface TokenManager {</pre></div>
<p>CICM::TokenManager supports associating and disassociating
					  modules and tokens. It is accessed from CICM::CryptoModule via the
					  CICM::CryptoModule::token_manager attribute. CICM::TokenManager
					  constructs the CICM::ModuleAssnIterator and CICM::TokenAssnIterator
					  interfaces.
</p>
<p>Example (C++):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::tokenManager tokenManager;

// Retrieve reference to the token manager.
tokenManager = device._get_token_manager();

// Associate the current token with the module.
sCode = tokenManager.associate();

// Assume that some time later the token is lost or destroyed.

// Disassociate the token from the module.
CICM::TokenUniqueId tokenId = new CICM::TokenUniqueId("TOKEN1426864");
sCode = tokenManager.disassociate_missing_token(tokenId);
</pre></div>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
CICM::TokenManager Attributes</h3>

<p>Attribute CICM::TokenManager::module_association_iterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::ModuleAssnIterator
	module_association_iterator;</pre></div>
<p>Returns an iterator to enable each module identifier
						  associated with the current token to be retrieved.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The returned iterator is set to the beginning of the iterated sequence.
</p>
</blockquote><p>
						
</p>
<p>Attribute CICM::TokenManager::token_association_iterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::TokenAssnIterator
	token_association_iterator;</pre></div>
<p>Returns an iterator to enable each token identifier
						  associated with the current module to be retrieved.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The returned iterator is set to the beginning of the iterated
							  sequence.
</p>
</blockquote><p>
						
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
CICM::TokenManager Methods</h3>

<p>Method CICM::TokenManager::associate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status associate(
	out CICM::ModuleRecord module_rec,
	out CICM::TokenRecord token_rec
);</pre></div>
<p>Associate the module and currently-inserted hardware access
						   token.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The module and token record identifiers should be recorded
								for use in the disassociation process in the event that either
								the module or the token are no longer available or usable.
</p>
<p>The formats of the module and token records are not defined
								by CICM. The Implementation Conformance Statement (see Conformance
                and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>)
                MUST reference a standard format or define a module developer-specific
                format implemented by the module for these datatypes.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] module_rec Module record identifier of the newly associated module.
</p>
<p>[in] token_rec Token record identifier of the newly associated token.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS, S_TOKEN_RESOURCES,
								  S_TOKEN_ASSOC_EXISTS, S_TOKEN_ASSOC_AT_MODULE,
								  S_TOKEN_ASSOC_AT_TOKEN, S_TOKEN_ASSOC_GENERAL,
								  S_TOKEN_TIMEOUT
</p>
</blockquote><p>
						
</p>
<p>Method CICM::TokenManager::disassociate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status disassociate();</pre></div>
<p>Disassociate the module and currently-inserted hardware
							access token when the associated module and token are both present
							and both recognize the association.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS,
								  S_TOKEN_ASSOC_NOT_EXIST, S_TOKEN_DISASSOC_GENERAL,
								  S_TOKEN_TIMEOUT, S_TOKEN_LAST_ASSOCIATED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::TokenManager::disassociate_missing_module()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status disassociate_missing_module(
	in  CICM::ModuleRecord module_rec
);</pre></div>
<p>Remove association information from the currently-inserted
							hardware access token when the associated module is not
							present.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The module on which this method is being executed is used
								as a surrogate to perform the disassociation (it is not the
								module that performed the initial association). The specific
								module to disassociate from the token is identified by a unique
								module identifier (e.g., a module serial number). Use
								CICM::ModuleAssnIterator to retrieve module record identifiers
								corresponding to modules associated with the inserted token.
</p>
<p>The format of the module record is not defined by CICM. The
								Implementation Conformance Statement (see Conformance and Extensions
                in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] module_rec Identifies the module for which module identification
								  information should be removed from the currently-inserted
								  hardware access token.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS,
								  S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND,
								  S_TOKEN_TIMEOUT
</p>
</blockquote><p>
						
</p>
<p>Method CICM::TokenManager::disassociate_missing_token()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status disassociate_missing_token(
	in  CICM::TokenRecord token_rec
);</pre></div>
<p>Remove association information from the module on which this
							method is being executed when the associated token is not
							present.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The specific token to disassociate from the module is
								identified by a unique token identifier (e.g., a token serial
								number). Use CICM::TokenAssnIterator to retrieve token record
								identifiers corresponding to associated tokens from the module.
</p>
<p>The format of the token record is not defined by CICM. The
								Implementation Conformance Statement (see Conformance and Extensions
                in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] token_rec Identifies the hardware access token for which token
								  identification information should be removed from the
								  module.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ASSOC_NOT_EXIST,
								  S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND,
								  S_TOKEN_TIMEOUT
</p>
</blockquote><p>
						
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Interface CICM::TokenAssnIterator</h3>

<p>Interface CICM::TokenAssnIterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface TokenAssnIterator : CICM::Iterator {</pre></div>
<p>CICM::TokenAssnIterator supports retrieving each token record
						from the token association list in the module.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
CICM::TokenAssnIterator Inheritance</h3>

<p>CICM::TokenAssnIterator inherits from: CICM::Iterator.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
CICM::TokenAssnIterator Methods</h3>

<p>Method CICM::TokenAssnIterator::get_next()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_next(
	out CICM::TokenRecord token_rec_ref
);</pre></div>
<p>Returns a reference to the next token.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Use CICM::Iterator::has_next to determine if additional
								elements exist.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] token_rec_ref Reference to next token.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Interface CICM::ModuleAssnIterator</h3>

<p>Interface CICM::ModuleAssnIterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ModuleAssnIterator : CICM::Iterator {</pre></div>
<p>CICM::ModuleAssnIterator supports retrieving each module
						record from the module association list in the token.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
CICM::ModuleAssnIterator Inheritance</h3>

<p>CICM::ModuleAssnIterator inherits from: CICM::Iterator.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
CICM::ModuleAssnIterator Methods</h3>

<p>Method CICM::ModuleAssnIterator::get_next()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_next(
	out CICM::ModuleRecord module_rec_ref
);</pre></div>
<p>Returns a reference to the next module record from the module
							association list in the token.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Use CICM::Iterator::has_next to determine if additional
								elements exist.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
						  </p>
<blockquote class="text">
<p>[out] module_rec_ref  Reference to next module record.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Users</h3>

<p>These interfaces enable the management of
				users in support of password-based login. See the Managing Module
				Authentication in <a class='info' href='#CICM-LM'>[CICM&#8209;LM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Logical Model           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for additional
				information.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
User Management Identifiers</h3>

<p>Type CICM::UserId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString UserId;</pre></div>
<p>Unique user identifier.
</p>
<p>Type CICM::RoleId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString RoleId;</pre></div>
<p>Unique role identifier.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Interface CICM::UserManager</h3>

<p>Interface CICM::UserManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface UserManager {</pre></div>
<p>CICM::UserManager supports adding a user/password, modifying
						a user's password, and removing users; and associating and
						disassociating users from a role. It is accessed from
						CICM::CryptoModule via the CICM::CryptoModule::user_manager
						attribute. CICM::UserManager constructs the CICM::UserIdIterator
						and CICM::RoleIdIterator interfaces.
</p>
<p>Example (C++):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::UserManager userManager;

// Retrieve reference to the user manager.
userManager = device._get_user_manager();

// Create the user.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = userManager.add(userId, password);

// Associate the user with a pre-defined module role.
CICM::RoleUniqueId roleId = "administrator";
sCode = userManager.associate(userId, roleId);

// Destroy the user.
sCode = userManager.remove(userId);</pre></div>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
CICM::UserManager Attributes</h3>

<p>Attribute CICM::UserManager::user_iterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::UserIdIterator user_iterator;</pre></div>
<p>Returns an iterator to enable an identifier for each user in
							the module user database to be retrieved.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The returned iterator is set to the beginning of the
								iterated sequence.
</p>
</blockquote><p>
						
</p>
<p>Attribute CICM::UserManager::role_iterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::RoleIdIterator role_iterator;</pre></div>
<p>Returns an iterator to enable an identifier for each role
							supported by the module to be retrieved.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The returned iterator is set to the beginning of the iterated
							  sequence.
</p>
</blockquote><p>
						
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
CICM::UserManager Methods</h3>

<p>Method CICM::UserManager::add()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status add(
	in  CICM::UserId user,
	in  CICM::CharString password
);</pre></div>
<p>Add a user to the module user database.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user New user to add.
</p>
<p>[in] password New user's password.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USERNAME_INVALID, S_USER_EXISTS,
								  S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR,
								  S_PASSWORD_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<p>Method CICM::UserManager::modify()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status modify(
	in  CICM::UserId user,
	in  CICM::CharString password
);</pre></div>
<p>Change the password of a user in the module user
							database.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user User to modify.
</p>
<p>[in] password User's new password.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID,
								  S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR,
								  S_PASSWORD_INVALID_LEN
</p>
</blockquote><p>
						
</p>
<p>Method CICM::UserManager::remove()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status remove(
	in  CICM::UserId user
);</pre></div>
<p>Remove a user from the module user database.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user User to remove.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID
</p>
</blockquote><p>
						
</p>
<p>Method CICM::UserManager::associate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status associate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);</pre></div>
<p>Associate a role with the specified user.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user User to associate.
</p>
<p>[in] role Role to associate with the user.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID,
								  S_ROLE_ASSOCIATED, S_ROLE_MAX
</p>
</blockquote><p>
						
</p>
<p>Method CICM::UserManager::disassociate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status disassociate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);</pre></div>
<p>Disassociate a role from the specified user.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user User to disassociate.
</p>
<p>[in] role Role to disassociate from the user.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID,
								  S_ROLE_NOT_ASSOCIATED
</p>
</blockquote><p>
						
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Interface CICM::UserIdIterator</h3>

<p>Interface CICM::UserIdIterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface UserIdIterator : CICM::Iterator {</pre></div>
<p>CICM::UserIdIterator supports retrieving each user configured on a module.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
CICM::UserIdIterator Inheritance</h3>

<p>CICM::UserIdIterator inherits from: CICM::Iterator.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
CICM::UserIdIterator Methods</h3>

<p>Method CICM::UserIdIterator::get_next()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_next(
	out CICM::UserId user_id
);</pre></div>
<p>Returns the next user identifier.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Use CICM::Iterator::has_next to determine if additional
								elements exist.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] user_id Next user identifier.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Interface CICM::RoleIdIterator</h3>

<p>Interface CICM::RoleIdIterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface RoleIdIterator : CICM::Iterator {</pre></div>
<p>CICM::RoleIdIterator supports retrieving each role available on a module.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
CICM::RoleIdIterator Inheritance</h3>

<p>CICM::RoleIdIterator inherits from: CICM::Iterator.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
CICM::RoleIdIterator Methods</h3>

<p>Method CICM::RoleIdIterator::get_next()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_next(
	out CICM::RoleId role_id
);</pre></div>
<p>Returns the next role identifier.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Use CICM::Iterator::has_next to determine if additional
								elements exist.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] role_id Reference to next role identifier.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Login</h3>

<p>These interfaces support a user configured on
				a module to login to a module using a password and, optionally,
				additional authentication data. See the Managing Module
				Authentication in <a class='info' href='#CICM-LM'>[CICM&#8209;LM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM) Logical Model           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a> for additional information.
</p>
<p>Modules that support hardware tokens may use the login manager
				in tandem with the CICM::TokenManager to support multi-factor
				authentication.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Interface CICM::LoginManager</h3>

<p>Interface CICM::LoginManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface LoginManager {</pre></div>
<p>CICM::LoginManager supports user login to a module. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::login_manager attribute. CICM::LoginManager
						constructs the CICM::Login interface. The LoginManager relies upon
						the CICM::UserManager to manage the users that are specified to the
						login methods.
</p>
<p>Example (C++):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LoginManager loginManager;
CICM::Login loginRef;
// Retrieve reference to the login manager.
loginManager = device._get_login_manager();
// Login to the module.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = loginManager.add(userId, password, &amp;loginRef);
// Logout from the module.
sCode = loginRef.logout();</pre></div>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
CICM::LoginManager Methods</h3>

<p>Method CICM::LoginManager::login()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> CICM::Status login(
	in  CICM::UserId user,
	in  CICM::CharString password,
	out CICM::Login login_ref
);</pre></div>
<p>Login to the module with username/password.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user User attempting to login.
</p>
<p>[in] password User's password.
</p>
<p>[out] login_ref Reference to state resulting from successful
									user login enabling the user to later logout.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_AUTHENTICATION_FAILED,
								  S_USER_AUTHENTICATED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::LoginManager::login_auth_data()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status login_auth_data(
	in  CICM::UserId user,
	in  CICM::CharString password,
	in  CICM::Buffer auth_data,
	out CICM::Login login_ref
);</pre></div>
<p>Login to the module with username/password, but provide
							additional (potentially host-stored) authentication data to the
							module for use in the authentication process.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This may be used in cases where the host supports a virtual token.
</p>
<p>The format of the authentication data is not defined by
								CICM. The Implementation Conformance Statement (see Conformance and Extensions
                in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] user User attempting to login.
</p>
<p>[in] password User's password.
</p>
<p>[in] auth_data Additional host-stored authentication data.
</p>
<p>[out] login_ref Reference to state resulting from successful user
									  login enabling the user to later logout.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_DATA_BUFFER,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
								  S_AUTHENTICATION_FAILED, S_USER_AUTHENTICATED
</p>
</blockquote><p>
						
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Interface CICM::Login</h3>

<p>Interface CICM::Login
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Login {</pre></div>
<p>CICM::Login results from a successful user login to a
						module and enables the user to log out from the module.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
CICM::Login Methods</h3>

<p>Method CICM::Login::logout()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status logout();</pre></div>
<p>Logout of the module.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This may be equivalent to disconnecting a hardware access
								token from a module in certain systems.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Software Packages</h3>

<p>These interfaces support software, FPGA
				images, policy databases, configuration parameters, or other types
				of executable or interpretable code to be imported into and removed
				from a module.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Package Management Identifier</h3>

<p>Type CICM::PackageId
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::CharString PackageId;</pre></div>
<p>Unique package identifier.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Interface CICM::PackageManager</h3>

<p>Interface CICM::PackageManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PackageManager {</pre></div>
<p>CICM::PackageManager supports the management of module
						software packages. It is accessed from CICM::CryptoModule via the
						CICM::CryptoModule::package_manager attribute. CICM::PackageManager
						constructs the CICM::PackageImporter, CICM::PackageIterator, and
						CICM::Package interfaces.
</p>
<p>Example (C++):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::PackageManager packageManager;
CICM::PackageImporter packageImporter;
// Retrieve reference to the package manager.
packageManager = device._get_package_manager();

// Initialize the import process.
sCode = packageManager.import_package(
	CICM::Package::C_PACKAGE_FPGA_IMAGE, &amp;packageImporter);

// Assume FPGA image data in [fpgaData].
CICM::Buffer fpgaData;
sCode = packageImporter.import_segment(fpgaData);

// Assume all segments are imported.
// Complete the import process.

CICM::Package fpgaPackage;
sCode = packageImporter.complete(&amp;fpgaPackage);
// If successful, [fpgaPackage] is a reference to the imported package.
// Activate the package.
sCode = fpgaPackage.activate();</pre></div>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
CICM::PackageManager Attributes</h3>

<p>Attribute CICM::PackageManager::package_iterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::PackageIterator package_iterator;</pre></div>
<p>Returns an iterator to enable a reference to each
							package loaded on the module to be retrieved.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The returned iterator is set to the beginning of the iterated
							  sequence.
</p>
</blockquote><p>
						
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
CICM::PackageManager Methods</h3>

<p>Method CICM::PackageManager::import_package()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status import_package(
	in  CICM::Package::PackageType package_type,
	out CICM::PackageImporter importer_ref
);</pre></div>
<p>Initiate the process of importing a package into the module.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The CICM::PackageImporter that results from this call is
								used to import package segments into the module. It is the
								responsibility of the caller to break a package into segments,
								import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package. Note that the key required to decrypt any
								encrypted package segments MUST be referenced within the
								package and MUST be available to the module; the key MAY be
								explicitly specified by using the
								CICM::PackageManager::import_package_with_key version of the
								call.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] package_type Type of the package being imported.
</p>
<p>[out] importer_ref Reference to package importer interface which enables
								  a package to be imported segment by segment.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID,
								  S_PACKAGE_KEY_NOT_AVAILABLE,
								  S_PACKAGE_KEY_NOT_SPECIFIED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::PackageManager::import_package_with_key()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status import_package_with_key(
	in  CICM::Package::PackageType package_type,
	in  CICM::SymKey key_ref,
	out CICM::PackageImporter importer_ref
);</pre></div>
<p>Initiate the process of importing a package into the module,
							specifying a reference to the key that will be used by
							CICM::PackageImporter to decrypt each package segment.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The CICM::PackageImporter that results from this call is
								used to import package segments into the module. It is the
								responsibility of the caller to break a package into segments,
								import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] package_type Type of the package being imported.
</p>
<p>[in] key_ref Reference to key to decrypt package segments.
</p>
<p>[out] importer_ref Reference to package importer interface which enables
								  a package to be imported segment by segment.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID
</p>
</blockquote><p>
						
</p>
<p>Method CICM::PackageManager::get_package_by_id()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_package_by_id(
	in  CICM::PackageId package_id,
	out CICM::Package package_ref
);</pre></div>
<p>Retrieve a reference to a package based upon a unique
							identifier associated with that package.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] package_id Package identifier.
</p>
<p>[out] package_ref Reference to package corresponding to the specified identifier.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<p>Method CICM::PackageManager::reencrypt_software()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status reencrypt_software();</pre></div>
<p>Re-encrypt module software with a key managed by the module.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY
</p>
</blockquote><p>
						
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Interface CICM::PackageImporter</h3>

<p>Interface CICM::PackageImporter
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PackageImporter {</pre></div>
<p>CICM::PackageImporter supports importing software packages,
						segment by segment. CICM::PackageImporter is constructed by the
						CICM::PackageManager::import_package and
						CICM::PackageManager::import_package_with_key methods and cannot
						be instantiated independently. CICM::PackageImporter constructs the
						CICM::Package interface.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3.1"></a><h3>6.3.1.&nbsp;
CICM::PackageImporter Methods</h3>

<p>Method CICM::PackageImporter::import_segment()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status import_segment(
	in  CICM::Buffer package_data
);</pre></div>
<p>Import one segment of a package.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>It is the responsibility of the caller to break a package
								into segments, import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package.
</p>
<p>CICM does not specify the structure of the binary data that
								constitutes the package being imported. The Implementation
								Conformance Statement (see Conformance and Extensions in
                <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a standard format or define a module
								developer-specific format implemented by the module for this
								datatype.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] package_data Contents of the package.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID
</p>
</blockquote><p>
						
</p>
<p>Method CICM::PackageImporter::complete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status complete(
	out CICM::Package package_ref
);</pre></div>
<p>Declare the package import complete and retrieve
							a reference to the resulting package object.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>If this method is called before the package is fully
								loaded, the CICM::S_PACKAGE_INVALID status results.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] package_ref Reference to resulting imported package.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID
</p>
</blockquote><p>
						
</p>
<p>Method CICM::PackageImporter::abort()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status abort();</pre></div>
<p>Abort a package import, resetting this CICM::PackageImporter
							instance, allowing a new package import session to begin.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Segments already imported are discarded.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Interface CICM::Package</h3>

<p>Interface CICM::Package
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface Package {</pre></div>
<p>CICM::Package serves as a reference to a package previously
						loaded into a module, and supports activating, deactivating, and
						deleting the package. CICM::Package is constructed by the
						CICM::PackageManager::get_package_by_id and
						CICM::PackageImporter::complete methods and cannot be instantiated
						independently.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.1"></a><h3>6.4.1.&nbsp;
CICM::Package Types and Constants</h3>

<p>Type CICM::Package::PackageType
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 PackageType;</pre></div>
<p>Supported package types.
</p>
<p>Constant CICM::Package::C_PACKAGE_ALGORITHM
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::Package::PackageType
	C_PACKAGE_ALGORITHM = 0x00006054;</pre></div>
<p>Algorithm package type.
</p>
<p>Constant CICM::Package::C_PACKAGE_CONFIG_PARAMS
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::Package::PackageType
	C_PACKAGE_CONFIG_PARAMS = 0x00006057;</pre></div>
<p>Configuration parameter package type.
</p>
<p>Constant CICM::Package::C_PACKAGE_FPGA_IMAGE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::Package::PackageType
	C_PACKAGE_FPGA_IMAGE = 0x00006058;</pre></div>
<p>FPGA image package type.
</p>
<p>Constant CICM::Package::C_PACKAGE_POLICY_DB
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::Package::PackageType
	C_PACKAGE_POLICY_DB = 0x0000605B;</pre></div>
<p>Policy database package type.
</p>
<p>Constant CICM::Package::C_PACKAGE_SOFTWARE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::Package::PackageType
	C_PACKAGE_SOFTWARE = 0x0000605D;</pre></div>
<p>Software package type.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.2"></a><h3>6.4.2.&nbsp;
CICM::Package Attributes</h3>

<p>Attribute CICM::Package::id
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::PackageId id;</pre></div>
<p>Unique package identifier of this package.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4.3"></a><h3>6.4.3.&nbsp;
CICM::Package Methods</h3>

<p>Method CICM::Package::activate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status activate();</pre></div>
<p>Activate a specific package on the module.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>It may be necessary to reset the module before the
								specified package is activated in place of the currently
								activated package.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVATABLE,
								  S_PACKAGE_ACTIVATED, S_PACKAGE_INVALID
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Package::deactivate()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status deactivate();</pre></div>
<p>Deactivate a specific package on the module.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVE,
								  S_PACKAGE_INVALID
</p>
</blockquote><p>
						
</p>
<p>Method CICM::Package::delete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status delete();</pre></div>
<p>Delete a package from the module.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_ACTIVATED,
								  S_PACKAGE_INVALID
</p>
</blockquote><p>
						
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5"></a><h3>6.5.&nbsp;
Interface CICM::PackageIterator</h3>

<p>Interface CICM::PackageIterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface PackageIterator : CICM::Iterator {</pre></div>
<p>CICM::PackageIterator supports retrieving a reference to each
						software package available on a module. CICM::PackageIterator
						constructs the CICM::Package interface.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.1"></a><h3>6.5.1.&nbsp;
CICM::PackageIterator Inheritance</h3>

<p>CICM::PackageIterator inherits from: CICM::Iterator.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.2"></a><h3>6.5.2.&nbsp;
CICM::PackageIterator Methods</h3>

<p>Method CICM::PackageIterator::get_next()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_next(
	out CICM::Package package_ref
);</pre></div>
<p>Returns a reference to the next software package.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Use CICM::Iterator::has_next to determine if additional
								elements exist.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] package_ref Reference to next software package.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Logs</h3>

<p>These interfaces support the retrieval and removal of log entries.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Interface CICM::LogManager</h3>

<p>Interface CICM::LogManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface LogManager {</pre></div>
<p>CICM::LogManager supports retrieving or destroying an entire
						module log, or retrieving or deleting individual log entries. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::log_manager attribute. CICM::LogManager
						constructs the CICM::LogEntryIterator interface.
</p>
<p>Example (C++):
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LogManager logManager;

// Retrieve reference to the log manager.
logManager = device._get_log_manager();

// Retrieve reference to a log entry iterator.
CICM::LogEntryIterator iter;
iter = logManager._get_log_entry_iterator();
CICM::Iterator::Status status;
CICM::LogEntry entry;

// Confirm that there are log entries.
sCode = iter.hasNext(&amp;status);

// Iterate over the log entries.
while( CICM::Iterator::C_ITERATOR_HAS_NEXT == status ) {
        sCode = iter.get_next(&amp;entry);
		// Perform an operation on [entry].
        sCode = iter.hasNext(&amp;status);
}
// Delete all of the log entries.
sCode = logManager.destroy();</pre></div>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.1"></a><h3>7.1.1.&nbsp;
CICM::LogManager Attributes</h3>

<p>Attribute CICM::LogManager::log_entry_iterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::LogEntryIterator log_entry_iterator;</pre></div>
<p>Returns an iterator to enable a reference to each module
							CICM::LogEntry to be retrieved.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The returned iterator is set to the beginning of the iterated
							  sequence.
</p>
</blockquote><p>
						
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2"></a><h3>7.1.2.&nbsp;
CICM::LogManager Methods</h3>

<p>Method CICM::LogManager::retrieve()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre> CICM::Status retrieve(
	out CICM::Buffer log_ref
);</pre></div>
<p>Retrieve a reference to the entire module log.
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] log_ref Reference to entire module log.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<p>Method CICM::LogManager::destroy()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status destroy();</pre></div>
<p>Destroy all entries in the module log.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Interface CICM::LogEntry</h3>

<p>Interface CICM::LogEntry
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface LogEntry {</pre></div>
<p>CICM::LogEntry serves as a reference to an individual log
						entry in the module log, and supports retrieving information about
						an individual log entry and deleting an individual log entry.
</p>
<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.1"></a><h3>7.2.1.&nbsp;
CICM::LogEntry Attributes</h3>

<p>Attribute CICM::LogEntry::user_id
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::UserId user_id;</pre></div>
<p>User initiating the module action resulting in this log entry.
</p>
<p>Attribute CICM::LogEntry::role_id
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::RoleId role_id;</pre></div>
<p>Role under which the module action resulting in this log
							entry was initiated.
</p>
<p>Attribute CICM::LogEntry::message
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::CharString message;</pre></div>
<p>Log message associated with this log entry.
</p>
<p>Attribute CICM::LogEntry::date_time
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>readonly attribute CICM::CharString date_time;</pre></div>
<p>Date/time of creation of this log entry.
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2.2"></a><h3>7.2.2.&nbsp;
CICM::LogEntry Methods</h3>

<p>Method CICM::LogEntry::delete()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status delete();</pre></div>
<p>Remove the current entry from the module log.
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_LOG_ENTRY_INVALID
</p>
</blockquote><p>
						
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Interface CICM::LogEntryIterator</h3>

<p>Interface CICM::LogEntryIterator
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface LogEntryIterator : CICM::Iterator {</pre></div>
<p>CICM::LogEntryIterator supports retrieving a reference to
						each log entry in the module log. CICM::LogEntryIterator constructs
						the CICM::LogEntry interface.
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.1"></a><h3>7.3.1.&nbsp;
CICM::LogEntryIterator Inheritance</h3>

<p>CICM::LogEntryIterator inherits from: CICM::Iterator.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3.2"></a><h3>7.3.2.&nbsp;
CICM::LogEntryIterator Methods</h3>

<p>Method CICM::LogEntryIterator::get_next()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status get_next(
	out CICM::LogEntry log_entry_ref
);</pre></div>
<p>Returns a reference to the next log entry.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>Use CICM::Iterator::has_next to determine if additional elements exist.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[out] log_entry_ref Reference to next log entry.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Tests</h3>

<p>These interfaces support the initiation of module internal tests by client programs.
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Interface CICM::TestManager</h3>

<p>Interface CICM::TestManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface TestManager {</pre></div>
<p>CICM::TestManager supports initiating client program-invoked
						module built-in tests. It is accessed from CICM::CryptoModule via
						the CICM::CryptoModule::test_manager attribute.
</p>
<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.1"></a><h3>8.1.1.&nbsp;
CICM::TestManager Types and Constants</h3>

<p>Type CICM::TestManager::Status
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 Status;</pre></div>
<p>Test state at completion.
</p>
<p>Constant CICM::TestManager::C_TEST_SUCCESS
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::TestManager::Status
	C_TEST_SUCCESS = 0x00006062;</pre></div>
<p>The test completed successfully.
</p>
<p>Constant CICM::TestManager::C_TEST_FAILURE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::TestManager::Status
	C_TEST_FAILURE = 0x00006064;</pre></div>
<p>The test failed.
</p>
<a name="anchor63"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.2"></a><h3>8.1.2.&nbsp;
CICM::TestManager Methods</h3>

<p>Method CICM::TestManager::run_test()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status run_test(
	in  CICM::Buffer test_parameters,
	out CICM::TestManager::Status status
);</pre></div>
<p>Run module built-in tests specifying module-specific test parameters.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This method can only initiate tests that a client program
								can explicitly request (e.g., this method does not apply to a
								series of tests automatically initiated during a module's
								start-up sequence). Running built-in tests on some modules may
								result in an alarm if an error is encountered during the test
								run.
</p>
<p>The format of the test parameters value is not defined by
								CICM. The Implementation Conformance Statement (see Conformance and Extensions
                in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] test_parameters Module-specific test parameters.
</p>
<p>[out] status Status of test at completion.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE,
								  S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::TestManager::run_test_get_results for the version of
								this method that returns test results.
</p>
</blockquote><p>
						
</p>
<p>Method CICM::TestManager::run_test_get_results()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status run_test_get_results(
	in  CICM::Buffer test_parameters,
	out CICM::Buffer test_results
);</pre></div>
<p>Run module built-in tests specifying module-specific test
							parameters and receiving module-specific results or data for later
							evaluation from the test run.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>This method can only initiate tests that a client program
								can explicitly request (e.g., this method does not apply to a
								series of tests automatically initiated during a module's
								start-up sequence). Running built-in tests on some modules may
								result in an alarm if an error is encountered during the test
								run.
</p>
<p>The formats of the test parameters and test results values
								are not defined by CICM. The Implementation Conformance
								Statement (see Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST
								reference a standard format or define a module
								developer-specific format implemented by the module for these
								datatypes.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] test_parameters Module-specific test parameters.
</p>
<p>[out] test_results Results of the test.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE,
								  S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT
</p>
</blockquote><p>
						
</p>
<p>See also:
							</p>
<blockquote class="text">
<p>CICM::TestManager::run_test for the version of this Method
								that returns a simple test status value.
</p>
</blockquote><p>
						
</p>
<a name="anchor64"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Module Events</h3>

<p>In certain cases it may be necessary for a
				module to asynchronously notify a client program of an event.
				Client programs can register to receive module notifications using
				CICM::ModuleEventManager. This manager enables a client program to
				register a listener (callback) method designed to handle a specific
				condition. The event method prototype provided by the client
				program is defined in CICM::ModuleEventListener.
				CICM::ModuleEventListener also defines the conditions that may
				result in a notification, including: hardware requires attention,
				alarm, key expired, and health test failure.
</p>
<p>In certain cases, a single event on a module may result in the
				generation of multiple notification messages. For example,
				CICM::ModuleEventListener::C_MODULE_ALARM may be followed by a
				CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC.
</p>
<a name="anchor65"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Interface CICM::ModuleEventManager</h3>

<p>Interface CICM::ModuleEventManager
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ModuleEventManager {</pre></div>
<p>CICM::ModuleEventManager supports registering and
						unregistering user-defined module event listeners
						(CICM::ModuleEventListener) for specific module events. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::event_manager attribute.
</p>
<a name="anchor66"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1.1"></a><h3>9.1.1.&nbsp;
CICM::ModuleEventManager Methods</h3>

<p>Method CICM::ModuleEventManager::register()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status register(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::ModuleEventListener listener
);</pre></div>
<p>Registers the listener for a specific module event.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The provided listener applies only to the client program
								from which the registration is initiated.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] event Event for which this listener is being registered.
</p>
<p>[in] listener Listener that will receive a notification about the
									  specified event.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_REGISTERED,
								  S_EVENT_NOT_SUPPORTED
</p>
</blockquote><p>
						
</p>
<p>Method CICM::ModuleEventManager::unregister()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>CICM::Status unregister(
	in  CICM::ModuleEventListener::ModuleEvent event
);</pre></div>
<p>Unregisters the listener associated with the specified event.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>The listener associated with the specified event is only
								unregistered from the client program from which this method is
								called.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] event Event that will no longer have a listener associated with it.
</p>
</blockquote><p>
						
</p>
<p>Returns:
							</p>
<blockquote class="text">
<p>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_NOT_REGISTERED
</p>
</blockquote><p>
						
</p>
<a name="anchor67"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Interface CICM::ModuleEventListener</h3>

<p>Interface CICM::ModuleEventListener
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>interface ModuleEventListener {</pre></div>
<p>CICM::ModuleEventListener is unlike other CICM interfaces in
						that the interface is implemented by the developer of the client
						program to service a specific module event and is then registered
						via the CICM::ModuleEventManager.
</p>
<a name="anchor68"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.1"></a><h3>9.2.1.&nbsp;
CICM::ModuleEventListener Types and Constants</h3>

<p>Type CICM::ModuleEventListener::ModuleEvent
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>typedef CICM::UInt32 ModuleEvent;</pre></div>
<p>Events for which a ModuleEventListener can be notified.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_INSERTED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;</pre></div>
<p>Access token has been inserted.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_REMOVED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;</pre></div>
<p>Access token has been removed.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_ALARM
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ALARM = 0x00002004;</pre></div>
<p>Module has entered an alarm state.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_FAILURE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_FAILURE = 0x00002007;</pre></div>
<p>Non-critical module failure detected.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_INSUFFICIENT_ENTROPY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;</pre></div>
<p>Insufficient entropy available to a cryptographic operation
								that requires it.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_HARD
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_HARD =	0x0000200B;</pre></div>
<p>Specific key has expired; the module can optionally include
							  identifying information about the specific key that expired in
							  the event_data buffer that is provided with the event
							  itself.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_SOFT
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;</pre></div>
<p>Specific key is within some system-defined delta of hard
							  expiration; the module can optionally include identifying
							  information about the specific key that is about to expire in the
							  event_data buffer that is provided with the event itself.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_COMPLETE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;</pre></div>
<p>Key fill is complete.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_CONNECTED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_CONNECTED = 0x00002010;</pre></div>
<p>Key fill device has been connected.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_INITIATED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_INITIATED = 0x00002013;</pre></div>
<p>Key fill has been initiated.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_MEMORY
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_MEMORY = 0x00002015;</pre></div>
<p>Out of internal key memory condition.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;</pre></div>
<p>Key protocol message is available; see the Key Protocol
								Management documentation for additional information.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_LOG_FULL
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_FULL = 0x00002019;</pre></div>
<p>Module log is full.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_LOG_NEAR_FULL
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_NEAR_FULL = 0x0000201A;</pre></div>
<p>Module log is nearly full.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_LOGIN_FAILURE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOGIN_FAILURE = 0x0000201C;</pre></div>
<p>Attempted login failed.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;</pre></div>
<p>Module is not able to process traffic.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_ENTER
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
C_MODULE_POWER_MGMT_ENTER = 0x00002020;</pre></div>
<p>Module has entered power management state.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_EXIT
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_MGMT_EXIT = 0x00002023;</pre></div>
<p>Module has exited power management state.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF = 0x00002025;</pre></div>
<p>Change in module power state to OFF detected.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF_FAILURE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF_FAILURE = 0x00002026;</pre></div>
<p>Disorderly change in module power state to OFF detected.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_POWER_ON
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_ON = 0x00002029;</pre></div>
<p>Change in module power state to ON detected.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_READY_FOR_TRAFFIC
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;</pre></div>
<p>Module is ready to process traffic.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_REKEY_REQUEST
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_REKEY_REQUEST = 0x0000202C;</pre></div>
<p>Rekey of a specific key is required; the module can
							  optionally include identifying information about the specific key
							  to be rekeyed in the event_data buffer that is provided with the
							  event itself.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_TEST_FAILURE
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_TEST_FAILURE = 0x0000202F;</pre></div>
<p>Module internal test has failed; the module can optionally
							  include identifying information about the specific test that
							  failed in the event_data buffer that is provided with the event
							  itself.
</p>
<p>Constant CICM::ModuleEventListener::C_MODULE_ZEROIZED
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ZEROIZED = 0x00002031;</pre></div>
<p>Module has been zeroized.
</p>
<a name="anchor69"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2.2"></a><h3>9.2.2.&nbsp;
CICM::ModuleEventListener Methods</h3>

<p>Method CICM::ModuleEventListener::event_occurred()
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>void event_occurred(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::Buffer event_data
);</pre></div>
<p>Method implemented by client program that is called by the
								host runtime system to notify that a specific module event has
								occurred.
</p>
<p>Remarks:
							</p>
<blockquote class="text">
<p>An opaque data field with additional information about the
								event in a module-specific format MAY optionally be provided
								with the event itself. This field MAY be of length zero.
</p>
<p>The format of the event data value is not defined in this
								specification. The Implementation Conformance Statement (see
								Conformance and Extensions in <a class='info' href='#CICM'>[CICM]<span> (</span><span class='info'>Lanz, D. and L. Novikov, &ldquo;Common Interface to Cryptographic Modules (CICM)           [RFC Editor: Please update the RFC reference and date prior to publication.],&rdquo; January&nbsp;2011.</span><span>)</span></a>) MUST reference a
								standard format or define a module-specific format for this
								datatype.
</p>
</blockquote><p>
						
</p>
<p>Note:
							</p>
<blockquote class="text">
<p>Because this method is called by the runtime system and not
                    a client program, it does not return a status value.
</p>
</blockquote><p>
						
</p>
<p>Parameters:
							</p>
<blockquote class="text">
<p>[in] event Event that occurred.
</p>
<p>[in] event_data Opaque data associated with the event (e.g., specific
									  test that failed, key that will expire).
</p>
</blockquote><p>
						
</p>
<a name="anchor70"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
IANA Considerations</h3>

<p>[RFC Editor: Please remove this section prior to publication.]
</p>
<p>This document has no IANA actions.
</p>
<a name="anchor71"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Security Considerations</h3>

<a name="anchor72"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
Unauthorized Usage</h3>

<p>A cryptographic module is typically a controlled resource which requires
          appropriate authorization to use. Specific implementations may use a combination
          of hardware access tokens, usernames and passwords, access control lists,
          or other means.
</p>
<p>CICM defines the TokenManager, UserManager, and LoginManager interfaces
          to facilitate with the management of authorized users and to provide authentication
          capabilities.
</p>
<a name="anchor73"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
Inappropriate Usage</h3>

<p>Although CICM does not define audit logs as a separate concept,
          the LogManager interface can conceivably provide enough information
          to act as a means for tracking inappropriate usage which is especially
          important for the operations that manage the module itself:
          managing users, updating the module software, and running the built-in
          tests. Additionally, manipulation of the module logs may undermine
          the value of the auditing countermeasure.
</p>
<a name="anchor74"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
Denial of Service</h3>

<p>As suggested by <a class='info' href='#RFC3552'>[RFC3552]<span> (</span><span class='info'>Rescorla, E. and B. Korver, &ldquo;Guidelines for Writing RFC Text on Security Considerations,&rdquo; July&nbsp;2003.</span><span>)</span></a>, implementers are advised to
          include mechanisms that mitigate against denial of service attacks.
          This is primarily an issue for modules that authenticate using a
          user name and password, although this may also be an issue for hardware
          access tokens.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CICM">[CICM]</a></td>
<td class="author-text">Lanz, D. and L. Novikov, &ldquo;<a href="http://tools.ietf.org/id/draft-lanz-cicm-02.txt">Common Interface to Cryptographic Modules (CICM)
          [RFC Editor: Please update the RFC reference and date prior to publication.]</a>,&rdquo; January&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="CICM-KM">[CICM-KM]</a></td>
<td class="author-text">Lanz, D. and L. Novikov, &ldquo;<a href="http://tools.ietf.org/id/draft-lanz-cicm-km-00.txt">Common Interface to Cryptographic Modules (CICM) Key Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</a>,&rdquo; January&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="IDL">[IDL]</a></td>
<td class="author-text">International Standards Organization, &ldquo;Information technology — Open Distributed Processing — Interface Definition Language,&rdquo; ISO/IEC&nbsp;14750:1999(E), March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CICM-LM">[CICM-LM]</a></td>
<td class="author-text">Lanz, D. and L. Novikov, &ldquo;<a href="http://tools.ietf.org/id/draft-lanz-cicm-model-00.txt">Common Interface to Cryptographic Modules (CICM) Logical Model
          [RFC Editor: Please update the RFC reference and date prior to publication.]</a>,&rdquo; January&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="CORBA">[CORBA]</a></td>
<td class="author-text">Object Management Group, &ldquo;Common Object Request Broker Architecture (CORBA) Specification, Version 3.1,&rdquo; January&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3552">[RFC3552]</a></td>
<td class="author-text">Rescorla, E. and B. Korver, &ldquo;<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>,&rdquo; BCP&nbsp;72, RFC&nbsp;3552, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3552.txt">TXT</a>).</td></tr>
</table>

<a name="idl-code"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
IDL Definitions</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>module CICM {
  typedef CICM::CharString TokenRecord;
  typedef CICM::CharString ModuleRecord;

  interface TokenAssnIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::TokenRecord token_rec_ref );
  };

  interface ModuleAssnIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::ModuleRecord module_rec_ref );
  };

  interface TokenManager {
    readonly attribute CICM::ModuleAssnIterator
      module_association_iterator;

    readonly attribute CICM::TokenAssnIterator
      token_association_iterator;

    CICM::Status associate(
      out CICM::ModuleRecord module_rec,
      out CICM::TokenRecord token_rec );

    CICM::Status disassociate();

    CICM::Status disassociate_missing_module(
      in  CICM::ModuleRecord module_rec );

    CICM::Status disassociate_missing_token(
      in  CICM::TokenRecord token_rec );
  };

  typedef CICM::CharString UserId;
  typedef CICM::CharString RoleId;

  interface UserIdIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::UserId user_id );
  };

  interface RoleIdIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::RoleId role_id );
  };

  interface UserManager {
    readonly attribute CICM::UserIdIterator user_iterator;
    readonly attribute CICM::RoleIdIterator role_iterator;

    CICM::Status add(
      in  CICM::UserId user,
      in  CICM::CharString password );

    CICM::Status modify(
      in  CICM::UserId user,
      in  CICM::CharString password );

    CICM::Status remove(
      in  CICM::UserId user );

    CICM::Status associate(
      in  CICM::UserId user,
      in  CICM::RoleId role );

    CICM::Status disassociate(
      in  CICM::UserId user,
      in  CICM::RoleId role );
  };

  interface Login {
    CICM::Status logout();
  };

  interface LoginManager {
     CICM::Status login(
      in  CICM::UserId user,
      in  CICM::CharString password,
      out CICM::Login login_ref );

    CICM::Status login_auth_data(
      in  CICM::UserId user,
      in  CICM::CharString password,
      in  CICM::Buffer auth_data,
      out CICM::Login login_ref );
  };

  typedef CICM::CharString PackageId;

  interface Package {
    typedef CICM::UInt32 PackageType;
    const CICM::Package::PackageType
      C_PACKAGE_ALGORITHM = 0x00006054;

    const CICM::Package::PackageType
      C_PACKAGE_CONFIG_PARAMS = 0x00006057;

    const CICM::Package::PackageType
      C_PACKAGE_FPGA_IMAGE = 0x00006058;

    const CICM::Package::PackageType
      C_PACKAGE_POLICY_DB = 0x0000605B;

    const CICM::Package::PackageType
      C_PACKAGE_SOFTWARE = 0x0000605D;

    readonly attribute CICM::PackageId id;

    CICM::Status activate();
    CICM::Status deactivate();
    CICM::Status delete();
  };

  interface PackageIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::Package package_ref );
  };

  interface PackageImporter {
    CICM::Status import_segment(
      in  CICM::Buffer package_data );

    CICM::Status complete(
      out CICM::Package package_ref );

    CICM::Status abort();
  };

  interface PackageManager {
    readonly attribute CICM::PackageIterator package_iterator;

    CICM::Status import_package(
      in  CICM::Package::PackageType package_type,
      out CICM::PackageImporter importer_ref );

    CICM::Status import_package_with_key(
      in  CICM::Package::PackageType package_type,
      in  CICM::SymKey key_ref,
      out CICM::PackageImporter importer_ref );

    CICM::Status get_package_by_id(
      in  CICM::PackageId package_id,
      out CICM::Package package_ref );

    CICM::Status reencrypt_software();
  };

  interface LogEntry {
    readonly attribute CICM::UserId user_id;
    readonly attribute CICM::RoleId role_id;
    readonly attribute CICM::CharString message;
    readonly attribute CICM::CharString date_time;

    CICM::Status delete();
  };

  interface LogEntryIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::LogEntry log_entry_ref );
  };

  interface LogManager {
    readonly attribute CICM::LogEntryIterator log_entry_iterator;

    CICM::Status retrieve(
      out CICM::Buffer log_ref );

    CICM::Status destroy();
  };

  interface TestManager {
    typedef CICM::UInt32 Status;
    const CICM::TestManager::Status C_TEST_SUCCESS = 0x00006062;
    const CICM::TestManager::Status C_TEST_FAILURE = 0x00006064;

    CICM::Status run_test(
      in  CICM::Buffer test_parameters,
      out CICM::TestManager::Status status );

    CICM::Status run_test_get_results(
      in  CICM::Buffer test_parameters,
      out CICM::Buffer test_results );
  };

  interface ModuleEventListener {
    typedef CICM::UInt32 ModuleEvent;
    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ALARM = 0x00002004;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_FAILURE = 0x00002007;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_EXPIRED_HARD = 0x0000200B;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_CONNECTED = 0x00002010;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_FILL_INITIATED = 0x00002013;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_MEMORY = 0x00002015;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOG_FULL = 0x00002019;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOG_NEAR_FULL = 0x0000201A;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_LOGIN_FAILURE = 0x0000201C;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_MGMT_ENTER = 0x00002020;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_MGMT_EXIT = 0x00002023;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_OFF = 0x00002025;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_OFF_FAILURE = 0x00002026;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_POWER_ON = 0x00002029;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_REKEY_REQUEST = 0x0000202C;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_TEST_FAILURE = 0x0000202F;

    const CICM::ModuleEventListener::ModuleEvent
      C_MODULE_ZEROIZED = 0x00002031;

    void event_occurred(
      in  CICM::ModuleEventListener::ModuleEvent event,
      in  CICM::Buffer event_data );
  };

  interface ModuleEventManager {
    CICM::Status register(
      in  CICM::ModuleEventListener::ModuleEvent event,
      in  CICM::ModuleEventListener listener );

    CICM::Status unregister(
      in  CICM::ModuleEventListener::ModuleEvent event );
  };
};</pre></div>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Daniel J. Lanz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Lev Novikov</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The MITRE Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></td></tr>
</table>
</body></html>
