<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Common Interface to Cryptographic Modules (CICM) Key Management </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Definition Language">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Conformance and Extension Language">
<link href="#rfc.section.2" rel="Chapter" title="2 CICM Dependencies">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Namespaces">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Types">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Interfaces">
<link href="#rfc.section.3" rel="Chapter" title="3 General Key Concepts">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Creating and Establishing Keys">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Exporting Keys">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Destroying Keys">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Locating Keys">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Protecting Keys">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Identifiers">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Interface CICM::Key">
<link href="#rfc.section.3.7.1" rel="Chapter" title="3.7.1 CICM::Key Types and Constants">
<link href="#rfc.section.3.7.2" rel="Chapter" title="3.7.2 CICM::Key Attributes">
<link href="#rfc.section.3.7.3" rel="Chapter" title="3.7.3 CICM::Key Methods">
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Interface CICM::KeyDatabase">
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 CICM::KeyDatabase Methods">
<link href="#rfc.section.4" rel="Chapter" title="4 Asymmetric Keys">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Interface CICM::AsymKeyManager">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 CICM::AsymKeyManager Attributes">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 CICM::AsymKeyManager Methods">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Interface CICM::AsymKey">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 CICM::AsymKey Inheritance">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 CICM::AsymKey Types and Constants">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 CICM::AsymKey Methods">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Interface CICM::AsymKeyIterator">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 CICM::AsymKeyIterator Inheritance">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 CICM::AsymKeyIterator Methods">
<link href="#rfc.section.5" rel="Chapter" title="5 Symmetric Keys">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Interface CICM::SymKeyManager">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 CICM::SymKeyManager Attributes">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 CICM::SymKeyManager Methods">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Interface CICM::SymKey">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 CICM::SymKey Inheritance">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 CICM::SymKey Types and Constants">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 CICM::SymKey Attributes">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 CICM::SymKey Methods">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Interface CICM::SymKeyIterator">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 CICM::SymKeyIterator Inheritance">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 CICM::SymKeyIterator Methods">
<link href="#rfc.section.6" rel="Chapter" title="6 Key Protocol">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Participants in the Interaction">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Return Status, Condition, and Session Status">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Generic Scenario">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Key Agreement Example Using Diffie-Hellman Protocol">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Protocol Support Examples">
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Interface CICM::KeyProtocolSender">
<link href="#rfc.section.6.6.1" rel="Chapter" title="6.6.1 CICM::KeyProtocolSender Inheritance">
<link href="#rfc.section.6.6.2" rel="Chapter" title="6.6.2 CICM::KeyProtocolSender Types and Constants">
<link href="#rfc.section.6.6.3" rel="Chapter" title="6.6.3 CICM::KeyProtocolSender Methods">
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Interface CICM::KeyProtocolReceiver">
<link href="#rfc.section.6.7.1" rel="Chapter" title="6.7.1 CICM::KeyProtocolReceiver Types and Constants">
<link href="#rfc.section.6.7.2" rel="Chapter" title="6.7.2 CICM::KeyProtocolReceiver Methods">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Authorization">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Authentication">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Entity Authentication">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Confidentiality">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Data Integrity">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 Inappropriate Usage">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A IDL Definitions">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="[RFC Editor: Please update the RFC references prior to publication.]" />
  <meta name="description" content="[RFC Editor: Please update the RFC references prior to publication.]" />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">D. Lanz</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">L. Novikov</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">MITRE</td>
</tr>
<tr>
<td class="left">Expires: January 26, 2012</td>
<td class="right">July 25, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Common Interface to Cryptographic Modules (CICM) Key Management <br />
  <span class="filename">draft-lanz-cicm-km-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>[RFC Editor: Please update the RFC references prior to publication.]</p>
<p>This memo defines a programming interface for the management of cryptographic keys as outlined in draft-lanz-cicm-model-00 and required by draf-lanz-cicm-02 including managing a key database as well as individual symmetric and asymmetric keys.</p>
<p>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 26, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Definition Language</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Conformance and Extension Language</a>
</li>
<li>2.   <a href="#rfc.section.2">CICM Dependencies</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Namespaces</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Types</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Interfaces</a>
</li>
<li>3.   <a href="#rfc.section.3">General Key Concepts</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Creating and Establishing Keys</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Exporting Keys</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Destroying Keys</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Locating Keys</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Protecting Keys</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Identifiers</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">Interface CICM::Key</a>
</li>
<li>3.7.1.   <a href="#rfc.section.3.7.1">CICM::Key Types and Constants</a>
</li>
<li>3.7.2.   <a href="#rfc.section.3.7.2">CICM::Key Attributes</a>
</li>
<li>3.7.3.   <a href="#rfc.section.3.7.3">CICM::Key Methods</a>
</li>
<li>3.8.   <a href="#rfc.section.3.8">Interface CICM::KeyDatabase</a>
</li>
<li>3.8.1.   <a href="#rfc.section.3.8.1">CICM::KeyDatabase Methods</a>
</li>
<li>4.   <a href="#rfc.section.4">Asymmetric Keys</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Interface CICM::AsymKeyManager</a>
</li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">CICM::AsymKeyManager Attributes</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">CICM::AsymKeyManager Methods</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Interface CICM::AsymKey</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">CICM::AsymKey Inheritance</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">CICM::AsymKey Types and Constants</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">CICM::AsymKey Methods</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Interface CICM::AsymKeyIterator</a>
</li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">CICM::AsymKeyIterator Inheritance</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">CICM::AsymKeyIterator Methods</a>
</li>
<li>5.   <a href="#rfc.section.5">Symmetric Keys</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Interface CICM::SymKeyManager</a>
</li>
<li>5.1.1.   <a href="#rfc.section.5.1.1">CICM::SymKeyManager Attributes</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">CICM::SymKeyManager Methods</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Interface CICM::SymKey</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">CICM::SymKey Inheritance</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">CICM::SymKey Types and Constants</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">CICM::SymKey Attributes</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">CICM::SymKey Methods</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Interface CICM::SymKeyIterator</a>
</li>
<li>5.3.1.   <a href="#rfc.section.5.3.1">CICM::SymKeyIterator Inheritance</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">CICM::SymKeyIterator Methods</a>
</li>
<li>6.   <a href="#rfc.section.6">Key Protocol</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Participants in the Interaction</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Return Status, Condition, and Session Status</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Generic Scenario</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Key Agreement Example Using Diffie-Hellman Protocol</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Protocol Support Examples</a>
</li>
<li>6.6.   <a href="#rfc.section.6.6">Interface CICM::KeyProtocolSender</a>
</li>
<li>6.6.1.   <a href="#rfc.section.6.6.1">CICM::KeyProtocolSender Inheritance</a>
</li>
<li>6.6.2.   <a href="#rfc.section.6.6.2">CICM::KeyProtocolSender Types and Constants</a>
</li>
<li>6.6.3.   <a href="#rfc.section.6.6.3">CICM::KeyProtocolSender Methods</a>
</li>
<li>6.7.   <a href="#rfc.section.6.7">Interface CICM::KeyProtocolReceiver</a>
</li>
<li>6.7.1.   <a href="#rfc.section.6.7.1">CICM::KeyProtocolReceiver Types and Constants</a>
</li>
<li>6.7.2.   <a href="#rfc.section.6.7.2">CICM::KeyProtocolReceiver Methods</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Authorization</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Authentication</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Entity Authentication</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">Confidentiality</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">Data Integrity</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">Inappropriate Usage</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">IDL Definitions</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document defines the key management functions for the Common Interface to Cryptographic Modules (CICM) as defined in <a href="#CICM">[CICM]</a>. The underlying logical model and terminology is defined in <a href="#CICM-LM">[CICM-LM]</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Definition Language</h1>
<p id="rfc.section.1.2.p.1">This document uses the Interface Definition Language (IDL) <a href="#IDL">[IDL]</a> to specify language-neutral interfaces and is not intended to prescribe or preclude a particular communications protocol such as General Inter-ORB Protocol (GIOP) <a href="#CORBA">[CORBA]</a> between programs in different address spaces or on different devices. In other words, any specific protocol is strictly OPTIONAL. See Definition Language in <a href="#CICM">[CICM]</a> for more information.  </p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Conformance and Extension Language</h1>
<p id="rfc.section.1.3.p.1">This document contains definitions for several opaque data parameters whose format is not defined by CICM. Instead, implementers are required to create an Implementation Conformance Statement which MUST reference a standard format or define a module developer-specific format implemented by the module for these datatypes. See Conformance and Extensions in <a href="#CICM">[CICM]</a> for more details.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> CICM Dependencies</h1>
<p id="rfc.section.2.p.1">This document depends on type definitions and interfaces that are defined in other CICM documents.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Namespaces</h1>
<p id="rfc.section.2.1.p.1">The CICM namespace is defined in <a href="#CICM">[CICM]</a>.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Types</h1>
<p id="rfc.section.2.2.p.1">The following type definitions are defined in <a href="#CICM">[CICM]</a>: </p>

<ul class="empty">
<li>CICM::UInt32</li>
<li>CICM::CharString</li>
<li>CICM::Buffer</li>
<li>CICM::Status (including all return values)</li>
<li>CICM::LocalPort</li>
<li>CICM::Classification</li>
</ul>

<p> </p>
<p id="rfc.section.2.2.p.2">The type definitions for the following identifiers are defined in <a href="#CICM-CM">[CICM-CM]</a>: </p>

<ul class="empty">
<li>CICM::SymEncrAlgorithmId</li>
<li>CICM::SymEncrAlgorithmId</li>
<li>CICM::HashAlgorithmId</li>
<li>CICM::KeyWrapAlgorithmId</li>
<li>CICM::ProtocolId</li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Interfaces</h1>
<p id="rfc.section.2.3.p.1">The interface CICM::Iterator is defined in <a href="#CICM">[CICM]</a>; CICM::Negotiator is defined in <a href="#CICM-CM">[CICM-CM]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> General Key Concepts</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Creating and Establishing Keys</h1>
<p id="rfc.section.3.1.p.1">This specification provides facilities to convey key material into a cryptographic module via one of several methods, including importing key into the module through the API or a key fill interface, or generating or deriving key on the module.</p>
<p id="rfc.section.3.1.p.2">Key material may also be created through the use of a key establishment protocol between the module and a key infrastructure component or another module. Such a protocol is initiated between two or more parties to establish a secret key over a communications channel. The specification supports conveying generic protocol messages to and from a cryptographic module to effect the establishment of this secret key. See the CICM::KeyProtocolSender and CICM::KeyProtocolReceiver interfaces for additional information.</p>
<p id="rfc.section.3.1.p.3">Key metadata may be retrieved and set for individual keys.  Metadata elements include the key identifier, alias, and classification. Keys imported via a fill device that are untagged may require certain metadata to be applied after the conclusion of the load, for example.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Exporting Keys</h1>
<p id="rfc.section.3.2.p.1">Key material may also be exported out of a cryptographic module through the use of the key export functionality to enable transfer to another entity or for storage within the host system.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Destroying Keys</h1>
<p id="rfc.section.3.3.p.1">This specification provides the ability to permanently and irretrievably destroy key material. These capabilities apply to keys managed by the module, whether stored internal to the module or stored externally.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Locating Keys</h1>
<p id="rfc.section.3.4.p.1">A key is typically designated by a global identifier defined by the external key management system from which the key originated. Alternatively, a key may be designated by a numeric value representing the physical storage location of the key within the module. Key location methods enable a key object representing the key specified by a supplied identifier to be retrieved by the caller.</p>
<p id="rfc.section.3.4.p.2">Note that the format of the key identifier is not defined by CICM. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> Protecting Keys</h1>
<p id="rfc.section.3.5.p.1">These methods enable the encryption and decryption of key material to support transferring keys between modules or other entities (including storage of key material external to the module).</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> Identifiers</h1>
<div id="#rfc.figure.1"></div>
<p>Type CICM::KeyId</p>
<pre>typedef CICM::CharString KeyId;</pre>
<p>Unique key identifier.</p>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> Interface CICM::Key</h1>
<div id="#rfc.figure.2"></div>
<p>Interface CICM::Key</p>
<pre>interface Key {</pre>
<p>Interface from which symmetric and asymmetric key interfaces inherit.</p>
<h1 id="rfc.section.3.7.1">
<a href="#rfc.section.3.7.1">3.7.1.</a> CICM::Key Types and Constants</h1>
<div id="#rfc.figure.3"></div>
<p>Type CICM::Key::State</p>
<pre>typedef CICM::UInt32 State;</pre>
<p>Indicates whether or not the key is valid.</p>
<div id="#rfc.figure.4"></div>
<p>Constant CICM::Key::C_KEY_INVALID</p>
<pre>const CICM::Key::State
	C_KEY_INVALID = 0x00006010;</pre>
<p>Key is invalid.</p>
<div id="#rfc.figure.5"></div>
<p>Constant CICM::Key::C_KEY_VALID_WRAPPED</p>
<pre>const CICM::Key::State
	C_KEY_VALID_WRAPPED = 0x00006013;</pre>
<p>Key is valid and in wrapped form.</p>
<div id="#rfc.figure.6"></div>
<p>Constant CICM::Key::C_KEY_VALID_UNWRAPPED</p>
<pre>const CICM::Key::State
	C_KEY_VALID_UNWRAPPED = 0x00006015;</pre>
<p>Key is valid and in unwrapped form.</p>
<div id="#rfc.figure.7"></div>
<p>Type CICM::Key::UsageStatus</p>
<pre>typedef CICM::UInt32 UsageStatus;</pre>
<p>Indicates whether a key usage is allowed or forbidden.</p>
<div id="#rfc.figure.8"></div>
<p>Constant CICM::Key::C_KEY_USAGE_ALLOWED</p>
<pre>const CICM::Key::UsageStatus
	C_KEY_USAGE_ALLOWED = 0x00006016;</pre>
<p>Key is valid for this usage.</p>
<div id="#rfc.figure.9"></div>
<p>Constant CICM::Key::C_KEY_USAGE_FORBIDDEN</p>
<pre>const CICM::Key::UsageStatus
	C_KEY_USAGE_FORBIDDEN = 0x00006019;</pre>
<p>Key is not valid for this usage.</p>
<h1 id="rfc.section.3.7.2">
<a href="#rfc.section.3.7.2">3.7.2.</a> CICM::Key Attributes</h1>
<div id="#rfc.figure.10"></div>
<p>Attribute CICM::Key::identifier</p>
<pre>attribute CICM::CharString identifier;</pre>
<p>Unique global identifier for this key.</p>
<p id="rfc.section.3.7.2.p.1">Remarks: </p>

<ul class="empty"><li>This identifier is the string representation of a key management authority-specific global key identifier. The identifier may be composed of multiple components; the representation of these components within the CICM identifier string is not defined in this specification. The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this identifier.</li></ul>

<p> </p>
<p id="rfc.section.3.7.2.p.2">Warning: </p>

<ul class="empty"><li>This attribute MUST NOT be implemented if CICM::Key::location is implemented.</li></ul>

<p> </p>
<div id="#rfc.figure.11"></div>
<p>Attribute CICM::Key::location</p>
<pre>attribute CICM::UInt32 location;</pre>
<p>Module-specific physical storage location for this key.</p>
<p id="rfc.section.3.7.2.p.3">Warning: </p>

<ul class="empty"><li>This attribute should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules. This attribute MUST NOT be implemented if CICM::Key::identifier is implemented.</li></ul>

<p> </p>
<div id="#rfc.figure.12"></div>
<p>Attribute CICM::Key::alias</p>
<pre>attribute CICM::CharString alias;</pre>
<p>Key alias, to assist in distinguishing one key from another.</p>
<div id="#rfc.figure.13"></div>
<p>Attribute CICM::Key::classification</p>
<pre>attribute CICM::Classification classification;</pre>
<p>Key classification level.</p>
<div id="#rfc.figure.14"></div>
<p>Attribute CICM::Key::caveat</p>
<pre>attribute CICM::CharString caveat;</pre>
<p>Key caveat, a protective marking or distribution/handling instruction that may augment classification level.</p>
<div id="#rfc.figure.15"></div>
<p>Attribute CICM::Key::authority</p>
<pre>attribute CICM::CharString authority;</pre>
<p>Key management authority governing generation and use of key.</p>
<div id="#rfc.figure.16"></div>
<p>Attribute CICM::Key::state</p>
<pre>readonly attribute CICM::Key::State state;</pre>
<p>State of key. A key may become invalid if zeroized, for example. Note that if an attempt is made to use an invalid key, the method accepting the key reference will return with an appropriate error status.</p>
<h1 id="rfc.section.3.7.3">
<a href="#rfc.section.3.7.3">3.7.3.</a> CICM::Key Methods</h1>
<div id="#rfc.figure.17"></div>
<p>Method CICM::Key::wrap()</p>
<pre>CICM::Status wrap(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm
);</pre>
<p>Instruct module to wrap key, destroying the original unwrapped key and replacing it with the newly wrapped key.</p>
<p id="rfc.section.3.7.3.p.1">Parameters: </p>

<ul class="empty">
<li>[in] kek Reference to key encryption key.</li>
<li>[in] algorithm Key wrap algorithm/mode used to wrap key.</li>
</ul>

<p> </p>
<p id="rfc.section.3.7.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED, S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.18"></div>
<p>Method CICM::Key::unwrap()</p>
<pre>CICM::Status unwrap(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm
);</pre>
<p>Instruct module to unwrap key, destroying the original wrapped key and replacing it with the newly unwrapped key.</p>
<p id="rfc.section.3.7.3.p.3">Parameters: </p>

<ul class="empty">
<li>[in] kek Reference to key decryption key.</li>
<li>[in] algorithm Key wrap algorithm/mode used to unwrap key.</li>
</ul>

<p> </p>
<p id="rfc.section.3.7.3.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.19"></div>
<p>Method CICM::Key::export()</p>
<pre>CICM::Status export(
	out CICM::Buffer key_material
);</pre>
<p>Export key material from a cryptographic module as an opaque binary object.</p>
<p id="rfc.section.3.7.3.p.5">Remarks: </p>

<ul class="empty"><li>The key must have been previously wrapped, if required. See CICM::Key::wrap.</li></ul>

<p> </p>
<p id="rfc.section.3.7.3.p.6">Parameters: </p>

<ul class="empty"><li>[out] key_material Binary version of the key.</li></ul>

<p> </p>
<p id="rfc.section.3.7.3.p.7">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_KEY_NOT_WRAPPED, S_KEY_NOT_EXPORTABLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.20"></div>
<p>Method CICM::Key::export_via_fill_interface()</p>
<pre>CICM::Status export_via_fill_interface(
	in  CICM::LocalPort fill_port
);</pre>
<p>Export key material from a cryptographic module via a port representing a key fill interface.</p>
<p id="rfc.section.3.7.3.p.8">Remarks: </p>

<ul class="empty"><li>The key must have been previously wrapped, if required. See CICM::Key::wrap.</li></ul>

<p> </p>
<p id="rfc.section.3.7.3.p.9">Parameters: </p>

<ul class="empty"><li>[in] fill_port The local port from which the key will emanate.</li></ul>

<p> </p>
<p id="rfc.section.3.7.3.p.10">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_KEY_NOT_WRAPPED, S_KEY_NOT_EXPORTABLE, S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.21"></div>
<p>Method CICM::Key::zeroize()</p>
<pre>CICM::Status zeroize();</pre>
<p>Zeroize the selected key.</p>
<p id="rfc.section.3.7.3.p.11">Remarks: </p>

<ul class="empty"><li>Future cryptographic operations depending upon this key MUST fail with a CICM::S_KEY_INVALID status.</li></ul>

<p> </p>
<p id="rfc.section.3.7.3.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.3.8">
<a href="#rfc.section.3.8">3.8.</a> Interface CICM::KeyDatabase</h1>
<div id="#rfc.figure.22"></div>
<p>Interface CICM::KeyDatabase</p>
<pre>interface KeyDatabase {</pre>
<p>CICM::KeyDatabase supports zeroizing keys and reencrypting a module key database. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::key_database attribute.</p>
<h1 id="rfc.section.3.8.1">
<a href="#rfc.section.3.8.1">3.8.1.</a> CICM::KeyDatabase Methods</h1>
<div id="#rfc.figure.23"></div>
<p>Method CICM::KeyDatabase::zeroize()</p>
<pre>CICM::Status zeroize();</pre>
<p>Zeroize all key material on the module.</p>
<p id="rfc.section.3.8.1.p.1">Remarks: </p>

<ul class="empty"><li>This method renders all instantiated key objects invalid.  Future cryptographic operations depending upon zeroized keys MAY fail with a CICM::S_KEY_INVALID status.</li></ul>

<p> </p>
<p id="rfc.section.3.8.1.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.24"></div>
<p>Method CICM::KeyDatabase::reencrypt()</p>
<pre>CICM::Status reencrypt();</pre>
<p>Re-encrypt the module key database.</p>
<p id="rfc.section.3.8.1.p.3">Remarks: </p>

<ul class="empty"><li>This method uses a module-managed key to protect the key database and only applies to keys managed by the module, whether stored internal to the module or stored externally.  Keys stored external to the module and not directly managed by the module must utilize the key wrap methods to protect key material.</li></ul>

<p> </p>
<p id="rfc.section.3.8.1.p.4">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Asymmetric Keys</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Interface CICM::AsymKeyManager</h1>
<div id="#rfc.figure.25"></div>
<p>Interface CICM::AsymKeyManager</p>
<pre>interface AsymKeyManager {</pre>
<p>CICM::AsymKeyManager supports retrieving, importing, and generating asymmetric keysets. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::asym_key_manager attribute. CICM::AsymKeyManager constructs the CICM::AsymKeyIterator and CICM::AsymKey interfaces.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> CICM::AsymKeyManager Attributes</h1>
<div id="#rfc.figure.26"></div>
<p>AttributeCICM::AsymKeyManager::asymkey_iterator</p>
<pre>readonly attribute CICM::AsymKeyIterator asymkey_iterator;</pre>
<p>Returns an iterator to enable a reference to each asymmetric keyset in the module key database to be retrieved.</p>
<p id="rfc.section.4.1.1.p.1">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> CICM::AsymKeyManager Methods</h1>
<div id="#rfc.figure.27"></div>
<p>Method CICM::AsymKeyManager::get_key_by_id()</p>
<pre>CICM::Status get_key_by_id(
	in  CICM::KeyId key_id,
	out CICM::AsymKey key_ref
);</pre>
<p>Retrieves a reference to the asymmetric keyset corresponding to the specified infrastructure-specific identifier.</p>
<p id="rfc.section.4.1.2.p.1">Warning: </p>

<ul class="empty"><li>This method MUST NOT be implemented if CICM::AsymKeyManager::get_key_by_phys_location is implemented.</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.2">Parameters: </p>

<ul class="empty">
<li>[in] key_id Unique identifier of the keyset to be retrieved.</li>
<li>[out] key_ref Reference to keyset corresponding to key identifier.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INVALID_ID, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.28"></div>
<p>Method CICM::AsymKeyManager::get_key_by_phys_location()</p>
<pre>CICM::Status get_key_by_phys_location(
	in  CICM::UInt32 phys_location,
	out CICM::AsymKey key_ref
);</pre>
<p>Retrieves a reference to the asymmetric keyset corresponding to the specified module physical storage location.</p>
<p id="rfc.section.4.1.2.p.4">Warning: </p>

<ul class="empty">
<li>This call should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules.</li>
<li>This method MUST NOT be implemented if CICM::AsymKeyManager::get_key_by_id is implemented.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] phys_location Physical location of the key to be retrieved.</li>
<li>[out] key_ref Reference to key corresponding to physical location.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_PHYSICAL_LOC, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.29"></div>
<p>Method CICM::AsymKeyManager::get_key_last_filled()</p>
<pre>CICM::Status get_key_last_filled(
	out CICM::AsymKey key_ref
);</pre>
<p>Retrieves a reference to the asymmetric keyset corresponding to the keyset most recently filled via a key fill device.</p>
<p id="rfc.section.4.1.2.p.7">Remarks: </p>

<ul class="empty"><li>A client program may need to initiate this action if key material imported into a module does not contain the corresponding key metadata. This method allows a reference to the last keyset filled over the key fill interface to be referenced to enable metadata to be applied directly to the resulting keyset. The error status CICM::S_NOT_AVAILABLE is returned if no key is filled.</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.8">Parameters: </p>

<ul class="empty"><li>[out] key_ref Object representing last filled key.</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.10">See also: </p>

<ul class="empty"><li>SymKeyManager::get_key_last_filled for the symmetric version of this method.</li></ul>

<p> </p>
<div id="#rfc.figure.30"></div>
<p>Method CICM::AsymKeyManager::import_key()</p>
<pre>CICM::Status import_key(
	in  CICM::Buffer key_material,
	out CICM::AsymKey key_ref
);</pre>
<p>Import asymmetric keysets into a cryptographic module.</p>
<p id="rfc.section.4.1.2.p.11">Remarks: </p>

<ul class="empty">
<li>Keysets may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the keyset prior to use.</li>
<li>Keyset attributes may optionally be set to create or supplement key metadata.</li>
<li>The format of the key material value is not defined by CICM.  The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.12">Warning: </p>

<ul class="empty"><li>This method MUST NOT be implemented if CICM::AsymKeyManager::import_key_into_phys_location is implemented.</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.13">Parameters: </p>

<ul class="empty">
<li>[in] key_material Key material to be imported into the module.</li>
<li>[out] key_ref Reference to newly imported key.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.14">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.15">See also: </p>

<ul class="empty">
<li>CICM::SymKeyManager::import_key for the symmetric version of this method.</li>
<li>CICM::AsymKeyManager::import_key_via_fill for the key fill version of this method.</li>
<li>CICM::AsymKeyManager::import_key_into_phys_location for the version of this method that imports key into a specific module key location.</li>
<li>CICM::AsymKeyManager::import_key_via_fill_into_phys_location for the version of this method that fills key into a specific module key location.</li>
</ul>

<p> </p>
<div id="#rfc.figure.31"></div>
<p>Method CICM::AsymKeyManager::import_key_into_phys_location()</p>
<pre>CICM::Status import_key_into_phys_location(
	in  CICM::Buffer key_material,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);</pre>
<p>Import key material into a specific physical key location in a cryptographic module.</p>
<p id="rfc.section.4.1.2.p.16">Remarks: </p>

<ul class="empty">
<li>Keysets may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the keyset prior to use.</li>
<li>Keyset object attributes may optionally be set to create or supplement keyset metadata.</li>
<li>The format of the key material value is not defined by CICM.  The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.17">Warning: </p>

<ul class="empty">
<li>This call should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules.</li>
<li>This method MUST NOT be implemented if CICM::AsymKeyManager::import_key is implemented.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.18">Parameters: </p>

<ul class="empty">
<li>[in] key_material Key material to be imported into the module.</li>
<li>[in] phys_location Physical location into which to import keyset.</li>
<li>[out] key_ref Reference to newly imported keyset.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.19">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.32"></div>
<p>Method CICM::AsymKeyManager::import_key_via_fill()</p>
<pre>CICM::Status import_key_via_fill(
	in  CICM::LocalPort fill_port,
	out CICM::AsymKey key_ref
);</pre>
<p>Initiate the import of key material via a key fill interface.</p>
<p id="rfc.section.4.1.2.p.20">Remarks: </p>

<ul class="empty">
<li>In some cases, a key fill device can initiate and effect the filling of key into a module completely independent of the host and thus any API control. In such cases, the host will utilize the CICM::AsymKeyManager::get_key_by_id, CICM::AsymKeyManager::get_key_by_phys_location, or CICM::AsymKeyManager::get_key_last_filled methods after the key fill has completed to enable future reference to the keyset.</li>
<li>Keysets may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the key prior to use.</li>
<li>Keyset attributes may optionally be set to create or supplement keyset metadata.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.21">Warning: </p>

<ul class="empty"><li>This method MUST NOT be implemented if CICM::AsymKeyManager::import_key_via_fill_into_phys_location is implemented.</li></ul>

<p> </p>
<p id="rfc.section.4.1.2.p.22">Parameters: </p>

<ul class="empty">
<li>[in] fill_port Fill port on which to initiate import.</li>
<li>[out] key_ref Reference to newly imported keyset.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.23">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.33"></div>
<p>Method CICM::AsymKeyManager::import_key_via_fill_into_phys_location()</p>
<pre>CICM::Status import_key_via_fill_into_phys_location(
	in  CICM::LocalPort fill_port,
	in  CICM::UInt32 phys_location,
	out CICM::AsymKey key_ref
);</pre>
<p>Initiate the import of key material into a specific key physical location via a key fill interface.</p>
<p id="rfc.section.4.1.2.p.24">Remarks: </p>

<ul class="empty">
<li>In some cases, a key fill device can initiate and effect the filling of key into a module completely independent of the host and thus any API control. In such cases, the host will utilize the CICM::AsymKeyManager::get_key_by_id, CICM::AsymKeyManager::get_key_by_phys_location, or CICM::AsymKeyManager::get_key_last_filled methods after the key fill has completed to enable future reference to the keyset.</li>
<li>Keysets may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the keyset prior to use.</li>
<li>Keyset attributes may optionally be set to create or supplement keyset metadata.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.25">Warning: </p>

<ul class="empty">
<li>This call should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules.</li>
<li>This method MUST NOT be implemented if CICM::AsymKeyManager::import_key_via_fill is implemented.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.26">Parameters: </p>

<ul class="empty">
<li>[in] fill_port Port of the key fill interface.</li>
<li>[in] phys_location Physical location into which to import keyset.</li>
<li>[out] key_ref Reference to newly imported keyset.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.27">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.34"></div>
<p>Method CICM::AsymKeyManager::generate_key_pair()</p>
<pre>CICM::Status generate_key_pair(
	in  CICM::AsymEncrAlgorithmId algorithm,
	out CICM::AsymKey key_ref
);</pre>
<p>Generate an asymmetric key pair compatible with the characteristics of the specified algorithm.</p>
<p id="rfc.section.4.1.2.p.28">Parameters: </p>

<ul class="empty">
<li>[in] algorithm Desired algorithm of resulting asymmetric key pair.</li>
<li>[out] key_ref Reference to newly generated key pair.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.29">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Interface CICM::AsymKey</h1>
<div id="#rfc.figure.35"></div>
<p>Interface CICM::AsymKey</p>
<pre>interface AsymKey : CICM::Key {</pre>
<p>CICM::AsymKey serves as an abstraction for an asymmetric keyset, which may comprise an asymmetric key pair, the public and private key components of a keypair, the digital certificate corresponding to the keyset public key, one or more verification certificates in the certificate chain of trust, and related public domain parameters; and supports operations on asymmetric keys, including wrapping and unwrapping.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> CICM::AsymKey Inheritance</h1>
<p id="rfc.section.4.2.1.p.1">CICM::AsymKey inherits from: CICM::Key.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> CICM::AsymKey Types and Constants</h1>
<div id="#rfc.figure.36"></div>
<p>Type CICM::AsymKey::Usage</p>
<pre>typedef CICM::UInt32 Usage;</pre>
<p>Asymmetric key usage types.</p>
<div id="#rfc.figure.37"></div>
<p>Constant CICM::AsymKey::C_USAGE_ASYM_DATA_ENCIPHERMENT</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_ASYM_DATA_ENCIPHERMENT = 0x00006001;</pre>
<p>Key intended for enciphering data.</p>
<div id="#rfc.figure.38"></div>
<p>Constant CICM::AsymKey::C_USAGE_ASYM_KEY_ENCIPHERMENT</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_ASYM_KEY_ENCIPHERMENT = 0x00006002;</pre>
<p>Key intended for enciphering other keys.</p>
<div id="#rfc.figure.39"></div>
<p>Constant CICM::AsymKey::C_USAGE_CERT_SIGN</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_CERT_SIGN = 0x00006004;</pre>
<p>Key intended for signing/verifying digital certificates.</p>
<div id="#rfc.figure.40"></div>
<p>Constant CICM::AsymKey::C_USAGE_CRL_SIGN</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_CRL_SIGN = 0x00006007;</pre>
<p>Key intended for signing/verifying certificate revocation lists.</p>
<div id="#rfc.figure.41"></div>
<p>Constant CICM::AsymKey::C_USAGE_DIGITAL_SIGNATURE</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_DIGITAL_SIGNATURE = 0x00006008;</pre>
<p>Key intended for producing digital signatures.</p>
<div id="#rfc.figure.42"></div>
<p>Constant CICM::AsymKey::C_USAGE_INFRA_KEY_AGREEMENT</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_INFRA_KEY_AGREEMENT = 0x0000600B;</pre>
<p>Key intended for participating in an infrastructure key agreement protocol.</p>
<div id="#rfc.figure.43"></div>
<p>Constant CICM::AsymKey::C_USAGE_P2P_KEY_AGREEMENT</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_P2P_KEY_AGREEMENT = 0x0000600D;</pre>
<p>Key intended for participating in a peer-to-peer key agreement protocol.</p>
<div id="#rfc.figure.44"></div>
<p>Constant CICM::AsymKey::C_USAGE_SEED</p>
<pre>const CICM::AsymKey::Usage
	C_USAGE_SEED = 0x0000600E;</pre>
<p>Key intended to serve as seed material.</p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> CICM::AsymKey Methods</h1>
<div id="#rfc.figure.45"></div>
<p>Method CICM::AsymKey::wrap_and_copy()</p>
<pre>CICM::Status wrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::AsymKey wrapped_key
);</pre>
<p>Instruct module to wrap keyset, resulting in two keysets, the original unwrapped keyset and the newly wrapped keyset.</p>
<p id="rfc.section.4.2.3.p.1">Parameters: </p>

<ul class="empty">
<li>[in] kek Reference to key encryption key.</li>
<li>[in] algorithm Key wrap algorithm/mode used to wrap keyset.</li>
<li>[out] wrapped_key Reference to resulting wrapped keyset.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.3.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED, S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.4.2.3.p.3">See also: </p>

<ul class="empty"><li>CICM::SymKey::wrap_and_copy for the symmetric version of this method.</li></ul>

<p> </p>
<div id="#rfc.figure.46"></div>
<p>Method CICM::AsymKey::unwrap_and_copy()</p>
<pre>CICM::Status unwrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::AsymKey unwrapped_key
);</pre>
<p>Instruct module to unwrap key, resulting in two keys, the original wrapped key and the newly unwrapped key.</p>
<p id="rfc.section.4.2.3.p.4">Parameters: </p>

<ul class="empty">
<li>[in] kek Reference to key decryption key.</li>
<li>[in] algorithm Key wrap algorithm/mode used to unwrap keyset.</li>
<li>[out] unwrapped_key Reference to resulting unwrapped keyset.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.3.p.5">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT   </li></ul>

<p> </p>
<p id="rfc.section.4.2.3.p.6">See also: </p>

<ul class="empty"><li>CICM::SymKey::unwrap_and_copy for the symmetric version of this method.</li></ul>

<p> </p>
<div id="#rfc.figure.47"></div>
<p>Method CICM::AsymKey::validate_key_usage()</p>
<pre>CICM::Status validate_key_usage(
	in  CICM::AsymKey::Usage usage_type,
	out CICM::Key::UsageStatus valid
);</pre>
<p>Validate that this keyset may be used for a specific purpose.</p>
<p id="rfc.section.4.2.3.p.7">Remarks: </p>

<ul class="empty"><li>In some cases, a given keyset can be used for multiple purposes.</li></ul>

<p> </p>
<p id="rfc.section.4.2.3.p.8">Parameters: </p>

<ul class="empty">
<li>[in] usage_type Specific purpose to validate.</li>
<li>[out] valid Indiciates whether or not the key may be used for the specified purpose.</li>
</ul>

<p> </p>
<p id="rfc.section.4.2.3.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.4.2.3.p.10">See also: </p>

<ul class="empty"><li>CICM::SymKey::validate_key_usage for the symmetric version of this method.</li></ul>

<p> </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Interface CICM::AsymKeyIterator</h1>
<div id="#rfc.figure.48"></div>
<p>Interface CICM::AsymKeyIterator</p>
<pre>interface AsymKeyIterator : CICM::Iterator {</pre>
<p>CICM::AsymKeyIterator supports retrieving a reference to each usable asymmetric key on a module. CICM::AsymKeyIterator constructs the CICM::AsymKey interface.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> CICM::AsymKeyIterator Inheritance</h1>
<p id="rfc.section.4.3.1.p.1">CICM::AsymKeyIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> CICM::AsymKeyIterator Methods</h1>
<div id="#rfc.figure.49"></div>
<p>Method CICM::AsymKeyIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::AsymKey asym_key_ref
);</pre>
<p>Returns a reference to the next asymmetric key.</p>
<p id="rfc.section.4.3.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.4.3.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] asym_key_ref Reference to next asymmetric key.</li></ul>

<p> </p>
<p id="rfc.section.4.3.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Symmetric Keys</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Interface CICM::SymKeyManager</h1>
<div id="#rfc.figure.50"></div>
<p>Interface CICM::SymKeyManager</p>
<pre>interface SymKeyManager {</pre>
<p>CICM::SymKeyManager supports retrieving, importing, generating and deriving symmetric keys; and operating key management protocols. It is accessed from CICM::CryptoModule via the CICM::CryptoModule::sym_key_manager attribute.  CICM::SymKeyManager constructs the CICM::KeyProtocolSender, CICM::KeyProtocolReceiver, CICM::SymKeyIterator, and CICM::SymKey interfaces.</p>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> CICM::SymKeyManager Attributes</h1>
<div id="#rfc.figure.51"></div>
<p>AttributeCICM::SymKeyManager::symkey_iterator</p>
<pre>readonly attribute CICM::SymKeyIterator symkey_iterator;</pre>
<p>Returns an iterator to enable a reference to each symmetric key in the module key database to be retrieved.</p>
<p id="rfc.section.5.1.1.p.1">Remarks: </p>

<ul class="empty"><li>The returned iterator is set to the beginning of the iterated sequence.</li></ul>

<p> </p>
<div id="#rfc.figure.52"></div>
<p>AttributeCICM::SymKeyManager::key_protocol_sender</p>
<pre>readonly attribute CICM::KeyProtocolSender key_protocol_sender;</pre>
<p>CICM::KeyProtocolSender supports sending key management protocol-related messages into a module.</p>
<div id="#rfc.figure.53"></div>
<p>AttributeCICM::SymKeyManager::key_protocol_receiver</p>
<pre>readonly attribute CICM::KeyProtocolReceiver key_protocol_receiver;</pre>
<p>CICM::KeyProtocolReceiver supports receiving key management protocol-related messages from a module. CICM::KeyProtocolReceiver constructs the CICM::SymKey interface.</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> CICM::SymKeyManager Methods</h1>
<div id="#rfc.figure.54"></div>
<p>Method CICM::SymKeyManager::get_key_by_id()</p>
<pre>CICM::Status get_key_by_id(
	in  CICM::KeyId key_id,
	out CICM::SymKey key_ref
);</pre>
<p>Retrieves a reference to the symmetric key corresponding to the specified infrastructure-specific identifier.</p>
<p id="rfc.section.5.1.2.p.1">Warning: </p>

<ul class="empty"><li>This method MUST NOT be implemented if CICM::SymKeyManager::get_key_by_phys_location is implemented.</li></ul>

<p> </p>
<p id="rfc.section.5.1.2.p.2">Parameters: </p>

<ul class="empty">
<li>[in] key_id Unique identifier of the key to be retrieved.</li>
<li>[out] key_ref Reference to key corresponding to key identifier.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INVALID_ID, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.55"></div>
<p>Method CICM::SymKeyManager::get_key_by_phys_location()</p>
<pre>CICM::Status get_key_by_phys_location(
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);</pre>
<p>Retrieves a reference to the symmetric key corresponding to the specified module physical storage location.</p>
<p id="rfc.section.5.1.2.p.4">Warning: </p>

<ul class="empty">
<li>This call should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules.</li>
<li>This method MUST NOT be implemented if CICM::SymKeyManager::get_key_by_id is implemented.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.5">Parameters: </p>

<ul class="empty">
<li>[in] phys_location Physical location of the key to be retrieved.</li>
<li>[out] key_ref Reference to key corresponding to physical location.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_PHYSICAL_LOC, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.56"></div>
<p>Method CICM::SymKeyManager::get_key_last_filled()</p>
<pre>CICM::Status get_key_last_filled(
	out CICM::SymKey key_ref
);</pre>
<p>Retrieves a reference to the symmetric key corresponding to the key most recently filled via a key fill device.</p>
<p id="rfc.section.5.1.2.p.7">Remarks: </p>

<ul class="empty"><li>A client program may need to initiate this action if key material imported into a module does not contain the corresponding key metadata. This method allows a reference to the last key filled over the key fill interface to be referenced to enable metadata to be applied directly to the resulting key. The error status CICM::S_NOT_AVAILABLE is returned if no key is filled.</li></ul>

<p> </p>
<p id="rfc.section.5.1.2.p.8">Parameters: </p>

<ul class="empty"><li>[out] key_ref Reference to last filled key.</li></ul>

<p> </p>
<p id="rfc.section.5.1.2.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.57"></div>
<p>Method CICM::SymKeyManager::import_key()</p>
<pre>CICM::Status import_key(
	in  CICM::Buffer key_material,
	out CICM::SymKey key_ref
);</pre>
<p>Import key material or seed key for pseudorandom data generation into a cryptographic module.</p>
<p id="rfc.section.5.1.2.p.10">Remarks: </p>

<ul class="empty">
<li>Keys may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the key prior to use.</li>
<li>Key attributes may optionally be set to create or supplement key metadata.</li>
<li>The format of the key material value is not defined by CICM.  The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) must reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.11">Warning: </p>

<ul class="empty"><li>This method MUST NOT be implemented if CICM::SymKeyManager::import_key_into_phys_location is implemented.</li></ul>

<p> </p>
<p id="rfc.section.5.1.2.p.12">Parameters: </p>

<ul class="empty">
<li>[in] key_material Key material to be imported into the module.</li>
<li>[out] key_ref Reference to newly imported key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.13">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.58"></div>
<p>Method CICM::SymKeyManager::import_key_into_phys_location()</p>
<pre>CICM::Status import_key_into_phys_location(
	in  CICM::Buffer key_material,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);</pre>
<p>Import key material or seed key for pseudorandom data generation into a specific physical key location in a cryptographic module.</p>
<p id="rfc.section.5.1.2.p.14">Remarks: </p>

<ul class="empty">
<li>Keys may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the key prior to use.</li>
<li>Key attributes may optionally be set to create or supplement key metadata.</li>
<li>The format of the key material value is not defined by CICM.  The Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) must reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.15">Warning: </p>

<ul class="empty">
<li>This call should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules.</li>
<li>This method MUST NOT be implemented if CICM::SymKeyManager::import_key is implemented.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.16">Parameters: </p>

<ul class="empty">
<li>[in] key_material Key material to be imported into the module.</li>
<li>[in] phys_location Physical location into which to import key.</li>
<li>[out] key_ref Reference to newly imported key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.17">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.59"></div>
<p>Method CICM::SymKeyManager::import_key_via_fill()</p>
<pre>CICM::Status import_key_via_fill(
	in  CICM::LocalPort fill_port,
	out CICM::SymKey key_ref
);</pre>
<p>Initiate the import of key material via a key fill interface.</p>
<p id="rfc.section.5.1.2.p.18">Remarks: </p>

<ul class="empty">
<li>In some cases, a key fill device can initiate and effect the filling of key into a module completely independent of the host and thus any API control. In such cases, the host will utilize the CICM::SymKeyManager::get_key_by_id, CICM::SymKeyManager::get_key_by_phys_location, or CICM::SymKeyManager::get_key_last_filled methods after the key fill has completed to enable future reference to the key.</li>
<li>Keys may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the key prior to use.</li>
<li>Key attributes may optionally be set to create or supplement key metadata.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.19">Warning: </p>

<ul class="empty"><li>This method MUST NOT be implemented if CICM::SymKeyManager::import_key_via_fill_into_phys_location is implemented.</li></ul>

<p> </p>
<p id="rfc.section.5.1.2.p.20">Parameters: </p>

<ul class="empty">
<li>[in] fill_port Port of the key fill interface.</li>
<li>[out] key_ref Reference to newly imported key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.21">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.60"></div>
<p>Method CICM::SymKeyManager::import_key_via_fill_into_phys_location()</p>
<pre>CICM::Status import_key_via_fill_into_phys_location(
	in  CICM::LocalPort fill_port,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);</pre>
<p>Initiate the import of key material into a specific key physical location via a key fill interface.</p>
<p id="rfc.section.5.1.2.p.22">Remarks: </p>

<ul class="empty">
<li>In some cases, a key fill device can initiate and effect the filling of key into a module completely independent of the host and thus any API control. In such cases, the host will utilize the CICM::SymKeyManager::get_key_by_id, CICM::SymKeyManager::get_key_by_phys_location, or CICM::SymKeyManager::get_key_last_filled methods after the key fill has completed to enable future reference to the key.</li>
<li>Keys may be imported into a module as wrapped entities, necessitating the use of CICM::Key::unwrap to decrypt the key prior to use.</li>
<li>Key attributes may optionally be set to create or supplement key metadata.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.23">Warning: </p>

<ul class="empty">
<li>This call should only be used when a module utilizes a key storage model that requires keys of particular types to be stored in specific locations or in situations where keys are tied to module capabilities based upon physical location of the key. Because of the architectural knowledge of a module required, its use is highly discouraged because it virtually guarantees that code using it will be incompatible with other dissimilar modules.</li>
<li>This method MUST NOT be implemented if CICM::SymKeyManager::import_key_via_fill is implemented.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.24">Parameters: </p>

<ul class="empty">
<li>[in] fill_port Port of the key fill interface.</li>
<li>[in] phys_location Physical location into which to import key.</li>
<li>[out] key_ref Reference to newly imported key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.25">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<div id="#rfc.figure.61"></div>
<p>Method CICM::SymKeyManager::generate_key()</p>
<pre>CICM::Status generate_key(
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
)</pre>
<p>Generate a symmetric key compatible with the characteristics of the specified algorithm.</p>
<p id="rfc.section.5.1.2.p.26">Parameters: </p>

<ul class="empty">
<li>[in] algorithm Desired algorithm of resulting symmetric key.</li>
<li>[out] key_ref Reference to newly generated key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.27">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</li></ul>

<p> </p>
<div id="#rfc.figure.62"></div>
<p>Method CICM::SymKeyManager::derive_key()</p>
<pre>CICM::Status derive_key(
	in  CICM::CharString password,
	in  CICM::Buffer salt,
	in  CICM::UInt32 iteration_count,
	in  CICM::HashAlgorithmId hash_algorithm,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
);</pre>
<p>Derives a symmetric key from a password and other parameters using a password-based key derivation function (PBKDF).</p>
<p id="rfc.section.5.1.2.p.28">Parameters: </p>

<ul class="empty">
<li>[in] password Password for conversion into a cryptographic key.</li>
<li>[in] salt Binary salt value.</li>
<li>[in] iteration_count Positive integer representing number of iterations to apply to hashing algorithm.</li>
<li>[in] hash_algorithm Hash function applied to derive key.</li>
<li>[in] algorithm Desired algorithm/mode of resulting symmetric key.</li>
<li>[out] key_ref Reference to newly derived key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.29">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN, S_SALT_INVALID, S_ITERATION_COUNT_INVALID</li></ul>

<p> </p>
<div id="#rfc.figure.63"></div>
<p>Method CICM::SymKeyManager::derive_deterministic_key()</p>
<pre>CICM::Status derive_deterministic_key(
	in  CICM::SymKey key_prod_key,
	in  CICM::CharString shared_secret,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
);</pre>
<p>Derives a symmetric key using a distributed deterministic key generation scheme.</p>
<p id="rfc.section.5.1.2.p.30">Remarks: </p>

<ul class="empty"><li>This may be used by peers in an ad-hoc group who initially only share a key production key (KPK) but are subsequently able to share an additional secret.</li></ul>

<p> </p>
<p id="rfc.section.5.1.2.p.31">Parameters: </p>

<ul class="empty">
<li>[in] key_prod_key Key production key.</li>
<li>[in] shared_secret Text-based secret sharable amongst peers in a group.</li>
<li>[in] algorithm Desired algorithm/mode of resulting symmetric key.</li>
<li>[out] key_ref Reference to newly derived key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.32">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN</li></ul>

<p> </p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Interface CICM::SymKey</h1>
<div id="#rfc.figure.64"></div>
<p>Interface CICM::SymKey</p>
<pre>interface SymKey : CICM::Key {</pre>
<p>CICM::SymKey serves as a reference to a symmetric key contained within a module and supports operations on symmetric keys, including key conversion, updating, wrapping, and unwrapping.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> CICM::SymKey Inheritance</h1>
<p id="rfc.section.5.2.1.p.1">CICM::SymKey inherits from: CICM::Key.</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> CICM::SymKey Types and Constants</h1>
<div id="#rfc.figure.65"></div>
<p>Type CICM::SymKey::Usage</p>
<pre>typedef CICM::UInt32 Usage;</pre>
<p>Symmetric key usage types.</p>
<div id="#rfc.figure.66"></div>
<p>Constant CICM::SymKey::C_USAGE_GENERATE_KEYSTREAM</p>
<pre>const CICM::SymKey::Usage
	C_USAGE_GENERATE_KEYSTREAM = 0x0000601A;</pre>
<p>Key intended for generating keystream.</p>
<div id="#rfc.figure.67"></div>
<p>Constant CICM::SymKey::C_USAGE_KEY_PRODUCTION_KEY</p>
<pre>const CICM::SymKey::Usage
	C_USAGE_KEY_PRODUCTION_KEY = 0x0000601C;</pre>
<p>Key intended for producing other keys.</p>
<div id="#rfc.figure.68"></div>
<p>Constant CICM::SymKey::C_USAGE_MESSAGE_AUTHENTICATION_CODE</p>
<pre>const CICM::SymKey::Usage
	C_USAGE_MESSAGE_AUTHENTICATION_CODE = 0x0000601F;</pre>
<p>Key intended for computing a Message Authentication Code.</p>
<div id="#rfc.figure.69"></div>
<p>Constant CICM::SymKey::C_USAGE_SYM_DATA_ENCIPHERMENT</p>
<pre>const CICM::SymKey::Usage
	C_USAGE_SYM_DATA_ENCIPHERMENT = 0x00006020;</pre>
<p>Key intended for enciphering data.</p>
<div id="#rfc.figure.70"></div>
<p>Constant CICM::SymKey::C_USAGE_SYM_KEY_ENCIPHERMENT</p>
<pre>const CICM::SymKey::Usage
	C_USAGE_SYM_KEY_ENCIPHERMENT = 0x00006023;</pre>
<p>Key intended for enciphering other keys.</p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> CICM::SymKey Attributes</h1>
<div id="#rfc.figure.71"></div>
<p>Attribute CICM::SymKey::update_count</p>
<pre>readonly attribute CICM::UInt32 update_count;</pre>
<p>Key update count.</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> CICM::SymKey Methods</h1>
<div id="#rfc.figure.72"></div>
<p>Method CICM::SymKey::update()</p>
<pre>CICM::Status update();</pre>
<p>Cryptographically update the key using the key's native algorithm. The update modifies the existing key.</p>
<p id="rfc.section.5.2.4.p.1">Remarks: </p>

<ul class="empty"><li>The new update count resulting from a call to this method is available as an attribute of the key object.</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_WRAPPED, S_KEY_UPDATE_MAX, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.3">See also: </p>

<ul class="empty"><li>CICM::SymKey::update_with_algo for the version of this method that accepts an algorithm parameter.</li></ul>

<p> </p>
<div id="#rfc.figure.73"></div>
<p>Method CICM::SymKey::update_with_algo()</p>
<pre>CICM::Status update_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);</pre>
<p>Cryptographically update the key using the specified key update algorithm. The update modifies the existing key.</p>
<p id="rfc.section.5.2.4.p.4">Remarks: </p>

<ul class="empty"><li>The new update count resulting from a call to this method is available as an attribute of the key object.</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.5">Parameters: </p>

<ul class="empty"><li>[in] algorithm Cryptographic algorithm/mode to use to effect the key update.</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.6">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_WRAPPED, S_KEY_UPDATE_MAX, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.7">See also: </p>

<ul class="empty"><li>CICM::SymKey::update for the version of this method that does not require an algorithm to be specified.</li></ul>

<p> </p>
<div id="#rfc.figure.74"></div>
<p>Method CICM::SymKey::wrap_and_copy()</p>
<pre>CICM::Status wrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::SymKey wrapped_key
);</pre>
<p>Instruct module to wrap key, resulting in two keys, the original unwrapped key and the newly wrapped key.</p>
<p id="rfc.section.5.2.4.p.8">Parameters: </p>

<ul class="empty">
<li>[in] kek Reference to key encryption key.</li>
<li>[in] algorithm Key wrap algorithm/mode used to wrap key.</li>
<li>[out] wrapped_key Reference to resulting wrapped key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.4.p.9">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED, S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.10">See also: </p>

<ul class="empty"><li>CICM::AsymKey::wrap_and_copy for the asymmetric version of this method.</li></ul>

<p> </p>
<div id="#rfc.figure.75"></div>
<p>Method CICM::SymKey::unwrap_and_copy()</p>
<pre>CICM::Status unwrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::SymKey unwrapped_key
);</pre>
<p>Instruct module to unwrap key, resulting in two keys, the original wrapped key and the newly unwrapped key.</p>
<p id="rfc.section.5.2.4.p.11">Parameters: </p>

<ul class="empty">
<li>[in] kek Reference to key decryption key.</li>
<li>[in] algorithm Key wrap algorithm/mode used to unwrap key.</li>
<li>[out] unwrapped_key Reference to resulting unwrapped key.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.4.p.12">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.13">See also: </p>

<ul class="empty"><li>CICM::AsymKey::unwrap_and_copy for the asymmetric version of this method.</li></ul>

<p> </p>
<div id="#rfc.figure.76"></div>
<p>Method CICM::SymKey::validate_key_usage()</p>
<pre>CICM::Status validate_key_usage(
	in  CICM::SymKey::Usage usage_type,
	out CICM::Key::UsageStatus valid
);</pre>
<p>Validate that this key may be used for a specific purpose.</p>
<p id="rfc.section.5.2.4.p.14">Remarks: </p>

<ul class="empty"><li>In some cases, a given key can be used for multiple purposes.</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.15">Parameters: </p>

<ul class="empty">
<li>[in] usage_type Specific purpose to validate.</li>
<li>[out] valid Indiciates if the key may be used for the specified purpose.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.4.p.16">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<p id="rfc.section.5.2.4.p.17">See also: </p>

<ul class="empty"><li>CICM::AsymKey::validate_key_usage for the asymmetric version of this method.</li></ul>

<p> </p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> Interface CICM::SymKeyIterator</h1>
<div id="#rfc.figure.77"></div>
<p>Interface CICM::SymKeyIterator</p>
<pre>interface SymKeyIterator : CICM::Iterator {</pre>
<p>CICM::SymKeyIterator supports retrieving a reference to each usable symmetric key on a module. CICM::SymKeyIterator constructs the CICM::SymKey interface.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> CICM::SymKeyIterator Inheritance</h1>
<p id="rfc.section.5.3.1.p.1">CICM::SymKeyIterator inherits from: CICM::Iterator.</p>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> CICM::SymKeyIterator Methods</h1>
<div id="#rfc.figure.78"></div>
<p>Method CICM::SymKeyIterator::get_next()</p>
<pre>CICM::Status get_next(
	out CICM::SymKey sym_key_ref
);</pre>
<p>Returns a reference to the next symmetric key.</p>
<p id="rfc.section.5.3.2.p.1">Remarks: </p>

<ul class="empty"><li>Use CICM::Iterator::has_next to determine if additional elements exist.</li></ul>

<p> </p>
<p id="rfc.section.5.3.2.p.2">Parameters: </p>

<ul class="empty"><li>[out] sym_key_ref Reference to next symmetric key.</li></ul>

<p> </p>
<p id="rfc.section.5.3.2.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</li></ul>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Key Protocol</h1>
<p id="rfc.section.6.p.1">The key management capabilities described here support certain key management protocols, including key establishment/distribution protocols such as Diffie-Hellman, EC-DH, and EC-MQV; trust anchor management protocols; the importation of key white lists (acceptable keys) or black lists (revoked keys or keys restricted administratively); and the execution of remote key functions. These key protocol IDL interfaces initiate a key agreement protocol between two or more entities to establish a secret key over an insecure communications channel. CICM channel negotiators (CICM::Negotiator) similarly initiate a key agreement protocol with a remote entity, but this typically results in an ephemeral key, in contrast to these key protocol interfaces which result in a persistent symmetric key that can be used by a variety of key management and channel management functions.</p>
<p id="rfc.section.6.p.2">For the purposes of these key protocol-related interfaces, a client program using the CICM API is only an intermediary in a key management protocol being conducted between a cryptographic module and other participants in a protocol session. In this role, a client program determines which module(s) should be involved and conveys the protocol messages, but otherwise does not participate in the protocol session. The client may be responsible for determining which key agreement protocol to use as well as for the reliable transport of messages passed between the peer entities.  The interactions that comprise a protocol session in its entirety may entail a number of exchanges among the participants in the protocol. Any results from calls to key protocol methods during the course of the protocol exchange must be communicated to the appropriate peer entity by the caller. The progress, success, or failure of the protocol session is determined by the modules and other active participants in the interaction.</p>
<p id="rfc.section.6.p.3">CICM key protocol functionality is exported via two independent objects: CICM::KeyProtocolSender for protocol messages inbound to the module and CICM::KeyProtocolReceiver for messages outbound from the module. Access to each respective object is available via CICM::SymKeyManager::key_protocol_sender and CICM::SymKeyManager::key_protocol_receiver.</p>
<p id="rfc.section.6.p.4">The key protocol methods support protocol sessions that may be long-term interactions potentially extending over several invocations of the controlling client program. To allow for this possibility, KeyProtocolReceiver::get_from_module may be used to "query" a module to determine if a response is ready and, if so, to retrieve response traffic (including current session status information) from the module. Thus, a single response from the module may take the form of a number of queries by the client program, with any productive response deferred until the module is ready: </p>

<ul class="empty">
<li>query, response is C_PROTOCOL_RECEIVE_BUSY</li>
<li>query, response is C_PROTOCOL_RECEIVE_BUSY</li>
<li>...</li>
<li>query, response is C_PROTOCOL_RECEIVE_BUSY</li>
<li>query, results returned, response is C_PROTOCOL_RECEIVE_OKAY</li>
</ul>

<p> </p>
<p id="rfc.section.6.p.5">In the example above, the client program expects either a "condition" update from the module as part of the protocol session, or the most recent results from the active session. Thus, the client program queries the module periodically until it is ready to produce a response.</p>
<p id="rfc.section.6.p.6">The traffic relayed by these functions is part of a specific protocol session. The protocol governing this session is specified with the protocol parameter, either the value CICM::IMPLICIT_PROTOCOL_ID, denoting that the message itself indicates the protocol, or a unique protocol identifier designating the protocol directly. If the protocol parameter is CICM::IMPLICIT_PROTOCOL_ID but the message does not indicate the protocol, then the method fails, returning the CICM::S_PROTO_UNDETERMINED error status.</p>
<p id="rfc.section.6.p.7">The initial message in a protocol exchange can be generated either by the cryptographic module or some other party, including some party in a key management infrastructure or the client program itself. If the initial message is generated by the cryptographic module, a two-step process allows the message to be retrieved from the module: </p>

<ol>
<li>The module notifies the client program that a protocol message is available to be retrieved via the CICM module event listener facility (this requires a CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE to have been previously registered by the client program). The listener facility provides an opaque buffer as part of the notification that is passed to the module in the following step to identify the specific protocol message involved.</li>
<li>The CICM::KeyProtocolReceiver::get_from_module method is used to retrieve the message from the module.</li>
</ol>

<p> </p>
<p id="rfc.section.6.p.8">If the initial message is generated by some other party, the CICM::KeyProtocolSender::put_into_module method is used to convey the message into the module.</p>
<p id="rfc.section.6.p.9">Any key protocol-related key fill device interactions are outside the scope of the API.</p>
<p id="rfc.section.6.p.10">Individual protocol events do not require a transaction identifier. Instead, each message itself indicates where it is to be forwarded (i.e. which module or other participant is to receive the message). This means that the client program must be capable of determining which module to associate with a given message, possibly by examining metadata conveyed with the message.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Participants in the Interaction</h1>
<p id="rfc.section.6.1.p.1">There are three types of participants in a protocol session using the key protocol functionality: </p>

<ul>
<li>The cryptographic modules themselves. Note that although these methods work with modules individually, there may in fact be several modules involved in a single protocol session, e.g., to deliver the same key material to several modules available to a host or in a net.</li>
<li>The other participants (generally key management infrastructure components) that also take an active part in the session, i.e., those that generate and/or consume messages exchanged in the session (perhaps with status indications embedded in the messages). All active participants, to the extent they find necessary, maintain and update internal status as the session continues.</li>
<li>The intermediary client program that conveys the messages among the active participants in the session (the cryptographic modules themselves and the other active participants in the session). Note that a module may generate a message for transmission to another module as part of the protocol session.</li>
</ul>
<p id="rfc.section.6.1.p.2">The CICM API is the interface between the intermediary client programs and the cryptographic modules. All exchanges for a specific protocol session between a given module and other modules or other active participants (Party 1, ..., Party N) are mediated by the intermediary client program using CICM. Although the client program does not directly participate in the protocol session, the client program may be asked during the negotiation process to display identifying information about the remote party in the protocol to a human user who must determine if the remote party is the expected remote party in the protocol and, if so, must positively acknowledge this assertion to allow the protocol to continue. Some protocol sessions will not require this peer validation interaction (e.g., validation of the peer using a trust anchor is deemed sufficient or an external trusted display handles the user interaction).</p>
<p id="rfc.section.6.1.p.3">Except for recognizing the specific role of the cryptographic modules themselves, assignment of roles in the protocol to the active participants is out of scope for this document.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Return Status, Condition, and Session Status</h1>
<p id="rfc.section.6.2.p.1">The key protocol interfaces convey messages between modules and the intermediary client program but do not conduct the actual protocol session. However, the client program still needs to know something about the state of the session, so the key protocol methods impart three types of status information: </p>

<ul>
<li>Status return value indicates the status of the method call itself. In the event of a failure, it gives an indication of what the failure was. Note that the returned value does not indicate the state of the protocol session itself: It could report a faulty call (e.g., an invalid protocol identifier) even when the protocol session is still making progress, and it could report a successful exchange with the cryptographic module even when the module decides that the session has reached an error condition.</li>
<li>The returned condition indication summarizes for the client program the state of the session, perhaps to be used along with other information to suggest what the client program should do next as part of the current protocol session.</li>
<li>The current or resulting status of the protocol session is embedded in the message conveyed between the client program and the active participants. The client program typically will not interpret the contents of this message; instead, it will simply convey the message to the appropriate active participants, who may then interpret the status in the message and take the appropriate next step in the protocol.</li>
</ul>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Generic Scenario</h1>
<p id="rfc.section.6.3.p.1">The following diagram presents a generic scenario for a key protocol session. This diagram does not show message exchanges with any other active participants, since they are out of scope for the API. Note that, although responses from the module to the intermediary client program are represented as arrows in the diagram, in fact, the module actually conveys the response only when the client program explicitly asks or is prompted by an event to ask for it.</p>
<div id="#rfc.figure.79"></div>
<pre>
 Intermediary
Client Program                                      Module
     |                                                |
     | A1: start key protocol                         |
     |-----------------------------------------------&gt;|
     |                                                |
     | M1: key protocol start C_PROTOCOL_SEND_OKAY    |
     |&lt;===============================================|
     |                                                |
     | A2: send protocol message                      |
     |-----------------------------------------------&gt;|
     |                                                |
     | M2: message C_PROTOCOL_SEND_OKAY, more pending |
     |&lt;===============================================|
     |                                                |
    ...             (protocol continues)             ...
     |                                                |
     | An: send protocol message                      |
     |-----------------------------------------------&gt;|
     | Mn: message C_PROTOCOL_SEND_OKAY, protocol done|
     |&lt;===============================================|
     |                                                |</pre>
<p>Figure 1. Generic Scenario for Key Protocol Session Initiated by a Key Infrastructure Component</p>
<p id="rfc.section.6.3.p.2">The notional key infrastructure-initiated message exchanges are as follows: </p>

<ul>
<li>Event "A1": Start key protocol - The client program receives the first protocol message from a key infrastructure component and sends it to the module using KeyProtocolSender::put_into_module. The returned condition indicates that the protocol session is C_PROTOCOL_SEND_OKAY.</li>
<li>Event "M1": Successful start to key protocol - The client program requests the module's response using KeyProtocolReceiver::get_from_module. This response is the module's first message in this exchange and includes the current status of the session. Multiple queries could respond with a BUSY condition before a C_PROTOCOL_SEND_OKAY condition is finally returned. The C_PROTOCOL_SEND_OKAY condition indicates that the session is in progress and a response message has been returned.  The client program is responsible for forwarding the resulting response message to another active protocol participant.</li>
<li>Event "A2": Send protocol message - The client program forwards the next message in the protocol sequence received from the infrastructure component to the module using the KeyProtocolSender::put_into_module method. The returned condition indicates that the protocol session is C_PROTOCOL_SEND_OKAY.</li>
<li>Event "M2": Message C_PROTOCOL_SEND_OKAY, more pending - The module provides another message in this exchange using KeyProtocolReceiver::get_from_module. The returned condition indicates that the protocol session is C_PROTOCOL_SEND_OKAY and a responding message has been returned.</li>
<li>Event "An": Send protocol message - The client program forwards what is ultimately the last message in the protocol sequence to the module using KeyProtocolSender::put_into_module.</li>
<li>Event "Mn": Message C_PROTOCOL_SEND_OKAY, protocol done - The module provides the corresponding last message in this exchange when the client program queries the module using KeyProtocolReceiver::get_from_module. The returned condition indicates that the protocol session is DONE and the last responding message in this protocol session has been returned. As shown here, the module determines (or at least reports to the client program) when the protocol session is done. Another active participant could plausibly make this determination.</li>
</ul>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Key Agreement Example Using Diffie-Hellman Protocol</h1>
<p id="rfc.section.6.4.p.1">The following example depicts a notional key infrastructure ("Entity A") initiating an authenticated Diffie-Hellman Discrete Logarithm (DH-DL) key agreement protocol with a cryptographic module ("Entity B"). A host running a client program using CICM for interactions with the module interposes itself between the key infrastructure and the module.</p>
<div id="#rfc.figure.80"></div>
<pre>
  Entity A       Client      Key Protocol  Key Protocol    Entity B
 (g,p,certA)     Program        Sender       Receiver     (g,p,certB)
     |              |              |             |            |
 generates a        |              |             |            |
     |              |              |             |            |
 calculates         |              |             |            |
A = g^a mod p       |              |             |            |
     |              |              |             |            |
     |[g,p,a,certA] |              |             |            |
     |-------------&gt;|              |             |            |
     |        put_into_module([g,p,a,certA])     |            |
     |              |-------------&gt;|      [g,p,a,certA]       |
     |              |              |-------------------------&gt;|
     |              |              |            ok            |
     |              |              |&lt;=========================|
     |           C_PROTOCOL_SEND_OKAY            |            |
     |              |&lt;=============|             |            |
     |              |     get_from_module()      |            |
     |              |---------------------------&gt;|            |
     |              |              |             |-----------&gt;|
     |              |              |             |            |
     |              |              |             |       generates b
     |              |              |             |            |
     |              |              |             |       calculates
     |              |              |             |      B = g^b mod p
     |              |              |             |            |
     |              |              |             |  [B,certB] |
     |              |         [B,certB]          |&lt;===========|
     |   [B,certB]  |&lt;===========================|            |
     |&lt;=============|              |             |            |
     |              |              |             |            |
 calculates         |              |             |       calculates
K = B^a mod p       |              |             |      K = A^b mod p
     |              |              |             |            |</pre>
<p>Figure 2. Example of a Two-key Diffie-Hellman Discrete Logarithm (DH-DL) Key Agreement Protocol Initiated by a Key Infrastructure</p>
<p id="rfc.section.6.4.p.2">The following are the steps required to use CICM in the protocol example between a notional key infrastructure ("Entity A") and a cryptographic module ("Entity B"): </p>

<ol>
<li>The following are prepositioned at both communicating elements: <ul>
<li>Domain parameters g and p.</li>
<li>Digital certificate.</li>
<li>Signature verification key required to validate the certificate of the other entity.</li>
</ul>
</li>
<li>"Entity A" generates random value a.</li>
<li>"Entity A" calculates A=g^a mod p.</li>
<li>"Entity A" signs the value A calculated above using its static private key whose corresponding static public key is contained in its certificate.</li>
<li>"Entity A" sends the signed value A and cert-A to the client program on the intermediary host as an opaque binary buffer.</li>
<li>The client program on the intermediary host calls KeyProtocolSender::put_into_module to send the opaque binary buffer received by the client program to the module; if a CICM::KeyProtocolSender::C_PROTOCOL_SEND_DISPLAY condition is returned from this call, the following steps SHOULD be performed (the steps do not appear in the diagram): <ol style="list-style-type: lower-alpha">
<li>"Entity A" calls CICM::Negotiator::get_remote_info to retrieve information about the remote peer; this information (including name/organization and classification level) are extracted from cert-B and returned in CICM::PeerInfo.</li>
<li>The client program on the intermediary host displays the identifying information returned above in CICM::PeerInfo to a human user and asks for positive acknowledgement that the entity initiating the protocol is in fact a legal entity to initiate the protocol.</li>
<li>If the human user does not recognize the remote entity and declines to give positive acknowledgement, the client program abandons the protocol. In this example, positive acknowledgement is given, and the client program calls CICM::KeyProtocolReceiver::get_from_module to request a protocol response.</li>
</ol>
</li>
<li>"Entity B" generates random value b.</li>
<li>"Entity B" calculates B=g^b mod p, using parameters g and p that it previously agreed it would use when initiating a protocol exchange with "Entity A."</li>
<li>"Entity B" signs the value B calculated above using its static private key whose corresponding static public key is contained in its certificate.</li>
<li>"Entity B" returns an opaque binary buffer containing its signed value B and cert-B to the caller of KeyProtocolReceiver::get_from_module with a condition of DONE.</li>
<li>The client program on the intermediary host sends the opaque binary buffer to "Entity A".</li>
<li>Both entities verify their peer's certificate is valid.</li>
<li>"Entity A" calculates K=B^a mod p.</li>
<li>"Entity B" calculates K=A^b mod p.</li>
<li>Both entities now share a symmetric key K.</li>
</ol>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> Protocol Support Examples</h1>
<p id="rfc.section.6.5.p.1">As previously stated, these methods support a wide range of key management protocols. The following is a notional list of such protocols with a description of their intended usage: </p>

<ul>
<li>Key agreement/distribution protocols - Key material can be distributed and keys can be agreed upon using the DH-DL, EC-DH, EC-MQV, or related protocols.</li>
<li>Remote key functions - Messages containing key-related commands (i.e., zeroize, rekey) requiring authentication by the module prior to execution may be presented using these functions.</li>
<li>Trust anchor management protocols - Trust anchor management commands and data may be sent as opaque data elements which are interpreted by the module in a protocol-specific manner.</li>
<li>Key revocation messages - Opaque data elements identifying certificates associated with keys which have been revoked or accepted. The ability to handle a list of revoked keys allows a module to prevent further usage of these keys, including performing key agreement with an entity that is known to have been compromised or no longer possesses the roles or affiliations described in the certificate.</li>
</ul>
<h1 id="rfc.section.6.6">
<a href="#rfc.section.6.6">6.6.</a> Interface CICM::KeyProtocolSender</h1>
<div id="#rfc.figure.81"></div>
<p>Interface CICM::KeyProtocolSender</p>
<pre>interface KeyProtocolSender : CICM::Negotiator {</pre>
<p>CICM::KeyProtocolSender supports sending key management protocol-related messages into a module.</p>
<h1 id="rfc.section.6.6.1">
<a href="#rfc.section.6.6.1">6.6.1.</a> CICM::KeyProtocolSender Inheritance</h1>
<p id="rfc.section.6.6.1.p.1">CICM::KeyProtocolSender inherits from: CICM::Negotiator.</p>
<h1 id="rfc.section.6.6.2">
<a href="#rfc.section.6.6.2">6.6.2.</a> CICM::KeyProtocolSender Types and Constants</h1>
<div id="#rfc.figure.82"></div>
<p>Type CICM::KeyProtocolSender::Condition</p>
<pre>typedef CICM::UInt32 Condition;</pre>
<p>Condition values summarize for the client program the state of the session. This information can be used along with other information to suggest what the client program should do next as part of the current protocol session.</p>
<div id="#rfc.figure.83"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_OKAY</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_OKAY = 0x00006045;</pre>
<p>Denotes that the session is in progress and a response message is available.</p>
<div id="#rfc.figure.84"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_DONE</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_DONE = 0x00006046;</pre>
<p>Denotes that the session terminated successfully.</p>
<div id="#rfc.figure.85"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_ERROR</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_ERROR = 0x00006049;</pre>
<p>Denotes that the session terminated with an error condition.</p>
<div id="#rfc.figure.86"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_DISPLAY</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_DISPLAY = 0x0000604A;</pre>
<p>As with the C_PROTOCOL_SEND_OKAY condition, denotes that the session is in progress and a response message is available, but additionally denotes that identification information extracted from the remote certificate is available via a call to the CICM::Negotiator::get_remote_info method; the information retrieved from a call to this method must be displayed to a human user on the host and validated before the protocol should be allowed to continue. Note that a trusted display may be employed by the module for the same purpose but, because no API interaction would be involved, the C_PROTOCOL_SEND_DISPLAY condition would not be returned.</p>
<div id="#rfc.figure.87"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_ABORTED</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_ABORTED = 0x0000604C;</pre>
<p>Denotes that the human user reviewing the remote peer information chose to reject it and abort the protocol.</p>
<div id="#rfc.figure.88"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_MESSAGE_INVALID</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_MESSAGE_INVALID = 0x0000604F;</pre>
<p>Denotes that the conveyed message was found to be invalid for the protocol. This event does not terminate the protocol session.</p>
<div id="#rfc.figure.89"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_MESSAGE_INTEGRITY</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_MESSAGE_INTEGRITY = 0x00006051;</pre>
<p>Denotes that the conveyed message failed one or more integrity checks used in the protocol. This event does not terminate the protocol session.</p>
<div id="#rfc.figure.90"></div>
<p>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_PROTOCOL_VIOLATION</p>
<pre>const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_PROTOCOL_VIOLATION = 0x00006052;</pre>
<p>Denotes that a message or attempted action unexpected at the current point in the protocol session was noted. This event does not terminate the protocol session.</p>
<h1 id="rfc.section.6.6.3">
<a href="#rfc.section.6.6.3">6.6.3.</a> CICM::KeyProtocolSender Methods</h1>
<div id="#rfc.figure.91"></div>
<p>Method CICM::KeyProtocolSender::put_into_module()</p>
<pre>CICM::Status put_into_module(
	in  CICM::ProtocolId protocol,
	in  CICM::Buffer message,
	out CICM::KeyProtocolSender::Condition condition
);</pre>
<p>Initiate or recommence a key management protocol session, forwarding a message to the cryptographic module. If the C_PROTOCOL_SEND_DISPLAY condition results, the get_remote_info method should be called to retrieve identity information about the remote peer for display to and validation by the responsible user before the protocol negotiation is allowed to continue.</p>
<p id="rfc.section.6.6.3.p.1">Remarks: </p>

<ul class="empty"><li>The format of the conveyed message is not defined by CICM.  If the client program must be capable of generating the message, then the Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li></ul>

<p> </p>
<p id="rfc.section.6.6.3.p.2">Parameters: </p>

<ul class="empty">
<li>[in] protocol Designate the protocol to be followed for this session; the same value must be used for this parameter for all calls to this method or to get_from_module, as part of the same protocol session.</li>
<li>[in] message Message conveyed to the module as part of the current protocol session.</li>
<li>[out] condition Condition of the current protocol session; the calling client program must interpret this value to determine what its next action must be.</li>
</ul>

<p> </p>
<p id="rfc.section.6.6.3.p.3">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</li></ul>

<p> </p>
<p id="rfc.section.6.6.3.p.4">See also: </p>

<ul class="empty"><li>CICM::KeyProtocolSender::put_into_module_algo for the version of this method that accepts an algorithm.</li></ul>

<p> </p>
<div id="#rfc.figure.92"></div>
<p>Method CICM::KeyProtocolSender::put_into_module_algo()</p>
<pre>CICM::Status put_into_module_algo(
	in  CICM::ProtocolId protocol,
	in  CICM::Buffer message,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::KeyProtocolSender::Condition condition
);</pre>
<p>Initiate or recommence a key management protocol session, forwarding a message to the cryptographic module. If the C_PROTOCOL_SEND_DISPLAY condition results, the get_remote_info method should be called to retrieve identity information about the remote peer for display to and validation by the responsible user before the protocol negotiation is allowed to continue. This method differs from KeyProtocolSender::put_into_module in that it enables the caller to specify the desired algorithm of the resulting symmetric key.</p>
<p id="rfc.section.6.6.3.p.5">Remarks: </p>

<ul class="empty"><li>The format of the conveyed message is not defined by CICM.  If the client program must be capable of generating the message, then the Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li></ul>

<p> </p>
<p id="rfc.section.6.6.3.p.6">Parameters: </p>

<ul class="empty">
<li>[in] protocol Designate the protocol to be followed for this session; the same value must be used for this parameter for all calls to this method or to get_from_module, as part of the same protocol session.</li>
<li>[in] message Message conveyed to the module as part of the current protocol session.</li>
<li>[in] algorithm Algorithm/mode of resulting symmetric key.</li>
<li>[out] condition Condition of the current protocol session; the calling client program must interpret this value to determine what its next action must be.</li>
</ul>

<p> </p>
<p id="rfc.section.6.6.3.p.7">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</li></ul>

<p> </p>
<p id="rfc.section.6.6.3.p.8">See also: </p>

<ul class="empty"><li>CICM::KeyProtocolSender::put_into_module for the version of this method that does not require an algorithm.</li></ul>

<p> </p>
<h1 id="rfc.section.6.7">
<a href="#rfc.section.6.7">6.7.</a> Interface CICM::KeyProtocolReceiver</h1>
<div id="#rfc.figure.93"></div>
<p>Interface CICM::KeyProtocolReceiver</p>
<pre>interface KeyProtocolReceiver {</pre>
<p>CICM::KeyProtocolReceiver supports receiving key management protocol-related messages from a module. CICM::KeyProtocolReceiver constructs the CICM::SymKey interface.</p>
<h1 id="rfc.section.6.7.1">
<a href="#rfc.section.6.7.1">6.7.1.</a> CICM::KeyProtocolReceiver Types and Constants</h1>
<div id="#rfc.figure.94"></div>
<p>Type CICM::KeyProtocolReceiver::Condition</p>
<pre>typedef CICM::UInt32 Condition;</pre>
<p>Condition values summarize for the client program the state of the session. This information can be used along with other information to suggest what the client program should do next as part of the current protocol session.</p>
<div id="#rfc.figure.95"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_OKAY</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_OKAY = 0x00006034;</pre>
<p>Denotes that the session is in progress and a response message has been returned.</p>
<div id="#rfc.figure.96"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_DONE</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_DONE = 0x00006037;</pre>
<p>Denotes that the session terminated successfully.</p>
<div id="#rfc.figure.97"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_BUSY</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_BUSY = 0x00006038;</pre>
<p>Denotes that the session is in progress but no response message or error indication is available at the current time; in this case, the client program must make additional calls to CICM::KeyProtocolReceiver::get_from_module to determine when the response message has become available and retrieve the message.</p>
<div id="#rfc.figure.98"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_ERROR</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_ERROR = 0x0000603B;</pre>
<p>Denotes that the session terminated with an error condition and a response message has been returned.</p>
<div id="#rfc.figure.99"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_ABORTED</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_ABORTED = 0x0000603D;</pre>
<p>Denotes that the human user reviewing the remote peer information chose to reject it and abort the protocol.</p>
<div id="#rfc.figure.100"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_MESSAGE_INVALID</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_MESSAGE_INVALID = 0x0000603E;</pre>
<p>Denotes that the conveyed message was found to be invalid for the protocol. This event does not terminate the protocol session.</p>
<div id="#rfc.figure.101"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY = 0x00006040;</pre>
<p>Denotes that the conveyed message failed one or more integrity checks used in the protocol. This event does not terminate the protocol session.</p>
<div id="#rfc.figure.102"></div>
<p>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_VIOLATION</p>
<pre>const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_VIOLATION = 0x00006043;</pre>
<p>Denotes that a message or attempted action unexpected at the current point in the protocol session was noted. This event does not terminate the protocol session.</p>
<h1 id="rfc.section.6.7.2">
<a href="#rfc.section.6.7.2">6.7.2.</a> CICM::KeyProtocolReceiver Methods</h1>
<div id="#rfc.figure.103"></div>
<p>Method CICM::KeyProtocolReceiver::abort()</p>
<pre>CICM::Status abort();</pre>
<p>Abort negotiation.</p>
<p id="rfc.section.6.7.2.p.1">Remarks: </p>

<ul class="empty"><li>This method may be called at any point in the negotiation process for any reason. However, it must be called in the event the identification information for the remote peer does not correspond to the expected peer.</li></ul>

<p> </p>
<p id="rfc.section.6.7.2.p.2">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_NOT_IN_PROGRESS</li></ul>

<p> </p>
<div id="#rfc.figure.104"></div>
<p>Method CICM::KeyProtocolReceiver::get_from_module()</p>
<pre>CICM::Status get_from_module(
	in  CICM::ProtocolId protocol,
	out CICM::Buffer message,
	out CICM::KeyProtocolReceiver::Condition condition
);</pre>
<p>Initiate or recommence a key management protocol session, soliciting a response from the cryptographic module.</p>
<p id="rfc.section.6.7.2.p.3">Remarks: </p>

<ul class="empty"><li>The format of the conveyed message is not defined by CICM.  If the client program must be capable of interpreting the contents of the message, then the Implementation Conformance Statement (see Conformance and Extensions in <a href="#CICM">[CICM]</a>) MUST reference a standard format or define a module developer-specific format implemented by the module for this datatype.</li></ul>

<p> </p>
<p id="rfc.section.6.7.2.p.4">Parameters: </p>

<ul class="empty">
<li>[in] protocol Designate the protocol to be followed for this session; the same value must be used for this parameter for all calls to this method or to CICM::KeyProtocolSender::put_into_module, as part of the same protocol session.</li>
<li>[out] message Message returned from the module as part of the current protocol session; message may be of length zero.</li>
<li>[out] condition Condition of the current protocol session; the calling client program must interpret this value to determine what its next action must be.</li>
</ul>

<p> </p>
<p id="rfc.section.6.7.2.p.5">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</li></ul>

<p> </p>
<div id="#rfc.figure.105"></div>
<p>Method CICM::KeyProtocolReceiver::get_key()</p>
<pre>CICM::Status get_key(
	out CICM::SymKey key_ref
);</pre>
<p>At successful conclusion of a key agreement/distribution protocol session (when the returned condition is C_PROTOCOL_RECEIVE_DONE), this method is called to retrieve a reference to the key resulting from the session.</p>
<p id="rfc.section.6.7.2.p.6">Remarks: </p>

<ul class="empty"><li>Note that, in those cases where the protocol session does not result in a key (e.g., a key revocation message, key white list or black list is presented to the module via this interface), calling this method will result in an CICM::S_INVALID_STATE error.</li></ul>

<p> </p>
<p id="rfc.section.6.7.2.p.7">Parameters: </p>

<ul class="empty"><li>[out] key_ref Reference to key resulting from a successful protocol session.</li></ul>

<p> </p>
<p id="rfc.section.6.7.2.p.8">Returns: </p>

<ul class="empty"><li>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_NOT_IN_PROGRESS</li></ul>

<p> </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> IANA Considerations</h1>
<p id="rfc.section.7.p.1">[RFC Editor: Please remove this section prior to publication.]</p>
<p id="rfc.section.7.p.2">This document has no IANA actions.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Security Considerations</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Authorization</h1>
<p id="rfc.section.8.1.p.1">The use of cryptographic key material is often limited to a set of authorized users. Authorization may be revoked by administrative means not defined by CICM or, in the extreme case, by zeroizing the key.</p>
<p id="rfc.section.8.1.p.2">The Key Protocol capabilities can also be used to manage key white lists and black lists which may limit authorized access to cryptographic material.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Authentication</h1>
<p id="rfc.section.8.2.p.1">The operations defined in this document require properly authorized and authenticated users in order to create, manage, import, export, or manipulate cryptographic key material.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> Entity Authentication</h1>
<p id="rfc.section.8.3.p.1">When using the Key Protocol mechanism, the module will typically authenticate that the party with which it is communicating is the party which is intended.  When the module receives the certificate of the communicating party, this information is extracted and provided in a CICM::PeerInfo object which must be positively identified before the protocol continues forward.</p>
<p id="rfc.section.8.3.p.2">Key Protocol also provides the capability to store revocation lists which may prevent the module from performing key agreement with an entity that is known to have to have been compromised or no longer possesses the roles or affiliations described in the certificate.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> Confidentiality</h1>
<p id="rfc.section.8.4.p.1">A common use of cryptographic key material is to provide confidentiality between two communicating entities. See <a href="#CICM-CM">[CICM-CM]</a> for the details of different confidential communications channels.</p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> Data Integrity</h1>
<p id="rfc.section.8.5.p.1">Asymmetric keys are often used to provide data integrity capabilities.  See <a href="#CICM-CM">[CICM-CM]</a> for channels that provide data integrity.</p>
<h1 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> Inappropriate Usage</h1>
<p id="rfc.section.8.6.p.1">CICM defines a set of error codes (S_KEY_USED_INVALID, S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION) to mitigate against the inappropriate key usage.</p>
<p id="rfc.section.8.6.p.2">Additionally, CICM provides the Key::state and Key::classification attributes as well as the SymKey::validate_key_usage() and AsymKey::validate_key_usage() methods to provide information about the appropriate uses for each key.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="CICM">[CICM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-KM">[CICM-KM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Key Management [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-CM">[CICM-CM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Channel Management [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="IDL">[IDL]</b></td>
<td class="top">
<a>International Standards Organization</a>, "<a>Information technology &#8212; Open Distributed Processing &#8212; Interface Definition Language</a>", ISO/IEC 14750:1999(E), March 1999.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3552">[RFC3552]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="CICM-LM">[CICM-LM]</b></td>
<td class="top">
<a>Lanz, D.</a> and <a>L. Novikov</a>, "<a>Common Interface to Cryptographic Modules (CICM) Logical Model [RFC Editor: Please update the RFC reference and date prior to publication.]</a>", January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="CORBA">[CORBA]</b></td>
<td class="top">
<a>Object Management Group</a>, "<a>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</a>", January 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#idl-code" id="idl-code">IDL Definitions</a>
</h1>
<div id="#rfc.figure.106"></div>
<pre>module CICM {
  typedef CICM::CharString KeyId;

  interface Key {
    typedef CICM::UInt32 State;
    const CICM::Key::State C_KEY_INVALID = 0x00006010;
    const CICM::Key::State C_KEY_VALID_WRAPPED = 0x00006013;
    const CICM::Key::State C_KEY_VALID_UNWRAPPED = 0x00006015;

    typedef CICM::UInt32 UsageStatus;
    const CICM::Key::UsageStatus C_KEY_USAGE_ALLOWED = 0x00006016;
    const CICM::Key::UsageStatus C_KEY_USAGE_FORBIDDEN = 0x00006019;

    attribute CICM::CharString identifier;
    attribute CICM::UInt32 location;
    attribute CICM::CharString alias;
    attribute CICM::Classification classification;
    attribute CICM::CharString caveat;
    attribute CICM::CharString authority;
    readonly attribute CICM::Key::State state;

    CICM::Status wrap(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm );

    CICM::Status unwrap(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm );

    CICM::Status export(
      out CICM::Buffer key_material );

    CICM::Status export_via_fill_interface(
      in  CICM::LocalPort fill_port );

    CICM::Status zeroize();
  };

  interface SymKey : CICM::Key {
    typedef CICM::UInt32 Usage;
    const CICM::SymKey::Usage
      C_USAGE_GENERATE_KEYSTREAM = 0x0000601A;

    const CICM::SymKey::Usage
      C_USAGE_KEY_PRODUCTION_KEY = 0x0000601C;

    const CICM::SymKey::Usage
      C_USAGE_MESSAGE_AUTHENTICATION_CODE = 0x0000601F;

    const CICM::SymKey::Usage
      C_USAGE_SYM_DATA_ENCIPHERMENT = 0x00006020;

    const CICM::SymKey::Usage
      C_USAGE_SYM_KEY_ENCIPHERMENT = 0x00006023;

    readonly attribute CICM::UInt32 update_count;

    CICM::Status update();

    CICM::Status update_with_algo(
      in  CICM::SymEncrAlgorithmId algorithm );

    CICM::Status wrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::SymKey wrapped_key );

    CICM::Status unwrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::SymKey unwrapped_key );

    CICM::Status validate_key_usage(
      in  CICM::SymKey::Usage usage_type,
      out CICM::Key::UsageStatus valid );
  };

  interface AsymKey : CICM::Key {
    typedef CICM::UInt32 Usage;
    const CICM::AsymKey::Usage
      C_USAGE_ASYM_DATA_ENCIPHERMENT = 0x00006001;

    const CICM::AsymKey::Usage
      C_USAGE_ASYM_KEY_ENCIPHERMENT = 0x00006002;

    const CICM::AsymKey::Usage
      C_USAGE_CERT_SIGN = 0x00006004;

    const CICM::AsymKey::Usage
      C_USAGE_CRL_SIGN = 0x00006007;

    const CICM::AsymKey::Usage
      C_USAGE_DIGITAL_SIGNATURE = 0x00006008;

    const CICM::AsymKey::Usage
      C_USAGE_INFRA_KEY_AGREEMENT = 0x0000600B;

    const CICM::AsymKey::Usage
      C_USAGE_P2P_KEY_AGREEMENT = 0x0000600D;

    const CICM::AsymKey::Usage
      C_USAGE_SEED = 0x0000600E;

    CICM::Status wrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::AsymKey wrapped_key );

    CICM::Status unwrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::AsymKey unwrapped_key );

    CICM::Status validate_key_usage(
      in  CICM::AsymKey::Usage usage_type,
      out CICM::Key::UsageStatus valid );
  };

  interface SymKeyIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::SymKey sym_key_ref );
  };

  interface AsymKeyIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::AsymKey asym_key_ref );
  };

  interface KeyProtocolSender : CICM::Negotiator {
    typedef CICM::UInt32 Condition;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_OKAY = 0x00006045;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_DONE = 0x00006046;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_ERROR = 0x00006049;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_DISPLAY = 0x0000604A;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_ABORTED = 0x0000604C;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_MESSAGE_INVALID = 0x0000604F;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_MESSAGE_INTEGRITY = 0x00006051;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_PROTOCOL_VIOLATION = 0x00006052;

    CICM::Status put_into_module(
      in  CICM::ProtocolId protocol,
      in  CICM::Buffer message,
      out CICM::KeyProtocolSender::Condition condition );

    CICM::Status put_into_module_algo(
      in  CICM::ProtocolId protocol,
      in  CICM::Buffer message,
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::KeyProtocolSender::Condition condition );
  };

  interface KeyProtocolReceiver {
    typedef CICM::UInt32 Condition;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_OKAY = 0x00006034;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_DONE = 0x00006037;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_BUSY = 0x00006038;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_ERROR = 0x0000603B;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_ABORTED = 0x0000603D;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_MESSAGE_INVALID = 0x0000603E;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY = 0x00006040;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_VIOLATION = 0x00006043;

    CICM::Status abort();

    CICM::Status get_from_module(
      in  CICM::ProtocolId protocol,
      out CICM::Buffer message,
      out CICM::KeyProtocolReceiver::Condition condition );

    CICM::Status get_key(
      out CICM::SymKey key_ref );
  };

  interface SymKeyManager {
    readonly attribute CICM::SymKeyIterator symkey_iterator;
    readonly attribute CICM::KeyProtocolSender key_protocol_sender;
    readonly attribute CICM::KeyProtocolReceiver key_protocol_receiver;

    CICM::Status get_key_by_id(
      in  CICM::KeyId key_id,
      out CICM::SymKey key_ref );

    CICM::Status get_key_by_phys_location(
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status get_key_last_filled(
      out CICM::SymKey key_ref );

    CICM::Status import_key(
      in  CICM::Buffer key_material,
      out CICM::SymKey key_ref );

    CICM::Status import_key_into_phys_location(
      in  CICM::Buffer key_material,
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status import_key_via_fill(
      in  CICM::LocalPort fill_port,
      out CICM::SymKey key_ref );

    CICM::Status import_key_via_fill_into_phys_location(
      in  CICM::LocalPort fill_port,
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status generate_key(
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::SymKey key_ref );

    CICM::Status derive_key(
      in  CICM::CharString password,
      in  CICM::Buffer salt,
      in  CICM::UInt32 iteration_count,
      in  CICM::HashAlgorithmId hash_algorithm,
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::SymKey key_ref );

    CICM::Status derive_deterministic_key(
      in  CICM::SymKey key_prod_key,
      in  CICM::CharString shared_secret,
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::SymKey key_ref );
  };

  interface AsymKeyManager {
    readonly attribute CICM::AsymKeyIterator asymkey_iterator;

    CICM::Status get_key_by_id(
      in  CICM::KeyId key_id,
      out CICM::AsymKey key_ref );

    CICM::Status get_key_by_phys_location(
      in  CICM::UInt32 phys_location,
      out CICM::AsymKey key_ref );

    CICM::Status get_key_last_filled(
      out CICM::AsymKey key_ref );

    CICM::Status import_key(
      in  CICM::Buffer key_material,
      out CICM::AsymKey key_ref );

    CICM::Status import_key_into_phys_location(
      in  CICM::Buffer key_material,
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status import_key_via_fill(
      in  CICM::LocalPort fill_port,
      out CICM::AsymKey key_ref );

    CICM::Status import_key_via_fill_into_phys_location(
      in  CICM::LocalPort fill_port,
      in  CICM::UInt32 phys_location,
      out CICM::AsymKey key_ref );

    CICM::Status generate_key_pair(
      in  CICM::AsymEncrAlgorithmId algorithm,
      out CICM::AsymKey key_ref );
  };

  interface KeyDatabase {
    CICM::Status zeroize();
    CICM::Status reencrypt();
  };
};</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Daniel J. Lanz</span> 
	  <span class="n hidden">
		<span class="family-name">Lanz</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Lev Novikov</span> 
	  <span class="n hidden">
		<span class="family-name">Novikov</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></span>

  </address>
</div>

</body>
</html>