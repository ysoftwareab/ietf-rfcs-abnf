<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Design Choices When
    Expanding DNS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Design Choices When
    Expanding DNS">
<meta name="keywords" content="DNS, Info, RFC, I-D, Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">IAB</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">P. Faltstrom, Ed.</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">R. Austein, Ed.</td></tr>
<tr><td class="header">Expires: February 12, 2009</td><td class="header">P. Koch, Ed.</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">August 11, 2008</td></tr>
</table></td></tr></table>
<h1><br />Design Choices When
    Expanding DNS<br />draft-iab-dns-choices-07</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on February 12, 2009.</p>

<h3>Abstract</h3>

<p>This note discusses how to extend the DNS with new data for a new
      application. DNS extension discussions too often focus on reuse of the
      TXT Resource Record Type. This document lists different mechanisms to
      extend the DNS, and concludes that the use of a new DNS Resource Record
      Type is the best solution.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">2.</a>&nbsp;
Background<br />
<a href="#anchor2">3.</a>&nbsp;
Extension mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#add_subtype">3.1.</a>&nbsp;
Place selectors inside the RDATA of existing Resource Record Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#add_prefix">3.2.</a>&nbsp;
Add a prefix to the owner name<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#add_suffix">3.3.</a>&nbsp;
Add a suffix to the owner name<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#add_class">3.4.</a>&nbsp;
Add a new Class<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#add_type">3.5.</a>&nbsp;
Add a new Resource Record Type<br />
<a href="#anchor3">4.</a>&nbsp;
Zone boundaries are invisible to applications<br />
<a href="#txt_evil">5.</a>&nbsp;
Why adding a new Resource Record Type is the preferred solution<br />
<a href="#anchor4">6.</a>&nbsp;
Conclusion and Recommendation<br />
<a href="#anchor5">7.</a>&nbsp;
Creating A New Resource Record Type<br />
<a href="#anchor6">8.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor7">9.</a>&nbsp;
Security Considerations<br />
<a href="#anchor8">10.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">11.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">11.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">11.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The DNS stores multiple categories of data. The two most commonly
      used categories are infrastructure data for the DNS system itself (NS
      and SOA Resource Records) and data which have to do with mappings
      between domain names and IP addresses (A, AAAA and PTR Resource
      Records). There are other categories as well, some of which are tied to
      specific applications like email (MX Resource Records), while others are
      generic Resource Record Types used to convey information for multiple
      protocols (SRV and NAPTR Resource Records).
</p>
<p>When storing data in the DNS for a new application, the goal must be
      to store data in such a way that the application can query for the data
      it wants, while minimizing both the impact on existing applications and
      the amount of extra data transfered to the client. This implies that a
      number of design choices have to be made, where the most important is to
      ensure that a precise selection of what data to return must be made
      already in the query. A query consists of the triple {Owner, Resource
      Record Type, Resource Record Class}.
</p>
<p>Historically, extending DNS to store application data tied to a
      domain name has been done in different ways at different times. MX
      Resource Records were created as a new Resource Record Type specifically
      designed to support electronic mail. SRV records are a generic type
      which use a prefixing scheme in combination with a base domain name.
      NAPTR records add selection data inside the RDATA. It is clear that the
      methods used to add new data types to the DNS have been inconsistent,
      and the purpose of this document is to attempt to clarify the
      implications of each of these methods, both for the applications that
      use them and for the rest of the DNS.
</p>
<p>This document talks extensively about use of DNS wildcards. Many
      people might think use of wildcards is not something that happens today.
      In reality though, wildcards are in use, especially for certain
      application-specific data such as MX Resource Records. Because of this,
      the choice has to be made with existence of wildcards in mind.
</p>
<p>Another overall issue that must be taken into account is what the new
      data in the DNS are to describe. In some cases they might be completely
      new data. In other cases they might be metadata tied to data that
      already exist in the DNS. An example of new data is key information for
      SSH and data used for authenticating sender of email messages (metadata
      tied to MX Resource Records). If the new data are tied to data that
      already exist in the DNS, an analysis should be made as to whether
      having (for example) address records and SSH key information in
      different DNS zones is a problem or if it is a bonus, and if it is a
      problem, whether the specification must require all of the related data
      to be in the same zone. One specific difference between having the
      records in the same zone or not has to do with maintenance of the
      records. If they are in the same zone, the same maintainer (from a DNS
      perspective) manages the two records. Specifically, they must be signed
      with the same DNSSEC keys if DNSSEC is in use.
</p>
<p>This document does not talk about what one should store in the DNS.
      It also doesn't discuss whether DNS should be used for service
      discovery, or whether DNS should be used for storage of data specific to
      the service. In general, DNS is a protocol that, apart from holding
      metadata that makes the DNS itself function (NS, SOA, DNSSEC Resource
      Record Types, etc), only holds references to service locations (SRV,
      NAPTR, A, AAAA Resource Record Types) -- though there are exceptions,
      such as MX Resource Records.
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Background</h3>

<p>See <a class='info' href='#RFC2929'>RFC 2929<span> (</span><span class='info'>Eastlake, D., Brunner-Williams, E., and B. Manning, &ldquo;Domain Name System (DNS) IANA Considerations,&rdquo; September&nbsp;2000.</span><span>)</span></a> [RFC2929] for a brief summary of DNS
      query structure. Readers interested in the full story should start with
      the base DNS specification in <a class='info' href='#RFC1035'>RFC 1035<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names           - implementation and specification,&rdquo; November&nbsp;1987.</span><span>)</span></a> [RFC1035],
      and continue with the various documents that update, clarify, and extend
      the base specification.
</p>
<p>When composing a DNS query, the parameters used by the protocol are a
      triple: a DNS name, a DNS class, and a DNS Resource Record Type. Every
      Resource Record matching a particular name, class and type is said to
      belong to the same Resource Record Set (RRSet), and the whole RRSet is
      always returned to the client that queries for it. Splitting an RRSet is
      a protocol violation (sending a partial RRSet, not truncating the DNS
      response), because it can result in coherency problems with the DNS
      caching mechanism. See <a class='info' href='#RFC2181'>RFC 2181 section 5<span> (</span><span class='info'>Elz, R. and R. Bush, &ldquo;Clarifications to the DNS           Specification,&rdquo; July&nbsp;1997.</span><span>)</span></a> [RFC2181]
      for more information.
</p>
<p>Some discussions around extensions to the DNS include arguments
      around MTU size. Note that most discussions about DNS and MTU size are
      about the size of the whole DNS packet, not about the size of a single
      RRSet.
</p>
<p>Almost all DNS query traffic is carried over UDP, where a DNS message
      must fit within a single UDP packet. DNS response messages are almost
      always larger than DNS query messages, so message size issues are almost
      always about responses, not queries. The base DNS specification limits
      DNS messages over UDP to 512 octets; EDNS0 <a class='info' href='#RFC2671'>[RFC2671]<span> (</span><span class='info'>Vixie, P., &ldquo;Extension Mechanisms for DNS (EDNS0),&rdquo; August&nbsp;1999.</span><span>)</span></a> specifies a mechanism by which a client can
      signal its willingness to receive larger responses, but deployment of
      EDNS0 is not universal, in part because of firewalls that block
      fragmented UDP packets or EDNS0. If a response message won't fit in a
      single packet, the name server returns a truncated response, at which
      point the client may retry using TCP. DNS queries over TCP are not
      subject to this length limitation, but TCP imposes significantly higher
      per-query overhead on name servers than UDP. It is also the case that
      the policies in deployed firewalls far too often are such that it blocks
      DNS over TCP, so using TCP might not in reality be an option. There are
      also risks (although possibly small) that a change of routing while a
      TCP flow is open creates problems when the DNS servers are deployed in
      an anycast environment.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Extension mechanisms</h3>

<p>The DNS protocol is intended to be extensible to support new kinds of
      data. This section examines the various ways in which this sort of
      extension can be accomplished.
</p>
<a name="add_subtype"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Place selectors inside the RDATA of existing Resource Record Types</h3>

<p>For a given query name, one might choose to have a single RRSet
        (all Resource Records sharing the same name, class and type) shared by
        multiple applications, and have the different applications use
        selectors within the Resource Record data (RDATA) to determine which
        records are intended for which applications. This sort of selector
        mechanism is usually referred to "subtyping", because it is in effect
        creating an additional type subsystem within a single DNS Resource
        Record Type.
</p>
<p>Examples of subtyping include NAPTR Resource Records <a class='info' href='#RFC3761'>[RFC3761]<span> (</span><span class='info'>Faltstrom, P. and M. Mealling, &ldquo;The E.164 to Uniform Resource Identifiers (URI) Dynamic           Delegation Discovery System (DDDS) Application (ENUM),&rdquo; April&nbsp;2004.</span><span>)</span></a> and the original DNSSEC KEY Resource Record
        Type <a class='info' href='#RFC2535'>[RFC2535]<span> (</span><span class='info'>Eastlake, D., &ldquo;Domain Name System Security           Extensions,&rdquo; March&nbsp;1999.</span><span>)</span></a> (which was later updated by <a class='info' href='#RFC3445'>RFC 3445<span> (</span><span class='info'>Massey, D. and S. Rose, &ldquo;Limiting the Scope of the KEY Resource Record (RR),&rdquo; December&nbsp;2002.</span><span>)</span></a> [RFC3445]).
</p>
<p>All DNS subtyping schemes share a common weakness: With subtyping
        schemes it is impossible for a client to query for just the data it
        wants. Instead, the client must fetch the entire RRSet, then select
        the Resource Records in which it is interested. Furthermore, since
        DNSSEC signatures operate on complete RRSets, the entire RRSet must be
        re-signed if any Resource Record in it changes. As a result, each
        application that uses a subtyped Resource Record incurs higher
        overhead than any of the applications would have incurred had they not
        been using a subtyping scheme. The fact the RRSet is always passed
        around as an indivisible unit increases the risk the RRSet will not
        fit in a UDP packet, which in turn increases the risk that the client
        will have to retry the query with TCP, which substantially increases
        the load on the name server. More precisely: having one query fail
        over to TCP is not a big deal, but since the typical ratio of clients
        to servers in today's deployed DNS is very high, having a substantial
        number of DNS messages fail over to TCP may cause the queried name
        servers to be overloaded by TCP overhead.
</p>
<p>Because of the size limitations, using a subtyping scheme to list a
        large number of services for a single domain name risks triggering
        truncation and fallback to TCP, which may in turn force the zone
        administrator to announce only a subset of available services.
</p>
<a name="add_prefix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Add a prefix to the owner name</h3>

<p>By adding an application-specific prefix to a domain name, we get a
        different name/class/type triple, and therefore a different RRSet. One
        problem with adding prefixes has to do with wildcards, especially if
        one has records like
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
*.example.com. IN MX 1 mail.example.com.
</pre></div>
<p>and one wants records tied to those names. Suppose one creates the
        prefix "_mail". One would then have to say something like
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
_mail.*.example.com. IN X-FOO A B C D
</pre></div>
<p>but DNS wildcards only work with the "*" as the leftmost token in
        the domain name (see also <a class='info' href='#RFC4592'>RFC 4592<span> (</span><span class='info'>Lewis, E., &ldquo;The Role of Wildcards in the Domain Name System,&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4592]).
</p>
<p>There have been proposals to deal with the problem that DNS
        wild-cards are always terminal records. These proposals introduce an
        additional set of trade-offs that would need to be taken into account
        when assessing which extension mechanism to choose. Aspects of extra
        response time needed to perform the extra queries, costs of
        pre-calculation of possible answers, or the costs induced to the
        system as a whole come to mind. At the time of writing none of these
        proposals has been published as standards-track RFCs.
</p>
<p>Even when a specific prefix is chosen, the data will still have to
        be stored in some Resource Record Type. This Resource Record Type can
        either be a new Resource Record Type or an existing Resource Record
        Type that has an appropriate format to store the data. One also might
        need some other selection mechanism, such as the ability to
        distinguish between the records in an RRSet given they have the same
        Resource Record Type. Because of this, one needs to both register a
        unique prefix and define what Resource Record Type is to be used for
        this specific service.
</p>
<p>If the record has some relationship with another record in the
        zone, the fact that the two records can be in different zones might
        have implications on the trust the application has in the records. For
        example:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
example.com.      IN MX    10 mail.example.com.
_foo.example.com. IN X-BAR "metadata for the mail service"
</pre></div>
<p>In this example, the two records might be in two different zones,
        and as a result might be administered by two different organisations,
        and signed by two different entities when using DNSSEC. For these two
        reasons, using a prefix has recently become a very interesting
        solution for many protocol designers. In some cases when using TXT
        records (add reference to DKIM), in other cases when adding new
        Resource Record Types (SRV).
</p>
<a name="add_suffix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Add a suffix to the owner name</h3>

<p>Adding a suffix to a domain name changes the name/class/type
        triple, and therefore the RRSet. In this case, since the query name
        can be set to exactly the data one wants the size of the RRSet is
        minimized. The problem with adding a suffix is that it creates a
        parallel tree within the IN class. Further, there is no technical
        mechanism to ensure that the delegation for "example.com" and
        "example.com._bar" are made to the same organization. Furthermore,
        data associated with a single entity will now be stored in two
        different zones, such as "example.com" and "example.com._bar", which,
        depending on who controls "_bar", can create new synchronization and
        update authorization issues.
</p>
<p>One way of solving the administrative issues is by using the DNAME
        Resource Record Type specified in <a class='info' href='#RFC2672'>RFC
        2672<span> (</span><span class='info'>Crawford, M., &ldquo;Non-Terminal DNS Name Redirection,&rdquo; August&nbsp;1999.</span><span>)</span></a> [RFC2672].
</p>
<p>Even when using a different name, the data will still have to be
        stored in some Resource Record Type that has an appropriate format to
        store the data. This implies that one might have to mix the prefix
        based selection mechanism with some other mechanism so that the right
        Resource Record can be found out of many in a potential larger
        RRSet.
</p>
<p>In <a class='info' href='#RFC2163'>RFC 2163<span> (</span><span class='info'>Allocchio, C., &ldquo;Using the Internet DNS to Distribute           MIXER Conformant Global Address Mapping (MCGAM),&rdquo; January&nbsp;1998.</span><span>)</span></a> [RFC2163] an infix token is
        inserted directly below the TLD, but the result is equivalent to
        adding a suffix to the owner name (instead of creating a TLD one is
        creating a second level domain).
</p>
<a name="add_class"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Add a new Class</h3>

<p>DNS zones are class-specific in the sense that all the records in
        that zone share the same class as the zone's SOA record and the
        existence of a zone in one class does not guarantee the existence of
        the zone in any other class. In practice, only the IN class has ever
        seen widespread deployment, and the administrative overhead of
        deploying an additional class would almost certainly be
        prohibitive.
</p>
<p>Nevertheless, one could in theory use the DNS class mechanism to
        distinguish between different kinds of data. However, since the DNS
        delegation tree (represented by NS Resource Records) is itself tied to
        a specific class, attempting to resolve a query by crossing a class
        boundary may produce unexpected results because there is no guarantee
        that the name servers for the zone in the new class will be the same
        as the name servers in the IN class. The MIT Hesiod system used a
        scheme like this for storing data in the HS class, but only on a very
        small scale (within a single institution), and with an administrative
        fiat requiring that the delegation trees for the IN and HS trees be
        identical. The use of the HS class for such storage of non-sensitive
        data was over time replaced by use of LDAP.
</p>
<p>Even when using a different class, the data will still have to be
        stored in some Resource Record Type that has an appropriate format to
        store the data. This implies that one might have to mix the prefix
        based selection mechanism with some other mechanism so that the right
        Resource Record can be found out of many in a potential larger
        RRSet.
</p>
<a name="add_type"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Add a new Resource Record Type</h3>

<p>When adding a new Resource Record Type to the system, entities in
        four different roles have to be able to handle the new Type:
</p>
<p></p>
<ol class="text">
<li>There must be a way to insert the new Resource Records into the
            zone of the Primary Master name server. For some server
            implementations, the user interface only accepts Resource Record
            Types which it understands (perhaps so that the implementation can
            attempt to validate the data). Other implementations allow the
            zone administrator to enter an integer for the Resource Record
            Type code and the RDATA in Base64 or hexadecimal encoding (or even
            as raw data). <a class='info' href='#RFC3597'>RFC 3597<span> (</span><span class='info'>Gustafsson, A., &ldquo;Handling of Unknown DNS Resource Record (RR) Types,&rdquo; September&nbsp;2003.</span><span>)</span></a> [RFC3597] specifies a
            standard generic encoding for this purpose.
</li>
<li>A slave authoritative name server must be able to do a zone
            transfer, receive the data from some other authoritative name
            server, and serve data from the zone even though the zone includes
            records of unknown Types. Historically, some implementations have
            had problems parsing stored copies of the zone file after
            restarting, but those problems have not been seen for a few
            years.
</li>
<li>A caching resolver (most commonly a recursive name server) will
            cache the records which are responses to queries. As mentioned in
            <a class='info' href='#RFC3597'>RFC 3597<span> (</span><span class='info'>Gustafsson, A., &ldquo;Handling of Unknown DNS Resource Record (RR) Types,&rdquo; September&nbsp;2003.</span><span>)</span></a> [RFC3597],there are various pitfalls
            where a recursive name server might end up having problems.
</li>
<li>The application must be able to get the RRSet with a new
            Resource Record Type. The application itself may understand the
            RDATA, but the resolver library might not. Support for a generic
            interface for retrieving arbitrary DNS Resource Record Types has
            been a requirement since 1989 (see <a class='info' href='#RFC1123'>RFC
            1123<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Application and           Support,&rdquo; October&nbsp;1989.</span><span>)</span></a> [RFC1123] Section 6.1.4.2). Some stub resolver library
            implementations neglect to provide this functionality and cannot
            handle unknown Resource Record Types, but implementation of a new
            stub resolver library is not particularly difficult, and open
            source libraries that already provide this functionality are
            available.
</li>
</ol>

<p>Historically, adding a new Resource Record Type has been very
        problematic. Review process has been cumbersome, DNS servers have not
        been able to handle new Resource Record Types, and firewalls have
        dropped queries or responses with Resource Record Types that are
        unknown to the firewall. This is for example one of the reasons the
        ENUM standard reuses the NAPTR Resource Record, a decision that today
        might have gone to creating a new resource record type instead.
</p>
<p>Today, there is a requirement that DNS software handle unknown
        Resource Record Types, and investigations have shown that software
        that is deployed in general does support it. Also, the approval
        process for new Resource Record Types has been updated so the effort
        that is needed for various Resource Record Types is more
        predictable.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Zone boundaries are invisible to applications</h3>

<p>Regardless of the possible choices above we have seen a number of
      cases where the application made assumptions about the structure of the
      namespace and the location where specific information resides. We take a
      small sidestep to argue against such approaches.
</p>
<p>The DNS namespace is a hierarchy, technically speaking. However, this
      only refers to the way names are built from multiple labels. DNS
      hierarchy neither follows nor implies administrative hierarchy. Because
      of that, it cannot be assumed that data attached to a node in the DNS
      tree is valid for the whole subtree. Technically, there are zone
      boundaries partitioning the namespace, and administrative boundaries (or
      policy boundaries) may even exist elsewhere.
</p>
<p>The false assumption has lead to an approach called "tree climbing",
      where a query that does not receive a positive response (either the
      requested RRSet was missing or the name did not exist) is retried by
      repeatedly stripping off the leftmost label (climbing towards the root)
      until the root domain is reached. Sometimes these proposals try to avoid
      the query for the root or the TLD level, but still this approach has
      severe drawbacks:
</p>
<p></p>
<ul class="text">
<li>Technically, the DNS was built as a query - response tool without
          any search capability <a class='info' href='#RFC3467'>[RFC3467]<span> (</span><span class='info'>Klensin, J., &ldquo;Role of the Domain Name System (DNS),&rdquo; February&nbsp;2003.</span><span>)</span></a>. Adding the
          search mechanism imposes additional burden on the technical
          infrastructure, in the worst case on TLD and root name servers.
</li>
<li>For reasons similar to those outlined in <a class='info' href='#RFC1535'>RFC 1535<span> (</span><span class='info'>Gavron, E., &ldquo;A Security Problem and           Proposed Correction With Widely Deployed DNS Software,&rdquo; October&nbsp;1993.</span><span>)</span></a> [RFC1535], querying for information in a
          domain outside the control of the intended entity may lead to
          incorrect results and may also put security at risk. Finding the
          exact policy boundary is impossible without an explicit marker which
          does not exist at present. At best, software can detect zone
          boundaries (e.g., by looking for SOA Resource Records), but some TLD
          registries register names starting at the second level (e.g.,
          CO.UK), and there are various other "registry" types at second,
          third or other level domains that cannot be identified as such
          without policy knowledge external to the DNS.
</li>
</ul>

<p>To restate, the zone boundary is purely a boundary that exists in the
      DNS for administrative purposes, and applications should be careful not
      to draw unwarranted conclusions from zone boundaries. A different way of
      stating this is that the DNS does not support inheritance, e.g. a
      wildcard MX RRSet for a TLD will not be valid for any subdomain of that
      particular TLD.
</p>
<a name="txt_evil"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Why adding a new Resource Record Type is the preferred solution</h3>

<p>By now, the astute reader might be wondering what conclusions to draw
      from the issues presented so far. We will now attempt to clear up the
      reader's confusion by following the thought processes of a typical
      application designer who wishes to store data in the DNS. We'll show how
      such a designer almost inevitably hits upon the idea of just using a TXT
      Resource Record, why this is a bad thing, and why a new Resource Record
      Type should be allocated instead. And we'll also explain how the reuse
      of an existing resource record, including TXT, can be made less
      harmful.
</p>
<p>The overall problem with most solutions has to do with two main
      issues: </p>
<ul class="text">
<li>No semantics to prevent collision with other use
</li>
<li>Space considerations in the DNS message
</li>
</ul>

<p>A typical application designer is not interested in the DNS for its
      own sake, but rather regards it as a distributed database in which
      application data can be stored. As a result, the designer of a new
      application is usually looking for the easiest way to add whatever new
      data the application needs to the DNS in a way that naturally associates
      the data with a DNS name.
</p>
<p>As explained in <a class='info' href='#add_class'>Section&nbsp;3.4<span> (</span><span class='info'>Add a new Class</span><span>)</span></a>, using the DNS class
      system as an extension mechanism is not really an option, and in fact
      most users of the system don't even realize that the mechanism exists.
      As a practical matter, therefore any extension is likely to be within
      the IN class.
</p>
<p>Adding a new Resource Record Type is the technically correct answer
      from the DNS protocol standpoint (more on this below), but doing so
      requires some DNS expertise, due to the issues listed in <a class='info' href='#add_type'>Section&nbsp;3.5<span> (</span><span class='info'>Add a new Resource Record Type</span><span>)</span></a>. Consequently, this option is often rejected.
      Note that according to <a class='info' href='#RFC2929'>RFC 2929<span> (</span><span class='info'>Eastlake, D., Brunner-Williams, E., and B. Manning, &ldquo;Domain Name System (DNS) IANA Considerations,&rdquo; September&nbsp;2000.</span><span>)</span></a> [RFC2929], some
      Types require IETF Consensus, while others only require a
      specification.
</p>
<p>There is a drawback to defining new RR types that is worth
      mentioning. The RRTYPE is a 16 bit value and hence is a limited
      resource. In order to prevent herding the registry has a review based
      allocation policy <a class='info' href='#RFC2929'>[RFC2929]<span> (</span><span class='info'>Eastlake, D., Brunner-Williams, E., and B. Manning, &ldquo;Domain Name System (DNS) IANA Considerations,&rdquo; September&nbsp;2000.</span><span>)</span></a>, however this may not
      be sufficient if extension of the DNS by addition of new RR types takes
      up significantly and the registry starts nearing completion. In that
      case the trade-offs with respect to choosing an extension mechanism may
      need to change.
</p>
<p>The application designer is thus left with the prospect of reusing
      some existing DNS Type within the IN class, but when the designer looks
      at the existing Types, almost all of them have well-defined semantics,
      none of which quite match the needs of the new application. This has not
      completely prevented proposals from reusing existing Resource Record
      Types in ways incompatible with their defined semantics, but it does
      tend to steer application designers away from this approach.
</p>
<p>For example, Resource Record Type 40 was registered for the SINK
      Resource Record Type. This Resource Record Type was discussed in the
      DNSIND working group of the IETF, and it was decided at the 46th IETF to
      not move the I-D forward to become an RFC because of the risk of
      encouraging application designers to use the SINK Resource Record Type
      instead of registering a new Resource Record Type, which would result in
      infeasibly large SINK RRsets.
</p>
<p>Eliminating all of the above leaves the TXT Resource Record Type in
      the IN class. The TXT RDATA format is free form text, and there are no
      existing semantics to get in the way. Some attempts have been made, for
      example in <a class='info' href='#I-D.cheshire-dnsext-dns-sd'>draft-cheshire-dnsext-dns-sd<span> (</span><span class='info'>Cheshire, S. and M. Krochmal, &ldquo;DNS-Based Service Discovery,&rdquo; August&nbsp;2006.</span><span>)</span></a> [I&#8209;D.cheshire&#8209;dnsext&#8209;dns&#8209;sd], to specify a structured format for
      TXT Resource Record Types, but no such attempt has reached RFC status.
      Furthermore, the TXT Resource Record can obviously just be used as a
      bucket in which to carry around data to be used by some higher level
      parser, perhaps in some human readable programming or markup language.
      Thus, for many applications, TXT Resource Records are the "obvious"
      choice. Unfortunately, this conclusion, while understandable, is also
      wrong, for several reasons.
</p>
<p>The first reason why TXT Resource Records are not well suited to such
      use is precisely what makes them so attractive: the lack of pre-defined
      common syntax or structure. As a result, each application that uses them
      creates its own syntax/structure, and that makes it difficult to
      reliably distinguish one application's record from others, and for its
      parser to avoid problems when it encounters other TXT records.
</p>
<p>Arguably, the TXT Resource Record is misnamed, and should have been
      called the Local Container record, because a TXT Resource Record means
      only what the data producer says it means. This is fine, so long as TXT
      Resource Records are being used by human beings or by private agreement
      between data producer and data consumer. However, it becomes a problem
      once one starts using them for standardized protocols in which there is
      no prior relationship between data producer and data consumer. If TXT
      records are used without one of the naming modifications discussed
      earlier (and in some cases even if one uses such naming mechanisms),
      there is nothing to prevent collisions with some other incompatible use
      of TXT Resource Records.
</p>
<p>This is even worse than the general subtyping problem described in in
      <a class='info' href='#add_subtype'>Section&nbsp;3.1<span> (</span><span class='info'>Place selectors inside the RDATA of existing Resource Record Types</span><span>)</span></a>, because TXT Resource Records don't
      even have a standardized selector field in which to store the subtype.
      <a class='info' href='#RFC1464'>RFC 1464<span> (</span><span class='info'>Rosenbaum, R., &ldquo;Using the Domain           Name System To Store Arbitrary String Attributes,&rdquo; May&nbsp;1993.</span><span>)</span></a> [RFC1464] tried, but it was not a success.
      At best a definition of a subtype is reduced to hoping that whatever
      scheme one has come up with will not accidently conflict with somebody
      else's subtyping scheme, and that it will not be possible to mis-parse
      one application's use of TXT Resource Records as data intended for a
      different application. Any attempt to impose a standardized format
      within the TXT Resource Record format would be at least fifteen years
      too late even if it were put into effect immediately; at best, one can
      restrict the syntax that a particular application uses within a TXT
      Resource Record and accept the risk that unrelated TXT Resource Record
      uses will collide with it.
</p>
<p>Using one of the naming modifications discussed in <a class='info' href='#add_prefix'>Section&nbsp;3.2<span> (</span><span class='info'>Add a prefix to the owner name</span><span>)</span></a> and <a class='info' href='#add_suffix'>Section&nbsp;3.3<span> (</span><span class='info'>Add a suffix to the owner name</span><span>)</span></a> would
      address the subtyping problem, (and have been used in combinations with
      reuse of TXT record, such as for the dns/txt lookup mechanism in DKIM)
      but each of these approaches brings in new problems of its own. The
      prefix approach (that for example SRV Resource Records use) does not
      work well with wildcards, which is a particular problem for mail-related
      applications, since MX Resource Records are probably the most common use
      of DNS wildcards. The suffix approach doesn't have wildcard issues, but,
      as noted previously, it does have synchronization and update
      authorization issues, since it works by creating a second subtree in a
      different part of the global DNS name space.
</p>
<p>The next reason why TXT Resource Records are not well suited to
      protocol use has to do with the limited data space available in a DNS
      message. As alluded to briefly in <a class='info' href='#add_subtype'>Section&nbsp;3.1<span> (</span><span class='info'>Place selectors inside the RDATA of existing Resource Record Types</span><span>)</span></a>,
      typical DNS query traffic patterns involve a very large number of DNS
      clients sending queries to a relatively small number of DNS servers.
      Normal path MTU discovery schemes do little good here because, from the
      server's perspective, there isn't enough repeat traffic from any one
      client for it to be worth retaining state. UDP-based DNS is an
      idempotent query, whereas TCP-based DNS requires the server to keep
      state (in the form of TCP connection state, usually in the server's
      kernel) and roughly triples the traffic load. Thus, there's a strong
      incentive to keep DNS messages short enough to fit in a UDP datagram,
      preferably a UDP datagram short enough not to require IP
      fragmentation.
</p>
<p>Subtyping schemes are therefore again problematic because they
      produce larger Resource RRSets than necessary, but verbose text
      encodings of data are also wasteful, since the data they hold can
      usually be represented more compactly in a Resource Record designed
      specifically to support the application's particular data needs. If the
      data that need to be carried are so large that there is no way to make
      them fit comfortably into the DNS regardless of encoding, it is probably
      better to move the data somewhere else, and just use the DNS as a
      pointer to the data, as with NAPTR.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Conclusion and Recommendation</h3>

<p>Given the problems detailed in <a class='info' href='#txt_evil'>Section&nbsp;5<span> (</span><span class='info'>Why adding a new Resource Record Type is the preferred solution</span><span>)</span></a>, it is
      worth reexamining the oft-jumped-to conclusion that specifying a new
      Resource Record Type is hard. Historically, this was indeed the case,
      but recent surveys suggest that support for unknown Resource Record
      Types <a class='info' href='#RFC3597'>[RFC3597]<span> (</span><span class='info'>Gustafsson, A., &ldquo;Handling of Unknown DNS Resource Record (RR) Types,&rdquo; September&nbsp;2003.</span><span>)</span></a> is now widespread, and because of
      that the DNS infrastructure can handle new resource record types. The
      lack of support for unknown Types is mostly an issue for relatively old
      provision software and applications that would probably need to be
      upgraded in any case as part of supporting a new feature (that require
      the new Resource Record Type). One should also remember that deployed
      DNS software today should support DNSSEC, and software recent enough to
      do so will likely support both unknown Resource Record Types <a class='info' href='#RFC3597'>[RFC3597]<span> (</span><span class='info'>Gustafsson, A., &ldquo;Handling of Unknown DNS Resource Record (RR) Types,&rdquo; September&nbsp;2003.</span><span>)</span></a> and EDNS0 <a class='info' href='#RFC2671'>[RFC2671]<span> (</span><span class='info'>Vixie, P., &ldquo;Extension Mechanisms for DNS (EDNS0),&rdquo; August&nbsp;1999.</span><span>)</span></a>.
</p>
<p>Of all the issues detailed in <a class='info' href='#add_type'>Section&nbsp;3.5<span> (</span><span class='info'>Add a new Resource Record Type</span><span>)</span></a>,
      provisioning the data is in some respects the most difficult. The
      problems can be divided in two, the ability to manage the zone on the
      master server, and the ability for secondary servers to do zone
      transfers (AXFR or IXFR) with the new data. Investigations show that the
      problem here is less difficult for the authoritative name servers
      themselves than the front-end systems used to enter (and perhaps
      validate) the data. Hand editing does not work well for maintenance of
      large zones, so some sort of tool is necessary, and the tool may not be
      tightly coupled to the name server implementation itself. Note, however,
      that this provisioning problem exists to some degree with any new form
      of data to be stored in the DNS, regardless of data format, Resource
      Record type (even if TXT Resource Record Types are in use), or naming
      scheme. Adapting front-end systems to support a new Resource Record Type
      may be a bit more difficult than reusing an existing type, but this
      appears to be a minor difference in degree rather than a difference in
      kind.
</p>
<p>Given the various issues described in this note, we believe that:
      </p>
<ul class="text">
<li>there is no magic solution which allows a completely painless
          addition of new data to the DNS, but
</li>
<li>on the whole, the best solution is still to use the DNS Resource
          Record Type mechanism designed for precisely this purpose, and
</li>
<li>of all the alternate solutions, the "obvious" approach of using
          TXT Resource Records is almost certainly the worst.
</li>
</ul><p> This especially for the two reasons outlined above (lack of
      semantics and its implications, and size leading to the need to use
      TCP).
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Creating A New Resource Record Type</h3>

<p>The process for creating a new Resource Record Type is specified in
      <a class='info' href='#I-D.ietf-dnsext-2929bis'>draft-ietf-dnsext-2929bis<span> (</span><span class='info'>Eastlake 3rd, D., &ldquo;Domain Name System (DNS) IANA Considerations,&rdquo; August&nbsp;2007.</span><span>)</span></a> [I&#8209;D.ietf&#8209;dnsext&#8209;2929bis].
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>This document does not require any IANA actions.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Security Considerations</h3>

<p>DNS RRSets can be signed using DNSSEC. DNSSEC is almost certainly
      necessary for any application mechanism that stores authorization data
      in the DNS. DNSSEC signatures significantly increase the size of the
      messages transported, and because of this, the DNS message size issues
      discussed in <a class='info' href='#add_subtype'>Section&nbsp;3.1<span> (</span><span class='info'>Place selectors inside the RDATA of existing Resource Record Types</span><span>)</span></a> and <a class='info' href='#txt_evil'>Section&nbsp;5<span> (</span><span class='info'>Why adding a new Resource Record Type is the preferred solution</span><span>)</span></a> are more serious than they might at first
      appear.
</p>
<p>Adding new Resource Record Types (as discussed in <a class='info' href='#add_type'>Section&nbsp;3.5<span> (</span><span class='info'>Add a new Resource Record Type</span><span>)</span></a>) can create two different kinds of problems.
      In DNS software and in applications. In the DNS software, it might
      conceivably trigger bugs and other bad behavior in software that is not
      compliant with <a class='info' href='#RFC3597'>RFC 3597<span> (</span><span class='info'>Gustafsson, A., &ldquo;Handling of Unknown DNS Resource Record (RR) Types,&rdquo; September&nbsp;2003.</span><span>)</span></a> [RFC3597], but most such DNS
      software is old enough and insecure enough that it should be updated for
      other reasons in any case. In applications and provisioning software,
      the changes for the new features that need the new data in DNS can be
      updated to understand the structure of the new data format (regardless
      of whether a new Resource Record Type is used or some other mechanism is
      chosen. Basic API support for retrieving arbitrary Resource Record Types
      has been a requirement since 1989<a class='info' href='#RFC1123'>[RFC1123]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Application and           Support,&rdquo; October&nbsp;1989.</span><span>)</span></a>.
</p>
<p>Any new protocol that proposes to use the DNS to store data used to
      make authorization decisions would be well advised not only to use
      DNSSEC but also to encourage upgrades to DNS server software recent
      enough not to be riddled with well-known exploitable bugs. Because of
      this, support for new Resource Record Types will not be as hard as
      people might think at first.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Acknowledgements</h3>

<p>This document has been created during a number of years, with input
      from many people. The question on how to expand and use the DNS is
      sensitive, and a document like this can not please everyone. The goal is
      instead to describe the architecture and tradeoffs, and make some
      recommendations about best practices.
</p>
<p>People that have helped include: Dean Andersson, Loa Andersson, Mark
      Andrews, John Angelmo, Roy Badami, Dan Bernstein, Alex Bligh, Nathaniel
      Borenstein, Stephane Bortzmeyer, Brian Carpenter, Leslie Daigle, Elwyn
      Davies, Mark Delany, Richard Draves, Martin Duerst, Donald Eastlake,
      Robert Elz, Jim Fenton, Tony Finch, Jim Gilroy, Olafur Gudmundsson, Eric
      Hall, Philip Hallam-Baker, Ted Hardie, Bob Hinden, Paul Hoffman, Geoff
      Houston, Christian Huitema, Johan Ihren, John Klensin, Olaf Kolkman, Ben
      Laurie, William Leibzon, John Levine, Edward Lewis, David MacQuigg,
      Allison Manking, Bill Manning, Danny McPherson, David Meyer, Pekka
      Nikander, Mans Nilsson, Masataka Ohta, Douglas Otis, Michael Patton,
      Jonathan Rosenberg, Anders Rundgren, Miriam Sapiro, Carsten Strotmann,
      Pekka Savola, Chip Sharp, James Snell, Dave Thaler, Michael Thomas, Paul
      Vixie, Sam Weiler, Florian Weimer, Bert Wijnen, and Dan Wing.
</p>
<p>Members of the IAB when this document was made available were: Loa
      Andersson, Gonzalo Camarillo, Stuart Cheshire, Russ Housley, Olaf
      Kolkman, Gregory Lebovitz, Barry Leiba, Kurtis Lindqvist, Andrew Malis,
      Danny McPherson, David Oran, Dave Thaler, and Lixia Zhang.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1035">[RFC1035]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1035">Domain names
          - implementation and specification</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1035, November&nbsp;1987 (<a href="ftp://ftp.isi.edu/in-notes/rfc1035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1464">[RFC1464]</a></td>
<td class="author-text"><a href="mailto:rosenbaum@lkg.dec.com">Rosenbaum, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1464">Using the Domain
          Name System To Store Arbitrary String Attributes</a>,&rdquo; RFC&nbsp;1464, May&nbsp;1993 (<a href="ftp://ftp.isi.edu/in-notes/rfc1464.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2535">[RFC2535]</a></td>
<td class="author-text"><a href="mailto:dee3@us.ibm.com">Eastlake, D.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2535">Domain Name System Security
          Extensions</a>,&rdquo; RFC&nbsp;2535, March&nbsp;1999 (<a href="ftp://ftp.isi.edu/in-notes/rfc2535.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2671">[RFC2671]</a></td>
<td class="author-text"><a href="mailto:vixie@isc.org">Vixie, P.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2671">Extension Mechanisms for DNS (EDNS0)</a>,&rdquo; RFC&nbsp;2671, August&nbsp;1999 (<a href="ftp://ftp.isi.edu/in-notes/rfc2671.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3597">[RFC3597]</a></td>
<td class="author-text">Gustafsson, A., &ldquo;<a href="http://tools.ietf.org/html/rfc3597">Handling of Unknown DNS Resource Record (RR) Types</a>,&rdquo; RFC&nbsp;3597, September&nbsp;2003 (<a href="ftp://ftp.isi.edu/in-notes/rfc3597.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>11.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.cheshire-dnsext-dns-sd">[I-D.cheshire-dnsext-dns-sd]</a></td>
<td class="author-text">Cheshire, S. and M. Krochmal, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsext-2929bis-06.txt">DNS-Based Service Discovery</a>,&rdquo; draft-ietf-dnsext-2929bis-06 (work in progress), August&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-dnsext-2929bis-06.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-dnsext-2929bis">[I-D.ietf-dnsext-2929bis]</a></td>
<td class="author-text">Eastlake 3rd, D., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-03.txt">Domain Name System (DNS) IANA Considerations</a>,&rdquo; draft-cheshire-dnsext-dns-sd-03 (work in progress), August&nbsp;2007 (<a href="http://tools.ietf.org/html/draft-cheshire-dnsext-dns-sd-04">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1123">[RFC1123]</a></td>
<td class="author-text"><a href="mailto:Braden@ISI.EDU">Braden, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and
          Support</a>,&rdquo; STD&nbsp;3, RFC&nbsp;1123, October&nbsp;1989 (<a href="ftp://ftp.isi.edu/in-notes/rfc1123.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1535">[RFC1535]</a></td>
<td class="author-text"><a href="mailto:gavron@aces.com">Gavron, E.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1535">A Security Problem and
          Proposed Correction With Widely Deployed DNS Software</a>,&rdquo; RFC&nbsp;1535, October&nbsp;1993 (<a href="ftp://ftp.isi.edu/in-notes/rfc1535.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2163">[RFC2163]</a></td>
<td class="author-text"><a href="mailto:Claudio.Allocchio@elettra.trieste.it">Allocchio, C.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2163">Using the Internet DNS to Distribute
          MIXER Conformant Global Address Mapping (MCGAM)</a>,&rdquo; RFC&nbsp;2163, January&nbsp;1998 (<a href="ftp://ftp.isi.edu/in-notes/rfc2163.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2181">[RFC2181]</a></td>
<td class="author-text"><a href="mailto:kre@munnari.OZ.AU">Elz, R.</a> and <a href="mailto:randy@psg.com">R. Bush</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2181">Clarifications to the DNS
          Specification</a>,&rdquo; RFC&nbsp;2181, July&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2181.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2181.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2181.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2672">[RFC2672]</a></td>
<td class="author-text"><a href="mailto:crawdad@fnal.gov">Crawford, M.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2672">Non-Terminal DNS Name Redirection</a>,&rdquo; RFC&nbsp;2672, August&nbsp;1999 (<a href="ftp://ftp.isi.edu/in-notes/rfc2672.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2929">[RFC2929]</a></td>
<td class="author-text">Eastlake, D., Brunner-Williams, E., and B. Manning, &ldquo;<a href="http://tools.ietf.org/html/rfc2929">Domain Name System (DNS) IANA Considerations</a>,&rdquo; BCP&nbsp;42, RFC&nbsp;2929, September&nbsp;2000 (<a href="ftp://ftp.isi.edu/in-notes/rfc2929.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3445">[RFC3445]</a></td>
<td class="author-text">Massey, D. and S. Rose, &ldquo;<a href="http://tools.ietf.org/html/rfc3445">Limiting the Scope of the KEY Resource Record (RR)</a>,&rdquo; RFC&nbsp;3445, December&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3445.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3467">[RFC3467]</a></td>
<td class="author-text">Klensin, J., &ldquo;<a href="http://tools.ietf.org/html/rfc3467">Role of the Domain Name System (DNS)</a>,&rdquo; RFC&nbsp;3467, February&nbsp;2003 (<a href="ftp://ftp.isi.edu/in-notes/rfc3467.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3761">[RFC3761]</a></td>
<td class="author-text">Faltstrom, P. and M. Mealling, &ldquo;<a href="http://tools.ietf.org/html/rfc3761">The E.164 to Uniform Resource Identifiers (URI) Dynamic
          Delegation Discovery System (DDDS) Application (ENUM)</a>,&rdquo; RFC&nbsp;3761, April&nbsp;2004 (<a href="ftp://ftp.isi.edu/in-notes/rfc3761.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4592">[RFC4592]</a></td>
<td class="author-text">Lewis, E., &ldquo;<a href="http://tools.ietf.org/html/rfc4592">The Role of Wildcards in the Domain Name System</a>,&rdquo; RFC&nbsp;4592, July&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4592.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Internet Architecture Board</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:iab@iab.org">iab@iab.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Patrik Faltstrom (editor)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:paf@cisco.com">paf@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rob Austein (editor)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:sra@isc.org">sra@isc.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Peter Koch (editor)</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:pk@denic.de">pk@denic.de</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
