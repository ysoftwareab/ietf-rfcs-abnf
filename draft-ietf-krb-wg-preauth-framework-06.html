<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>A Generalized Framework for Kerberos Pre-Authentication</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="A Generalized Framework for Kerberos Pre-Authentication">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Kerberos Working Group</td><td class="header">L. Zhu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Microsoft Corporation</td></tr>
<tr><td class="header">Updates: <a href='http://tools.ietf.org/html/rfc4120'>4120</a> (if&nbsp;approved)</td><td class="header">S. Hartman</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">MIT</td></tr>
<tr><td class="header">Expires: January 10, 2008</td><td class="header">July 09, 2007</td></tr>
</table></td></tr></table>
<h1><br />A Generalized Framework for Kerberos Pre-Authentication<br />draft-ietf-krb-wg-preauth-framework-06</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 10, 2008.</p>

<h3>Abstract</h3>

<p>Kerberos is a protocol for verifying the identity of
principals (e.g., a workstation user or a network server) on an
open network.  The Kerberos protocol provides a mechanism called
pre-authentication for proving the identity of a principal and for
better protecting the long-term secret of the principal.
</p>
<p>This document describes a model for Kerberos
pre-authentication mechanisms.  The model describes what state in the
Kerberos request a pre-authentication mechanism is likely to change.
It also describes how multiple pre-authentication mechanisms used in
the same request will interact.
</p>
<p>This document also provides common tools needed by multiple
pre-authentication mechanisms. One of these tools is a secure channel 
between the client and the KDC with a reply key delivery mechanism;
this secure channel can be used to protect the authentication exchange
thus eliminate offline dictionary attacks. 
With these tools, it is relatively straightforward to 
chain multiple authentication mechanisms, utilize a different key management system, 
or support a new key agreement algorithm. 
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">2.</a>&nbsp;
Conventions and Terminology Used in This Document<br />
<a href="#anchor2">3.</a>&nbsp;
Model for Pre-Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#state">3.1.</a>&nbsp;
Information Managed by the Pre-authentication Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#preauth-required-error">3.2.</a>&nbsp;
Initial Pre-authentication Required Error<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client-request">3.3.</a>&nbsp;
Client to KDC<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#kdc-client">3.4.</a>&nbsp;
KDC to Client<br />
<a href="#anchor3">4.</a>&nbsp;
Pre-Authentication Facilities<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.1.</a>&nbsp;
Client-authentication Facility<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#strengthen-reply">4.2.</a>&nbsp;
Strengthening-reply-key Facility<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#replace-reply-key">4.3.</a>&nbsp;
Replacing-reply-key Facility<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">4.4.</a>&nbsp;
KDC-authentication Facility<br />
<a href="#requirements">5.</a>&nbsp;
Requirements for Pre-Authentication Mechanisms<br />
<a href="#anchor7">6.</a>&nbsp;
Tools for Use in Pre-Authentication Mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#combine-key">6.1.</a>&nbsp;
Combining Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.2.</a>&nbsp;
Protecting Requests/Responses<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#kdc-state">6.3.</a>&nbsp;
Managing States for the KDC<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pa-authentication-set">6.4.</a>&nbsp;
Pre-authentication Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fast">6.5.</a>&nbsp;
Definition of Kerberos FAST Padata<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#armor_key">6.5.1.</a>&nbsp;
FAST Armors<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fastreq">6.5.2.</a>&nbsp;
FAST Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fastrep">6.5.3.</a>&nbsp;
FAST Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#err">6.5.4.</a>&nbsp;
Authenticated Kerberos Error Messages using Kerberos FAST<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">6.5.5.</a>&nbsp;
The Authenticated Timestamp FAST Factor<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#auth-strength">6.6.</a>&nbsp;
Authentication Strength Indication<br />
<a href="#iana">7.</a>&nbsp;
IANA Considerations<br />
<a href="#security">8.</a>&nbsp;
Security Considerations<br />
<a href="#ack">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#anchor19">Appendix&nbsp;A.</a>&nbsp;
ASN.1 module<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The core Kerberos specification <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> treats pre-authentication data
  as an opaque typed hole in the messages to the KDC that may
  influence the reply key used to encrypt the KDC reply.  This
  generality has been useful: pre-authentication data is used for a
  variety of extensions to the protocol, many outside the expectations
  of the initial designers. However, this generality makes designing
  more common types of pre-authentication mechanisms difficult.
  Each mechanism needs to specify how it interacts with other
  mechanisms.  Also, problems like combining a key with the long-term
  secret or proving the identity of the user are common to multiple
  mechanisms.  Where there are generally well-accepted solutions to
  these problems, it is desirable to standardize one of these
  solutions so mechanisms  can avoid duplication of work.  In other
  cases, a modular approach to these problems is appropriate.  The
  modular approach will allow new and better solutions to common
  pre-authentication problems to be used by existing mechanisms as they are developed.
</p>
<p>This document specifies a framework for Kerberos
  pre-authentication mechanisms.  It defines the common set of
  functions that pre-authentication mechanisms perform as well as how these
  functions affect the state of the request and reply.  In addition
  several common tools needed by pre-authentication mechanisms are
  provided. Unlike <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a>, this framework is not
  complete--it does not describe all the inputs and outputs for the
  pre-authentication mechanisms.  Pre-Authentication mechanism designers should try to be
  consistent with this framework because doing so will make their
  mechanisms easier to implement.  Kerberos implementations are likely
  to have plugin architectures for pre-authentication; such
  architectures are likely to support mechanisms that follow this
  framework plus commonly used extensions. 
</p>
<p> One of these common tools is the flexible 
  authentication secure tunneling (FAST) padata type. FAST provides a protected
  channel between the client and the KDC, and it can optionally deliver
  a reply key within the protected channel. Based on FAST, pre-authentication
  mechanisms can extend Kerberos with ease, to support, for example, password authenticated
  key exchange (PAKE) protocols with zero knowledge password proof (ZKPP) [EKE] [IEEE1363.2]. 
  Any pre-authentication mechanism can be encapsulated in the FAST messages as defined in <a class='info' href='#fast'>Section&nbsp;6.5<span> (</span><span class='info'>Definition of Kerberos FAST Padata</span><span>)</span></a>. 
  A pre-authentication type carried within FAST is called a FAST factor.
  Creating a  FAST factor is the easiest path to create  a new pre-authentication mechanism.  FAST  factors are  significantly easier to analyze from a security standpoint than other pre-authentication mechanisms.
</p>
<p>Mechanism designers should design FAST factors, instead
  of  new pre-authentication mechanisms outside of FAST.
</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conventions and Terminology Used in This Document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
    "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<p> The word padata is used as a shorthand for pre-authentication data. 
</p>
<p>A conversation
is the set  of  all authentication messages exchanged between the client and the KDCs in order to authenticate the client principal.
A conversation as defined here consists of all messages that are necessary to complete the authentication 
between the client and the KDC. 

</p>
<p>Lastly, this document should be read only after reading the documents
describing the Kerberos cryptography framework <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a> and the core Kerberos protocol <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>.  This
document may freely use terminology and notation from these
documents without reference or further explanation.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Model for Pre-Authentication</h3>

<p>When a Kerberos client wishes to obtain a ticket using the
      authentication server, it sends an initial Authentication Service (AS) request.  If
      pre-authentication is required but not being used, then the KDC will respond with
      a KDC_ERR_PREAUTH_REQUIRED error.  Alternatively, if the client
      knows what pre-authentication to use, it MAY optimize away a 
      round-trip and send an initial request with padata included
      in the initial request. If
      the client includes the padata computed using the wrong pre-authentication mechanism or incorrect keys, the KDC MAY return
      KDC_ERR_PREAUTH_FAILED with no indication of what padata should
      have been included. In that case, the client MUST retry with no padata and examine
      the error data of the KDC_ERR_PREAUTH_REQUIRED error. 
      If the KDC includes pre-authentication information
      in the accompanying error data of KDC_ERR_PREAUTH_FAILED, the client SHOULD process
      the error data, and then retry.
</p>
<p>The conventional KDC maintains no state between two requests; subsequent
      requests may even be processed by a different KDC. On the other
      hand, the client treats a series of exchanges with KDCs as a
      single conversation.  Each exchange accumulates state
      and hopefully brings the client closer to a successful
      authentication.  
</p>
<p>These models for state management are in apparent conflict.
      For many of the simpler pre-authentication scenarios, the client
      uses one round trip to find out what mechanisms the KDC
      supports.  Then the next request contains sufficient
      pre-authentication for the KDC to be able to return a successful
      reply.  For these simple scenarios, the client only sends one
      request with pre-authentication data and so the conversation is trivial.  For more complex conversations,
      the KDC needs to provide the client with a cookie to include in
      future requests to capture the current state of the
      authentication session.  Handling of multiple round-trip
      mechanisms is discussed in
<a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a>.
</p>
<p>This framework specifies the behavior of Kerberos
      pre-authentication mechanisms used to identify users or to modify
      the reply key used to encrypt the KDC reply.  The PA-DATA
      typed hole may be used to carry extensions to Kerberos that have
      nothing to do with proving the identity of the user or
      establishing a reply key.  Such extensions are outside the
      scope of this framework.  However mechanisms that do accomplish
      these goals should follow this framework.
</p>
<p>This framework specifies the minimum state that a Kerberos
      implementation needs to maintain while handling a request in
      order to process pre-authentication.  It also specifies how
      Kerberos implementations process the padata at
      each step of the AS request process.
</p>
<a name="state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Information Managed by the Pre-authentication Model</h3>

<p>  The following information is maintained by the client and KDC as each
    request is being processed: <br />
<br />

</p>
<ul class="text">
<li>The reply key used to encrypt the KDC reply<br />
<br />

</li>
<li>How strongly the identity of the client has been authenticated<br />
<br />

</li>
<li>Whether the reply key has been used in this
        conversation<br />
<br />

</li>
<li>Whether the reply key has been replaced in this
        conversation<br />
<br />

</li>
<li>Whether the contents of the KDC reply can be verified by
        the client principal<br />
<br />

</li>
</ul><p>

</p>
<p>Conceptually, the reply key is initially the long-term key
    of the principal.  However, principals can have multiple
    long-term keys because of support for multiple encryption
    types, salts and string2key parameters.  As described in
    Section 5.2.7.5 of the Kerberos protocol <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>, the KDC sends PA-ETYPE-INFO2 to notify the
    client  what types of keys are available.  Thus in full
    generality, the reply key in the pre-authentication model is actually a
    set of keys.  At the beginning of a request, it is initialized
    to the set of long-term keys advertised in the
    PA-ETYPE-INFO2 element on the KDC.  If multiple reply keys are
    available, the client chooses which one to use.  Thus the
    client does not need to treat the reply key as a set.  At the
    beginning of a request, the client picks a reply
    key to use.
</p>
<p>KDC implementations MAY choose to offer only one key in the
    PA-ETYPE-INFO2 element.  Since the KDC already knows the
    client's list of supported enctypes from the request, no
    interoperability problems are created by choosing a single
    possible reply key.  This way, the KDC implementation avoids
    the complexity of treating the reply key as a set.
</p>
<p>When the padata in the request is verified by the KDC, 
    then the client is known to have that key, therefore the KDC SHOULD pick
    the same key as the reply key.
</p>
<p>At the beginning of handling a message on both the client
    and the KDC, the client's identity is not authenticated.  A
    mechanism may indicate that it has successfully authenticated
    the client's identity.  This information is useful to keep
    track of on the client  in order to know what
    pre-authentication mechanisms should be used.  The KDC needs to
    keep track of whether the client is authenticated because the
    primary purpose of pre-authentication is to authenticate the
    client identity before issuing a ticket. 
    The handling of authentication strength using various authentication mechanisms is discussed
    in <a class='info' href='#auth-strength'>Section&nbsp;6.6<span> (</span><span class='info'>Authentication Strength Indication</span><span>)</span></a>.
</p>
<p>Initially the reply key has not been used.  A
    pre-authentication mechanism that uses the reply key 
    to encrypt or checksum some data in the
    generation of new keys MUST indicate that the reply key is
    used.  This state is maintained by the client and the KDC to
    enforce the security requirement stated in <a class='info' href='#replace-reply-key'>Section&nbsp;4.3<span> (</span><span class='info'>Replacing-reply-key Facility</span><span>)</span></a> that the reply key cannot be
    replaced after it is used.
</p>
<p>Initially the reply key has not been replaced.  If a
    mechanism implements the Replace Reply Key facility discussed
    in <a class='info' href='#replace-reply-key'>Section&nbsp;4.3<span> (</span><span class='info'>Replacing-reply-key Facility</span><span>)</span></a>, then the state MUST be
    updated to indicate that the reply key has been replaced.
    Once the reply key has been replaced, knowledge of the reply
    key is insufficient to authenticate the client. The reply key
    is marked replaced in exactly the same situations as the KDC
    reply  is marked as not being verified to the client
    principal.  However, while mechanisms can verify the KDC
    reply to the client, once the reply key is replaced, then
    the reply key remains replaced for the remainder of the
    conversation.
</p>
<p>Without pre-authentication, the client knows that the KDC
    reply is authentic and has not been modified because it is
    encrypted in a long-term key of the client.  Only the KDC
    and the client know that key.  So at the start of handling any
    message the KDC reply is presumed to be verified using the
    client principal's long-term key.  Any pre-authentication mechanism that sets a
    new reply key not based on the principal's long-term secret
    MUST either verify the KDC reply some other way or indicate
    that the reply is not verified.  If a mechanism indicates
    that the reply is not verified then the client
    implementation MUST return an error unless a subsequent
    mechanism verifies the reply.  The KDC needs to track this
    state so it can avoid generating a reply that is not verified.
</p>
<p>The typical Kerberos request does not provide a way for the
    client machine to know that it is talking to the correct KDC.
    Someone who can inject packets into the network between the
    client machine and the KDC and who knows the password that the
    user will give to the client machine can generate a KDC
    reply that will decrypt properly.  So, if the client
    machine needs to authenticate that the user is in fact the
    named principal, then the client machine needs to do a TGS
    request for itself as a service.  Some pre-authentication
    mechanisms may provide  a way for the client to authenticate
    the KDC.  Examples of this include signing the reply that can be 
    verified using a well-known public key or providing a ticket for the client
    machine as a service.  
</p>
<a name="preauth-required-error"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Initial Pre-authentication Required Error</h3>

<p>Typically a client starts a conversation by
    sending  an initial request with no
    pre-authentication.  If the KDC requires pre-authentication,
    then it returns a KDC_ERR_PREAUTH_REQUIRED message.  
    After the first reply with the KDC_ERR_PREAUTH_REQUIRED error code, 
    the KDC returns the error code KDC_ERR_MORE_PREAUTH_DATA_NEEDED (defined in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a>)  for pre-authentication
    configurations that use multi-round-trip mechanisms; see <a class='info' href='#kdc-client'>Section&nbsp;3.4<span> (</span><span class='info'>KDC to Client</span><span>)</span></a> for details of that case. 

</p>
<p>The KDC needs to choose which mechanisms to offer the
    client.  The client needs to be able to choose what mechanisms
    to use from the first message.  For example consider the KDC 
    that will accept mechanism A followed by mechanism B or
    alternatively the single mechanism C.  A client that supports
    A and C needs to know that it should not bother trying A.
</p>
<p> Mechanisms can either be sufficient on their own or can be
    part of an authentication set--a group of mechanisms that all
    need to successfully complete in order to authenticate a
    client.   Some mechanisms may only be useful in authentication
    sets; others may be useful alone or in authentication sets.
    For the second group of mechanisms, KDC policy dictates
    whether the mechanism will be part of an authentication set or
    offered alone.  For each mechanism that is offered alone, the
    KDC includes the pre-authentication type ID of the mechanism
    in the padata sequence returned in the
    KDC_ERR_PREAUTH_REQUIRED error. 
</p>
<p>The KDC SHOULD NOT send data that is
    encrypted in the long-term password-based key of the
    principal.  Doing so has the same security exposures as the
    Kerberos protocol without pre-authentication.  There are few
    situations where pre-authentication is desirable and where the
    KDC needs to expose cipher text encrypted in a weak key before
    the client has proven knowledge of that key.
</p>
<a name="client-request"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Client to KDC</h3>

<p>This description assumes that a client has already received a
    KDC_ERR_PREAUTH_REQUIRED from the KDC.  If the client performs
    optimistic pre-authentication then the client needs to
    optimistically guess values for  the information it would normally receive
    from that error response.
</p>
<p>The client starts by
    initializing the pre-authentication state as specified.  It
    then processes the padata in the KDC_ERR_PREAUTH_REQUIRED. 
</p>
<p>When processing the response to the
    KDC_ERR_PREAUTH_REQUIRED, the client MAY ignore any padata it
    chooses unless doing so violates a specification to which the
    client conforms.  Clients conforming to this specification MUST NOT ignore the padata defined
    in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a>.  Clients SHOULD process padata
    unrelated to this 
    framework or other means of authenticating the user.  Clients
    SHOULD choose one authentication set or mechanism that could
    lead to authenticating the user and ignore the rest.  Since
    the list of mechanisms offered by the KDC is in the decreasing
    preference order, clients
    typically choose the first mechanism or authentication set that the client can
    usefully perform.  If a client chooses to ignore a padata it
    MUST NOT process the padata, allow the padata to affect the
    pre-authentication state, nor respond to the padata.
</p>
<p>For each padata the client chooses to process, the client
    processes the padata and modifies the pre-authentication state
    as required by that mechanism.  Padata are processed in the
    order received from the KDC.  
</p>
<p>After processing the padata in the KDC
    error, the client generates a new request.  It processes the
    pre-authentication mechanisms in the order in which they will
    appear in the next request, updating the state as appropriate.
    The request is sent when it is complete.
</p>
<a name="kdc-client"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
KDC to Client</h3>

<p>When a KDC receives an AS request from a client, it needs
    to determine whether it will respond with an error or an AS
    reply.  There are many causes for an error to be generated
    that have nothing to do with pre-authentication; they are
    discussed in the core Kerberos specification.   
</p>
<p>From the standpoint of evaluating the pre-authentication,
    the KDC first starts by initializing the pre-authentication
    state.  It then processes the padata in the request.  As
    mentioned in <a class='info' href='#client-request'>Section&nbsp;3.3<span> (</span><span class='info'>Client to KDC</span><span>)</span></a>, the KDC
    MAY ignore padata that is inappropriate for the configuration
    and MUST ignore padata of an unknown type.  
</p>
<p>At this point the KDC decides whether it will issue a
    pre-authentication required error or a reply.  Typically a KDC
    will issue a reply if the client's identity has been
    authenticated to a sufficient degree.  
</p>
<p>In the case of a KDC_ERR_MORE_PREAUTH_DATA_NEEDED error, the KDC first starts by
    initializing the pre-authentication state.  Then it processes
    any padata in the client's request in the order provided by
    the client.  Mechanisms that are not understood by the KDC are
    ignored.  Mechanisms that are inappropriate for the client
    principal or the request SHOULD also be ignored.  Next, it
    generates padata for the error response, modifying the
    pre-authentication state appropriately as each mechanism is
    processed.  The KDC chooses the order in which it will
    generate padata (and thus the order of padata in the
    response), but it needs to modify the pre-authentication state
    consistently with the choice of order.  For example, if some
    mechanism establishes an authenticated client identity, then
    the subsequent mechanisms in the generated response receive
    this state as input.  After the padata is generated, the error
    response is sent.  Typically 
    the errors with the code KDC_ERR_MORE_PREAUTH_DATA_NEEDED 
    in a converstation will
    include KDC state as discussed in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a>.
</p>
<p>To generate a final reply, the KDC generates the padata modifying the pre-authentication
    state as necessary.  Then it generates the final response,
    encrypting it in the current pre-authentication reply key.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Pre-Authentication Facilities</h3>

<p>Pre-Authentication mechanisms can be thought of as
       providing various conceptual facilities.  This serves two
      useful purposes.  First, mechanism authors can choose only to
      solve one specific small problem.  It is often useful for a
      mechanism designed to offer key management not to directly
      provide client authentication but instead to allow one or more
      other mechanisms to handle this need.  Secondly, thinking about
      the  abstract services that a mechanism provides yields a
      minimum set of security requirements that all mechanisms
      providing that facility must meet. These security requirements
      are not complete; mechanisms will have additional security
      requirements based on the specific protocol they employ. 
</p>
<p>A mechanism is not constrained to only offering one of these
      facilities.  While such mechanisms can be designed and are
      sometimes useful, many pre-authentication mechanisms implement
      several facilities.  By combining multiple facilities in a
      single mechanism, it is often easier to construct a secure,
      simple solution than  by solving the problem in full
      generality.  Even when mechanisms provide multiple facilities,
      they need to meet the security requirements for all the
      facilities they provide.     If the FAST factor approach is used, it is likely that one or a small number of facilities can be provided by a single mechanism without complicating the security analysis.
</p>
<p>According to Kerberos extensibility rules (Section 1.5 of
    the Kerberos specification <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>), an
    extension MUST NOT change the semantics of a message unless a
    recipient is known to understand that extension.  Because a
    client does not know that the KDC supports a particular
    pre-authentication mechanism when it sends an initial request, a pre-authentication
    mechanism MUST NOT change the semantics of the request in a
    way that will break a KDC that does not understand that
    mechanism.  Similarly, KDCs MUST NOT send messages to clients
      that affect the core semantics unless the client has indicated
      support for the message.  
</p>
<p>The only state in this model that would
    break the interpretation of a message is changing the expected
    reply key.  If one mechanism changed the reply key and a
    later mechanism used that reply key, then a KDC that
    interpreted the second mechanism but not the first would fail
    to interpret the request correctly.  In order to avoid this 
problem,  extensions that change core semantics are typically divided
      into two parts.  The first part proposes a change to the core
      semantic--for example proposes a new reply key.  The second part
      acknowledges that the extension is understood and that the
      change takes effect.  
    <a class='info' href='#strengthen-reply'>Section&nbsp;4.2<span> (</span><span class='info'>Strengthening-reply-key Facility</span><span>)</span></a> discusses how to design
    mechanisms that modify the reply key to be split into a
      proposal and acceptance without requiring additional round trips
       to use the new reply key in subsequent pre-authentication.
      Other changes in the state described in <a class='info' href='#state'>Section&nbsp;3.1<span> (</span><span class='info'>Information Managed by the Pre-authentication Model</span><span>)</span></a> can safely be ignored by a KDC that does not
    understand a mechanism.  Mechanisms that modify the behavior
    of the request outside the scope of this framework need to
    carefully consider the Kerberos extensibility rules to avoid
    similar problems.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Client-authentication Facility</h3>

<p>The client authentication facility proves the identity of a
    user to the KDC before a ticket is issued.  Examples of
    mechanisms implementing this facility include the encrypted
    timestamp facility defined in Section 5.2.7.2 of the Kerberos
    specification <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>.
    Mechanisms that provide this facility are expected to mark the
    client as authenticated.
</p>
<p>Mechanisms implementing this facility SHOULD require the
    client to prove knowledge  of the reply key before
    transmitting a successful KDC reply.  Otherwise, an attacker
    can intercept the pre-authentication exchange and get a reply
    to attack.  One way of proving the client knows the reply key
    is to implement the Replace Reply Key facility along with this
    facility.  The PKINIT mechanism <a class='info' href='#RFC4556'>[RFC4556]<span> (</span><span class='info'>Zhu, L. and B. Tung, &ldquo;Public Key Cryptography for Initial Authentication in Kerberos (PKINIT),&rdquo; June&nbsp;2006.</span><span>)</span></a> implements Client Authentication
    alongside Replace Reply Key.  
</p>
<p>If the reply key has been replaced, then mechanisms such as
    encrypted-timestamp that rely on knowledge of the reply key to
    authenticate the client MUST NOT be used.
</p>
<a name="strengthen-reply"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Strengthening-reply-key Facility</h3>

<p>Particularly, when dealing with keys based on passwords, it
    is desirable to increase the strength of the key by adding
    additional secrets to it.  Examples of sources of additional
    secrets include the results of a Diffie-Hellman key exchange
    or key bits from the output of a smart card <a class='info' href='#KRB-WG.SAM'>[KRB&#8209;WG.SAM]<span> (</span><span class='info'>Hornstein, K., Renard, K., Neuman, C., and G. Zorn, &ldquo;Integrating Single-use Authentication Mechanisms with Kerberos,&rdquo; October&nbsp;2003.</span><span>)</span></a>.   Typically these additional secrets can be
    first combined with the existing reply key and 
    then converted to a protocol key using
    tools defined in <a class='info' href='#combine-key'>Section&nbsp;6.1<span> (</span><span class='info'>Combining Keys</span><span>)</span></a>.
</p>
<p>If a mechanism implementing this facility wishes to modify
the reply key before knowing that the other party in the exchange
supports the mechanism, it proposes modifying the reply key.  The
other party then includes a message indicating that the proposal is
accepted if it is understood and meets policy.  In many
cases it is desirable to use the new reply key for client
authentication and for other facilities.  Waiting for the other party
to accept the proposal and actually modify the reply key state would
add an additional round trip to the exchange.  Instead, mechanism
designers  are encouraged to include a typed hole for additional
padata in the message that proposes the reply key change.  The padata
included in the typed hole are generated assuming the new reply key.
If the other party accepts the proposal, then these padata are
considered as an inner level.  As with the outer level, one
authentication set  or mechanism is typically chosen for client
authentication, along with auxiliary mechanisms such as KDC cookies,
and other mechanisms are ignored.  <a class='info' href='#comment.anchor5'>[anchor5]<span> (</span><span class='info'>Containers like this  need more thought.  For example if you are constructing an authentication set do you expect  to use a strengthen reply key mechanism  in conjunction with something else, do you include the something else in the hint of the strengthen mechanism or as its own entry.  It's easier to configure and express the authentication set as its own entry. However if you do that' the composition of the mechanisms looks in practice than it appears in the authentication set.</span><span>)</span></a><a name='anchor5'></a> The party generating the proposal can determine whether the
padata were processed based on whether the proposal for the reply key
is accepted.  
</p>
<p>The specific formats of the proposal message, including
where padata are included is a matter for the mechanism
specification.  Similarly, the format of the message accepting the
proposal is mechanism-specific.  
</p>
<p>Mechanisms implementing this facility and including a typed
hole for additional padata MUST checksum that padata using a keyed
checksum or encrypt the padata.  This requirement protects against modification of the contents of the typed hole.  By modifying these contents an attacker might be able to choose which mechanism is used to authenticate the client, or to convince a party to provide text encrypted in a key that the attacker had manipulated.   It is important that mechanisms strengthen the reply key enough that using it to checksum padata is appropriate.  
</p>
<a name="replace-reply-key"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Replacing-reply-key Facility</h3>

<p>The Replace Reply Key facility replaces the key in which a
successful AS reply will be encrypted.    This facility can only be
used in cases where knowledge of the reply key is not used to
authenticate the client.  The new reply key MUST be communicated to
the client and the KDC in a secure manner.    Mechanisms implementing this
facility MUST mark the reply key as replaced in the
pre-authentication state.  Mechanisms implementing this facility MUST
either provide a mechanism to verify the KDC reply to the client or
mark the reply as unverified in the pre-authentication state.
Mechanisms implementing this facility SHOULD NOT be used if a previous
mechanism has used the reply key.
</p>
<p>As with the strengthening-reply-key facility, Kerberos
extensibility rules require that the reply key not be changed unless
both sides of the exchange understand the extension.  In the case of
this facility it will likely be more common for both sides to know
that the facility is available by the time that the new key is
available to be used.  However, mechanism designers can use a
container for padata in a proposal message as discussed in <a class='info' href='#strengthen-reply'>Section&nbsp;4.2<span> (</span><span class='info'>Strengthening-reply-key Facility</span><span>)</span></a> if appropriate.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
KDC-authentication Facility</h3>

<p>This facility verifies that the reply comes from the
    expected KDC.  In traditional Kerberos, the KDC and the client
    share a key, so if the KDC reply can be decrypted then the client
    knows that a trusted KDC responded.  Note that the client
    machine cannot trust the client unless the machine is presented with a
    service ticket for it (typically the machine can retrieve 
    this ticket by itself).  However, if the reply key is
    replaced, some mechanism is required to verify the KDC.
    Pre-authentication mechanisms providing this facility allow a 
    client to determine that the expected KDC has responded even after the reply key is replaced.
    They mark the pre-authentication state as having been
    verified.
</p>
<a name="requirements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Requirements for Pre-Authentication Mechanisms</h3>

<p>This section lists requirements for specifications of
      pre-authentication mechanisms. 
</p>
<p>For each message in the pre-authentication mechanism, the
      specification describes  the pa-type value to be used and the
      contents of the message.  The processing of the message by the
      sender and recipient is also specified.  This specification
      needs to include all modifications to the pre-authentication
      state.  
</p>
<p>Generally mechanisms have a message that can be sent in the 
      error data of the KDC_ERR_PREAUTH_REQUIRED error message or in an
      authentication set. If the client needs information such
      as trusted certificate authorities in order to determine if it can use the
      mechanism, then this information should be in that
      message.  In addition, such mechanisms should also define a
      pa-hint to be included in authentication sets.  Often,
      the same information included in the padata-value is
      appropriate to include in the pa-hint (as defined in <a class='info' href='#pa-authentication-set'>Section&nbsp;6.4<span> (</span><span class='info'>Pre-authentication Set</span><span>)</span></a>).
</p>
<p>In order to ease security analysis the mechanism
      specification should describe what facilities from this document
      are offered by the mechanism.   
      For each facility, 
      the security consideration section of the mechanism specification should
      show that the security requirements of that facility are met.
      This requirement is applicable to any FAST factor 
      that provides authentication information.
</p>
<p>Significant problems have resulted in the specification of
      Kerberos protocols because much of the KDC exchange is not
      protected against authentication.  The security considerations
      section should discuss unauthenticated plaintext attacks.  It
      should either show that plaintext is protected or discuss what
      harm an attacker could do by modifying the plaintext.   It is
      generally acceptable for an attacker to be able to cause the
      protocol negotiation to fail by modifying plaintext.  More
      significant attacks should be evaluated carefully.
</p>
<p>As discussed in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a>, there is no guarantee that a client will use the same KDCs for all messages in a conversation.  The mechanism specification needs to show why the mechanism is secure in this situation.  The hardest problem to deal with, especially for challenge/response mechanisms is to make sure that the same response cannot be replayed against two KDCs while allowing the client to talk to any KDC.  
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Tools for Use in Pre-Authentication Mechanisms</h3>

<p>This section describes common tools needed by multiple
        pre-authentication mechanisms. By using these tools
        mechanism designers can use a modular approach to specify
        mechanism details and ease security analysis. 
</p>
<a name="combine-key"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Combining Keys</h3>

<p> Frequently a weak key needs to be combined with a stronger key before use.                     
            For example, passwords are typically limited in size and insufficiently random,
            therefore it is desirable to increase the strength of the keys based on passwords by adding
            additional secrets. Additional source of secrecy may come from hardware tokens. 
</p>
<p>This section provides standard ways to combine two keys into one.
</p>
<p>KRB-FX-CF1() is defined to combine two pass-phrases. 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    KRB-FX-CF1(UTF-8 string, UTF-8 string) -&gt; (UTF-8 string)
    KRB-FX-CF1(x, y) -&gt; x || y
</pre></div>
<p> Where || denotes concatenation. The strength of the final key is roughly the 
 total strength of the individual keys being combined assuming that
 the string_to_key() function <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a> uses all its input evenly.
</p>
<p> An example usage of KRB-FX-CF1() is when a device provides random but short passwords, 
            the password is often combined with a personal identification number (PIN). The password and the PIN can be combined
            using KRB-FX-CF1().
</p>
<p> KRB-FX-CF2()  combines two protocol keys based on the pseudo-random() function defined in <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a>.
</p>
<p> Given two input keys, K1 and K2, where K1 and K2 can be of two different enctypes, the output
   key of KRB-FX-CF2(), K3, is derived as follows:                                                    
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    KRB-FX-CF2(protocol key, protocol key, octet string,
              octet string)  -&gt;  (protocol key)

    PRF+(K1, pepper1) -&gt; octet-string-1
    PRF+(K2, pepper2) -&gt; octet-string-2
    KRB-FX-CF2(K1, K2, pepper1, pepper2) -&gt;
           random-to-key(octet-string-1 ^ octet-string-2)
</pre></div>
<p>Where ^ denotes the exclusive-OR operation.  PRF+() is defined as follows:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  PRF+(protocol key, octet string) -&gt; (octet string)

  PRF+(key, shared-info) -&gt; pseudo-random( key,  1 || shared-info ) ||
                pseudo-random( key, 2 || shared-info ) ||
                pseudo-random( key, 3 || shared-info ) || ...
</pre></div>
<p>Here the counter value 1, 2, 3 and so on are encoded as a one-octet integer.
The pseudo-random() operation is specified by the enctype of the protocol key. 
PRF+() uses the counter to generate enough bits as needed by  the  random-to-key() <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a>
 function for the encryption type specified for the resulting key;
unneeded bits are removed from the tail.
</p>
<p> Mechanism designers MUST 
specify the values for the input parameter pepper1 and pepper2 when combining two keys using KRB-FX-CF2(). The pepper1 and pepper2
MUST be distinct so that if the two keys being combined are the same, the resulting
key is not a trivial key. 
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Protecting Requests/Responses</h3>

<p>Mechanism designers SHOULD protect clear text portions of pre-authentication data. 
        Various denial of service attacks and downgrade attacks against
   Kerberos are possible unless plaintexts are somehow protected against
   modification.  An early design goal of Kerberos Version 5 <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> was to
   avoid encrypting more of the authentication exchange that was
   required.  (Version 4 doubly-encrypted the encrypted part of a ticket
   in a KDC reply, for example.)  This minimization of encryption
   reduces the load on the KDC and busy servers.  Also, during the
   initial design of Version 5, the existence of legal restrictions on
   the export of cryptography made it desirable to minimize of the
   number of uses of encryption in the protocol.  Unfortunately,
   performing this minimization created numerous instances of
   unauthenticated security-relevant plaintext fields.
</p>
<p> If there is more than one roundtrip for an authentication
  exchange, mechanism designers need to allow
  either the client or the KDC to provide a checksum of all the messages exchanged on the wire in the conversation, and the checksum is then
  verified by the receiver.
</p>
<p> New mechanisms MUST NOT be hard-wired to use a specific algorithm. 
</p>
<p>Primitives defined in <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a> are RECOMMENDED for integrity protection and confidentiality.
 Mechanisms based on these primitives are crypto-agile as the result of using <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a>
along with <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>. The advantage afforded by crypto-agility is the ability to avoid a multi-year standardization and deployment cycle 
 to fix a problem that is specific to a particular algorithm, when real attacks do arise against that algorithm.
 
</p>
<p>Note that data used by FAST factors (defined in <a class='info' href='#fast'>Section&nbsp;6.5<span> (</span><span class='info'>Definition of Kerberos FAST Padata</span><span>)</span></a>) is encrypted in a protected channel, thus they do not share
 the un-authenticated-text issues with mechanisms designed as full-blown pre-authentication mechanisms. 
</p>
<a name="kdc-state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Managing States for the KDC</h3>

<p> Kerberos KDCs are stateless.  There is no requirement that clients
    will choose the same KDC for the second request in a
    conversation.  Proxies or other intermediate nodes may also
    influence KDC selection.  So, each request from a client to a
    KDC must include sufficient information that the KDC can
    regenerate any needed state.    This is accomplished by giving
    the client a potentially long opaque cookie in responses
    to include in future requests in the same conversation.   The
    KDC MAY respond that a conversation is too old and needs to
    restart by responding with a KDC_ERR_PREAUTH_EXPIRED error.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    KDC_ERR_PREAUTH_EXPIRED            TBA
</pre></div>
<p>When a client receives this error, the client SHOULD abort the existing conversation, and restart a new one.
</p>
<p>   
An example, where more than one message from the client is needed, is when
 the client is authenticated based on a challenge-response scheme. In that case, the KDC
 needs to keep track of the challenge issued for a client authentication request. 
</p>
<p> The PA-FX-COOKIE pdata type is defined in this section to
facilitate state management.   This padata is sent by the KDC when
the KDC requires state for a future transaction.  The client includes
this opaque token in the next message in the conversation.  The token
may be relatively large; clients MUST be prepared for tokens somewhat
larger than the size of all messages in a conversation.  
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    PA_FX_COOKIE                       TBA
        -- Stateless cookie that is not tied to a specific KDC.
</pre></div>
<p> The corresponding padata-value field <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> contains the Distinguished Encoding Rules 
(DER) [X60] [X690] encoding of the following 
Abstract Syntax Notation One (ASN.1) type PA-FX-COOKIE: 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     PA-FX-COOKIE ::= SEQUENCE {
         conversationId  [0] OCTET STRING,
            -- Contains the identifier of this conversation. This field
            -- must contain the same value for all the messages
            -- within the same conversation.
         enc-binding-key [1] EncryptedData OPTIONAL,
                         -- EncryptionKey --
            -- This field is present when and only when a FAST
            -- padata as defined in Section 6.5 is included.
            -- The encrypted data, when decrypted, contains an
            -- EncryptionKey structure.
            -- This encryption key is encrypted using the armor key
            -- (defined in Section 6.5.1), and the key usage for the
            -- encryption is KEY_USAGE_FAST_BINDING_KEY.
            -- Present only once in a converstation.
         cookie          [2] OCTET STRING OPTIONAL,
            -- Opaque data, for use to associate all the messages in
            -- a single conversation between the client and the KDC.
            -- This is generated by the KDC and the client MUST copy
            -- the exact cookie encapsulated in a PA_FX_COOKIE data
            -- element into the next message of the same conversation.
         ...
     }
     KEY_USAGE_FAST_BINDING_KEY         TBA
</pre></div>
<p>The conversationId field contains a sufficiently-long rand number that uniquely identifies
the conversation. If a PA_FX_COOKIE padata is present in one message, 
a PA_FX_COOKIE structure MUST be present in all subsequent messages of the same converstation between
the client and the KDC, with the same
conversationId value.
</p>
<p> The enc-binding-key field is present when and only when a FAST padata (defined in <a class='info' href='#fast'>Section&nbsp;6.5<span> (</span><span class='info'>Definition of Kerberos FAST Padata</span><span>)</span></a>) is included.
The enc-binding-key field is present only once in a conversation. It MUST be ignored if it is present in a subsequent message
of the same conversation.
The encrypted data, when decrypted, contains an EncryptionKey structure that is called the binding key.
 The binding key is encrypted using the armor key (defined in <a class='info' href='#armor_key'>Section&nbsp;6.5.1<span> (</span><span class='info'>FAST Armors</span><span>)</span></a>), 
 and the key usage for the encryption is KEY_USAGE_FAST_BINDING_KEY.
</p>
<p>If a Kerberos FAST padata as defined in <a class='info' href='#fast'>Section&nbsp;6.5<span> (</span><span class='info'>Definition of Kerberos FAST Padata</span><span>)</span></a> is included in one message, it MUST be included in all subsequent messages
of the same conversation.
</p>
<p>When FAST padata as defined <a class='info' href='#fast'>Section&nbsp;6.5<span> (</span><span class='info'>Definition of Kerberos FAST Padata</span><span>)</span></a> is included, the PA-FX-COOKIE padata MUST be included.
</p>
<p>The cookie token is generated by the KDC and the client MUST copy the exact cookie encapsulated in a PA_FX_COOKIE data 
element into the next message of the same conversation. The content of the cookie field is a local matter of the
KDC.  However the KDC MUST construct the cookie token in such a manner that a
malicious client cannot subvert the authentication process by
manipulating the token. The KDC implementation needs to consider
expiration of tokens, key rollover and other security issues in token
design. The content of the cookie field is likely specific to the pre-authentication
mechanisms used to authenticate the client. 
If a client authentication response can be replayed to multiple KDCs via 
the PA_FX_COOKIE mechanism, an expiration in the cookie
is RECOMMENDED to prevent the response being presented indefinitely.
</p>
<p>If at least one more message for a mechanism or a mechanism set is expected by the KDC, the KDC returns a KDC_ERR_MORE_PREAUTH_DATA_NEEDED error
with a PA_FX_COOKIE to identify the conversation with the client according to <a class='info' href='#err'>Section&nbsp;6.5.4<span> (</span><span class='info'>Authenticated Kerberos Error Messages using Kerberos FAST</span><span>)</span></a>. 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KDC_ERR_MORE_PREAUTH_DATA_NEEDED   TBA
</pre></div>
<a name="pa-authentication-set"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Pre-authentication Set</h3>

<p>If all mechanisms in a group need to successfully complete
    in order to authenticate a 
    client, the client and the KDC SHOULD use the PA_AUTHENTICATION_SET padata element.
</p>
<p> A PA_AUTHENTICATION_SET padata element contains the ASN.1 DER encoding of the PA-AUTHENTICATION-SET
    structure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     PA-AUTHENTICATION-SET ::= SEQUENCE OF PA-AUTHENTICATION-SET-ELEM

     PA-AUTHENTICATION-SET-ELEM ::= SEQUENCE {
         pa-type      [0] Int32,
             -- same as padata-type.
         pa-hint      [1] OCTET STRING,
             -- hint data.
         ...
     }
</pre></div>
<p>The pa-type field of the PA-AUTHENTICATION-SET-ELEM structure contains the corresponding value of
        padata-type in PA-DATA <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>. Associated with the pa-type is a pa-hint, which is an octet-string
        specified by the pre-authentication mechanism.  This hint may
        provide information for the client which helps it determine
        whether the mechanism can be used.  For example a public-key
        mechanism might include the certificate authorities it trusts
        in the hint info.  Most mechanisms today do not specify hint
        info; if a mechanism does not specify hint info the KDC MUST
        NOT send a hint for that mechanism.  To allow future revisions
        of mechanism specifications to add hint info, clients MUST
        ignore hint info received for mechanisms that the client
        believes do not support hint info. If a member of the pre-authentication mechanism set that requires a
        challenge, a separate padata that carries the challenge SHOULD be included along with the pre-authentication set padata. 
</p>
<p>The PA-AUTHENTICATION-SET appears only in the first message  from the KDC to
        the client.  In particular, the client should not be prepared
        for the future authentication mechanisms to change as the
        conversation progresses.  <a class='info' href='#comment.anchor9'>[anchor9]<span> (</span><span class='info'>I think this is correct; we should discuss and if the WG agrees the text should reflect this.</span><span>)</span></a><a name='anchor9'></a>
</p>
<p>When indicating which sets of pre-authentication mechanisms are supported, the KDC includes a PA-AUTHENTICATION-SET padata element
    for each pre-authentication mechanism set.
</p>
<p> The client sends the
        padata-value for the first mechanism it picks in the
        pre-authentication set, when the first mechanism completes, the client and the
        KDC will proceed with the second mechanism, and so on until all mechanisms complete successfully.
        The PA_FX_COOKIE as defined in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a> MUST be sent by the KDC along with the first message
        that contains a PA-AUTHENTICATION-SET, in order to keep track of KDC states.
</p>
<p>Before the authentication succeeds and
         a ticket is returned, the message that the client sends is an AS_REQ and the message that the KDC sends is a KRB-ERROR message. 
         The error code in the KRB-ERROR message from the KDC is KDC_ERR_MORE_PREAUTH_DATA_NEEDED as defined in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a> and the accompanying e-data contains
         the DER encoding of ASN.1 type METHOD-DATA. The KDC includes the padata elements in the METHOD-DATA. If there is no padata, the e-data field is 
         absent in the KRB-ERROR message.
</p>
<p>If one mechanism completes on the client side, and the client expects the KDC to send the next padata for the next pre-authentication mechanism before the authentication
         succeeds, the client
         sends an AS_REQ with a padata of type PA_FX_HEARTBEAT. 
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     PA_FX_HEARTBEAT                    TBA
</pre></div>
<p>The padata-value for the PA_FX_HEARTBEAT is empty.
</p>
<p> If one mechanism completes on the KDC side, and the KDC expects the client to send the next padata for the next pre-authentication mechanism before the authentication
         succeeds, the KDC sends a KRB-ERROR message with the code KDC_ERR_MORE_PREAUTH_DATA_NEEDED and includes a padata of type PA_FX_HEARTBEAT. 
</p>
<p><a class='info' href='#comment.anchor10'>[anchor10]<span> (</span><span class='info'>It's much easier to design UIs if you can determine ahead of time what all the elements of your dialogue will need to be.    If we mandate that the pa-hints need to be sufficient that you can determine what information you will require from a user ahead of time we can simplify the UI for login.  I propose that we make this requirement.  WG agreement required.</span><span>)</span></a><a name='anchor10'></a>
</p>
<a name="fast"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5"></a><h3>6.5.&nbsp;
Definition of Kerberos FAST Padata</h3>

<p> As described in <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>, Kerberos is vulnerable to offline dictionary attacks.  An attacker can request an AS-REP 
and try various passwords to see if they can decrypt the resulting ticket.  
RFC 4120 provides the entrypted timestap  pre-authentication method that ameliorates the situation somewhat 
by requiring that an attacker observe a successful authentication.  However stronger security is desired in many environments.   
The Kerberos FAST pre-authentication padata defined in this section
provides a tool to significantly reduce vulnerability to offline dictionary attack.   When combined with encrypted timestamp, 
FAST requires an attacker to mount a successful man-in-the-middle attack to observe ciphertext.  When combined with host keys, 
FAST can even protect against active attacks.  FAST also provides solutions to common problems 
for pre-authentication mechanisms such as binding of the request and the reply,
freshness guarantee of the authentication. 
FAST itself, however, does not authenticate the client or the KDC, instead, it provides 
a typed hole to allow pre-authentication data be tunneled.
A pre-authentication data element used within FAST is called a  FAST factor.
A FAST factor captures the minimal work required for extending Kerberos to support a new pre-authentication scheme. 
</p>
<p> 
A FAST factor MUST NOT be used outside of FAST unless its specification explicitly
allows so.  The typed holes in FAST messages can also be
used as generic holes for other padata  that are not intended to prove the client's identity, or
establish the reply key.
</p>
<p>New pre-authentication mechanisms SHOULD be designed as FAST factors, instead
of full-blown pre-authentication mechanisms. 
</p>
<p>  FAST factors that are pre-authentication mechanisms MUST meet the
requirements in <a class='info' href='#requirements'>Section&nbsp;5<span> (</span><span class='info'>Requirements for Pre-Authentication Mechanisms</span><span>)</span></a>.
</p>
<p>FAST employs an armoring scheme. The armor can be a Ticket Granting Ticket (TGT)
obtained by the client's machine using the host keys to pre-authenticate with the KDC, or an anonymous
TGT obtained based on anonymous PKINIT <a class='info' href='#KRB-ANON'>[KRB&#8209;ANON]<span> (</span><span class='info'>Zhu, L. and P. Leach, &ldquo;Kerberos Anonymity Support,&rdquo; 2007.</span><span>)</span></a> <a class='info' href='#RFC4556'>[RFC4556]<span> (</span><span class='info'>Zhu, L. and B. Tung, &ldquo;Public Key Cryptography for Initial Authentication in Kerberos (PKINIT),&rdquo; June&nbsp;2006.</span><span>)</span></a>. 
</p>
<p>The rest of this section describes
the types of armors and the syntax of the messages used by FAST.
Conforming implementations MUST support Kerberos FAST padata.
</p>
<a name="armor_key"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.1"></a><h3>6.5.1.&nbsp;
FAST Armors</h3>

<p> An armor key is used to encrypt pre-authentication data in the FAST request and the response. 
The KrbFastArmor structure is defined to identify the armor key. 
This structure contains the following two fields: the armor-type identifies the type of armors, and the armor-value 
as an OCTET STRING contains the description of the armor scheme and the armor key.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KrbFastArmor ::= SEQUENCE {
         armor-type   [0] Int32,
             -- Type of the armor.
         armor-value  [1] OCTET STRING,
             -- Value of the armor.
         ...
     }
</pre></div>
<p>The value of the armor key is a matter of the armor type specification. 
Only one armor type is defined in this document.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     FX_FAST_ARMOR_AP_REQUEST           TBA
</pre></div>
<p> The FX_FAST_ARMOR_AP_REQUEST armor is based on Kerberos tickets.
</p>
<p>Conforming implementations MUST implement the FX_FAST_ARMOR_AP_REQUEST armor type.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.1.1"></a><h3>6.5.1.1.&nbsp;
Ticket-based Armors</h3>

<p>This is a ticket-based armoring scheme. The armor-type is FX_FAST_ARMOR_AP_REQUEST, the armor-value contains 
an ASN.1 DER encoded AP-REQ. The ticket in the AP-REQ is called an armor ticket or an armor TGT.
The subkey field in the AP-REQ MUST be present.
The armor key is the subkey in the AP-REQ authenticator. 
</p>
<p> The server name field of the armor ticket MUST identify the TGS of the target realm. 
 Here are three ways in the decreasing preference order how an armor TGT SHOULD be obtained:
<br />
<br />

</p>
<ol class="text">
<li>If the client is authenticating from a host machine whose Kerberos realm has a trust path to 
the client's realm, the host machine obtains a TGT by pre-authenticating intitialy the realm of the host machine using the host keys. If the client's realm is different
than the realm of the local host, the machine then obtains a cross-realm TGT to the client's realm as the armor ticket. Otherwise, the host's primary TGT is the armor ticket.
<br />
<br />


</li>
<li>If the client's host machine cannot obtain a host ticket strictly based on RFC4120, 
but  the KDC has an asymmetric signing key that the client can verify the binding between the public key of the signing key and the 
expected KDC,  the client can use anonymous PKINIT <a class='info' href='#KRB-ANON'>[KRB&#8209;ANON]<span> (</span><span class='info'>Zhu, L. and P. Leach, &ldquo;Kerberos Anonymity Support,&rdquo; 2007.</span><span>)</span></a> <a class='info' href='#RFC4556'>[RFC4556]<span> (</span><span class='info'>Zhu, L. and B. Tung, &ldquo;Public Key Cryptography for Initial Authentication in Kerberos (PKINIT),&rdquo; June&nbsp;2006.</span><span>)</span></a>  to authenticate the KDC and obtain an anonymous TGT as the armor ticket. 
The armor key can be a cross-team TGT obtained based on the initial primary TGT obtained using anonymous PKINIT with KDC authentication.
<br />
<br />


</li>
<li>Otherwise, the client uses anonymous PKINIT to get an anonymous TGT without KDC authentication and that TGT is the armor ticket. 
Note that this mode of operation is vulnerable to man-in-the-middle attacks at the time of obtaining 
the initial anonymous armor TGT. The armor key can be a cross-team TGT obtained based on the initial primary TGT obtained using anonymous PKINIT without KDC authentication.

</li>
</ol><p>

</p>
<p>Because the KDC does not know if the client is able to
        trust the ticket it has, the KDC MUST
        initialize the pre-authentication state to an unverified KDC.
</p>
<a name="fastreq"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.2"></a><h3>6.5.2.&nbsp;
FAST Request</h3>

<p>A padata type PA_FX_FAST is defined for the Kerberos FAST pre-authentication padata. 
The corresponding padata-value field <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> contains the DER encoding of the ASN.1 type PA-FX-FAST-REQUEST.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     PA_FX_FAST                         TBA
         -- Padata type for Kerberos FAST

     PA-FX-FAST-REQUEST ::= CHOICE {
         armored-data [0] KrbFastArmoredReq,
         ...
     }

     KrbFastArmoredReq ::= SEQUENCE {
         armor        [0] KrbFastArmor OPTIONAL,
             -- Contains the armor that identifies the armor key.
             -- MUST be present in AS-REQ.
             -- MUST be absent in TGS-REQ.
         req-checksum [1] Checksum,
             -- Checksum performed over the type KDC-REQ-BODY for
             -- the req-body field of the KDC-REQ structure defined in
             -- [RFC4120]
             -- The checksum key is the armor key, the checksum
             -- type is the required checksum type for the enctype of
             -- the armor key, and the key usage number is
             -- KEY_USAGE_FAST_REA_CHKSUM.
         enc-fast-req [2] EncryptedData, -- KrbFastReq --
             -- The encryption key is the armor key, and the key usage
             -- number is KEY_USAGE_FAST_ENC.
         ...
     }

     KEY_USAGE_FAST_REA_CHKSUM          TBA
     KEY_USAGE_FAST_ENC                 TBA
</pre></div>
<p> The PA-FX-FAST-REQUEST structure contains a KrbFastArmoredReq type.
The KrbFastArmoredReq encapsulates the encrypted padata.
</p>
<p>The enc-fast-req field contains an encrypted KrbFastReq structure. The armor key is used to encrypt the KrbFastReq structure, and
the key usage number for that encryption is KEY_USAGE_FAST_ARMOR.  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KEY_USAGE_FAST_ARMOR               TBA
</pre></div>
<p>The armor key is selected as follows:
<br />
<br />

</p>
<ul class="text">
<li>In an AS request, the armor field in the KrbFastArmoredReq structure MUST be present and the armor key is
identified according to the specification of the armor type.
<br />
<br />


</li>
<li>In a TGS request, the armor field in the KrbFastArmoredReq structure MUST NOT be present and the subkey in the
 AP-REQ authenticator in the PA-TGS-REQ PA-DATA MUST be present.  In this case, the armor key is that subkey in the 
 AP-REQ authenticator.
</li>
</ul><p>

</p>
<p> The req-checksum field contains a checksum
that is performed over the type KDC-REQ-BODY for the req-body field of the KDC-REQ <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> structure of the containing message. 
The checksum key is the armor key, and the checksum type is the required checksum type for the enctype of the 
armor key per <a class='info' href='#RFC3961'>[RFC3961]<span> (</span><span class='info'>Raeburn, K., &ldquo;Encryption and Checksum Specifications for Kerberos 5,&rdquo; February&nbsp;2005.</span><span>)</span></a>. <a class='info' href='#comment.anchor12'>[anchor12]<span> (</span><span class='info'>Is this checksum still needed if we include a full kdc-req-body</span><span>)</span></a><a name='anchor12'></a>
</p>
<p>The KrbFastReq structure contains the following information:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KrbFastReq ::= SEQUENCE {
         fast-options [0] FastOptions,
             -- Additional options.
         padata       [1] SEQUENCE OF PA-DATA,
             -- padata typed holes.
         req-body     [2] KDC-REQ-BODY,
             -- Contains the KDC request body as defined in Section
             -- 5.4.1 of [RFC4120].  The req-body field in the KDC-REQ
             -- structure [RFC4120] MUST be ignored.
             -- The client name and realm in the KDC-REQ [RFC4120]
             -- MUST NOT be present for AS-REQ and TGS-REQ when
             -- Kerberos FAST padata is included in the request.
         ...
     }
</pre></div>
<p><a class='info' href='#comment.anchor13'>[anchor13]<span> (</span><span class='info'>See mailing list discussion about whether client name absent is correct.</span><span>)</span></a><a name='anchor13'></a>
</p>
<p>The fast-options field indicates various options that are to modify the behavior of the KDC. The following options are defined:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     FastOptions ::= KerberosFlags
         -- reserved(0),
         -- anonymous(1),
         -- kdc-referrals(16)
</pre></div><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    Bits    Name          Description
   -----------------------------------------------------------------
    0     RESERVED        Reserved for future expansion of this field.
    1     anonymous       Requesting the KDC to hide client names in
                          the KDC response, as described next in this
                          section.
    16    kdc-referrals   Requesting the KDC to follow referrals, as
                          described next in this section.
</pre></div>
<p>Bits 1 through 15 (with bit 2 and bit 15 included) are critical options. If the KDC does not
support a critical option, it MUST fail the request with KDC_ERR_UNKNOWN_CRITICAL_FAST_OPTIONS (there is no accompanying e-data defined in this document for this error code). Bit 16 and onward (with bit 16 included) are 
non-critical options. KDCs conforming to this specification ignores unknown non-critical options.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KDC_ERR_UNKNOWN_FAST_OPTIONS       TBA
</pre></div>
<p></p>
<blockquote class="text"><dl>
<dt>The anonymous Option</dt>
<dd> <br />


The Kerberos response defined in <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> contains the client identity in clear text, 
This makes traffic analysis straightforward. 
The anonymous option is designed to complicate traffic analysis.

If the anonymous option is set, the KDC implementing PA_FX_FAST MUST identify the client 
as the anonymous principal in the KDC reply and the error response.
Hence this option is set by the client if it wishes to conceal the client identity in the KDC response.<br />
<br />


</dd>
<dt>The kdc-referrals Option</dt>
<dd> <br />



    The Kerberos client described in <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> 
        has to request referral TGTs 
        along the authentication path in order to get
        a service ticket for the target service. The Kerberos client
        described in the <a class='info' href='#REFERRALS'>[REFERRALS]<span> (</span><span class='info'>Raeburn, K. and L. Zhu, &ldquo;Generating KDC Referrals to Locate Kerberos Realms,&rdquo; 2007.</span><span>)</span></a> need to contact
        the AS specified in the error response in order to complete
        client referrals.

   The kdc-referrals option is designed to minimize
   the number of messages that need to be processed by the client.
   This option is useful when, for example, the client may contact
   the KDC via a satellite link that has high network latency, or the
   client has limited computational capabilities.
If the kdc-referrals option is set, the KDC that honors this option
 acts as the client to follow AS referrals and TGS referrals <a class='info' href='#REFERRALS'>[REFERRALS]<span> (</span><span class='info'>Raeburn, K. and L. Zhu, &ldquo;Generating KDC Referrals to Locate Kerberos Realms,&rdquo; 2007.</span><span>)</span></a>,
 and return the service ticket to the named server principal in the client request using the reply key expected by the client.
 The kdc-referrals option can be implemented when the KDC knows the reply key.
 The KDC can ignore kdc-referrals option when it does not understand it or it
 does not allow this option based on local policy. The client
 SHOULD be able to process the KDC responses when this option is not honored
 by the KDC.
</dd>
</dl></blockquote><p>

</p>
<p> The padata field contains a list of PA-DATA structures as described in
Section 5.2.7 of <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>. These PA-DATA structures
can contain FAST factors. They can also be used as generic typed-holes 
to contain data not intended for proving the client's identity or establishing a reply key,
but for protocol extensibility. 
</p>
<p> The KDC-REQ-BODY in the FAST structure is used in preference to the KDC-REQ-BODY outside of the FAST pre-authentication.  
This outer structure SHOULD be filled in for backwards compatibility with KDCs that do not support FAST.  The client
MAY fill in the cname and crealm fields in the kdc-req-body in the KrbFastReq structure and leave the cname field and the crealm field in KDC-REQ absent, 
in order to conceal the client's identity in the AS-REQ.<a class='info' href='#comment.anchor14'>[anchor14]<span> (</span><span class='info'>Absent is probably wrong.  Presumably we want a name similar to the anonymous principal name.</span><span>)</span></a><a name='anchor14'></a>
</p>
<a name="fastrep"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.3"></a><h3>6.5.3.&nbsp;
FAST Response</h3>

<p> The KDC that supports the PA_FX_FAST padata MUST include a PA_FX_FAST padata element in the KDC reply. In the case of an error,
the PA_FX_FAST padata is included in the KDC responses according to <a class='info' href='#err'>Section&nbsp;6.5.4<span> (</span><span class='info'>Authenticated Kerberos Error Messages using Kerberos FAST</span><span>)</span></a>.
</p>
<p>The corresponding padata-value field <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> for the PA_FX_FAST in the KDC response contains
the DER encoding of the ASN.1 type PA-FX-FAST-REPLY.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     PA-FX-FAST-REPLY ::= CHOICE {
         armored-data [0] KrbFastArmoredRep,
         ...
     }

     KrbFastArmoredRep ::= SEQUENCE {
         enc-fast-rep      [0] EncryptedData, -- KrbFastResponse --
             -- The encryption key is the armor key in the request, and
             -- the key usage number is KEY_USAGE_FAST_REP.
         ...
     }
     KEY_USAGE_FAST_REP                 TBA
</pre></div>
<p>The PA-FX-FAST-REPLY structure contains a KrbFastArmoredRep structure. 
The KrbFastArmoredRep structure encapsulates the padata in the KDC reply in the encrypted form.
The KrbFastResponse is encrypted with the armor key used 
in the corresponding request, and the key usage number is KEY_USAGE_FAST_REP.
</p>
<p>The Kerberos client who does not receive a PA-FX-FAST-REPLY in the KDC response
 MUST support a local policy that rejects the response. Clients MAY
 also support policies  that fall back to other mechanisms or that do
 not use pre-authentication  when FAST is unavailable.  It is
 important to consider the potential downgrade attacks when deploying
 such a policy. 
</p>
<p> The KrbFastResponse structure contains the following information:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KrbFastResponse ::= SEQUENCE {
         padata      [0] SEQUENCE OF PA-DATA,
             -- padata typed holes.
         rep-key     [1] EncryptionKey OPTIONAL,
             -- This, if present, replaces the reply key for AS and TGS.
             -- MUST be absent in KRB-ERROR.
         finished    [2] KrbFastFinished OPTIONAL,
             -- MUST be present if the client is authenticated,
             -- absent otherwise.
             -- Typically this is present if and only if the containing
             -- message is the last one in a conversation.
         ...
     }
</pre></div>
<p> The padata field in the KrbFastResponse structure contains a list of PA-DATA structures as described in
Section 5.2.7 of <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>. These PA-DATA structures
are used to carry data advancing the exchange specific for the FAST factors. They can also be used as generic typed-holes 
for protocol extensibility. 
</p>
<p> The rep-key field, if present, contains the reply key that is used to encrypted the KDC reply. The rep-key field
MUST be absent in the case where an error occurs. The enctype of the rep-key is the strongest mutually supported by
the KDC and the client.
</p>
<p>The finished field contains a KrbFastFinished structure. 
It is filled by the KDC in the final message in the conversation;
it MUST be absent otherwise. In other words, 
this field can only be present in an AS-REP or a TGS-REP when a ticket is returned. 
</p>
<p>The KrbFastFinished structure contains the following information:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KrbFastFinished ::= SEQUENCE {
         timestamp   [0] KerberosTime,
         usec        [1] Microseconds,
             -- timestamp and usec represent the time on the KDC when
             -- the reply was generated.
         crealm      [2] Realm,
         cname       [3] PrincipalName,
             -- Contains the client realm and the client name.
         checksum    [4] Checksum,
             -- Checksum performed over all the messages in the
             -- conversation, except the containing message.
             -- The checksum key is the binding key as defined in
             -- Section 6.3, and the checksum type is the required
             -- checksum type of the binding key.
         ...
     }
     KEY_USAGE_FAST_FINISHED            TBA
</pre></div>
<p> The timestamp and usec fields represent the time on the KDC when 
 the reply ticket was generated, these fields have the same semantics as the corresponding-identically-named fields in Section 5.6.1 of
<a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>. The client MUST use the KDC's time in these fields thereafter when using the returned ticket.
Note that the KDC's time in AS-REP may not match the authtime in the reply ticket 
if the kdc-referrals option is requested and honored by the KDC.
</p>
<p> The cname and crealm fields identify the authenticated client.
</p>
<p>The checksum field contains a checksum of all the messages in the conversation
 prior to the containing message (the containing message is excluded).  
 The checksum key is the binding key as defined in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a>, and the checksum type is the required checksum type of the enctype of that key, and
 the key usage number is KEY_USAGE_FAST_FINISHED. <a class='info' href='#comment.anchor15'>[anchor15]<span> (</span><span class='info'>Examples would be good here; what all goes into the checksum?</span><span>)</span></a><a name='anchor15'></a>
</p>
<p>When FAST padata is included, the PA-FX-COOKIE padata as defined in <a class='info' href='#kdc-state'>Section&nbsp;6.3<span> (</span><span class='info'>Managing States for the KDC</span><span>)</span></a> MUST also be included if the
KDC expects at least one more message from the client in order to complete the authentication.
</p>
<a name="err"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.4"></a><h3>6.5.4.&nbsp;
Authenticated Kerberos Error Messages using Kerberos FAST</h3>

<p>If the Kerberos FAST padata was included in the request, unless otherwise specified,  
      the e-data field of the KRB-ERROR message <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>  
  contains the ASN.1 DER encoding of the type METHOD-DATA <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> and a PA_FX_FAST is included in 
  the METHOD-DATA. The KDC MUST include all the padata elements such as PA-ETYPE-INFO2 and
  padata elments that indicate acceptable pre-authentication mechanisms <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> and in the KrbFastResponse structure.
</p>
<p>If the Kerberos FAST padata is included in the request but  not included in the error reply, it is a matter of the local
   policy on the client to accept the information in the error message without integrity protection.
   The Kerberos client MAY process
  an error message without a PA-FX-FAST-REPLY, if that is only intended to return 
  better error information to the application, typically for trouble-shooting purposes.
</p>
<p> In the cases where the e-data field of the KRB-ERROR message is expected to carry a TYPED-DATA <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> element, 
   the PA_FX_TYPED_DATA padata is included in the KrbFastResponse structure to encapsulate the
   TYPED-DATA <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> elements.  For example, the TD_TRUSTED_CERTIFIERS structure is expected to be in the KRB-ERROR message
   when the error code is KDC_ERR_CANT_VERIFY_CERTIFICATE <a class='info' href='#RFC4556'>[RFC4556]<span> (</span><span class='info'>Zhu, L. and B. Tung, &ldquo;Public Key Cryptography for Initial Authentication in Kerberos (PKINIT),&rdquo; June&nbsp;2006.</span><span>)</span></a>.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     PA_FX_TYPED_DATA                   TBA
         -- This is the padata element that encapsulates a TYPED-DATA
         -- structure.
</pre></div>
<p>The corresponding padata-value for the PA_FX_TYPED_DATA padata type contains the DER encoding of the ASN.1 type TYPED-DATA <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5.5"></a><h3>6.5.5.&nbsp;
The Authenticated Timestamp FAST Factor</h3>

<p>The encrypted time stamp <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a> padata can be used as a FAST factor to authenticate the client and it does not expose the cipher text derived using the client's long term keys.  
 However this FAST factor is not risk-free from current intellectual property claims as of the time of this writing. To 
provide a clearn replacement FAST factor that closely matches the encrypted timestamp FAST factor, the authenticated timestamp pre-authentication is 
introduced in this section.
</p>
<p>The authenticated timestamp FAST factor authenticates a client by means of computing a checksum over
   a time-stamped structure using the client's long term keys. The padata-type is  PA_AUTHENTICATED_TIMESTAMP and the corresponding
   padata-value contains the DER encoding of ASN.1 type  AuthenticatedTimestamp.  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     AuthenticatedTimestampToBeSigned ::= SEQUENCE {
         timestamp   [0] PA-ENC-TS-ENC,
             -- Contains the timestamp field of the corresponding
             -- AuthenticatedTimestamp structure.
         req-body    [1] KDC-REQ-BODY OPTIONAL,
             -- MUST contain the req-body field of the KDC-REQ
             -- structure in the containing AS-REQ for the client
             -- request.
             -- MUST be Absent for the KDC reply.
         ...
     }

     AuthenticatedTimestamp ::= SEQUENCE {
         timestamp   [0] PA-ENC-TS-ENC,
             -- Filled out according to Section 5.2.7.2 of [RFC4120].
             -- Contains the client's current time for the client,
             -- and the KDC's current time for the KDC.
         checksum    [1] CheckSum,
             -- The checksum is performed over the type
             -- AuthenticatedTimestampToBeSigned and the key usage is
             -- KEY_USAGE_AUTHENTICATED_TS_CLIENT for the client and
             _ KEY_USAGE_AUTHENTICATED_TS_KDC for the KDC
         ...
     }

     KEY_USAGE_AUTHENTICATED_TS_CLIENT  TBA
     KEY_USAGE_AUTHENTICATED_TS_KDC     TBA
</pre></div>
<p>The client fills out the AuthenticatedTimestamp structure as follows:
</p>
<p> </p>
<ul class="text">
<li>The timestamp field in the AuthenticatedTimestamp structure is filled out 
with the client's current time according to Section 5.2.7.2 of <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>.<br />
<br />


</li>
<li> The checksum field in the AuthenticatedTimestamp structure is performed over the type
AuthenticatedTimestampToBeSigned. The checksum key is one of the client's long term keys.
The key usage for the checksum operation is KEY_USAGE_AUTHENTICATED_TS_CLIENT. The checksum type is the required checksum
type for the strongest enctype mutually supported by the client and the KDC.<br />
<br />


</li>
<li>Within the AuthenticatedTimestampToBeSigned structure, the timestamp field 
  contains the timestamp field of the corresponding AuthenticatedTimestamp structure,
 and the req-body field  MUST contain the req-body field 
of the KDC-REQ structure in the containing AS-REQ.
</li>
</ul>

<p>Upon receipt of the PA_AUTHENTICATED_TIMESTAMP FAST factor, 
the KDC MUST process the padata in a way similar to that of the encrypted timestamp padata. The KDC MUST
verify the checksum in the AuthenticatedTimestamp structure and the timestamp
is within the window of acceptable clock skew for the KDC.
</p>
<p> When the authenticated timestamp FAST factor is accepted by the KDC, the KDC MUST include
a PA_AUTHENTICATED_TIMESTAMP as a FAST factor in in a successful KDC reply and it MUST include
the rep-key field as defined in <a class='info' href='#fastrep'>Section&nbsp;6.5.3<span> (</span><span class='info'>FAST Response</span><span>)</span></a>.
</p>
<p>The KDC fills out the AuthenticatedTimestamp structure as follows:
</p>
<p> </p>
<ul class="text">
<li>The timestamp field in the AuthenticatedTimestamp structure is filled out 
with the KDC's current time according to Section 5.2.7.2 of <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>.<br />
<br />


</li>
<li> The checksum field in the AuthenticatedTimestamp structure is performed over the type
AuthenticatedTimestampToBeSigned. The checksum key is the reply key picked from the client's long term keys
according to <a class='info' href='#RFC4120'>[RFC4120]<span> (</span><span class='info'>Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;The Kerberos Network Authentication Service (V5),&rdquo; July&nbsp;2005.</span><span>)</span></a>.
The key usage for the checksum operation is KEY_USAGE_AUTHENTICATED_TS_KDC. The checksum type is the required checksum
type for the checksum key.<br />
<br />


</li>
<li>Within the AuthenticatedTimestampToBeSigned structure, the timestamp field 
  contains the timestamp field of the corresponding AuthenticatedTimestamp structure,
 and the req-body field MUST be absent.
</li>
</ul>

<p> Upon receipt of the PA_AUTHENTICATED_TIMESTAMP FAST factor in the KDC reply, 
the client MUST verify the checksum in the AuthenticatedTimestamp structure and the timestamp
is within the window of acceptable clock skew for the client. The successful verificaiton of the
PA_AUTHENTICATED_TIMESTAMP padata authenticates the KDC.
</p>
<p> The authenticated timestamp FAST factor provides the following facilities:
client-authentication, replacing-reply-key, KDC-authentication. It does not provide
the strengthening-reply-key facility. The security considerations section of this document
provides an explanation why the security requirements are met.
</p>
<p>Conforming implementations MUST support the authenticated timestamp FAST factor.
</p>
<a name="auth-strength"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.6"></a><h3>6.6.&nbsp;
Authentication Strength Indication</h3>

<p> Implementations that
    have pre-authentication mechanisms offering significantly
    different strengths of client authentication MAY choose to
    keep track of the strength of the authentication used as an
    input into policy decisions.  For example, some principals
    might require strong pre-authentication, while less sensitive
    principals can use relatively weak forms of pre-authentication
    like encrypted timestamp.  

</p>
<p> An AuthorizationData data type AD-Authentication-Strength is defined for this purpose.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     AD-authentication-strength         TBA
</pre></div>
<p> The corresponding ad-data field contains the DER encoding of the pre-authentication
data set as defined in <a class='info' href='#pa-authentication-set'>Section&nbsp;6.4<span> (</span><span class='info'>Pre-authentication Set</span><span>)</span></a>. 
This set contains all the pre-authentication mechanisms that were used to authenticate the client. If only
one pre-authentication mechanism was used to authenticate the client,
the pre-authentication set contains one element.
</p>
<p>The AD-authentication-strength element
MUST be included in the AD-IF-RELEVANT, thus it can be ignored if it is unknown to the receiver.
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This document defines several new pa-data types, key usages and error codes.  
      In addition it would be good to track which pa-data items are only to be used as  FAST factors.  
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p> The kdc-referrals option in the Kerberos FAST padata requests the KDC 
    to act as the client to follow referrals. This can overload the KDC.
    To limit the damages of denied of service using this option, 
    KDCs MAY restrict the number of simultaneous active requests with this option
    for any given client principal.
</p>
<p>Because the client secrets are known only to the client and the KDC,
    the verification of the authenticated timestamp proves the client's identity,
    the verification of the authenticated timestamp in the KDC reply 
    proves that the expected KDC responded. The encrypted reply key is contained in the rep-key
    in the PA-FX-FAST-REPLY. Therefore, the authenticated timestamp FAST factor as
    a pre-authentication mechanism offers the following facilities: client-authentication, replacing-reply-key,
    KDC-authentication. There is no un-authenticated clear text introduced
    by the authenticated timestamp FAST factor.
</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p> Several suggestions from Jeffery Hutzman based on early revisions of this documents
    led to significant improvements of this document.
</p>
<p>The proposal to ask one KDC to chase down the referrals and return the final ticket is based on requirements in <a class='info' href='#ID.CROSS'>[ID.CROSS]<span> (</span><span class='info'>Sakane, S., Zrelli, S., and M. Ishiyama , &ldquo;Problem Statement on the Operation of Kerberos in a Specific System,&rdquo; April&nbsp;2007.</span><span>)</span></a>.
</p>
<p>Joel Webber had a proposal for a mechanism similar to FAST that created a protected tunnel  for Kerberos pre-authentication.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="KRB-ANON">[KRB-ANON]</a></td>
<td class="author-text">Zhu, L. and P. Leach, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-anon-04.txt.txt">Kerberos Anonymity Support</a>,&rdquo; draft-ietf-krb-wg-anon-04.txt (work in progress), 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="REFERRALS">[REFERRALS]</a></td>
<td class="author-text">Raeburn, K. and L. Zhu, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-referrals-10.txt.txt">Generating KDC Referrals to Locate Kerberos Realms</a>,&rdquo; draft-ietf-krb-wg-kerberos-referrals-10.txt (work in progress), 2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3961">[RFC3961]</a></td>
<td class="author-text">Raeburn, K., &ldquo;<a href="http://tools.ietf.org/html/rfc3961">Encryption and Checksum Specifications for Kerberos 5</a>,&rdquo; RFC&nbsp;3961, February&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3961.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4120">[RFC4120]</a></td>
<td class="author-text">Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &ldquo;<a href="http://tools.ietf.org/html/rfc4120">The Kerberos Network Authentication Service (V5)</a>,&rdquo; RFC&nbsp;4120, July&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4120.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4556">[RFC4556]</a></td>
<td class="author-text">Zhu, L. and B. Tung, &ldquo;<a href="http://tools.ietf.org/html/rfc4556">Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)</a>,&rdquo; RFC&nbsp;4556, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4556.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ID.CROSS">[ID.CROSS]</a></td>
<td class="author-text">Sakane, S., Zrelli, S., and M. Ishiyama , &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-sakane-krb-cross-problem-statement-02.txt.txt">Problem Statement on the Operation of Kerberos in a Specific System</a>,&rdquo; draft-sakane-krb-cross-problem-statement-02.txt (work in progress), April&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="KRB-WG.SAM">[KRB-WG.SAM]</a></td>
<td class="author-text">Hornstein, K., Renard, K., Neuman, C., and G. Zorn, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-sam-02.txt.txt">Integrating Single-use Authentication Mechanisms with Kerberos</a>,&rdquo; draft-ietf-krb-wg-kerberos-sam-02.txt (work in progress), October&nbsp;2003.</td></tr>
</table>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
ASN.1 module</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
     KerberosPreauthFramework {
           iso(1) identified-organization(3) dod(6) internet(1)
           security(5) kerberosV5(2) modules(4) preauth-framework(3)
     } DEFINITIONS EXPLICIT TAGS ::= BEGIN

     IMPORTS
          KerberosTime, PrincipalName, Realm, EncryptionKey, Checksum,
          Int32, EncryptedData, PA-ENC-TS-ENC, PA-DATA, KDC-REQ-BODY
               FROM KerberosV5Spec2 { iso(1) identified-organization(3)
                 dod(6) internet(1) security(5) kerberosV5(2)
                 modules(4) krb5spec2(2) };
                 -- as defined in RFC 4120.

     PA-FX-COOKIE ::= SEQUENCE {
         conversationId  [0] OCTET STRING,
            -- Contains the identifier of this conversation. This field
            -- must contain the same value for all the messages
            -- within the same conversation.
         enc-binding-key [1] EncryptedData OPTIONAL,
                         -- EncryptionKey --
            -- This field is present when and only when a FAST
            -- padata as defined in Section 6.5 is included.
            -- The encrypted data, when decrypted, contains an
            -- EncryptionKey structure.
            -- This encryption key is encrypted using the armor key
            -- (defined in Section 6.5.1), and the key usage for the
            -- encryption is KEY_USAGE_FAST_BINDING_KEY.
         cookie          [2] OCTET STRING OPTIONAL,
            -- Opaque data, for use to associate all the messages in
            -- a single conversation between the client and the KDC.
            -- This is generated by the KDC and the client MUST copy
            -- the exact cookie encapsulated in a PA_FX_COOKIE data
            -- element into the next message of the same conversation.
         ...
     }

     PA-AUTHENTICATION-SET ::= SEQUENCE OF PA-AUTHENTICATION-SET-ELEM

     PA-AUTHENTICATION-SET-ELEM ::= SEQUENCE {
         pa-type      [0] Int32,
             -- same as padata-type.
         pa-hint      [1] OCTET STRING,
             -- hint data.
         ...
     }

     KrbFastArmor ::= SEQUENCE {
         armor-type   [0] Int32,
             -- Type of the armor.
         armor-value  [1] OCTET STRING,
             -- Value of the armor.
         ...
     }

     PA-FX-FAST-REQUEST ::= CHOICE {
         armored-data [0] KrbFastArmoredReq,
         ...
     }

     KrbFastArmoredReq ::= SEQUENCE {
         armor        [0] KrbFastArmor OPTIONAL,
             -- Contains the armor that identifies the armor key.
             -- MUST be present in AS-REQ.
             -- MUST be absent in TGS-REQ.
         req-checksum [1] Checksum,
             -- Checksum performed over the type KDC-REQ-BODY for
             -- the req-body field of the KDC-REQ structure defined in
             -- [RFC4120]
             -- The checksum key is the armor key, the checksum
             -- type is the required checksum type for the enctype of
             -- the armor key, and the key usage number is
             -- KEY_USAGE_FAST_REA_CHKSUM.
         enc-fast-req [2] EncryptedData, -- KrbFastReq --
             -- The encryption key is the armor key, and the key usage
             -- number is KEY_USAGE_FAST_ENC.
         ...
     }

     KrbFastReq ::= SEQUENCE {
         fast-options [0] FastOptions,
             -- Additional options.
         padata       [1] SEQUENCE OF PA-DATA,
             -- padata typed holes.
         req-body     [2] KDC-REQ-BODY,
             -- Contains the KDC request body as defined in Section
             -- 5.4.1 of [RFC4120].  The req-body field in the KDC-REQ
             -- structure [RFC4120] MUST be ignored.
             -- The client name and realm in the KDC-REQ [RFC4120]
             -- MUST NOT be present for AS-REQ and TGS-REQ when
             -- Kerberos FAST padata is included in the request.
         ...
     }

     FastOptions ::= KerberosFlags
         -- reserved(0),
         -- anonymous(1),
         -- kdc-referrals(16)

     PA-FX-FAST-REPLY ::= CHOICE {
         armored-data [0] KrbFastArmoredRep,
         ...
     }

     KrbFastArmoredRep ::= SEQUENCE {
         enc-fast-rep [0] EncryptedData, -- KrbFastResponse --
             -- The encryption key is the armor key in the request, and
             -- the key usage number is KEY_USAGE_FAST_REP.
         ...
     }

     KrbFastResponse ::= SEQUENCE {
         padata      [0] SEQUENCE OF PA-DATA,
             -- padata typed holes.
         rep-key     [1] EncryptionKey OPTIONAL,
             -- This, if present, replaces the reply key for AS and TGS.
             -- MUST be absent in KRB-ERROR.
         finished    [2] KrbFastFinished OPTIONAL,
             -- MUST be present if the client is authenticated,
             -- absent otherwise.
             -- Typically this is present if and only if the containing
             -- message is the last one in a conversation.
         ...
     }

     KrbFastFinished ::= SEQUENCE {
         timestamp   [0] KerberosTime,
         usec        [1] Microseconds,
             -- timestamp and usec represent the time on the KDC when
             -- the reply was generated.
         crealm      [2] Realm,
         cname       [3] PrincipalName,
             -- Contains the client realm and the client name.
         checksum    [4] Checksum,
             -- Checksum performed over all the messages in the
             -- conversation, except the containing message.
             -- The checksum key is the binding key as defined in
             -- Section 6.3, and the checksum type is the required
             -- checksum type of the binding key.
         ...
     }

     AuthenticatedTimestampToBeSigned ::= SEQUENCE {
         timestamp   [0] PA-ENC-TS-ENC,
             -- Contains the timestamp field of the corresponding
             -- AuthenticatedTimestamp structure.
         req-body    [1] KDC-REQ-BODY OPTIONAL,
             -- MUST contain the req-body field of the KDC-REQ
             -- structure in the containing AS-REQ for the client
             -- request.
             -- MUST be Absent for the KDC reply.
         ...
     }

     AuthenticatedTimestamp ::= SEQUENCE {
         timestamp   [0] PA-ENC-TS-ENC,
             -- Filled out according to Section 5.2.7.2 of [RFC4120].
             -- Contains the client's current time for the client,
             -- and the KDC's current time for the KDC.
         checksum    [1] CheckSum,
             -- The checksum is performed over the type
             -- AuthenticatedTimestampToBeSigned and the key usage is
             -- KEY_USAGE_AUTHENTICATED_TS_CLIENT for the client and
             _ KEY_USAGE_AUTHENTICATED_TS_KDC for the KDC
         ...
     }
     END
</pre></div>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Larry Zhu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Microsoft Corporation</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">One Microsoft Way</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Redmond, WA  98052</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lzhu@microsoft.com">lzhu@microsoft.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sam hartman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">MIT</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hartmans@mit.edu">hartmans@mit.edu</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2007).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
