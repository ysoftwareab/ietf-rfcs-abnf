AGING = pow(2, (LG_AGING-30) ) * T_RES;   // lg([B/s]) to [B/T_RES]
CRITICALqL = CRITICALqL_us * 1000;        // [us] to [ns]
CRITICALqLSCORE = CRITICALqLSCORE_us * 1000/T_RES; // [us] to [T_RES]
CRITICALqLPRODUCT = CRITICALqL * CRITICALqLSCORE;
qLSCORE_MAX = 5E9 / T_RES;           // Max queuing score = 5 s

ATTEMPTS = 2; // Max attempts to pick a bucket (vendor-specific)
BI_SIZE = 5;  // Bit-width of index number for non-default buckets
NBUCKETS = pow(2, BI_SIZE);  // No. of non-default buckets
MASK = NBUCKETS-1;     // convenient constant, with BI_SIZE LSBs set

                          // Queue Protection exit states
EXIT_SUCCESS  = 0;     // Forward the packet
EXIT_SANCTION = 1;     // Redirect the packet

MAX_PROB      = 1; // For integer arithmetic, would use a large int
                      //  e.g., 2^31, to allow space for overflow
MAXTH = MAXTH_us * 1000;   // Max marking threshold [ns]
MAX_FRAME_SIZE = 2000;  // DOCSIS-wide constant [B]
FLOOR =  2 * 8 * MAX_FRAME_SIZE * 10^9 / MAX_RATE;
RANGE = (1 << LG_RANGE);      // Range of ramp [ns]
MINTH = max ( MAXTH - RANGE, FLOOR);
MAXTH = MINTH + RANGE;           // Max marking threshold [ns]
queue_id = classify(packet);
queue_id = CQ;
qdelay = qL.qdelay(...);
probNative = calcProbNative(qdelay);

bckt_id = pick_bucket(packet.uflow);
qLscore = fill_bucket(buckets[bckt_id], packet.size, probNative);

h32   = hash32(uflw);     // 32-bit hash of flow ID
hsav  = NBUCKETS;         // Default bucket
now   = get_time_now();   // in units of T_RES

h = h32 & MASK;
hsav = h;                  // set it as the interim bucket
now = get_time_now();                      // in units of T_RES
qLscore = min(buckets[bckt_id].t_exp - now
                    + probNative * pkt_sz / AGING, qLSCORE_MAX);
probNative = MAX_PROB;
probNative = MAX_PROB * (qdelay - MINTH)/RANGE;
probNative = 0;
NBUCKETS=32, it requires about 94 attack flows, each using different
