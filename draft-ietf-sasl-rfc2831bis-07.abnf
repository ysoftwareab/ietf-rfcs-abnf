digest-challenge  =
         1#( realm | nonce | qop-options | stale | server_maxbuf | charset
               algorithm | cipher-opts | auth-param )

realm             = "realm" "=" realm-value
realm-value       = quoted-string
nonce             = "nonce" "=" nonce-value
nonce-value       = quoted-string
                            ;; contains data described by "nonce-data"
qop-options       = "qop" "=" <"> qop-list <">
qop-list          = 1#qop-value
qop-value         = "auth" | "auth-int" | "auth-conf" |
                             qop-token
                             ;; qop-token is reserved for identifying future
                             ;; extensions to DIGEST-MD5
qop-token         = token
stale             = "stale" "=" "true"
server_maxbuf     = "maxbuf" "=" maxbuf-value
maxbuf-value      = 1*DIGIT
charset           = "charset" "=" "utf-8"
algorithm         = "algorithm" "=" "md5-sess"
cipher-opts       = "cipher" "=" <"> 1#cipher-value <">
cipher-value      = "rc4-40" | "rc4" | "rc4-56" |
                            "aes-cbc" | cipher-token
                             ;; cipher-token is reserved for new ciphersuites
cipher-token      = token
auth-param        = token "=" ( token | quoted-string )
nonce-data        = new-nonce-data | obs-nonce-data
new-nonce-data    = "CB-" channel-type ":" channel-bindings ":" nonce-octets
obs-nonce-data    = nonce-octets
                            ;; nonce value as defined in RFC 2831. Should be accepted
                            ;; must not be generated.
channel-type      = "TLS" / channel-type-ext
channel-type-ext  = 1*(ALPHA | DIGIT)
                            ;; for future channel bindings
channel-bindings  = 1*TEXTCHAR
                            ;; channel binding data as defined by the channel type
nonce-octets      = 1*TEXTCHAR

digest-response  = 1#( username | realm | nonce | cnonce |
                          nonce-count | qop | digest-uri | response |
                          client_maxbuf | charset | cipher | authzid |
                          auth-param )

username         = "username" "=" username-value
username-value   = quoted-string
cnonce           = "cnonce" "=" cnonce-value
cnonce-value     = nonce-value
nonce-count      = "nc" "=" nc-value
nc-value         = 8LHEX
client_maxbuf    = "maxbuf" "=" maxbuf-value
qop              = "qop" "=" qop-value
digest-uri       = "digest-uri" "=" <"> digest-uri-value <">
digest-uri-value  = serv-type "/" host [ "/" serv-name ]
serv-type        = 1*ALPHA
serv-name        = host
response         = "response" "=" response-value
response-value   = 32LHEX
LHEX             = "0" | "1" | "2" | "3" |
                          "4" | "5" | "6" | "7" |
                          "8" | "9" | "a" | "b" |
                          "c" | "d" | "e" | "f"
cipher           = "cipher" "=" cipher-value
authzid          = "authzid" "=" authzid-value
authzid-value    = quoted-string
host          = IP-literal / IPv4address / reg-name

response-value  =
         HEX( KD ( HEX(H(A1)),
                 { unq(nonce-value), ":" nc-value, ":",
                   unq(cnonce-value), ":", qop-value, ":", HEX(H(A2)) }))

A1 = { SS, ":", unq(nonce-value), ":",
             unq(cnonce-value), ":", unq(authzid-value) }

A1 = { SS, ":", unq(nonce-value), ":", unq(cnonce-value) }

password   = *OCTET

SS = H( { unq(username-value), ":", unq(realm-value), ":", password } )



A2       = { "AUTHENTICATE:", digest-uri-value }
A2       = { "AUTHENTICATE:", digest-uri-value,
               ":00000000000000000000000000000000" }

auth-info      = 1#( response-auth | auth-param )

response-auth = "rspauth" "=" response-value

A2 = { ":", digest-uri-value }

A2 = { ":", digest-uri-value, ":00000000000000000000000000000000" }
Kic = MD5({H(A1),
Kis = MD5({H(A1),
Kcc = MD5({H(A1)[0..n-1],
Kcs = MD5({H(A1)[0..n-1],
packet_type_data = 0x0001

IVc = MD5({Kcc, "aes-128"})

IVs = MD5({Kcs, "aes-128"})

E1 = CIPHER ( Kc, P1 XOR IV )
E2 = CIPHER ( Kc, P2 XOR E1 )
E3 = CIPHER ( Kc, P3 XOR E2 )
Ei = CIPHER ( Kc, Pi XOR Ei-1)
Em = CIPHER ( Kc, Pm XOR Em-1)

P1 = CIPHER ( Kc, E1 ) XOR IV
P2 = CIPHER ( Kc, E2 ) XOR E1
P3 = CIPHER ( Kc, E3 ) XOR E2
Pi = CIPHER ( Kc, Ei ) XOR Ei-1
Pm = CIPHER ( Kc, Em ) XOR Em-1

cnNldD11dGYtOA==
ZDRiYmQ3NjBhMTUyMzIxZjIxNDNhZjcscW9wPWF1dGg=
algorithm=md5-sess,charset=utf-8
nonce="OA6MG9tEQGm2hh",nc=00000001,cnonce="OA6MHXh6VqTrRk",
digest-uri="imap/elwood.innosoft.com",
response=d388dad90d4bbd760a152321f2143af7,qop=auth
algorithm=md5-sess,charset=utf-8
nonce="OA9BSXrbuRhWay",nc=00000001,cnonce="OA9BSuZWMSpW8m",
digest-uri="acap/elwood.innosoft.com",
response=6084c6db3fede7352c551284490fd0fc,qop=auth
name = definition
      The name of a rule is simply the name itself (without any
      enclosing "<" and ">") and is separated from its definition by the
      equal "=" character. White space is only significant in that
      indentation of continuation lines is used to indicate a rule
      definition that spans more than one line. Certain basic rules are
      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle
      brackets are used within definitions whenever their presence will
      facilitate discerning the use of rule names.

OCTET          = <any 8-bit character>
CHAR           = <any US-ASCII character (octets 0 - 127)>
UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
LOALPHA        = <any US-ASCII lowercase letter "a".."z">
ALPHA          = UPALPHA | LOALPHA
DIGIT          = <any US-ASCII digit "0".."9">
CTL            = <any US-ASCII control character
                        (octets 0 - 31) and DEL (127)>
CR             = <US-ASCII CR, carriage return (13)>
LF             = <US-ASCII LF, linefeed (10)>
SP             = <US-ASCII SP, space (32)>
HT             = <US-ASCII HT, horizontal-tab (9)>
TEXTCHAR       = <any OCTET except CTLs, but including HT>
CRLF           = CR LF

LWS            = [CRLF] 1*( SP | HT )

TEXT           = <any *OCTET except CTLs,
                        but including LWS>

HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

token          = 1*TOKENCHAR
separators     = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
TOKENCHAR      = <any CHAR except CTLs or separators>

quoted-string  = ( <"> qdstr-val <"> )
qdstr-val      = *( qdtext | quoted-pair )
qdtext         = <any TEXTCHAR except <"> and "\">

quoted-pair    = "\" CHAR

end = base + len;
cbuf = ((scan[0] & 0x3) << 6) | (scan[1] & 0x3f);
base = scan + 2;
