HTTPParametersSet = {
       ? owner: Owner

       ~HTTPParameters

       ; qlog-specific
       ; indicates whether this implementation waits for a SETTINGS
       ; frame before processing requests
       ? waits_for_settings: bool
HTTPParameters = {
       ? max_header_list_size: uint64
       ? max_table_capacity: uint64
       ? blocked_streams_count: uint64

       ; additional settings for grease and extensions
       * text => uint64
HTTPParametersRestored = {

       ~HTTPParameters

HTTPStreamTypeSet = {
       ? owner: Owner
       stream_id: uint64

       ? old: HTTPStreamType
       new: HTTPStreamType

       ; only when new === "push"
       ? associated_push_id: uint64
HTTPStreamType =  "data" /
                     "control" /
                     "push" /
                     "reserved" /
                     "qpack_encode" /
                     "qpack_decode"

                   Figure 3: HTTPStreamTypeSet definition
HTTPFrameCreated = {
       stream_id: uint64
       ? length: uint64
       frame: HTTPFrame
       ? raw: RawInfo
HTTPFrameParsed = {
       stream_id: uint64
       ? length: uint64
       frame: HTTPFrame
       ? raw: RawInfo
HTTPPushResolved = {
       ? push_id: uint64

       ; in case this is logged from a place that does not have access
       ; to the push_id
       ? stream_id: uint64

       decision: HTTPPushDecision
HTTPPushDecision = "claimed" / "abandoned"

                   Figure 6: HTTPPushResolved definition

QPACKStateUpdate = {
       owner: Owner
       ? dynamic_table_capacity: uint64

       ; effective current size, sum of all the entries
       ? dynamic_table_size: uint64
       ? known_received_count: uint64
       ? current_insert_count: uint64
QPACKStreamStateUpdate = {
       stream_id: uint64
       ; streams are assumed to start "unblocked"
       ; until they become "blocked"
       state: QPACKStreamState
QPACKStreamState = "blocked" / "unblocked"

                Figure 8: QPACKStreamStateUpdate definition
QPACKDynamicTableUpdate = {
       ; local = the encoder's dynamic table
       ; remote = the decoder's dynamic table
       owner: Owner

       update_type: QPACKDynamicTableUpdateType
       entries: [+ QPACKDynamicTableEntry]
QPACKDynamicTableUpdateType = "inserted" / "evicted"

QPACKDynamicTableEntry = {
       index: uint64
       ? name: text / hexstring
       ? value: text / hexstring
QPACKHeadersEncoded = {
       ? stream_id: uint64
       ? headers: [+ HTTPField]

       block_prefix: QPACKHeaderBlockPrefix
       header_block: [+ QPACKHeaderBlockRepresentation]

       ? length: uint
       ? raw: hexstring
QPACKHeadersDecoded = {
       ? stream_id: uint64
       ? headers: [+ HTTPField]

       block_prefix: QPACKHeaderBlockPrefix
       header_block: [+ QPACKHeaderBlockRepresentation]

       ? length: uint32
       ? raw: hexstring
QPACKInstructionCreated = {
       ; see definition in appendix
       instruction: QPACKInstruction
       ? length: uint32
       ? raw: hexstring
QPACKInstructionParsed = {
       ; see QPACKInstruction definition in appendix
       instruction: QPACKInstruction

       ? length: uint32
       ? raw: hexstring
HTTPEvents = HTTPParametersSet / HTTPParametersRestored /
                HTTPStreamTypeSet / HTTPFrameCreated /
                HTTPFrameParsed / HTTPPushResolved

Owner = "local" / "remote"

                        Figure 15: Owner definition

HTTPFrame =  HTTPDataFrame /
                HTTPHeadersFrame /
                HTTPCancelPushFrame /
                HTTPSettingsFrame /
                HTTPPushPromiseFrame /
                HTTPGoawayFrame /
                HTTPMaxPushIDFrame /
                HTTPReservedFrame /
                UnknownFrame

                      Figure 16: HTTPFrame definition

HTTPDataFrame = {
       frame_type: "data"
       ? raw: hexstring
HTTPHeadersFrame = {
       frame_type: "headers"
       headers: [* HTTPField]
HTTPField = {
       name: text
       value: text
HTTPCancelPushFrame = {
       frame_type: "cancel_push"
       push_id: uint64
HTTPSettingsFrame = {
       frame_type: "settings"
       settings: [* HTTPSetting]
HTTPSetting = {
       name: text
       value: uint64
HTTPPushPromiseFrame = {
       frame_type: "push_promise"
       push_id: uint64
       headers: [* HTTPField]
HTTPGoawayFrame = {
       frame_type: "goaway"

       ; Either stream_id or push_id.
       ; This is implicit from the sender of the frame
       id: uint64
HTTPMaxPushIDFrame = {
       frame_type: "max_push_id"
       push_id: uint64
HTTPReservedFrame = {
       frame_type: "reserved"

       ? length: uint64
HTTPApplicationError =  "http_no_error" /
                           "http_general_protocol_error" /
                           "http_internal_error" /
                           "http_stream_creation_error" /
                           "http_closed_critical_stream" /
                           "http_frame_unexpected" /
                           "http_frame_error" /
                           "http_excessive_load" /
                           "http_id_error" /
                           "http_settings_error" /
                           "http_missing_settings" /
                           "http_request_rejected" /
                           "http_request_cancelled" /
                           "http_request_incomplete" /
                           "http_early_response" /
                           "http_connect_error" /
                           "http_version_fallback"

                 Figure 27: HTTPApplicationError definition

QPACKEvents = QPACKStateUpdate / QPACKStreamStateUpdate /
                 QPACKDynamicTableUpdate / QPACKHeadersEncoded /
                 QPACKHeadersDecoded / QPACKInstructionCreated /
                 QPACKInstructionParsed

QPACKInstruction =  SetDynamicTableCapacityInstruction /
                       InsertWithNameReferenceInstruction /
                       InsertWithoutNameReferenceInstruction /
                       DuplicateInstruction /
                       SectionAcknowledgementInstruction /
                       StreamCancellationInstruction /
                       InsertCountIncrementInstruction

                   Figure 29: QPACKInstruction definition

SetDynamicTableCapacityInstruction = {
       instruction_type: "set_dynamic_table_capacity"
       capacity: uint32
InsertWithNameReferenceInstruction = {
       instruction_type: "insert_with_name_reference"
       table_type: QPACKTableType
       name_index: uint32
       huffman_encoded_value: bool
       ? value_length: uint32
       ? value: text
InsertWithoutNameReferenceInstruction = {
       instruction_type: "insert_without_name_reference"
       huffman_encoded_name: bool
       ? name_length: uint32
       ? name: text
       huffman_encoded_value: bool
       ? value_length: uint32
       ? value: text
DuplicateInstruction = {
       instruction_type: "duplicate"
       index: uint32
SectionAcknowledgementInstruction = {
       instruction_type: "section_acknowledgement"
       stream_id: uint64
StreamCancellationInstruction = {
       instruction_type: "stream_cancellation"
       stream_id: uint64
InsertCountIncrementInstruction = {
       instruction_type: "insert_count_increment"
       increment: uint32
QPACKHeaderBlockRepresentation =  IndexedHeaderField /
                                     LiteralHeaderFieldWithName /
                                     LiteralHeaderFieldWithoutName

            Figure 37: QPACKHeaderBlockRepresentation definition

IndexedHeaderField = {
       header_field_type: "indexed_header"

       ; MUST be "dynamic" if is_post_base is true
       table_type: QPACKTableType
       index: uint32

       ; to represent the "indexed header field with post-base index"
       ; header field type
       is_post_base: bool .default false
LiteralHeaderFieldWithName = {
       header_field_type: "literal_with_name"

       ; the 3rd "N" bit
       preserve_literal: bool

       ; MUST be "dynamic" if is_post_base is true
       table_type: QPACKTableType
       name_index: uint32
       huffman_encoded_value: bool
       ? value_length: uint32
       ? value: text

       ; to represent the "indexed header field with post-base index"
       ; header field type
       is_post_base: bool .default false
LiteralHeaderFieldWithoutName = {
       header_field_type: "literal_without_name"

       ; the 3rd "N" bit
       preserve_literal: bool
       huffman_encoded_name: bool
       ? name_length: uint32
       ? name: text

       huffman_encoded_value: bool
       ? value_length: uint32
       ? value: text
QPACKHeaderBlockPrefix = {
       required_insert_count: uint32
       sign_bit: bool
       delta_base: uint32
QPACKTableType = "static" / "dynamic"

                    Figure 42: QPACKTableType definition

