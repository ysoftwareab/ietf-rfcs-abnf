SWSP =   CR / LF / WSP   ; streaming white space


hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
base64string =     1*(ALPHA / DIGIT / "+" / "/" / "=" / SWSP)


dkim-quoted-printable =
                          *(FWS / hex-octet / dkim-safe-char)
                     ; hex-octet is from RFC 2045
dkim-safe-char =   %x21-3A / %x3C / %x3E-7E
                     ; '!' - ':', '<', '>' - '~'
                     ; Characters not listed as "mail-safe" in
                     ; RFC 2049 are also not recommended.

selector =   sub-domain *( "." sub-domain )

tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
tag-name  =  ALPHA 0*ALNUMPUNC
tag-value =  [ 1*VALCHAR 0*( 1*(WSP / FWS) 1*VALCHAR ) ]
                             ; WSP and FWS prohibited at beginning and end
VALCHAR   =  %x21-3A / %x3C-7E
                             ; EXCLAMATION to TILDE except SEMICOLON
ALNUMPUNC =  ALPHA / DIGIT / "_"

Tag=value pairs that represent the default value MAY be included to
BODY=BINARYMIME [RFC3030] then the body should be treated as a
v=  Version (MUST be included).  This tag defines the version of this
       specification that applies to the signature record.  It MUST have
       the value 0.4.

       ABNF:


sig-v-tag   = %x76 [FWS] "=" [FWS] "0.4"

           INFORMATIVE NOTE:  DKIM-Signature version numbers are
           expected to increase arithmetically as new versions of this
           specification are released.

           [[INFORMATIVE NOTE:  Upon publication, this version number
           should be changed to "1", and this note should be deleted.]]

a=  The algorithm used to generate the signature (plain-text;
       REQUIRED).  Verifiers MUST support "rsa-sha1" and "rsa-sha256";
       signers SHOULD sign using "rsa-sha256".  See Section 3.3 for a
       description of algorithms.

       ABNF:


sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
sig-a-tag-alg   = sig-a-tag-k "-" sig-a-tag-h
sig-a-tag-k     = "rsa" / x-sig-a-tag-k
sig-a-tag-h     = "sha1" / "sha256" / x-sig-a-tag-h
x-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)   ; for later extension
x-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)   ; for later extension

b=  The signature data (base64; REQUIRED).  Whitespace is ignored in
       this value and MUST be ignored when re-assembling the original
       signature.  In particular, the signing process can safely insert
       FWS in this value in arbitrary places to conform to line-length
       limits.  See Signer Actions (Section 5) for how the signature is
       computed.
       ABNF:


sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
sig-b-tag-data  = base64string

bh= The hash of the canonicalized body part of the message as limited
       by the "l=" tag (base64; REQUIRED).  Whitespace is ignored in
       this value and MUST be ignored when re-assembling the original
       signature.  In particular, the signing process can safely insert
       FWS in this value in arbitrary places to conform to line-length
       limits.  See Section 3.7 for how the body hash is computed.

       ABNF:


sig-bh-tag      = %x62 %x68 [FWS] "=" [FWS] sig-bh-tag-data
sig-bh-tag-data = base64string

c=  Message canonicalization (plain-text; OPTIONAL, default is
       "simple/simple").  This tag informs the verifier of the type of
       canonicalization used to prepare the message for signing.  It
       consists of two names separated by a "slash" (%d47) character,
       corresponding to the header and body canonicalization algorithms
       respectively.  These algorithms are described in Section 3.4.  If
       only one algorithm is named, that algorithm is used for the
       header and "simple" is used for the body.  For example,
       "c=relaxed" is treated the same as "c=relaxed/simple".

       ABNF:


sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                     ["/" sig-c-tag-alg]
sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
x-sig-c-tag-alg = hyphenated-word    ; for later extension

d=  The domain of the signing entity (plain-text; REQUIRED).  This is
       the domain that will be queried for the public key.  This domain
       MUST be the same as or a parent domain of the "i=" tag (the
       signing identity, as described below), or it MUST meet the
       requirements for parent domain signing described in Section 3.8.
       When presented with a signature that does not meet these
       requirement, verifiers MUST consider the signature invalid.
       Internationalized domain names MUST be punycode-encoded
       [RFC3492].

       ABNF:


sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
domain-name     = sub-domain 1*("." sub-domain)
                ; from RFC 2821 Domain, but excluding address-literal

h=  Signed header fields (plain-text, but see description; REQUIRED).
       A colon-separated list of header field names that identify the
       header fields presented to the signing algorithm.  The field MUST
       contain the complete list of header fields in the order presented
       to the signing algorithm.  The field MAY contain names of header
       fields that do not exist when signed; nonexistent header fields
       do not contribute to the signature computation (that is, they are
       treated as the null input, including the header field name, the
       separating colon, the header field value, and any CRLF
       terminator).  The field MUST NOT include the DKIM-Signature
       header field that is being created or verified, but may include
       others.  Folding white space (FWS) MAY be included on either side
       of the colon separator.  Header field names MUST be compared
       against actual header field names in a case insensitive manner.
       This list MUST NOT be empty.  See Section 5.4 for a discussion of
       choosing header fields to sign.

       ABNF:


sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                     0*( *FWS ":" *FWS hdr-name )
hdr-name        = field-name

           INFORMATIVE EXPLANATION:  By "signing" header fields that do
           not actually exist, a signer can prevent insertion of those
           header fields before verification.  However, since a signer
           cannot possibly know what header fields might be created in
           the future, and that some MUAs might present header fields
           that are embedded inside a message (e.g., as a message/rfc822
           content type), the security of this solution is not total.

           INFORMATIVE EXPLANATION:  The exclusion of the header field
           name and colon as well as the header field value for non-
           existent header fields prevents an attacker from inserting an
           actual header field with a null value.
i=  Identity of the user or agent (e.g., a mailing list manager) on
       behalf of which this message is signed (dkim-quoted-printable;
       OPTIONAL, default is an empty local-part followed by an "@"
       followed by the domain from the "d=" tag).  The syntax is a
       standard email address where the local-part MAY be omitted.  The
       domain part of the address MUST be the same as or a subdomain of
       the value of the "d=" tag.

       Internationalized domain names MUST be punycode-encoded
       [RFC3492].

       ABNF:


sig-i-tag =   %x69 [FWS] "=" [FWS] [ Local-part ] "@" domain-name

           INFORMATIVE NOTE:  The local-part of the "i=" tag is optional
           because in some cases a signer may not be able to establish a
           verified individual identity.  In such cases, the signer may
           wish to assert that although it is willing to go as far as
           signing for the domain, it is unable or unwilling to commit
           to an individual user name within their domain.  It can do so
           by including the domain part but not the local-part of the
           identity.

           INFORMATIVE DISCUSSION:  This document does not require the
           value of the "i=" tag to match the identity in any message
           header field fields.  This is considered to be a verifier
           policy issue.  Constraints between the value of the "i=" tag
           and other identities in other header fields seek to apply
           basic authentication into the semantics of trust associated
           with a role such as content author.  Trust is a broad and
           complex topic and trust mechanisms are subject to highly
           creative attacks.  The real-world efficacy of any but the
           most basic bindings between the "i=" value and other
           identities is not well established, nor is its vulnerability
           to subversion by an attacker.  Hence reliance on the use of
           these options should be strictly limited.  In particular it
           is not at all clear to what extent a typical end-user
           recipient can rely on any assurances that might be made by
           successful use of the "i=" options.

l=  Body length count (plain-text unsigned decimal integer; OPTIONAL,
       default is entire body).  This tag informs the verifier of the
       number of octets in the body of the email after canonicalization
       included in the cryptographic hash, starting from 0 immediately
       following the CRLF preceding the body.  This value MUST NOT be
       larger than the actual number of octets in the canonicalized
       message body.

           INFORMATIVE IMPLEMENTATION WARNING:  Use of the l= tag might
           allow display of fraudulent content without appropriate
           warning to end users.  The l= tag is intended for increasing
           signature robustness when sending to mailing lists that both
           modify their content and do not sign their messages.
           However, using the l= tag enables attacks in which an
           intermediary with malicious intent modifies a message to
           include content that solely benefits the attacker.  It is
           possible for the appended content to completely replace the
           original content in the end recipient's eyes and to defeat
           duplicate message detection algorithms.  Examples are
           described in Security Considerations (Section 8).  To avoid
           this attack, signers should be extremely wary of using this
           tag, and verifiers might wish to ignore the tag or remove
           text that appears after the specified content length.

           INFORMATIVE NOTE:  The value of the l= tag is constrained to
           76 decimal digits, which will fit in a 256-bit binary integer
           field.  This constraint is not intended to predict the size
           of future messages, but is intended to remind the implementer
           to check the length of this and all other tags during
           verification.  Implementers may need to limit the actual
           value expressed to a value smaller than 10^76, e.g., to allow
           a message to fit within the available storage space.

       ABNF:


sig-l-tag    = %x6c [FWS] "=" [FWS] 1*76DIGIT

q=  A colon-separated list of query methods used to retrieve the
       public key (plain-text; OPTIONAL, default is "dns/txt").  Each
       query method is of the form "type[/options]", where the syntax
       and semantics of the options depends on the type and specified
       options.  If there are multiple query mechanisms listed, the
       choice of query mechanism MUST NOT change the interpretation of
       the signature.  Implementations MUST use the recognized query
       mechanisms in the order presented.

       Currently the only valid value is "dns/txt" which defines the DNS
       TXT record lookup algorithm described elsewhere in this document.
       The only option defined for the "dns" query type is "txt", which
       MUST be included.  Verifiers and signers MUST support "dns/txt".
       ABNF:


sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                      *([FWS] ":" [FWS] sig-q-tag-method)
sig-q-tag-method = "dns/txt" / x-sig-q-tag-type ["/" x-sig-q-tag-args]
x-sig-q-tag-type = hyphenated-word  ; for future extension
x-sig-q-tag-args = qp-hdr-value

s=  The Selector subdividing the namespace for the "d=" (domain) tag
       (plain-text; REQUIRED).

       ABNF:


sig-s-tag    = %x73 [FWS] "=" [FWS] selector

t=  Signature Timestamp (plain-text unsigned decimal integer;
       RECOMMENDED, default is an unknown creation time).  The time that
       this signature was created.  The format is the number of seconds
       since 00:00:00 on January 1, 1970 in the UTC time zone.  The
       value is expressed as an unsigned integer in decimal ASCII.  This
       value is not constrained to fit into a 31- or 32-bit integer.
       Implementations SHOULD be prepared to handle values up to at
       least 10^12 (until approximately AD 200,000; this fits into 40
       bits).  To avoid denial of service attacks, implementations MAY
       consider any value longer than 12 digits to be infinite.

       ABNF:


sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT

x=  Signature Expiration (plain-text unsigned decimal integer;
       RECOMMENDED, default is no expiration).  The format is the same
       as in the "t=" tag, represented as an absolute date, not as a
       time delta from the signing timestamp.  The value is expressed as
       an unsigned integer in decimal ASCII, with the same contraints on
       the value in the "t=" tag.  Signatures MAY be considered invalid
       if the verification time at the verifier is past the expiration
       date.  The verification time should be the time that the message
       was first received at the administrative domain of the verifier
       if that time is reliably available; otherwise the current time
       should be used.  The value of the "x=" tag MUST be greater than
       the value of the "t=" tag if both are present.
           INFORMATIVE NOTE:  The x= tag is not intended as an anti-
           replay defense.

       ABNF:


sig-x-tag    = %x78 [FWS] "=" [FWS] 1*12DIGIT

z=  Copied header fields (dkim-quoted-printable, but see description;
       OPTIONAL, default is null).  A vertical-bar-separated list of
       selected header fields present when the message was signed,
       including both the field name and value.  It is not required to
       include all header fields present at the time of signing.  This
       field need not contain the same header fields listed in the "h="
       tag.  The header field text itself must encode the vertical bar
       ("|", %x7C) character (i.e., vertical bars in the z= text are
       metacharacters, and any actual vertical bar characters in a
       copied header field must be encoded).  Note that all white space
       must be encoded, including white space between the colon and the
       header field value.  After encoding, SWSP MAY be added at
       arbitrary locations in order to avoid excessively long lines;
       such white space is NOT part of the value of the header field,
       and MUST be removed before decoding.

       Verifiers MUST NOT use the header field names or copied values
       for checking the signature in any way.  Copied header field
       values are for diagnostic use only.

       Header fields with characters requiring conversion (perhaps from
       legacy MTAs which are not [RFC2822] compliant) SHOULD be
       converted as described in MIME Part Three [RFC2047].

       ABNF:
sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                    *( [FWS] "|" sig-z-tag-copy )
sig-z-tag-copy = hdr-name ":" qp-hdr-value
qp-hdr-value   = dkim-quoted-printable    ; with "|" encoded

      INFORMATIVE EXAMPLE of a signature header field spread across
      multiple continuation lines:

c=simple; q=dns/txt; i=@eng.example.net; t=1117574938; x=1118006938;
h=from:to:subject:date;
z=From:foo@eng.example.net|To:joe@example.com|
        Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
               VoG4ZHRNiYzR


public_key = dkim_find_key(q_val, d_val, s_val)

v=  Version of the DKIM key record (plain-text; RECOMMENDED, default
       is "DKIM1").  If specified, this tag MUST be set to "DKIM1"
       (without the quotes).  This tag MUST be the first tag in the
       record.  Records beginning with a "v=" tag with any other value
       MUST be discarded.

       ABNF:
key-v-tag    = %x76 [FWS] "=" [FWS] "DKIM1"

g=  granularity of the key (plain-text; OPTIONAL, default is "*").
       This value MUST match the Local-part of the "i=" tag of the DKIM-
       Signature header field (or its default value of the empty string
       if "i=" is not specified), with a "*" character matching a
       sequence of zero or more arbitrary characters ("wildcarding").
       The intent of this tag is to constrain which signing address can
       legitimately use this Selector.  An email with a signing address
       that does not match the value of this tag constitutes a failed
       verification.  Wildcarding allows matching for addresses such as
       "user+*".  An empty "g=" value never matches any addresses.

       ABNF:


key-g-tag       = %x67 [FWS] "=" [FWS] key-g-tag-lpart
key-g-tag-lpart = [dot-atom-text] ["*"] [dot-atom-text]

           [[NON-NORMATIVE DISCUSSION POINT:  "*" is legal in a "dot-
           atom-text".  This should probably use a different character
           for wildcarding.  Unfortunately, the options are non-mnemonic
           (e.g., "@", "(", ":").  Alternatively we could insist on
           escaping a "*" intended as a literal "*" in the address.]]

h=  Acceptable hash algorithms (plain-text; OPTIONAL, defaults to
       allowing all algorithms).  A colon-separated list of hash
       algorithms that might be used.  Signers and Verifiers MUST
       support the "sha256" hash algorithm.  Verifiers MUST also support
       the "sha1" hash algorithm.

       ABNF:


key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                     0*( [FWS] ":" [FWS] key-h-tag-alg )
key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
x-key-h-tag-alg = hyphenated-word   ; for future extension

k=  Key type (plain-text; OPTIONAL, default is "rsa").  Signers and
       verifiers MUST support the "rsa" key type.  The "rsa" key type
       indicates that an ASN.1 DER-encoded [X.660] RSAPublicKey
       [RFC3447] (see sections 3.1 and A.1.1) is being used in the p=
       tag.  (Note:  the p= tag further encodes the value using the
       base64 algorithm.)

       ABNF:
key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
key-k-tag-type   = "rsa" / x-key-k-tag-type
x-key-k-tag-type = hyphenated-word   ; for future extension

           [[NON-NORMATIVE DISCUSSION NOTE:  In some cases it can be
           hard to separate h= and k=; for example DSA implies that
           SHA-1 will be used.  This might be an actual change to the
           spec depending on how we decide to fix this.]]

n=  Notes that might be of interest to a human (qp-section; OPTIONAL,
       default is empty).  No interpretation is made by any program.
       This tag should be used sparingly in any key server mechanism
       that has space limitations (notably DNS).

       ABNF:


key-n-tag    = %x6e [FWS] "=" [FWS] qp-section

p=  Public-key data (base64; REQUIRED).  An empty value means that
       this public key has been revoked.  The syntax and semantics of
       this tag value before being encoded in base64 is defined by the
k= tag.

key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string ]

s=  Service Type (plain-text; OPTIONAL; default is "*").  A colon-
       separated list of service types to which this record applies.
       Verifiers for a given service type MUST ignore this record if the
       appropriate type is not listed.  Currently defined service types
       are:

       *   matches all service types

       email   electronic mail (not necessarily limited to SMTP)

       This tag is intended to permit signers to constrain the use of
       delegated keys, e.g., where a company is willing to delegate the
       right to send mail in their name to an outsourcer, but not to
       send IM or make VoIP calls.  (This of course presumes that these
       keys are used in other services in the future.)
       ABNF:


key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                       0*( [FWS] ":" [FWS] key-s-tag-type
key-s-tag-type   = "email" / "*" / x-key-s-tag-type
x-key-s-tag-type = hyphenated-word   ; for future extension

t=  Flags, represented as a colon-separated list of names (plain-
       text; OPTIONAL, default is no flags set).  The defined flags are:

       y   This domain is testing DKIM.  Verifiers MUST NOT treat
           messages from signers in testing mode differently from
           unsigned email, even should the signature fail to verify.
           Verifiers MAY wish to track testing mode results to assist
           the signer.

       s   Any DKIM-Signature header fields using the "i=" tag MUST have
           the same domain value on the right hand side of the "@" in
           the "i=" tag and the value of the "d=" tag.  That is, the
           "i=" domain MUST NOT be a subdomain of "d=".  Use of this
           flag is RECOMMENDED unless subdomaining is required.

       ABNF:


key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                      0*( [FWS] ":" [FWS] key-t-tag-flag )
key-t-tag-flag   = "y" / "s" / x-key-t-tag-flag
x-key-t-tag-flag = hyphenated-word   ; for future extension

       Unrecognized flags MUST be ignored.


body-hash = hash-alg(canon_body)
header-hash = hash-alg(canon_header || DKIM-SIG)
signature = sig-alg(header-hash, key)

width=578 height=370>
c=simple; q=dns/txt; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
bh=ZSVEYuq4ri3LR9S+qjlzCP+LxvJrIfrOI2g5hxp5+MI=;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
           VoG4ZHRNiYzR;
c=simple; q=dns/txt; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
bh=ZSVEYuq4ri3LR9S+qjlzCP+LxvJrIfrOI2g5hxp5+MI=;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
             VoG4ZHRNiYzR
