
NSIS                                                           C. Werner
Internet-Draft                                                     X. Fu
Expires: May 2, 2005                                    Univ. Goettingen
                                                           H. Tschofenig
                                                                 Siemens
                                                                 C. Aoun
                                                                  Nortel
                                                           November 2004


                       NSLP NAT/FW State Machine
            draft-werner-nsis-natfw-nslp-statemachine-00.txt

Status of this Memo

   This document is an Internet-Draft and is subject to all provisions
   of section 3 of RFC 3667.  By submitting this Internet-Draft, each
   author represents that any applicable patent or other IPR claims of
   which he or she is aware have been or will be disclosed, and any of
   which he or she become aware will be disclosed, in accordance with
   RFC 3668.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as
   Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on May 2, 2005.

Copyright Notice

   Copyright (C) The Internet Society (2004).

Abstract

   This document describes the state machines for the NSIS Signaling
   Layer Protocol for Network Address Translation/Firewall signaling
   (NAT/FW NSLP).  A set of state machines for NAT/FW NSLP entities at



Werner, et al.            Expires May 2, 2005                   [Page 1]


Internet-Draft            NAT/FW State Machine             November 2004


   different locations of a signaling path are presented in order to
   illustrate how NAT/FW NSLP may be implemented.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4
   3.  Notational conventions used in state diagrams  . . . . . . . .  5
   4.  State Machine Symbols  . . . . . . . . . . . . . . . . . . . .  8
   5.  Common Rules . . . . . . . . . . . . . . . . . . . . . . . . .  9
     5.1   Common Procedures  . . . . . . . . . . . . . . . . . . . .  9
     5.2   Common Variables . . . . . . . . . . . . . . . . . . . . . 11
     5.3   Constants  . . . . . . . . . . . . . . . . . . . . . . . . 12
   6.  State machine for the NAT/FW NI  . . . . . . . . . . . . . . . 13
   7.  State machines for the NAT/FW NF . . . . . . . . . . . . . . . 16
     7.1   State machine for NAT/FW Firewall NF . . . . . . . . . . . 16
     7.2   State machine for NAT/FW NAT NF  . . . . . . . . . . . . . 18
   8.  State machine for the NAT/FW NR  . . . . . . . . . . . . . . . 24
   9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 27
   10.   Open Issues  . . . . . . . . . . . . . . . . . . . . . . . . 28
   11.   Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . 29
   12.   References . . . . . . . . . . . . . . . . . . . . . . . . . 30
   12.1  Normative References . . . . . . . . . . . . . . . . . . . . 30
   12.2  Informative References . . . . . . . . . . . . . . . . . . . 30
       Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 30
       Intellectual Property and Copyright Statements . . . . . . . . 32

























Werner, et al.            Expires May 2, 2005                   [Page 2]


Internet-Draft            NAT/FW State Machine             November 2004


1.  Introduction

   This document describes the state machines for NAT/FW NSLP [1],
   trying to show how NAT/FW NSLP can be implemented to support its
   deployment.  The state machines described in this document are
   illustrative of how the NAT/FW NSLP protocol defined in [1] may be
   implemented for the first NAT/FW NSLP node in the signaling path,
   intermediate NAT/FW NSLP nodes with Firewall and/or NAT
   functionality, and the last NAT/FW NSLP node in the signaling path.
   Where there are differences [1] are authoritative.  The state
   machines are informative only.  Implementations may achieve the same
   results using different methods.

   The messages used in the NAT/FW NSLP protocol can be summarized as
   follows:

      Requesting message       Responding message
      ------------------------+---------------------------
      CREATE                  |RESPONSE
      REA                     |RESPONSE
      QUERY                   |RESPONSE
      RESPONSE                |NONE
      NOTIFY                  |NONE
      TRIGGER                 |CREATE
      ------------------------+---------------------------

   We describe a set of state machines for different roles of entities
   running NAT/FW NSLP to illustrate how NAT/FW NSLP may be implemented.























Werner, et al.            Expires May 2, 2005                   [Page 3]


Internet-Draft            NAT/FW State Machine             November 2004


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [2].














































Werner, et al.            Expires May 2, 2005                   [Page 4]


Internet-Draft            NAT/FW State Machine             November 2004


3.  Notational conventions used in state diagrams

   The following state transition tables are completed mostly based on
   the conventions specified in [3].  The complete text is described
   below.

   State transition tables are used to represent the operation of the
   protocol by a number of cooperating state machines each comprising a
   group of connected, mutually exclusive states.  Only one state of
   each machine can be active at any given time.

   All permissible transitions from a given state to other states and
   associated actions performed when the transitions occur are
   represented by using triplets of (exit condition, exit action, exit
   state).  All conditions are expressions that evaluate to TRUE or
   FALSE; if a condition evaluates to TRUE, then the condition is met.
   A state "ANY" is a wildcard state that matches the current state in
   each state machine.  The exit conditions of a wildcard state are
   evaluated after all other exit conditions of specific to the current
   state are met.

   On exit from a state, the procedures defined for the state and the
   exit condition are executed exactly once, in the order that they
   appear on the page.  (Note that the procedures defined in [4]  are
   executed on entry to a state, which is one major difference from this
   document.)  Each procedure is deemed to be atomic; i.e., execution of
   a procedure completes before the next sequential procedure starts to
   execute.  No procedures execute outside of a state block.  The
   procedures in only one state block execute at a time, even if the
   conditions for execution of state blocks in different state machines
   are satisfied, and all procedures in an executing state block
   complete execution before the transition to and execution of any
   other state block occurs, i.e., the execution of any state block
   appears to be atomic with respect to the execution of any other state
   block and the transition condition to that state from the previous
   state is TRUE when execution commences.  The order of execution of
   state blocks in different state machines is undefined except as
   constrained by their transition conditions.  A variable that is set
   to a particular value in a state block retains this value until a
   subsequent state block executes a procedure that modifies the value.

   On completion of the transition from the previous state to the
   current state, all exit conditions for the current state (including
   exit conditions defined for the wildcard state) are evaluated
   continuously until one of the conditions is met.

   Any event variable is set to TRUE when the corresponding event occurs
   and set to FALSE immediately after completion of the action



Werner, et al.            Expires May 2, 2005                   [Page 5]


Internet-Draft            NAT/FW State Machine             November 2004


   associated with the current state and the event.

   The interpretation of the special symbols and operators is reused
   from [4] and the state diagrams are based on the conventions
   specified in [5], Section 8.2.1.

   The complete text is reproduced here:


      State diagrams are used to represent the operation of the protocol
      by a number of cooperating state machines each comprising a group
      of connected, mutually exclusive states.  Only one state of each
      machine can be active at any given time.

      All permissible transitions between states are represented by
      arrows, the arrowhead denoting the direction of the possible
      transition.  Labels attached to arrows denote the condition(s)
      that must be met in order for the transition to take place.  All
      conditions are expressions that evaluate to TRUE or FALSE; if a
      condition evaluates to TRUE, then the condition is met.  The label
      UCT denotes an unconditional transition (i.e., UCT always
      evaluates to TRUE).  A transition that is global in nature (i.e.,
      a transition that occurs from any of the possible states if the
      condition attached to the arrow is met) is denoted by an open
      arrow; i.e., no specific state is identified as the origin of the
      transition.  When the condition associated with a global
      transition is met, it supersedes all other exit conditions
      including UCT.  The special global condition BEGIN supersedes all
      other global conditions, and once asserted remains asserted until
      all state blocks have executed to the point that variable
      assignments and other consequences of their execution remain
      unchanged.

      On entry to a state, the procedures defined for the state (if any)
      are executed exactly once, in the order that they appear on the
      page.  Each action is deemed to be atomic; i.e., execution of a
      procedure completes before the next sequential procedure starts to
      execute.  No procedures execute outside of a state block.  The
      procedures in only one state block execute at a time, even if the
      conditions for execution of state blocks in different state
      machines are satisfied, and all procedures in an executing state
      block complete execution before the transition to and execution of
      any other state block occurs, i.e., the execution of any state
      block appears to be atomic with respect to the execution of any
      other state block and the transition condition to that state from
      the previous state is TRUE when execution commences.  The order of
      execution of state blocks in different state machines is undefined
      except as constrained by their transition conditions.  A variable



Werner, et al.            Expires May 2, 2005                   [Page 6]


Internet-Draft            NAT/FW State Machine             November 2004


      that is set to a particular value in a state block retains this
      value until a subsequent state block executes a procedure that
      modifies the value.

      On completion of all of the procedures within a state, all exit
      conditions for the state (including all conditions associated with
      global transitions) are evaluated continuously until one of the
      conditions is met.  The label ELSE denotes a transition that
      occurs if none of the other conditions for transitions from the
      state are met (i.e., ELSE evaluates to TRUE if all other possible
      exit conditions from the state evaluate to FALSE).  Where two or
      more exit conditions with the same level of precedence become TRUE
      simultaneously, the choice as to which exit condition causes the
      state transition to take place is arbitrary.

   In addition to the above notation, there are a couple of
   clarifications specific to this document.  First, all boolean
   variables are initialized to FALSE before the state machine execution
   begins.  Second, the following notational shorthand is specific to
   this document:

   <variable> = <expression1> | <expression2> | ...
      Execution of a statement of this form will result in <variable>
      having a value of exactly one of the expressions.  The logic for
      which of those expressions gets executed is outside of the state
      machine and could be environmental, configurable, or based on
      another state machine such as that of the method.
























Werner, et al.            Expires May 2, 2005                   [Page 7]


Internet-Draft            NAT/FW State Machine             November 2004


4.  State Machine Symbols

   ( ) Used to force the precedence of operators in Boolean expressions
      and to delimit the argument(s) of actions within state boxes.
   ;  Used as a terminating delimiter for actions within state boxes.
      Where a state box contains multiple actions, the order of
      execution follows the normal language conventions for reading
      text.
   =  Assignment action.  The value of the expression to the right of
      the operator is assigned to the variable to the left of the
      operator.  Where this operator is used to define multiple
      assignments, e.g., a = b = X the action causes the value of the
      expression following the right-most assignment operator to be
      assigned to all of the variables that appear to the left of the
      right-most assignment operator.
   !  Logical NOT operator.
   && Logical AND operator.
   || Logical OR operator.
   if...then...  Conditional action.  If the Boolean expression
      following the if evaluates to TRUE, then the action following the
      then is executed.
   \{ statement 1, ...  statement N \} Compound statement.  Braces are
      used to group statements that are executed together as if they
      were a single statement.
   != Inequality.  Evaluates to TRUE if the expression to the left of
      the operator is not equal in value to the expression to the right.
   == Equality.  Evaluates to TRUE if the expression to the left of the
      operator is equal in value to the expression to the right.
   >  Greater than.  Evaluates to TRUE if the value of the expression to
      the left of the operator is greater than the value of the
      expression to the right.
   <= Less than or equal to.  Evaluates to TRUE if the value of the
      expression to the left of the operator is either less than or
      equal to the value of the expression to the right.
   ++ Increment the preceding integer operator by 1.
















Werner, et al.            Expires May 2, 2005                   [Page 8]


Internet-Draft            NAT/FW State Machine             November 2004


5.  Common Rules

   Throughout the document we use terms defined in the [1], such as NI,
   NF, NR, NI+, NR+, CREATE, QUERY, or RESPONSE.

5.1  Common Procedures

   tx_CREATE(): Transmit a CREATE message
   tx_CREATE(LIFETIME=0): Transmit CREATE message with lifetime object
      explicitly set to 0 for session deletion
   tx_RESP(code,type): Transmit RESPONSE message with specified code
      (SUCCESS or ERROR) and result type (related to a specific request
      type message: CREATE, REA or QUERY).  A code or result type may be
      omitted, typically when forwarding received RESPONSE messages.
   tx_QUERY(): Transmit QUERY message.
   tx_NOTIFY(): Transmit NOTIFY message.
   rx_RESP(code, type): Evaluates to TRUE if a RESPONSE message has been
      received with the specified code (SUCCESS or ERROR) and result
      type (related to a specific request type message: CREATE, REA or
      QUERY).  If the code or type is omitted, any received RESPONSE
      message which is only matching the given code or type will
      evaluate this procedure to TRUE.
   rx_NOTIFY(): Evaluates to TRUE if a NOTIFY message has been received.
   rx_QUERY(): Evaluates to TRUE if a QUERY message has been received
   rx_CREATE(): Evaluates to TRUE if a CREATE message has been received.
   CHECK_AA(): Checks Authorization and Authentication of the received
      message.  Evaluates to TRUE if the check is successful, otherwise
      it evaluates to FALSE.  This check is performed on all received
      messages hence it will only be shown within the state machine when
      the check has failed.  This CHECK_AA also MAY include a local
      policy check for the received message.
   CHECK_NoNR(): Checks if the message can reach its targeted
      destination, i.e.  the NR if it exists at the targeted host.
   CHECK_SCOPE(): Checks if the message has reached the network
      boundaries defined by the SCOPE object.
   Process Event(): Processes a NOTIFY messages and adapts the behaviour
      of this node to the new condition.
   Process Query(): Processes the received QUERY message and prepares
      the appropriate RESPONSE message.
   Binding.create(): Creates a public/private network translation
      binding on a NAT device for the requesting entity.
   Binding.clear(): Deletes a previously created a public/private
      network translation binding on a NAT device for the requesting
      entity.
   Session.create(): Installs all session related states, variables,
      bindings, policies.





Werner, et al.            Expires May 2, 2005                   [Page 9]


Internet-Draft            NAT/FW State Machine             November 2004


   Session.update(): Updates all session related states, variables,
      bindings, policies based on received CREATE or TRIGGER if
      applicable.
   Session.clear(): Removes all session related states, variables,
      bindings, policies.
   PckFilter.create(): Installs a packet filter for the new session.
   PckFilter.update(): Updates the packet filter for changes in the
      session rules.
   PckFilter.clear(): Removes a previously set packet filter.
   Start.STATE_TIMER(identifier): This procedure starts a timer with a
      certain timespan, which is up to the specific implementation.  The
      parameter 'identifier' identifies this timer uniquely.  Any
      subsequent Start_STATE_TIMER(x), Stop_STATE_TIMER(x),
      TIMEOUT_STATE(x) refer to the same timer labeled x.  This timer is
      required to time the lifetime of state, which means that when it
      times out, it indicates the current machine state should be left
      or its validation has expired.  This procedure starts the timer
      'identifier'.  If a timer with the same 'identifier' has
      already	been started and not yet stopped, the timer is now stopped
      and restarted.  After the timer has timed out, the procedure
      TIMEOUT_STATE(identifier) evaluates to TRUE.  The timer does not
      restart automatically, but must be started again with a
      Start_STATE_TIMER(identifier).  Notice that there is no difference
      to the Start_REFRESH_TIMER(identifier) procedure which has exactly
      the same functionality.  The different procedure names are only
      supplied to underline the purpose of this specific timer.
   Stop.STATE_TIMER(identifier): This procedure stops the timer labeled
      'identifier'.  If it has already been stopped, this procedure has
      no effect.  If the timer has already timed out, this procedure
      removes the timeout-state from the timer 'identifier', so
      subsequent calls to TIMEOUT_STATE(identifier) evaluate to FALSE.
      A timeout cannot occur until the timer 'identifier' has been
      (re-)started.
   TIMEOUT.STATE(identifier): This procedure evaluates to TRUE if the
      timer 'identifier' has timed out and indicates a state lifetime
      expiration.  Subsequent TIMEOUT_STATE(identifier) calls also
      evaluate to TRUE until the timer 'identifier' has been
      (re-)started.  This procedure cannot evaluate to TRUE if the timer
      has been stopped.
   Start.REFRESH_TIMER(identifier): This procedure starts a timer with a
      certain timespan, which is up to the specific implementation.  The
      parameter 'identifier' identifies this timer uniquely.  Any
      subsequent Start_REFRESH_TIMER(x), Stop_REFRESH_TIMER(x),
      TIMEOUT_REFRESH(x) refer to the same timer labeled x.  This timer
      times a refresh interval, which means that when it times out, it
      indicates a state refresh message is due to be sent.  This
      procedure starts the timer 'identifier'.  If a timer with the same
      'identifier' has already	been started and not yet stopped, the



Werner, et al.            Expires May 2, 2005                  [Page 10]


Internet-Draft            NAT/FW State Machine             November 2004


      timer is now stopped and restarted.  After the timer has timed
      out, the procedure TIMEOUT_REFRESH(identifier) evaluates to TRUE.
      The timer does not restart automatically, but must be started
      again with a Start_REFRESH_TIMER(identifier).  Notice that there
      is no difference to the Start_STATE_TIMER(identifier) procedure
      which has exactly the same functionality.  The different procedure
      names are only supplied to underline the purpose of this specific
      timer.
   Stop.REFRESH_TIMER(identifier): This procedure stops the timer
      labeled 'identifier'.  If it has already been stopped, this
      procedure has no effect.  If the timer has already timed out, this
      procedure removes the timeout-state from the timer 'identifier',
      so subsequent calls to TIMEOUT_REFRESH(identifier) evaluate to
      FALSE.  A timeout cannot occur until the timer 'identifier' has
      been (re-)started.
   TIMEOUT.REFRESH(identifier): This procedure evaluates to TRUE if the
      timer 'identifier' has timed out and indicates a refresh interval
      expiration.  Subsequent TIMEOUT_REFRESH(identifier) calls also
      evaluate to TRUE until the timer 'identifier' has been
      (re-)started.  This procedure cannot evaluate to TRUE if the timer
      has been stopped.
   tg_QUERY: External trigger to send a QUERY message (typically
      triggered by the application).
   tg_CREATE: External trigger to send a CREATE message (typically
      triggered by the application).
   tg_NOTIFY: External trigger to notify the entity of a new event to be
      processed (typically triggered by the application)
   tg_TRIGGER: External trigger to send a TRIGGER message to a NF
      (typically triggered by the application)
   tg_TEARDOWN: External trigger to delete a previously created session
      (typically triggered by the application)
   tg_REA: External trigger to send a REA message towards an
      opportunistic address (typically triggered by the application)

5.2  Common Variables

   IS_EDGE: Boolean flag which evaluates to TRUE if the node is on the
      network edge, otherwise it evaluates to FALSE.
   IS_PUBLICSIDE: Boolean flag which evaluates to TRUE if the (CREATE-
      or REA-) message has been received on the public side of the
      network.
   CREATE(LIFETIME?): Gets the value of the LIFETIME object in the
      CREATE message.
   CREATE(TRIGGER?): Evaluates to TRUE if the received CREATE message
      indicates a CREATE trigger.






Werner, et al.            Expires May 2, 2005                  [Page 11]


Internet-Draft            NAT/FW State Machine             November 2004


   CREATE(POLICY?): Gets the policy for the CREATE message.
   CREATE(SOURCE?): Retrieves the sender of the CREATE message.
   CREATE(NoNR?): Evaluates to TRUE if the CREATE message has an active
      NoNR-flag.
   CREATE(Scope?): Evaluates to TRUE if the CREATE message has an active
      Scope-flag.
   Retry_Counter(CREATE): Denotes the current number of retries of
      CREATE message which has been re-transmitted due to previous
      RESPONSE_ERROR message.  If the number of Retry_Counter(CREATE)
      equals the value of MAXRETRY(CREATE), the current session creation
      attempt is aborted and the application is being notified.
   Retry_Counter(QUERY): Denotes the current number of retries of QUERY
      message which has been re-transmitted due to previous
      RESPONSE_ERROR message.  If the number of Retry_Counter(QUERY)
      equals the value of MAXRETRY(QUERY), the current QUERY attempt is
      aborted and the application is being notified.
   Retry_Counter(REA): Denotes the current number of retries of REA
      message which has been re-transmitted due to previous
      RESPONSE_ERROR message.  If the number of Retry_Counter(REA)
      equals the value of MAXRETRY(REA), the current REA initiation
      attempt is aborted and the application is being notified.

5.3  Constants

   Max_Retry(CREATE): Contains the maximum number of retransmission
      attempts of a CREATE message after it is aborted and the
      application is being notified.
   Max_Retry(QUERY): Contains the maximum number of retransmission
      attempts of a QUERY message after it is aborted and the
      application is being notified.
   Max_Retry(REA): Contains the maximum number of retransmission
      attempts of a REA message after it is aborted and the application
      is being notified.


















Werner, et al.            Expires May 2, 2005                  [Page 12]


Internet-Draft            NAT/FW State Machine             November 2004


6.  State machine for the NAT/FW NI

   This section presents the state machines for the NSIS initator which
   is capable of NSLP NAT/FW signaling


      -------------------
      State: Initialize
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
              UCT             |retry_Counter(Create)=0; |IDLE
                              |retry_Counter(Query)=0;  |
      ------------------------+-------------------------+------------


      -------------------
      State: IDLE
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      tg_CREATE               |Start.STATE_TIMER(Resp); |PENDING
                              |retry_Counter(Create)=0; |
                              |tx_CREATE;               |
      ------------------------+-------------------------+------------
























Werner, et al.            Expires May 2, 2005                  [Page 13]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: PENDING
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(SUCCESS,Create) |Stop.STATE_TIMER(Resp);  |ESTABLISHED
                              |Session.create();        |
                              |Start.REFRESH_TIMER(Cre);|
                              |retry_Counter(Create)=0; |
                              |                         |
      TIMEOUT.STATE(Resp)     |Stop.STATE_TIMER(Resp);  |PENDING
                              |retry_Counter(Create)++; |
                              |if (retry_Counter(Create)|
                              |<=Max_Retry(Create))     |
                              |{Start.STATE_TIMER(Resp);|
                              |tx_CREATE;}              |
                              |                         |
      (Retry_Counter(Create)  |Send info to appl.;      |IDLE
      > Max_Retry(Create)) || |Stop.STATE_TIMER(Resp);  |
      tg_TEARDOWN ||          |                         |
      rx_RESP(ERROR,Create)   |                         |
      ------------------------+-------------------------+------------


      -------------------
      State: ESTABLISHED
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(SUCCESS,Query)  |Stop.STATE_TIMER(Query); |ESTABLISHED
      && CHECK_AA             |Send info to appl.;      |
                              |                         |
      tg_QUERY                |tx_QUERY;                |ESTABLISHED
                              |Start.STATE_TIMER(Query);|
                              |retry_Counter(Query)=0;  |
                              |                         |
      rx_RESP(SUCCESS,Create) |Start.REFRESH_TIMER(Cre);|ESTABLISHED
                              |Stop.STATE_TIMER(Resp);  |
                              |retry_counter(Create)=0; |
                              |                         |
      TIMEOUT.REFRESH(Cre)    |Start.STATE_TIMER(Resp); |ESTABLISHED
                              |tx_CREATE;               |
                              |                         |
      TIMEOUT.STATE(Resp)     |Stop.STATE_TIMER(Resp);  |ESTABLISHED
                              |retry_Counter(Create)++; |
                              |if (retry_Counter(Create)|



Werner, et al.            Expires May 2, 2005                  [Page 14]


Internet-Draft            NAT/FW State Machine             November 2004


                              | <= Max_Retry(Create)) { |
                              |Start.STATE_TIMER(Resp); |
                              |tx_CREATE;}              |
                              |                         |
      rx_NOTIFY && CHECK_AA   |Process Event();         |ESTABLISHED
                              |                         |
      rx_RESP(ERROR,Query) || |Stop.STATE_TIMER(Query); |ESTABLISHED
      TIMEOUT.STATE(Query)    |retry_Counter(Query)++;  |
                              |if (retry_Counter(Query) |
                              | <= Max_Retry(Query)) {  |
                              |Start.STATE_TIMER(Query);|
                              |tx_QUERY;} else {        |
                              |send info to appl.}      |
                              |                         |
      (retry_Counter(Create)  |Send info to appl.;      |IDLE
      > Max_Rety(Create)) ||  |Session.clear();         |
      rx_RESP(ERROR,Create)   |Stop.REFRESH_TIMER(Cre); |
                              |                         |
      tg_TEARDOWN             |tx_CREATE(LIFETIME=0);   |IDLE
                              |Session.clear();         |
                              |Stop.REFRESH_TIMER(Cre); |
                              |Stop.STATE_TIMER(Resp);  |
      ------------------------+-------------------------+------------




























Werner, et al.            Expires May 2, 2005                  [Page 15]


Internet-Draft            NAT/FW State Machine             November 2004


7.  State machines for the NAT/FW NF

   This section describes the state machines for intermediate nodes
   within the signaling path capable of processing NAT/FW NSLP messages.
   These nodes typically implement firewall and/or network address
   translation (NAT) functionality.  To keep it simple, the state
   machines are separated in two independent state machines for nodes
   with firewall and nodes with NAT functionality.

7.1  State machine for NAT/FW Firewall NF


      -------------------
      State: Initialize
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
              UCT             | -                       |IDLE
      ------------------------+-------------------------+------------


      -------------------
      State: IDLE
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_REA && !(CHECK_AA)   |tx_RESP(ERROR,Rea);      |IDLE
                              |                         |
      rx_RESP(Rea)            |tx_RESP(Rea);            |IDLE
                              |                         |
      rx_REA && IS_EDGE       |tx_RESP(ERROR,Rea);  (*) |IDLE
                              |                         |
      rx_REA && !(IS_EDGE)    |tx_REA;                  |IDLE
                              |                         |
      rx_CREATE && CHECK_AA   |Start.STATE_TIMER(Resp); |PENDING
                              |tx_CREATE;               |
                              |                         |
      rx_CREATE && !(CHECK_AA)|tx_RESP(ERROR,Create);   |IDLE
      ------------------------+-------------------------+------------
      * REA Error message "No NAT here"









Werner, et al.            Expires May 2, 2005                  [Page 16]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: PENDING
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(SUCCESS,Create) |Stop_STATE_TIMER(Resp);  |ESTABLISHED
                              |Session.create();        |
                              |PckFilter.create();      |
                              |Start.STATE_TIMER(Cre);  |
                              |                         |
      rx_RESP(ERROR,Create)   |Stop.STATE_TIMER(Resp);  |IDLE
      || TIMEOUT.STATE(Resp)  |                         |
      ------------------------+-------------------------+------------





































Werner, et al.            Expires May 2, 2005                  [Page 17]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: ESTABLISHED
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_CREATE && !(CHECK_AA)|tx_RESP(ERROR,Create);   |ESTABLISHED
                              |                         |
      rx_TRIGGER && CHECK_AA  |tx_TRIGGER;              |ESTABLISHED
      && !IS_EDGE             |                         |
                              |                         |
      rx_RESP(SUCCESS,Create) |Start.STATE_TIMER(Cre);  |ESTABLISHED
                              |tx_RESP(SUCCESS,Create); |
                              |                         |
      rx_QUERY && CHECK_AA    |Process Query();         |ESTABLISHED
                              |tx_QUERY;                |
                              |                         |
      rx_CREATE && CHECK_AA   |tx_CREATE;               |ESTABLISHED
      && CREATE(LIFETIME?)>0  |                         |
                              |                         |
      rx_RESP(,Query) &&      |tx_RESP(,Query);         |ESTABLISHED
      CHECK_AA                |                         |
                              |                         |
      tg_NOTIFY               |tx_NOTIFY;               |ESTABLISHED
                              |                         |
      rx_NOTIFY && CHECK_AA   |Process Event();         |ESTABLISHED
                              |tx_NOTIFY;               |
                              |                         |
      TIMEOUT.STATE(Cre) ||   |Session.clear();         |IDLE
      tg_TEARDOWN             |PckFilter.clear();       |
                              |                         |
      rx_CREATE && CHECK_AA   |tx_CREATE(LIFETIME=0);   |IDLE
      && CREATE(LIFETIME?)==0 |Session.clear();         |
                              |PckFilter.clear();       |
                              |Stop.STATE_TIMER(Cre);   |
      ------------------------+-------------------------+------------


7.2  State machine for NAT/FW NAT NF


      -------------------
      State: Initialize
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
              UCT             |Retry_Counter(Create)=0; |IDLE



Werner, et al.            Expires May 2, 2005                  [Page 18]


Internet-Draft            NAT/FW State Machine             November 2004


      ------------------------+-------------------------+------------


      -------------------
      State: IDLE
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_CREATE &&            |tx_RESP(ERROR,Rea);  (*1)|IDLE
      IS_PUBLICSIDE           |                         |
                              |                         |
      rx_REA && CHECK_AA &&   |tx_RESP(ERROR,Rea);  (*2)|IDLE
      && IS_PUBLICSIDE        |                         |
                              |                         |
      rx_REA && CHECK_AA &&   |Binding.create();        |NonEDGE REA
      !IS_EDGE                |tx_REA;                  |
                              |Start_STATE_TIMER(Rea);  |
                              |                         |
      rx_REA && CHECK_AA &&   |Binding.create();        |REA
      IS_EDGE &&              |Start.STATE_TIMER(Rea);  |
      !IS_PUBLICSIDE          |tx_RESP(SUCCESS,Rea);    |
                              |retry_Counter(Create)=0; |
                              |Start.STATE_TIMER(Resp); |
                              |tx_CREATE;               |
                              |                         |
      rx_CREATE && CHECK_AA   |Binding.create();        |PENDING
      && !IS_PUBLICSIDE       |Start.STATE_TIMER(Resp); |
                              |tx_CREATE;               |
      ------------------------+-------------------------+------------
      *1 Error message is "No reservation made"
      *2 Error message is "REA received on public side"



















Werner, et al.            Expires May 2, 2005                  [Page 19]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: NonEDGE REA
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(,Query) &&      |tx_RESP(,Query);         |NonEDGE REA
      CHECK_AA                |                         |
                              |                         |
      rx_QUERY && CHECK_AA    |Process Query();         |NonEDGE REA
                              |tx_QUERY;                |
                              |                         |
      tx_TRIGGER && CHECK_AA  |PckFilter.update();      |NonEDGE REA
                              |Start.STATE_TIMER(Rea);  |
                              |tx_TRIGGER;              |
                              |                         |
      rx_CREATE && CHECK_AA   |Stop.STATE_TIMER(Rea);   |PENDING
                              |Start.STATE_TIMER(Resp); |
                              |tx_CREATE;               |
                              |                         |
      TIMEOUT.STATE(Rea) ||   |Binding.clear();         |IDLE
      rx_RESPONSE(ERROR,Rea)  |PckFilter.clear();       |
      ------------------------+-------------------------+------------




























Werner, et al.            Expires May 2, 2005                  [Page 20]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: REA
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      TIMEOUT.STATE(Rea) ||   |Binding.clear();         |IDLE
      rx_RESP(ERROR,Create)   |                         |
                              |                         |
      rx_RESP(SUCCESS,Create) |Stop.STATE_TIMER(Resp);  |REA
                              |                         |
      rx_CREATE &&            |Start.STATE_TIMER(Resp); |NI-PENDING
      CREATE(SOURCE?)==NI &&  |tx_CREATE;               |
      CHECK_AA                |                         |
                              |                         |
      TIMEOUT.STATE(Resp)     |Stop.STATE_TIMER(Resp);  |REA
                              |retry_Counter(Create)++; |
                              |if (retry_Counter(Create)|
                              | <= Max_Retry(Create)) { |
                              |tx_CREATE;               |
                              |Start.STATE_TIMER(Resp);}|
                              |                         |
      rx_TRIGGER && CHECK_AA  |Start.STATE_TIMER(Rea);  |REA
                              |Start.STATE_TIMER(Resp); |
                              |retry_Counter(Create)=0; |
                              |PckFilter.update();      |
                              |tx_CREATE;               |
                              |                         |
      tg_NOTIFY               |tx_NOTIFY;               |REA
                              |                         |
      rx_QUERY && CHECK_AA    |tx_RESPONSE(,Query);     |REA
      ------------------------+-------------------------+------------


      -------------------
      State: PENDING
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(SUCCESS,Create) |Stop.STATE_TIMER(Resp);  |ESTABLISHED
                              |Start.STATE_TIMER(Cre);  |
                              |Session.create();        |
                              |PckFilter.create();      |
                              |tx_RESP(SUCCESS,Create); |
                              |                         |
      rx_RESP(ERROR,Create)   |Binding.remove();        |IDLE
      || TIMEOUT.STATE(Resp)  |                         |



Werner, et al.            Expires May 2, 2005                  [Page 21]


Internet-Draft            NAT/FW State Machine             November 2004


      ------------------------+-------------------------+------------


      -------------------
      State: NI-PENDING
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(SUCCESS,Create) |Stop.STATE_TIMER(Resp);  |ESTABLISHED
                              |Session.clear();         |
                              |Session.create();        |
                              |PckFilter.create();      |
                              |Start.STATE_TIMER(Cre);  |
                              |tx_RESP(SUCCESS,Create); |
                              |                         |
      rx_RESP(ERROR,Create)   | -                       |REA
      || TIMEOUT.STATE(Resp)  |                         |
      ------------------------+-------------------------+------------
































Werner, et al.            Expires May 2, 2005                  [Page 22]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: ESTABLISHED
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_CREATE && !(CHECK_AA)|tx_RESP(ERROR,Create);   |ESTABLISHED
                              |                         |
      rx_QUERY && CHECK_AA    |Process Query();         |ESTABLISHED
                              |tx_QUERY;                |
                              |                         |
      TIMEOUT.STATE(Cre) ||   |Session.clear();         |IDLE
      tg_TEARDOWN             |send info to appl.;      |
                              |                         |
                              |                         |
      rx_CREATE && CHECK_AA   |tx_CREATE(LIFETIME=0);   |IDLE
      && CREATE(LIFETIME?)==0 |Session.clear();         |
                              |PckFilter.clear();       |
                              |                         |
      rx_TRIGGER && !IS_EDGE  |PckFilter.update();      |ESTABLISHED
      && CHECK_AA             |tx_TRIGGER;              |
                              |                         |
      rx_RESP(,Query) &&      |tx_RESP(,Query);         |ESTABLISHED
      CHECK_AA                |                         |
                              |                         |
      rx_NOTIFY && CHECK_AA   |Process Event();         |ESTABLISHED
                              |tx_NOTIFY;               |
                              |                         |
      tg_NOTIFY               |tx_NOTIFY;               |ESTABLISHED
                              |                         |
      rx_CREATE && CHECK_AA   |PckFilter.update();      |ESTABLISHED
      && CREATE(LIFETIME?)>0  |tx_CREATE;               |
                              |                         |
      rx_RESP(SUCCESS,Create) |Start.STATE_TIMER(Cre);  |ESTABLISHED
                              |tx_RESP(SUCCESS,Create); |
                              |                         |
      rx_RESP(ERROR,Create)   |tx_RESP(ERROR,Create);   |ESTABLISHED
      ------------------------+-------------------------+------------













Werner, et al.            Expires May 2, 2005                  [Page 23]


Internet-Draft            NAT/FW State Machine             November 2004


8.  State machine for the NAT/FW NR

   This section presents the state machines for the NSIS responder which
   is capable of NSLP NAT/FW signaling


      -------------------
      State: Initialize
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
              UCT (*)         |Retry_Counter(REA)=0;    |IDLE
      ------------------------+-------------------------+------------
      * Triggered by application when forking process


      -------------------
      State: IDLE
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_CREATE && CHECK_AA   |tx_RESP(SUCCESS,Create); |ESTABLISHED
                              |Start.STATE_TIMER(Cre);  |
                              |Session.start();         |
                              |PckFilter.create();      |
                              |Send info to appl.       |
                              |                         |
      tg_REA                  |tx_REA;                  |REA PENDING
                              |retry_Counter(REA)=0;    |
                              |Start.STATE_Timer(Resp); |
                              |                         |
      rx_CREATE && !(CHECK_AA)|tx_RESP(ERROR,Create);   |IDLE
      ------------------------+-------------------------+------------
















Werner, et al.            Expires May 2, 2005                  [Page 24]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: REA PENDING
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      rx_RESP(SUCCESS,Rea)    |Stop.STATE_TIMER(Resp);  |TRIG PENDING
                              |Start.STATE_TIMER(Cre);  |
                              |                         |
      TIMEOUT.STATE(Resp)     |retry_Counter(REA)++;    |REA PENDING
                              |if (retry_Counter(REA)   |
                              | <= Max_Retry(REA)) {    |
                              |Start.STATE_TIMER(Resp); |
                              |tx_REA;}                 |
                              |                         |
      (retry_Counter(REA) >   |Send info to appl.;      |IDLE
      Max_Retry(REA)) ||      |                         |
      rx_RESP(ERROR,Rea)      |                         |
      ------------------------+-------------------------+------------


      -------------------
      State: TRIG PENDING
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      TIMEOUT.STATE(Cre)      |Send info to appl.;      |IDLE
                              |                         |
      rx_CREATE && CHECK_AA   |tx_RESP(SUCCESS,Create); |ESTABLISHED
                              |Session.create();        |
                              |PckFilter.create();      |
                              |Send info to appl.;      |
                              |Start.STATE_TIMER(Cre);  |
                              |Start.REFRESH_TIMER(Trg);|
      ------------------------+-------------------------+------------















Werner, et al.            Expires May 2, 2005                  [Page 25]


Internet-Draft            NAT/FW State Machine             November 2004


      -------------------
      State: ESTABLISHED
      -------------------

      Condition                Action                    State
      ------------------------+-------------------------+------------
      (rx_CREATE &&           |Session.session();       |IDLE
      CREATE(LIFETIME?)==0 && |PckFilter.clear();       |
      CHECK_AA) ||            |Send info to appl.;      |
      TIMEOUT.STATE(Cre) ||   |                         |
      tg_TEARDOWN             |                         |
                              |                         |
      TIMEOUT.REFRESH(Trg)    |tx_TRIGGER;              |ESTABLISHED
                              |Start.REFRESH_TIMER(Trg);|
                              |                         |
      rx_QUERY && CHECK_AA    |Process Query();         |ESTABLISHED
                              |tx_RESP(,Query);         |
                              |                         |
      rx_CREATE &&            |if (CREATE(SOURCE?)!=NF){|ESTABLISHED
      CREATE(LIFETIME?)>0 &&  |Stop.REFRESH_TIMER(Trg);}|
      CHECK_AA                |tx_RESP(SUCCESS,Create); |
                              |Start.STATE_TIMER(Cre);  |
                              |                         |
      rx_CREATE && !(CHECK_AA)|tx_RESP(ERROR,Create);   |ESTABLISHED
                              |                         |
      rx_NOTIFY && CHECK_AA   |Process Event();         |ESTABLISHED
                              |                         |
      tg_NOTIFY               |tx_NOTIFY;               |ESTABLISHED
      ------------------------+-------------------------+------------






















Werner, et al.            Expires May 2, 2005                  [Page 26]


Internet-Draft            NAT/FW State Machine             November 2004


9.  Security Considerations

   This document does not raise new security considerations.  Any
   security concerns with the NAT/FW NSLP are likely reflected in
   security related NSIS work already (such as [1] or [6]).

   For the time being, the state machines described in this document do
   not consider the security aspect of NAT/FW NSLP protocol itself.  A
   future version of this document will add security relevant states and
   state transitions.









































Werner, et al.            Expires May 2, 2005                  [Page 27]


Internet-Draft            NAT/FW State Machine             November 2004


10.  Open Issues

   CREATE[NoNR] and CREATE[Scope] message triggers are currently not
   implemented in the state machines and all other open issues in [1]
   will be added in future versions of this document.














































Werner, et al.            Expires May 2, 2005                  [Page 28]


Internet-Draft            NAT/FW State Machine             November 2004


11.  Acknowledgments

   The authors would like to thank Tseno Tsenov for his valuable
   comments and discussions.















































Werner, et al.            Expires May 2, 2005                  [Page 29]


Internet-Draft            NAT/FW State Machine             November 2004


12.  References

12.1  Normative References

   [1]  Stiemerling, M., "A NAT/Firewall NSIS Signaling Layer Protocol
        (NSLP)", draft-ietf-nsis-nslp-natfw-04 (work in progress),
        October 2004.

   [2]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", March 1997.

12.2  Informative References

   [3]  Ohba, Y., "State Machines for Protocol for Carrying
        Authentication for Network Access  (PANA)",
        draft-ohba-pana-statemachine-00 (work in progress), July 2004.

   [4]  Vollbrecht, J., Eronen, P., Petroni, N. and Y. Ohba, "State
        Machines for Extensible Authentication Protocol (EAP) Peer and
        Authenticator", draft-ietf-eap-statemachine-05 (work in
        progress), September 2004.

   [5]  Institute of Electrical and Electronics Engineers, "DRAFT
        Standard for Local and Metropolitan Area Networks: Port-Based
        Network Access Control (Revision)", IEEE 802-1X-REV/D9, January
        2004.

   [6]  Tschofenig, H. and D. Kroeselberg, "Security Threats for NSIS",
        draft-ietf-nsis-threats-06 (work in progress), October 2004.


Authors' Addresses

   Constantin Werner
   University of Goettingen
   Telematics Group
   Lotzestr. 16-18
   Goettingen  37083
   Germany

   EMail: werner@cs.uni-goettingen.de










Werner, et al.            Expires May 2, 2005                  [Page 30]


Internet-Draft            NAT/FW State Machine             November 2004


   Xiaoming Fu
   University of Goettingen
   Telematics Group
   Lotzestr. 16-18
   Goettingen  37083
   Germany

   EMail: fu@cs.uni-goettingen.de


   Hannes Tschofenig
   Siemens
   Otto-Hahn-Ring 6
   Munich, Bayern  81739
   Germany

   EMail: Hannes.Tschofenig@siemens.com


   Cedric Aoun
   Nortel Networks/ENST Paris

   EMail: cedric.aoun@nortelnetworks.com




























Werner, et al.            Expires May 2, 2005                  [Page 31]


Internet-Draft            NAT/FW State Machine             November 2004


Intellectual Property Statement

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Copyright Statement

   Copyright (C) The Internet Society (2004).  This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Acknowledgment

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Werner, et al.            Expires May 2, 2005                  [Page 32]




