<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Common Interface to Cryptographic Modules (CICM) Logical Model </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Background">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Language Independent">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Audience">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Scope of the Specification">
<link href="#rfc.section.2" rel="Chapter" title="2 Use Cases">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Data-in-Transit">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Data-at-Rest">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Single Security Domain">
<link href="#rfc.section.3" rel="Chapter" title="3 Module Management">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Managing Module Authentication">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Managing Hardware Access Tokens">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Managing Users">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Logging in to a Module from a Host">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Managing Software Packages">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Managing Logs">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Managing Tests">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Managing Module Events">
<link href="#rfc.section.4" rel="Chapter" title="4 Key Management">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Creating and Establishing Keys">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 No Host Interaction Key Fill">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Client Program-Initiated">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 Module/Key Infrastructure Initiated">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Exporting Keys">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Locating and Retrieving Information about a Key">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Applying Metadata to Keys">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Performing Operations on Keys">
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 Enabling Remote Management">
<link href="#rfc.section.5" rel="Chapter" title="5 Channel Management">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Creating Channels">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Encryption and Decryption">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Bypass">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Integrity">
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 Hashing">
<link href="#rfc.section.5.1.5" rel="Chapter" title="5.1.5 Keystream Generation">
<link href="#rfc.section.5.1.6" rel="Chapter" title="5.1.6 Random Data">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Managing Channels">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Using Channels">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Grouping Channels">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Receiving Notification of Channel Events">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Destroying Channels">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Unauthorized Usage">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Inappropriate Usage">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Confidentiality and Data Integrity">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Bypass">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Entity Authentication">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Terms">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document defines an abstract model for high assurance cryptographic modules. It defines the relevant terminology and high-level descriptions of the types of services and operations offered by such modules. The goal is to provide a common vocabulary for discussing the programming of high assurance modules." />
  <meta name="description" content="This document defines an abstract model for high assurance cryptographic modules. It defines the relevant terminology and high-level descriptions of the types of services and operations offered by such modules. The goal is to provide a common vocabulary for discussing the programming of high assurance modules." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">D. Lanz</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">L. Novikov</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">MITRE</td>
</tr>
<tr>
<td class="left">Expires: January 26, 2012</td>
<td class="right">July 25, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Common Interface to Cryptographic Modules (CICM) Logical Model <br />
  <span class="filename">draft-lanz-cicm-lm-01</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines an abstract model for high assurance cryptographic modules. It defines the relevant terminology and high-level descriptions of the types of services and operations offered by such modules. The goal is to provide a common vocabulary for discussing the programming of high assurance modules.</p>
<p>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 26, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Background</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Language Independent</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Audience</a>
</li>
<li>1.4.   <a href="#rfc.section.1.4">Scope of the Specification</a>
</li>
<li>2.   <a href="#rfc.section.2">Use Cases</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Data-in-Transit</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Data-at-Rest</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Single Security Domain</a>
</li>
<li>3.   <a href="#rfc.section.3">Module Management</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Managing Module Authentication</a>
</li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">Managing Hardware Access Tokens</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Managing Users</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Logging in to a Module from a Host</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Managing Software Packages</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Managing Logs</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Managing Tests</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Managing Module Events</a>
</li>
<li>4.   <a href="#rfc.section.4">Key Management</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Creating and Establishing Keys</a>
</li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">No Host Interaction Key Fill</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Client Program-Initiated</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">Module/Key Infrastructure Initiated</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Exporting Keys</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Locating and Retrieving Information about a Key</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Applying Metadata to Keys</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Performing Operations on Keys</a>
</li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">Enabling Remote Management</a>
</li>
<li>5.   <a href="#rfc.section.5">Channel Management</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Creating Channels</a>
</li>
<li>5.1.1.   <a href="#rfc.section.5.1.1">Encryption and Decryption</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Bypass</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Integrity</a>
</li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">Hashing</a>
</li>
<li>5.1.5.   <a href="#rfc.section.5.1.5">Keystream Generation</a>
</li>
<li>5.1.6.   <a href="#rfc.section.5.1.6">Random Data</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Managing Channels</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Using Channels</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Grouping Channels</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Receiving Notification of Channel Events</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Destroying Channels</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Unauthorized Usage</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Inappropriate Usage</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Confidentiality and Data Integrity</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Bypass</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Entity Authentication</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Terms</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Background</h1>
<p id="rfc.section.1.1.p.1">Sensitive data is increasingly under attack, whether in transit or at rest. The computer security community has responded to these threats by using cryptography to secure sensitive data. To counter the growing number and types of threats against systems processing sensitive data, module vendors have engineered a diverse set of cryptographic modules.</p>
<p id="rfc.section.1.1.p.2">Systems that require cryptographic protection may use various cryptographic services including data encryption, signature generation, hashing, and keystream generation. Cryptographic modules providing these services and the key material they hold must be managed. All of these services have proprietary interfaces that differ significantly among module types, leading to the following problems:</p>
<p></p>

<ul>
<li>Replacement of one module type for another and reuse of module-dependent software are inhibited as applications require extensive modifications to adapt to new module types and their proprietary interfaces.</li>
<li>Developers of systems that host cryptographic modules must accommodate different cryptographic module interfaces for different types of cryptographic modules.</li>
<li>Test tools and procedures developed for one module usually will not work with other modules.</li>
<li>Security evaluators must learn multiple module developers' interfaces, increasing evaluation time and expense.</li>
</ul>
<p id="rfc.section.1.1.p.4">To address these problems, this document outlines a logical model for the Common Interface to Cryptographic	Modules (CICM) specification which offers module developers a set of standard programming interfaces for the set of operations supported by high	assurance cryptographic modules. Although many Application Programming Interfaces (APIs) intended for commercial cryptography are available, the CICM specification was designed for high assurance environments, but may be used in other environments as well.</p>
<p id="rfc.section.1.1.p.5">Modules do not require changes to support the use of CICM. A module-specific abstraction layer between the library implementing CICM interfaces and the module performs the needed translations between the CICM model of a module and the model presented by a specific module. This abstraction component may be provided by the module developer, a module embedder/integrator, or another interested party. This arrangement is analogous to manufacturers of computer peripheral devices providing platform or operating system-specific drivers for their peripheral devices.</p>
<p id="rfc.section.1.1.p.6">The benefits of using standard interfaces to access cryptographic services include:</p>
<p></p>

<ul>
<li>Provide a common, logical model of cryptographic modules that is straightforward to learn and easy to use.</li>
<li>Enable the replacement of one cryptographic module for another without significant modifications to the client programs that interact and use the cryptographic module, assuming certain compatibility characteristics between the modules exist.</li>
<li>Accommodate binding to multiple programming languages.</li>
<li>Enforce the correct use of the API; in particular, interfaces must be used in the intended order, imposable at compile time or recognizable via static analysis.</li>
<li>Support high assurance evaluation by enabling evaluators to quickly validate that a particular implementation uses only the required functions in the manner they were intended.</li>
</ul>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Language Independent</h1>
<p id="rfc.section.1.2.p.1">CICM is defined using Interface Definition Language (IDL) <a href="#IDL">[IDL]</a>, a specification language that describes a software interface in a language-neutral way. The specification currently does not specify normative bindings for specific programming languages, although bindings for common languages can be generated from the IDL provided with the specification. However, normative bindings for one or more popular programming languages will be made available in a future release of the specification.</p>
<p id="rfc.section.1.2.p.2">The use of IDL in CICM is not intended to either prescribe or preclude a particular communications protocol such as General Inter-ORB Protocol (GIOP) <a href="#CORBA">[CORBA]</a> between programs in different address	spaces or on different devices.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Audience</h1>
<p id="rfc.section.1.3.p.1">The CICM specification is written for computer programmers, software engineers, and technical architects with a background in data security and cryptography. Knowledge of object-oriented programming concepts is useful when reading IDL definitions. Software engineers may use the specification when developing software that integrates with cryptographic modules.  Technical architects may use the specification when designing systems that incorporate cryptographic modules to secure data within the system or between systems.</p>
<p id="rfc.section.1.3.p.2">Although the specification is targeted to software developers who will access module services using a compliant implementation, it also addresses module developers and others who implement library and other support software.</p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> Scope of the Specification</h1>
<p id="rfc.section.1.4.p.1">The CICM model should provide a common way to access the following services offered by cryptographic modules: </p>

<ul>
<li>Cryptographic module management: Includes retrieving information about a specific module, managing access control, managing module events, and loading and managing software packages on modules.</li>
<li>Key management: Includes the generation, storage, protection, and removal of key material, and support for message exchanges used in key agreement and key transfer protocols.</li>
<li>Channel management: A channel defines a specific cryptographic transform and encapsulates all attributes associated with that transform. Channel management includes channel instantiation, channel control throughout its lifetime, providing data to a channel for transformation, and extracting transformed data from a channel.</li>
</ul>
<p id="rfc.section.1.4.p.2">The following elements are not addressed: </p>

<ul>
<li>Hardware interfaces, protocols, or design</li>
<li>Details of specific protocols (The model provides a means to move protocol messages into and out of a module, but does not dictate low level protocol.)</li>
<li>Internal structure of certain types of data elements (e.g., software packages imported into a module, test results extracted from a module)</li>
<li>Policy enforcement (The model provides a means to convey policy elements to the module, but policy enforcement is considered a module responsibility.)</li>
<li>Organization of the information stored and processed within a module</li>
<li>Separation of commands/data for multiple security domains that access a single CICM library instance (e.g., Multiple Levels of Security).</li>
</ul>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Use Cases</h1>
<p id="rfc.section.2.p.1">A significant characteristic that differentiates CICM from other cryptographic interfaces such as Cryptoki <a href="#PKCS-11">[PKCS-11]</a>, GSS-API <a href="#RFC5554">[RFC5554]</a>, and <a href="#JCA">[JCA]</a> is its ability to support cryptographic modules that separate two security domains. The use cases that follow capture this fundamental element of the CICM model. These use cases can be divided into two basic types: </p>

<ul>
<li>Cryptographic transformation of data initiated in one security domain with the result made available in another security domain</li>
<li>Cryptographic transformation of data within a single security domain: Cryptographic hash or digital signature operations may be initiated in the same security domain where the result is received. Other single domain use cases include data encryption/decryption for storage and keystream/random data generation.</li>
</ul>
<p id="rfc.section.2.p.2">The data-in-transit and data-at-rest use cases illustrated below incorporate multiple security domains, while the final use case depicts a transformation within a single domain.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Data-in-Transit</h1>
<p id="rfc.section.2.1.p.1">The figure below shows a hardware device with an embedded cryptographic module providing encryption and decryption services between a secure and non-secure network. The secure side protocol logic subsystems access cryptographic services using CICM. In this use case, the High Assurance IP Encryptor (HAIPE) device uses CICM to enable the internal protocol logic of the device to access cryptographic services; the network to which the HAIPE device is connected does not interface to the protocol encryptor using CICM.</p>
<div id="#rfc.figure.1"></div>
<pre>
                  High Assurance IP Encryptor
        +----------------------------.-----------------+
        |    HAIPE              Cryptographic  HAIPE   |
Secure &lt;-&gt; Protocol &lt;-&gt; CICM &lt;-&gt;  Module &lt;-&gt; Protocol &lt;-&gt; Non-Secure
Network |    Logic                   .         Logic   |   Network
        +----------------------------.-----------------+
                                     .
                               Security Domain
                                  Boundary
</pre>
<p>Figure 1. First Data-in-Transit Use Case, HAIPE</p>
<p id="rfc.section.2.1.p.2">The following figure depicts the same use case in its end-to-end configuration.</p>
<div id="#rfc.figure.2"></div>
<pre>
                                      Security Domain
                                         Boundary
                                            .
             +------------------------------.--------+
             |   HAIPE                      .        |
( Secure  ) &lt;-&gt; Protocol &lt;-&gt; CICM &lt;-&gt; Cryptographic &lt;---+
( Network )  |   Logic                    Module     |  |
             +------------------------------.--------+  |
                                                        |
          +-------------&gt; ( Non-Secure ) &lt;--------------+
          |               (  Network   )
          |
          |  +--------.------------------------------+
          |  |        .                     HAIPE    |
          +---&gt; Cryptographic &lt;-&gt; CICM &lt;-&gt; Protocol &lt;-&gt; ( Secure  )
             |      Module                  Logic    |  ( Network )
             +--------.------------------------------+
                      .
                Security Domain
                   Boundary
</pre>
<p>Figure 2. HAIPE Use Case in End-to-End Configuration</p>
<p id="rfc.section.2.1.p.3">A second data-in-transit use case shows a tactical secure radio with an embedded cryptographic module providing encryption and decryption services between a local host and a radio frequency environment. The functional blocks that make up the tactical secure radio are logically identical to those in the first example.</p>
<div id="#rfc.figure.3"></div>
<pre>
                     Tactical Secure Radio
      +----------------------------.---------------------+
Host &lt;-&gt; Information &lt;-&gt; CICM &lt;-&gt; Module &lt;-&gt;   Waveform &lt;-&gt; RF
      |  Processing                .          Processing |
      +----------------------------.---------------------+
                                   .
                             Security Domain
                                Boundary
</pre>
<p>Figure 3. Second Data-in-Transit Use Case, Tactical Secure Radio</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Data-at-Rest</h1>
<p id="rfc.section.2.2.p.1">The figure below shows a cryptographic module providing encryption services for data stored on a disk and decryption services for data read from a disk. A file system driver accesses cryptographic services using CICM.  This use case could apply to a laptop computer that contains encrypted data; it would prevent access to sensitive data from a lost or stolen laptop.</p>
<div id="#rfc.figure.4"></div>
<pre>
                    Host                         .
      +---------------------------------+        .
User &lt;-&gt;   Word    &lt;-&gt;  File  &lt;-&gt; CICM &lt;-&gt; Cryptographic &lt;-&gt; Disk
      |  Processor     System           |      Module
      +---------------------------------+        .
                                                 .
                                           Security Domain
                                              Boundary
</pre>
<p>Figure 4. Data-at-Rest Use Case</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Single Security Domain</h1>
<p id="rfc.section.2.3.p.1">The following figure shows a cryptographic transform within a single security domain (it assumes that the transform does not change the classification of the data).  The plaintext is conveyed to the module, transformed by an encryption algorithm, and results in ciphertext. This information is then returned to the same domain from which the plaintext originated. Other natural examples of a single domain use case include signing, which results in a digital signature; hashing, which results in a hash value; and keystream generation, which results in keystream data.</p>
<div id="#rfc.figure.5"></div>
<pre>
      1. Query              2. Load
User &lt;---------&gt; Database &lt;---------&gt; Disk
                 Back end
                    |
                    +---------------&gt; Cryptographic
                       3. Decrypt         Module
</pre>
<p>Figure 5. Single Security Domain Use Case</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Module Management</h1>
<p id="rfc.section.3.p.1">The fundamental element of the CICM model is the MODULE -- an abstraction which refers to the cryptographic module and its capabilities.  A single CICM library may provide access to multiple modules.</p>
<p id="rfc.section.3.p.2">Each module contains references to information about the module, including the module  manufacturer, serial number, and version numbers.  Modules also defines attributes called MANAGERS that provide access to the services made available by the module.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#mm-auth" id="mm-auth">Managing Module Authentication</a>
</h1>
<p id="rfc.section.3.1.p.1">Modules may require a host or user to authenticate to the module before the module will enter an operational state, allowing it to accept commands and perform cryptographic transformations. In some cases, a specialized, removable hardware component will perform or participate in the authentication. This hardware component is termed a HARDWARE ACCESS TOKEN in CICM nomenclature, although other communities may use different terminology. Most implementations that use hardware access tokens will transfer key material between the token and module, independent of CICM. In cases where access tokens are not supported, a user may provide authentication credentials to the module via CICM. In still other cases, support for multi-factor authentication will require a token and a user login. Note that the user and token holder may be different entities.</p>
<p id="rfc.section.3.1.p.2">CICM provides interfaces that can be used separately or in combination with one another as appropriate for the system using them and for the authentication mechanisms offered by the module that is used by the system. Methods to manage module/token associations are available for systems where hardware access tokens are supported. Login methods and related user management methods are supported for systems that require user login.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> Managing Hardware Access Tokens</h1>
<p id="rfc.section.3.1.1.p.1">The TOKEN MANAGER defines methods that support associating a token with a module, disassociating a token from a module, and disassociating a module from a token. The manager also supports retrieving a list of token associations on a module and module associations on a token.</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> Managing Users</h1>
<p id="rfc.section.3.1.2.p.1">The USER MANAGER defines methods that support adding users to and removing users from a module user database, and associating a user with a module-defined ROLE. The manager also supports listing the user database, and the roles defined and supported by the module.</p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> Logging in to a Module from a Host</h1>
<p id="rfc.section.3.1.3.p.1">The LOGIN MANAGER defines methods that enable a user configured on a module to login to and logout from a module.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Managing Software Packages</h1>
<p id="rfc.section.3.2.p.1">The PACKAGE MANAGER defines methods that support importing and managing the executable images that reside on a cryptographic module. These methods enable module software/firmware PACKAGES to be imported and other software package management operations to be performed, including retrieving a list of packages, and activating or deleting a specific package.</p>
<p id="rfc.section.3.2.p.2">The package manager enables packages to be imported into a module in segments rather as an atomic unit. This supports modules that must make special provisions to import executable images due to internal storage space limitations.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#mm-logs" id="mm-logs">Managing Logs</a>
</h1>
<p id="rfc.section.3.3.p.1">Modules generate log entries as they operate.  The LOG MANAGER defines methods that support retrieving individual log entries or extracting an entire log from a module.  Additionally, clients may clear individual log entries or the entire module log.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Managing Tests</h1>
<p id="rfc.section.3.4.p.1">Modules may incorporate built-in tests to validate that module functionality is operating as designed. Some tests may be externally initiated. The TEST MANAGER defines methods that support host-initiated module tests.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> Managing Module Events</h1>
<p id="rfc.section.3.5.p.1">The MODULE EVENT MANAGER defines methods that support registering/unregistering module-generated event notifications received by a client program. Clients can register custom-developed CALLBACK procedures, called LISTENERS, for specific module events. When the condition associated with a specific listener presents itself, the registered listener is called.</p>
<p id="rfc.section.3.5.p.2">Examples of events for which listeners may be registered include: </p>

<ul>
<li>Hardware access token has been inserted or removed.</li>
<li>Module is ready to receive traffic.</li>
<li>Alarm condition is raised.</li>
<li>Hardware zeroization condition raised.</li>
<li>Continuous module/engine health test failed.</li>
<li>Usable lifespan of key expired.</li>
<li>Change in module power state.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Key Management</h1>
<p id="rfc.section.4.p.1">Cryptographic modules use key material under their protection as one input to perform a cryptographic transformation. Keys </p>

<ul>
<li>can originate at a Key Infrastructure Component that has a trust relationship with the module</li>
<li>may be agreed upon between the module and another entity</li>
<li>may be generated on the module itself</li>
<li>may be derived from information presented to the module by a client program.</li>
</ul>
<p id="rfc.section.4.p.2">Once established on a module, they may be subject to client-initiated management operations or may be used as part of a cryptographic channel to effect cryptographic transformations.</p>
<p id="rfc.section.4.p.3">CICM treats SYMMETRIC KEYS and ASYMMETRIC KEYSETS separately. An asymmetric keyset may comprise an asymmetric key pair, the public and private key components of a keypair, the digital certificate corresponding to the keyset public key, one or more verification certificates in the certificate chain of trust, and related public domain parameters.</p>
<p id="rfc.section.4.p.4">The ASYMMETRIC KEY MANAGER and SYMMETRIC KEY MANAGER attributes allow for access to asymmetric keysets and symmetric keys, respectively.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Creating and Establishing Keys</h1>
<p id="rfc.section.4.1.p.1">Keys may be moved into a module in one of several scenarios. Each scenario is described in detail below.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> No Host Interaction Key Fill</h1>
<p id="rfc.section.4.1.1.p.1">Specialized hardware devices designed to transfer key from a key infrastructure component to a specific cryptographic module may fill key into a module without host involvement and thus no API interaction. In some cases, this process does not support transferring key metadata with a key. This requires host and API interaction to apply metadata to the key inside the module upon completion of the fill.</p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> Client Program-Initiated</h1>
<p id="rfc.section.4.1.2.p.1">In some cases, key fill devices require host interaction to initiate a key fill. In such cases, the target key storage location or key tagging information can be specified prior to the initiation of the fill.</p>
<p id="rfc.section.4.1.2.p.2">Keys may be imported directly or derived using a text-based secret provided by the user of the client program.  Keys also may be generated on the module. Each case results in a persistent key.</p>
<p id="rfc.section.4.1.2.p.3">A key also is implicitly established each time a channel is created using an asymmetric keyset and upon renegotiation. Keys resulting from channel-based key agreement are ephemeral; they are not generally managed outside of a channel. Ephemeral keys also may be destroyed when a channel is destroyed.</p>
<h1 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#km-keyproto" id="km-keyproto">Module/Key Infrastructure Initiated</a>
</h1>
<p id="rfc.section.4.1.3.p.1">A facility to operate a key agreement protocol with an infrastructure component is supported. This facility also enables key material or key revocation information to be authenticated by one of the module's trust anchors, and then loaded into the module.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Exporting Keys</h1>
<p id="rfc.section.4.2.p.1">Methods to export key material out of a module are supported. A module may require wrapping the key material prior to export or may disallow this operation.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> Locating and Retrieving Information about a Key</h1>
<p id="rfc.section.4.2.1.p.1">A method to locate a specific key on a module based upon identification information associated with the key is supported. In addition, the entire key database may be listed.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> Applying Metadata to Keys</h1>
<p id="rfc.section.4.2.2.p.1">Key metadata may be retrieved and set for individual keys. Metadata elements include the key identifier, alias, and classification. Untagged keys that are imported via a fill device may require certain metadata to be applied after the conclusion of the load.</p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> Performing Operations on Keys</h1>
<p id="rfc.section.4.2.3.p.1">A number of management operations on keys are supported. Keys may be wrapped (cryptographically protected) in preparation for export, or unwrapped after import. All key material on the module can be zeroized either on a key-by-key basis or as a whole. There are also operations to perform key conversions and updates.</p>
<h1 id="rfc.section.4.2.4">
<a href="#rfc.section.4.2.4">4.2.4.</a> Enabling Remote Management</h1>
<p id="rfc.section.4.2.4.p.1">CICM supports various key management-related protocol messages including remote key functions (e.g., remote zeroize or rekey), infrastructure-initiated key revocation, and trust anchor management.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#cm" id="cm">Channel Management</a>
</h1>
<p id="rfc.section.5.p.1">The CHANNEL is the fundamental construct under which one or more related cryptographic transforms are performed, and within which all details and attributes associated with the transform are encapsulated, including the path through the module. Most channels accept data from a port in the local security domain, transform the data, and output the result on a port in another security domain. A channel also may perform transformations within a single security domain, or may accept data for transformation in one domain and output the result in another.  The channel type determines which ports must be specified when a channel is created.</p>
<div id="#rfc.figure.6"></div>
<pre>
               Security Domain         Security Domain
                  Boundary                Boundary
                     .                       .
            +--------.--------+     +--------.--------+
 Client  --(a) Cryptographic (b)---(c) Cryptographic (d) -- Client
Program X   |      Module     |     |      Module     |    Program Y
            +--------.--------+     +--------.--------+
                     .                       .

            X local    X remote     Y remote    Y local
            port (a)   port (b)     port (c)   port (d)
</pre>
<p>Figure 6. Local and Remote Port Nomenclature for Channels that Operate in Two Security Domains</p>
<p id="rfc.section.5.p.2">Three classes of objects are fundamental to the creation and use of CICM channels. A CONTROLLER is used to configure and control a channel. A STREAM enables data to be sent to a module to be transformed, and transformed data to be received using a controller as a foundation. A CONDUIT is the sum of a controller and a stream. Thus, the term "channel" is only an abstraction representing the logical path through the module on which cryptographic transformations are performed.</p>
<div id="#rfc.figure.7"></div>
<pre>
+----------------------------------------+
|                  Channel               |
|                                        |
|  +-----------------------+             |
|  |             +--------------------+  |
|  | Controller  | Conduit |   Stream |  |
|  +-----------------------+          |  |
|                +--------------------+  |
+----------------------------------------+
</pre>
<p>Figure 7. Relationship Between Channel, Conduit, Controller, and Stream</p>
<p id="rfc.section.5.p.3">This division of responsibility makes channels very flexible.  One client program can be responsible for creating and managing channels with a controller, and another can send data over this pre-configured channel for transformation using a stream. In some environments, data to be transformed never enters the host to pass through the API. Instead, it is clocked directly through the module. In this situation, a controller is configured, but no stream is configured since it would never be used. In other cases, a client program is required to configure the channel and pass data through the channel it configured. In this case, the client program configures a conduit, which incorporates a controller and a stream.</p>
<p id="rfc.section.5.p.4">Both controllers and conduits accept symmetric keys, requiring that the client program configuring the channel and its remote peer share the same secret key. Alternatively, all peers may hold their own respective asymmetric keysets, requiring a key negotiation which, upon successful completion, results in each peer holding an ephemeral symmetric key. CICM supports a NEGOTIATOR for this purpose.  A successful negotiation results in a negotiated controller or conduit.</p>
<p id="rfc.section.5.p.5">CICM supports the following channel types: </p>

<ul>
<li>Encryption/decryption, including selective bypass</li>
<li>Signature generation/verification</li>
<li>Message Authentication Code (MAC) generation/verification</li>
<li>Cryptographic hashing</li>
<li>Keystream generation</li>
<li>Random/pseudo-random data generation</li>
<li>Key wrap</li>
<li>Full bypass.</li>
</ul>
<p id="rfc.section.5.p.6">CICM also supports hybrid channel types. A channel that simultaneously supports encryption and signature, resulting in both ciphertext and a final signature value, is a hybrid channel.</p>
<p id="rfc.section.5.p.7">Each of the types above differs in the way it is configured, its configuration options, and how it handles the cryptographic transformation of data. Consider the following examples portraying the diversity of the channel types: </p>

<ul>
<li>The encryption channel accepts plaintext to be transformed, and can return the resulting ciphertext directly to the caller or route it a different security domain</li>
<li>The random data generation channel requires no data for transformation, but emits a random stream</li>
<li>The signature channel accepts an indeterminate amount of data, and returns an algorithm-specific fixed-sized value</li>
<li>The hashing channel does not accept a cryptographic key as a parameter, as most of the other channel types do (keyed hashes are supported by MAC channels)</li>
<li>The decryption channel accepts a state vector input parameter, but does not allow a state vector to be generated.</li>
</ul>
<p id="rfc.section.5.p.8">This diversity results from the fundamental characteristics of the cryptographic primitives that are being abstracted. The CHANNEL MANAGER defines the methods that support creating conduits, controllers, streams, and negotiators for each of the channel services listed above.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Creating Channels</h1>
<p id="rfc.section.5.1.p.1">Creating a channel requires an awareness of the options available: </p>

<ul>
<li>The type of cryptographic operation desired (encryption, hashing, keystream generation, etc.)</li>
<li>How the channel will be used (control-only, send/receive data only, or both control and send/receive data)</li>
<li>The type of key that will be used for channels that require a symmetric key or an asymmetric keyset (hybrid channels accept two keys).</li>
</ul>
<p id="rfc.section.5.1.p.2">Selecting among these options enables the client program developer to determine what channel interface to use.</p>
<p id="rfc.section.5.1.p.3">In cases where an asymmetric keyset is used, channels are created as a result of a key agreement protocol negotiation with a remote peer.  To ensure that it is the expected peer, a human user at the client may validate information extracted from the peer's certificate.  If the module uses a trusted display, the module communicates the peer information directly to the display. Based upon user input at the display, host-independent negotiation is continued or aborted. If no trusted display is available, the client program requests information about the remote peer, displays it at the host for user confirmation, and provides positive confirmation via the API that the peer is valid, allowing the negotiation to continue.</p>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> Encryption and Decryption</h1>
<p id="rfc.section.5.1.1.p.1">CICM defines interfaces to support encryption and decryption between two security domains or within a single security domain. Additional variants are defined including hybrid channels that can concurrently compute integrity values. Another set of variants provides methods to perform encryption/decryption with selective bypass.</p>
<p id="rfc.section.5.1.1.p.2">If an asymmetric keyset is used to create a channel, a negotiation process is initiated, which results in a negotiated channel. Negotiated versions of hybrid channels also are available.  For those negotiator versions that combine encryption with integrity value generation, negotiation applies only to the encryption key specified when the channel is negotiated, not the signature or MAC key.</p>
<p id="rfc.section.5.1.1.p.3">Channel-based multiple key wrap/unwrap support is provided via a special channels for that purpose.</p>
<p id="rfc.section.5.1.1.p.4">CICM also supports encryption/decryption channels that operate in coprocessor mode . These channels accept their input and return their output as part of the same method call. Where relevant, the integrity value or verification status (verified/not verified) is returned when the final block of the input has been presented for transformation.</p>
<p id="rfc.section.5.1.1.p.5">Duplex channel configurations that use the same key to perform encrypt and decrypt transformations also are supported. Negotiated versions of the duplex channel also are available.</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> Bypass</h1>
<p id="rfc.section.5.1.2.p.1">Bypass channels capable of defining a path through a module and then bypassing data from one security domain to a different domain are supported. Selective bypass also is supported on encryption and decryption channels.</p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> Integrity</h1>
<p id="rfc.section.5.1.3.p.1">Interfaces to compute and validate integrity values using asymmetric key-derived digital signatures or symmetric key-derived MACs are available. A variant on the sign and verify interfaces accepts a previously generated hash value in place of a message.</p>
<h1 id="rfc.section.5.1.4">
<a href="#rfc.section.5.1.4">5.1.4.</a> Hashing</h1>
<p id="rfc.section.5.1.4.p.1">A channel to calculate a fixed-length cryptographic hash from an input message is available. Keyed hashes are supported by MAC channels.</p>
<h1 id="rfc.section.5.1.5">
<a href="#rfc.section.5.1.5">5.1.5.</a> Keystream Generation</h1>
<p id="rfc.section.5.1.5.p.1">Channels are supported to read keystream from a module.</p>
<h1 id="rfc.section.5.1.6">
<a href="#rfc.section.5.1.6">5.1.6.</a> Random Data</h1>
<p id="rfc.section.5.1.6.p.1">Separate interfaces are defined to retrieve random or pseudorandom data from a module.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Managing Channels</h1>
<p id="rfc.section.5.2.p.1">Only conduits and controllers (not streams) can manage channels. Negotiators can manage the negotiation aspects of a channel.</p>
<p id="rfc.section.5.2.p.2">The management operations that can be performed on a channel are specific to each channel type, but the following general operations are supported: </p>

<ul>
<li>Generating, extracting, and setting state vectors</li>
<li>Resynchronization</li>
<li>Initiating a key rollover</li>
<li>Initiating a key update.</li>
</ul>
<p id="rfc.section.5.2.p.3">Negotiators support the following general operations: </p>

<ul>
<li>Renegotiation</li>
<li>Changing classification level/acknowledging change of classification level.</li>
</ul>
<p id="rfc.section.5.2.p.4">Managing state vectors is an important channel management capability. CICM provides a method to explicitly generate a state vector for those algorithms/modes that require a random initialization vector (IV), although modules may alternatively generate an IV as a byproduct of channel creation.  CICM also provides a method to set the state vector on a channel.  This may be used to: </p>

<ul>
<li>Set the decrypt channel to the IV generated/used on the encrypt side of a channel.</li>
<li>Provide a vector on a block-by-block basis for appropriate algorithms/modes or at each time epoch (e.g., time-of-day encryption). In addition, a method is available to take a special state vector called a synchronization vector to assist in resynchronizing a channel.</li>
</ul>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> Using Channels</h1>
<p id="rfc.section.5.3.p.1">Only conduits and streams (not controllers) can send data for transformation and receive cryptographically transformed data on a channel.</p>
<p id="rfc.section.5.3.p.2">The data operations that can be performed on a channel or stream are specific to each channel type, but the following general operations are supported: </p>

<ul>
<li>Sending data on a channel to initiate a cryptographic transformation: <ul>
<li>Blocking send: Call does not return until data has been sent or the operation times out.</li>
<li>Non-blocking send: Call queues data for sending and returns immediately to the caller.</li>
<li>Poll: Determines status of non-blocking send operation.</li>
</ul>
</li>
<li>Receiving transformed data from a channel: <ul>
<li>Blocking read: Blocks until data becomes available or the operation times out.</li>
<li>Non-blocking read: Call queues a buffer to receive data and returns immediately.</li>
<li>Poll: Determines status of non-blocking read operation.</li>
<li>Notification via callback that data has become available using a channel event listener.</li>
</ul>
</li>
</ul>
<p id="rfc.section.5.3.p.3">Although it is possible for multiple client programs to use the same stream, the model provides no facilities to coordinate the parties participating in the communication.</p>
<p id="rfc.section.5.3.p.4">Certain channel services support receiving an "answer" from a channel. For example, signature and hashing channels accept variable amounts of data for transformation before returning a final, constant-sized "answer" (a signature or a hash) to the caller. HYBRID CHANNELS require sending/receiving data and receiving a final "answer" after a discrete unit of data has been transformed.</p>
<p id="rfc.section.5.3.p.5">The figure below depicts the use of a hybrid channel. Plaintext is sent through CICM for transformation. The module performs encrypt and sign transformations on the plaintext data.  Ciphertext resulting from the encrypt transform emits from the module in a different security domain than the one in which it originated. When it is finished presenting data for transformation, the client program requests the signature that results from the transaction.</p>
<div id="#rfc.figure.8"></div>
<pre>                          .
        Plaintext         .       Ciphertext
  Host  ---------&gt;  Cryptographic ----------&gt;
        &lt;---------      Module
         Signature        .
                          .
                    Security Domain
                       Boundary

</pre>
<p>Figure 8. Hybrid Sign-Encrypt Channel Operations</p>
<p id="rfc.section.5.3.p.6">Each type of channel supports a specific set of channel data operations. Channel types and the data operations they support are listed below: </p>

<ul>
<li>Encrypt, selective bypass with encryption, and full bypass write channels: Write data in the local security domain for transformation and output in another security domain.</li>
<li>Decrypt, selective bypass with decryption, and full bypass read channels: Read transformed data from one security domain into the local security domain.</li>
<li>Coprocessor channels: Data is presented for transformation and the result received within the same security domain.</li>
<li>Duplex channels: Read/write exchange between two security domains.</li>
<li>Keystream and random data generation: Transformation within module results in data stream that emits in the local domain.</li>
</ul>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> Grouping Channels</h1>
<p id="rfc.section.5.4.p.1">Controllers and conduits can be grouped to enable certain characteristics to be shared. One characteristic may be the state vector associated with the channels. This supports environments where two or more channels with related security rules supporting a single operation are used within a system. Whenever a shared characteristic is changed on a controller or conduit in a group, the effect of this change is applied to all controllers/conduits in the group.</p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> Receiving Notification of Channel Events</h1>
<p id="rfc.section.5.5.p.1">The CICM model defines methods that support managing module event notifications.  Similar support is available at the granularity of an individual conduit/controller. Conduits and controllers define methods that support registering/unregistering channel-specific module-generated event notifications captured by a client program. Clients can register custom-developed callback procedures called listeners for specific channel events. When the condition associated with a specific listener presents itself, the registered listener is called.</p>
<p id="rfc.section.5.5.p.2">Examples of channel events for which listeners may be registered include: </p>

<ul>
<li>Data is available.</li>
<li>Synchronization with peer has been lost.</li>
<li>Remote peer no longer available.</li>
<li>General channel error encountered.</li>
</ul>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> Destroying Channels</h1>
<p id="rfc.section.5.6.p.1">Conduits and controllers may be destroyed when their services are no longer needed. A channel is destroyed without regard for users who may have pending operations on the channel. Any ephemeral keys associated with the channel also may be destroyed. A stream ceases to function when its associated controller is destroyed. A destroyed channel is removed from any channel groups to which it belongs without effect upon other controllers/conduits in the group.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> IANA Considerations</h1>
<p id="rfc.section.6.p.1">[RFC Editor: Please remove this section prior to publication.]</p>
<p id="rfc.section.6.p.2">This document has no IANA actions.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Security Considerations</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Unauthorized Usage</h1>
<p id="rfc.section.7.1.p.1">Cryptographic modules are typically protected assets and most have built-in mechanisms for preventing unauthorized usage. <a href="#mm-auth">Section 3.1</a> discusses several mechanisms for preventing unauthorized usage including using hardware access tokens and user login. Specific implementations may also consider the use of access control lists.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Inappropriate Usage</h1>
<p id="rfc.section.7.2.p.1">The log manager described in <a href="#mm-logs">Section 3.3</a> may be used by some modules to report certain types of usage which may act as a type of audit log thereby providing information about inappropriate usage.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Confidentiality and Data Integrity</h1>
<p id="rfc.section.7.3.p.1">Many of CICM's channel types provide confidentiality services such as encryption and decryption as well as data integrity services such as hashing, MACing, signing, and verifying.</p>
<p id="rfc.section.7.3.p.2">Hybrid channels provide a combination of confidentiality and data integrity service.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> Bypass</h1>
<p id="rfc.section.7.4.p.1">There are four broad categories of bypass that are supported: reading and writing full bypass; encrypting and decrypting with selective bypass. These services must be used with caution in order to avoid accidental or malicious bypass of protected data.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> Entity Authentication</h1>
<p id="rfc.section.7.5.p.1">As described in <a href="#cm">Section 5</a>, a negotiator is the primary mechanism for establishing that the peer entity is the one desired.</p>
<p id="rfc.section.7.5.p.2">Similarly, the mechanism described in <a href="#km-keyproto">Section 4.1.3</a> ensures that the infrastructure component that is attempting to send data to the module is trusted.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC4949">[RFC4949]</b></td>
<td class="top">
<a>Shirey, R.</a>, "<a href="http://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>", RFC 4949, August 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5554">[RFC5554]</b></td>
<td class="top">
<a>Williams, N.</a>, "<a href="http://tools.ietf.org/html/rfc5554">Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings</a>", RFC 5554, May 2009.</td>
</tr>
<tr>
<td class="reference"><b id="IDL">[IDL]</b></td>
<td class="top">
<a>International Standards Organization</a>, "<a>Information technology &#8212; Open Distributed Processing &#8212; Interface Definition Language</a>", ISO/IEC 14750:1999(E), March 1999.</td>
</tr>
<tr>
<td class="reference"><b id="CORBA">[CORBA]</b></td>
<td class="top">
<a>Object Management Group</a>, "<a>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</a>", January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="CNSSI-4009">[CNSSI-4009]</b></td>
<td class="top">
<a>Committee on National Security Systems (U.S. Government)</a>, "<a>National Information Assurance (IA) Glossary</a>", CNSS Instruction No. 4009, revised June 2006.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS-140-2">[FIPS-140-2]</b></td>
<td class="top">
<a>Federal Information Processing Standards Publication (FIPS PUB) 140-2</a>, "<a>Security Requirements for Cryptographic Modules</a>", May 2001.</td>
</tr>
<tr>
<td class="reference"><b id="PKCS-11">[PKCS-11]</b></td>
<td class="top">
<a>RSA Laboratories</a>, "<a>PKCS #11 v2.30: Cryptographic Token Interface Standard</a>", April 2009.</td>
</tr>
<tr>
<td class="reference"><b id="GCS-API">[GCS-API]</b></td>
<td class="top">
<a>The OpenGroup</a>, "<a>Generic Cryptographic Service API</a>", June 1996.</td>
</tr>
<tr>
<td class="reference"><b id="JCA">[JCA]</b></td>
<td class="top">
<a>Oracle</a>, "<a>Java Cryptography Architecture</a>", August 2002.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#terms" id="terms">Terms</a>
</h1>
<p id="rfc.section.Appendix A.p.1">This section contains a list of terms and their corresponding definitions as used in this model.  Following the formatting convention in <a href="#RFC4949">[RFC4949]</a>, each term is preceded by a dollar sign ($) and a space to facilitate automated searching.</p>
<p id="rfc.section.Appendix A.p.2">$ alarm</p>

<ul class="empty"><li>Output signal that denotes that the module has entered an alarm state. An alarm condition may prohibit a module from performing cryptographic operations.</li></ul>
<p id="rfc.section.Appendix A.p.3">$ asymmetric key</p>

<ul class="empty"><li>Pair of related keys, a public key known to everyone and a private key known only to the owning entity. See symmetric key and asymmetric keyset.</li></ul>
<p id="rfc.section.Appendix A.p.4">$ asymmetric keyset</p>

<ul class="empty"><li>May comprise one more of the following components: an asymmetric key pair, the public and private key components of a keypair, the digital certificate corresponding to the keyset public key, one or more verification certificates in the certificate chain of trust, and related public domain parameters. See also asymmetric key.</li></ul>
<p id="rfc.section.Appendix A.p.5">$ asynchronous notification</p>

<ul class="empty"><li>Delivery of an indication of a condition or event where, from the point of view of the recipient (the client program), the delivery occurs asynchronously via a callback. See also event and event notification.</li></ul>
<p id="rfc.section.Appendix A.p.6">$ attribute</p>

<ul class="empty"><li>State associated with an instance of an interface.</li></ul>
<p id="rfc.section.Appendix A.p.7">$ authentication</p>

<ul class="empty"><li>Security measure designed to establish the validity of a transmission, message, or originator, or a means of verifying an individual's authorization to receive specific categories of information (<a href="#CNSSI-4009">[CNSSI-4009]</a>).</li></ul>
<p id="rfc.section.Appendix A.p.8">$ authorization</p>

<ul class="empty"><li>Access privileges granted to a user, program, or process (<a href="#CNSSI-4009">[CNSSI-4009]</a>).</li></ul>
<p id="rfc.section.Appendix A.p.9">$ blocking</p>

<ul class="empty"><li>A call to a method is blocking if the method does not return program control to the caller until either the operation has completed or an error is recognized. See also non-blocking.</li></ul>
<p id="rfc.section.Appendix A.p.10">$ buffer</p>

<ul class="empty"><li>Collection of binary data.</li></ul>
<p id="rfc.section.Appendix A.p.11">$ bypass</p>

<ul class="empty"><li>In cryptography, this is an operation whereby all of the data is passed from one security domain through the cryptographic module to the other security domain without having a cryptographic transformation applied to it. See also selective bypass.</li></ul>
<p id="rfc.section.Appendix A.p.12">$ callback</p>

<ul class="empty"><li>Procedure provided by the client program that is to be invoked when an appropriate condition or event is recognized. See also asynchronous notification.</li></ul>
<p id="rfc.section.Appendix A.p.13">$ certificate</p>

<ul class="empty"><li>Digitally signed document that binds a public key with an identity. The certificate contains, at a minimum, the identity of the issuing Certification Authority, the user identification information, and the user's public key (<a href="#CNSSI-4009">[CNSSI-4009]</a>).</li></ul>
<p id="rfc.section.Appendix A.p.14">$ certificate revocation list (CRL)</p>

<ul class="empty"><li>List of certificate serial numbers corresponding to certificates that have been revoked or are no longer valid.</li></ul>
<p id="rfc.section.Appendix A.p.15">$ channel</p>

<ul class="empty"><li>Abstraction under which one or more cryptographic transforms are performed and within which all details associated with the transform are encapsulated, including the path through the module. See also conduit, controller, and stream.</li></ul>
<p id="rfc.section.Appendix A.p.16">$ channel type</p>

<ul class="empty"><li>Cryptographic transform to be applied on a channel.</li></ul>
<p id="rfc.section.Appendix A.p.17">$ client program</p>

<ul class="empty"><li>Program linked to a CICM library running as a single process on a host computer system that accesses cryptographic services and/or to manages a cryptographic module.</li></ul>
<p id="rfc.section.Appendix A.p.18">$ conduit</p>

<ul class="empty"><li>Abstraction that encapsulates channel control and data flow. See also channel, controller, and stream.</li></ul>
<p id="rfc.section.Appendix A.p.19">$ controller</p>

<ul class="empty"><li>Abstraction used to configure and control a channel. See also channel, conduit, and stream.</li></ul>
<p id="rfc.section.Appendix A.p.20">$ coprocessor mode</p>

<ul class="empty"><li>Mode of operation in which cryptographic transformations are performed within a single security domain. For example, in coprocessor mode, a client program provides plaintext to a module, the plaintext is transformed, and the resulting ciphertext is returned to the same client program.</li></ul>
<p id="rfc.section.Appendix A.p.21">$ cryptographic module</p>

<ul class="empty"><li>Abstraction of hardware, firmware, or software components that makes cryptographic services available to client programs via one or more channels.</li></ul>
<p id="rfc.section.Appendix A.p.22">$ cryptographic synchronization</p>

<ul class="empty"><li>Process by which a receiving decrypting cryptographic logic attains the same internal state as the transmitting encrypting logic.</li></ul>
<p id="rfc.section.Appendix A.p.23">$ cryptographic transform</p>

<ul class="empty"><li>The specific cryptographic process that is to be applied to a stream of data or is used to generate keystream or random data, often (but not always) based upon a cryptographic key. Transforms include encryption, decryption, signing, keystream generation, hashing, and random data generation.</li></ul>
<p id="rfc.section.Appendix A.p.24">$ driver</p>

<ul class="empty"><li>Conceptual component residing on a host that enables the exchange of commands and data between the client program and a module. Module-specific abstraction layer that serves as a translation mechanism between the individual functions defined in the CICM library and the commands specific to a given cryptographic module. This component also provides a conduit for data between a host and a module.</li></ul>
<p id="rfc.section.Appendix A.p.25">$ ephemeral symmetric key</p>

<ul class="empty"><li>Symmetric cryptographic key generated as part of a key negotiation process. Ephemeral keys may be destroyed when the channel or session utilizing the ephemeral key completes. Ephemeral keys are not visible if a client program lists the keys on a module. See also static key.</li></ul>
<p id="rfc.section.Appendix A.p.26">$ event</p>

<ul class="empty"><li>Situation occurring on a module or a channel for which a client program may be notified.</li></ul>
<p id="rfc.section.Appendix A.p.27">$ event notification</p>

<ul class="empty"><li>Call from the host runtime system to a client program announcing that a specific situation has occurred. See callback and asynchronous notification.</li></ul>
<p id="rfc.section.Appendix A.p.28">$ grade</p>

<ul class="empty"><li>Negotiated classification level of a channel.</li></ul>
<p id="rfc.section.Appendix A.p.29">$ hardware access token</p>

<ul class="empty"><li>Removable device used to provide locking and unlocking features for the cryptographic capabilities of a cryptographic module.</li></ul>
<p id="rfc.section.Appendix A.p.30">$ host</p>

<ul class="empty"><li>Computer system upon which a client program linked to a CICM library executes.</li></ul>
<p id="rfc.section.Appendix A.p.31">$ hybrid channel</p>

<ul class="empty"><li>Channel that simultaneously supports two fundamental cryptographic services; for example, an encryption with signature channel transforms data, resulting in both ciphertext and a final signature value.</li></ul>
<p id="rfc.section.Appendix A.p.32">$ iterator</p>

<ul class="empty"><li>Software construct that enables a software program to walk through a list of related items.</li></ul>
<p id="rfc.section.Appendix A.p.33">$ key</p>

<ul class="empty"><li>See symmetric key and asymmetric key.</li></ul>
<p id="rfc.section.Appendix A.p.34">$ key agreement protocol</p>

<ul class="empty"><li>Protocol that allows two or more participants to negotiate an ephemeral symmetric key without disclosing the resulting key material to non-participants. The protocol is conducted in such a way that all participants influence the outcome.</li></ul>
<p id="rfc.section.Appendix A.p.35">$ key encryption key</p>

<ul class="empty"><li>Key that encrypts or decrypts another key for transmission or storage.</li></ul>
<p id="rfc.section.Appendix A.p.36">$ key fill device</p>

<ul class="empty"><li>Devices that read-in, transfer, and store key material.</li></ul>
<p id="rfc.section.Appendix A.p.37">$ key fill interface</p>

<ul class="empty"><li>Set of protocols, electrical connections, and physical characteristics that comprise the connecting link between a key fill device and a cryptographic module. CICM enables a key fill interface to be configured and actions to be initiated on a key fill device via the key fill interface.</li></ul>
<p id="rfc.section.Appendix A.p.38">$ key infrastructure</p>

<ul class="empty"><li>Set of hardware, software, people, policies, and procedures needed to create, manage, store, distribute, and revoke key material.</li></ul>
<p id="rfc.section.Appendix A.p.39">$ key rollover</p>

<ul class="empty"><li>Process of moving from one key to another in a pre-defined sequence of keys; may also be referred to as "key supersession."</li></ul>
<p id="rfc.section.Appendix A.p.40">$ key tag</p>

<ul class="empty"><li>Identification information associated with certain types of electronic key (<a href="#CNSSI-4009">[CNSSI-4009]</a>).</li></ul>
<p id="rfc.section.Appendix A.p.41">$ key unwrap</p>

<ul class="empty"><li>Process whereby an encrypted cryptographic key is decrypted using a cryptographic module and a different key.</li></ul>
<p id="rfc.section.Appendix A.p.42">$ key update</p>

<ul class="empty"><li>Deterministic one-way transformation of a symmetric key (and its current update count) to a new key.</li></ul>
<p id="rfc.section.Appendix A.p.43">$ key wrap</p>

<ul class="empty"><li>Process whereby a cryptographic key is encrypted by a cryptographic module using a separate key in a manner sufficient to protect the key at the level of its classification.</li></ul>
<p id="rfc.section.Appendix A.p.44">$ keystream</p>

<ul class="empty"><li>Sequence of symbols produced by a cryptographic module using a cryptographic key to combine with plain text to produce cipher text, control transmission security processes, or produce key (<a href="#CNSSI-4009">[CNSSI-4009]</a>).</li></ul>
<p id="rfc.section.Appendix A.p.45">$ listener</p>

<ul class="empty"><li>Method registered by the client program that will be called upon the occurrence of a specific module event.</li></ul>
<p id="rfc.section.Appendix A.p.46">$ local port</p>

<ul class="empty"><li>Port on module in same security domain in which client program is located to which commands are presented and through which data is sent/received. See also remote port.</li></ul>
<p id="rfc.section.Appendix A.p.47">$ manager</p>

<ul class="empty"><li>Specialized attributes that encapsulate different classes of module, key and channel management functionality.</li></ul>
<p id="rfc.section.Appendix A.p.48">$ message authentication code (MAC)</p>

<ul class="empty"><li>Data associated with an authenticated message allowing a receiver to verify the integrity of the message (<a href="#CNSSI-4009">[CNSSI-4009]</a>).</li></ul>
<p id="rfc.section.Appendix A.p.49">$ method</p>

<ul class="empty"><li>Single CICM library function that performs a specific task.</li></ul>
<p id="rfc.section.Appendix A.p.50">$ namespace</p>

<ul class="empty"><li>An abstract container that holds related interfaces.</li></ul>
<p id="rfc.section.Appendix A.p.51">$ non-blocking</p>

<ul class="empty"><li>A method is non-blocking if it initiates an operation and then returns control to the caller, usually before the outcome of the operation has been determined. See also blocking.</li></ul>
<p id="rfc.section.Appendix A.p.52">$ opaque data object</p>

<ul class="empty"><li>Binary object accepted by or returned from a method call whose structure is imposed by some entity unrelated to the CICM specification.</li></ul>
<p id="rfc.section.Appendix A.p.53">$ package</p>

<ul class="empty"><li>Software, FPGA image, policy database, configuration parameters, or other types of executable or interpretable code that may be imported into and removed from a module.</li></ul>
<p id="rfc.section.Appendix A.p.54">$ persistent key</p>

<ul class="empty"><li>See static key.</li></ul>
<p id="rfc.section.Appendix A.p.55">$ policy</p>

<ul class="empty"><li>Precise specification of the security rules under which a cryptographic module will operate.</li></ul>
<p id="rfc.section.Appendix A.p.56">$ port</p>

<ul class="empty"><li>Identifier that designates a logical interface through which data moves into and out of a cryptographic module. See also local port and remote port.</li></ul>
<p id="rfc.section.Appendix A.p.57">$ remote port</p>

<ul class="empty"><li>Port in non-local security domain from which transformed data is received. See also local port.</li></ul>
<p id="rfc.section.Appendix A.p.58">$ role</p>

<ul class="empty"><li>A designation to which users are assigned that identifies a job type defined in terms of the privileges of that user.</li></ul>
<p id="rfc.section.Appendix A.p.59">$ security domain</p>

<ul class="empty"><li>System or group of systems operating under a common security policy. Communication between domains is controlled in a well-defined manner.</li></ul>
<p id="rfc.section.Appendix A.p.60">$ selective bypass</p>

<ul class="empty"><li>Portion of the traffic through a channel that is not to be cryptographically transformed. Also commonly referred to as "header bypass."</li></ul>
<p id="rfc.section.Appendix A.p.61">$ static key</p>

<ul class="empty"><li>Cryptographic key imported into or established on a module that will remain on the module until it is explicitly removed. See also ephemeral key.</li></ul>
<p id="rfc.section.Appendix A.p.62">$ stream</p>

<ul class="empty"><li>An abstraction representing an entity utilizing an existing controller to enable data to be sent to a module to be transformed and transformed data to be received using a controller as a foundation.</li></ul>
<p id="rfc.section.Appendix A.p.63">$ symmetric key</p>

<ul class="empty"><li>Usually a sequence of random or pseudorandom bits used initially to set up and periodically change the operations performed in crypto-equipment for the purpose of encrypting or decrypting electronic signals (<a href="#CNSSI-4009">[CNSSI-4009]</a>). See asymmetric key.</li></ul>
<p id="rfc.section.Appendix A.p.64">$ system</p>

<ul class="empty"><li>Hardware and software components, including the cryptographic module, that meet a specific set of security-related requirements.</li></ul>
<p id="rfc.section.Appendix A.p.65">$ tamper</p>

<ul class="empty"><li>Output signal from module that denotes it has detected a tamper event.</li></ul>
<p id="rfc.section.Appendix A.p.66">$ token</p>

<ul class="empty"><li>See hardware access token.</li></ul>
<p id="rfc.section.Appendix A.p.67">$ trusted display</p>

<ul class="empty"><li>Hardware component independent of a host to enter or display information to be directly sent to/received from a cryptographic module.</li></ul>
<p id="rfc.section.Appendix A.p.68">$ zeroize</p>

<ul class="empty"><li>Input signal instructing the module to clear its memory of any sensitive cryptographic material. CICM supports both a module zeroize (destroying all key material on module) and zeroizing an individual key. </li></ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Daniel J. Lanz</span> 
	  <span class="n hidden">
		<span class="family-name">Lanz</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dlanz@mitre.org">dlanz@mitre.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Lev Novikov</span> 
	  <span class="n hidden">
		<span class="family-name">Novikov</span>
	  </span>
	</span>
	<span class="org vcardline">The MITRE Corporation</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:lnovikov@mitre.org">lnovikov@mitre.org</a></span>

  </address>
</div>

</body>
</html>