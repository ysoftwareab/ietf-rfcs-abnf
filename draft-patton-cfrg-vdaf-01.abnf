out_shares = []
input_shares = Vdaf.measurement_to_input_shares(public_param,
                                                           measurement)

prep_states = []
state = Vdaf.prep_init(verify_params[j],
                                      agg_param,
                                      nonce,
                                      input_shares[j])
inbound = None
outbound = []
out = Vdaf.prep_next(prep_states[j], inbound)
inbound = Vdaf.prep_shares_to_prep(agg_param,
                                                      outbound)

agg_shares = []
out_shares_j = [out[j] for out in out_shares]
agg_share_j = Vdaf.out_shares_to_agg_share(agg_param,
                                                      out_shares_j)
agg_result = Vdaf.agg_shares_to_result(agg_param, agg_shares)
encoded = Bytes()
L = Field.ENCODED_SIZE
vec = []
encoded_x = encoded[i:i+L]
x = Field(OS2IP(encoded_x))
prg = Prg(seed, info)
m = next_power_of_2(Field.MODULUS) - 1
prg = Prg(seed, info)
vec = []
x = OS2IP(prg.next(Field.ENCODED_SIZE))
stream = AES128-CTR(key, zeros(16), zeros(self.length_consumed))
joint_rand = Flp.Field.rand_vec(Flp.JOINT_RAND_LEN)
prove_rand = Flp.Field.rand_vec(Flp.PROVE_RAND_LEN)
query_rand = Flp.Field.rand_vec(Flp.QUERY_RAND_LEN)

proof = Flp.prove(inp, prove_rand, joint_rand)

verifier = Flp.query(inp, proof, query_rand, joint_rand, num_shares)

k_query_init = gen_rand(Prio3.Prg.SEED_SIZE)
verify_param = [(j, k_query_init) for j in range(Prio3.SHARES)]
dst = b"vdaf-00 prio3"
inp = Prio3.Flp.encode(measurement)
k_joint_rand = zeros(Prio3.Prg.SEED_SIZE)

leader_input_share = inp
k_helper_input_shares = []
k_helper_blinds = []
k_helper_hints = []
k_blind = gen_rand(Prio3.Prg.SEED_SIZE)
k_share = gen_rand(Prio3.Prg.SEED_SIZE)
helper_input_share = Prio3.Prg.expand_into_vec(
               Prio3.Flp.Field,
               k_share,
               dst + byte(j+1),
               Prio3.Flp.INPUT_LEN
leader_input_share = vec_sub(leader_input_share,
                                        helper_input_share)
encoded = Prio3.Flp.Field.encode_vec(helper_input_share)
k_hint = Prio3.Prg.derive_seed(k_blind,
                                          byte(j+1) + encoded)
k_joint_rand = xor(k_joint_rand, k_hint)
k_leader_blind = gen_rand(Prio3.Prg.SEED_SIZE)
encoded = Prio3.Flp.Field.encode_vec(leader_input_share)
k_leader_hint = Prio3.Prg.derive_seed(k_leader_blind,
                                             byte(0) + encoded)
k_joint_rand = xor(k_joint_rand, k_leader_hint)

k_leader_hint = xor(k_leader_hint, k_joint_rand)

prove_rand = Prio3.Prg.expand_into_vec(
           Prio3.Flp.Field,
           gen_rand(Prio3.Prg.SEED_SIZE),
           dst,
           Prio3.Flp.PROVE_RAND_LEN
joint_rand = Prio3.Prg.expand_into_vec(
           Prio3.Flp.Field,
           k_joint_rand,
           dst,
           Prio3.Flp.JOINT_RAND_LEN
proof = Prio3.Flp.prove(inp, prove_rand, joint_rand)
leader_proof_share = proof
k_helper_proof_shares = []
k_share = gen_rand(Prio3.Prg.SEED_SIZE)
helper_proof_share = Prio3.Prg.expand_into_vec(
               Prio3.Flp.Field,
               k_share,
               dst + byte(j+1),
               Prio3.Flp.PROOF_LEN
leader_proof_share = vec_sub(leader_proof_share,
                                        helper_proof_share)

input_shares = []
dst = b"vdaf-00 prio3"
out_share = Prio3.Flp.truncate(input_share)

k_query_rand = Prio3.Prg.derive_seed(k_query_init,
                                            byte(255) + nonce)
query_rand = Prio3.Prg.expand_into_vec(
           Prio3.Flp.Field,
           k_query_rand,
           dst,
           Prio3.Flp.QUERY_RAND_LEN
encoded = Prio3.Flp.Field.encode_vec(input_share)
k_joint_rand_share = Prio3.Prg.derive_seed(k_blind,
                                                      byte(j) + encoded)
k_joint_rand = xor(k_hint, k_joint_rand_share)
joint_rand = Prio3.Prg.expand_into_vec(
               Prio3.Flp.Field,
               k_joint_rand,
               dst,
               Prio3.Flp.JOINT_RAND_LEN
verifier_share = Prio3.Flp.query(input_share,
                                        proof_share,
                                        query_rand,
                                        joint_rand,
                                        Prio3.SHARES)

prep_msg = Prio3.encode_prepare_message(verifier_share,
                                               k_joint_rand_share)
verifier = Prio3.Flp.Field.zeros(Prio3.Flp.VERIFIER_LEN)
k_joint_rand_check = zeros(Prio3.Prg.SEED_SIZE)
verifier = vec_add(verifier, verifier_share)

k_joint_rand_check = xor(k_joint_rand_check,
                                        k_joint_rand_share)

agg_share = Prio3.Flp.Field.zeros(Prio3.Flp.OUTPUT_LEN)
agg_share = vec_add(agg_share, out_share)
agg = Prio3.Flp.Field.zeros(Prio3.Flp.OUTPUT_LEN)
agg = vec_add(agg, agg_share)
encoded = Bytes()
l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.INPUT_LEN
input_share = Prio3.Flp.Field.decode_vec(encoded_input_share)
l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.PROOF_LEN
proof_share = Prio3.Flp.Field.decode_vec(encoded_proof_share)
l = Prio3.Prg.SEED_SIZE
encoded = Bytes()
l = Prio3.Prg.SEED_SIZE
input_share = Prio3.Prg.expand_into_vec(Prio3.Flp.Field,
                                               k_input_share,
                                               dst + byte(j),
                                               Prio3.Flp.INPUT_LEN)
proof_share = Prio3.Prg.expand_into_vec(Prio3.Flp.Field,
                                               k_proof_share,
                                               dst + byte(j),
                                               Prio3.Flp.PROOF_LEN)
encoded = Bytes()
l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.VERIFIER_LEN
verifier = Prio3.Flp.Field.decode_vec(encoded_verifier)
k_joint_rand = None
l = Prio3.Prg.SEED_SIZE
length = 0
P = next_power_of_2(1 + g_calls)
length = 1
encoded = []
decoded = Sum.Field(0)
w = Sum.Field(1 << l)
out = Field128(0)
r = joint_rand[0]
boundaries = buckets + [Infinity]
encoded = [Field128(0) for _ in range(len(boundaries))]
range_check = Field128(0)
r = joint_rand[0]
sum_check = -Field128(1) * Field128(num_shares).inv()
out = joint_rand[1]   * range_check + \
             joint_rand[1]^2 * sum_check
k_verify_init = gen_rand(SEED_SIZE)
A = -2*a + k
B = a*a + b - k*a + c

beta = []
A = -2*a+k
B = a*a + b - a * k + c
correlation_share = Field[l].rand_vec(5)
input_shares = [
       encode_input_share(key_0, correlation_shares_0),
       encode_input_share(key_1, correlation_shares_1),
l = self.l
value = kdpf_key.eval(l, x)
r = Prg.expand_into_vec(Field[l], self.k_verify_rand, len(data_share))
verifier_share_1 = [
         a_share + inner_product(data_share, r),
         b_share + inner_product(data_share, r * r),
         c_share + inner_product(auth_share, r),
verifier_1 = Field[l].decode_vec(inbound)
verifier_share_2 = [
        (verifier_1[0] * verifier_1[0] \
         - verifier_1[1] \
         - verifier_1[2]) * self.party_id \
        + A_share * verifier_1[0] \
        + B_share
verifier_2 = Field[l].decode_vec(inbound)
verifier = Field[l].decode_vec(inbound[0]) + \
             Field[l].decode_vec(inbound[1])

agg_share = Field[l].zeros(len(candidate_prefixes))
agg = Field[l].decode_vec(agg_shares[0]) + \
           Field[l].decode_vec(agg_shares[1]J)

