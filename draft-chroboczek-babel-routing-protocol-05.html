<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The Babel Routing Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The Babel Routing Protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">J. Chroboczek</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">PPS, University of Paris 7</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">October 25, 2010</td></tr>
<tr><td class="header">Expires: April 28, 2011</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />The Babel Routing Protocol<br />draft-chroboczek-babel-routing-protocol-05</h1>

<h3>Abstract</h3>

<p>Babel is a mostly loop-free distance vector routing protocol that is
robust and efficient both in ordinary wired networks and in wireless
mesh networks.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on April 28, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Features<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Limitations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
Specification of Requirements<br />
<a href="#anchor5">2.</a>&nbsp;
Conceptual Description of the Protocol<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">2.1.</a>&nbsp;
Costs, Metrics and Neighbourship<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.</a>&nbsp;
The Bellman-Ford algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.</a>&nbsp;
Transient Loops in Bellman-Ford<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">2.4.</a>&nbsp;
Feasibility Conditions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">2.5.</a>&nbsp;
Solving Starvation: Sequencing Routes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">2.6.</a>&nbsp;
Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">2.7.</a>&nbsp;
Multiple Routers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#overlapping-prefixes">2.8.</a>&nbsp;
Overlapping Prefixes<br />
<a href="#anchor13">3.</a>&nbsp;
Protocol Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.1.</a>&nbsp;
Message Transmission and Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.2.</a>&nbsp;
Data Structures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">3.3.</a>&nbsp;
Acknowledged Packets<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">3.4.</a>&nbsp;
Neighbour Acquisition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">3.5.</a>&nbsp;
Routing Table Maintenance<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#route-selection">3.6.</a>&nbsp;
Route Selection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">3.7.</a>&nbsp;
Sending Updates<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#requests">3.8.</a>&nbsp;
Explicit Route Requests<br />
<a href="#anchor33">4.</a>&nbsp;
Protocol Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">4.1.</a>&nbsp;
Data Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">4.2.</a>&nbsp;
Packet Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">4.3.</a>&nbsp;
TLV Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tlv-details">4.4.</a>&nbsp;
Details of Specific TLVs<br />
<a href="#anchor52">5.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor53">6.</a>&nbsp;
Security Considerations<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informative References<br />
<a href="#anchor56">Appendix&nbsp;A.</a>&nbsp;
Cost and Metric Computation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#hello-history">A.1.</a>&nbsp;
Maintaining Hello history<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cost-computation-examples">A.2.</a>&nbsp;
Cost Computation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#metric-computation-examples">A.3.</a>&nbsp;
Metric computation<br />
<a href="#anchor58">Appendix&nbsp;B.</a>&nbsp;
Constants<br />
<a href="#anchor59">Appendix&nbsp;C.</a>&nbsp;
Simplified Implementations<br />
<a href="#anchor60">Appendix&nbsp;D.</a>&nbsp;
Software Availability<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Babel is a sequenced distance vector routing protocol, inspired by DSDV
<a class='info' href='#DSDV'>[DSDV]<span> (</span><span class='info'>Perkins, C. and P. Bhagwat, &ldquo;Highly Dynamic Destination-Sequenced Distance-Vector Routing       (DSDV) for Mobile Computers,&rdquo; 1994.</span><span>)</span></a>, that is designed to be robust and efficient both in
networks using prefix-based routing and in networks using flat routing
(``mesh networks''), and both in relatively stable wired networks and in
highly dynamic wireless networks.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Features</h3>

<p>The main property that makes Babel suitable for unstable networks is
that, unlike naive distance-vector routing protocols <a class='info' href='#RIP'>[RIP]<span> (</span><span class='info'>Malkin, G., &ldquo;RIP Version 2,&rdquo; November&nbsp;1998.</span><span>)</span></a>,
it strongly limits the frequency and duration of routing pathologies
such as routing loops and black-holes during reconvergence.  Even after
a mobility event is detected, a Babel network usually remains loop-free.
Babel then quickly reconverges to a configuration that preserves the
loop-freedom and connectedness of the network, but is not necessarily
optimal; in many cases, this operation requires no packet exchanges at
all.  Babel then slowly converges, in a time on the scale of minutes, to
an optimal configuration.
</p>
<p>More precisely, Babel has the following properties:
</p>
<ul class="text">
<li>when every prefix is originated by at most one router, Babel never
  suffers from routing loops;
</li>
<li>when a prefix is originated by multiple routers, Babel may occasionally
  create a transient routing loop for this particular prefix; this loop
  disappears in a time proportional to its diameter, and never again (up
  to an arbitrary garbage-collection time) will the routers involved
  participate in a routing loop for the same prefix;
</li>
<li>assuming reasonable packet loss rates, any routing black-holes that
  may appear after a mobility event are corrected in a time at most
  proportional to the network's diameter.
</li>
</ul><p>

</p>
<p>Babel has provisions for link quality estimation and for fairly
arbitrary metrics.  When configured suitably, Babel can implement
shortest-path routing, or it may use a metric based e.g. on packet loss
statistics.
</p>
<p>Babel nodes will successfully establish an association even when they
are configured with different parameters.  For example, a mobile node that
is low on battery may choose to use larger time constants (hello and update
intervals, etc.) than a node that has access to wall power.  Conversely, a
node that detects high levels of mobility may choose to use smaller time
constants.  The ability to build such heterogeneous networks makes Babel
particularly adapted to the wireless environment.
</p>
<p>Finally, Babel is a hybrid routing protocol, in the sense that it can
carry routes for multiple network-layer protocols (IPv4 and IPv6) whichever
protocol the Babel packets are themselves being carried over.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Limitations</h3>

<p>Babel has two limitations that make it unsuitable for use in some
environments.  First, Babel relies on periodic routing table updates
rather than using a reliable transport; hence, in large, stable networks
it generates more traffic than protocols that only send updates when the
network topology changes.  In such networks, protocols such as OSPF
<a class='info' href='#OSPF'>[OSPF]<span> (</span><span class='info'>Moy, J., &ldquo;OSPF Version 2,&rdquo; April&nbsp;1998.</span><span>)</span></a>, IS-IS <a class='info' href='#IS-IS'>[IS&#8209;IS]<span> (</span><span class='info'>, &ldquo;Information technology &mdash; Telecommunications and     information exchange between systems &mdash; Intermediate System to     Intermediate System intra-domain routeing information exchange protocol     for use in conjunction with the protocol for providing the     connectionless-mode network service (ISO 8473),&rdquo; .</span><span>)</span></a> or EIGRP <a class='info' href='#EIGRP'>[EIGRP]<span> (</span><span class='info'>Albrightson, B., Garcia Luna Aceves, J., and J. Boyle, &ldquo;EIGRP -- a Fast Routing Protocol Based on Distance Vectors,&rdquo; 1994.</span><span>)</span></a> might be more suitable.
</p>
<p>Second, Babel does impose a hold time when a prefix is retracted
(<a class='info' href='#hold-time'>Section&nbsp;3.5.5<span> (</span><span class='info'>Hold Time</span><span>)</span></a>).  While this hold time does not apply to the
exact prefix being retracted, and hence does not prevent fast reconvergence
should it become available again, it does apply to any shorter prefix that
covers it.  Hence, if a previously deaggregated prefix becomes aggregated,
it will be unreachable for a few minutes.  This makes Babel unsuitable for
use in mobile networks that implement automatic prefix aggregation.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Specification of Requirements</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conceptual Description of the Protocol</h3>

<p>Babel is a mostly loop-free distance vector protocol: it is based on
the Bellman-Ford protocol, just like the venerable RIP <a class='info' href='#RIP'>[RIP]<span> (</span><span class='info'>Malkin, G., &ldquo;RIP Version 2,&rdquo; November&nbsp;1998.</span><span>)</span></a>, but includes a number of refinements that either prevent
loop formation altogether, or ensure that a loop disappears in a timely
manner and doesn't form again.
</p>
<p>Conceptually, Bellman-Ford is executed in parallel for every source of
routing information (destination of data traffic).  In the following
discussion, we fix a source S; the reader will recall that the same
algorithm is executed for all sources.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Costs, Metrics and Neighbourship</h3>

<p>As many routing algorithms, Babel computes costs of links between any
two neighbouring nodes, abstract values attached to the edges between two
nodes.  We write C(a,&nbsp;b) for the cost of the edge from node A to node
B.
</p>
<p>Given a route between any two nodes, the metric of the route is the sum
of the costs of all the edges along the route.  The goal of the routing
algorithm is to compute, for every source S, the tree of the routes of
lowest metric to S.
</p>
<p>Costs and metrics need not be integers.  In general, they can be values
in any algebra that satisfies two fairly general conditions
(<a class='info' href='#metric-computation'>Section&nbsp;3.5.2<span> (</span><span class='info'>Metric Computation</span><span>)</span></a>).
</p>
<p>A Babel node periodically broadcasts Hello packets to all of its
neighbours; it also periodically sends an IHU ("I Heard You") packets to
every neighbour from which it has recently heard a Hello.  From the
information derived from Hello and IHU messages received from its neighbour
B, a node A computes the cost C(A,B) of the link from A to B.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
The Bellman-Ford algorithm</h3>

<p>Every node A maintains two pieces of data: its estimated distance to S,
written D(A), and its next-hop router to S, written NH(A).  Initially, D(S)
= 0, D(A) is infinite, and NH(A) is undefined.
</p>
<p>Periodically, every node B sends to all of its neighbours a route
update, a message containing D(B).  When a neighbour A of B receives the
route update, it checks whether B is its selected next hop; if that is the
case, then NH(A) is set to B, and D(A) is set to C(A, B) + D(B).  If that
is not the case, then A compares C(A, B) + D(B) to its current value of
D(A).  If that value is smaller, meaning that the received update
advertises a route that is better than the currently selected route, then
NH(A) is set to B, and D(A) is set to C(A, B) + D(B).
</p>
<p>A number of refinements to this algorithm are possible, and are used by
Babel.  In particular, convergence speed may be increased by sending
unscheduled "triggered updates" whenever a major change in the topology is
detected, in addition to the regular, scheduled updates.  Additionally,
a node may maintain a number of alternate routes, which are being
advertised by neighbours other than its selected neighbour, and which can
be used immediately if the selected route were to fail.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Transient Loops in Bellman-Ford</h3>

<p>It is well known that a naive application of Bellman-Ford to distributed
routing can cause transient loops after a topology change.  Consider for
example the following diagram:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         B
      1 /|
   1   / |
S --- A  |1
       \ |
      1 \|
         C
</pre></div><p>

After convergence, D(B) = D(C) = 2, with NH(B) = NH(C) = A.
</p>
<p>Suppose now that the link between S and A fails:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
         B
      1 /|
       / |
S     A  |1
       \ |
      1 \|
         C
</pre></div><p>


</p>
<p>When it detects the failure of the link, A switches its next hop to
B (which is still advertising a route to S with metric 2), and advertises
a metric equal to 3, and then advertises a new route with metric 3.  This
process of nodes changing selected neighbours and increasing their metric
continues until the advertised metric reaches "infinity", a value larger
than all the metrics that the routing protocol is able to carry.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Feasibility Conditions</h3>

<p>Bellman-Ford is a very robust algorithm: its convergence properties
are preserved when routers delay route acquisition or when they
discard some updates.  Babel routers discard received route
announcements unless they can prove that accepting them cannot
possibly cause a routing loop.
</p>
<p>More formally, we define a condition over route announcements, known as
the feasibility condition, that guarantees the absence of routing loops
whenever all routers ignore route updates that do not satisfy the
feasibility condition.  In effect, this makes Bellman-Ford into a family of
routing algorithms, parameterised by the feasibility condition.
</p>
<p>Many different feasibility conditions are possible.  For example, the
BGP protocol can be modelled as being a distance-vector protocol with
a (rather drastic) feasibility condition: a routing update is only accepted
when the receiving node's AS number is not included in the update's AS-Path
attribute (note that BGP's feasibility condition does not ensure the
absence of transitory "micro-loops" during reconvergence).
</p>
<p>Another simple feasibility condition, used in DSDV and AODV, stems
from the following observation: a routing loop can only arise after
a router has switched to a route with a larger metric than the route that
it had previously selected.  Hence, one could decide that a route is
feasible only when its metric at the local node would be no larger than the
metric of the currently selected route, i.e. an announcement carrying
a metric D(B) is accepted by A when C(A, B) + D(B) &lt;= D(A).  If all
routers obey this constraint, then the metric at every router is
nonincreasing, and the following invariant is always preserved: if A has
selected B as its successor, then D(B) &lt; D(A), which implies that the
forwarding graph is loop-free.
</p>
<p>Babel uses a slightly more refined feasibility condition, used in EIGRP
<a class='info' href='#DUAL'>[DUAL]<span> (</span><span class='info'>Garcia Luna Aceves, J., &ldquo;Loop-Free Routing Using Diffusing Computations,&rdquo; February&nbsp;1993.</span><span>)</span></a>.  Given a router A, define the feasibility distance
of A, written FD(A), as the smallest metric that A has ever advertised for
S to any of its neighbours.  An update sent by a neighbour B of A is
feasible when the metric D(B) advertised by B is strictly smaller than A's
feasibility distance, i.e. when D(B) &lt; FD(A).
</p>
<p>It is easy to see that this latter condition is no more restrictive than
DSDV-feasibility.  Suppose that node A obeys DSDV-feasibility; then D(A) is
nonincreasing, hence at all times D(A) &lt;= FD(A).  Suppose now that
A receives a DSDV-feasible update that advertises a metric D(B).  Since the
update is DSDV-feasible, C(A, B) + D(B) &lt;= D(A), hence D(B) &lt; D(A),
and since D(A) &lt;= FD(A), D(B) &lt; FD(A).
</p>
<p>To see that it is strictly less restrictive, consider the following
diagram, where A has selected the route through B, and D(A) = FD(A) = 2.
Since D(C) = 1 &lt; FD(A), the alternate route through C is feasible for A,
although its metric C(A, C) + D(C) = 5 is larger than that of the
currently selected route:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   B
1 / \ 1
 /   \
S     A
 \   /
1 \ / 4
   C
</pre></div><p>


</p>
<p>To show that this feasibility condition still guarantees loop-freeness,
recall that at the time when A accepts an update from B, the metric D(B)
announced by B is no smaller than FD(B); since it is smaller than FD(A), at
that point in time FD(B) &lt; FD(A).  Since this property is preserved when
A sends updates, it remains true at all times, which ensures that the
forwarding graph has no loops.
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Solving Starvation: Sequencing Routes</h3>

<p>Obviously, the feasibility conditions defined above cause starvation
when a router runs out of feasible routes.  Consider the following diagram,
where both A and B have selected the direct route to S:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   A
1 /|        D(A) = 1
 / |       FD(A) = 1
S  |1
 \ |        D(B) = 2
2 \|       FD(B) = 2
   B
</pre></div><p>


</p>
<p>Suppose now that the link between A and S breaks:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   A
   |
   |       FD(A) = 1
S  |1
 \ |        D(B) = 2
2 \|       FD(B) = 2
   B
</pre></div><p>


</p>
<p>The only route available from A to S, the one that goes through B, is
not feasible: A suffers from a spurious starvation.
</p>
<p>At this point, the whole network must be rebooted in order to solve the
starvation; this is essentially what EIGRP does, when it performs a global
synchronisation of all the routers in the network with the source (the
"active" phase of EIGRP).
</p>
<p>Babel reacts to starvation in a less drastic manner, by using sequenced
routes, a technique introduced by DSDV and adopted by AODV.  In addition to
a metric, every route carries a sequence number, a nondecreasing integer
that is propagated unchanged through the network, and is only ever
incremented by the source; a pair (s, m), where s is a sequence number and
m a metric, is called a distance.
</p>
<p>A received update is feasible when either it is more recent than the
feasibility distance maintained by the receiving node, or it is equally
recent and the metric is strictly smaller.  More formally, if FD(A) =
(s,&nbsp;m), then an update carrying the distance (s',&nbsp;m') is feasible
when either s' &gt; s, or s = s' and m' &lt; m.
</p>
<p>Assuming the sequence number of S is 137, the diagram above becomes:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   A
   |
   |       FD(A) = (137, 1)
S  |1
 \ |        D(B) = (137, 2)
2 \|       FD(B) = (137, 2)
   B
</pre></div><p>


</p>
<p>After S increases its sequence number, and the new sequence number is
propagated to B, we have:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   A
   |
   |       FD(A) = (137, 1)
S  |1
 \ |        D(B) = (138, 2)
2 \|       FD(B) = (138, 2)
   B
</pre></div><p>

at which point the route through B becomes feasible again.
</p>
<p>Note that while sequence numbers are used for determining
feasibility, they are not necessarily used in route selection: a node
will normally ignore the sequence number when selecting a route
(<a class='info' href='#route-selection'>Section&nbsp;3.6<span> (</span><span class='info'>Route Selection</span><span>)</span></a>).
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Requests</h3>

<p>In DSDV, the sequence number of a source is increased periodically.
A route becomes feasible again after the source increases its sequence
number, and the new sequence number is propagated through the network,
which may, in general, require a significant amount of time.
</p>
<p>Babel takes a different approach.  When a node detects that it is
suffering from a potentially spurious starvation, it sends an explicit
request to the source for a new sequence number.  This request is forwarded
hop by hop to the source, with no regard to the feasibility condition.
Upon receiving the request, the source increases its sequence number, and
broadcasts an update, which is forwarded to the requesting node.
</p>
<p>Note that after a change in network topology not all such requests
will, in general, reach the source, as some will be sent over links
which are now broken.  However, if the network is still connected, then
at least one among the nodes suffering from spurious starvation has an
(unfeasible) route to the source; hence, in the absence of packet loss,
at least one such request will reach the source.  (Packet loss is
compensated for by resending requests a small number of times.)
</p>
<p>Since requests are forwarded with no regard to the feasibility
condition, they may, in general, be caught in a forwarding loop; this is
avoided by having nodes perform duplicate detection for the requests that
they forward.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.7"></a><h3>2.7.&nbsp;
Multiple Routers</h3>

<p>The above discussion assumes that every prefix is originated by a single
router.  In real networks, however, it is often necessary to have a single
prefix originated by multiple routers; for example, the default route will
be originated by all of the edge routers of a routing domain.
</p>
<p>Since synchronising sequence numbers between distinct routers is
problematic, Babel treats routes for the same prefix as distinct entities
when they are originated by different routers: every route announcement
carries the router-id of its originating router, and feasibility distances
are not maintained per-prefix, but per source, where a source is a pair of
a router-id and a prefix.  In effect, Babel guarantees loop-freedom for the
forwarding graph to every source; since the union of multiple acyclic
graphs is not in general acyclic, Babel does not in general guarantee
loop-freeness when a prefix is originated by multiple routers, but any
loops will be broken in a time at most proportional to the diameter of the
loop &mdash; as soon as an update has "gone around" the routing loop.
</p>
<p>Consider for example the following diagram, where A has selected the
default route through S, and B has selected the one through S':
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           1     1     1
::/0 -- S --- A --- B --- S' -- ::/0
</pre></div><p>


</p>
<p>Suppose that both default routes fail at the same time; then nothing
prevents A from switching to B, and B simultaneously switching to A.
However, as soon as A has successfully advertised the new route to B, the
route through A will become unfeasible for B.  Conversely, as soon as
B will have advertised the route through A, the route through B will
become unfeasible for A.
</p>
<p>In effect, the routing loop disappears at the latest when routing
information has gone around the loop.  Since this process can be delayed by
lost packets, Babel makes certain efforts to ensure that updates are sent
reliably after a router-id change.
</p>
<p>Additionally, after the routers have advertised the two routes, both
sources will be in their source tables, which will prevent them from ever
again participating in a routing loop involving routes from S and S' (up to
the source GC time, which, available memory permitting, can be set to
arbitrarily large values).
</p>
<a name="overlapping-prefixes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.8"></a><h3>2.8.&nbsp;
Overlapping Prefixes</h3>

<p>In the above discussion, we have assumed that all prefixes are disjoint,
as is the case in flat ("mesh") routing.  In practice, however, prefixes
may overlap: for example, the default route overlaps with all of the routes
present in the network.
</p>
<p>After a route fails, it is not correct in general to switch to a route
that subsumes the failed route.  Consider for example the following
configuration:
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
           1     1
::/0 -- A --- B --- C
</pre></div><p>


</p>
<p>Suppose that node C fails.  If B forwards packets destined to C by
following the default route, a routing loop will form, and persist until
A learns of B's retraction of the direct route to C.  Babel avoids this
pitfall by maintaining an "unreachable" route for a few minutes after
a route is retracted; the time for which such a route must be maintained
should be the worst-case propagation time of the retraction for the route
to C.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Protocol Operation</h3>

<p>Every Babel speaker is assigned a router-id, which is an arbitrary
string of 8 octets that is assumed unique across the routing domain.  We
suggest that router-ids should be assigned in modified EUI-64
format <a class='info' href='#ADDRARCH'>[ADDRARCH]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;IP Version 6 Addressing Architecture,&rdquo; February&nbsp;2006.</span><span>)</span></a>.  (As a matter of fact, the protocol
encoding is slightly more compact when router-ids are assigned in the same
manner as the IPv6 layer assigns host ids.)
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Message Transmission and Reception</h3>

<p>Babel protocol packets are sent in the body of a UDP datagram.  Each
Babel packet consists of one or more TLVs.
</p>
<p>The source address of a Babel packet is always a unicast address,
link-local in the case of IPv6.  Babel packets may be sent to a well-known
(link-local) multicast address (this is the usual case) or to
a (link-local) unicast address.  In normal operation, a Babel speaker sends
both multicast and unicast packets to its neighbours.
</p>
<p>With the exception of Hello TLVs and acknowledgements, all Babel TLVs
can be sent to either unicast or multicast addresses, and their semantics
does not depend on whether the destination was a unicast or multicast
address.  Hence, a Babel speaker does not need to determine the destination
address of a packet that it receives in order to interpret it.
</p>
<p>A moderate amount of jitter is applied to packets sent by a Babel
speaker: outgoing TLVs are buffered, and SHOULD be sent with a small random
delay.  This is done for two purposes: it avoids synchronisation of
multiple Babel speakers across a network <a class='info' href='#JITTER'>[JITTER]<span> (</span><span class='info'>Floyd, S. and V. Jacobson, &ldquo;The synchronization of periodic routing messages,&rdquo; April&nbsp;1994.</span><span>)</span></a>, and
allows for the aggregation of multiple TLVs into a single packet.
</p>
<p>The exact delay and amount of jitter applied to a packet depends on
whether it contains any urgent TLVs.  Acknowledgement TLVs MUST be sent
before the deadline specified in the corresponding request.  The particular
class of updates specified in <a class='info' href='#triggered-updates'>Section&nbsp;3.7.2<span> (</span><span class='info'>Triggered Updates</span><span>)</span></a> MUST be
sent in a timely manner.  The particular class of request and update TLVs
specified in <a class='info' href='#sending-requests'>Section&nbsp;3.8.2<span> (</span><span class='info'>Sending Requests</span><span>)</span></a> SHOULD be sent in a timely
manner.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Data Structures</h3>

<p>Every Babel speaker maintains a number of data structures.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Sequence Number</h3>

<p>A node's sequence number is a 16-bit integer that is included in route
updates sent for routes originated by this node.  A node increments its
sequence number (modulo 2^16) whenever it receives a request for a new
sequence number (<a class='info' href='#handling-seqno-requests'>Section&nbsp;3.8.1.2<span> (</span><span class='info'>Seqno Requests</span><span>)</span></a>).
</p>
<p>A node SHOULD NOT increment its seqno number spontaneously, since
increasing seqnos makes it less likely that other nodes will have
feasible alternate routes when their selected routes fail.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
The Interface Table</h3>

<p>The interface table contains the list of interfaces on which the node
speaks the Babel protocol.  Every interface table entry contains the
interface's Hello seqno, a 16-bit integer that is sent with each Hello TLV
on this interface and is incremented (modulo 2^16) whenever a Hello is
sent.  (Note that an interface's Hello seqno is unrelated to the node's
seqno.)
</p>
<p>There are two timers associated with each interface table entry, the
hello timer, which governs the sending of periodic Hello and IHU packets,
and the update timer, which governs the sending of periodic route
updates.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
The Neighbour Table</h3>

<p>The neighbour table contains the list of all neighbouring interfaces
from which a Babel packet has been recently received.  The neighbour table
is indexed by pairs of the form (interface, address), and every neighbour table
entry contains the following data:
</p>
<ul class="text">
<li>the local node's interface over which this neighbour is reachable;
</li>
<li>the address of the neighbouring interface;
</li>
<li>a history of recently received Hello packets from this neighbour; this
can, for example, be a sequence of n bits, for some small value n,
indicating which of the n hellos most recently sent by this neighbour have
been received by the local node;
</li>
<li>the ``transmission cost'' value from the last IHU packet received from
this neighbour, or FFFF hexadecimal (infinity) if the IHU hold timer for
this neighbour has expired;
</li>
<li>the neighbour's expected hello sequence number, an integer modulo 2^16.
</li>
</ul><p>

</p>
<p>There are two timers associated with each neighbour entry, the hello
timer, which is initialised from the interval value carried by Hello TLVs,
and the IHU timer, which is initialised to a small multiple of the interval
carried in IHU TLVs.
</p>
<p>Note that the neighbour table is indexed by IP addresses, not by
router-ids: neighbourship is a relationship between interfaces, not between
nodes.  Therefore, two nodes with multiple interfaces can participate in
multiple neighbourship relationships, a fairly common situation when
wireless nodes with multiple radios are involved.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.4"></a><h3>3.2.4.&nbsp;
The Source Table</h3>

<p>The source table is used to record feasibility distances.  It is indexed
by triples of the form (prefix, plen, router-id), and every source table
entry contains the following data:
</p>
<ul class="text">
<li>the prefix (prefix, plen) that this entry applies to;
</li>
<li>the router-id of a router originating this prefix;
</li>
<li>a pair (seqno, metric), this source's feasibility distance.
</li>
</ul><p>

</p>
<p>There is one timer associated with each entry in the source table, the
source garbage collection timer.  It is initialised to a time on the order
of minutes, and reset as specified in <a class='info' href='#maintaining-fd'>Section&nbsp;3.7.3<span> (</span><span class='info'>Maintaining Feasibility Distances</span><span>)</span></a>.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.5"></a><h3>3.2.5.&nbsp;
The Route Table</h3>

<p>The route table contains the routes known to this node.  It is indexed
by triples of the form (prefix, plen, neighbour), and every route table
entry contains the following data:
</p>
<ul class="text">
<li>the source (prefix, plen, router-id) for which this route is advertised;
</li>
<li>the neighbour that advertised this route;
</li>
<li>the metric with which this route was advertised by the neighbour, or
FFFF hexadecimal (infinity) for a recently retracted route;
</li>
<li>the sequence number with which this route was advertised;
</li>
<li>the next hop address of this route;
</li>
<li>a boolean flag indicating whether this route is selected, i.e. whether
it is currently being used for forwarding and is being advertised.
</li>
</ul><p>

</p>
<p>There is one timer associated with each route table entry, the route
expiry timer.  It is initialised and reset as specified in
<a class='info' href='#route-acquisition'>Section&nbsp;3.5.4<span> (</span><span class='info'>Route Acquisition</span><span>)</span></a>.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.6"></a><h3>3.2.6.&nbsp;
The Table of Pending Requests</h3>

<p>The table of pending requests contains a list of seqno requests that
the local node has sent (either because they have been originated
locally, or because they were forwarded) and to which no reply has been
received yet.  This table is indexed by prefixes, and every entry in
this table contains the following data:
</p>
<ul class="text">
<li>the prefix, router-id and seqno being requested;
</li>
<li>the neighbour, if any, on behalf of which we are forwarding this
request;
</li>
<li>a small integer indicating the number of times that this request will be
resent if it remains unsatisfied.
</li>
</ul><p>

</p>
<p>There is one timer associated with each pending request, which governs
both the resending of requests and their expiry.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Acknowledged Packets</h3>

<p>A Babel speaker may request that any neighbour receiving a given packet
reply with an explicit acknowledgement within a given time.  While the use
of acknowledgement requests is optional, every Babel speaker MUST be able
to reply to such a request.
</p>
<p>An acknowledgement MUST be sent to a unicast destination.  On the other
hand, acknowledgement requests may be sent to either unicast or multicast
destinations, in which case they request an acknowledgement from all of the
receiving nodes.
</p>
<p>When to request acknowledgements is a matter of local policy; the
simplest strategy is to never request acknowledgements, and rely on
periodic updates to ensure that any reachable routes are eventually
propagated throughout the routing domain.  For increased efficiency, we
suggest that acknowledged packets should be used in order to send urgent
updates (<a class='info' href='#triggered-updates'>Section&nbsp;3.7.2<span> (</span><span class='info'>Triggered Updates</span><span>)</span></a>) when the number of neighbours
on a given interface is small.  Since Babel is designed to deal gracefully
with packet loss on unreliable media, sending all packets with
acknowledgement requests is not necessary, and not even recommended, as the
acknowledgements cause additional traffic and may force additional ARP or
Neighbour Discovery exchanges.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Neighbour Acquisition</h3>

<p>Neighbour acquisition is the process by which a Babel node discovers the
set of neighbours heard over each of its interfaces and ascertains
bidirectional reachability.  On unreliable media, neighbour acquisition
additionally provides some statistics that MAY be used in link quality
computation.
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Reverse Reachability Detection</h3>

<p>Every Babel node sends periodic Hellos over each of its interfaces.
Each Hello TLV carries an increasing (modulo 2^16) sequence number, and the
interval between successive periodic packets sent on this particular
interface.
</p>
<p>In addition to the periodic Hello packets, a node MAY send unscheduled
Hello packets, e.g. to accelerate link cost estimation when a new neighbour
is discovered, or when link conditions have suddenly changed.
</p>
<p>A node MAY change its Hello interval.  The Hello interval MAY be
decreased at any time; it SHOULD NOT be increased, except immediately
before sending a Hello packet.  (Equivalently, a node SHOULD send an
unscheduled Hello immediately after increasing its Hello interval.)
</p>
<p>How to deal with received Hello TLVs, and what statistics to maintain,
is considered a local implementation matter; typically, a node will
maintain some sort of history of recently received Hellos.  A possible
algorithm is described in <a class='info' href='#hello-history'>Appendix&nbsp;A.1<span> (</span><span class='info'>Maintaining Hello history</span><span>)</span></a>.
</p>
<p>After receiving a Hello, or determining that it has missed one, the node
recomputes the association's cost (<a class='info' href='#cost-computation'>Section&nbsp;3.4.3<span> (</span><span class='info'>Cost Computation</span><span>)</span></a>) and
runs the route selection procedure (<a class='info' href='#route-selection'>Section&nbsp;3.6<span> (</span><span class='info'>Route Selection</span><span>)</span></a>).
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Bidirectional Reachability Detection</h3>

<p>In order to establish bidirectional reachability, every node sends
periodic IHU (``I Heard You'') TLVs to each of its neighbours.  Since IHUs
carry an explicit interval value, they MAY be sent less often than Hellos
in order to reduce the amount of routing traffic in dense networks; in
particular, they SHOULD be sent less often than Hellos over links with
little packet loss.  While IHUs are conceptually unicast, they SHOULD be
sent to a multicast address in order to avoid an ARP or Neighbour Discovery
exchange, and to aggregate multiple IHUs in a single packet.
</p>
<p>In addition to the periodic IHUs, a node MAY, at any time, send an
unscheduled IHU packet.  It MAY also, at any time, decrease its IHU
interval, and MAY increase its IHU interval immediately before sending an
IHU.
</p>
<p>Every IHU TLV contains two pieces of data: the link's rxcost from the
sender's perspective, used by the neighbour for computing link costs (<a class='info' href='#cost-computation'>Section&nbsp;3.4.3<span> (</span><span class='info'>Cost Computation</span><span>)</span></a>), and the interval between periodic IHU
packets.  A node receiving an IHU updates the sending neighbour's txcost
(from its perspective) value to the value contained in the IHU, and resets
this neighbour's IHU timer to a small multiple of the value received in the
IHU.
</p>
<p>When a neighbour's IHU timer expires, its txcost is set to infinity.
</p>
<p>After updating a neighbour's txcost, the receiving node recomputes the
neighbour's cost (<a class='info' href='#cost-computation'>Section&nbsp;3.4.3<span> (</span><span class='info'>Cost Computation</span><span>)</span></a>) and runs the route
selection procedure (<a class='info' href='#route-selection'>Section&nbsp;3.6<span> (</span><span class='info'>Route Selection</span><span>)</span></a>).
</p>
<a name="cost-computation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Cost Computation</h3>

<p>A neighbourship association's link cost is computed from the values
maintained in the neighbour table, namely the statistics kept in the
neighbour table about the reception of Hellos, and the txcost computed from
received IHU packets.
</p>
<p>For every neighbour, a Babel node computes a value known as this
neighbour's reception cost, written rxcost.  This value is usually derived
from the hello history, which may be combined with other data, such as
statistics maintained by the link layer.  The rxcost is sent to a neighbour
in each IHU.
</p>
<p>How a the txcost and rxcost are combined in order to compute a link's
cost is a matter of local policy; as far as Babel's correctness is
concerned, only the following conditions MUST be satisfied:
</p>
<ul class="text">
<li>the cost is strictly positive;
</li>
<li>if no hellos were received recently, then the cost is infinite;
</li>
<li>if the txcost is infinite, then the cost is infinite.
</li>
</ul>

<p>Note that while this document does not constrain cost computation any
further, not all cost computation strategies will give good results.  We
give a few examples of strategies for computing a link's cost that are known
to work well in practice in <a class='info' href='#cost-computation-examples'>Appendix&nbsp;A.2<span> (</span><span class='info'>Cost Computation</span><span>)</span></a>.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Routing Table Maintenance</h3>

<p>Conceptually, a Babel update is a quintuple (prefix, plen, router-id,
seqno, metric), where (prefix, plen) is the prefix for which a route is
being advertised, router-id is the router-id of the router originating this
update, seqno is a non-decreasing (modulo 2^16) integer that carries the
originating router seqno, and metric is the announced metric.
</p>
<p>Before being accepted, an update is checked against the feasibility
condition (<a class='info' href='#feasibility-condition'>Section&nbsp;3.5.1<span> (</span><span class='info'>The Feasibility Condition</span><span>)</span></a>), which ensures that the
route does not create a routing loop.  If the feasibility condition is not
satisfied, the update is either ignored or treated as a retraction,
depending on some other conditions (<a class='info' href='#route-acquisition'>Section&nbsp;3.5.4<span> (</span><span class='info'>Route Acquisition</span><span>)</span></a>).
If the feasibility condition is satisfied, then the update cannot possibly
cause a routing loop, and the update is accepted.
</p>
<a name="feasibility-condition"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1"></a><h3>3.5.1.&nbsp;
The Feasibility Condition</h3>

<p>The feasibility condition is applied to all received updates.  The
feasibility condition compares the metric in the received update with the
metrics of the updates previously sent by the receiving node; updates with
finite metrics large enough to cause a loop are discarded.
</p>
<p>A feasibility distance is a pair (seqno, metric), where seqno is an
integer modulo 2^16 and metric is a positive integer.  Feasibility
distances are compared lexicographically, with the first component
inverted: we say that a distance (seqno, metric) is strictly better than
a distance (seqno', metric'), written
</p>
<blockquote class="text">
<p>(seqno, metric) &lt; (seqno', metric')
</p>
</blockquote><p>
when
</p>
<blockquote class="text">
<p>seqno &gt; seqno' or (seqno = seqno' and metric &lt; metric')
</p>
</blockquote><p>
where sequence numbers are compared modulo 2^16.
</p>
<p>Given a source (p, plen, id), a node's feasibility distance for this
source is the minimum, according to the ordering defined above, of the
distances of all the finite updates ever sent by this particular node for
the prefix (p, plen) carrying the router-id id.  Feasibility distances are
maintained in the source table; the exact procedure is given in
<a class='info' href='#maintaining-fd'>Section&nbsp;3.7.3<span> (</span><span class='info'>Maintaining Feasibility Distances</span><span>)</span></a>.
</p>
<p>A received update is feasible when either it is a retraction (its metric
is FFFF hexadecimal), or the advertised distance is strictly better, in the
sense defined above, than the feasibility distance for the corresponding
source.  More precisely, a route advertisement carrying the quintuple
(prefix, plen, router-id, seqno, metric) is feasible if one of the
following conditions holds:
</p>
<ul class="text">
<li>metric is infinite; or
</li>
<li>no entry exists in the source table indexed by (id, prefix, plen);
  or
</li>
<li>an entry (prefix, plen, router-id, seqno', metric') exists in the
    source table, and either
    
<ul class="text">
<li>seqno' &lt; seqno or
</li>
<li>seqno = seqno' and metric &lt; metric'.
</li>
</ul>
  
</li>
</ul><p>

</p>
<p>Note that the feasibility condition considers the metric advertised by
the neighbour, not the route's metric; hence, a fluctuation in
a neighbour's cost cannot render a selected route unfeasible.
</p>
<a name="metric-computation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2"></a><h3>3.5.2.&nbsp;
Metric Computation</h3>

<p>A route's metric is computed from the metric advertised by the neighbour
and the neighbour's link cost.  Just like cost computation, metric
computation is considered a local policy matter; as far as Babel is
concerned, the function M(c,&nbsp;m) used for computing a metric from
a locally computed link cost and the metric advertised by a neighbour MUST
only satisfy the following conditions:
</p>
<ul class="text">
<li>if c is infinite, then M(c, m) is infinite;
</li>
<li>M is strictly monotonic: M(c, m) &gt; m.
</li>
</ul><p>
Additionally, the metric SHOULD satisfy the following condition:
</p>
<ul class="text">
<li>M is isotonic: if m &le; m' then M(c, m) &le; M(c, m').
</li>
</ul><p>
Note that while strict monotonicity is essential to the integrity of the
network (persistent routing loops may appear if it is not satisfied),
isotonicity is not: if it is not satisfied, Babel will still converge to a
locally optimal routing table, but might not reach a global optimum (in
fact, such a global optimum may not even exist).
</p>
<p>As with cost computation, not all strategies for computing route metrics
will give good results.  In particular, some metrics are more likely than
others to lead to routing instabilities (route flapping).  We give a number
of examples of strictly monotonic, isotonic routing metrics that are known
to work well in practice in <a class='info' href='#metric-computation-examples'>Appendix&nbsp;A.3<span> (</span><span class='info'>Metric computation</span><span>)</span></a>.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.3"></a><h3>3.5.3.&nbsp;
Encoding of Updates</h3>

<p>In a large network, the bulk of Babel traffic consists of route updates;
hence, some care has been given to encoding them efficiently.  An Update
TLV itself only contains the prefix, seqno and metric, while the next hop
is derived either from the network-layer source address of the packet, or
from an explicit Next Hop TLV in the same packet.  The router-id is derived
from a separate Router-Id TLV in the same packet, which optimises the case
when multiple updates are sent with the same router-id.
</p>
<p>Additionally, a prefix of the advertised prefix can be omitted in an
Update TLV, in which case it is copied from a previous Update TLV in
the same packet &mdash; this is known as address compression <a class='info' href='#PACKETBB'>[PACKETBB]<span> (</span><span class='info'>Clausen, T., Dearlove, C., Dean, J., and C. Adjih, &ldquo;Generalized Mobile Ad Hoc Network (MANET) Packet/Message     Format,&rdquo; 2009.</span><span>)</span></a>.
</p>
<p>Finally, as a special optimisation for the case when a router-id
coincides with the interface-id part of an IPv6 address, the router-id can
optionally be derived from the low-order bits of the advertised prefix.
</p>
<p>The encoding of updates is described in detail in
<a class='info' href='#tlv-details'>Section&nbsp;4.4<span> (</span><span class='info'>Details of Specific TLVs</span><span>)</span></a>.
</p>
<a name="route-acquisition"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.4"></a><h3>3.5.4.&nbsp;
Route Acquisition</h3>

<p>When a Babel node receives an update (id, prefix, seqno, metric) from a
neighbour neigh with a link cost value equal to cost, it checks whether it
already has a routing table entry indexed by (neigh, id, prefix).
</p>
<p>If no such entry exists:
</p>
<ul class="text">
<li>if the update is unfeasible, it is ignored;
</li>
<li>if the metric is infinite (the update is a retraction), the update is
  ignored;
</li>
<li>otherwise, a new route table entry is created, indexed by (neigh, id,
  prefix), with seqno seqno and an advertised metric equal to the metric
  carried by the update.
</li>
</ul><p>
If such an entry exists:
</p>
<ul class="text">
<li>if the entry is currently installed and the update is unfeasible, then
  the behaviour depends on whether the router-ids of the two entries match.
  If the router-ids are different, the update is treated as though it were
  a retraction (i.e. as though the metric were FFFF hexadecimal).  If the
  router-ids are equal, the update is ignored;
</li>
<li>otherwise (i.e. if either the update is feasible or the entry is not
  currently installed), then the entry's sequence number, advertised
  metric, metric and router-id are updated and, unless the advertised
  metric is infinite, the route's expiry timer is reset to a small multiple
  of the Interval value included in the update.
</li>
</ul>

<p>When a route's expiry timer triggers, the behaviour depends on whether
the route's metric is finite.  If the metric is finite, it is set to
infinity and the expiry timer is reset.  If the metric is already infinite,
the route is flushed from the route table.
</p>
<p>After the routing table is updated, the route selection procedure
(<a class='info' href='#route-selection'>Section&nbsp;3.6<span> (</span><span class='info'>Route Selection</span><span>)</span></a>) is run.
</p>
<a name="hold-time"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.5"></a><h3>3.5.5.&nbsp;
Hold Time</h3>

<p>When a prefix p is retracted, because all routes are unfeasible, too
old, or have an infinite metric, and a shorter prefix p' that covers p is
reachable, p' cannot in general be used for routing packets destined to
p without running the risk of creating a routing loop (<a class='info' href='#overlapping-prefixes'>Section&nbsp;2.8<span> (</span><span class='info'>Overlapping Prefixes</span><span>)</span></a>).
</p>
<p>To avoid this issue, whenever a prefix is retracted, a routing table
entry with infinite metric is maintained as described in <a class='info' href='#route-acquisition'>Section&nbsp;3.5.4<span> (</span><span class='info'>Route Acquisition</span><span>)</span></a> above, and packets destined for that prefix
MUST NOT be forwarded by following a route for a shorter prefix.  The
infinite metric entry is maintained until it is superseded by a feasible
update; if no such update arrives within the route hold time, the entry is
flushed.
</p>
<a name="route-selection"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Route Selection</h3>

<p>Route selection is the process by which a single route for a given
prefix is selected to be used for forwarding packets and to be
readvertised to a node's neighbours.
</p>
<p>Babel is designed to allow flexible route selection policies.  As far as
  the protocol's correctness is concerned, the route selection policy MUST
  only satisfy the following properties:
</p>
<ul class="text">
<li>a route with infinite metric (a retracted route) is never selected;
</li>
<li>an unfeasible route is never selected.
</li>
</ul><p>
Note, however, that Babel does not naturally guarantee the stability of
routing, and configuring conflicting route selection policies on different
routers may lead to persistent route oscillation.
</p>
<p>Defining a good route selection policy for Babel is an open research
problem.  Route selection can take into account multiple mutually
contradictory criteria; in roughly decreasing order of importance, these
are:
</p>
<ul class="text">
<li>routes with a small metric should be preferred over routes with a large
    metric;
</li>
<li>switching router-ids should be avoided;
</li>
<li>routes through stable neighbours should be preferred over routes
    through unstable ones;
</li>
<li>stable routes should be preferred over unstable ones;
</li>
<li>switching next hops should be avoided.
</li>
</ul><p>
A simple strategy is to choose the feasible route with the smallest metric,
with a small amount of hysteresis applied to avoid switching router-ids.
</p>
<p>After the route selection procedure is run, triggered updates
(<a class='info' href='#triggered-updates'>Section&nbsp;3.7.2<span> (</span><span class='info'>Triggered Updates</span><span>)</span></a>) and requests
(<a class='info' href='#sending-requests'>Section&nbsp;3.8.2<span> (</span><span class='info'>Sending Requests</span><span>)</span></a>) are sent.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
Sending Updates</h3>

<p>A Babel speaker advertises to its neighbours its set of selected routes.
Normally, this is done by sending one or more multicast packets containing
Update TLVs on all of its connected interfaces; however, on link
technologies where multicast is significantly more expensive than unicast,
a node MAY choose to send multiple copies of updates in unicast packets
when the number of neighbours is small.
</p>
<p>Additionally, in order to ensure that any black-holes are reliably
cleared in a timely manner, a Babel node sends retractions (updates with an
infinite metric) for any recently retracted prefixes.
</p>
<p>If an update is for a route injected into the Babel domain by the local
node (e.g. the address of a local interface, the prefix of a directly
attached network, or redistributed from a different routing protocol), the
router-id is set to the local id, the metric is set to some arbitrary
finite value (typically 0), and the seqno is set to the local router's
sequence number.
</p>
<p>If an update is for a route learned from another Babel speaker, the
router-id and sequence number are copied from the routing table entry, and
the metric is computed as specified in <a class='info' href='#metric-computation'>Section&nbsp;3.5.2<span> (</span><span class='info'>Metric Computation</span><span>)</span></a>.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.1"></a><h3>3.7.1.&nbsp;
Periodic Updates</h3>

<p>Every Babel speaker periodically advertises all of its selected routes
on all of its interfaces, including any recently retracted routes.  Since
Babel doesn't suffer from routing loops (there is no ``counting to
infinity'') and relies heavily on triggered updates
(<a class='info' href='#triggered-updates'>Section&nbsp;3.7.2<span> (</span><span class='info'>Triggered Updates</span><span>)</span></a>), this full dump only needs to happen
infrequently.
</p>
<a name="triggered-updates"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.2"></a><h3>3.7.2.&nbsp;
Triggered Updates</h3>

<p>In addition to the periodic routing updates, a Babel speaker sends
unscheduled, or triggered updates in order to inform its neighbours of a
significant change in the network topology.
</p>
<p>A change of router-id for the selected route to a given prefix may be
indicative of a routing loop in formation; hence, a node MUST send a
triggered update in a timely manner whenever it changes the selected
router-id for a given destination.  Additionally, it SHOULD make a
reasonable attempt at ensuring that all neighbours receive this update.
</p>
<p>There are two strategies for ensuring that.  If the number of neighbours
is small, then it is reasonable to send the update together with an
acknowledgement request; the update is resent until all neighbours have
acknowledged the packet, up to some number of times.  If the number of
neighbours is large, however, requesting acknowledgements from all of them
might cause a non-negligible amount of network traffic; in that case, it
may be preferable to simply repeat the update some reasonable number of
times (say, 5 for wireless and 2 for wired links).
</p>
<p>A route retraction is somewhat less worrying: if the route retraction
doesn't reach all neighbours, a black-hole might be created, which, unlike
a routing loop, does not endanger the integrity of the network.  When a
route is retracted, a node SHOULD send a triggered update, and SHOULD make
a reasonable attempt at ensuring that all neighbours receive this
retraction.
</p>
<p>Finally, a node MAY send a triggered update when the metric for a given
prefix changes in a significant manner, either due to a received update or
because a link cost has changed.  A node SHOULD NOT send triggered updates
for other reasons, such as when there is a minor fluctuation in a route's
metric, when the selected next hop changes, or to propagate a new sequence
number (except to satisfy a request, as specified in
<a class='info' href='#requests'>Section&nbsp;3.8<span> (</span><span class='info'>Explicit Route Requests</span><span>)</span></a>).
</p>
<a name="maintaining-fd"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.3"></a><h3>3.7.3.&nbsp;
Maintaining Feasibility Distances</h3>

<p>Before sending an update (prefix, plen, router-id, seqno, metric) with
finite metric (i.e. not a route retraction), a Babel node updates the
feasibility distance maintained in the source table.  This is done as
follows.
</p>
<p>If no entry indexed by (prefix, plen, router-id) exists in the source
table, then one is created with value (prefix, plen, router-id, seqno,
metric).
</p>
<p>If an entry (prefix, plen, router-id, seqno', metric') exists, then it
is updated as follows:
</p>
<ul class="text">
<li>if seqno &gt; seqno', then seqno' := seqno, metric' := metric;
</li>
<li>if seqno = seqno' and metric' &gt; metric, then metric' := metric;
</li>
<li>otherwise, nothing needs to be done.
</li>
</ul>

<p>The garbage collection timer for the modified entry is then reset.
Note that the garbage collection timer is not reset when a retraction is
sent.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7.4"></a><h3>3.7.4.&nbsp;
Split Horizon</h3>

<p>When running over a transitive, symmetric link technology, e.g. a
point-to-point link or a wired LAN technology such as Ethernet, a Babel
node SHOULD use an optimisation known as split horizon.  When split horizon
is used on a given interface, a routing update is not sent on this
particular interface when the advertised route was learnt from a neighbour
over the same interface.
</p>
<p>Split horizon SHOULD NOT be applied to an interface unless the interface
is known to be symmetric and transitive; in particular, split horizon is
not applicable to decentralised wireless link technologies
(e.g.&nbsp;IEEE 802.11 in ad-hoc mode).
</p>
<a name="requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8"></a><h3>3.8.&nbsp;
Explicit Route Requests</h3>

<p>In normal operation, a node's routing table is populated by the regular
and triggered updates sent by its neighbours.  Under some circumstances,
however, a node sends explicit requests to cause a resynchronisation
with the source after a mobility event, and to prevent a route from
spuriously expiring.
</p>
<p>The Babel protocol provides two kinds of explicit requests: route
requests, which simply request an update for a given prefix, and seqno
requests, which request an update for a given prefix with a specific
sequence number.  The former are never forwarded; the latter are forwarded
if they cannot be satisfied by a neighbour.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.1"></a><h3>3.8.1.&nbsp;
Handling Requests</h3>

<p>Upon receiving a request, a node either forwards the request or sends an
update in reply to the request, as described in the following sections.  If
this causes an update to be sent, the update is either sent to a multicast
address on the interface on which the request was received, or to the
unicast address of the neighbour that sent the update.
</p>
<p>The exact behaviour is different for route requests and seqno requests.
</p>
<a name="handling-route-requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.1.1"></a><h3>3.8.1.1.&nbsp;
Route Requests</h3>

<p>When a node receives a route request for a prefix (prefix, plen), it
checks its route table for a selected route to this exact prefix.  If such
a route exists, it MUST send an update; if it is not, it MUST send a
retraction for that prefix.
</p>
<p>When a node receives a wildcard route request, it SHOULD send a full
routing table dump.
</p>
<a name="handling-seqno-requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.1.2"></a><h3>3.8.1.2.&nbsp;
Seqno Requests</h3>

<p>When a node receives a seqno request for a given router-id and sequence
number, it checks whether its routing table contains a selected entry for
that prefix; if no such entry exists, or the entry has infinite metric, it
ignores the request.
</p>
<p>If a selected route for the given prefix exists, and either the
router-ids are different or the router-ids are equal and the entry's
sequence number is no smaller than the requested sequence number, it MUST
send an update for the given prefix.
</p>
<p>If the router-ids match but the requested seqno is larger than the route
entry's, the node compares the router-id against its own router-id.  If the
router-id is its own, then it increases its sequence number by 1 and sends
an update.  A node MUST NOT increase its sequence number by more than 1 in
response to a route request.
</p>
<p>If the requested router-id is not its own, the received request's hop
count is 2 or more, and the node has a route (not necessarily a feasible
one) for the requested prefix that does not use the requestor as
a next-hop, the node SHOULD forward the request.  It does so by decreasing
the hop count and sending the request in a unicast packet destined to
a neighbour that advertises the given prefix (not necessarily the selected
neighbour) and that is distinct from the neighbour from which the request
was received.
</p>
<p>A node SHOULD maintain a list of recently forwarded requests, and
forward the reply in a timely manner.  A node SHOULD compare every incoming
request against its list of recently forwarded requests and avoid
forwarding it if it is redundant.
</p>
<p>Since the request forwarding mechanism does not necessarily obey the
feasibility condition, it may get caught into routing loops; hence,
requests carry a hop count to limit the time for which they remain in the
network.  However, since requests are only ever forwarded as unicast
packets, the initial hop count need not be kept particularly low, and
performing an expanding horizon search is not necessary.  A request MUST
NOT be forwarded to a multicast address, and MUST be forwarded to a single
neighbour only.
</p>
<a name="sending-requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.2"></a><h3>3.8.2.&nbsp;
Sending Requests</h3>

<p>A Babel node MAY send a route or seqno request at any time, to a
multicast or a unicast address; there is only one case when originating
requests is required (<a class='info' href='#avoiding-starvation'>Section&nbsp;3.8.2.1<span> (</span><span class='info'>Avoiding Starvation</span><span>)</span></a>).
</p>
<a name="avoiding-starvation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.2.1"></a><h3>3.8.2.1.&nbsp;
Avoiding Starvation</h3>

<p>When a route is retracted or expires, a Babel node usually switches to
another feasible route for the same prefix.  It may be the case, however,
that no such routes are available.
</p>
<p>A node that has lost all feasible routes to a given destination MUST
send a seqno request.  The router-id of the request is set to the router-id
of the route that it has just lost, and the requested seqno is the value
contained in the source table, plus 1.
</p>
<p>Such a request SHOULD be multicast over all of the node's attached
interfaces.  Similar requests will be sent by other nodes that are affected
by the route's loss, and will be forwarded by neighbouring nodes up to the
source.  If the network is connected, and there is no packet loss, this
will result in a route being advertised with a new sequence number.  (Note
that due to duplicate suppression only a small number of such requests will
actually reach the source.)
</p>
<p>In order to compensate for packet loss, a node SHOULD repeat such
a request a small number of times if no route becomes feasible within
a short time.  Under heavy packet loss, however, all such requests may
be lost; in that case, the second mechanism in the next section will
eventually ensure that a new seqno is received.
</p>
<a name="request-unfeasible"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.2.2"></a><h3>3.8.2.2.&nbsp;
Dealing with Unfeasible Updates</h3>

<p>When a route's metric increases, a node might receive an unfeasible
update for a route that it has currently selected.  As specified in
<a class='info' href='#feasibility-condition'>Section&nbsp;3.5.1<span> (</span><span class='info'>The Feasibility Condition</span><span>)</span></a>, the receiving node will either
ignore the update or retract the route.
</p>
<p>In order to keep routes from spuriously expiring because they have
become unfeasible, a node SHOULD send a unicast seqno request whenever it
receives an unfeasible update for a route that is currently selected.  The
requested sequence number is computed from the source table as above.
</p>
<p>Additionally, a node SHOULD send a unicast seqno request whenever it
receives an unfeasible update from a currently unselected neighbour that is
"good enough", i.e. that would lead to the received route becoming selected
were it feasible.
</p>
<a name="request-expiring"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.2.3"></a><h3>3.8.2.3.&nbsp;
Preventing Routes From Expiring</h3>

<p>In normal operation, a route's expiry timer should never trigger: since
a route's hold time is computed from an explicit interval included in
Update TLVs, a new update should arrive in time to prevent a route from
expiring.
</p>
<p>In the presence of packet loss, however, it may be the case that no
update is successfully received for an extended period of time, causing a
route to expire.  In order to avoid such spurious expiry, shortly before a
selected route expires, a Babel node SHOULD send a unicast route request to
the neighbour that advertised this route; since nodes always send
retractions in response to non-wildcard route requests
(<a class='info' href='#handling-route-requests'>Section&nbsp;3.8.1.1<span> (</span><span class='info'>Route Requests</span><span>)</span></a>), this will usually result in
either the route being refreshed, or a retraction being received.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8.2.4"></a><h3>3.8.2.4.&nbsp;
Acquiring new neighbours</h3>

<p>In order to speed up convergence after a mobility event, a node MAY send
a unicast wildcard request after acquiring a new neighbour.  Additionally,
a node MAY send a small number of multicast wildcard requests shortly after
booting.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Protocol Encoding</h3>

<p>A Babel packet is sent as the body of a UDP datagram, with network-layer
hop count set to 1, destined to a well-known multicast address or to
a unicast address, over IPv4 or IPv6; in the case of IPv6, these addresses
are link-local.  Both the source and destination UDP port are set to
a well-known port number.  A Babel packet MUST be silently ignored unless
its source address is either a link-local IPv6 address, or an IPv4 address
belonging to the local network, and its source port is the well-known Babel
port.  Babel packets MUST NOT be sent as IPv6 Jumbograms.
</p>
<p>In order to minimise the number of packets being sent while avoiding
lower-layer fragmentation, a Babel node SHOULD attempt to maximise the size
of the packets it sends, up to the outgoing interface's MTU adjusted for
lower-layer headers (28 octets for UDP/IPv4, 48 octets for UDP/IPv6).  It
MUST NOT send packets larger than the attached interface's MTU (adjusted
for lower-layer headers) or 512 octets, whichever is larger, but not
exceeding 2^16 - 1 adjusted for lower-layer headers.  Every Babel speaker
MUST be able to receive packets that are as large as any attached
interface's MTU (adjusted for lower-layer headers) or 512 octets, whichever
is larger.
</p>
<p>In order to avoid global synchronisation of a Babel network and to
aggregate multiple TLVs into large packets, a Babel node MUST buffer every
TLV and delay sending a UDP packet by a small, randomly chosen delay <a class='info' href='#JITTER'>[JITTER]<span> (</span><span class='info'>Floyd, S. and V. Jacobson, &ldquo;The synchronization of periodic routing messages,&rdquo; April&nbsp;1994.</span><span>)</span></a>.  In order to allow accurate computation of packet loss
rates, this delay MUST NOT be larger than half the advertised Hello
interval.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Data Types</h3>

<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Interval</h3>

<p>Relative times are carried as 16-bit values specifying a number of
centiseconds (hundredths of a second).  This allows times up to roughly 11
minutes with a granularity of 10ms, which should cover all reasonable
applications of Babel.
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Router-Id</h3>

<p>A router-id is an arbitrary 8-octet value.  Router-ids SHOULD be assigned
in modified EUI-64 format <a class='info' href='#ADDRARCH'>[ADDRARCH]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;IP Version 6 Addressing Architecture,&rdquo; February&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Address</h3>

<p>Since the bulk of the protocol is taken by addresses, multiple ways of
encoding addresses are defined.  Additionally, a common subnet prefix may
be omitted when multiple addresses are sent in a single packet &mdash; this
is known as address compression <a class='info' href='#PACKETBB'>[PACKETBB]<span> (</span><span class='info'>Clausen, T., Dearlove, C., Dean, J., and C. Adjih, &ldquo;Generalized Mobile Ad Hoc Network (MANET) Packet/Message     Format,&rdquo; 2009.</span><span>)</span></a>.
</p>
<p>Address encodings:
</p>
<ul class="text">
<li>AE 0: wildcard address.  The value is 0 octets long.
</li>
<li>AE 1: IPv4 address.  Compression is allowed.  4 octets or less.
</li>
<li>AE 2: IPv6 address.  Compression is allowed.  16 octets or less.
</li>
<li>AE 3: link-local IPv6 address.  The value is 8 octets long, a prefix of
fe80::/64 is implied.
</li>
</ul><p>

</p>
<p>The address family of an address is either IPv4 or IPv6; it is undefined
for AE 0, IPv4 for AE 1, and IPv6 for AE 2 and 3.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.4"></a><h3>4.1.4.&nbsp;
Prefixes</h3>

<p>A network prefix is encoded just like a network address, but it is
stored in the smallest number of octets that are enough to hold the
significant bits (up to the prefix length).
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Packet Format</h3>

<p>A Babel packet consists of a four-octet header, followed by a sequence
of TLVs.
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Magic     |    Version    |        Body length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Packet Body ...
+-+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Magic</dt>
<dd>The arbitrary but carefully chosen value 42 (decimal);
packets with a first octet different from 42 MUST be silently ignored.
</dd>
<dt>Version</dt>
<dd>This document specifies version 2 of the Babel
  protocol.  Packets with a second octet different from 2 MUST be silently
  ignored.
</dd>
<dt>Body length</dt>
<dd>The length in octets of the body following the
  packet header.
</dd>
<dt>Body</dt>
<dd>The packet body, a sequence of TLVs.
</dd>
</dl></blockquote>

<p>Any data following the body MUST be silently ignored.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
TLV Format</h3>

<p>With the exception of Pad1, all TLVs have the following structure:
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Body...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>This field specifies the type of the TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
  Length fields.  If the body is longer than the expected length of a given
  type of TLV, any extra data MUST be silently ignored.
</dd>
<dt>Body</dt>
<dd>This is the TLV body, the interpretation of which
depends on the type.
</dd>
</dl></blockquote>

<p>TLVs with an unknown type value MUST be silently ignored.
</p>
<a name="tlv-details"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Details of Specific TLVs</h3>

<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
Pad1</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0
0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|   Type = 0    |
+-+-+-+-+-+-+-+-+
</pre></div>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 0 to indicate a Pad1 TLV.
</dd>
</dl></blockquote>

<p>This TLV is silently ignored on reception.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
PadN</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 1   |    Length     |      MBZ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 1 to indicate a PadN TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>MBZ</dt>
<dd>This field is set to 0 on transmission.
</dd>
</dl></blockquote>

<p>This TLV is silently ignored on reception.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
Acknowledgement Request</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 2   |    Length     |          Reserved             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Nonce              |          Interval             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>This TLV requests that the receiver send an Acknowledgement TLV
within the number of centiseconds specified by the Interval field.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 2 to indicate an Acknowledgement Request TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>Reserved</dt>
<dd>This field is sent as 0, and MUST be ignored on
  reception.
</dd>
<dt>Nonce</dt>
<dd>This is an arbitrary value which will be echoed in the
receiver's Acknowledgement TLV.
</dd>
<dt>Interval</dt>
<dd>This field expresses a time interval in centiseconds
after which the sender will assume that this packet has been lost.  This
MUST NOT be 0.  The receiver MUST send an acknowledgement before this time
has elapsed (with a margin allowing for propagation time). 
</dd>
</dl></blockquote>

<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.4"></a><h3>4.4.4.&nbsp;
Acknowledgement</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 3   |    Length     |            Nonce              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>This TLV is sent by a node upon receiving an Acknowledgement Request.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 3 to indicate an Acknowledgement TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>Nonce</dt>
<dd>This is set to the Nonce value of the Acknowledgement
Request that prompted this Acknowledgement.
</dd>
</dl></blockquote>

<p>Since nonce values are not globally unique, this TLV MUST be sent to
a unicast address.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.5"></a><h3>4.4.5.&nbsp;
Hello</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 4   |    Length     |          Reserved             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Seqno              |          Interval             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>This TLV is used for neighbour discovery and for determining a link's
reception cost.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 4 to indicate a Hello TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>Reserved</dt>
<dd>This field is sent as 0, and MUST be ignored on
reception.
</dd>
<dt>Seqno</dt>
<dd>The value of the sending node's hello seqno for this
interface.
</dd>
<dt>Interval</dt>
<dd>An upper bound, expressed in centiseconds, on the
time after which the sending node will send a new Hello TLV.  This MUST NOT
be 0.
</dd>
</dl></blockquote>

<p>Since there is a single seqno counter for all the hellos sent by a given
node over a given interface, this TLV MUST be sent to a multicast
destination.  In order to avoid large discontinuities in link quality,
multiple Hello TLVs SHOULD NOT be sent in the same packet.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.6"></a><h3>4.4.6.&nbsp;
IHU</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 5   |    Length     |       AE      |    Reserved   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Rxcost             |          Interval             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Address...
+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>An IHU (``I Heard You'') TLV is used for confirming bidirectional
reachability and carrying a link's transmission cost.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 5 to indicate an IHU TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>AE</dt>
<dd>The encoding of the Address field.  This should be 1 or 3
in most cases.  As an optimisation, it MAY be 0 if the TLV is
sent to a unicast address, if the association is over a point-to-point
link, or when bidirectional reachability is ascertained by means outside of
the Babel protocol.
</dd>
<dt>Reserved</dt>
<dd>This field is sent as 0, and MUST be ignored on
reception.
</dd>
<dt>Rxcost</dt>
<dd>The rxcost according to the sending node of the
interface whose address is specified in the Address field.  The value FFFF
hexadecimal (infinity) indicates that this interface is unreachable.
</dd>
<dt>Interval</dt>
<dd>An upper bound, expressed in centiseconds, on the
time after which the sending node will send a new IHU; this MUST NOT be 0.
The receiving node will use this value in order to compute a hold time for
this symmetric association.
</dd>
<dt>Address</dt>
<dd>The address of the destination node, in the format
specified by the AE field.  Address compression is not allowed.
</dd>
</dl></blockquote>

<p>Conceptually, an IHU is destined to a single neighbour.  However, IHU
TLVs contain an explicit destination address, and SHOULD be sent to
a multicast address, as this allows aggregation of IHUs destined to
distinct neighbours into a single packet, and avoids the need for an ARP or
Neighbour Discovery exchange when a neighbour is not being used for data
traffic.
</p>
<p>IHU TLVs with an unknown value for the AE field MUST be silently
ignored.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.7"></a><h3>4.4.7.&nbsp;
Router-Id</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 6   |    Length     |          Reserved             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                           Router-Id                           +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>A Router-Id TLV establishes a router-id that is implied by subsequent
Update TLVs.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 6 to indicate a Router-Id TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>Reserved</dt>
<dd>This field is sent as 0, and MUST be ignored on
reception.
</dd>
<dt>Router-Id</dt>
<dd>This field contains the router-id for routes
advertised in subsequent Update TLVs
</dd>
</dl></blockquote>

<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.8"></a><h3>4.4.8.&nbsp;
Next Hop</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 7   |    Length     |      AE       |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Next hop...
+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>A Next Hop TLV establishes a next hop address for a given address family
(IPv4 or IPv6) that is implied by subsequent Update TLVs.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 7 to indicate a Next Hop TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>AE</dt>
<dd>The encoding of the Address field.  This SHOULD be 1 or 3,
and MUST NOT be 0.
</dd>
<dt>Reserved</dt>
<dd>This field is sent as 0, and MUST be ignored on
reception.
</dd>
<dt>Next hop</dt>
<dd>The next hop address advertised by subsequent Update
TLV, for this address family.
</dd>
</dl></blockquote>

<p>When the address family matches the network-layer protocol that this
packet is transported over, a Next Hop TLV is not needed: in that case, the
next hop is taken to be the source address of the packet.
</p>
<p>Next Hop TLVs with an unknown value for the AE field MUST be silently
ignored.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.9"></a><h3>4.4.9.&nbsp;
Update</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 8   |    Length     |       AE      |    Flags      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Plen      |    Omitted    |            Interval           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Seqno             |            Metric             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Prefix...
+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>An Update TLV advertises or retracts a route.  As an optimisation, this
can also have the side effect of establishing a new implied router-id, and
a new default prefix.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 8 to indicate an Update TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>AE</dt>
<dd>The encoding of the Prefix field.
</dd>
<dt>Flags</dt>
<dd>The individual bits of this field specify special
handling of this TLV (see below).  Every node MUST be able to interpret the
flags with values 80 and 40 hexadecimal; unknown flags MUST be silently
ignored.
</dd>
<dt>Plen</dt>
<dd>This is the length of the advertised prefix.
</dd>
<dt>Omitted</dt>
<dd>The number of octets that have been omitted at
the beginning of the advertised prefix, and that should be taken from a
preceding Update TLV with the flag with value 80 hexadecimal set.
</dd>
<dt>Interval</dt>
<dd>An upper bound, expressed in centiseconds, on the
time after which the sending node will send a new update for this prefix.
This MUST NOT be 0, and SHOULD NOT be less than 10.  The receiving node
will use this value to compute a hold time for this routing table entry.
The value FFFF hexadecimal (infinity) expresses that this announcement will
not be repeated unless a request is received (<a class='info' href='#request-expiring'>Section&nbsp;3.8.2.3<span> (</span><span class='info'>Preventing Routes From Expiring</span><span>)</span></a>).
</dd>
<dt>Seqno</dt>
<dd>The originator's sequence number for this update.
</dd>
<dt>Metric</dt>
<dd>The sender's metric for this route.  The value FFFF
hexadecimal (infinity) means that this is a route retraction.
</dd>
<dt>Prefix</dt>
<dd>This field, of size (Plen/8 - Omitted) rounded
  upwards, specifies the prefix being advertised.
</dd>
</dl></blockquote>

<p>The Flags field is interpreted as follows:
</p>
<ul class="text">
<li>if the bit with value 80 hexadecimal is set, then this Update
establishes a new default prefix for subsequent Update TLVs with a matching
address family within the same packet;
</li>
<li>if the bit with value 40 hexadecimal is set, then the low-order 8 octets
of the advertised prefix establish a new default router-id for this TLV and
subsequent Update TLVs in the same packet.
</li>
</ul><p>

</p>
<p>The prefix being advertised by an Update TLV is computed as follows:
</p>
<ul class="text">
<li>the first Omitted octets of the prefix are taken from the previous
Update TLV with flag 80 hexadecimal set and the same address family;
</li>
<li>the next (Plen/8 - Omitted) (rounded upwards) octets are taken from the
Prefix field;
</li>
<li>the remaining octets are set to 0.
</li>
</ul><p>

</p>
<p>If the Metric field is finite, the router-id of the originating node for
this announcement is taken from the low-order 8 octets of the prefix
advertised by this Update if the bit with value 40 hexadecimal is set in
the Flags field.  Otherwise, it is taken either from the preceding
Router-Id packet, or the preceding Update packet with flag 40 hexadecimal
set, whichever comes last.
</p>
<p>The next hop address for this update is taken from the last preceding
Next Hop TLV with a matching address family in the same packet; if no
such TLV exists, it is taken from the network-layer source address of
this packet.
</p>
<p>If the metric field is FFFF hexadecimal, this TLV specifies
a retraction.  In that case, the current router-id and the Seqno are not
used.  AE MAY then be 0, in which case this Update retracts all of the
routes previously advertised on this interface.
</p>
<p>Update TLVs with an unknown value for the AE field MUST be silently
ignored.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.10"></a><h3>4.4.10.&nbsp;
Route Request</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 9   |    Length     |      AE       |     Plen      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Prefix...
+-+-+-+-+-+-+-+-+-+-+-+-
</pre></div>
<p>A Route Request TLV prompts the receiver to send an update for a given
prefix, or a full routing table dump.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 9 to indicate a Route Request TLV.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>AE</dt>
<dd>The encoding of the Prefix field.  The value 0 specifies
  that this is a request for a full routing table dump (a wildcard
  request).
</dd>
<dt>Plen</dt>
<dd>This is the length of the requested prefix.
</dd>
<dt>Prefix</dt>
<dd>This field, of size Plen/8 rounded upwards, specifies
  the prefix being requested.
</dd>
</dl></blockquote>

<p>A Request TLV prompts the receiving node to send an update message for
the prefix specified by the AE, Plen and Prefix fields, or a full dump of
its routing table if AE is 0 (in which case Plen MUST be 0 and Prefix is of
length 0).  A Request may be sent to a unicast address if it is destined to
a single node, or to a multicast address if the request is destined to all
of the neighbours of the sending interface.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.11"></a><h3>4.4.11.&nbsp;
Seqno Request</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type = 10  |    Length     |      AE       |    Plen       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Seqno             |  Hop Count    |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                          Router-Id                            +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Prefix...
+-+-+-+-+-+-+-+-+-+-+
</pre></div>
<p>A Seqno Request TLV prompts the receiver to send an Update for a given
prefix with a given sequence number, or to forward the request further if
it cannot be satisfied locally.
</p>
<p>Fields :
</p>
<blockquote class="text"><dl>
<dt>Type</dt>
<dd>Set to 10 to indicate a Seqno Request message.
</dd>
<dt>Length</dt>
<dd>The length of the body, exclusive of the Type and
Length fields.
</dd>
<dt>AE</dt>
<dd>The encoding of the Prefix field.  This MUST NOT be 0.
</dd>
<dt>Plen</dt>
<dd>This is the length of the requested prefix.
</dd>
<dt>Seqno</dt>
<dd>The sequence number that is being requested.
</dd>
<dt>Hop Count</dt>
<dd>The maximum number of times that this TLV may be
forwarded, plus 1.  This MUST NOT be 0.
</dd>
<dt>Prefix</dt>
<dd>This field, of size Plen/8 rounded upwards, specifies
  the prefix being requested.
</dd>
</dl></blockquote>

<p>A Seqno Request TLV prompts the receiving node to send an Update for the
prefix specified by the AE, Plen and Prefix fields, with either a router-id
different from what is specified by the Router-Id field, or a Seqno no less
than what is specified by the Seqno field.  If this request cannot be
satisfied locally, then it is forwarded according to the rules set out in
<a class='info' href='#handling-seqno-requests'>Section&nbsp;3.8.1.2<span> (</span><span class='info'>Seqno Requests</span><span>)</span></a>.
</p>
<p>While a Seqno Request MAY be sent to a multicast address, it MUST NOT be
forwarded to a multicast address, and MUST NOT be forwarded to more than
one neighbour.  A request MUST NOT be forwarded if its Hop Count field is
1.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
IANA Considerations</h3>

<p>IANA has registered the UDP port number TBD, called "babel", for use
by the Babel protocol.
</p>
<p>IANA has registered the IPv6 multicast group TBD and the IPv4 multicast
group TBD for use by the Babel protocol.
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>As defined in this document, Babel is a completely insecure protocol.
Any attacker can attract data traffic by advertising routes with a low
metric.  This particular issue can be solved either by lower-layer security
mechanisms (e.g.&nbsp;IPSec or link-layer security), or by appending a
cryptographic key to Babel packets; the provision of ignoring any data
contained within a Babel packet beyond the body length declared by the
header is designed for just such a purpose.
</p>
<p>The information that a Babel node announces to the whole routing domain
is often sufficient to determine a mobile node's physical location with
reasonable precision.  The privacy issues that this causes can be mitigated
somewhat by using randomly chosen router-ids, randomly chosen IP addresses,
and changing them periodically.
</p>
<p>When carried over IPv6, Babel packets are ignored unless they are sent
from a link-local IPv6 address; since routers don't forward link-local IPv6
packets, this provides protection against spoofed Babel packets being sent
from the global Internet.  No such natural protection exists when Babel
packets are carried over IPv4.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ADDRARCH">[ADDRARCH]</a></td>
<td class="author-text">Hinden, R. and S. Deering, &ldquo;<a href="http://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>,&rdquo; RFC&nbsp;4291, February&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, March&nbsp;1997.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="DSDV">[DSDV]</a></td>
<td class="author-text">Perkins, C. and P. Bhagwat, &ldquo;Highly Dynamic Destination-Sequenced Distance-Vector Routing
      (DSDV) for Mobile Computers,&rdquo; ACM SIGCOMM'94 Conference on Communications
           Architectures, Protocols and Applications&nbsp;234-244, 1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="DUAL">[DUAL]</a></td>
<td class="author-text">Garcia Luna Aceves, J., &ldquo;Loop-Free Routing Using Diffusing Computations,&rdquo; IEEE/ACM Transactions on Networking&nbsp;1:1, February&nbsp;1993.</td></tr>
<tr><td class="author-text" valign="top"><a name="EIGRP">[EIGRP]</a></td>
<td class="author-text">Albrightson, B., Garcia Luna Aceves, J., and J. Boyle, &ldquo;EIGRP -- a Fast Routing Protocol Based on Distance Vectors,&rdquo; Proc. Interop&nbsp;94, 1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="ETX">[ETX]</a></td>
<td class="author-text">De Couto, D., Aguayo, D., Bicket, J., and R. Morris, &ldquo;A high-throughput path metric for multi-hop wireless networks,&rdquo; Proc. MobiCom&nbsp;2003, 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="IS-IS">[IS-IS]</a></td>
<td class="author-text">&ldquo;Information technology &mdash; Telecommunications and
    information exchange between systems &mdash; Intermediate System to
    Intermediate System intra-domain routeing information exchange protocol
    for use in conjunction with the protocol for providing the
    connectionless-mode network service (ISO 8473),&rdquo; ISO/IEC&nbsp;10589:2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="JITTER">[JITTER]</a></td>
<td class="author-text">Floyd, S. and V. Jacobson, &ldquo;The synchronization of periodic routing messages,&rdquo; IEEE/ACM Trans. Netw.&nbsp;2, 2, 122-136, April&nbsp;1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="OSPF">[OSPF]</a></td>
<td class="author-text">Moy, J., &ldquo;<a href="http://tools.ietf.org/html/rfc2328">OSPF Version 2</a>,&rdquo; RFC&nbsp;2328, STD&nbsp;0054, April&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="PACKETBB">[PACKETBB]</a></td>
<td class="author-text">Clausen, T., Dearlove, C., Dean, J., and C. Adjih, &ldquo;<a href="http://tools.ietf.org/html/rfc5444">Generalized Mobile Ad Hoc Network (MANET) Packet/Message
    Format</a>,&rdquo; RFC&nbsp;5444, 2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RIP">[RIP]</a></td>
<td class="author-text">Malkin, G., &ldquo;<a href="http://tools.ietf.org/html/rfc2453">RIP Version 2</a>,&rdquo; RFC&nbsp;2453, November&nbsp;1998.</td></tr>
</table>

<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Cost and Metric Computation</h3>

<p>The strategy for computing link costs and route metrics is a local
matter; Babel itself only requires that it comply with the conditions given
in <a class='info' href='#cost-computation'>Section&nbsp;3.4.3<span> (</span><span class='info'>Cost Computation</span><span>)</span></a> and
<a class='info' href='#metric-computation'>Section&nbsp;3.5.2<span> (</span><span class='info'>Metric Computation</span><span>)</span></a>.  Different nodes MAY use different
strategies in a single network, and MAY use different strategies on
different interface types.  This section gives a few examples of such
strategies.
</p>
<p>The sample implementation of Babel maintains statistics about the last
16 received Hello TLVs (<a class='info' href='#hello-history'>Appendix&nbsp;A.1<span> (</span><span class='info'>Maintaining Hello history</span><span>)</span></a>), computes costs by
using the 2-out-of-3 strategy (<a class='info' href='#k-j'>Appendix&nbsp;A.2.1<span> (</span><span class='info'>k-out-of-j</span><span>)</span></a>) on wired links, and
ETX (<a class='info' href='#etx'>Appendix&nbsp;A.2.2<span> (</span><span class='info'>ETX</span><span>)</span></a>) on wireless links.  It uses an additive algebra
for metric computation (<a class='info' href='#additive-metric'>Appendix&nbsp;A.3.1<span> (</span><span class='info'>Additive Metrics</span><span>)</span></a>).
</p>
<a name="hello-history"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
Maintaining Hello history</h3>

<p>For each neighbour, the sample implementation of Babel maintains a Hello
history and an expected sequence number.  The Hello history is a vector of
16 bits, where a 1 value represents a received Hello, and a 0 value
a missed Hello.  The expected sequence number, written ne, is the sequence
number that is expected to be carried by the next received hello from this
neighbour.
</p>
<p>Whenever it receives a Hello packet from a neighbour, a node compares
the received sequence number nr with its expected sequence number ne.
Depending on the outcome of this comparison, one of the following actions
is taken:
</p>
<ul class="text">
<li>if the two differ by more than 16 (modulo 2^16), then the sending node
  has probably rebooted and lost its sequence number; the associated
  neighbour table entry is flushed;
</li>
<li>otherwise, if the received nr is smaller (modulo 2^16) than the
  expected sequence number ne, then the sending node has increased its
  hello interval without our noticing; the receiving node removes the last
  (ne - nr) entries from this neighbour's hello history (we ``undo
  history'');
</li>
<li>otherwise, if nr is larger (modulo 2^16) than ne, then the sending
  node has decreased its hello interval, and some hellos were lost; the
  receiving node adds (nr - ne) 0 bits to the hello history (we
  ``fast-forward'').
</li>
</ul><p>
The receiving node then appends a 1 bit to the neighbour's hello history,
resets the neighbour's hello timer, and sets ne to (nr + 1).  It then
resets the neighbour's hello timer to 1.5 times the value advertised in the
received Hello (the extra margin allows for the delay due to jitter).
</p>
<p>Whenever the Hello timer associated to a neighbour expires, the local
node adds a 0 bit to this neighbour's hello history, and increments the
expected hello number.  If the hello history is empty (it contains 0 bits
only), the neighbour entry is flushed; otherwise, it resets the neighbour's
hello timer to the value advertised in the last Hello received from this
neighbour (no extra margin is necessary in this case).
</p>
<a name="cost-computation-examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
Cost Computation</h3>

<a name="k-j"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.1"></a><h3>A.2.1.&nbsp;
k-out-of-j</h3>

<p>K-out-of-j link sensing is suitable for wired links, that are either up,
in which case they only occasionally drop a packet, or down, in which case
they drop all packets.
</p>
<p>The k-out-of-j strategy is parametrised by two small integers k and j,
such that 0 &lt; k &le; j, and the nominal link cost, a constant K &ge; 1.
A node keeps a history of the last j hellos; if k or more of those have
been correctly received, the link is assumed to be up, and the rxcost is
set to K; otherwise, the link is assumed to be down, and the rxcost is set
to infinity.
</p>
<p>The cost of such a link is defined as
  </p>
<ul class="text">
<li>cost = FFFF hexadecimal if rxcost = FFFF hexadecimal;
</li>
<li>cost = txcost otherwise.
</li>
</ul><p>

</p>
<a name="etx"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.2"></a><h3>A.2.2.&nbsp;
ETX</h3>

<p>The Estimated Transmission Cost metric <a class='info' href='#ETX'>[ETX]<span> (</span><span class='info'>De Couto, D., Aguayo, D., Bicket, J., and R. Morris, &ldquo;A high-throughput path metric for multi-hop wireless networks,&rdquo; 2003.</span><span>)</span></a> estimates
the number of times that a unicast frame will be retransmitted by the IEEE
802.11 MAC, assuming infinite persistence.
</p>
<p>A node uses a neighbour's hello history to compute an estimate beta of
the probability that a Hello TLV is successfully received.  The rxcost is
defined as 256/beta.
</p>
<p>Let alpha be MIN(1, 256/txcost), an estimate of the probability of
successfully sending a Hello TLV.  The cost is then computed by
  </p>
<blockquote class="text">
<p>cost = 256/(alpha * beta)
</p>
</blockquote><p>
or, equivalently,
  </p>
<blockquote class="text">
<p>cost = (MAX(txcost, 256) * rxcost) / 256.
</p>
</blockquote><p>

</p>
<a name="metric-computation-examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
Metric computation</h3>

<a name="additive-metric"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.1"></a><h3>A.3.1.&nbsp;
Additive Metrics</h3>

<p>The simplest approach for obtaining a monotonic, isotonic metric is to
define the metric of a route as the sum of the costs of the component
links.  More formally, if a neighbour advertises a route with metric m over
a link with cost c, then the resulting route has metric M(c, m) = c +
m.
</p>
<p>A multiplicative metric can be converted to an additive one by taking
the logarithm (in some suitable base) of the link costs.
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.2"></a><h3>A.3.2.&nbsp;
External Sources of Willingness</h3>

<p>A node may want to vary its willingness to forward packets by taking
into account information that is external to the Babel protocol, such as
the monetary cost of a link, the node's battery status, CPU load, etc.
This can be done by adding a value k that depends on the external data to
every route's metric.  For example, battery-powered node receives an update
with metric m over a link with cost c, it might compute a metric M(c, m) =
k + c + m, where k depends on the battery status.
</p>
<p>In order to preserve strict monotonicity
(<a class='info' href='#metric-computation'>Section&nbsp;3.5.2<span> (</span><span class='info'>Metric Computation</span><span>)</span></a>), 
the value k must be greater than -c.
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Constants</h3>

<p>The choice of time constants is a trade-off between fast detection of
mobility events and protocol overhead.  Two implementations of Babel with
different time constants will interoperate, although the resulting
convergence time will most likely be dictated by the slowest of the two
implementations.
</p>
<p>Experience with the sample implementation of Babel indicates that the
Hello interval is the most important time constant: a mobility event is
detected within 1.5 to 3 Hello intervals.  Due to Babel's reliance on
triggered updates and explicit requests, the Update interval only has an
effect on the time it takes for accurate metrics to be propagated after
variations in link costs too small to trigger an unscheduled update.
</p>
<p>At the time of writing, the sample implementation of Babel uses the
following default values:
</p>
<blockquote class="text">
<p>Hello Interval: 4 seconds on wireless links, 20 seconds on
wired links.
</p>
<p>IHU Interval: the advertised IHU interval is always 3 times the Hello
interval.  IHUs are actually sent with each Hello on lossy links (as
determined from the Hello history), but only with every third Hello on
lossless links.
</p>
<p>Update Interval: 4 times the Hello interval.
</p>
<p>IHU Hold Time: 3.5 times the advertised IHU interval.
</p>
<p>Route Expiry Time: 3.5 times the advertised update interval.
</p>
<p>Source GC time: 3 minutes.
</p>
</blockquote>

<p>The amount of jitter applied to a packet depends on whether it contains
any urgent TLVs or not.  Urgent triggered updates and urgent requests are
delayed by no more than 200ms; other TLVs are delayed by no more than
one-half the Hello interval.
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Simplified Implementations</h3>

<p>Babel is a fairly economic protocol.  Route updates take between 12 and
40 octets per destination, depending on how successful compression is; in
a double-stack mesh network, an average of less than 24 octets is typical.
The route table occupies about 35 octets per IPv6 entry.  To put these
values into perspective, a single full-size Ethernet frame can carry some
65 route updates, and a megabyte of memory can contain a 20000-entry
routing table and the associated source table.
</p>
<p>Babel is also a reasonably simple protocol.  The sample implementation
consists of less than 7000 lines of C code, and compiles to less than
60&nbsp;kB of text on a 32-bit CISC architecture.
</p>
<p>Nonetheless, in some very constrained environments, such as PDAs,
microwave ovens or abacuses, it may be desirable to have subset
implementations of the protocol.
</p>
<p>A parasitic implementation is one that uses a Babel network for routing
its packets but does not announce any of the routes that it has learnt from
its neighbours.  (This is slightly more than a passive implementation,
which doesn't even announce routes to itself.)  It may either maintain a
full routing table, or simply select a gateway amongst any one of its
neighbours that announces a default route.  Since a parasitic
implementation never forwards packets, it cannot possibly participate in a
routing loop; hence, it need not evaluate the feasibility condition, and
need not maintain a source table.
</p>
<p>A parasitic implementation MUST answer acknowledgement requests, and
MUST participate in the Hello/IHU protocol.  Finally, it MUST be able to
reply to seqno requests for routes that it announces, and SHOULD be able to
reply to route requests.
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;
Software Availability</h3>

<p>The sample implementation of Babel is available from
<a href='http://www.pps.jussieu.fr/~jch/software/babel/'>http://www.pps.jussieu.fr/~jch/software/babel/</a>.
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Juliusz Chroboczek</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PPS, University of Paris 7</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Case 7014</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">75205 Paris Cedex 13,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jch@pps.jussieu.fr">jch@pps.jussieu.fr</a></td></tr>
</table>
</body></html>
