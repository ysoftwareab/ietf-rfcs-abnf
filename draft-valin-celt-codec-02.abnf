alpha_p=0.8.  The inverse of the pre-emphasis is applied at the
fl=sum(f(i),i<k), fh=fl+f(i), and ft=sum(f(i)).
y0 = round_towards_zero( (K-1) * R / sum(abs(R)))

J = -R^T*y / ||y||

imid = bitexact_cos(itheta);

iside = bitexact_cos(16384-itheta);

delta = (N-1)*(log2_frac(iside,6)-log2_frac(imid,6))>>2;

qalloc = log2_frac((1<<qb)+1,4);

mbits = (b-qalloc/2-delta)/2;

CC = gcc
CFLAGS = -c -O2 -g
LIBS = -lm

OBJS = bands.o celt.o cwrs.o entcode.o entdec.o entenc.o kiss_fft.o \
           kiss_fftr.o laplace.o mdct.o modes.o pitch.o \
           quant_bands.o rangedec.o rangeenc.o rate.o testcelt.o vq.o plc.o

rate = atoi(argv[1]);
channels = atoi(argv[2]);
frame_size = atoi(argv[3]);
mode = celt_mode_create(rate, frame_size, NULL);
bytes_per_packet = atoi(argv[4]);
inFile = argv[argc - 2];
fin = fopen(inFile, "rb");
outFile = argv[argc - 1];
fout = fopen(outFile, "wb+");
enc = celt_encoder_create(mode, channels, &err);
dec = celt_decoder_create(mode, channels, &err);
complexity = atoi(argv[5]);
in = (celt_int16 *) malloc(frame_size * channels *
                                sizeof(celt_int16));
out =
         (celt_int16 *) malloc(frame_size * channels *
                               sizeof(celt_int16));
err = fread(in, sizeof(short), frame_size * channels, fin);
len =
           celt_encode_resynthesis(enc, in, in, frame_size, data,
                                   bytes_per_packet);
skip = 0;
rmsd = sqrt(rmsd / (1.0 * frame_size * channels * count));
C = channels;
st = celt_alloc(sizeof(CELTEncoder));

x = x * CELT_SIG_SCALE;
x = MAX32(x, -32768);
x = MIN32(x, 32767);
n = -1;

threshold = (((.2f)) * (begin[len]));
n = i;
n = -1;
ratio = 0;
ratio = ((begin[len]) / (1 + MAX32(*frame_max, begin[n - 16])));
ratio = 0;
ratio = 1000;

N = mode->shortMdctSize;
B = shortBlocks;
N4 = (N - overlap) >> 1;
N2 = mode->shortMdctSize;
B = shortBlocks;
n4offset = N4;
flag_bits = flaglist[i] & 0xf;
flag_bits = ec_dec_uint(dec, 4);
flag_bits = (flag_bits << 2) | ec_dec_uint(dec, 4);
flag_bits = (flag_bits << 1) | ec_dec_uint(dec, 2);
x = &in[C * (MAX_PERIOD - N) + c];
y = pcm + c;
m = tmp;
lambda = (5.f);
lambda = (2.f);
lambda = (1.f);
lambda = (.5f);

average = 0;
average = ((average) / (len));
threshold = (1.f);
tf_select = average > (3.f);
threshold = (.5f);
tf_select = average > (1.f);
cost0 = 0;
cost1 = lambda;
from0 = cost0;
from1 = cost1 + lambda;
curr0 = from0;
curr0 = from1;
from0 = cost0 + lambda;
from1 = cost1;
curr1 = from0;
curr1 = from1;
cost0 = curr0 + (metric[i] - threshold);
cost1 = curr1;
curr = tf_res[0];
curr = tf_res[i];
curr = tf_res[0];
curr = tf_res[i];
tf_select = ec_dec_bits(dec, 1);
M = 1 << LM;

enc = &_enc;
nbFilledBytes = 0;
nbFilledBytes = (ec_enc_tell(enc, 0) + 4) >> 3;
nbAvailableBytes = nbCompressedBytes - nbFilledBytes;

N = M * st->mode->shortMdctSize;
N4 = (N - st->overlap) >> 1;
transient_time = -1;
transient_shift = 0;
isTransient = 0;

resynth = st->pitch_available > 0 || optional_resynthesis != NULL;

gain_1 = 1. / (1 << transient_shift);
isTransient = 1;
has_fold = 1;
shortBlocks = M;
shortBlocks = 0;

norm_rate =
      (nbAvailableBytes -
       5) * 8 * (celt_uint32) st->mode->Fs / (C * N) >> 10;
has_pitch = st->pitch_enabled && st->pitch_permitted && (N <= 512)
      && (st->pitch_available >= MAX_PERIOD) && (!shortBlocks)
      && norm_rate < 50;
has_pitch =
        compute_pitch_gain(st->mode, freq, pitch_freq, norm_rate,
                           &gain_id, C, &st->gain_prod, M);
has_fold = 0;

intra_ener = st->force_intra || (!has_pitch && st->delayedIntra
                                   && nbAvailableBytes >
                                   st->mode->nbEBands);
NN = M * st->mode->eBands[st->mode->nbEBands];
m = 0;
m = 0;
mdct_weight_shift = 2;
mdct_weight_pos = m;
mdct_weight_shift = 1;
mdct_weight_pos = m;
vbr_rate = M * st->vbr_rate_norm;
vbr_bound = vbr_rate;
max_allowed =
        (vbr_rate + vbr_bound - st->vbr_reservoir) >> (BITRES + 3);
max_allowed = 4;
nbAvailableBytes = max_allowed;
tf_select =
      tf_analysis(bandLogE, st->oldBandE, st->mode->nbEBands, C,
                  isTransient, tf_res, nbAvailableBytes);

max_decay = .125 * nbAvailableBytes;

coarse_needed =
      quant_coarse_energy(st->mode, st->start, bandLogE,
                          st->oldBandE,
                          nbFilledBytes * 8 + nbAvailableBytes * 4 -
                          8, intra_ener, st->mode->prob, error, enc,
                          C, max_decay);
coarse_needed = ((coarse_needed * 3 - 1) >> 3) + 1;
coarse_needed = nbAvailableBytes;
target =
        target + st->vbr_offset - 588 + ec_enc_tell(enc, BITRES);

target = IMAX(coarse_needed, (target + 64) / 128);
target = IMIN(nbAvailableBytes, target);
alpha = celt_rcp(((st->vbr_count + 10)));
alpha = (.001f);

delta = (8 << BITRES) * (celt_int32) target - vbr_rate;
nbAvailableBytes = target;
nbCompressedBytes = nbAvailableBytes + nbFilledBytes;

bits = nbCompressedBytes * 8 - ec_enc_tell(enc, 0) - 1;
M = 1 << LM;

C = CHANNELS(st->channels);
N = M * st->mode->shortMdctSize;
ret =
        celt_encode_with_ec_float(st, in, in, frame_size, compressed,
                                  nbCompressedBytes, enc);
ret =
        celt_encode_with_ec_float(st, in, NULL, frame_size,
                                  compressed, nbCompressedBytes,
                                  enc);
value = 3072000;
frame_rate = ((st->mode->Fs << 3) + (N >> 1)) / N;
C = CHANNELS(channels);
st = celt_alloc(sizeof(CELTDecoder));

len = N + st->mode->overlap;

len2 = MAX_PERIOD >> 1;
pitch_index = MAX_PERIOD - len2 - pitch_index;
pitch_index = st->last_pitch_index;
fade = (.8f);
fade = 0;
offset = MAX_PERIOD - pitch_index;
E2 = 1;
period = pitch_index;
period = MAX_PERIOD / 2;
E1 = E2;
decay = celt_sqrt(frac_div32((E1), E2));
decay = ((decay) * (decay));
tmp1 = ((st->mode->window[i]) * (e[i])) -
          ((st->mode->window[overlap - i - 1]) *
           (e[overlap - i - 1]));
tmp2 =
          ((st->mode->window[i]) * (e[N + overlap - 1 - i])) +
          ((st->mode->window[overlap - i - 1]) * (e[N + i]));
tmp1 = ((fade) * (tmp1));
tmp2 = ((fade) * (tmp2));
M = 1 << LM;
N = M * st->mode->shortMdctSize;
N4 = (N - st->overlap) >> 1;

dec = &_dec;
nbFilledBytes = 0;
nbFilledBytes = (ec_dec_tell(dec, 0) + 4) >> 3;
nbAvailableBytes = len - nbFilledBytes;

shortBlocks = M;
shortBlocks = 0;

transient_shift = ec_dec_uint(dec, 4);
transient_time = ec_dec_uint(dec, N + st->mode->overlap);
mdct_weight_shift = transient_shift;
mdct_weight_pos = ec_dec_uint(dec, M - 1);
transient_shift = 0;
transient_time = 0;
transient_time = -1;
transient_shift = 0;
pitch_index = 0;
has_pitch = 0;
pitch_index = ec_dec_uint(dec, maxpitch);
gain_id = ec_dec_uint(dec, 16);
pitch_index = 0;
bits = len * 8 - ec_dec_tell(dec, 0) - 1;
M = 1 << LM;

C = CHANNELS(st->channels);
N = M * st->mode->shortMdctSize;
ret =
      celt_decode_with_ec_float(st, data, len, out, frame_size, dec);

offset = 0;

eBands = celt_alloc(sizeof(celt_int16) * (*nbEBands + 2));
low = (bark_freq[lin] + res / 2) / res;
high = nBark - lin;
eBands = celt_alloc(sizeof(celt_int16) * (*nbEBands + 2));

offset = eBands[low - 1] * res - bark_freq[lin - 1];
offset = eBands[i + low] * res - target;
allocVectors =
         celt_alloc(sizeof(unsigned char) *
                    (BITALLOC_SIZE * mode->nbEBands));
alloc =
             band_allocation[i * maxBands +
                             j] * (mode->eBands[eband + 1] -
                                   mode->eBands[eband]) << 4;
low = eband5ms[j] * 200;
high = eband5ms[j + 1] * 200;
edge = mode->eBands[eband + 1] * res;
num = alloc * (edge - low);
den = high - low;
bits = (2 * num + den) / (2 * den);
low = edge;
current = 0;
edge = mode->eBands[eband + 1] * res;
mode = celt_alloc(sizeof(CELTMode));
LM = 3;
LM = 2;
LM = 1;
LM = 0;
res = (mode->Fs + mode->shortMdctSize) / (2 * mode->shortMdctSize);

window = (float *) celt_alloc(mode->overlap * sizeof(float));
logN =
         (celt_int16 *) celt_alloc(mode->nbEBands * sizeof(celt_int16));
prevPtr = mode->bits[m][i];
prevPtr = mode->bits[-1][i];
N = M * m->eBands[m->nbEBands + 1];
N = M * m->eBands[m->nbEBands + 1];
i = 0;
N = M * m->eBands[m->nbEBands + 1];
f = freq + c * N;
x = X + c * N;
j = M * eBands[i];
end = M * eBands[i + 1];
Sxx = 0,
Syy = 0;
delta = ((1.0f) / (len));
Xj = ((X[j + c * N]));
Pj = ((gg) * (((P[j + c * N]))));
Sxy = ((Sxy) + (Xj) * (Pj));
Sxx = ((Sxx) + (Pj) * (Pj));
Syy = ((Syy) + (Xj) * (Xj));
gg = ((gg) - (delta));
fact = 1;
g = Sxy / (.1f + Sxx + .03f * Syy);
g = 0;
g = (((.5f)) + ((((.05f)) * (*gain_id))));
N = M * m->eBands[m->nbEBands + 1];
gain = (((.5f)) + ((((.05f)) * (gain_id))));
delta = ((gain) / (len));
gain = -gain;
delta = -delta;
gg = ((gg) + (delta));
a1 = (.70711f);
a2 = dir * (.70711f);
left = (bank[i]);
right = (bank[i + m->nbEBands]);
norm =
          1e-15f + celt_sqrt(1e-15f + ((left) * (left)) +
                             ((right) * (right)));
a1 = ((((left))) / (norm));
a2 = dir * ((((right))) / (norm));
l = X[j];
r = Y[j];
N0 = M * m->eBands[m->nbEBands + 1];

N = M * eBands[i + 1] - M * eBands[i];
max_val = ABS16(x[j]);
max_i = j;
floor_ener = (1.) - ((max_val) * (max_val));
floor_ener = MAX32(floor_ener, 1e-15f);

den = MAX32((.02f), den);
r = ((((max_val))) / (den));
ratio = ((ratio) + ((r)));
ratio = ((ratio) / (NR));
ratio = (((.5f * (ratio))) + ((.5f * (*average))));
N = N0 * stride;
N = N0 * stride;
iside = 0;
N_B0 = N_B;

split = stereo = Y != NULL;

sign = x[0] < 0;
sign = ec_dec_bits((ec_dec *) ec, 1);
x = Y;
spread0 = spread;
N_B0 = N_B;
spread0 = spread;
N_B0 = N_B;
Y = X + N;
split = 1;
spread = (spread + 1) >> 1;
offset = m->logN[i] + (LM << BITRES) - QTHETA_OFFSET;

N2 = 2 * N - 1;
qb = (b + N2 * offset) / (N2 << BITRES);
qb = (b >> (BITRES + 1)) - 1;

qb = 0;
qb = 14;

qalloc = 0;
shift = 14 - qb;

mid = renormalise_vector(X, 1.0f, N, 1);
side = renormalise_vector(Y, 1.0f, N, 1);

itheta = floor(.5f + 16384 * 0.63662f * atan2(side, mid));

itheta = (itheta + (1 << shift >> 1)) >> shift;
itheta = ec_dec_uint((ec_dec *) ec, (1 << qb) + 1);
qalloc = log2_frac((1 << qb) + 1, BITRES);
ft = ((1 << qb >> 1) + 1) * ((1 << qb >> 1) + 1);
j = 0;
fm = ec_decode((ec_dec *) ec, ft);
j = 0;
itheta = j;
qalloc = log2_frac(ft, BITRES) - log2_frac(fs, BITRES) + 1;
imid = 32767;
iside = 0;
delta = -10000;
imid = 0;
iside = 32767;
delta = 10000;
imid = bitexact_cos(itheta);
iside = bitexact_cos(16384 - itheta);
delta =
            (N - 1) * (log2_frac(iside, BITRES + 2) -
                       log2_frac(imid, BITRES + 2)) >> 2;
mbits = b - qalloc;
sbits = 0;
sbits = 1 << BITRES;
c = itheta > 8192 ? 1 : 0;
x2 = X;
y2 = Y;
c2 = 1 - c;

sign = 1;
sign = -1;
sign = 2 * ec_dec_bits((ec_dec *) ec, 1) - 1;
sign = 1;
mbits = (b - qalloc / 2 - delta) / 2;
mbits = b - qalloc;
mbits = 0;
sbits = b - qalloc - mbits;
next_lowband2 = lowband + N;
next_lowband_out1 = lowband_out;
next_level = level + 1;

q = bits2pulses(m, m->bits[LM][i], N, b);
curr_bits = pulses2bits(m->bits[LM][i], N, q);
curr_bits = pulses2bits(m->bits[LM][i], N, q);
mid = (1.f / 32768) * imid;
side = (1.f / 32768) * iside;

N_B = N_B0;
spread = spread0;
n = celt_sqrt(((N0)));
M = 1 << LM;
B = shortBlocks ? M : 1;
spread = fold ? B : 0;
norm = _norm;

balance = 0;
lowband = NULL;
X = _X + M * eBands[i];
Y = _Y + M * eBands[i];
Y = NULL;
N = M * eBands[i + 1] - M * eBands[i];
tell = ec_enc_tell((ec_enc *) ec, BITRES);
tell = ec_dec_tell((ec_dec *) ec, BITRES);

remaining_bits = (total_bits << BITRES) - tell - 1;
curr_balance = (m->nbEBands - i);
curr_balance = 3;
curr_balance = balance / curr_balance;
b = IMIN(remaining_bits + 1, pulses[i] + curr_balance);
b = 0;
b = C * 16 * N << BITRES;

lowband = norm + M * eBands[i] - N;
lowband = NULL;

tf_change = tf_res[i];
update_lowband = (b >> BITRES) > 2 * N;
l = EC_ILOG(val);
val =
          (val >> l - 16) + ((val & (1 << l - 16) - 1) +
                             (1 << l - 16) - 1 >> l - 16);
l = l - 1 << frac;
b = (int) (val >> 16);
val = val + b >> b;
val = val * val + 0x7FFF >> 15;
shift = EC_ILOG(_d ^ _d - 1);
inv = INV_TABLE[_d - 1 >> shift];
one = 1 << shift;
mask = one - 1;
g = 0;
bshift = EC_ILOG(_val) - 1 >> 1;
b = 1U << bshift;
t = ((celt_uint32) g << 1) + b << bshift;
N=0 or K=0. This allows us to construct a row of one of the tables
volume="IT-32", number=4, pages="568--583", month=Jul, year=1986 } */

j = 1;
ui1 = ((((_ui[j]) + (_ui[j - 1]))) + (_ui0));
j = 1;
ui1 = ((((_ui[j]) - (_ui[j - 1]))) - (_ui0));
len = _k + 2;
k = 2;
s = -(int) _i;
p = ucwrs2(_k + 1U);
s = -(_i >= p);
yj = _k;
p = ucwrs2(_k);
p = ucwrs3(_k + 1U);
s = -(_i >= p);
yj = _k;
p = ucwrs3(_k);
p = ucwrs4(_k + 1);
s = -(_i >= p);
yj = _k;
kl = 0;
kr = _k;
p = ucwrs4(_k);
kl = _k + 1;
kr = _k - 1;
p = ucwrs5(_k + 1);
s = -(_i >= p);
yj = _k;
p = ucwrs5(_k);
kl = _k + 1;
kr = _k - 1;
j = 0;
p = _u[_k + 1];
s = -(_i >= p);
yj = _k;
p = _u[_k];
p = _u[--_k];
i = icwrs1(_y + 1, &k);
i = icwrs2(_y + 1, &k);
i = icwrs3(_y + 1, &k);
i = icwrs4(_y + 1, &k);
i = icwrs1(_y + _n - 1, &k);
j = _n - 2;
i = icwrs1(_y, &_k);
i = icwrs2(_y, &_k);
i = icwrs3(_y, &_k);
i = icwrs4(_y, &_k);
i = icwrs5(_y, &_k);
i = icwrs(_n, _k, &nc, _y, u);
s = -s;
Xptr = X;
x1 = Xptr[0];
x2 = Xptr[stride];
Xptr = &X[len - 2 * stride - 1];
x1 = Xptr[0];
x2 = Xptr[stride];
K=5; } */
gain = celt_div((float) ((1.f) * (len)), (float) (len + 10 * K));
theta = (.5f * (((gain) * (gain))));

c = celt_cos_norm((theta));
s = celt_cos_norm((((1.0f) - (theta))));      /* sin(theta) */

stride2 = 1;
t = (Ryy);
g = celt_rsqrt_norm(t);

i = 0;
K = get_pulses(K);

N_1 = 512 / N;

sum = 0;
j = 0;
xy = yy = 0;

pulsesLeft = K;

j = 0;
j = 1;
sum = (1.f);
rcp = (((K - 1) * (celt_rcp(sum))));
j = 0;
yy = ((yy) + (y[j]) * (y[j]));
xy = ((xy) + (X[j]) * (y[j]));
pulsesAtOnce = (pulsesLeft * N_1) >> 9;     /* pulsesLeft/N */
pulsesAtOnce = 1;

magnitude = (pulsesAtOnce);

best_id = 0;
yy = ((yy) + (magnitude) * (magnitude));
j = 0;
s = magnitude;
Rxy = ((((xy) + (s) * (X[j]))));
Ryy = ((((yy) + (s) * (y[j]))));

Rxy = ((Rxy) * (Rxy));
best_den = Ryy;
best_num = Rxy;
best_id = j;
j = best_id;
is = pulsesAtOnce;
s = (is);

xy = xy + ((s) * (X[j]));
yy = yy + ((s) * (y[j]));

j = 0;
K = get_pulses(K);
Ryy = 0;
i = 0;
Ryy = ((Ryy) + (iy[i]) * (iy[i]));
E = ((E) + (*xptr) * (*xptr));
t = (E);
g = ((value) * (celt_rsqrt_norm(t)));

xptr = X;
Syy = ((Syy) + (y[j]) * (y[j]));
xcorr16 = ((xcorr[i]));
num = ((xcorr16) * (xcorr16));
score = num * 1. / Syy;
Syy = MAX32(1, Syy);
sum = ((sum) + (x_lp4[j]) * (y_lp4[i + j]));
maxcorr = MAX32(maxcorr, sum);
maxcorr = 1;
maxcorr = MAX32(maxcorr, sum);
a = xcorr[best_pitch[0] - 1];
b = xcorr[best_pitch[0]];
c = xcorr[best_pitch[0] + 1];
offset = 1;
offset = -1;
offset = 0;
offset = 0;
lo = 0;
hi = MAX_PSEUDO - 1;
hi = mid;
lo = mid;
lo = 0;
hi = MAX_PULSES - 1;

lo = 127;
hi = 1024;
hi = pulses;
lo = pulses;
hi = 1024;
hi = pulses;
lo = pulses;
hi = mid;
lo = mid;
bits =
          log2_frac(((((pulses) * (pulses)) >> 1) + 1) >> 1, BITRES);
bits =
          log2_frac((((((pulses) * (pulses)) +
                       2) * (pulses))) / 3 << 3, BITRES);
bits = celt_alloc(m->nbEBands * sizeof(celt_int16 *));
prevN = -1;
N = M * (eBands[i + 1] - eBands[i]);
N = (eBands[i + 1] - eBands[i]) >> 1;
error = 1;
prevN = N;
prevPtr = bits[i];
bits = NULL;
logM = log2_frac(M, BITRES);
lo = 0;
hi = 1 << BITRES;
psum = 0;
hi = mid;
lo = mid;
psum = 0;
left = (total << BITRES) - psum;
perband = left / (len - start);
left = left - len * perband;
N = M * (m->eBands[j + 1] - m->eBands[j]);
d = (C * N + ((C == 2 && N > 2) ? 1 : 0)) << BITRES;
offset = FINE_OFFSET - m->logN[j] - logM;
offset = bits[j] - offset * N * C;
offset = 0;
len = m->nbEBands;
lo = 0;
hi = m->nbAllocVectors - 1;
hi = mid;
lo = mid;
r = -frac_div32((rr), error);
tmp1 = lpc[j];
tmp2 = lpc[i - 1 - j];
error = error - ((((r) * (r))) * (error));
N2 = N >> 1;
N4 = N >> 2;
N = l->n;
N2 = N >> 1;
N4 = N >> 2;
sine = 2 * M_PI * (.125f) / N;

wp1 = window;
wp2 = window + overlap - 1;
re = yp[0];
im = yp[1];
yr = -S_MUL(re, t[i << shift]) - S_MUL(im,
                                               t[(N4 - i) << shift]);
yi = -S_MUL(im, t[i << shift]) + S_MUL(re,
                                               t[(N4 - i) << shift]);
yr = S_MUL(fp[1], t[(N4 - i) << shift]) + S_MUL(fp[0],
                                                        t[i << shift]);
yi = S_MUL(fp[0], t[(N4 - i) << shift]) - S_MUL(fp[1],
                                                        t[i << shift]);
N = l->n;
N2 = N >> 1;
N4 = N >> 2;
sine = 2 * M_PI * (.125f) / N;
yr = -S_MUL(*xp2, t[i << shift]) + S_MUL(*xp1,
                                                 t[(N4 - i) << shift]);
yi = -S_MUL(*xp2, t[(N4 - i) << shift]) - S_MUL(*xp1,
                                                        t[i << shift]);
re = fp[0];
im = fp[1];
yr = S_MUL(re, t[i << shift]) - S_MUL(im,
                                              t[(N4 - i) << shift]);
yi = S_MUL(im, t[i << shift]) + S_MUL(re,
                                              t[(N4 - i) << shift]);
x1 = *fp1--;
x2 = *fp2++;
ret = !!_v;
m = !!(_v & 0xFFFF0000) << 4;
m = !!(_v & 0xFF00) << 3;
m = !!(_v & 0xF0) << 2;
m = !!(_v & 0xC) << 1;
endbyte = _b->ptr - _b->buf;
fl = (unsigned) (_fl >> _ftb) & EC_UNIT_MASK;
ft = 1 << _ftb;
fl = (unsigned) _fl & ft - 1;
ftb = EC_ILOG(_ft);
ft = (_ft >> ftb) + 1;
fl = (unsigned) (_fl >> ftb);
endbyte = _b->ptr - _b->buf;
t = 0;
s = ec_decode_raw(_this, EC_UNIT_BITS);
t = t << EC_UNIT_BITS | s;
s = ec_decode_raw(_this, _ftb);
t = t << _ftb | s;
t = 0;
ftb = EC_ILOG(_ft);
ft = (unsigned) (_ft >> ftb) + 1;
s = ec_decode(_this, ft);
t = t << EC_UNIT_BITS | s;
t = t << ftb | ec_dec_bits(_this, ftb);
t = _ft;
s = ec_decode(_this, (unsigned) _ft);
t = t << ftb | s;
year=1979, address="Southampton", month=Jul } @ARTICLE{MNW98,
author="Alistair Moffat and Radford Neal and Ian H. Witten",
title="Arithmetic Coding Revisited", journal="{ACM} Transactions
pages="256--294", month=Jul,
URL="http://www.stanford.edu/class/ee398/handouts/papers/Moffat98Ari\
carry = _c >> EC_SYM_BITS;
sym = EC_SYM_MAX + carry & EC_SYM_MAX;
r = _this->rng / _ft;
r = _this->rng >> _bits;
r = _this->rng;
l = _this->low;
s = (r >> 16) * _prob;
nbits =
      (ec_byte_bytes(_this->buf) + (_this->rem >= 0) +
       _this->ext) * EC_SYM_BITS;
l = EC_ILOG(_this->rng);
r = _this->rng >> l - 16;
r = r * r >> 15;
b = (int) (r >> 16);
l = l << 1 | b;
l = EC_CODE_BITS - EC_ILOG(_this->rng);
msk = EC_CODE_TOP - 1 >> l;
end = _this->low + msk & ~msk;
end = _this->low + msk & ~msk;
end = end << EC_SYM_BITS & EC_CODE_TOP - 1;
year=1979, address="Southampton", month=Jul } @ARTICLE{MNW98,
author="Alistair Moffat and Radford Neal and Ian H. Witten",
title="Arithmetic Coding Revisited", journal="{ACM} Transactions
pages="256--294", month=Jul,
URL="http://www.stanford.edu/class/ee398/handouts/papers/Moffat98Ari\
ret = ec_byte_read1(_this->buf);
ret = 0;
sym = _this->rem << EC_CODE_EXTRA & EC_SYM_MAX;
s = (unsigned) ((_this->dif - 1) / _this->nrm);
s = (unsigned) ((_this->dif - 1) / _this->nrm);
s = ((_this->nrm) * ((_ft - _fh)));
r = _this->rng;
d = _this->dif;
s = (r >> 16) * _prob;
val = d <= s;
nbits =
      (ec_byte_bytes(_this->buf) -
       (EC_CODE_BITS + EC_SYM_BITS - 1) / EC_SYM_BITS) * EC_SYM_BITS;
l = EC_ILOG(_this->rng);
r = _this->rng >> l - 16;
r = r * r >> 15;
b = (int) (r >> 16);
l = l << 1 | b;
s = 1;
val = -val;
ft = 32768;
fl = -fs;
tmp_l = fl;
tmp_s = fs;
fs = (fs * (ec_int32) decay) >> 14;
fs = 1;
fs = tmp_s;
fl = tmp_l;
fl = 0;
fl = 0;
ft = 32768;
fh = fs;
fm = ec_decode_bin(dec, 15);
fl = fh;
fs = (fs * (ec_int32) decay) >> 14;
fs = 1;
val = -val;
dist = ((dist) + (d) * (d));
prob = celt_alloc(4 * m->nbEBands * sizeof(int));
coef = 0;
beta = (((.8f)) * (coef));

c = 0;
x = eBands[i + c * m->nbEBands];

f = x - mean - coef * oldEBands[i + c * m->nbEBands] - prev[c];
qi = (int) floor(.5f + f);

qi = 0;
bits_used = ec_enc_tell(enc, 0);
qi = -1;
q = (qi);

c = 0;
q2 = (int) floor((error[i + c * m->nbEBands] + .5f) * frac);

q2 = frac - 1;
q2 = 0;
offset =
             (q2 + .5f) * (1 << (14 - fine_quant[i])) * (1.f / 16384) -
             .5f;

c = 0;
q2 = error[i + c * m->nbEBands] < 0 ? 0 : 1;
offset =
               (q2 -
                .5f) * (1 << (14 - fine_quant[i] - 1)) * (1.f / 16384);

c = 0;
coef = 0;
beta = (((.8f)) * (coef));

c = 0;
qi = -1;
qi = ec_laplace_decode_start(dec, prob[2 * i],
                                        prob[2 * i + 1]);
q = (qi);

c = 0;
q2 = ec_dec_bits(dec, fine_quant[i]);

offset =
             (q2 + .5f) * (1 << (14 - fine_quant[i])) * (1.f / 16384) -
             .5f;

c = 0;
q2 = ec_dec_bits(dec, 1);

offset =
               (q2 -
                .5f) * (1 << (14 - fine_quant[i] - 1)) * (1.f / 16384);

c = 0;
id = 0;
id = i;
max_corr = x[i];
id = 0;
id = i;
max_corr = x[i];
tmp = (4096 + ((celt_int32) (x) * (x))) >> 13;
tmp = 32767;
x2 = tmp;
x2 = (32767 - x2) + FRAC_MUL16(x2,
                                 (-7651 +
                                  FRAC_MUL16(x2,
                                             (8277 +
                                              FRAC_MUL16(-626,
                                                         x2)))));
x2 = 32766;
integer = (in.i >> 23) - 127;
frac = in.f - 1.5f;
frac = -0.41445418f + frac * (0.95909232f
                                + frac * (-0.33951290f +
                                          frac * 0.16541097f));
integer = floor(x);
frac = x - integer;
maxval = MAX16(maxval, ABS16(x[i]));
n = x - 32768;
r = ((23557) + (((n) * (((-13490) + (((n) * (6713))))))));
r2 = ((r) * (r));
y = (((((((r2) * (n))) + (r2))) - (16384)));
k = celt_ilog2(x) >> 1;
x = (x);
k = (celt_ilog2(x) >> 1) - 7;
x = (x);
n = x - 32768;
rt = ((C[0]) +
        (((n) *
          (((C[1]) +
            (((n) *
              (((C[2]) +
                (((n) * (((C[3]) + (((n) * ((C[4])))))))))))))))));

rt = (rt);
k = (celt_ilog2(x) >> 1) - 7;
x = (x);
n = x - 32768;
rt = ((C[0]) +
        (((n) *
          (((C[1]) +
            (((n) *
              (((C[2]) +
                (((n) * (((C[3]) + (((n) * ((C[4])))))))))))))))));

rt = (rt);
x2 = ((x) * (x));
x = x & 0x0001ffff;
x = ((((1))) - (x));
i = celt_ilog2(x);
n = (x) - 32768 - 16384;
frac =
      ((C[0]) +
       (((n) *
         (((C[1]) +
           (((n) *
             (((C[2]) +
               (((n) * (((C[3]) + (((n) * (C[4]))))))))))))))));
K0 = 1 K1 = log(2) K2 = 3-4*log(2) K3 = 3*log(2) - 2 */
integer = (x);
frac = (x - (integer));
frac =
      ((D0) +
       (((frac) *
         (((D1) + (((frac) * (((D2) + (((D3) * (frac))))))))))));
i = celt_ilog2(x);
n = (x) - 32768;
r = ((30840) + (((-15420) * (n))));
r = ((r) - (((r) * (((((r) * (n))) + (((r) + (-32768))))))));

r = ((r) -
       (((1) + (((r) * (((((r) * (n))) + (((r) + (-32768))))))))));

a = (a);
b = (b);

rcp = (celt_rcp((b)));
result = (((rcp) * (a)));
rem = a - ((result) * (b));
arg = celt_div(((y)), x);
arg = 32767;
arg = celt_div(((x)), y);
arg = 32767;
Fout = Fout_beg + i * mm;
Fout2 = Fout + m;
tw1 = st->twiddles;
Fout = Fout_beg + i * mm;
Fout2 = Fout + m;
tw1 = st->twiddles;
Fout = Fout_beg + i * mm;
tw3 = tw2 = tw1 = st->twiddles;
Fout = Fout_beg + i * mm;
tw3 = tw2 = tw1 = st->twiddles;
epi3 = st->twiddles[fstride * m];
Fout = Fout_beg + i * mm;
tw1 = tw2 = st->twiddles;
k = m;
epi3 = st->twiddles[fstride * m];
Fout = Fout_beg + i * mm;
tw1 = tw2 = st->twiddles;
k = m;
ya = twiddles[fstride * m];
yb = twiddles[fstride * 2 * m];
tw = st->twiddles;

Fout = Fout_beg + i * mm;
Fout0 = Fout;
Fout1 = Fout0 + m;
Fout2 = Fout0 + 2 * m;
Fout3 = Fout0 + 3 * m;
Fout4 = Fout0 + 4 * m;

ya = twiddles[fstride * m];
yb = twiddles[fstride * 2 * m];
tw = st->twiddles;

Fout = Fout_beg + i * mm;
Fout0 = Fout;
Fout1 = Fout0 + m;
Fout2 = Fout0 + 2 * m;
Fout3 = Fout0 + 3 * m;
Fout4 = Fout0 + 4 * m;

p = 2;
p = 3;
p = n;                  /* no more factors, skip to end */
st = (kiss_fft_cfg) KISS_FFT_MALLOC(memneeded);
st = (kiss_fft_cfg) mem;
twiddle_size = nfft / 2 + 1;
memneeded =
         sizeof(struct kiss_fftr_state) + subsize +
         sizeof(kiss_twiddle_cpx) * twiddle_size;

st = (kiss_fftr_cfg) KISS_FFT_MALLOC(memneeded);
st = (kiss_fftr_cfg) mem;
ncfft = st->substate->nfft;

ncfft = st->substate->nfft;

k1 = st->substate->bitrev[k];
k2 = st->substate->bitrev[ncfft - k];
