<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Stateful NAT64: Network Address and Protocol
   Translation from IPv6 Clients to IPv4 Servers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Stateful NAT64: Network Address and Protocol
   Translation from IPv6 Clients to IPv4 Servers">
<meta name="keywords" content="NAT64, IPv6">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">BEHAVE WG</td><td class="header">M. Bagnulo</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">UC3M</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">P. Matthews</td></tr>
<tr><td class="header">Expires: July 25, 2010</td><td class="header">Alcatel-Lucent</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">I. van Beijnum</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">IMDEA Networks</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">January 21, 2010</td></tr>
</table></td></tr></table>
<h1><br />Stateful NAT64: Network Address and Protocol
   Translation from IPv6 Clients to IPv4 Servers<br />draft-ietf-behave-v6v4-xlate-stateful-08</h1>

<h3>Abstract</h3>

<p>This document describes stateful NAT64 translation, which allows
	   IPv6-only clients to contact IPv4 servers using unicast UDP, TCP, 
	   or ICMP.  The public IPv4 address can be shared among several IPv6-only 
	   clients.   When the stateful NAT64 is used in conjunction with DNS64 
	   no changes are usually 
	   required in the IPv6 client or the IPv4 server.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on July 25, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the BSD License.</p>
<p>
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Features of stateful NAT64<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.2.1.</a>&nbsp;
Stateful NAT64 solution elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.2.2.</a>&nbsp;
Stateful NAT64 Behaviour Walkthrough<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.2.3.</a>&nbsp;
Filtering<br />
<a href="#anchor7">2.</a>&nbsp;
Terminology<br />
<a href="#normative">3.</a>&nbsp;
Stateful NAT64 Normative Specification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.1.</a>&nbsp;
Binding Information Bases<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.2.</a>&nbsp;
Session Tables<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.3.</a>&nbsp;
Packet Processing Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#incoming tuple">3.4.</a>&nbsp;
Determining the Incoming tuple<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec-session-info">3.5.</a>&nbsp;
Filtering and Updating Binding and Session Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.5.1.</a>&nbsp;
UDP Session Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#UDP transport address alloc">3.5.1.1.</a>&nbsp;
Rules for Allocation of IPv4 Transport Addresses for UDP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">3.5.2.</a>&nbsp;
TCP Session Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">3.5.2.1.</a>&nbsp;
State definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.5.2.2.</a>&nbsp;
State machine for TCP processing in the NAT64<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TCP transport address alloc">3.5.2.3.</a>&nbsp;
Rules for allocation of IPv4 transport addresses for TCP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.5.3.</a>&nbsp;
ICMP Query Session Handling<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#address-transform">3.5.4.</a>&nbsp;
Generation of the IPv6 Representations of IPv4 Addresses<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#outgoing tuple">3.6.</a>&nbsp;
Computing the Outgoing Tuple<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">3.6.1.</a>&nbsp;
Computing the Outgoing 5-tuple for TCP and UDP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#outgoing 3-tuple">3.6.2.</a>&nbsp;
Computing the Outgoing 3-tuple for ICMP Query Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.7.</a>&nbsp;
Translating the Packet<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.8.</a>&nbsp;
Handling Hairpinning<br />
<a href="#anchor19">4.</a>&nbsp;
Protocol Constants<br />
<a href="#sec">5.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">5.1.</a>&nbsp;
Implications on end-to-end security<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">5.2.</a>&nbsp;
Filtering<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">5.3.</a>&nbsp;
Attacks on NAT64<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">5.4.</a>&nbsp;
Avoiding hairpinning loops<br />
<a href="#anchor24">6.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor25">7.</a>&nbsp;
Contributors<br />
<a href="#anchor26">8.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>This document specifies stateful NAT64, a mechanism for IPv4-IPv6
     transition and co-existence. Together with DNS64 
	  <a class='info' href='#I-D.ietf-behave-dns64'>[I&#8209;D.ietf&#8209;behave&#8209;dns64]<span> (</span><span class='info'>Bagnulo, M., Sullivan, A., Matthews, P., and I. Beijnum, &ldquo;DNS64: DNS extensions for Network Address Translation from IPv6 Clients to IPv4 Servers,&rdquo; March&nbsp;2010.</span><span>)</span></a>, these two mechanisms allow a
     IPv6-only client to initiate communications to an IPv4-only server.
     They also enable peer-to-peer
     communication between an IPv4 and an IPv6 node, where the communication can be
     initiated by either end using existing, NAT-traversing, peer-to-peer
     communication techniques, such as ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>. Stateful NAT64 also supports IPv4-initiated communications to a subset
	 of the IPv6 hosts through statically configured bindings in the stateful NAT64.
</p>
<p>Stateful NAT64 is a mechanism for translating IPv6 packets to IPv4 packets and vice-versa.
     The translation is done by translating the packet headers according 
	  to the IP/ICMP Translation Algorithm defined in <a class='info' href='#I-D.ietf-behave-v6v4-xlate'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate]<span> (</span><span class='info'>Li, X., Bao, C., and F. Baker, &ldquo;IP/ICMP Translation Algorithm,&rdquo; April&nbsp;2010.</span><span>)</span></a>. 
	  The IPv4 addresses of IPv4 hosts are algorithmically translated to and from IPv6 addresses 
	  by using the algorithm defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a> and 
	  a prefix assigned to the stateful NAT64 for this specific purpose. The IPv6 addresses of IPv6 hosts 
	  are translated to and from IPv4 addresses by installing mappings in the normal NAT manner. 
	  The current specification only defines how stateful NAT64 translates packets carrying TCP and UDP traffic. Other protocols,
	including SCTP, DCCP and IPsec are out of the scope of this specification and will be specified somewhere else.
</p>
<p>DNS64 is a mechanism for synthesizing AAAA resource records (RR)
	  from A RR. The IPv6 address contained in the synthetic AAAA RR is algorithmically generated from the IPv4 
	  address and the IPv6 prefix assigned to a NAT64 device by using the same algorithm defined in 
	  <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</p>
<p>Together, these two mechanisms allow an IPv6-only client 
	(i.e. either a host with only IPv6 stack, or a host with both IPv4 and IPv6 stack, 
	but only with IPv6 connectivity or a host running an IPv6 only application)
	to initiate
     communications to an IPv4-only server (analogous meaning to the IPv6-only host above).
</p>
<p>These mechanisms are expected to play a critical role in the
     IPv4-IPv6 transition and co-existence. Due to IPv4 address depletion, 
	 it is likely that in the future, many IPv6-only clients will want 
	 to connect to IPv4-only servers. The stateful NAT64 and DNS64 mechanisms are
     easily deployable, since they require no changes to either the IPv6 client
     nor the IPv4 server. For basic functionality, the approach only requires
     the deployment of the stateful NAT64 function in the devices connecting an IPv6-only network to
     the IPv4-only network, along with the deployment of a few DNS64-enabled
     name servers accessible to the IPv6-only hosts. 
	 An analysis of the application scenarios can be found in <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; March&nbsp;2010.</span><span>)</span></a>.
	  
</p>
<p>For brevity, in the rest of the document, we will refer to the stateful NAT64 either as stateful NAT64 or simply as NAT64.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Features of stateful NAT64</h3>

<p>The features of NAT64 are:</p>
<ul class="text">
<li> NAT64 is compliant with the
           recommendations for how NATs should handle UDP <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>, TCP <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>, and ICMP 
		    <a class='info' href='#RFC5508'>[RFC5508]<span> (</span><span class='info'>Srisuresh, P., Ford, B., Sivakumar, S., and S. Guha, &ldquo;NAT Behavioral Requirements for ICMP,&rdquo; April&nbsp;2009.</span><span>)</span></a>. As such, NAT64 only supports Endpoint-Independent mappings
			and supports both Endpoint-Independent and Address-Dependent Filtering. 
			Because of the compliance with the aforementioned requirements, NAT64 is compatible 
			with current NAT traversal techniques, such as ICE <a class='info' href='#I-D.ietf-mmusic-ice'>[I&#8209;D.ietf&#8209;mmusic&#8209;ice]<span> (</span><span class='info'>Rosenberg, J., &ldquo;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols,&rdquo; October&nbsp;2007.</span><span>)</span></a>
			and compatible with other non-IETF-standard NAT traversal
			techniques.
</li>
<li>In the absence of any state in NAT64, only IPv6 nodes can initiate sessions to IPv4 nodes.
		     This works for roughly the same class of applications that work
	         through IPv4-to-IPv4 NATs.
</li>
<li>Depending on the filtering policy used (Endpoint-Independent,
		   or Address-Dependent), IPv4-nodes might be able
		   to initiate sessions to a given IPv6 node, if the NAT64 somehow has an
		   appropriate mapping (i.e.,state) for an IPv6 node, via one of the
		   following mechanisms:
				
<ul class="text">
<li> The IPv6 node has recently initiated a session to the
					same or another IPv4 node. this is also the case if the IPv6 
					node has used a NAT-traversal technique (such as ICE) .
</li>
<li> If a statically configured mapping exists
					for the IPv6 node.
</li>
</ul>
</li>
<li>IPv4 address sharing: NAT64 allows multiple IPv6-only nodes to share an IPv4 address
		    to access the IPv4 Internet. This helps with IPv4 forthcoming exhaustion.
</li>
<li>As currently defined in this NAT64 specification, only TCP/UDP/ICMP are supported.
			Support for other protocols such as other transport protocols and IPsec are to be defined in
			separated documents.
</li>
</ul>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Overview</h3>

<p>This section provides a non-normative introduction to
      NAT64.	This is achieved by describing the NAT64 behavior involving a simple 
	setup, that involves a single NAT64 device, a single DNS64 and a simple
	network topology. The goal of this description is to provide the reader with 
	a general view of NAT64.  It is not the goal of this
	section to describe all possible configurations nor to provide a normative 
	specification of the NAT64 behavior.
	So, for the sake of clarity, only TCP and UDP are described in this overview; the details
    of ICMP, fragmentation, and other aspects of translation are purposefully avoided in this overview.
    The normative specification of NAT64 is provided in <a class='info' href='#normative'>Section&nbsp;3<span> (</span><span class='info'>Stateful NAT64 Normative Specification</span><span>)</span></a>.
</p>
<p>The NAT64 mechanism is implemented in a device which has (at least) two
     interfaces, an IPv4 interface connected to the IPv4 network, and an
     IPv6 interface connected to the IPv6 network. Packets generated in the
     IPv6 network for a receiver located in the IPv4 network will be routed
     within the IPv6 network towards the NAT64 device. The NAT64 will
     translate them and forward them as IPv4 packets through the IPv4 network
     to the IPv4 receiver. The reverse takes place for packets generated by hosts connected to 
     the IPv4 network for an IPv6 receiver. NAT64, however, is not symmetric.
     In order to be able to perform IPv6-IPv4 translation, NAT64 requires state, 
	  binding an IPv6 address and TCP/UDP port (hereafter called an IPv6 transport address) 
	  to an IPv4 address and TCP/UDP port (hereafter called an IPv4 transport address).
</p>
<p>Such binding state is either statically configured in the NAT64 or it is 
	 created when the first packet flowing from the
     IPv6 network to the IPv4 network is translated. After the binding state
     has been created, 
	 packets flowing in both directions on that particular
     flow are translated. The result is that, in the general case, NAT64 only supports
     communications initiated by the IPv6-only node towards an IPv4-only
     node. Some additional mechanisms (like ICE) or static binding configuration, can be used 
	 to provide support for communications initiated by an
     IPv4-only node to an IPv6-only node. 
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.1"></a><h3>1.2.1.&nbsp;
Stateful NAT64 solution elements</h3>

<p>In this section we describe the different elements involved in the
       NAT64 approach.
</p>
<p>The main component of the proposed solution is the translator
       itself. The translator has essentially two main parts, the address
       translation mechanism and the protocol translation mechanism.
</p>
<p>Protocol translation from IPv4 packet header to IPv6 packet header
       and vice-versa is performed according to the <a class='info' href='#I-D.ietf-behave-v6v4-xlate'>IP/ICMP Translation Algorithm<span> (</span><span class='info'>Li, X., Bao, C., and F. Baker, &ldquo;IP/ICMP Translation Algorithm,&rdquo; April&nbsp;2010.</span><span>)</span></a> [I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate].
</p>
<p>Address translation maps IPv6 transport addresses to IPv4 transport
       addresses and vice-versa. In order to create these mappings the NAT64
       has two pools of addresses: an IPv6 address pool (to represent
       IPv4 addresses in the IPv6 network) and an IPv4 address pool (to
       represent IPv6 addresses in the IPv4 network). 
</p>
<p>The IPv6 address pool is one or more IPv6 prefixes assigned to the translator 
	   itself (hereafter we will call the IPv6 address pool as Pref64::/n, in the case there are more 
	   than one prefix assigned to the NAT64, the comments made about Pref64::/n apply to each of them). 
	   Pref64::/n will be used by the NAT64 to construct IPv4-Converted IPv6 addresses as defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
	   Due to the abundance of IPv6 address space, 
	   it is possible to assign one or more Pref64::/n, each of them being equal to or even bigger than the size of the whole IPv4 address space. This allows
       each IPv4 address to be mapped into a different IPv6 address by simply
       concatenating a Pref64::/n with the IPv4 address being mapped and a suffix. 
	   The provisioning of the Pref64::/n as well as the address format are 
 	   defined in <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>. 
</p>
<p>The IPv4 address pool is a set of IPv4 addresses,
       normally a small prefix assigned by the local administrator. Since IPv4 
		address space is a scarce resource, the IPv4 address pool is small and 
		typically not sufficient to establish permanent one-to-one mappings with IPv6
       addresses. So, except for the static/manually created ones, 
	   mappings using the IPv4 address pool will be created
       and released dynamically. Moreover, because of the IPv4 address
       scarcity, the usual practice for NAT64 is likely to be the binding of
       IPv6 transport addresses into IPv4 transport addresses, instead of
       IPv6 addresses into IPv4 addresses directly, enabling a higher
       utilization of the limited IPv4 address pool.
</p>
<p>Because of the dynamic nature of the IPv6 to IPv4 address mapping
       and the static nature of the IPv4 to IPv6 address mapping, it is far simpler to allow communications initiated
       from the IPv6 side toward an IPv4 node, whose address is algorithmically 
       mapped into an IPv6 address, than communications initiated from
       IPv4-only nodes to an IPv6 node in which case an IPv4 address needs to be
       associated with the IPv6 node's address dynamically.
</p>
<p>Using DNS64, an IPv6 client obtains an IPv6 address that embeds
	  the IPv4 address of the IPv4 server, and sends a packet to that
	  IPv6 address. The
       packets are intercepted by the NAT64 device, which associates an IPv4 transport
       address of its IPv4 pool to the IPv6 transport address of the
       initiator, creating binding state, so that reply packets can be
       translated and forwarded back to the initiator. The binding state is
       kept while packets are flowing. Once the flow stops, and based on a
       timer, the IPv4 transport address is returned to the IPv4 address pool
       so that it can be reused for other communications.
</p>
<p>To allow an IPv6 initiator to do a DNS lookup to learn
       the address of the responder, DNS64 <a class='info' href='#I-D.ietf-behave-dns64'>[I&#8209;D.ietf&#8209;behave&#8209;dns64]<span> (</span><span class='info'>Bagnulo, M., Sullivan, A., Matthews, P., and I. Beijnum, &ldquo;DNS64: DNS extensions for Network Address Translation from IPv6 Clients to IPv4 Servers,&rdquo; March&nbsp;2010.</span><span>)</span></a> 
		is used to synthesize AAAA RRs from the A
       RRs. The IPv6 addresses contained in the synthetic AAAA RRs contain 
       the Pref64::/n assigned to the NAT64 and the real IPv4 
	   address of the responder. The
       synthetic AAAA RRs are passed back to the IPv6 initiator, which will
       initiate an IPv6 communication with an IPv6 address associated to the
       IPv4 receiver. The packet will be routed to the NAT64 device, which
       will create the IPv6 to IPv4 address mapping as described before.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.2"></a><h3>1.2.2.&nbsp;
Stateful NAT64 Behaviour Walkthrough</h3>

<p>In this section we provide a simple example of the NAT64 behaviour. 
	   We consider an IPv6 node located in an IPv6-only
       site that initiates a TCP connection to an IPv4-only node located in the IPv4
       network.
</p>
<p>The scenario for this case is depicted in the following figure:
</p>
<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
+---------------------+         +---------------+
|IPv6 network         |         |    IPv4       |
|           |  +-------------+  |  Network      |
|           |--| Name server |--|               |
|           |  | with DNS64  |  |  +----+       |
|  +----+   |  +-------------+  |  | H2 |       |
|  | H1 |---|         |         |  +----+       |
|  +----+   |      +-------+    |  192.0.2.1    |
|2001:DB8::1|------| NAT64 |----|               |
|           |      +-------+    |               |
|           |         |         |               |
+---------------------+         +---------------+
</pre></div>
<p>
</p>
<p>The figure above shows an IPv6 node H1 with an IPv6 address 2001:DB8::1 and an
       IPv4 node H2 with IPv4 address 192.0.2.1. H2 has h2.example.com as FQDN.
</p>
<p>A NAT64 connects the IPv6 network to the IPv4 network. This NAT64 uses the Well-Know Prefix 64:FF9B::/96
	     defined <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a> to represent IPv4 addresses in
		the IPv6 address space and a single IPv4 address 203.0.113.1 assigned to its IPv4 interface.
		The routing is configured in such a way that the IPv6 packets addressed
		to a destination address in 64:FF9B::/96  are routed to the IPv6
		interface of the NAT64 device. 
</p>
<p>Also shown is a local name server with DNS64 functionality. The local 
		name server uses the Well-Know prefix 64:FF9B::/96 to create the IPv6 addresses in the synthetic RRs.
</p>
<p>For this example, assume the typical DNS situation where IPv6 hosts
       have only stub resolvers and the local name server does the recursive
       lookups.
</p>
<p>The steps by which H1 establishes communication with H2 are: </p>
<ol class="text">
<li>H1 performs a DNS query for h2.example.com and receives the synthetic
	 			AAAA RR from the local name server that implements the 
	    		DNS64 functionality. The AAAA record contains an IPv6 address formed 
	 			by the Well-Known Prefix and
               the IPv4 address of H2 (i.e. 64:FF9B::192.0.2.1).
</li>
<li>H1 sends a TCP SYN packet
           to H2. The packet is sent from a source transport address of
           (2001:DB8::1,1500) to a destination transport address of (64:FF9B::192.0.2.1,80), where 
           the ports are set by H1.
</li>
<li>The packet is routed to the IPv6 interface of the NAT64 (since
            IPv6 routing is configured that way).
</li>
<li>The NAT64 receives the packet and performs the following
           actions: 
<ul class="text">
<li>The NAT64 selects an unused port e.g. 2000 on its IPv4 address 203.0.113.1
               and creates the mapping entry (2001:DB8::1,1500) &lt;--&gt; (203.0.113.1,2000)
</li>
<li>The NAT64 translates the IPv6 header into an IPv4 header
               using the IP/ICMP Translation Algorithm <a class='info' href='#I-D.ietf-behave-v6v4-xlate'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate]<span> (</span><span class='info'>Li, X., Bao, C., and F. Baker, &ldquo;IP/ICMP Translation Algorithm,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</li>
<li>The NAT64 includes (203.0.113.1,2000) as source transport address in the
               packet and (192.0.2.1.,80) as destination transport address in the
               packet. Note that 192.0.2.1. is extracted directly from the destination 
			   IPv6 address of the received IPv6
               packet that is being translated. The destination port 80 of the translated
 				packet is the same as the destination port of the received IPv6 packet.
</li>
</ul>
</li>
<li>The NAT64 sends the translated packet out its IPv4
           interface and the packet arrives at H2.
</li>
<li>H2 node responds by sending a TCP SYN+ACK packet with destination transport
           address (203.0.113.1,2000) and source transport address (192.0.2.1.,80).
</li>
<li>Since the IPv4 address 203.0.113.1 is assigned to the IPv4 interface of the NAT64 device, 
			the packet is routed to the NAT64 device, which will look for an
           existing mapping containing (203.0.113.1,2000). Since the mapping (2001:DB8::1,1500)
           &lt;--&gt; (203.0.113.1,2000) exists, the NAT64 performs the following
           operations: 
<ul class="text">
<li>The NAT64 translates the IPv4 header into an IPv6 header
               using the IP/ICMP Translation Algorithm <a class='info' href='#I-D.ietf-behave-v6v4-xlate'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate]<span> (</span><span class='info'>Li, X., Bao, C., and F. Baker, &ldquo;IP/ICMP Translation Algorithm,&rdquo; April&nbsp;2010.</span><span>)</span></a>.
</li>
<li>The NAT64 includes (2001:DB8::1,1500) as destination transport address in
               the packet and (64:FF9B::192.0.2.1,80) as source transport address
               in the packet. Note that 192.0.2.1. is extracted directly from the
               source IPv4 address of the received IPv4 packet that is being
               translated. The source port 80 of the translated
 				packet is the same as the source port of the received IPv4 packet.
</li>
</ul>
</li>
<li>The translated packet is sent out the IPv6 interface to
           H1.
</li>
</ol>

<p>The packet exchange between H1 and H2 continues and packets are
       translated in the different directions as previously
       described.
</p>
<p>It is important to note that the translation still works if the 
			IPv6 initiator H1 learns the IPv6 representation of H2's IPv4 
			address (i.e., 64:FF9B::192.0.2.1) through some scheme other than a DNS look-up. 
			This is because the DNS64 processing does NOT
       result in any state installed in the NAT64 and because the mapping
       of the IPv4 address into an IPv6 address is the result of
       concatenating the Well-Known Prefix to the original IPv4
       address.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.3"></a><h3>1.2.3.&nbsp;
Filtering</h3>

<p>NAT64 may do filtering, which means that it only allows a
       packet in through an interface if the appropriate permission exists.
	   The NAT64 can do filtering of IPv6 packets based on the administrative 
	   rules to create entries in the binding and session tables. The filtering can be flexible 
	   enough and broad enough but the idea of the filtering is to provide the 
	   administrators necessary control to avoid DoS attacks that would result in 
	   exhaustion of the NAT64's IPv4 address, port, memory and CPU resources. Filtering techniques of 
	   incoming IPv6 packets are not specific to the NAT64 and therefore is not described in this specification.
</p>
<p>Filtering of IPv4 packets on the other hand is tightly coupled to the NAT64 state and
		therefore is described in this specification. In this document, we consider that the
	       NAT64 may do no filtering, or it may filter incoming IPv4 packets.
</p>
<p>NAT64 filtering of incoming IPv4 packets is consistent with the recommendations of 
	    <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>, and the ones of
		<a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>. Because of that, the NAT64
		as specified in this document, supports both Endpoint-Independent Filtering 
		and Address-Dependent Filtering, both for TCP and UDP.
</p>
<p>If a NAT64 performs Endpoint-Independent Filtering of incoming IPv4 packets,
			then an incoming IPv4 packet is dropped unless the NAT64 has state for the 
			destination transport address of the incoming IPv4 packet.
</p>
<p>
		If a NAT64 performs Address-Dependent Filtering of incoming IPv4 packets, then an incoming IPv4 packet is dropped
		unless the NAT64 has state involving the destination transport address of the IPv4 incoming packet 
		and the particular source IP address of the incoming IPv4 packet.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>This section provides a definitive reference for all the terms used
     in this document. 
</p>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
     "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
     document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<p>The following additional terms are used in this document:
</p>
<p></p>
<blockquote class="text"><dl>
<dt>3-Tuple:</dt>
<dd> The tuple (source IP address, destination
		 IP address, ICMP Identifier). A 3-tuple uniquely identifies an
		 ICMP Query session. When an ICMP Query session flows through
	     a NAT64, each session has two different 3-tuples: one with IPv4
	     addresses and one with IPv6 addresses. 
</dd>
<dt>5-Tuple:</dt>
<dd>The tuple (source IP address, source port,
         destination IP address, destination port, transport protocol). A
         5-tuple uniquely identifies a UDP/TCP session. When a UDP/TCP session flows through
         a NAT64, each session has two different 5-tuples: one with IPv4
         addresses and one with IPv6 addresses. 
</dd>
<dt>BIB:</dt>
<dd>Binding Information Base. A table of mappings kept
         by a NAT64. Each NAT64 has three BIBs, one for TCP, one for
         UDP and one for ICMP Queries.
</dd>
<dt>Endpoint-Independent Mapping:</dt>
<dd>In NAT64, using the same 
		  mapping for all the sessions involving a given IPv6 transport address 
		  of an IPv6 host (irrespectively of the transport address of the IPv4 
		  host involved in the communication). 
	  	  Endpoint-independent Mapping is
         important for peer-to-peer communication. See <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> for the definition of the different types
         of mappings in IPv4-to-IPv4 NATs.
</dd>
<dt>Filtering, Endpoint-Independent:</dt>
<dd> The NAT64 filters out 
		 only incoming IPv4 packets not destined to a transport address for 
		 which there is not state in the NAT64, regardless of the source 
		 IPv4 transport address. The NAT forwards any packets destined to
         any transport address for which it has state.  
		 In other words, having state for a given transport address is sufficient 
		 to allow any packets back to the internal endpoint. See <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> for the definition of the different types
         of filtering in IPv4-to-IPv4 NATs.
</dd>
<dt>Filtering, Address-Dependent:</dt>
<dd>
         The NAT64 filters out incoming IPv4 packets not destined to a transport 
		 address for which there is no state (similar to the Endpoint-Independent 
		 Filtering).  Additionally, the NAT64 will filter out incoming 
		 IPv4 packets coming from a given IPv4 address X and
         destined for a transport address that it has state for if the NAT64 has not
         sent packets to X previously (independently of the port
         used by X).
		 In other words, for receiving packets from a
         specific IPv4 endpoint, it is necessary for the IPv6
         endpoint to send packets first to that specific IPv4
         endpoint's IP address.
</dd>
<dt>Hairpinning:</dt>
<dd>Having a packet do a "U-turn" inside a NAT
         and come back out the same side as it arrived on.
	     If the destination IPv6 address and its embedded IPv4 address 
	     are both assigned to the NAT64 itself, then the packet is 
	     being sent to another IPv6 host connected to the same
	     NAT64.  Such a packet is called a 'hairpin packet'.
         A NAT64 that forwards hairpin packets, back to the IPv6 host are defined as
		 supporting "hairpinning". Hairpinning
         support is important for peer-to-peer applications, as there are
         cases when two different hosts on the same side of a NAT can only
         communicate using sessions that hairpin through the NAT. Hairpin packets packets can be either TCP or UDP. More detailed 
		 explanation of hairpinning and examples for the UDP case can be found in <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.  
</dd>
<dt>Mapping or Binding:</dt>
<dd>A mapping between an IPv6 transport address and a
         IPv4 transport address or a mapping between an (IPv6 address, ICMPv6 Identifier)
 		 pair and an (IPv4 address, ICMPv4 Identifier) pair. Used to translate the addresses and ports/Query Identifiers
         of packets flowing between the IPv6 host and the IPv4 host. 
	      In NAT64, the IPv4 address and port/ICMPv4 Identifier is always
         one assigned to the NAT64 itself, while the IPv6
         address and port/ICMPv6 Identifier belongs to some IPv6 host.
</dd>
<dt>Session:</dt>
<dd>A TCP, UDP or ICMP Query session. In other words, the
         bi-directional flow of packets between two different
         hosts. In NAT64, typically one host is an IPv4 host, and the
         other one is an IPv6 host. However, due to hairpinning, both hosts might be IPv6 hosts.
</dd>
<dt>Session table:</dt>
<dd>A table of sessions kept by a NAT64.
         Each NAT64 has three session tables, one for TCP, one for UDP and one for ICMP Queries.
</dd>
<dt>Stateful NAT64:</dt>
<dd>
		A function that has per-flow state which translates IPv6 packets
		  to IPv4 packets and vice-versa, for TCP, UDP, and ICMP.  The NAT64 uses binding state to 
 		 perform the translation between IPv6 and IPv4 addresses. 
		 In this document we also refer to stateful NAT64 simply as NAT64.
</dd>
<dt>Stateful NAT64 device:</dt>
<dd>
		 The device where the NAT64 function is executed.
		 In this document we also refer to stateful NAT64 device simply as NAT64 device.
</dd>
<dt>Transport Address:</dt>
<dd>The combination of an IPv6 or IPv4
         address and a port. Typically written as (IP address, port)- e.g.
         (192.0.2.15, 8001).
</dd>
<dt>Tuple:</dt>
<dd>Refers to either a 3-Tuple or a 5-tuple as defined above.
</dd>
</dl></blockquote>

<p>For a detailed understanding of this document, the reader should also be
     familiar with 
     NAT terminology <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="normative"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Stateful NAT64 Normative Specification</h3>

<p>A NAT64 is a device with at least one IPv6 interface and at least one IPv4 interface.
       Each NAT64 device MUST have at least one unicast /n IPv6 prefix assigned to it,
       denoted Pref64::/n. Additional considerations about the Pref64::/n are presented in
 		<a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>. A NAT64 MUST have one or more unicast
       IPv4 addresses assigned to it. 
</p>
<p>A NAT64 uses the following conceptual dynamic data structures:</p>
<ul class="text">
<li>UDP Binding Information Base
</li>
<li>UDP Session Table
</li>
<li>TCP Binding Information Base
</li>
<li>TCP Session Table
</li>
<li>ICMP Query Binding Information Base
</li>
<li>ICMP Query Session Table
</li>
</ul>

<p>These tables contain information needed for the NAT64 processing. The actual
			 division of the information into six tables is done in order to ease the 
			description of the NAT64 behaviour. NAT64 implementations are free use different data structures
			but they MUST store all the required information and the externally
		       visible outcome MUST be the same as the one described in this document.
</p>
<p>The notation used is the following: upper case letters are IPv4
		addresses; upper case letters with a prime(') are IPv6 addresses; lower
		case letters are ports; prefixes of length n are indicated by "P::/n", mappings
		       are indicated as "(X,x) &lt;--&gt; (Y',y)".
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Binding Information Bases</h3>

<p>A NAT64 has three Binding Information Bases (BIBs): one for TCP, one for
       UDP and one for ICMP Queries. In the case of UDP and TCP BIBs, each
  	   BIB entry specifies a mapping between an IPv6 transport address
       and an IPv4 transport address:</p>
<blockquote class="text">
<p>(X',x) &lt;--&gt; (T,t)
</p>
</blockquote><p>where X' is some IPv6 address, T is an IPv4 address, and x and t
       are ports. T will always be one of the IPv4 addresses assigned to the NAT64.
	   The BIB has then two columns: the BIB IPv6 transport address and the BIB IPv4 transport address.
       A given IPv6 or IPv4 transport address can appear
       in at most one entry in a BIB: for example, (2001:db8::17, 4) can
       appear in at most one TCP and at most one UDP BIB entry. TCP and UDP
       have separate BIBs because the port number space for TCP and UDP are
       distinct. This implementation of the BIBs ensures Endpoint-Independent Mappings in the NAT64.
		The information in the BIBs is also used to implement Endpoint-Independent Filtering.
		(Address-Dependent Filtering is implemented using the session tables described below.)
</p>
<p>In the case of the ICMP Query BIB, each ICMP Query BIB entry specifies a 
		mapping between an (IPv6 address, ICMPv6 Identifier)
	    pair and an (IPv4 address, ICMPv4 Identifier) pair.
		</p>
<blockquote class="text">
<p>(X',I1) &lt;--&gt; (T,I2)
</p>
</blockquote><p>
	    where X' is some IPv6 address, T is an IPv4 address, I1 is an ICMPv6 Identifier and I2
	    is an ICMPv4 Identifier. T will always be one of the IPv4 addresses assigned to the NAT64.
	    A given (IPv6 or IPv4 address, ICMPv6 or ICMPv4 Identifier) pair can appear
	    in at most one entry in the ICMP Query BIB. 
</p>
<p>Entries in any of the three BIBs can be created dynamically as the result of the
		flow of packets as described in <a class='info' href='#sec-session-info'>Section&nbsp;3.5<span> (</span><span class='info'>Filtering and Updating Binding and Session Information</span><span>)</span></a>
		but they can also be created manually by an administrator. NAT64
		implementations SHOULD support manually configured BIB entries for any of the three BIBs.
		Dynamically-created entries are deleted from the corresponding BIB when the last session 
		associated with the BIB entry is removed from the session table. 
		Manually-configured BIB entries are not deleted when there is no corresponding
		session table entry and can only be deleted by the administrator.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Session Tables</h3>

<p>A NAT64 also has three session tables: one for TCP sessions, one
       for UDP sessions, and one for ICMP Query sessions. Each entry keeps information on the state of the
       corresponding session. 
	   In the TCP and UDP session tables, each entry specifies a mapping between a pair of IPv6 transport addresses
       and a pair of IPv4 transport addresses:</p>
<blockquote class="text">
<p>(X',x),(Y',y) &lt;--&gt; (T,t),(Z,z)
</p>
</blockquote><p>where X' and Y' are IPv6 addresses, T and Z are IPv4 addresses, and x, y, z and t
       are ports. T will always be one of the IPv4 addresses assigned to the NAT64.
	   Y' is always the IPv6 representation of the IPv4 address Z, so Y' is obtained
	   from Z using the algorithm applied by the NAT64 to create IPv6 representations of 
	   IPv4 addresses. y will always be equal to z. 
</p>
<p>For each TCP or UDP Session Table Entry (STE), there are then five columns:
			</p>
<blockquote class="text">
<p>The STE source IPv6 transport address, (X',x) in the example above,
</p>
<p>The STE destination IPv6 transport address,  (Y',y) in the example above,
</p>
<p>The STE source IPv4 transport address,  (T,t) in the example above, and,
</p>
<p>The STE destination IPv4 transport address,  (Z,z) in the example above.
</p>
<p>The STE lifetime.
</p>
</blockquote><p>
			The terminology used for the session table entry columns is from the perspective 
			of an incoming IPv6 packet being translated into an outgoing IPv4 packet.
</p>
<p>In the ICMP query session table, each entry specifies a mapping between a 3-tuple of IPv6 source address,
	   IPv6 destination address and ICMPv6 Identifier and a 3-tuple of IPv4 source address,
		   IPv4 destination address and ICMPv4 Identifier:</p>
<blockquote class="text">
<p>(X',Y',I1) &lt;--&gt; (T,Z,I2)
</p>
</blockquote><p>where X' and Y' are IPv6 addresses, T and Z are IPv4 addresses, I1 is an ICMPv6 Identifier and I2
       is an ICMPv4 Identifier. T will always be one of the IPv4 addresses assigned to the NAT64.
	   Y' is always the IPv6 representation of the IPv4 address Z, so Y' is obtained
	   from Z using the algorithm applied by the NAT64 to create IPv6 representations of 
	   IPv4 addresses.
</p>
<p>For each ICMP Query Session Table Entry (STE), there are then seven columns:
			</p>
<blockquote class="text">
<p>The STE source IPv6 address, X' in the example above,
</p>
<p>The STE destination IPv6 address,  Y' in the example above,
</p>
<p>The STE ICMPv6 Identifier, I1 in the example above,
</p>
<p>The STE source IPv4 address, T in the example above,
</p>
<p>The STE destination IPv4 address, Z in the example above, and,
</p>
<p>The STE ICMPv4 Identifier, I2 in the example above.
</p>
<p>The STE lifetime.
</p>
</blockquote>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Packet Processing Overview</h3>

<p>The NAT64 uses the session state information to determine when the
       session is completed, and also uses session information for Address-Dependent
       Filtering. A session can be uniquely identified by either an incoming
       tuple or an outgoing tuple.
</p>
<p>For each TCP or UDP session, there is a corresponding BIB entry, uniquely
       specified by either the source IPv6 transport address 
       (in the IPv6 --&gt; IPv4 direction) or the destination IPv4 transport address (in the IPv4
       --&gt; IPv6 direction). For each ICMP Query session, there is a corresponding BIB entry, uniquely
       specified by either the source IPv6 address and ICMPv6 Identifier
       (in the IPv6 --&gt; IPv4 direction) or the 
	   destination IPv4 address and the ICMPv4 Identifier (in the IPv4
       --&gt; IPv6 direction). However, for all the BIBs, a single BIB entry can have multiple
       corresponding sessions. When the last corresponding session is
       deleted, if the BIB entry was dynamically created, the BIB entry is deleted.
</p>
<p>The NAT64 will receive packets through its interfaces. These packets can be either IPv6
		packets or IPv4 packets and they may carry TCP traffic, UDP traffic or ICMP traffic. The processing 
		of the packets will be described next. In the case that the processing is common to all the aforementioned
		types of packets, we will refer to the packet as the incoming IP packet in general. In case that the processing
		is specific to IPv6 packets, we will refer to the incoming IPv6 packet and similarly to the IPv4 packets.
</p>
<p> The processing of an incoming 
		IP packet takes the following steps:</p>
<ol class="text">
<li>Determining the incoming tuple
</li>
<li>Filtering and updating binding and session information
</li>
<li>Computing the outgoing tuple
</li>
<li>Translating the packet
</li>
<li>Handling hairpinning
</li>
</ol><p>The details of these steps are specified in the following
       subsections.
</p>
<p>This breakdown of the NAT64 behavior into processing steps is done
       for ease of presentation. A NAT64 MAY perform the steps in a different
       order, or MAY perform different steps, but the externally
       visible outcome MUST be the same as the one described in this document.
</p>
<a name="incoming tuple"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Determining the Incoming tuple</h3>

<p>This step associates an incoming tuple with every incoming IP packet 
			for use in subsequent steps. In the case of TCP, UDP and ICMP error packets, the 
			tuple is a 5-tuple consisting of source IP address,
	         source port, destination IP address, destination port, transport
	         protocol. In case of ICMP Queries, the tuple is a 3-tuple consisting of 
	         the source IP address, destination IP address and ICMP Identifier.
</p>
<p>If the incoming IP packet contains a complete (un-fragmented) UDP
         or TCP protocol packet, then the 5-tuple is computed by extracting
         the appropriate fields from the received packet.
</p>
<p>If the incoming packet is a complete (un-fragmented) ICMP query message (i.e., an ICMPv4 Query message 
			or an ICMPv6 Informational message), the 3-tuple is the source IP address,
			the destination IP address and the ICMP Identifier.
</p>
<p>If the incoming IP packet contains a complete (un-fragmented)
         ICMP error message containing a UDP or a TCP packet, then the 5-tuple is computed by extracting the
         appropriate fields from the IP packet embedded inside the ICMP
         error message. However, the role of source and destination is swapped when
         doing this: the embedded source IP address becomes the destination
         IP address in the 5-tuple, the embedded source port becomes the
         destination port in the 5-tuple, etc. If it is not possible to
         determine the 5-tuple (perhaps because not enough of the embedded
         packet is reproduced inside the ICMP message), then the incoming IP
         packet MUST be silently discarded.
</p>
<p>If the incoming IP packet contains a complete (un-fragmented)
         ICMP error message containing a ICMP error message, then the packet is silently discarded.
</p>
<p>If the incoming IP packet contains a complete (un-fragmented)
         ICMP error message containing an ICMP Query message, then the 3-tuple is computed by extracting the
         appropriate fields from the IP packet embedded inside the ICMP
         error message. However, the role of source and destination is swapped when
         doing this: the embedded source IP address becomes the destination
         IP address in the 3-tuple, the embedded destination  IP address becomes the source 
		 address in the 3-tuple and the embedded ICMP Identifier is used as the ICMP Identifier of the 3-tuple.
         If it is not possible to
         determine the 3-tuple (perhaps because not enough of the embedded
         packet is reproduced inside the ICMP message), then the incoming IP
         packet MUST be silently discarded.
</p>
<p>If the incoming IP packet contains a fragment, then more
         processing may be needed. This specification leaves open the exact
         details of how a NAT64 handles incoming IP packets containing
         fragments, and simply requires that the external behavior of the NAT64
		 is compliant with the following conditions:
			</p>
<blockquote class="text">
<p>The NAT64 MUST handle fragments. In particular, NAT64 MUST handle fragments arriving out-of-order ,
					conditioned on the following:
					</p>
<ul class="text">
<li>The NAT64 MUST limit the amount of resources
							devoted to the storage of fragmented packets
							in order to protect from DoS attacks. 
</li>
<li> As long as the NAT64 has available resources, 
							the NAT64 MUST allow the fragments to arrive 
							over a time interval. The time interval 
							SHOULD be configurable and the default value MUST
							be of at least FRAGMENT_MIN.
</li>
<li> The NAT64 MAY require that the UDP, TCP, or ICMP header be
							completely contained within the fragment that contains 
							OFFSET equal to zero.
</li>
</ul>

<p>For incoming packets carrying TCP or UDP fragments with non-null checksum, 
					NAT64 MAY elect to queue the fragments as
         			they arrive and translate all fragments at the same time. In this case, 
					the incoming tuple is determined as documented above to the un-fragmented packets.
         			Alternatively, a NAT64 MAY translate the fragments as they arrive,
         			by storing information that allows it to compute the 5-tuple for
         			fragments other than the first. In the latter case,  subsequent fragments
 					may arrive before the first and the rules about how the NAT64 handles 
					(out-of-order) fragments described in the bulleted list above apply.
</p>
<p>For incoming IPv4 packets carrying UDP packets with null checksum, 
				if the NAT64 has enough resources, the NAT64 MUST reassemble the
				packets and MUST calculate the checksum.  If the NAT64 does not 
				have enough resources, then it MUST silently discard the packets.
</p>
<p>Implementers of NAT64 should be aware that there are a number of
         			well-known attacks against IP fragmentation; see <a class='info' href='#RFC1858'>[RFC1858]<span> (</span><span class='info'>Ziemba, G., Reed, D., and P. Traina, &ldquo;Security Considerations for IP Fragment Filtering,&rdquo; October&nbsp;1995.</span><span>)</span></a> and <a class='info' href='#RFC3128'>[RFC3128]<span> (</span><span class='info'>Miller, I., &ldquo;Protection Against a Variant of the Tiny Fragment Attack (RFC 1858),&rdquo; June&nbsp;2001.</span><span>)</span></a>.
					Implementers should also be aware of additional issues with 
					reassembling packets at high rates, described in <a class='info' href='#RFC4963'>[RFC4963]<span> (</span><span class='info'>Heffner, J., Mathis, M., and B. Chandler, &ldquo;IPv4 Reassembly Errors at High Data Rates,&rdquo; July&nbsp;2007.</span><span>)</span></a>. 
</p>
</blockquote>

<a name="sec-session-info"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Filtering and Updating Binding and Session Information</h3>

<p>This step updates binding and session information stored in the
         appropriate tables. 
         This step may also filter incoming packets, if desired.
</p>
<p>Irrespective of the transport protocol used, the NAT64 MUST silently discard
			all incoming IPv6 packets containing a source address that contains the Pref64::/n.
			This is required in order to prevent hairpinning loops as described in <a class='info' href='#sec'>Section&nbsp;5<span> (</span><span class='info'>Security Considerations</span><span>)</span></a>. 
			In addition, the NAT64   MUST only process incoming 
			IPv6 packets that contain a destination address that contains Pref64::/n.
			Likewise, the NAT64   MUST only process incoming 
			IPv4 packets that contain a destination address that belong to the IPv4 pool assigned to the NAT64.
</p>
<p>The details of this step depend on the protocol (UDP,
         TCP or ICMP Query).
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1"></a><h3>3.5.1.&nbsp;
UDP Session Handling</h3>

<p>The following state information is stored for a UDP session:
			</p>
<blockquote class="text">
<p>Binding:(X',x),(Y',y) &lt;--&gt; (T,t),(Z,z)
</p>
<p>Lifetime: a timer that
	           tracks the remaining lifetime of the TCP session. When the timer
	           expires, the UDP session is deleted. If all the UDP sessions corresponding to a 
			   dynamically created UDP BIB entry are deleted, then the UDP BIB entry is also deleted.
</p>
</blockquote>

<p>An IPv6 incoming packet with an incoming tuple with source transport address (X',x) and 
			destination transport address (Y',y) is processed as follows:
			</p>
<blockquote class="text">
<p>The NAT64 searches 
				for a UDP BIB entry that contains the BIB IPv6 transport address that matches the IPv6 source transport address (X',x). 
				If such an entry does not exist, the NAT64 tries to create a new entry (if resources and policy permit).
				The source IPv6 transport address of the packet (X',x) is used as BIB IPv6 transport address,  and
				the BIB IPv4 transport address is set to (T,t) which is allocated using the rules defined in <a class='info' href='#UDP transport address alloc'>Section&nbsp;3.5.1.1<span> (</span><span class='info'>Rules for Allocation of IPv4 Transport Addresses for UDP</span><span>)</span></a>. 
				The result is a BIB entry as follows: (X',x) &lt;--&gt; (T,t).
</p>
<p>The NAT64 searches for the session table entry
               corresponding to the incoming 5-tuple. If no such entry is
               found,  the NAT64 tries to create a new entry (if resources and policy permit).
				The information included in the session table is as follows:
				</p>
<ul class="text">
<li>The STE source IPv6 transport address is set to (X',x),  the source IPv6 transport addresses contained in the received IPv6 packet,
</li>
<li>The STE destination IPv6 transport address is set to  (Y',y), the destination IPv6 transport addresses contained in the received IPv6 packet,
</li>
<li>The STE source IPv4 transport address is extracted from the corresponding UDP BIB entry i.e. it is set to (T,t),
</li>
<li>The STE destination IPv4 transport is set to (Z(Y'),y),  y being the same port as
					the STE destination IPv6 transport address and Z(Y') being algorithmically generated from the IPv6 
					destination address (i.e. Y') using the reverse algorithm as specified in  <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</li>
</ul>
					
				The result is a Session table entry as follows: (X',x),(Y',y) &lt;--&gt; (T,t),(Z(Y'),y)

<p>The NAT64 sets (or resets) the timer in the Session Table
               Entry to maximum session lifetime. The maximum session lifetime MAY be configurable and 
			   the default SHOULD be at least UDP_DEFAULT. 
			   The maximum session lifetime MUST NOT be less than UDP_MIN. 
			   The packet is translated and forwarded as described in the following sections.
</p>
</blockquote>

<p>An IPv4 incoming packet, with an incoming tuple with source IPv4 transport address (Y,y) and 
			destination IPv4 transport address (X,x) is processed as follows:
			</p>
<blockquote class="text">
<p>The NAT64 searches 
				for a UDP BIB entry that contains the BIB IPv4 transport address matching (Y,y), 
				(i.e., the IPv4 destination transport address in the incoming IPv4 packet). 
				If such an entry does not exist, the packet MUST be dropped.  An ICMP error message with type
	               of 3 (Destination Unreachable) MAY be sent to the
	               original sender of the packet, unless the discarded packet is
	               itself an ICMP error message. 
</p>
<p>If the NAT64
               applies Address-Dependent Filters on its IPv4 interface, then the NAT64 checks to see if
               the incoming packet is allowed according to the
               Address-Dependent Filtering rule. To do this, it searches for 
				a session table entry with an STE source IPv4 transport address 
				equal to (X,x), (i.e., the destination IPv4 transport address in the incoming packet) 
				 and STE destination IPv4 address 
				equal to Y, (i.e., the source IPv4 address in the incoming packet).
				If such an entry
               is found (there may be more than one), packet processing
               continues. Otherwise, the packet is discarded. If the packet
               is discarded, then an ICMP error message MAY be sent to the
               original sender of the packet, unless the discarded packet is
               itself an ICMP message. The ICMP error message, if sent, has a type
               of 3 (Destination Unreachable) and a code of 13 (Communication
               Administratively Prohibited).
</p>
<p>In case the packet is not discarded in the previous processing (either because the NAT64 
				is not filtering or because the packet is compliant with the Address-Dependent Filtering rule), 
				then the NAT64 searches for the session table entry
                corresponding containing the STE source IPv4 transport address equal 
				to (X,x) and the STE destination IPv4 transport address equal to (Y,y). If no such entry is
               found, the NAT64 tries to create a new entry (if resources and policy permit).
				In case a new UDP session table entry is created, it contains the following information:
				</p>
<ul class="text">
<li>The STE source IPv6 transport address is extracted from the corresponding UDP BIB entry.
</li>
<li>The STE destination IPv6 transport address is set to (Z'(Y),y), y being the same port y than the destination IPv4 
						transport address and Z'(Y) being the 
					IPv6 representation of Y,  generated using the
					algorithm described in <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</li>
<li>The STE source IPv4 transport address is set to  (X,x) the destination IPv4 transport addresses contained in the received IPv4 packet.
</li>
<li>The STE destination IPv4 transport is set to (Y,y),  the source IPv4 transport addresses contained in the received IPv4 packet.
</li>
</ul>

<p>The NAT64 sets (or resets) the timer in the Session Table
               Entry to maximum session lifetime.
			   The maximum session lifetime MAY be configurable and 
			   the default SHOULD be at least UDP_DEFAULT. 
			   The maximum session lifetime MUST NOT be less than UDP_MIN.
			   The packet is translated and forwarded as described in the following sections.
</p>
</blockquote>

<a name="UDP transport address alloc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1.1"></a><h3>3.5.1.1.&nbsp;
Rules for Allocation of IPv4 Transport Addresses for UDP</h3>

<p>When a new UDP BIB entry is created for a source
	         transport address of (S',s), then the NAT64 allocates an IPv4 transport
	         address for this BIB entry as follows:</p>
<blockquote class="text">
<p>If there exists some other BIB entry containing S' as the IPv6
	             address and mapping it to some IPv4 address T, then the NAT64 SHOULD use T as the
	             IPv4 address. Otherwise, use any IPv4 address of the IPv4 pool assigned to the NAT64 to be used for translation.
</p>
<p>If the port s is in the Well-Known port range 0-1023, and the NAT64 has an 
					available port t in the same port range, then the NAT64 SHOULD allocate the port t. 
					If the NAT64 does not have a port available in the same range, 
					the NAT64 MAY assign a port t from other range where it has an available port. 
					(this behavior is recommended in REQ 3-a of <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>)
</p>
<p>If the port s is in the range 1024-65535, and the NAT64 has an 
					available port t in the same port range, then the NAT64 SHOULD allocate the port t. 
					If the NAT64 does not have a port available in the same range, 
					the NAT64 MAY assign a port t from other range where it has an available port. 
					(this behavior is recommended in REQ 3-a of <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>)
</p>
<p>The NAT64 SHOULD preserve the port parity (odd/even), as 
				  per Section 4.2.2 of <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>).
</p>
<p>In all cases, the allocated IPv4 transport address (T,t) MUST
	             NOT be in use in another entry in the same BIB, but MAY be in
	             use in the other BIB (referring to the UDP and TCP BIBs).
</p>
</blockquote><p>If it is not possible to allocate an appropriate IPv4
	         transport address or create a BIB entry, then the
	         packet is discarded. The NAT64 SHOULD send an ICMPv6 Destination Unreachable/Address unreachable (Code 3) message. 
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2"></a><h3>3.5.2.&nbsp;
TCP Session Handling</h3>

<p> In this section we describe how the TCP BIB and Session table are populated. 
			We do so by defining the state machine of the NAT64   uses for TCP.
			We first describe the states and the information contained in them and then
			we describe the actual state machine and state transitions.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2.1"></a><h3>3.5.2.1.&nbsp;
State definition</h3>

<p>The following state information is stored for a TCP session:
			</p>
<blockquote class="text">
<p>Binding:(X',x),(Y',y) &lt;--&gt; (T,t),(Z,z)
</p>
<p>Lifetime: a timer that
	           tracks the remaining lifetime of the TCP session. When the timer
	           expires, the TCP session is deleted. If all the TCP sessions corresponding to a 
			   TCP BIB entry are deleted, then the dynamically created TCP BIB entry is also deleted.
</p>
</blockquote>

<p>TCP sessions are expensive, because their inactivity lifetime is set to at least
				2 hours and 4 min (as per <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>), so it is important that each TCP session table entry 
				corresponds to an existent TCP session. In order to do that, for each TCP session
				established through it, it tracks the corresponding state machine as
				follows.
				
</p>
<p>The states are the following ones:
				</p>
<blockquote class="text">
<p>CLOSED: Analogous to <a class='info' href='#RFC0793'>[RFC0793]<span> (</span><span class='info'>Postel, J., &ldquo;Transmission Control Protocol,&rdquo; September&nbsp;1981.</span><span>)</span></a>, CLOSED is a fictional state
					  because it represents the state when there is no state for this particular 5-tuple, and therefore,
					  no connection.
</p>
<p>V4 SYN RCV: An IPv4 packet containing a TCP SYN was received by the NAT64, implying that a TCP connection is being initiated from the IPv4 side.
						The NAT64 is now waiting for a matching IPv6 packet containing the TCP SYN in the opposite direction.
</p>
<p>V6 SYN RCV: An IPv6 packet containing a TCP SYN was received by the NAT64, implying that a TCP connection is being initiated from the IPv6 side. 
						The NAT64 is now waiting for a matching IPv4 packet containing the TCP SYN in the opposite direction.
</p>
<p>ESTABLISHED: Represents an open connection, with data able to flow in both directions.
</p>
<p>V4 FIN RCV: An IPv4 packet containing a TCP FIN was received by the NAT64, data can still flow in the connection, 
						and the NAT64 is waiting for a matching TCP FIN in the opposite direction.
</p>
<p>V6 FIN RCV: An IPv6 packet containing a TCP FIN was received by the NAT64, data can still flow in the connection, 
							and the NAT64 is waiting for a matching TCP FIN in the opposite direction.
</p>
<p>V6 FIN + V4 FIN RCV: Both an IPv4 packet containing a TCP FIN and an IPv6 packet containing an TCP FIN for
						this connection were received by the NAT64. The NAT64 keeps the connection state alive and forwards packet 
						in both directions for a short period of time to allow remaining packets (in particular the ACKs) to be delivered.
</p>
<p>4MIN: The lifetime of the state for the connection is set to 4 minutes either because a packet containing a TCP RST was received 
						by the NAT64 for this connection or simply because the lifetime of the connection has decreased and there are only 4 minutes left. 
						The NAT64 will keep the state
						for the connection for a short time and if no other data packets for that connection are received,
						the state for this connection is then terminated.
</p>
</blockquote>

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2.2"></a><h3>3.5.2.2.&nbsp;
State machine for TCP processing in the NAT64</h3>

<p>The state machine used by the NAT64 for the TCP session processing is depicted next.
				The described state machine handles all TCP segments received through the IPv6 and IPv4 interface.
				There is one state machine per TCP connection that is potentially established through the NAT64. 
				After bootstrapping of the NAT64 device, all TCP sessions are in CLOSED state. As we mention above, 
				the CLOSED state is a fictional state when is no state for that
				particular connection in the NAT64. It should be noted that there is one state machine per connection, so only
				packets belonging to a given connection are inputs to the state machine associated to that connection. In other words,
				when in the state machine below we state that a packet is received, it is implicit that the incoming 5-tuple of the data packet
				matches to the one of the state machine.
</p>
<p> A TCP segment with the SYN flag set that is received through the IPv6 interface is
					called a V6 SYN, similarly, V4 SYN, V4 FIN, V6 FIN, V6 FIN + V4 FIN, V6 RST and V4 RST.
</p>
<p>
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
                                 +-----------------------------+
                                 |                             |
                                 V                             |
                  V6       +------+      V4                    |
             +----SYN------|CLOSED|-----SYN------+             |
             |             +------+              |             |
             |                ^                  |             |
             |                |4min T.O.         |             |
             V                |                  V             |
         +-------+         +-------+          +-------+        |
         |V6 SYN |         |  4MIN |          |V4 SYN |        |
         |  RCV  |         +-------+          |  RCV  |        |
         +-------+          |    ^            +-------+        |
            |         data pkt   |               |             |
            |               |  V4 or V6 RST      |             |
            |               |  2 hr. T.O.        |             |
         V4 SYN             V    |              V6 SYN         |
            |          +--------------+          |             |
            +---------&gt;| ESTABLISHED  |&lt;---------+             |
                       +--------------+                        |
                         |           |                         |
                     V4 FIN       V6 FIN                       |
                         |           |                         |
                         V           V                         |
                 +---------+       +----------+                |
                 | V4 FIN  |       |  V6 FIN  |                |
                 +---------+       +----------+                |
                         |           |                         |
                     V6 FIN       V4 FIN                     4 min
                         |           |                        T.O.
                         V           V                         |
                    +-------------------+                      |
                    | V4 FIN + V6 FIN   |----------------------+
                    +-------------------+


</pre></div>
<p>
</p>
<p>We next describe the state information and the transitions.
</p>
<p>*** CLOSED ***
</p>
<p>If a V6 SYN is received with an incoming tuple with source transport address (X',x) and 
					destination transport address (Y',y) (this is the case of a TCP connection initiated from the IPv6 side), the processing is as follows:
					</p>
<ol class="text">
<li>The NAT64 searches 
							for a TCP BIB entry that matches the IPv6 source transport address (X',x).
							
<blockquote class="text">
<p>If such an entry does not exist, the NAT64 tries to create a new BIB entry (if resources and policy permit).
								The BIB IPv6 transport address is set to (X',x) (i.e., the source IPv6 transport address of the packet). 
								The BIB IPv4 transport address is set to an IPv4 transport address allocated using the rules defined 
								in <a class='info' href='#TCP transport address alloc'>Section&nbsp;3.5.2.3<span> (</span><span class='info'>Rules for allocation of IPv4 transport addresses for TCP</span><span>)</span></a>
								The processing  of the packet continues as described in bullet 2.
</p>
<p>If the entry already exists, then the processing continues as described in bullet 2.
</p>
</blockquote>
</li>
<li>Then the NAT64 tries to create a new TCP session entry in the TCP session table (if resources and policy permit).
						The information included in the session table is as follows:					
							
<blockquote class="text">
<p> The STE source IPv6 transport address is set to (X',x) (i.e. the source transport address contained in the received V6 SYN packet,
</p>
<p> The STE destination IPv6 transport address is set to (Y',y) (i.e. the destination transport address 
									contained in the received V6 SYN packet.
</p>
<p>The STE source IPv4 transport address is set to the BIB IPv4 transport address of the corresponding TCP BIB entry.
</p>
<p>The STE destination IPv4 transport address contains the port y (i.e., the same port as
								the IPv6 destination transport address) and the IPv4 address that is algorithmically generated from the IPv6 
								destination address (i.e. Y') using the reverse algorithm as specified in  <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</p>
<p>The lifetime of the TCP session table entry is set to at least to TCP_TRANS (the 
								transitory connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>).
</p>
</blockquote>
</li>
<li>The state of the session is moved to V6 SYN RCV.
</li>
<li>The NAT64 translates and forwards the packet as described 
							in the following sections
</li>
</ol>

<p> If a V4 SYN packet is received with an incoming tuple with source IPv4 transport address (Y,y) and 
						destination IPv4 transport address (X,x) (this is the case of a TCP connection initiated from the IPv4 side), the processing is as follows:
					</p>
<blockquote class="text">
<p> If the security policy requires silently dropping externally initiated TCP connections, then 
						the packet is silently discarded, else,
</p>
<p>If the destination transport address contained in the incoming V4 SYN (i.e., X,x) is not in use in the TCP BIB,
					then:
						</p>
<blockquote class="text">
<p>The NAT64 tries to create a new session table entry in the TCP session table (if resources and policy permit), 
								containing the following information:
					 			</p>
<ul class="text">
<li> The STE source IPv4 transport address is set to (X,x) (i.e. the destination transport address contained in the V4 SYN) 
</li>
<li> The STE destination IPv4 transport address is set to (Y,y) (i.e. the source transport address contained in the V4 SYN) 
</li>
<li>	The STE transport IPv6 source address is left unspecified and may be populated by other protocols out of the scope 
										of this specification.
</li>
<li>The STE destination IPv6 
										transport address contains the port y (i.e. the same port than the destination IPv4 transport address) and the 
										IPv6 representation of Y (i.e. the IPv4 address of the destination IPv4 transport address), generated using the
										algorithm described in <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</li>
</ul>

<p>The state is moved to V4 SYN RCV.
</p>
<p>The lifetime of the STE entry is set to TCP_INCOMING_SYN 
								as per <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a> and the packet is stored. The motivation for 
								creating the session table entry and storing the packet (instead of simply dropping the packet based on the filtering) is
								to support simultaneous open of TCP connections.
</p>
</blockquote>

<p>If the destination transport address contained in the incoming V4 SYN (i.e., X,x) is in use in the TCP BIB, then:
						</p>
<blockquote class="text">
<p>The NAT64 tries to create a new session table entry in the TCP session table (if resources and policy permit), 
								containing the following information:
					 			</p>
<ul class="text">
<li> The STE source IPv4 transport address is set to (X,x) (i.e. the destination transport address contained in the V4 SYN) 
</li>
<li> The STE destination IPv4 transport address is set to (Y,y) (i.e. the source transport address contained in the V4 SYN) 
</li>
<li>	The STE transport IPv6 source address is set to the IPv6 transport address contained in the corresponding TCP BIB entry.
</li>
<li>The STE destination IPv6 
										transport address contains the port y (i.e. the same port than the destination IPv4 transport address) and the 
										IPv6 representation of Y (i.e. the IPv4 address of the destination IPv4 transport address), generated using the
										algorithm described in <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</li>
</ul>

<p>The state is moved to V4 SYN RCV.
</p>
<p>If the NAT64 is performing Address-Dependent Filtering, the lifetime of the STE entry is set to TCP_INCOMING_SYN 
								as per <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a> and the packet is stored. The motivation for 
								creating the session table entry and storing the packet (instead of simply dropping the packet based on the filtering) is
								to support simultaneous open of TCP connections.
</p>
<p>If the NAT64 is not performing Address-Dependent Filtering, 	the lifetime of the STE is set to at least to TCP_TRANS (the 
								transitory connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>) and it translates and forwards the packet as described 
								in the following sections. 
</p>
</blockquote>

</blockquote>

<p>For any other packet belonging to this connection: 
					</p>
<blockquote class="text">
<p>If there is a corresponding entry in the TCP BIB
					 other packets SHOULD be translated and forwarded if the security policy allows to do so.
					The state remains unchanged.
</p>
<p>If there is no corresponding entry in the TCP BIB
					the packet is silently discarded.
</p>
</blockquote><p>
				
</p>
<p>*** V4 SYN RCV ***
</p>
<p>If a V6 SYN is received with incoming tuple with source transport address (X',x) and 
					destination transport address (Y',y).
					The lifetime of the TCP session table entry is set to at least to the maximum session lifetime. The value for the maximum 
					session lifetime MAY be configurable but it MUST not be less than TCP_EST (the 
					established connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>). The default value for the maximum session lifetime 
					SHOULD be set to TCP_EST.
					The packet is translated and forwarded. The state is moved to ESTABLISHED.
</p>
<p>If the lifetime expires, an ICMP Port Unreachable error (Type 3, Code 3) containing the IPv4 SYN packet stored is sent back to 
							the source of the v4 SYN, the session table entry is deleted and, the state is moved to CLOSED.
</p>
<p>For any other packet, other packets SHOULD be translated and forwarded if the security policy allows to do so. 
				The state remains unchanged.
</p>
<p>*** V6 SYN RCV ***
</p>
<p>If a V4 SYN is received (with or without the ACK flag set), with an incoming tuple with source IPv4 transport address (Y,y) and 
					destination IPv4 transport address (X,x),  then the state is moved to ESTABLISHED.
					The lifetime of the TCP session table entry is set to at least to the maximum session lifetime. The value for the maximum 
					session lifetime MAY be configurable but it MUST not be less than TCP_EST (the 
					established connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>). The default value for the maximum session lifetime 
					SHOULD be set to TCP_EST.
							The packet is translated and forwarded.
</p>
<p>If the lifetime expires, the session table entry is deleted and the state is moved to CLOSED.
</p>
<p>For any other packet, other packets SHOULD be translated and forwarded if the security policy allows to do so. 
					The state remains unchanged.
</p>
<p>*** ESTABLISHED ***
</p>
<p>If a V4 FIN packet is received, the packet is translated and forwarded. 
				   The state is moved to V4 FIN RCV.
</p>
<p>If a V6 FIN packet is received, the packet is translated and forwarded. 
				   The state is moved to V6 FIN RCV.
</p>
<p>If a V4 RST or a V6 RST packet is received, the packet is translated and forwarded. The lifetime is set to TCP_TRANS and
					the state is moved to 4MIN. (Since the NAT64 is uncertain whether the peer will accept the RST packet, instead of moving the state to
					CLOSED, it moves to 4MIN, which has a shorter lifetime. If no other packets are received for this connection during the 
					short timer, the NAT64 assumes that the peer has accepted the RST packet and moves to CLOSED. If packets keep flowing,
					the NAT64 assumes that the peer has not accepted the RST packet and moves back to the ESTABLISHED state. 
					This is described below in the 4MIN state processing description.)
</p>
<p>If any other packet is received, the packet is translated and forwarded.
					The lifetime of the TCP session table entry is set to at least to the maximum session lifetime. The value for the maximum 
					session lifetime MAY be configurable but it MUST not be less than TCP_EST (the 
					established connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>). The default value for the maximum session lifetime 
					SHOULD be set to TCP_EST.
					The state remains unchanged as ESTABLISHED.
</p>
<p>If the lifetime expires then the NAT64 SHOULD send a probe packet (as defined next) to al least one of the endpoints
					of the TCP connection. The probe packet is a TCP segment for the connection with no data. The sequence number and 
					the acknowledgment number are set to zero. All flags but the ACK flag are reset. 
					</p>
<blockquote class="text">
<p>Upon the reception of this probe packet, the endpoint will reply with an ACK containing the expected sequence number for 
							that connection. It should be noted that, for an active connection, each of these probe packets will generate one packet
							from each end involved in the connection, since the reply of the first point to the probe packet will generate a reply
							from the other endpoint.
</p>
</blockquote><p>
							The state is moved to 4MIN.
</p>
<p>*** V4 FIN RCV ***
</p>
<p>If a V6 FIN packet is received, the packet is translated and forwarded. 
				   The lifetime is set to TCP_TRANS. The state is moved to V6 FIN + V4 FIN RCV.
</p>
<p>If any packet other than the V6 FIN is received, the packet is translated and forwarded.
					The lifetime of the TCP session table entry is set to at least to the maximum session lifetime. The value for the maximum 
					session lifetime MAY be configurable but it MUST not be less than TCP_EST (the 
					established connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>). The default value for the maximum session lifetime 
					SHOULD be set to TCP_EST.
					The state remains unchanged as V4 FIN RCV.
</p>
<p>If the lifetime expires, the session table entry is deleted and the state is moved to CLOSED.
</p>
<p>*** V6 FIN RCV ***
</p>
<p>If a V4 FIN packet is received, the packet is translated and forwarded. 
				   The lifetime is set to TCT_TRANS. The state is moved to V6 FIN + V4 FIN RCV.
</p>
<p>If any packet other than the V4 FIN is received, the packet is translated and forwarded. 
					The lifetime of the TCP session table entry is set to at least to the maximum session lifetime. The value for the maximum 
					session lifetime MAY be configurable but it MUST not be less than TCP_EST (the 
					established connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>). The default value for the maximum session lifetime 
					SHOULD be set to TCP_EST.
					The state remains unchanged as V6 FIN RCV.
</p>
<p>If the lifetime expires, the session table entry is deleted and the state is moved to CLOSED.
</p>
<p>*** V6 FIN + V4 FIN RCV ***
</p>
<p>All packets are translated and forwarded.
</p>
<p>If the lifetime expires, the session table entry is deleted and the state is moved to CLOSED.
</p>
<p>*** 4MIN ***
</p>
<p>If a packet other than a RST packet is received, 
					the lifetime of the TCP session table entry is set to at least to the maximum session lifetime. The value for the maximum 
					session lifetime MAY be configurable but it MUST not be less than TCP_EST (the 
					established connection idle timeout as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>). The default value for the maximum session lifetime 
					SHOULD be set to TCP_EST.
					The state is moved to ESTABLISHED.
</p>
<p>If the lifetime expires, the session table entry is deleted and the state is moved to CLOSED.
</p>
<a name="TCP transport address alloc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2.3"></a><h3>3.5.2.3.&nbsp;
Rules for allocation of IPv4 transport addresses for TCP</h3>

<p>When a new TCP BIB entry is created for a source
	         transport address of (S',s), then the NAT64 allocates an IPv4 transport
	         address for this BIB entry as follows:</p>
<blockquote class="text">
<p>If there exists some other BIB entry containing S' as the IPv6
	             address and mapping it to some IPv4 address T, then use SHOULD T as the
	             IPv4 address. Otherwise, use any IPv4 address of the IPv4 pool assigned to the NAT64 to be used for translation.
</p>
<p>If the port s is in the Well-Known port range 0-1023, and the NAT64 has an 
					available port t in the same port range, then the NAT64 SHOULD allocate the port t. 
					If the NAT64 does not have a port available in the same range, 
					the NAT64 MAY assign a port t from another range where it has an available port. 
</p>
<p>If the port s is in the range 1024-65535, and the NAT64 has an 
					available port t in the same port range, then the NAT64 SHOULD allocate the port t. 
					If the NAT64 does not have a port available in the same range, 
					the NAT64 MAY assign a port t from another range where it has an available port. 
</p>
<p>In all cases, the allocated IPv4 transport address (T,t) MUST
	             NOT be in use in another entry in the same BIB, but MAY be in
	             use in the other BIB (referring to the UDP and TCP BIBs).
</p>
</blockquote><p>If it is not possible to allocate an appropriate IPv4
	         transport address or create a BIB entry, then the
	         packet is discarded. The NAT64 SHOULD send an ICMPv6 Destination Unreachable/Address unreachable (Code 3) message. 
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.3"></a><h3>3.5.3.&nbsp;
ICMP Query Session Handling</h3>

<p>The following state information is stored for an ICMP Query session in the ICMP Query session table:
				</p>
<blockquote class="text">
<p>Binding:(X',Y',I1) &lt;--&gt; (T,Z,I2)
</p>
<p>Lifetime: a timer that
		           tracks the remaining lifetime of the ICMP Query session. When the timer
		           expires, the session is deleted. If all the ICMP Query sessions corresponding to a 
				   dynamically created ICMP Query BIB entry are deleted, then the ICMP Query BIB entry is also deleted.
</p>
</blockquote>

<p>An incoming ICMPv6 Informational packet with IPv6 source address X', IPv6 destination address Y' and ICMPv6 Identifier I1, is processed as follows:
			</p>
<blockquote class="text">
<p>
				If the local security policy determines that ICMPv6 Informative packets are to be filtered, the packet is silently discarded.
				Else, the NAT64 searches 
				for an ICMP Query BIB entry that matches the (X',I1) pair. 
				If such entry does not exist, the NAT64 tries to create a new entry (if resources and policy permit) with the following data:
				</p>
<ul class="text">
<li>The BIB IPv6 address is set to X' (i.e. the source IPv6 address of the IPv6 packet).
</li>
<li>The BIB ICMPv6 Identifier is set to I1 (i.e. the ICMPv6 Identifier).
</li>
<li>If there exists another BIB entry containing the same IPv6
	             		address X' and mapping it to an IPv4 address T, then use T as the
	             		BIB IPv4 address for this new entry. Otherwise, use any IPv4 address assigned to the IPv4
	             		interface.
</li>
<li>As the BIB ICMPv4 Identifier use any available value i.e. any identifier value for which
						no other entry exists with the same (IPv4 address, ICMPv4 Identifier) pair.
</li>
</ul>

<p>The NAT64 searches for an ICMP query session table entry
               corresponding to the incoming 3-tuple (X',Y',I1). If no such entry is
               found, the NAT64 tries to create a new entry (if resources and policy permit).
				The information included in the new session table entry is as follows: 
				</p>
<ul class="text">
<li>The STE IPv6 source address is set to the X' (i.e. the address contained in the received IPv6 packet),
</li>
<li>The STE IPv6 destination address is set to the Y' (i.e. the address contained in the received IPv6 packet),
</li>
<li>The STE ICMPv6 Identifier is set to the I1 (i.e. the identifier contained in the received IPv6 packet),
</li>
<li>The STE IPv4 source address is set to the IPv4 address contained in the corresponding BIB entry,
</li>
<li>The STE ICMPv4 Identifier is set to the IPv4 identifier contained in the corresponding BIB entry,
</li>
<li>The STE IPv4 destination address is algorithmically generated from Y' using the reverse algorithm as
	 					specified in  <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</li>
</ul>

<p>The NAT64 sets (or resets) the timer in the session table
               entry to the maximum session lifetime. By default, the maximum
               session lifetime is ICMP_DEFAULT. The maximum lifetime value SHOULD be configurable.
 			   The packet is translated and forwarded as described in the following sections.
</p>
</blockquote>

<p>An incoming ICMPv4 Query packet with source IPv4 address Y, 
					destination IPv4 address X and ICMPv4 Identifier I2 is processed as follows:
			</p>
<blockquote class="text">
<p>The NAT64 searches 
				for an ICMP Query BIB entry that contains X as IPv4 address and I2 as the ICMPv4 Identifier. 
				If such an entry does not exist, the packet is dropped.  An ICMP error message MAY be sent to the
	               original sender of the packet, unless the discarded packet is
	               itself an ICMP error message. The ICMP error message, if sent, has a type
	               of 3 (Destination Unreachable).
</p>
<p>If the NAT64
               filters on its IPv4 interface, then the NAT64 checks to see if
               the incoming packet is allowed according to the
               Address-Dependent Filtering rule. To do this, it searches for 
			   a session table entry with an STE source IPv4 address equal to X, an STE ICMPv4 Identifier equal to I2 
			   and a STE destination IPv4 address equal to Y. 
				If such an entry
               is found (there may be more than one), packet processing
               continues. Otherwise, the packet is discarded. If the packet
               is discarded, then an ICMP message MAY be sent to the
               original sender of the packet, unless the discarded packet is
               itself an ICMP message. The ICMP message, if sent, has a type
               of 3 (Destination Unreachable) and a code of 13 (Communication
               Administratively Prohibited).
</p>
<p>In case the packet is not discarded in the previous processing steps (either because the NAT64 
				is not filtering or because the packet is compliant with the Address-dependent Filtering rule), 
				then the NAT64 searches for
                a session table entry with an STE source IPv4 address equal to X, an STE ICMPv4 Identifier equal to I2 
				   and a STE destination IPv4 address equal to Y. If no such entry is
                found, the NAT64 tries to create a new entry (if resources and policy permit) with the following information:
				</p>
<ul class="text">
<li>The STE source IPv4 address is set to X,
</li>
<li>The STE ICMPv4 Identifier is set to I2,
</li>
<li>The STE destination IPv4 address is set to Y,
</li>
<li>The STE source IPv6 address is set to the IPv6 address of the corresponding BIB entry,
</li>
<li>The STE ICMPv6 Identifier is set to the ICMPv6 Identifier of the corresponding BIB entry, and,
</li>
<li>The STE destination IPv6 address is set to the 
				IPv6 representation of the IPv4 address of Y, generated using the
				algorithm described in <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</li>
<li>The NAT64 sets (or resets) the timer in the session table
               entry to the maximum session lifetime. By default, the maximum
               session lifetime is ICMP_DEFAULT. The maximum lifetime value SHOULD be configurable.
 			   The packet is translated and forwarded as described in the following sections.
</li>
</ul>

</blockquote>

<a name="address-transform"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.4"></a><h3>3.5.4.&nbsp;
Generation of the IPv6 Representations of IPv4 Addresses</h3>

<p>NAT64 supports multiple algorithms for the generation of the IPv6 representation of an IPv4 address.
							The constraints imposed on the generation algorithms are the following:
							</p>
<blockquote class="text">
<p>The algorithm MUST be reversible, i.e. it MUST be possible to derive the original IPv4 address
									from the IPv6 representation. 
</p>
<p>The input for the algorithm MUST be limited to the IPv4 address, the IPv6 prefix (denoted Pref64::/n) used in the
									IPv6 representations and optionally a set of stable parameters that are 
									configured in the NAT64 (such as fixed string to be used as a suffix).
									</p>
<blockquote class="text">
<p>	If we note n the length of the prefix Pref64::/n, then n MUST the less or equal than 96.
						 				If a Pref64::/n is configured through any means in the NAT64 
										(such as manually configured, or other automatic mean not specified 
										in this document), the default algorithm MUST use this prefix. 
										If no prefix is available, the algorithm SHOULD use the Well-Known Prefix 
										(64:FF9B::/96) defined in 
										<a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>
</p>
</blockquote>

</blockquote>

<p>NAT64 MUST support the algorithm for generating IPv6 representations of IPv4 addresses defined in 
							Section 2.1 of <a class='info' href='#I-D.ietf-behave-address-format'>[I&#8209;D.ietf&#8209;behave&#8209;address&#8209;format]<span> (</span><span class='info'>Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;IPv6 Addressing of IPv4/IPv6 Translators,&rdquo; April&nbsp;2010.</span><span>)</span></a>. The aforementioned algorithm SHOULD be used as default algorithm.
</p>
<a name="outgoing tuple"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;
Computing the Outgoing Tuple</h3>

<p>This step computes the outgoing tuple by translating the
         IP addresses and port numbers or ICMP Identifier in the incoming tuple. 
</p>
<p>In the text below, a reference to a BIB means either the
         TCP BIB the UDP BIB or the ICMP Query BIB as appropriate.
</p>
<p></p>
<blockquote class="text">
<p>NOTE: Not all addresses are translated using the BIB. BIB
             entries are used to translate IPv6 source transport addresses to
             IPv4 source transport addresses, and IPv4 destination transport
             addresses to IPv6 destination transport addresses. They are NOT
             used to translate IPv6 destination transport addresses to IPv4
             destination transport addresses, nor to translate IPv4 source
             transport addresses to IPv6 source transport addresses. The latter
             cases are handled applying the algorithmic transformation described 
			 in <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>. This
             distinction is important; without it, hairpinning doesn't work
             correctly.
</p>
</blockquote>

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6.1"></a><h3>3.6.1.&nbsp;
Computing the Outgoing 5-tuple for TCP and UDP</h3>

<p>The transport protocol
         in the outgoing 5-tuple is always the same as that in the incoming
         5-tuple.
</p>
<p>When translating in the IPv6 --&gt; IPv4 direction, let the incoming
         source and destination transport addresses in the 5-tuple be (S',s)
         and (D',d) respectively. The outgoing source transport address is
         computed as follows: if the BIB contains a entry (S',s) &lt;--&gt; (T,t), then the
             outgoing source transport address is (T,t).
</p>
<p>The outgoing destination address is computed
	         algorithmically from D' using the address transformation described in 
			 <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</p>
<p>When translating in the IPv4 --&gt; IPv6 direction, let the incoming
	         source and destination transport addresses in the 5-tuple be (S,s)
	         and (D,d) respectively. The outgoing source transport address is
	         computed as follows: </p>
<blockquote class="text">
<p>The outgoing source transport address is generated from S using the address transformation algorithm described in
				<a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</p>
<p>The BIB table is searched for an entry  (X',x) &lt;--&gt; (D,d), and if one is found, the outgoing destination transport address is set to (X',x).
</p>
</blockquote>

<a name="outgoing 3-tuple"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6.2"></a><h3>3.6.2.&nbsp;
Computing the Outgoing 3-tuple for ICMP Query Messages</h3>

<p>When translating in the IPv6 --&gt; IPv4 direction, let the incoming
         source and destination addresses in the 3-tuple be S'
         and D' respectively and the ICMPv6 Identifier be I1. The outgoing source address is
         computed as follows: the BIB contains an entry (S',I1) &lt;--&gt; (T,I2), then the
             outgoing source address is T and the ICMPv4 Identifier is I2.
</p>
<p>The outgoing IPv4 destination address is computed
         algorithmically from D' using the address transformation described in 
		 <a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
</p>
<p>When translating in the IPv4 --&gt; IPv6 direction, let the incoming
         source and destination addresses in the 3-tuple be S
         and D respectively and the ICMPv4 Identifier is I2. The outgoing source address is
         generated from S using the address transformation algorithm described in
		<a class='info' href='#address-transform'>Section&nbsp;3.5.4<span> (</span><span class='info'>Generation of the IPv6 Representations of IPv4 Addresses</span><span>)</span></a>.
           The BIB is searched for an entry containing (X',I1) &lt;--&gt; (D,I2) and if found
             the outgoing destination address is X' and the outgoing ICMPv6 Identifier is I1.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;
Translating the Packet</h3>

<p>This step translates the packet from IPv6 to IPv4 or vice-versa.
</p>
<p>The translation of the packet is as specified in Section 3 and
         Section 4 of the <a class='info' href='#I-D.ietf-behave-v6v4-xlate'>IP/ICMP Translation Algorithm<span> (</span><span class='info'>Li, X., Bao, C., and F. Baker, &ldquo;IP/ICMP Translation Algorithm,&rdquo; April&nbsp;2010.</span><span>)</span></a> [I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate], with the following
         modifications:</p>
<ul class="text">
<li>When translating an IP header (Sections 3.1 and 4.1), the
             source and destination IP address fields are set to the source
             and destination IP addresses from the outgoing tuple as determined in  <a class='info' href='#outgoing tuple'>Section&nbsp;3.6<span> (</span><span class='info'>Computing the Outgoing Tuple</span><span>)</span></a>.
</li>
<li>When the protocol following the IP header is TCP or UDP, then
             the source and destination ports are modified to the source and
             destination ports from the outgoing 5-tuple. In addition, the TCP or UDP
             checksum must also be updated to reflect the translated
             addresses and ports; note that the TCP and UDP checksum covers
             the pseudo-header which contains the source and destination IP
             addresses. An algorithm for efficiently updating these checksums
             is described in <a class='info' href='#RFC3022'>[RFC3022]<span> (</span><span class='info'>Srisuresh, P. and K. Egevang, &ldquo;Traditional IP Network Address Translator (Traditional NAT),&rdquo; January&nbsp;2001.</span><span>)</span></a>.
</li>
<li>When the protocol following the IP header is ICMP and it is an ICMP Query message, 
				the ICMP Identifier is set to the one from the outgoing 3-tuple as determined in  <a class='info' href='#outgoing 3-tuple'>Section&nbsp;3.6.2<span> (</span><span class='info'>Computing the Outgoing 3-tuple for ICMP Query Messages</span><span>)</span></a>.
</li>
<li>When the protocol following the IP header is ICMP (Sections
             3.4 and 4.4) and it is an ICMP error message, 
			  the source and destination transport addresses in
             the embedded packet are set to the destination and source
             transport addresses from the outgoing 5-tuple (note the swap of
             source and destination).
</li>
</ul>

<p>The size of outgoing packets as well and the potential need for fragmentation
			is done according to the behavior defined in the <a class='info' href='#I-D.ietf-behave-v6v4-xlate'>IP/ICMP Translation Algorithm<span> (</span><span class='info'>Li, X., Bao, C., and F. Baker, &ldquo;IP/ICMP Translation Algorithm,&rdquo; April&nbsp;2010.</span><span>)</span></a> [I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;xlate]
		
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.8"></a><h3>3.8.&nbsp;
Handling Hairpinning</h3>

<p>If the destination IP address is an IPv4 address assigned to the NAT64
         itself  then the packet is a hairpin packet. 
 		 Hairpin packets are processed as follows:
		 </p>
<ul class="text">
<li> The outgoing 5-tuple becomes the incoming 5-tuple, and, 
</li>
<li> the packet is treated as if it was received on the outgoing interface.
</li>
<li> Processing of the packet continues at step 2 - Filtering and updating binding and 
		 session information described in <a class='info' href='#sec-session-info'>Section&nbsp;3.5<span> (</span><span class='info'>Filtering and Updating Binding and Session Information</span><span>)</span></a>.
</li>
</ul>

<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Protocol Constants</h3>

<p>UDP_MIN 2 minutes (as defined in <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>) 
</p>
<p>UDP_DEFAULT 5 minutes (as defined in <a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>)
</p>
<p>TCP_TRANS 4 minutes (as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>)
</p>
<p>TCP_EST 2 hours (the minimum lifetime for an established TCP session defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a> 
	is 2 hrs and 4 minutes, which is achieved adding the 2 hours with this timer and the 4 minutes with the TCP_TRANS timer)
</p>
<p>TCP_INCOMING_SYN 6 seconds (as defined in <a class='info' href='#RFC5382'>[RFC5382]<span> (</span><span class='info'>Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;NAT Behavioral Requirements for TCP,&rdquo; October&nbsp;2008.</span><span>)</span></a>)
</p>
<p>FRAGMENT_MIN 2 seconds
</p>
<p>ICMP_DEFAULT 60 seconds (as defined in <a class='info' href='#RFC5508'>[RFC5508]<span> (</span><span class='info'>Srisuresh, P., Ford, B., Sivakumar, S., and S. Guha, &ldquo;NAT Behavioral Requirements for ICMP,&rdquo; April&nbsp;2009.</span><span>)</span></a>)
</p>
<a name="sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Security Considerations</h3>

<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Implications on end-to-end security</h3>

<p>Any protocols that protect IP header information is essentially incompatible
	with NAT64. This implies that end-to-end IPsec verification will fail when 
	AH is used (both transport and tunnel mode) and when ESP is used in transport mode. 
	This is inherent in any network-layer translation mechanism. End-to-end IPsec protection
	can be restored, using UDP encapsulation as described in <a class='info' href='#RFC3948'>[RFC3948]<span> (</span><span class='info'>Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;UDP Encapsulation of IPsec ESP Packets,&rdquo; January&nbsp;2005.</span><span>)</span></a>.
	The actual extensions to support IPsec are out of the scope of this document.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Filtering</h3>

<p>NAT64 creates binding state using packets flowing from the IPv6 side
   to the IPv4 side.  In accordance with the procedures defined in this
	document following the guidelines defined in  
	<a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a> a NAT64 must offer
   "Endpoint-Independent Filtering". This means:
	</p>
<blockquote class="text">
<p> for any IPv6 packet with source (S'1,s1) and destination
   (Pref64::D1,d1) that creates an external mapping to (S1,s1), (D1,d1),
</p>
<p> for any subsequent external connection from S'1 to (D2,d2)
     within a given binding timer window,
</p>
<p> (S1,s1) = (S2,s2) for all values of D2,d2
</p>
</blockquote>

<p>Implementations may also provide support for "Address-Dependent
  Mapping" as also defined 
	in this document and following the guidelines defined in 
	<a class='info' href='#RFC4787'>[RFC4787]<span> (</span><span class='info'>Audet, F. and C. Jennings, &ldquo;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP,&rdquo; January&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The security
  properties however are determined by which packets the NAT64 filter
  allows in and which it does not. The security properties are
  determined by the filtering behavior and filtering configuration
  in the filtering portions of the NAT64, not by the address mapping
  behavior. For example,
	</p>
<blockquote class="text">
<p> Without filtering - When "Endpoint-Independent
  Filtering" is used in NAT64, once a binding is created in the
  IPv6 ---> IPv4 direction, packets from any node on the IPv4 side
  destined to the IPv6 transport address will traverse the
  NAT64 gateway and be forwarded to the IPv6 transport address
  that created the binding. However,
</p>
<p>  With filtering - When "Endpoint-Independent
  Filtering" is used in NAT64, once a binding is created in the
  IPv6 ---> IPv4 direction, packets from any node on the IPv4 side
  destined to the IPv6 transport address will first be processed
  against the filtering rules. If the source IPv4 address is
  permitted, the packets will be forwarded to the IPv6 transport
  address. If the source IPv4 address is explicitly denied -- or the
  default policy is to deny all addresses not explicitly permitted
  -- then the packet will be discarded. A dynamic filter may be
  employed where by the filter will only allow packets from the
  IPv4 address to which the original packet that created the binding
  was sent. This means that only the IPv4 addresses to which the
  IPv6 host has initiated connections will be able to reach the IPv6
  transport address, and no others. This essentially narrows the
  effective operation of the NAT64 device to an
  "Address-Dependent Filtering" behavior, though not by its
  mapping behavior, but instead by its filtering behavior.
</p>
</blockquote>

<p>	As currently specified, the NAT64 only requires
	filtering traffic based on the 5-tuple.  In some cases (e.g., statically
	configured mappings), this may make it easy for an attacker to guess.  
	An attacker need not be able to guess other fields, e.g. the TCP sequence
	number, to get a packet through the NAT64.  While such traffic might be
	dropped by the final destination, it does not provide additional
	mitigations against bandwidth/CPU attacks targeting the internal network.
	To avoid these type of abuse, some NAT64 MAY keep track the sequence number 
	of TCP packets in order to verify that proper sequencing of exchanged segments, 
	in particular, the SYNs and the FINs.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Attacks on NAT64</h3>

<p>The NAT64 device itself is a potential victim of different types of
	   attacks.  In particular, the NAT64 can be a victim of DoS attacks.
	   The NAT64 device has a limited number of resources that can be consumed
	   by attackers creating a DoS attack.  The NAT64 has a limited number
	   of IPv4 addresses that it uses to create the bindings.  Even though the
	   NAT64 performs address and port translation, it is possible for an
	   attacker to consume all the IPv4 transport addresses by sending IPv6
	   packets with different source IPv6 transport addresses.  This attack 
	   can only be launched from the IPv6 side, since
	   IPv4 packets are not used to create binding state.  DoS attacks can
	   also affect other limited resources available in the NAT64 such as
	   memory or link capacity. For instance, it is possible for an attacker 
	   to launch a DoS attack on the memory of the NAT64 device by sending
	   fragments that the NAT64 will store for a given period.  If the
	   number of fragments is high enough, the memory of the NAT64 could be
	   exhausted.  NAT64 devices MUST implement proper protection against
	   such attacks, for instance allocating a limited amount of memory for
	   fragmented packet storage as specified in <a class='info' href='#incoming tuple'>Section&nbsp;3.4<span> (</span><span class='info'>Determining the Incoming tuple</span><span>)</span></a>.
	
</p>
<p>Another consideration related to NAT64 resource depletion refers to the 
		preservation of binding state. Attackers may try to keep a binding state
		alive forever by sending periodic packets that refresh the state. In
		order to allow the NAT64 to defend against such attacks, the NAT64 MAY
		choose not to extend the session entry lifetime for a specific entry upon the reception 
		of packets for that entry through the external interface. As described in the
		Framework document  <a class='info' href='#I-D.ietf-behave-v6v4-framework'>[I&#8209;D.ietf&#8209;behave&#8209;v6v4&#8209;framework]<span> (</span><span class='info'>Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;Framework for IPv4/IPv6 Translation,&rdquo; March&nbsp;2010.</span><span>)</span></a>, the NAT64
		can be deployed in multiple scenarios, some of which the external side is the IPv6 one
		and some of which the external side is the IPv4 one. It is then important to properly
		set which is the external side of the NAT64 in each specific configuration.
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Avoiding hairpinning loops</h3>

<p>If an IPv6-only client can guess the IPv4 binding address that will be
	created, it can use the IPv6 representation of it as source address for
	creating this binding. Then any packet sent to the binding's IPv4
	address could loop in the NAT64. This is prevented in the current specification 
	by filtering incoming packets containing Pref64::/n in the source address as described next.
</p>
<p>Consider the following example:
</p>
<p>Suppose that the IPv4 pool is 192.0.2.0/24
</p>
<p>Then the IPv6-only client sends this to NAT64:
		</p>
<blockquote class="text">
<p>Source: [Pref64::192.0.2.1]:500
</p>
<p>Destination: whatever
</p>
</blockquote>

<p>The NAT64 allocates 192.0.2.1:500 as IPv4 binding address.
		Now anything sent to 192.0.2.1:500, be it a hairpinned IPv6 packet or an
		IPv4 packet, could loop.
</p>
<p>It is not hard to guess the IPv4 address that will be allocated.
		First the attacker creates a binding and use e.g.
	STUN to learn its external IPv4 address. New bindings will always have this
	address. Then it uses a source port in the range 1-1023. This will
	increase the chances to 1/512 (since range and parity must be
	preserved in UDP). 
</p>
<p>In order to address this vulnerability, the NAT64 MUST drop IPv6 
		packets whose source address is in Pref64::/n as defined in <a class='info' href='#sec-session-info'>Section&nbsp;3.5<span> (</span><span class='info'>Filtering and Updating Binding and Session Information</span><span>)</span></a>. 
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>This document contains no actions for IANA.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Contributors</h3>

<p>George Tsirtsis
</p>
<blockquote class="text">
<p>Qualcomm
</p>
<p>tsirtsis@googlemail.com
</p>
</blockquote>
<p>Greg Lebovitz
</p>
<blockquote class="text">
<p>Juniper
</p>
<p>gregory.ietf@gmail.com
</p>
</blockquote>
<p>Simon Parreault
</p>
<blockquote class="text">
<p>Viagenie
</p>
<p>simon.perreault@viagenie.ca
</p>
</blockquote>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Acknowledgements</h3>

<p>Dave Thaler, Dan Wing, Alberto Garcia-Martinez, Reinaldo Penno, Ranjana Rao, 
		Lars Eggert, Senthil Sivakumar, Zhen Cao, Xiangsong Cui, Mohamed Boucadair, 
		Dong Zhang, Bryan Ford and Joao Damas reviewed the document and 
		provided useful comments to improve it.
</p>
<p>The content of the draft was improved thanks to discussions with Christian Huitema, Fred Baker and Jari Arkko.
</p>
<p>Marcelo Bagnulo and Iljitsch van Beijnum are partly funded by Trilogy, 
	a research project supported by the European Commission under its Seventh 
	Framework Program.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1035">[RFC1035]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1035, November&nbsp;1987 (<a href="http://www.rfc-editor.org/rfc/rfc1035.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4787">[RFC4787]</a></td>
<td class="author-text">Audet, F. and C. Jennings, &ldquo;<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>,&rdquo; BCP&nbsp;127, RFC&nbsp;4787, January&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4787.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5382">[RFC5382]</a></td>
<td class="author-text">Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &ldquo;<a href="http://tools.ietf.org/html/rfc5382">NAT Behavioral Requirements for TCP</a>,&rdquo; BCP&nbsp;142, RFC&nbsp;5382, October&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5382.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5508">[RFC5508]</a></td>
<td class="author-text">Srisuresh, P., Ford, B., Sivakumar, S., and S. Guha, &ldquo;<a href="http://tools.ietf.org/html/rfc5508">NAT Behavioral Requirements for ICMP</a>,&rdquo; BCP&nbsp;148, RFC&nbsp;5508, April&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5508.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-v6v4-xlate">[I-D.ietf-behave-v6v4-xlate]</a></td>
<td class="author-text">Li, X., Bao, C., and F. Baker, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-xlate-19.txt">IP/ICMP Translation Algorithm</a>,&rdquo; draft-ietf-behave-v6v4-xlate-19 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-xlate-19.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-address-format">[I-D.ietf-behave-address-format]</a></td>
<td class="author-text">Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-address-format-07.txt">IPv6 Addressing of IPv4/IPv6 Translators</a>,&rdquo; draft-ietf-behave-address-format-07 (work in progress), April&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-address-format-07.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-dns64">[I-D.ietf-behave-dns64]</a></td>
<td class="author-text">Bagnulo, M., Sullivan, A., Matthews, P., and I. Beijnum, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-dns64-09.txt">DNS64: DNS extensions for Network Address Translation from IPv6 Clients to IPv4 Servers</a>,&rdquo; draft-ietf-behave-dns64-09 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-dns64-09.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0793">[RFC0793]</a></td>
<td class="author-text">Postel, J., &ldquo;<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>,&rdquo; STD&nbsp;7, RFC&nbsp;793, September&nbsp;1981 (<a href="http://www.rfc-editor.org/rfc/rfc793.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2766">[RFC2766]</a></td>
<td class="author-text"><a href="mailto:george.tsirtsis@bt.com">Tsirtsis, G.</a> and <a href="mailto:srisuresh@yahoo.com">P. Srisuresh</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2766">Network Address Translation - Protocol Translation (NAT-PT)</a>,&rdquo; RFC&nbsp;2766, February&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2766.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1858">[RFC1858]</a></td>
<td class="author-text"><a href="mailto:paul@alantec.com">Ziemba, G.</a>, <a href="mailto:darrenr@cyber.com.au">Reed, D.</a>, and <a href="mailto:pst@cisco.com">P. Traina</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1858">Security Considerations for IP Fragment Filtering</a>,&rdquo; RFC&nbsp;1858, October&nbsp;1995 (<a href="http://www.rfc-editor.org/rfc/rfc1858.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3128">[RFC3128]</a></td>
<td class="author-text">Miller, I., &ldquo;<a href="http://tools.ietf.org/html/rfc3128">Protection Against a Variant of the Tiny Fragment Attack (RFC 1858)</a>,&rdquo; RFC&nbsp;3128, June&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3128.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3022">[RFC3022]</a></td>
<td class="author-text">Srisuresh, P. and K. Egevang, &ldquo;<a href="http://tools.ietf.org/html/rfc3022">Traditional IP Network Address Translator (Traditional NAT)</a>,&rdquo; RFC&nbsp;3022, January&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3022.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4966">[RFC4966]</a></td>
<td class="author-text">Aoun, C. and E. Davies, &ldquo;<a href="http://tools.ietf.org/html/rfc4966">Reasons to Move the Network Address Translator - Protocol Translator (NAT-PT) to Historic Status</a>,&rdquo; RFC&nbsp;4966, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4966.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-ice">[I-D.ietf-mmusic-ice]</a></td>
<td class="author-text">Rosenberg, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>,&rdquo; draft-ietf-mmusic-ice-19 (work in progress), October&nbsp;2007 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-19.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4963">[RFC4963]</a></td>
<td class="author-text">Heffner, J., Mathis, M., and B. Chandler, &ldquo;<a href="http://tools.ietf.org/html/rfc4963">IPv4 Reassembly Errors at High Data Rates</a>,&rdquo; RFC&nbsp;4963, July&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4963.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-behave-v6v4-framework">[I-D.ietf-behave-v6v4-framework]</a></td>
<td class="author-text">Baker, F., Li, X., Bao, C., and K. Yin, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-framework-08.txt">Framework for IPv4/IPv6 Translation</a>,&rdquo; draft-ietf-behave-v6v4-framework-08 (work in progress), March&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-behave-v6v4-framework-08.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.penno-behave-64-analysis">[I-D.penno-behave-64-analysis]</a></td>
<td class="author-text">Penno, R., Saxena, T., and D. Wing, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-penno-behave-64-analysis-03.txt">Analysis of 64 Translation</a>,&rdquo; draft-penno-behave-64-analysis-03 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-penno-behave-64-analysis-03.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3948">[RFC3948]</a></td>
<td class="author-text">Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &ldquo;<a href="http://tools.ietf.org/html/rfc3948">UDP Encapsulation of IPsec ESP Packets</a>,&rdquo; RFC&nbsp;3948, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3948.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Marcelo Bagnulo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UC3M</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Av. Universidad 30</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Leganes, Madrid  28911</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Spain</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+34-91-6249500</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:marcelo@it.uc3m.es">marcelo@it.uc3m.es</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.it.uc3m.es/marcelo">http://www.it.uc3m.es/marcelo</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Philip Matthews</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alcatel-Lucent</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">600 March Road</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ottawa, Ontario  </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Canada</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 613-592-4343 x224</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:philip_matthews@magma.ca">philip_matthews@magma.ca</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href=""></a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Iljitsch van Beijnum</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">IMDEA Networks</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Avda. del Mar Mediterraneo, 22</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Leganes, Madrid  28918</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Spain</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:iljitsch@muada.com">iljitsch@muada.com</a></td></tr>
</table>
</body></html>
