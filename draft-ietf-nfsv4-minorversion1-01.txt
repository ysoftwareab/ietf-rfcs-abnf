


NFSv4                                                         S. Shepler
Internet-Draft                                                    Editor
Expires: June 15, 2006                                 December 12, 2005


                         NFSv4 Minor Version 1
                 draft-ietf-nfsv4-minorversion1-01.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on June 15, 2006.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   This Internet-Draft describes the NFSv4 minor version 1 protocol
   extensions.  These most significant of these extensions are commonly
   called: Sessions, Directory Delegations, and parallel NFS or pNFS

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].



Shepler                   Expires June 15, 2006                 [Page 1]

Internet-Draft           NFSv4 Minior Version 1            December 2005


Table of Contents

   1.   Security Negotiation . . . . . . . . . . . . . . . . . . . .   6
   2.   Clarification of Security Negotiation in NFSv4.1 . . . . . .   6
     2.1  PUTFH + LOOKUP . . . . . . . . . . . . . . . . . . . . . .   6
     2.2  PUTFH + LOOKUPP  . . . . . . . . . . . . . . . . . . . . .   7
     2.3  PUTFH + SECINFO  . . . . . . . . . . . . . . . . . . . . .   7
     2.4  PUTFH + Anything Else  . . . . . . . . . . . . . . . . . .   7
   3.   NFSv4.1 Sessions . . . . . . . . . . . . . . . . . . . . . .   8
     3.1  Sessions Background  . . . . . . . . . . . . . . . . . . .   8
       3.1.1  Introduction to Sessions . . . . . . . . . . . . . . .   8
       3.1.2  Motivation . . . . . . . . . . . . . . . . . . . . . .   9
       3.1.3  Problem Statement  . . . . . . . . . . . . . . . . . .  10
       3.1.4  NFSv4 Session Extension Characteristics  . . . . . . .  11
     3.2  Transport Issues . . . . . . . . . . . . . . . . . . . . .  12
       3.2.1  Session Model  . . . . . . . . . . . . . . . . . . . .  12
       3.2.2  Connection State . . . . . . . . . . . . . . . . . . .  13
       3.2.3  NFSv4 Channels, Sessions and Connections . . . . . . .  14
       3.2.4  Reconnection, Trunking and Failover  . . . . . . . . .  16
       3.2.5  Server Duplicate Request Cache . . . . . . . . . . . .  17
     3.3  Session Initialization and Transfer Models . . . . . . . .  18
       3.3.1  Session Negotiation  . . . . . . . . . . . . . . . . .  18
       3.3.2  RDMA Requirements  . . . . . . . . . . . . . . . . . .  19
       3.3.3  RDMA Connection Resources  . . . . . . . . . . . . . .  20
       3.3.4  TCP and RDMA Inline Transfer Model . . . . . . . . . .  21
       3.3.5  RDMA Direct Transfer Model . . . . . . . . . . . . . .  23
     3.4  Connection Models  . . . . . . . . . . . . . . . . . . . .  26
       3.4.1  TCP Connection Model . . . . . . . . . . . . . . . . .  27
       3.4.2  Negotiated RDMA Connection Model . . . . . . . . . . .  28
       3.4.3  Automatic RDMA Connection Model  . . . . . . . . . . .  29
     3.5  Buffer Management, Transfer, Flow Control  . . . . . . . .  29
     3.6  Retry and Replay . . . . . . . . . . . . . . . . . . . . .  32
     3.7  The Back Channel . . . . . . . . . . . . . . . . . . . . .  33
     3.8  COMPOUND Sizing Issues . . . . . . . . . . . . . . . . . .  34
     3.9  Data Alignment . . . . . . . . . . . . . . . . . . . . . .  34
     3.10   NFSv4 Integration  . . . . . . . . . . . . . . . . . . .  36
       3.10.1   Minor Versioning . . . . . . . . . . . . . . . . . .  36
       3.10.2   Slot Identifiers and Server Duplicate Request
                Cache  . . . . . . . . . . . . . . . . . . . . . . .  36
       3.10.3   COMPOUND and CB_COMPOUND . . . . . . . . . . . . . .  40
       3.10.4   eXternal Data Representation Efficiency  . . . . . .  41
       3.10.5   Effect of Sessions on Existing Operations  . . . . .  41
       3.10.6   Authentication Efficiencies  . . . . . . . . . . . .  42
     3.11   Sessions Security Considerations . . . . . . . . . . . .  43
       3.11.1   Authentication . . . . . . . . . . . . . . . . . . .  44
   4.   Directory Delegations  . . . . . . . . . . . . . . . . . . .  45
     4.1  Introduction to Directory Delegations  . . . . . . . . . .  45
     4.2  Directory Delegation Design (in brief) . . . . . . . . . .  47



Shepler                   Expires June 15, 2006                 [Page 2]

Internet-Draft           NFSv4 Minior Version 1            December 2005


     4.3  Recommended Attributes in support of Directory
          Delegations  . . . . . . . . . . . . . . . . . . . . . . .  48
     4.4  Delegation Recall  . . . . . . . . . . . . . . . . . . . .  48
     4.5  Delegation Recovery  . . . . . . . . . . . . . . . . . . .  49
   5.   Introduction . . . . . . . . . . . . . . . . . . . . . . . .  49
   6.   General Definitions  . . . . . . . . . . . . . . . . . . . .  51
     6.1  Metadata Server  . . . . . . . . . . . . . . . . . . . . .  52
     6.2  Client . . . . . . . . . . . . . . . . . . . . . . . . . .  52
     6.3  Storage Device . . . . . . . . . . . . . . . . . . . . . .  52
     6.4  Storage Protocol . . . . . . . . . . . . . . . . . . . . .  52
     6.5  Control Protocol . . . . . . . . . . . . . . . . . . . . .  53
     6.6  Metadata . . . . . . . . . . . . . . . . . . . . . . . . .  53
     6.7  Layout . . . . . . . . . . . . . . . . . . . . . . . . . .  53
   7.   pNFS protocol semantics  . . . . . . . . . . . . . . . . . .  53
     7.1  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  54
       7.1.1  Layout Types . . . . . . . . . . . . . . . . . . . . .  54
       7.1.2  Layout Iomode  . . . . . . . . . . . . . . . . . . . .  54
       7.1.3  Layout Segments  . . . . . . . . . . . . . . . . . . .  55
       7.1.4  Device IDs . . . . . . . . . . . . . . . . . . . . . .  56
       7.1.5  Aggregation Schemes  . . . . . . . . . . . . . . . . .  56
     7.2  Guarantees Provided by Layouts . . . . . . . . . . . . . .  56
     7.3  Getting a Layout . . . . . . . . . . . . . . . . . . . . .  58
     7.4  Committing a Layout  . . . . . . . . . . . . . . . . . . .  58
       7.4.1  LAYOUTCOMMIT and mtime/atime/change  . . . . . . . . .  59
       7.4.2  LAYOUTCOMMIT and size  . . . . . . . . . . . . . . . .  60
       7.4.3  LAYOUTCOMMIT and layoutupdate  . . . . . . . . . . . .  61
     7.5  Recalling a Layout . . . . . . . . . . . . . . . . . . . .  61
       7.5.1  Basic Operation  . . . . . . . . . . . . . . . . . . .  61
       7.5.2  Recall Callback Robustness . . . . . . . . . . . . . .  62
       7.5.3  Recall/Return Sequencing . . . . . . . . . . . . . . .  63
     7.6  Metadata Server Write Propagation  . . . . . . . . . . . .  65
     7.7  Crash Recovery . . . . . . . . . . . . . . . . . . . . . .  66
       7.7.1  Leases . . . . . . . . . . . . . . . . . . . . . . . .  66
       7.7.2  Client Recovery  . . . . . . . . . . . . . . . . . . .  67
       7.7.3  Metadata Server Recovery . . . . . . . . . . . . . . .  68
       7.7.4  Storage Device Recovery  . . . . . . . . . . . . . . .  70
   8.   Security Considerations  . . . . . . . . . . . . . . . . . .  71
     8.1  File Layout Security . . . . . . . . . . . . . . . . . . .  72
     8.2  Object Layout Security . . . . . . . . . . . . . . . . . .  72
     8.3  Block/Volume Layout Security . . . . . . . . . . . . . . .  73
   9.   The NFSv4 File Layout Type . . . . . . . . . . . . . . . . .  74
     9.1  File Striping and Data Access  . . . . . . . . . . . . . .  74
       9.1.1  Sparse and Dense Storage Device Data Layouts . . . . .  75
       9.1.2  Metadata and Storage Device Roles  . . . . . . . . . .  77
       9.1.3  Device Multipathing  . . . . . . . . . . . . . . . . .  78
       9.1.4  Operations Issued to Storage Devices . . . . . . . . .  79
     9.2  Global Stateid Requirements  . . . . . . . . . . . . . . .  79
     9.3  The Layout Iomode  . . . . . . . . . . . . . . . . . . . .  80



Shepler                   Expires June 15, 2006                 [Page 3]

Internet-Draft           NFSv4 Minior Version 1            December 2005


     9.4  Storage Device State Propagation . . . . . . . . . . . . .  80
       9.4.1  Lock State Propagation . . . . . . . . . . . . . . . .  80
       9.4.2  Open-mode Validation . . . . . . . . . . . . . . . . .  81
       9.4.3  File Attributes  . . . . . . . . . . . . . . . . . . .  81
     9.5  Storage Device Component File Size . . . . . . . . . . . .  82
     9.6  Crash Recovery Considerations  . . . . . . . . . . . . . .  83
     9.7  Security Considerations  . . . . . . . . . . . . . . . . .  83
     9.8  Alternate Approaches . . . . . . . . . . . . . . . . . . .  84
   10.  pNFS Typed Data Structures . . . . . . . . . . . . . . . . .  85
     10.1   pnfs_layouttype4 . . . . . . . . . . . . . . . . . . . .  85
     10.2   pnfs_deviceid4 . . . . . . . . . . . . . . . . . . . . .  85
     10.3   pnfs_deviceaddr4 . . . . . . . . . . . . . . . . . . . .  86
     10.4   pnfs_devlist_item4 . . . . . . . . . . . . . . . . . . .  86
     10.5   pnfs_layout4 . . . . . . . . . . . . . . . . . . . . . .  87
     10.6   pnfs_layoutupdate4 . . . . . . . . . . . . . . . . . . .  87
     10.7   pnfs_layouthint4 . . . . . . . . . . . . . . . . . . . .  88
     10.8   pnfs_layoutiomode4 . . . . . . . . . . . . . . . . . . .  88
   11.  pNFS File Attributes . . . . . . . . . . . . . . . . . . . .  88
     11.1   pnfs_layouttype4<> FS_LAYOUT_TYPES . . . . . . . . . . .  88
     11.2   pnfs_layouttype4<> FILE_LAYOUT_TYPES . . . . . . . . . .  88
     11.3   pnfs_layouthint4 FILE_LAYOUT_HINT  . . . . . . . . . . .  89
     11.4   uint32_t FS_LAYOUT_PREFERRED_BLOCKSIZE . . . . . . . . .  89
     11.5   uint32_t FS_LAYOUT_PREFERRED_ALIGNMENT . . . . . . . . .  89
   12.  pNFS Error Definitions . . . . . . . . . . . . . . . . . . .  89
   13.  Layouts and Aggregation  . . . . . . . . . . . . . . . . . .  90
     13.1   Simple Map . . . . . . . . . . . . . . . . . . . . . . .  90
     13.2   Block Extent Map . . . . . . . . . . . . . . . . . . . .  90
     13.3   Striped Map (RAID 0) . . . . . . . . . . . . . . . . . .  90
     13.4   Replicated Map . . . . . . . . . . . . . . . . . . . . .  91
     13.5   Concatenated Map . . . . . . . . . . . . . . . . . . . .  91
     13.6   Nested Map . . . . . . . . . . . . . . . . . . . . . . .  91
   14.  NFSv4.1 Operations . . . . . . . . . . . . . . . . . . . . .  91
     14.1   LOOKUPP - Lookup Parent Directory  . . . . . . . . . . .  91
     14.2   SECINFO -- Obtain Available Security . . . . . . . . . .  93
     14.3   SECINFO_NO_NAME - Get Security on Unnamed Object . . . .  96
     14.4   CREATECLIENTID - Instantiate Clientid  . . . . . . . . .  98
     14.5   CREATESESSION - Create New Session and Confirm
            Clientid . . . . . . . . . . . . . . . . . . . . . . . . 104
     14.6   BIND_BACKCHANNEL - Create a callback channel binding . . 109
     14.7   DESTROYSESSION - Destroy existing session  . . . . . . . 112
     14.8   SEQUENCE - Supply per-procedure sequencing and control . 113
     14.9   CB_RECALLCREDIT - change flow control limits . . . . . . 114
     14.10  CB_SEQUENCE - Supply callback channel sequencing and
            control  . . . . . . . . . . . . . . . . . . . . . . . . 115
     14.11  GET_DIR_DELEGATION - Get a directory delegation  . . . . 117
     14.12  CB_NOTIFY - Notify directory changes . . . . . . . . . . 120
     14.13  CB_RECALL_ANY - Keep any N delegations . . . . . . . . . 124
     14.14  LAYOUTGET - Get Layout Information . . . . . . . . . . . 126



Shepler                   Expires June 15, 2006                 [Page 4]

Internet-Draft           NFSv4 Minior Version 1            December 2005


     14.15  LAYOUTCOMMIT - Commit writes made using a layout . . . . 128
     14.16  LAYOUTRETURN - Release Layout Information  . . . . . . . 131
     14.17  GETDEVICEINFO - Get Device Information . . . . . . . . . 133
     14.18  GETDEVICELIST - Get List of Devices  . . . . . . . . . . 134
     14.19  CB_LAYOUTRECALL  . . . . . . . . . . . . . . . . . . . . 136
     14.20  CB_SIZECHANGED . . . . . . . . . . . . . . . . . . . . . 138
   15.  References . . . . . . . . . . . . . . . . . . . . . . . . . 139
     15.1   Normative References . . . . . . . . . . . . . . . . . . 139
     15.2   Informative References . . . . . . . . . . . . . . . . . 139
        Author's Address . . . . . . . . . . . . . . . . . . . . . . 139
   A.   Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . 139
        Intellectual Property and Copyright Statements . . . . . . . 141







































Shepler                   Expires June 15, 2006                 [Page 5]

Internet-Draft           NFSv4 Minior Version 1            December 2005


1.  Security Negotiation

   The NFSv4.0 specification contains three oversights and ambiguities
   with respect to the SECINFO operation.

   First, it is impossible for the client to use the SECINFO operation
   to determine the correct security triple for accessing a parent
   directory.  This is because SECINFO takes as arguments the current
   file handle and a component name.  However, NFSv4.0 uses the LOOKUPP
   operation to get the parent directory of the current file handle.  If
   the client uses the wrong security when issuing the LOOKUPP, and gets
   back an NFS4ERR_WRONGSEC error, SECINFO is useless to the client.
   The client is left with guessing which security the server will
   accept.  This defeats the purpose of SECINFO, which was to provide an
   efficient method of negotiating security.

   Second, there is ambiguity as to what the server should do when it is
   passed a LOOKUP operation such that the server restricts access to
   the current file handle with one security triple, and access to the
   component with a different triple, and remote procedure call uses one
   of the two security triples.  Should the server allow the LOOKUP?

   Third, there is a problem as to what the client must do (or can do),
   whenever the server returns NFS4ERR_WRONGSEC in response to a PUTFH
   operation.  The NFSv4.0 specification says that client should issue a
   SECINFO using the parent filehandle and the component name of the
   filehandle that PUTFH was issued with.  This may not be convenient
   for the client.

   This document resolves the above three issues in the context of
   NFSv4.1.

2.  Clarification of Security Negotiation in NFSv4.1

   This section attempts to clarify NFSv4.1 security negotiation issues.
   Unless noted otherwise, for any mention of PUTFH in this section, the
   reader should interpret it as applying to PUTROOTFH and PUTPUBFH in
   addition to PUTFH.

2.1  PUTFH + LOOKUP

   The server implementation may decide whether to impose any
   restrictions on export security administration.  There are at least
   three approaches (Sc is the flavor set of the child export, Sp that
   of the parent),






Shepler                   Expires June 15, 2006                 [Page 6]

Internet-Draft           NFSv4 Minior Version 1            December 2005


     a) Sc <= Sp (<= for subset)

     b) Sc ^ Sp != {} (^ for intersection, {} for the empty set)

     c) free form

   To support b (when client chooses a flavor that is not a member of
   Sp) and c, PUTFH must NOT return NFS4ERR_WRONGSEC in case of security
   mismatch.  Instead, it should be returned from the LOOKUP that
   follows.

   Since the above guideline does not contradict a, it should be
   followed in general.

2.2  PUTFH + LOOKUPP

   Since SECINFO only works its way down, there is no way LOOKUPP can
   return NFS4ERR_WRONGSEC without the server implementing
   SECINFO_NO_NAME.  SECINFO_NO_NAME solves this issue because via style
   "parent", it works in the opposite direction as SECINFO (component
   name is implicit in this case).

2.3  PUTFH + SECINFO

   This case should be treated specially.

   A security sensitive client should be allowed to choose a strong
   flavor when querying a server to determine a file object's permitted
   security flavors.  The security flavor chosen by the client does not
   have to be included in the flavor list of the export.  Of course the
   server has to be configured for whatever flavor the client selects,
   otherwise the request will fail at RPC authentication.

   In theory, there is no connection between the security flavor used by
   SECINFO and those supported by the export.  But in practice, the
   client may start looking for strong flavors from those supported by
   the export, followed by those in the mandatory set.

2.4  PUTFH + Anything Else

   PUTFH must return NFS4ERR_WRONGSEC in case of security mismatch.
   This is the most straightforward approach without having to add
   NFS4ERR_WRONGSEC to every other operations.

   PUTFH + SECINFO_NO_NAME (style "current_fh") is needed for the client
   to recover from NFS4ERR_WRONGSEC.





Shepler                   Expires June 15, 2006                 [Page 7]

Internet-Draft           NFSv4 Minior Version 1            December 2005


3.  NFSv4.1 Sessions

3.1  Sessions Background

3.1.1  Introduction to Sessions

   This draft proposes extensions to NFS version 4 [RFC3530] enabling it
   to support sessions and endpoint management, and to support operation
   atop RDMA-capable RPC over transports such as iWARP.  [RDMAP, DDP]
   These extensions enable support for exactly-once semantics by NFSv4
   servers, multipathing and trunking of transport connections, and
   enhanced security.  The ability to operate over RDMA enables greatly
   enhanced performance.  Operation over existing TCP is enhanced as
   well.

   While discussed here with respect to IETF-chartered transports, the
   proposed protocol is intended to function over other standards, such
   as Infiniband.  [IB]

   The following are the major aspects of this proposal:

      Changes are proposed within the framework of NFSv4 minor
      versioning.  RPC, XDR, and the NFSv4 procedures and operations are
      preserved.  The proposed extension functions equally well over
      existing transports and RDMA, and interoperates transparently with
      existing implementations, both at the local programmatic interface
      and over the wire.

      An explicit session is introduced to NFSv4, and new operations are
      added to support it.  The session allows for enhanced trunking,
      failover and recovery, and authentication efficiency, along with
      necessary support for RDMA.  The session is implemented as
      operations within NFSv4 COMPOUND and does not impact layering or
      interoperability with existing NFSv4 implementations.  The NFSv4
      callback channel is dynamically associated and is connected by the
      client and not the server, enhancing security and operation
      through firewalls.  In fact, the callback channel will be enabled
      to share the same connection as the operations channel.

      An enhanced RPC layer enables NFSv4 operation atop RDMA.  The
      session assists RDMA-mode connection, and additional facilities
      are provided for managing RDMA resources at both NFSv4 server and
      client.  Existing NFSv4 operations continue to function as before,
      though certain size limits are negotiated.  A companion draft to
      this document, "RDMA Transport for ONC RPC" [RPCRDMA] is to be
      referenced for details of RPC RDMA support.





Shepler                   Expires June 15, 2006                 [Page 8]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      Support for exactly-once semantics ("EOS") is enabled by the new
      session facilities, by providing to the server a way to bound the
      size of the duplicate request cache for a single client, and to
      manage its persistent storage.


                                   Block Diagram

             +-----------------+-------------------------------------+
             |     NFSv4       |     NFSv4 + session extensions      |
             +-----------------+------+----------------+-------------+
             |      Operations        |   Session      |             |
             +------------------------+----------------+             |
             |                RPC/XDR                  |             |
             +-------------------------------+---------+             |
             |       Stream Transport        |    RDMA Transport     |
             +-------------------------------+-----------------------+


3.1.2  Motivation

   NFS version 4 [RFC3530] has been granted "Proposed Standard" status.
   The NFSv4 protocol was developed along several design points,
   important among them: effective operation over wide-area networks,
   including the Internet itself;  strong security integrated into the
   protocol;  extensive cross-platform interoperability including
   integrated locking semantics compatible with multiple operating
   systems; and protocol extensibility.

   The NFS version 4 protocol, however, does not provide support for
   certain important transport aspects.  For example, the protocol does
   not address response caching, which is required to provide
   correctness for retried client requests across a network partition,
   nor does it provide an interoperable way to support trunking and
   multipathing of connections.  This leads to inefficiencies,
   especially where trunking and multipathing are concerned, and
   presents additional difficulties in supporting RDMA fabrics, in which
   endpoints may require dedicated or specialized resources.  Sessions
   can be employed to unify NFS-level constructs such as the clientid,
   with transport-level constructs such as transport endpoints.  Each
   transport endpoint draws on resources via its membership in a
   session.  Resource management can be more strictly maintained,
   leading to greater server efficiency in implementing the protocol.
   The enhanced operation over a session affords an opportunity to the
   server to implement a highly reliable duplicate request cache, and
   thereby export exactly-once semantics.

   NFSv4 advances the state of high-performance local sharing, by virtue



Shepler                   Expires June 15, 2006                 [Page 9]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   of its integrated security, locking, and delegation, and its
   excellent coverage of the sharing semantics of multiple operating
   systems.  It is precisely this environment where exactly-once
   semantics become a fundamental requirement.

   Additionally, efforts to standardize a set of protocols for Remote
   Direct Memory Access, RDMA, over the Internet Protocol Suite have
   made significant progress.  RDMA is a general solution to the problem
   of CPU overhead incurred due to data copies, primarily at the
   receiver.  Substantial research has addressed this and has borne out
   the efficacy of the approach.  An overview of this is the RDDP
   Problem Statement document, [RDDPPS].

   Numerous upper layer protocols achieve extremely high bandwidth and
   low overhead through the use of RDMA.  Products from a wide variety
   of vendors employ RDMA to advantage, and prototypes have demonstrated
   the effectiveness of many more.  Here, we are concerned specifically
   with NFS and NFS-style upper layer protocols;  examples from Network
   Appliance [DAFS, DCK+03], Fujitsu Prime Software Technologies [FJNFS,
   FJDAFS] and Harvard University [KM02] are all relevant.

   By layering a session binding for NFS version 4 directly atop a
   standard RDMA transport, a greatly enhanced level of performance and
   transparency can be supported on a wide variety of operating system
   platforms.  These combined capabilities alter the landscape between
   local filesystems and network attached storage, enable a new level of
   performance, and lead new classes of application to take advantage of
   NFS.

3.1.3  Problem Statement

   Two issues drive the current proposal: correctness, and performance.
   Both are instances of "raising the bar" for NFS, whereby the desire
   to use NFS in new classes applications can be accommodated by
   providing the basic features to make such use feasible.  Such
   applications include tightly coupled sharing environments such as
   cluster computing, high performance computing (HPC) and information
   processing such as databases.  These trends are explored in depth in
   [NFSPS].

   The first issue, correctness, exemplified among the attributes of
   local filesystems, is support for exactly-once semantics.  Such
   semantics have not been reliably available with NFS.  Server-based
   duplicate request caches [CJ89] help, but do not reliably provide
   strict correctness.  For the type of application which is expected to
   make extensive use of the high-performance RDMA-enabled environment,
   the reliable provision of such semantics is a fundamental
   requirement.



Shepler                   Expires June 15, 2006                [Page 10]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Introduction of a session to NFSv4 will address these issues.  With
   higher performance and enhanced semantics comes the problem of
   enabling advanced endpoint management, for example high-speed
   trunking, multipathing and failover.  These characteristics enable
   availability and performance.  RFC3530 presents some issues in
   permitting a single clientid to access a server over multiple
   connections.

   A second issue encountered in common by NFS implementations is the
   CPU overhead required to implement the protocol.  Primary among the
   sources of this overhead is the movement of data from NFS protocol
   messages to its eventual destination in user buffers or aligned
   kernel buffers.  The data copies consume system bus bandwidth and CPU
   time, reducing the available system capacity for applications.
   [RDDPPS] Achieving zero-copy with NFS has to date required
   sophisticated, "header cracking" hardware and/or extensive platform-
   specific virtual memory mapping tricks.

   Combined in this way, NFSv4, RDMA and the emerging high-speed network
   fabrics will enable delivery of performance which matches that of the
   fastest local filesystems, preserving the key existing local
   filesystem semantics, while enhancing them by providing network
   filesystem sharing semantics.

   RDMA implementations generally have other interesting properties,
   such as hardware assisted protocol access, and support for user space
   access to I/O. RDMA is compelling here for another reason; hardware
   offloaded networking support in itself does not avoid data copies,
   without resorting to implementing part of the NFS protocol in the
   NIC.  Support of RDMA by NFS enables the highest performance at the
   architecture level rather than by implementation; this enables
   ubiquitous and interoperable solutions.

   By providing file access performance equivalent to that of local file
   systems, NFSv4 over RDMA will enable applications running on a set of
   client machines to interact through an NFSv4 file system, just as
   applications running on a single machine might interact through a
   local file system.

   This raises the issue of whether additional protocol enhancements to
   enable such interaction would be desirable and what such enhancements
   would be.  This is a complicated issue which the working group needs
   to address and will not be further discussed in this document.

3.1.4  NFSv4 Session Extension Characteristics

   This draft will present a solution based upon minor versioning of
   NFSv4.  It will introduce a session to collect transport endpoints



Shepler                   Expires June 15, 2006                [Page 11]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   and resources such as reply caching, which in turn enables
   enhancements such as trunking, failover and recovery.  It will
   describe use of RDMA by employing support within an underlying RPC
   layer [RPCRDMA].  Most importantly, it will focus on making the best
   possible use of an RDMA transport.

   These extensions are proposed as elements of a new minor revision of
   NFS version 4.  In this draft, NFS version 4 will be referred to
   generically as "NFSv4", when describing properties common to all
   minor versions.  When referring specifically to properties of the
   original, minor version 0 protocol, "NFSv4.0" will be used, and
   changes proposed here for minor version 1 will be referred to as
   "NFSv4.1".

   This draft proposes only changes which are strictly upward-
   compatible with existing RPC and NFS Application Programming
   Interfaces (APIs).

3.2  Transport Issues

   The Transport Issues section of the document explores the details of
   utilizing the various supported transports.

3.2.1  Session Model

   The first and most evident issue in supporting diverse transports is
   how to provide for their differences.  This draft proposes
   introducing an explicit session.

   A session introduces minimal protocol requirements, and provides for
   a highly useful and convenient way to manage numerous endpoint-
   related issues.  The session is a local construct; it represents a
   named, higher-layer object to which connections can refer, and
   encapsulates properties important to each associated client.

   A session is a dynamically created, long-lived server object created
   by a client, used over time from one or more transport connections.
   Its function is to maintain the server's state relative to the
   connection(s) belonging to a client instance.  This state is entirely
   independent of the connection itself.  The session in effect becomes
   the object representing an active client on a connection or set of
   connections.

   Clients may create multiple sessions for a single clientid, and may
   wish to do so for optimization of transport resources, buffers, or
   server behavior.  A session could be created by the client to
   represent a single mount point, for separate read and write
   "channels", or for any number of other client-selected parameters.



Shepler                   Expires June 15, 2006                [Page 12]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   The session enables several things immediately.  Clients may
   disconnect and reconnect (voluntarily or not) without loss of context
   at the server.  (Of course, locks, delegations and related
   associations require special handling, and generally expire in the
   extended absence of an open connection.)  Clients may connect
   multiple transport endpoints to this common state.  The endpoints may
   have all the same attributes, for instance when trunked on multiple
   physical network links for bandwidth aggregation or path failover.
   Or, the endpoints can have specific, special purpose attributes such
   as callback channels.

   The NFSv4 specification does not provide for any form of flow
   control;  instead it relies on the windowing provided by TCP to
   throttle requests.  This unfortunately does not work with RDMA, which
   in general provides no operation flow control and will terminate a
   connection in error when limits are exceeded.  Limits are therefore
   exchanged when a session is created; These limits then provide maxima
   within which each session's connections must operate, they are
   managed within these limits as described in [RPCRDMA].  The limits
   may also be modified dynamically at the server's choosing by
   manipulating certain parameters present in each NFSv4.1 request.

   The presence of a maximum request limit on the session bounds the
   requirements of the duplicate request cache.  This can be used to
   advantage by a server, which can accurately determine any storage
   needs and enable it to maintain duplicate request cache persistence
   and to provide reliable exactly-once semantics.

   Finally, given adequate connection-oriented transport security
   semantics, authentication and authorization may be cached on a per-
   session basis, enabling greater efficiency in the issuing and
   processing of requests on both client and server.  A proposal for
   transparent, server-driven implementation of this in NFSv4 has been
   made.  [CCM] The existence of the session greatly facilitates the
   implementation of this approach.  This is discussed in detail in the
   Authentication Efficiencies section later in this draft.

3.2.2  Connection State

   In RFC3530, the combination of a connected transport endpoint and a
   clientid forms the basis of connection state.  While has been made to
   be workable with certain limitations, there are difficulties in
   correct and robust implementation.  The NFSv4.0 protocol must provide
   a server-initiated connection for the callback channel, and must
   carefully specify the persistence of client state at the server in
   the face of transport interruptions.  The server has only the
   client's transport address binding (the IP 4-tuple) to identify the
   client RPC transaction stream and to use as a lookup tag on the



Shepler                   Expires June 15, 2006                [Page 13]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   duplicate request cache.  (A useful overview of this is in [RW96].)
   If the server listens on multiple adddresses, and the client connects
   to more than one, it must employ different clientid's on each,
   negating its ability to aggregate bandwidth and redundancy.  In
   effect, each transport connection is used as the server's
   representation of client state.  But, transport connections are
   potentially fragile and transitory.

   In this proposal, a session identifier is assigned by the server upon
   initial session negotiation on each connection.  This identifier is
   used to associate additional connections, to renegotiate after a
   reconnect, to provide an abstraction for the various session
   properties, and to address the duplicate request cache.  No
   transport-specific information is used in the duplicate request cache
   implementation of an NFSv4.1 server, nor in fact the RPC XID itself.
   The session identifier is unique within the server's scope and may be
   subject to certain server policies such as being bounded in time.

   It is envisioned that the primary transport model will be connection
   oriented.  Connection orientation brings with it certain potential
   optimizations, such as caching of per-connection properties, which
   are easily leveraged through the generality of the session.  However,
   it is possible that in future, other transport models could be
   accommodated below the session abstraction.

3.2.3  NFSv4 Channels, Sessions and Connections

   There are at least two types of NFSv4 channels: the "operations"
   channel used for ordinary requests from client to server, and the
   "back" channel, used for callback requests from server to client.

   As mentioned above, different NFSv4 operations on these channels can
   lead to different resource needs.  For example, server callback
   operations (CB_RECALL) are specific, small messages which flow from
   server to client at arbitrary times, while data transfers such as
   read and write have very different sizes and asymmetric behaviors.
   It is sometimes impractical for the RDMA peers (NFSv4 client and
   NFSv4 server) to post buffers for these various operations on a
   single connection.  Commingling of requests with responses at the
   client receive queue is particularly troublesome, due both to the
   need to manage both solicited and unsolicited completions, and to
   provision buffers for both purposes.  Due to the lack of any ordering
   of callback requests versus response arrivals, without any other
   mechanisms, the client would be forced to allocate all buffers sized
   to the worst case.

   The callback requests are likely to be handled by a different task
   context from that handling the responses.  Significant demultiplexing



Shepler                   Expires June 15, 2006                [Page 14]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   and thread management may be required if both are received on the
   same queue.  However, if callbacks are relatively rare (perhaps due
   to client access patterns), many of these difficulties can be
   minimized.

   Also, the client may wish to perform trunking of operations channel
   requests for performance reasons, or multipathing for availability.
   This proposal permits both, as well as many other session and
   connection possibilities, by permitting each operation to carry
   session membership information and to share session (and clientid)
   state in order to draw upon the appropriate resources.  For example,
   reads and writes may be assigned to specific, optimized connections,
   or sorted and separated by any or all of size, idempotency, etc.

   To address the problems described above, this proposal allows
   multiple sessions to share a clientid, as well as for multiple
   connections to share a session.

   Single Connection model:

                            NFSv4.1 Session
                               /      \
                Operations_Channel   [Back_Channel]
                                \    /
                             Connection
                                  |


        Multi-connection trunked model (2 operations channels shown):

                            NFSv4.1 Session
                               /      \
                Operations_Channels  [Back_Channel]
                    |          |               |
                Connection Connection     [Connection]
                    |          |               |


        Multi-connection split-use model (2 mounts shown):

                                     NFSv4.1 Session
                                   /                 \
                            (/home)        (/usr/local - readonly)
                            /      \                    |
             Operations_Channel  [Back_Channel]         |
                     |                 |          Operations_Channel
                 Connection       [Connection]          |
                     |                 |            Connection



Shepler                   Expires June 15, 2006                [Page 15]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                                                        |

   In this way, implementation as well as resource management may be
   optimized.  Each session will have its own response caching and
   buffering, and each connection or channel will have its own transport
   resources, as appropriate.  Clients which do not require certain
   behaviors may optimize such resources away completely, by using
   specific sessions and not even creating the additional channels and
   connections.

3.2.4  Reconnection, Trunking and Failover

   Reconnection after failure references stored state on the server
   associated with lease recovery during the grace period.  The session
   provides a convenient handle for storing and managing information
   regarding the client's previous state on a per- connection basis,
   e.g. to be used upon reconnection.  Reconnection to a previously
   existing session, and its stored resources, are covered in the
   "Connection Models" section below.

   One important aspect of reconnection is that of RPC library support.
   Traditionally, an Upper Layer RPC-based Protocol such as NFS leaves
   all transport knowledge to the RPC layer implementation below it.
   This allows NFS to operate over a wide variety of transports and has
   proven to be a highly successful approach.  The session, however,
   introduces an abstraction which is, in a way, "between" RPC and
   NFSv4.1.  It is important that the session abstraction not have
   ramifications within the RPC layer.

   One such issue arises within the reconnection logic of RPC.
   Previously, an explicit session binding operation, which established
   session context for each new connection, was explored.  This however
   required that the session binding also be performed during reconnect,
   which in turn required an RPC request.  This additional request
   requires new RPC semantics, both in implementation and the fact that
   a new request is inserted into the RPC stream.  Also, the binding of
   a connection to a session required the upper layer to become "aware"
   of connections, something the RPC layer abstraction architecturally
   abstracts away.  Therefore the session binding is not handled in
   connection scope but instead explicitly carried in each request.

   For Reliability Availability and Serviceability (RAS) issues such as
   bandwidth aggregation and multipathing, clients frequently seek to
   make multiple connections through multiple logical or physical
   channels.  The session is a convenient point to aggregate and manage
   these resources.





Shepler                   Expires June 15, 2006                [Page 16]

Internet-Draft           NFSv4 Minior Version 1            December 2005


3.2.5  Server Duplicate Request Cache

   Server duplicate request caches, while not a part of an NFS protocol,
   have become a standard, even required, part of any NFS
   implementation.  First described in [CJ89], the duplicate request
   cache was initially found to reduce work at the server by avoiding
   duplicate processing for retransmitted requests.  A second, and in
   the long run more important benefit, was improved correctness, as the
   cache avoided certain destructive non-idempotent requests from being
   reinvoked.

   However, such caches do not provide correctness guarantees;  they
   cannot be managed in a reliable, persistent fashion.  The reason is
   understandable - their storage requirement is unbounded due to the
   lack of any such bound in the NFS protocol, and they are dependent on
   transport addresses for request matching.

   As proposed in this draft, the presence of maximum request count
   limits and negotiated maximum sizes allows the size and duration of
   the cache to be bounded, and coupled with a long-lived session
   identifier, enables its persistent storage on a per-session basis.

   This provides a single unified mechanism which provides the following
   guarantees required in the NFSv4 specification, while extending them
   to all requests, rather than limiting them only to a subset of state-
   related requests:

   "It is critical the server maintain the last response sent to the
   client to provide a more reliable cache of duplicate non- idempotent
   requests than that of the traditional cache described in [CJ89]..."
   [RFC3530]

   The maximum request count limit is the count of active operations,
   which bounds the number of entries in the cache.  Constraining the
   size of operations additionally serves to limit the required storage
   to the product of the current maximum request count and the maximum
   response size.  This storage requirement enables server- side
   efficiencies.

   Session negotiation allows the server to maintain other state.  An
   NFSv4.1 client invoking the session destroy operation will cause the
   server to denegotiate (close) the session, allowing the server to
   deallocate cache entries.  Clients can potentially specify that such
   caches not be kept for appropriate types of sessions (for example,
   read-only sessions).  This can enable more efficient server operation
   resulting in improved response times, and more efficient sizing of
   buffers and response caches.




Shepler                   Expires June 15, 2006                [Page 17]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Similarly, it is important for the client to explicitly learn whether
   the server is able to implement reliable semantics.  Knowledge of
   whether these semantics are in force is critical for a highly
   reliable client, one which must provide transactional integrity
   guarantees.  When clients request that the semantics be enabled for a
   given session, the session reply must inform the client if the mode
   is in fact enabled.  In this way the client can confidently proceed
   with operations without having to implement consistency facilities of
   its own.

3.3  Session Initialization and Transfer Models

   Session initialization issues, and data transfer models relevant to
   both TCP and RDMA are discussed in this section.

3.3.1  Session Negotiation

   The following parameters are exchanged between client and server at
   session creation time.  Their values allow the server to properly
   size resources allocated in order to service the client's requests,
   and to provide the server with a way to communicate limits to the
   client for proper and optimal operation.  They are exchanged prior to
   all session-related activity, over any transport type.  Discussion of
   their use is found in their descriptions as well as throughout this
   section.

   Maximum Requests

      The client's desired maximum number of concurrent requests is
      passed, in order to allow the server to size its reply cache
      storage.  The server may modify the client's requested limit
      downward (or upward) to match its local policy and/or resources.
      Over RDMA-capable RPC transports, the per-request management of
      low-level transport message credits is handled within the RPC
      layer.  [RPCRDMA]

   Maximum Request/Response Sizes

      The maximum request and response sizes are exchanged in order to
      permit allocation of appropriately sized buffers and request cache
      entries.  The size must allow for certain protocol minima,
      allowing the receipt of maximally sized operations (e.g.  RENAME
      requests which contains two name strings).  Note the maximum
      request/response sizes cover the entire request/response message
      and not simply the data payload as traditional NFS maximum read or
      write size.  Also note the server implementation may not, in fact
      probably does not, require the reply cache entries to be sized as
      large as the maximum response.  The server may reduce the client's



Shepler                   Expires June 15, 2006                [Page 18]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      requested sizes.

   Inline Padding/Alignment

      The server can inform the client of any padding which can be used
      to deliver NFSv4 inline WRITE payloads into aligned buffers.  Such
      alignment can be used to avoid data copy operations at the server
      for both TCP and inline RDMA transfers.  For RDMA, the client
      informs the server in each operation when padding has been
      applied.  [RPCRDMA]

   Transport Attributes

      A placeholder for transport-specific attributes is provided, with
      a format to be determined.  Possible examples of information to be
      passed in this parameter include transport security attributes to
      be used on the connection, RDMA- specific attributes, legacy
      "private data" as used on existing RDMA fabrics, transport Quality
      of Service attributes, etc.  This information is to be passed to
      the peer's transport layer by local means which is currently
      outside the scope of this draft, however one attribute is provided
      in the RDMA case:

   RDMA Read Resources

      RDMA implementations must explicitly provision resources to
      support RDMA Read requests from connected peers.  These values
      must be explicitly specified, to provide adequate resources for
      matching the peer's expected needs and the connection's delay-
      bandwidth parameters.  The client provides its chosen value to the
      server in the initial session creation, the value must be provided
      in each client RDMA endpoint.  The values are asymmetric and
      should be set to zero at the server in order to conserve RDMA
      resources, since clients do not issue RDMA Read operations in this
      proposal.  The result is communicated in the session response, to
      permit matching of values across the connection.  The value may
      not be changed in the duration of the session, although a new
      value may be requested as part of a new session.


3.3.2  RDMA Requirements

   A complete discussion of the operation of RPC-based protocols atop
   RDMA transports is in [RPCRDMA].  Where RDMA is considered, this
   proposal assumes the use of such a layering;  it addresses only the
   upper layer issues relevant to making best use of RPC/RDMA.

   A connection oriented (reliable sequenced) RDMA transport will be



Shepler                   Expires June 15, 2006                [Page 19]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   required.  There are several reasons for this.  First, this model
   most closely reflects the general NFSv4 requirement of long-lived and
   congestion-controlled transports.  Second, to operate correctly over
   either an unreliable or unsequenced RDMA transport, or both, would
   require significant complexity in the implementation and protocol not
   appropriate for a strict minor version.  For example, retransmission
   on connected endpoints is explicitly disallowed in the current NFSv4
   draft;  it would again be required with these alternate transport
   characteristics.  Third, the proposal assumes a specific RDMA
   ordering semantic, which presents the same set of ordering and
   reliability issues to the RDMA layer over such transports.

   The RDMA implementation provides for making connections to other
   RDMA-capable peers.  In the case of the current proposals before the
   RDDP working group, these RDMA connections are preceded by a
   "streaming" phase, where ordinary TCP (or NFS) traffic might flow.
   However, this is not assumed here and sizes and other parameters are
   explicitly exchanged upon a session entering RDMA mode.

3.3.3  RDMA Connection Resources

   On transport endpoints which support automatic RDMA mode, that is,
   endpoints which are created in the RDMA-enabled state, a single,
   preposted buffer must initially be provided by both peers, and the
   client session negotiation must be the first exchange.

   On transport endpoints supporting dynamic negotiation, a more
   sophisticated negotiation is possible, but is not discussed in the
   current draft.

   RDMA imposes several requirements on upper layer consumers.
   Registration of memory and the need to post buffers of a specific
   size and number for receive operations are a primary consideration.

   Registration of memory can be a relatively high-overhead operation,
   since it requires pinning of buffers, assignment of attributes (e.g.
   readable/writable), and initialization of hardware translation.
   Preregistration is desirable to reduce overhead.  These registrations
   are specific to hardware interfaces and even to RDMA connection
   endpoints, therefore negotiation of their limits is desirable to
   manage resources effectively.

   Following the basic registration, these buffers must be posted by the
   RPC layer to handle receives.  These buffers remain in use by the
   RPC/NFSv4 implementation; the size and number of them must be known
   to the remote peer in order to avoid RDMA errors which would cause a
   fatal error on the RDMA connection.




Shepler                   Expires June 15, 2006                [Page 20]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   The session provides a natural way for the server to manage resource
   allocation to each client rather than to each transport connection
   itself.  This enables considerable flexibility in the administration
   of transport endpoints.

3.3.4  TCP and RDMA Inline Transfer Model

   The basic transfer model for both TCP and RDMA is referred to as
   "inline".  For TCP, this is the only transfer model supported, since
   TCP carries both the RPC header and data together in the data stream.

   For RDMA, the RDMA Send transfer model is used for all NFS requests
   and replies, but data is optionally carried by RDMA Writes or RDMA
   Reads.  Use of Sends is required to ensure consistency of data and to
   deliver completion notifications.  The pure-Send method is typically
   used where the data payload is small, or where for whatever reason
   target memory for RDMA is not available.

        Inline message exchange

               Client                                Server
                  :                Request              :
             Send :   ------------------------------>   : untagged
                  :                                     :  buffer
                  :               Response              :
         untagged :   <------------------------------   : Send
          buffer  :                                     :


               Client                                Server
                  :            Read request             :
             Send :   ------------------------------>   : untagged
                  :                                     :  buffer
                  :       Read response with data       :
         untagged :   <------------------------------   : Send
          buffer  :                                     :


               Client                                Server
                  :       Write request with data       :
             Send :   ------------------------------>   : untagged
                  :                                     :  buffer
                  :            Write response           :
         untagged :   <------------------------------   : Send
          buffer  :                                     :

   Responses must be sent to the client on the same connection that the
   request was sent.  It is important that the server does not assume



Shepler                   Expires June 15, 2006                [Page 21]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   any specific client implementation, in particular whether connections
   within a session share any state at the client.  This is also
   important to preserve ordering of RDMA operations, and especially
   RMDA consistency.  Additionally, it ensures that the RPC RDMA layer
   makes no requirement of the RDMA provider to open its memory
   registration handles (Steering Tags) beyond the scope of a single
   RDMA connection.  This is an important security consideration.

   Two values must be known to each peer prior to issuing Sends: the
   maximum number of sends which may be posted, and their maximum size.
   These values are referred to, respectively, as the message credits
   and the maximum message size.  While the message credits might vary
   dynamically over the duration of the session, the maximum message
   size does not.  The server must commit to preserving this number of
   duplicate request cache entires, and preparing a number of receive
   buffers equal to or greater than its currently advertised credit
   value, each of the advertised size.  These ensure that transport
   resources are allocated sufficient to receive the full advertised
   limits.

   Note that the server must post the maximum number of session requests
   to each client operations channel.  The client is not required to
   spread its requests in any particular fashion across connections
   within a session.  If the client wishes, it may create multiple
   sessions, each with a single or small number of operations channels
   to provide the server with this resource advantage.  Or, over RDMA
   the server may employ a "shared receive queue".  The server can in
   any case protect its resources by restricting the client's request
   credits.

   While tempting to consider, it is not possible to use the TCP window
   as an RDMA operation flow control mechanism.  First, to do so would
   violate layering, requiring both senders to be aware of the existing
   TCP outbound window at all times.  Second, since requests are of
   variable size, the TCP window can hold a widely variable number of
   them, and since it cannot be reduced without actually receiving data,
   the receiver cannot limit the sender.  Third, any middlebox
   interposing on the connection would wreck any possible scheme.
   [MIDTAX] In this proposal, maximum request count limits are exchanged
   at the session level to allow correct provisioning of receive buffers
   by transports.

   When operating over TCP or other similar transport, request limits
   and sizes are still employed in NFSv4.1, but instead of being
   required for correctness, they provide the basis for efficient server
   implementation of the duplicate request cache.  The limits are chosen
   based upon the expected needs and capabilities of the client and
   server, and are in fact arbitrary.  Sizes may be specified by the



Shepler                   Expires June 15, 2006                [Page 22]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   client as zero (requesting the server's preferred or optimal value),
   and request limits may be chosen in proportion to the client's
   capabilities.  For example, a limit of 1000 allows 1000 requests to
   be in progress, which may generally be far more than adequate to keep
   local networks and servers fully utilized.

   Both client and server have independent sizes and buffering, but over
   RDMA fabrics client credits are easily managed by posting a receive
   buffer prior to sending each request.  Each such buffer may not be
   completed with the corresponding reply, since responses from NFSv4
   servers arrive in arbitrary order.  When an operations channel is
   also used for callbacks, the client must account for callback
   requests by posting additional buffers.  Note that implementation-
   specific facilities such as a shared receive queue may also allow
   optimization of these allocations.

   When a session is created, the client requests a preferred buffer
   size, and the server provides its answer.  The server posts all
   buffers of at least this size.  The client must comply by not sending
   requests greater than this size.  It is recommended that server
   implementations do all they can to accommodate a useful range of
   possible client requests.  There is a provision in [RPCRDMA] to allow
   the sending of client requests which exceed the server's receive
   buffer size, but it requires the server to "pull" the client's
   request as a "read chunk" via RDMA Read.  This introduces at least
   one additional network roundtrip, plus other overhead such as
   registering memory for RDMA Read at the client and additional RDMA
   operations at the server, and is to be avoided.

   An issue therefore arises when considering the NFSv4 COMPOUND
   procedures.  Since an arbitrary number (total size) of operations can
   be specified in a single COMPOUND procedure, its size is effectively
   unbounded.  This cannot be supported by RDMA Sends, and therefore
   this size negotiation places a restriction on the construction and
   maximum size of both COMPOUND requests and responses.  If a COMPOUND
   results in a reply at the server that is larger than can be sent in
   an RDMA Send to the client, then the COMPOUND must terminate and the
   operation which causes the overflow will provide a TOOSMALL error
   status result.

3.3.5  RDMA Direct Transfer Model

   Placement of data by explicitly tagged RDMA operations is referred to
   as "direct" transfer.  This method is typically used where the data
   payload is relatively large, that is, when RDMA setup has been
   performed prior to the operation, or when any overhead for setting up
   and performing the transfer is regained by avoiding the overhead of
   processing an ordinary receive.



Shepler                   Expires June 15, 2006                [Page 23]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   The client advertises RDMA buffers in this proposed model, and not
   the server.  This means the "XDR Decoding with Read Chunks" described
   in [RPCRDMA] is not employed by NFSv4.1 replies, and instead all
   results transferred via RDMA to the client employ "XDR Decoding with
   Write Chunks".  There are several reasons for this.

   First, it allows for a correct and secure mode of transfer.  The
   client may advertise specific memory buffers only during specific
   times, and may revoke access when it pleases.  The server is not
   required to expose copies of local file buffers for individual
   clients, or to lock or copy them for each client access.

   Second, client credits based on fixed-size request buffers are easily
   managed on the server, but for the server additional management of
   buffers for client RDMA Reads is not well-bounded.  For example, the
   client may not perform these RDMA Read operations in a timely
   fashion, therefore the server would have to protect itself against
   denial-of-service on these resources.

   Third, it reduces network traffic, since buffer exposure outside the
   scope and duration of a single request/response exchange necessitates
   additional memory management exchanges.

   There are costs associated with this decision.  Primary among them is
   the need for the server to employ RDMA Read for operations such as
   large WRITE.  The RDMA Read operation is a two-way exchange at the
   RDMA layer, which incurs additional overhead relative to RDMA Write.
   Additionally, RDMA Read requires resources at the data source (the
   client in this proposal) to maintain state and to generate replies.
   These costs are overcome through use of pipelining with credits, with
   sufficient RDMA Read resources negotiated at session initiation, and
   appropriate use of RDMA for writes by the client - for example only
   for transfers above a certain size.

   A description of which NFSv4 operation results are eligible for data
   transfer via RDMA Write is in [NFSDDP].  There are only two such
   operations: READ and READLINK.  When XDR encoding these requests on
   an RDMA transport, the NFSv4.1 client must insert the appropriate
   xdr_write_list entries to indicate to the server whether the results
   should be transferred via RDMA or inline with a Send.  As described
   in [NFSDDP], a zero-length write chunk is used to indicate an inline
   result.  In this way, it is unnecessary to create new operations for
   RDMA-mode versions of READ and READLINK.

   Another tool to avoid creation of new, RDMA-mode operations is the
   Reply Chunk [RPCRDMA], which is used by RPC in RDMA mode to return
   large replies via RDMA as if they were inline.  Reply chunks are used
   for operations such as READDIR, which returns large amounts of



Shepler                   Expires June 15, 2006                [Page 24]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   information, but in many small XDR segments.  Reply chunks are
   offered by the client and the server can use them in preference to
   inline.  Reply chunks are transparent to upper layers such as NFSv4.

   In any very rare cases where another NFSv4.1 operation requires
   larger buffers than were negotiated when the session was created (for
   example extraordinarily large RENAMEs), the underlying RPC layer may
   support the use of "Message as an RDMA Read Chunk" and "RDMA Write of
   Long Replies" as described in [RPCRDMA].  No additional support is
   required in the NFSv4.1 client for this.  The client should be
   certain that its requested buffer sizes are not so small as to make
   this a frequent occurrence, however.

   All operations are initiated by a Send, and are completed with a
   Send.  This is exactly as in conventional NFSv4, but under RDMA has a
   significant purpose: RDMA operations are not complete, that is,
   guaranteed consistent, at the data sink until followed by a
   successful Send completion (i.e. a receive).  These events provide a
   natural opportunity for the initiator (client) to enable and later
   disable RDMA access to the memory which is the target of each
   operation, in order to provide for consistent and secure operation.
   The RDMAP Send with Invalidate operation may be worth employing in
   this respect, as it relieves the client of certain overhead in this
   case.

   A "onetime" boolean advisory to each RDMA region might become a hint
   to the server that the client will use the three-tuple for only one
   NFSv4 operation.  For a transport such as iWARP, the server can
   assist the client in invalidating the three-tuple by performing a
   Send with Solicited Event and Invalidate.  The server may ignore this
   hint, in which case the client must perform a local invalidate after
   receiving the indication from the server that the NFSv4 operation is
   complete.  This may be considered in a future version of this draft
   and [NFSDDP].

   In a trusted environment, it may be desirable for the client to
   persistently enable RDMA access by the server.  Such a model is
   desirable for the highest level of efficiency and lowest overhead.













Shepler                   Expires June 15, 2006                [Page 25]

Internet-Draft           NFSv4 Minior Version 1            December 2005


        RDMA message exchanges

               Client                                Server
                  :         Direct Read Request         :
             Send :   ------------------------------>   : untagged
                  :                                     :  buffer
                  :               Segment               :
          tagged  :   <------------------------------   :  RDMA Write
          buffer  :                  :                  :
                  :              [Segment]              :
          tagged  :   <------------------------------   : [RDMA Write]
          buffer  :                                     :
                  :         Direct Read Response        :
         untagged :   <------------------------------   :  Send (w/Inv.)
          buffer  :                                     :






               Client                                Server
                  :        Direct Write Request         :
             Send :   ------------------------------>   : untagged
                  :                                     :  buffer
                  :               Segment               :
          tagged  :   v------------------------------   :  RDMA Read
          buffer  :   +----------------------------->   :
                  :                  :                  :
                  :              [Segment]              :
          tagged  :   v------------------------------   : [RDMA Read]
          buffer  :   +----------------------------->   :
                  :                                     :
                  :        Direct Write Response        :
         untagged :   <------------------------------   :  Send (w/Inv.)
          buffer  :                                     :


3.4  Connection Models

   There are three scenarios in which to discuss the connection model.
   Each will be discussed individually, after describing the common case
   encountered at initial connection establishment.

   After a successful connection, the first request proceeds, in the
   case of a new client association, to initial session creation, and
   then optionally to session callback channel binding, prior to regular
   operation.



Shepler                   Expires June 15, 2006                [Page 26]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Commonly, each new client "mount" will be the action which drives
   creation of a new session.  However there are any number of other
   approaches.  Clients may choose to share a single connection and
   session among all their mount points.  Or, clients may support
   trunking, where additional connections are created but all within a
   single session.  Alternatively, the client may choose to create
   multiple sessions, each tuned to the buffering and reliability needs
   of the mount point.  For example, a readonly mount can sharply reduce
   its write buffering and also makes no requirement for the server to
   support reliable duplicate request caching.

   Similarly, the client can choose among several strategies for
   clientid usage.  Sessions can share a single clientid, or create new
   clientids as the client deems appropriate.  For kernel-based clients
   which service multiple authenticated users, a single clientid shared
   across all mount points is generally the most appropriate and
   flexible approach.  For example, all the client's file operations may
   wish to share locking state and the local client kernel takes the
   responsibility for arbitrating access locally.  For clients choosing
   to support other authentication models, perhaps example userspace
   implementations, a new clientid is indicated.  Through use of session
   create options, both models are supported at the client's choice.

   Since the session is explicitly created and destroyed by the client,
   and each client is uniquely identified, the server may be
   specifically instructed to discard unneeded presistent state.  For
   this reason, it is possible that a server will retain any previous
   state indefinitely, and place its destruction under administrative
   control.  Or, a server may choose to retain state for some
   configurable period, provided that the period meets other NFSv4
   requirements such as lease reclamation time, etc.  However, since
   discarding this state at the server may affect the correctness of the
   server as seen by the client across network partitioning, such
   discarding of state should be done only in a conservative manner.

   Each client request to the server carries a new SEQUENCE operation
   within each COMPOUND, which provides the session context.  This
   session context then governs the request control, duplicate request
   caching, and other persistent parameters managed by the server for a
   session.

3.4.1  TCP Connection Model

   The following is a schematic diagram of the NFSv4.1 protocol
   exchanges leading up to normal operation on a TCP stream.






Shepler                   Expires June 15, 2006                [Page 27]

Internet-Draft           NFSv4 Minior Version 1            December 2005


               Client                                Server
          TCPmode :   Create Clientid(nfs_client_id4)   : TCPmode
                  :   ------------------------------>   :
                  :                                     :
                  :     Clientid reply(clientid, ...)   :
                  :   <------------------------------   :
                  :                                     :
                  :   Create Session(clientid, size S,  :
                  :      maxreq N, STREAM, ...)         :
                  :   ------------------------------>   :
                  :                                     :
                  :   Session reply(sessionid, size S', :
                  :      maxreq N')                     :
                  :   <------------------------------   :
                  :                                     :
                  :          <normal operation>         :
                  :   ------------------------------>   :
                  :   <------------------------------   :
                  :                  :                  :

   No net additional exchange is added to the initial negotiation by
   this proposal.  In the NFSv4.1 exchange, the CREATECLIENTID replaces
   SETCLIENTID (eliding the callback "clientaddr4" addressing) and
   CREATESESSION subsumes the function of SETCLIENTID_CONFIRM, as
   described elsewhere in this document.  Callback channel binding is
   optional, as in NFSv4.0.  Note that the STREAM transport type is
   shown above, but since the transport mode remains unchanged and
   transport attributes are not necessarily exchanged, DEFAULT could
   also be passed.

3.4.2  Negotiated RDMA Connection Model

   One possible design which has been considered is to have a
   "negotiated" RDMA connection model, supported via use of a session
   bind operation as a required first step.  However due to issues
   mentioned earlier, this proved problematic.  This section remains as
   a reminder of that fact, and it is possible such a mode can be
   supported.

   It is not considered critical that this be supported for two reasons.
   One, the session persistence provides a way for the server to
   remember important session parameters, such as sizes and maximum
   request counts.  These values can be used to restore the endpoint
   prior to making the first reply.  Two, there are currently no
   critical RDMA parameters to set in the endpoint at the server side of
   the connection.  RDMA Read resources, which are in general not
   settable after entering RDMA mode, are set only at the client - the
   originator of the connection.  Therefore as long as the RDMA provider



Shepler                   Expires June 15, 2006                [Page 28]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   supports an automatic RDMA connection mode, no further support is
   required from the NFSv4.1 protocol for reconnection.

   Note, the client must provide at least as many RDMA Read resources to
   its local queue for the benefit of the server when reconnecting, as
   it used when negotiating the session.  If this value is no longer
   appropriate, the client should resynchronize its session state,
   destroy the existing session, and start over with the more
   appropriate values.

3.4.3  Automatic RDMA Connection Model

   The following is a schematic diagram of the NFSv4.1 protocol
   exchanges performed on an RDMA connection.

             Client                                Server
       RDMAmode :                  :                  : RDMAmode
                :                  :                  :
       Prepost  :                  :                  : Prepost
       receive  :                  :                  : receive
                :                                     :
                :   Create Clientid(nfs_client_id4)   :
                :   ------------------------------>   :
                :                                     : Prepost
                :     Clientid reply(clientid, ...)   : receive
                :   <------------------------------   :
       Prepost  :                                     :
       receive  :   Create Session(clientid, size S,  :
                :      maxreq N, RDMA ...)            :
                :   ------------------------------>   :
                :                                     : Prepost <=N'
                :   Session reply(sessionid, size S', :     receives of
                :      maxreq N')                     :     size S'
                :   <------------------------------   :
                :                                     :
                :          <normal operation>         :
                :   ------------------------------>   :
                :   <------------------------------   :
                :                  :                  :


3.5  Buffer Management, Transfer, Flow Control

   Inline operations in NFSv4.1 behave effectively the same as TCP
   sends.  Procedure results are passed in a single message, and its
   completion at the client signal the receiving process to inspect the
   message.




Shepler                   Expires June 15, 2006                [Page 29]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   RDMA operations are performed solely by the server in this proposal,
   as described in the previous "RDMA Direct Model" section.  Since
   server RDMA operations do not result in a completion at the client,
   and due to ordering rules in RDMA transports, after all required RDMA
   operations are complete, a Send (Send with Solicited Event for iWARP)
   containing the procedure results is performed from server to client.
   This Send operation will result in a completion which will signal the
   client to inspect the message.

   In the case of client read-type NFSv4 operations, the server will
   have issued RDMA Writes to transfer the resulting data into client-
   advertised buffers.  The subsequent Send operation performs two
   necessary functions: finalizing any active or pending DMA at the
   client, and signaling the client to inspect the message.

   In the case of client write-type NFSv4 operations, the server will
   have issued RDMA Reads to fetch the data from the client-advertised
   buffers.  No data consistency issues arise at the client, but the
   completion of the transfer must be acknowledged, again by a Send from
   server to client.

   In either case, the client advertises buffers for direct (RDMA style)
   operations.  The client may desire certain advertisement limits, and
   may wish the server to perform remote invalidation on its behalf when
   the server has completed its RDMA.  This may be considered in a
   future version of this draft.

   In the absence of remote invalidation, the client may perform its
   own, local invalidation after the operation completes.  This
   invalidation should occur prior to any RPCSEC GSS integrity checking,
   since a validly remotely accessible buffer can possibly be modified
   by the peer.  However, after invalidation and the contents integrity
   checked, the contents are locally secure.

   Credit updates over RDMA transports are supported at the RPC layer as
   described in [RPCRDMA].  In each request, the client requests a
   desired number of credits to be made available to the connection on
   which it sends the request.  The client must not send more requests
   than the number which the server has previously advertised, or in the
   case of the first request, only one.  If the client exceeds its
   credit limit, the connection may close with a fatal RDMA error.

   The server then executes the request, and replies with an updated
   credit count accompanying its results.  Since replies are sequenced
   by their RDMA Send order, the most recent results always reflect the
   server's limit.  In this way the client will always know the maximum
   number of requests it may safely post.




Shepler                   Expires June 15, 2006                [Page 30]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Because the client requests an arbitrary credit count in each
   request, it is relatively easy for the client to request more, or
   fewer, credits to match its expected need.  A client that discovered
   itself frequently queuing outgoing requests due to lack of server
   credits might increase its requested credits proportionately in
   response.  Or, a client might have a simple, configurable number.
   The protocol also provides a per-operation "maxslot" exchange to
   assist in dynamic adjustment at the session level, described in a
   later section.

   Occasionally, a server may wish to reduce the total number of credits
   it offers a certain client on a connection.  This could be
   encountered if a client were found to be consuming its credits
   slowly, or not at all.  A client might notice this itself, and reduce
   its requested credits in advance, for instance requesting only the
   count of operations it currently has queued, plus a few as a base for
   starting up again.  Such mechanisms can, however, be potentially
   complicated and are implementation-defined.  The protocol does not
   require them.

   Because of the way in which RDMA fabrics function, it is not possible
   for the server (or client back channel) to cancel outstanding receive
   operations.  Therefore, effectively only one credit can be withdrawn
   per receive completion.  The server (or client back channel) would
   simply not replenish a receive operation when replying.  The server
   can still reduce the available credit advertisement in its replies to
   the target value it desires, as a hint to the client that its credit
   target is lower and it should expect it to be reduced accordingly.
   Of course, even if the server could cancel outstanding receives, it
   cannot do so, since the client may have already sent requests in
   expectation of the previous limit.

   This brings out an interesting scenario similar to the client
   reconnect discussed earlier in "Connection Models".  How does the
   server reduce the credits of an inactive client?

   One approach is for the server to simply close such a connection and
   require the client to reconnect at a new credit limit.  This is
   acceptable, if inefficient, when the connection setup time is short
   and where the server supports persistent session semantics.

   A better approach is to provide a back channel request to return the
   operations channel credits.  The server may request the client to
   return some number of credits, the client must comply by performing
   operations on the operations channel, provided of course that the
   request does not drop the client's credit count to zero (in which
   case the connection would deadlock).  If the client finds that it has
   no requests with which to consume the credits it was previously



Shepler                   Expires June 15, 2006                [Page 31]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   granted, it must send zero-length Send RDMA operations, or NULL NFSv4
   operations in order to return the resources to the server.  If the
   client fails to comply in a timely fashion, the server can recover
   the resources by breaking the connection.

   While in principle, the back channel credits could be subject to a
   similar resource adjustment, in practice this is not an issue, since
   the back channel is used purely for control and is expected to be
   statically provisioned.

   It is important to note that in addition to maximum request counts,
   the sizes of buffers are negotiated per-session.  This permits the
   most efficient allocation of resources on both peers.  There is an
   important requirement on reconnection: the sizes posted by the server
   at reconnect must be at least as large as previously used, to allow
   recovery.  Any replies that are replayed from the server's duplicate
   request cache must be able to be received into client buffers.  In
   the case where a client has received replies to all its retried
   requests (and therefore received all its expected responses), then
   the client may disconnect and reconnect with different buffers at
   will, since no cache replay will be required.

3.6  Retry and Replay

   NFSv4.0 forbids retransmission on active connections over reliable
   transports;  this includes connected-mode RDMA.  This restriction
   must be maintained in NFSv4.1.

   If one peer were to retransmit a request (or reply), it would consume
   an additional credit on the other.  If the server retransmitted a
   reply, it would certainly result in an RDMA connection loss, since
   the client would typically only post a single receive buffer for each
   request.  If the client retransmitted a request, the additional
   credit consumed on the server might lead to RDMA connection failure
   unless the client accounted for it and decreased its available
   credit, leading to wasted resources.

   RDMA credits present a new issue to the duplicate request cache in
   NFSv4.1.  The request cache may be used when a connection within a
   session is lost, such as after the client reconnects.  Credit
   information is a dynamic property of the connection, and stale values
   must not be replayed from the cache.  This implies that the request
   cache contents must not be blindly used when replies are issued from
   it, and credit information appropriate to the channel must be
   refreshed by the RPC layer.

   Finally, RDMA fabrics do not guarantee that the memory handles
   (Steering Tags) within each rdma three-tuple are valid on a scope



Shepler                   Expires June 15, 2006                [Page 32]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   outside that of a single connection.  Therefore, handles used by the
   direct operations become invalid after connection loss.  The server
   must ensure that any RDMA operations which must be replayed from the
   request cache use the newly provided handle(s) from the most recent
   request.

3.7  The Back Channel

   The NFSv4 callback operations present a significant resource problem
   for the RDMA enabled client.  Clearly, callbacks must be negotiated
   in the way credits are for the ordinary operations channel for
   requests flowing from client to server.  But, for callbacks to arrive
   on the same RDMA endpoint as operation replies would require
   dedicating additional resources, and specialized demultiplexing and
   event handling.  Or, callbacks may not require RDMA sevice at all
   (they do not normally carry substantial data payloads).  It is highly
   desirable to streamline this critical path via a second
   communications channel.

   The session callback channel binding facility is designed for exactly
   such a situation, by dynamically associating a new connected endpoint
   with the session, and separately negotiating sizes and counts for
   active callback channel operations.  The binding operation is
   firewall-friendly since it does not require the server to initiate
   the connection.

   This same method serves as well for ordinary TCP connection mode.  It
   is expected that all NFSv4.1 clients may make use of the session
   facility to streamline their design.

   The back channel functions exactly the same as the operations channel
   except that no RDMA operations are required to perform transfers,
   instead the sizes are required to be sufficiently large to carry all
   data inline, and of course the client and server reverse their roles
   with respect to which is in control of credit management.  The same
   rules apply for all transfers, with the server being required to flow
   control its callback requests.

   The back channel is optional.  If not bound on a given session, the
   server must not issue callback operations to the client.  This in
   turn implies that such a client must never put itself in the
   situation where the server will need to do so, lest the client lose
   its connection by force, or its operation be incorrect.  For the same
   reason, if a back channel is bound, the client is subject to
   revocation of its delegations if the back channel is lost.  Any
   connection loss should be corrected by the client as soon as
   possible.




Shepler                   Expires June 15, 2006                [Page 33]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   This can be convenient for the NFSv4.1 client; if the client expects
   to make no use of back channel facilities such as delegations, then
   there is no need to create it.  This may save significant resources
   and complexity at the client.

   For these reasons, if the client wishes to use the back channel, that
   channel must be bound first, before using the operations channel.  In
   this way, the server will not find itself in a position where it will
   send callbacks on the operations channel when the client is not
   prepared for them.

   There is one special case, that where the back channel is bound in
   fact to the operations channel's connection.  This configuration
   would be used normally over a TCP stream connection to exactly
   implement the NFSv4.0 behavior, but over RDMA would require complex
   resource and event management at both sides of the connection.  The
   server is not required to accept such a bind request on an RDMA
   connection for this reason, though it is recommended.

3.8  COMPOUND Sizing Issues

   Very large responses may pose duplicate request cache issues.  Since
   servers will want to bound the storage required for such a cache, the
   unlimited size of response data in COMPOUND may be troublesome.  If
   COMPOUND is used in all its generality, then the inclusion of certain
   non-idempotent operations within a single COMPOUND request may render
   the entire request non-idempotent.  (For example, a single COMPOUND
   request which read a file or symbolic link, then removed it, would be
   obliged to cache the data in order to allow identical replay).
   Therefore, many requests might include operations that return any
   amount of data.

   It is not satisfactory for the server to reject COMPOUNDs at will
   with NFS4ERR_RESOURCE when they pose such difficulties for the
   server, as this results in serious interoperability problems.
   Instead, any such limits must be explicitly exposed as attributes of
   the session, ensuring that the server can explicitly support any
   duplicate request cache needs at all times.

3.9  Data Alignment

   A negotiated data alignment enables certain scatter/gather
   optimizations.  A facility for this is supported by [RPCRDMA].  Where
   NFS file data is the payload, specific optimizations become highly
   attractive.

   Header padding is requested by each peer at session initiation, and
   may be zero (no padding).  Padding leverages the useful property that



Shepler                   Expires June 15, 2006                [Page 34]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   RDMA receives preserve alignment of data, even when they are placed
   into anonymous (untagged) buffers.  If requested, client inline
   writes will insert appropriate pad bytes within the request header to
   align the data payload on the specified boundary.  The client is
   encouraged to be optimistic and simply pad all WRITEs within the RPC
   layer to the negotiated size, in the expectation that the server can
   use them efficiently.

   It is highly recommended that clients offer to pad headers to an
   appropriate size.  Most servers can make good use of such padding,
   which allows them to chain receive buffers in such a way that any
   data carried by client requests will be placed into appropriate
   buffers at the server, ready for filesystem processing.  The
   receiver's RPC layer encounters no overhead from skipping over pad
   bytes, and the RDMA layer's high performance makes the insertion and
   transmission of padding on the sender a significant optimization.  In
   this way, the need for servers to perform RDMA Read to satisfy all
   but the largest client writes is obviated.  An added benefit is the
   reduction of message roundtrips on the network - a potentially good
   trade, where latency is present.

   The value to choose for padding is subject to a number of criteria.
   A primary source of variable-length data in the RPC header is the
   authentication information, the form of which is client-determined,
   possibly in response to server specification.  The contents of
   COMPOUNDs, sizes of strings such as those passed to RENAME, etc. all
   go into the determination of a maximal NFSv4 request size and
   therefore minimal buffer size.  The client must select its offered
   value carefully, so as not to overburden the server, and vice- versa.
   The payoff of an appropriate padding value is higher performance.

                    Sender gather:
        |RPC Request|Pad bytes|Length| -> |User data...|
        \------+---------------------/       \
                \                             \
                 \    Receiver scatter:        \-----------+- ...
            /-----+----------------\            \           \
            |RPC Request|Pad|Length|   ->  |FS buffer|->|FS buffer|->...

   In the above case, the server may recycle unused buffers to the next
   posted receive if unused by the actual received request, or may pass
   the now-complete buffers by reference for normal write processing.
   For a server which can make use of it, this removes any need for data
   copies of incoming data, without resorting to complicated end-to-end
   buffer advertisement and management.  This includes most kernel-based
   and integrated server designs, among many others.  The client may
   perform similar optimizations, if desired.




Shepler                   Expires June 15, 2006                [Page 35]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Padding is negotiated by the session creation operation, and
   subsequently used by the RPC RDMA layer, as described in [RPCRDMA].

3.10  NFSv4 Integration

   The following section discusses the integration of the proposed RDMA
   extensions with NFSv4.0.

3.10.1  Minor Versioning

   Minor versioning is the existing facility to extend the NFSv4
   protocol, and this proposal takes that approach.

   Minor versioning of NFSv4 is relatively restrictive, and allows for
   tightly limited changes only.  In particular, it does not permit
   adding new "procedures" (it permits adding only new "operations").
   Interoperability concerns make it impossible to consider additional
   layering to be a minor revision.  This somewhat limits the changes
   that can be proposed when considering extensions.

   To support the duplicate request cache integrated with sessions and
   request control, it is desirable to tag each request with an
   identifier to be called a Slotid.  This identifier must be passed by
   NFSv4 when running atop any transport, including traditional TCP.
   Therefore it is not desirable to add the Slotid to a new RPC
   transport, even though such a transport is indicated for support of
   RDMA.  This draft and [RPCRDMA] do not propose such an approach.

   Instead, this proposal conforms to the requirements of NFSv4 minor
   versioning, through the use of a new operation within NFSv4 COMPOUND
   procedures as detailed below.

   If sessions are in use for a given clientid, this same clientid
   cannot be used for non-session NFSv4 operation, including NFSv4.0.
   Because the server will have allocated session-specific state to the
   active clientid, it would be an unnecessary burden on the server
   implementor to support and account for additional, non- session
   traffic, in addition to being of no benefit.  Therefore this proposal
   prohibits a single clientid from doing this.  Nevertheless, employing
   a new clientid for such traffic is supported.

3.10.2  Slot Identifiers and Server Duplicate Request Cache

   The presence of deterministic maximum request limits on a session
   enables in-progress requests to be assigned unique values with useful
   properties.

   The RPC layer provides a transaction ID (xid), which, while required



Shepler                   Expires June 15, 2006                [Page 36]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   to be unique, is not especially convenient for tracking requests.
   The transaction ID is only meaningful to the issuer (client), it
   cannot be interpreted at the server except to test for equality with
   previously issued requests.  Because RPC operations may be completed
   by the server in any order, many transaction IDs may be outstanding
   at any time.  The client may therefore perform a computationally
   expensive lookup operation in the process of demultiplexing each
   reply.

   In the proposal, there is a limit to the number of active requests.
   This immediately enables a convenient, computationally efficient
   index for each request which is designated as a Slot Identifier, or
   slotid.

   When the client issues a new request, it selects a slotid in the
   range 0..N-1, where N is the server's current "totalrequests" limit
   granted the client on the session over which the request is to be
   issued.  The slotid must be unused by any of the requests which the
   client has already active on the session.  "Unused" here means the
   client has no outstanding request for that slotid.  Because the slot
   id is always an integer in the range 0..N-1, client implementations
   can use the slotid from a server response to efficiently match
   responses with outstanding requests, such as, for example, by using
   the slotid to index into a outstanding request array.  This can be
   used to avoid expensive hashing and lookup functions in the
   performace-critical receive path.

   The sequenceid, which accompanies the slotid in each request, is
   important for a second, important check at the server: it must be
   able to be determined efficiently whether a request using a certain
   slotid is a retransmit or a new, never-before-seen request.  It is
   not feasible for the client to assert that it is retransmitting to
   implement this, because for any given request the client cannot know
   the server has seen it unless the server actually replies.  Of
   course, if the client has seen the server's reply, the client would
   not retransmit!

   The sequenceid must increase monotonically for each new transmit of a
   given slotid, and must remain unchanged for any retransmission.  The
   server must in turn compare each newly received request's sequenceid
   with the last one previously received for that slotid, to see if the
   new request is:

      A new request, in which the sequenceid is greater than that
      previously seen in the slot (accounting for sequence wraparound).
      The server proceeds to execute the new request.





Shepler                   Expires June 15, 2006                [Page 37]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      A retransmitted request, in which the sequenceid is equal to that
      last seen in the slot.  Note that this request may be either
      complete, or in progress.  The server performs replay processing
      in these cases.

      A misordered duplicate, in which the sequenceid is less than that
      previously seen in the slot.  The server must drop the incoming
      request, which may imply dropping the connection if the transport
      is reliable, as dictated by section 3.1.1 of [RFC3530].

   This last condition is possible on any connection, not just
   unreliable, unordered transports.  Delayed behavior on abandoned TCP
   connections which are not yet closed at the server, or pathological
   client implementations can cause it, among other causes.  Therefore,
   the server may wish to harden itself against certain repeated
   occurrences of this, as it would for retransmissions in [RFC3530].

   It is recommended, though not necessary for protocol correctness,
   that the client simply increment the sequenceid by one for each new
   request on each slotid.  This reduces the wraparound window to a
   minimum, and is useful for tracing and avoidance of possible
   implementation errors.

   The client may however, for implementation-specific reasons, choose a
   different algorithm.  For example it might maintain a single sequence
   space for all slots in the session - e.g. employing the RPC XID
   itself.  The sequenceid, in any case, is never interpreted by the
   server for anything but to test by comparison with previously seen
   values.

   The server may thereby use the slotid, in conjunction with the
   sessionid and sequenceid, within the SEQUENCE portion of the request
   to maintain its duplicate request cache (DRC) for the session, as
   opposed to the traditional approach of ONC RPC applications that use
   the XID along with certain transport information [RW96].

   Unlike the XID, the slotid is always within a specific range;  this
   has two implications.  The first implication is that for a given
   session, the server need only cache the results of a limited number
   of COMPOUND requests.  The second implication derives from the first,
   which is unlike XID-indexed DRCs, the slotid DRC by its nature cannot
   be overflowed.  Through use of the sequenceid to identify
   retransmitted requests, it is notable that the server does not need
   to actually cache the request itself, reducing the storage
   requirements of the DRC further.  These new facilities makes it
   practical to maintain all the required entries for an effective DRC.

   The slotid and sequenceid therefore take over the traditional role of



Shepler                   Expires June 15, 2006                [Page 38]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   the port number in the server DRC implementation, and the session
   replaces the IP address.  This approach is considerably more portable
   and completely robust - it is not subject to the frequent
   reassignment of ports as clients reconnect over IP networks.  In
   addition, the RPC XID is not used in the reply cache, enhancing
   robustness of the cache in the face of any rapid reuse of XIDs by the
   client.

   It is required to encode the slotid information into each request in
   a way that does not violate the minor versioning rules of the NFSv4.0
   specification.  This is accomplished here by encoding it in a control
   operation within each NFSv4.1 COMPOUND and CB_COMPOUND procedure.
   The operation easily piggybacks within existing messages.  The
   implementation section of this document describes the specific
   proposal.

   In general, the receipt of a new sequenced request arriving on any
   valid slot is an indication that the previous DRC contents of that
   slot may be discarded.  In order to further assist the server in slot
   management, the client is required to use the lowest available slot
   when issuing a new request.  In this way, the server may be able to
   retire additional entries.

   However, in the case where the server is actively adjusting its
   granted maximum request count to the client, it may not be able to
   use receipt of the slotid to retire cache entries.  The slotid used
   in an incoming request may not reflect the server's current idea of
   the client's session limit, because the request may have been sent
   from the client before the update was received.  Therefore, in the
   downward adjustment case, the server may have to retain a number of
   duplicate request cache entries at least as large as the old value,
   until operation sequencing rules allow it to infer that the client
   has seen its reply.

   The SEQUENCE (and CB_SEQUENCE) operation also carries a "maxslot"
   value which carries additional client slot usage information.  The
   client must always provide its highest-numbered outstanding slot
   value in the maxslot argument, and the server may reply with a new
   recognized value.  The client should in all cases provide the most
   conservative value possible, although it can be increased somewhat
   above the actual instantaneous usage to maintain some minimum or
   optimal level.  This provides a way for the client to yield unused
   request slots back to the server, which in turn can use the
   information to reallocate resources.  Obviously, maxslot can never be
   zero, or the session would deadlock.

   The server also provides a target maxslot value to the client, which
   is an indication to the client of the maxslot the server wishes the



Shepler                   Expires June 15, 2006                [Page 39]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   client to be using.  This permits the server to withdraw (or add)
   resources from a client that has been found to not be using them, in
   order to more fairly share resources among a varying level of demand
   from other clients.  The client must always comply with the server's
   value updates, since they indicate newly established hard limits on
   the client's access to session resources.  However, because of
   request pipelining, the client may have active requests in flight
   reflecting prior values, therefore the server must not immediately
   require the client to comply.

   It is worthwhile to note that Sprite RPC [BW87] defined a "channel"
   which in some ways is similar to the slotid proposed here.  Sprite
   RPC used channels to implement parallel request processing and
   request/response cache retirement.

3.10.3  COMPOUND and CB_COMPOUND

   Support for per-operation control can be piggybacked onto NFSv4
   COMPOUNDs with full transparency, by placing such facilities into
   their own, new operation, and placing this operation first in each
   COMPOUND under the new NFSv4 minor protocol revision.  The contents
   of the operation would then apply to the entire COMPOUND.

   Recall that the NFSv4 minor revision is contained within the COMPOUND
   header, encoded prior to the COMPOUNDed operations.  By simply
   requiring that the new operation always be contained in NFSv4 minor
   COMPOUNDs, the control protocol can piggyback perfectly with each
   request and response.

   In this way, the NFSv4 RDMA Extensions may stay in compliance with
   the minor versioning requirements specified in section 10 of
   [RFC3530].

   Referring to section 13.1 of the same document, the proposed session-
   enabled COMPOUND and CB_COMPOUND have the form:

      +-----+--------------+-----------+------------+-----------+----
      | tag | minorversion | numops    | control op | op + args | ...
      |     |   (== 1)     | (limited) |  + args    |           |
      +-----+--------------+-----------+------------+-----------+----

      and the reply's structure is:

      +------------+-----+--------+-------------------------------+--//
      |last status | tag | numres | status + control op + results |  //
      +------------+-----+--------+-------------------------------+--//
              //-----------------------+----
              // status + op + results | ...



Shepler                   Expires June 15, 2006                [Page 40]

Internet-Draft           NFSv4 Minior Version 1            December 2005


              //-----------------------+----

   The single control operation within each NFSv4.1 COMPOUND defines the
   context and operational session parameters which govern that COMPOUND
   request and reply.  Placing it first in the COMPOUND encoding is
   required in order to allow its processing before other operations in
   the COMPOUND.

3.10.4  eXternal Data Representation Efficiency

   RDMA is a copy avoidance technology, and it is important to maintain
   this efficiency when decoding received messages.  Traditional XDR
   implementations frequently use generated unmarshaling code to convert
   objects to local form, incurring a data copy in the process (in
   addition to subjecting the caller to recursive calls, etc).  Often,
   such conversions are carried out even when no size or byte order
   conversion is necessary.

   It is recommended that implementations pay close attention to the
   details of memory referencing in such code.  It is far more efficient
   to inspect data in place, using native facilities to deal with word
   size and byte order conversion into registers or local variables,
   rather than formally (and blindly) performing the operation via
   fetch, reallocate and store.

   Of particular concern is the result of the READDIR operation, in
   which such encoding abounds.

3.10.5  Effect of Sessions on Existing Operations

   The use of a session replaces the use of the SETCLIENTID and
   SETCLIENTID_CONFIRM operations, and allows certain simplification of
   the RENEW and callback addressing mechanisms in the base protocol.

   The cb_program and cb_location which are obtained by the server in
   SETCLIENTID_CONFIRM must not be used by the server, because the
   NFSv4.1 client performs callback channel designation with
   BIND_BACKCHANNEL.  Therefore the SETCLIENTID and SETCLIENTID_CONFIRM
   operations becomes obsolete when sessions are in use, and a server
   should return an error to NFSv4.1 clients which might issue either
   operation.

   Another favorable result of the session is that the server is able to
   avoid requiring the client to perform OPEN_CONFIRM operations.  The
   existence of a reliable and effective DRC means that the server will
   be able to determine whether an OPEN request carrying a previously
   known open_owner from a client is or is not a retransmission.
   Because of this, the server no longer requires OPEN_CONFIRM to verify



Shepler                   Expires June 15, 2006                [Page 41]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   whether the client is retransmitting an open request.  This in turn
   eliminates the server's reason for requesting OPEN_CONFIRM - the
   server can simply replace any previous information on this
   open_owner.  Client OPEN operations are therefore streamlined,
   reducing overhead and latency through avoiding the additional
   OPEN_CONFIRM exchange.

   Since the session carries the client liveness indication with it
   implicitly, any request on a session associated with a given client
   will renew that client's leases.  Therefore the RENEW operation is
   made unnecessary when a session is present, as any request (including
   a SEQUENCE operation with or without additional NFSv4 operations)
   performs its function.  It is possible (though this proposal does not
   make any recommendation) that the RENEW operation could be made
   obsolete.

   An interesting issue arises however if an error occurs on such a
   SEQUENCE operation.  If the SEQUENCE operation fails, perhaps due to
   an invalid slotid or other non-renewal-based issue, the server may or
   may not have performed the RENEW.  In this case, the state of any
   renewal is undefined, and the client should make no assumption that
   it has been performed.  In practice, this should not occur but even
   if it did, it is expected the client would perform some sort of
   recovery which would result in a new, successful, SEQUENCE operation
   being run and the client assured that the renewal took place.

3.10.6  Authentication Efficiencies

   NFSv4 requires the use of the RPCSEC_GSS ONC RPC security flavor
   [RFC2203] to provide authentication, integrity, and privacy via
   cryptography.  The server dictates to the client the use of
   RPCSEC_GSS, the service (authentication, integrity, or privacy), and
   the specific GSS-API security mechanism that each remote procedure
   call and result will use.

   If the connection's integrity is protected by an additional means
   than RPCSEC_GSS, such as via IPsec, then the use of RPCSEC_GSS's
   integrity service is nearly redundant (See the Security
   Considerations section for more explanation of why it is "nearly" and
   not completely redundant).  Likewise, if the connection's privacy is
   protected by additional means, then the use of both RPCSEC_GSS's
   integrity and privacy services is nearly redundant.

   Connection protection schemes, such as IPsec, are more likely to be
   implemented in hardware than upper layer protocols like RPCSEC_GSS.
   Hardware-based cryptography at the IPsec layer will be more efficient
   than software-based cryptography at the RPCSEC_GSS layer.




Shepler                   Expires June 15, 2006                [Page 42]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   When transport integrity can be obtained, it is possible for server
   and client to downgrade their per-operation authentication, after an
   appropriate exchange.  This downgrade can in fact be as complete as
   to establish security mechanisms that have zero cryptographic
   overhead, effectively using the underlying integrity and privacy
   services provided by transport.

   Based on the above observations, a new GSS-API mechanism, called the
   Channel Conjunction Mechanism [CCM], is being defined.  The CCM works
   by creating a GSS-API security context using as input a cookie that
   the initiator and target have previously agreed to be a handle for
   GSS-API context created previously over another GSS-API mechanism.

   NFSv4.1 clients and servers should support CCM and they must use as
   the cookie the handle from a successful RPCSEC_GSS context creation
   over a non-CCM mechanism (such as Kerberos V5).  The value of the
   cookie will be equal to the handle field of the rpc_gss_init_res
   structure from the RPCSEC_GSS specification.

   The [CCM] Draft provides further discussion and examples.

3.11  Sessions Security Considerations

   The NFSv4 minor version 1 retains all of existing NFSv4 security; all
   security considerations present in NFSv4.0 apply to it equally.

   Security considerations of any underlying RDMA transport are
   additionally important, all the more so due to the emerging nature of
   such transports.  Examining these issues is outside the scope of this
   draft.

   When protecting a connection with RPCSEC_GSS, all data in each
   request and response (whether transferred inline or via RDMA)
   continues to receive this protection over RDMA fabrics [RPCRDMA].
   However when performing data transfers via RDMA, RPCSEC_GSS
   protection of the data transfer portion works against the efficiency
   which RDMA is typically employed to achieve.  This is because such
   data is normally managed solely by the RDMA fabric, and intentionally
   is not touched by software.  Therefore when employing RPCSEC_GSS
   under CCM, and where integrity protection has been "downgraded", the
   cooperation of the RDMA transport provider is critical to maintain
   any integrity and privacy otherwise in place for the session.  The
   means by which the local RPCSEC_GSS implementation is integrated with
   the RDMA data protection facilities are outside the scope of this
   draft.

   It is logical to use the same GSS context on a session's callback
   channel as that used on its operations channel(s), particularly when



Shepler                   Expires June 15, 2006                [Page 43]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   the connection is shared by both.  The client must indicate to the
   server:

   - what security flavor(s) to use in the call back.  A special
   callback flavor might be defined for this.

   - if the flavor is RPCSEC_GSS, then the client must have previously
   created an RPCSEC_GSS session with the server.  The client offers to
   the server the the opaque handle<> value from the rpc_gss_init_res
   structure, the window size of RPCSEC_GSS sequence numbers, and an
   opaque gss_cb_handle.

   This exchange can be performed as part of session and clientid
   creation, and the issue warrants careful analysis before being
   specified.

   If the NFS client wishes to maintain full control over RPCSEC_GSS
   protection, it may still perform its transfer operations using either
   the inline or RDMA transfer model, or of course employ traditional
   TCP stream operation.  In the RDMA inline case, header padding is
   recommended to optimize behavior at the server.  At the client, close
   attention should be paid to the implementation of RPCSEC_GSS
   processing to minimize memory referencing and especially copying.
   These are well-advised in any case!

   The proposed session callback channel binding improves security over
   that provided by NFSv4 for the callback channel.  The connection is
   client-initiated, and subject to the same firewall and routing checks
   as the operations channel.  The connection cannot be hijacked by an
   attacker who connects to the client port prior to the intended
   server.  The connection is set up by the client with its desired
   attributes, such as optionally securing with IPsec or similar.  The
   binding is fully authenticated before being activated.

3.11.1  Authentication

   Proper authentication of the principal which issues any session and
   clientid in the proposed NFSv4.1 operations exactly follows the
   similar requirement on client identifiers in NFSv4.0.  It must not be
   possible for a client to impersonate another by guessing its session
   identifiers for NFSv4.1 operations, nor to bind a callback channel to
   an existing session.  To protect against this, NFSv4.0 requires
   appropriate authentication and matching of the principal used.  This
   is discussed in Section 16, Security Considerations of [RFC3530].
   The same requirement when using a session identifier applies to
   NFSv4.1 here.

   Going beyond NFSv4.0, the presence of a session associated with any



Shepler                   Expires June 15, 2006                [Page 44]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   clientid may also be used to enhance NFSv4.1 security with respect to
   client impersonation.  In NFSv4.0, there are many operations which
   carry no clientid, including in particular those which employ a
   stateid argument.  A rogue client which wished to carry out a denial
   of service attack on another client could perform CLOSE, DELEGRETURN,
   etc operations with that client's current filehandle, sequenceid and
   stateid, after having obtained them from eavesdropping or other
   approach.  Locking and open downgrade operations could be similarly
   attacked.

   When an NFSv4.1 session is in place for any clientid, countermeasures
   are easily applied through use of authentication by the server.
   Because the clientid and sessionid must be present in each request
   within a session, the server may verify that the clientid is in fact
   originating from a principal with the appropriate authenticated
   credentials, that the sessionid belongs to the clientid, and that the
   stateid is valid in these contexts.  This is in general not possible
   with the affected operations in NFSv4.0 due to the fact that the
   clientid is not present in the requests.

   In the event that authentication information is not available in the
   incoming request, for example after a reconnection when the security
   was previously downgraded using CCM, the server must require the
   client re-establish the authentication in order that the server may
   validate the other client-provided context, prior to executing any
   operation.  The sessionid, present in the newly retransmitted
   request, combined with the retransmission detection enabled by the
   NFSv4.1 duplicate request cache, are a convenient and reliable
   context for the server to use for this contingency.

   The server should take care to protect itself against denial of
   service attacks in the creation of sessions and clientids.  Clients
   who connect and create sessions, only to disconnect and never use
   them may leave significant state behind.  (The same issue applies to
   NFSv4.0 with clients who may perform SETCLIENTID, then never perform
   SETCLIENTID_CONFIRM.)  Careful authentication coupled with resource
   checks is highly recommended.

4.  Directory Delegations

4.1  Introduction to Directory Delegations

   The major addition to NFS version 4 in the area of caching is the
   ability of the server to delegate certain responsibilities to the
   client.  When the server grants a delegation for a file to a client,
   the client receives certain semantics with respect to the sharing of
   that file with other clients.  At OPEN, the server may provide the
   client either a read or write delegation for the file.  If the client



Shepler                   Expires June 15, 2006                [Page 45]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   is granted a read delegation, it is assured that no other client has
   the ability to write to the file for the duration of the delegation.
   If the client is granted a write delegation, the client is assured
   that no other client has read or write access to the file.  This
   reduces network traffic and server load by allowing the client to
   perform certain operations on local file data and can also provide
   stronger consistency for the local data.

   Directory caching for the NFS version 4 protocol is similar to
   previous versions.  Clients typically cache directory information for
   a duration determined by the client.  At the end of a predefined
   timeout, the client will query the server to see if the directory has
   been updated.  By caching attributes, clients reduce the number of
   GETATTR calls made to the server to validate attributes.
   Furthermore, frequently accessed files and directories, such as the
   current working directory, have their attributes cached on the client
   so that some NFS operations can be performed without having to make
   an RPC call.  By caching name and inode information about most
   recently looked up entries in DNLC (Directory Name Lookup Cache),
   clients do not need to send LOOKUP calls to the server every time
   these files are accessed.

   This caching approach works reasonably well at reducing network
   traffic in many environments.  However, it does not address
   environments where there are numerous queries for files that do not
   exist.  In these cases of "misses", the client must make RPC calls to
   the server in order to provide reasonable application semantics and
   promptly detect the creation of new directory entries.  Examples of
   high miss activity are compilation in software development
   environments.  The current behavior of NFS limits its potential
   scalability and wide-area sharing effectiveness in these types of
   environments.  Other distributed stateful filesystem architectures
   such as AFS and DFS have proven that adding state around directory
   contents can greatly reduce network traffic in high miss
   environments.

   Delegation of directory contents is proposed as an extension for
   NFSv4.  Such an extension would provide similar traffic reduction
   benefits as with file delegations.  By allowing clients to cache
   directory contents (in a read-only fashion) while being notified of
   changes, the client can avoid making frequent requests to interrogate
   the contents of slowly-changing directories, reducing network traffic
   and improving client performance.

   These extensions allow improved namespace cache consistency to be
   achieved through delegations and synchronous recalls alone without
   asking for notifications.  In addition, if time-based consistency is
   sufficient, asynchronous notifications can provide performance



Shepler                   Expires June 15, 2006                [Page 46]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   benefits for the client, and possibly the server, under some common
   operating conditions such as slowly-changing and/or very large
   directories.

4.2  Directory Delegation Design (in brief)

   A new operation GET_DIR_DELEGATION is used by the client to ask for a
   directory delegation.  The delegation covers directory attributes and
   all entries in the directory.  If either of these change the
   delegation will be recalled synchronously.  The operation causing the
   recall will have to wait before the recall is complete.  Any changes
   to directory entry attributes will not cause the delegation to be
   recalled.

   In addition to asking for delegations, a client can also ask for
   notifications for certain events.  These events include changes to
   directory attributes and/or its contents.  If a client asks for
   notification for a certain event, the server will notify the client
   when that event occurs.  This will not result in the delegation being
   recalled for that client.  The notifications are asynchronous and
   provide a way of avoiding recalls in situations where a directory is
   changing enough that the pure recall model may not be effective while
   trying to allow the client to get substantial benefit.  In the
   absence of notifications, once the delegation is recalled the client
   has to refresh its directory cache which might not be very efficient
   for very large directories.

   The delegation is read only and the client may not make changes to
   the directory other than by performing NFSv4 operations that modify
   the directory or the associated file attributes so that the server
   has knowledge of these changes.  In order to keep the client
   namespace in sync with the server, the server will notify the client
   holding the delegation of the changes made as a result.  This is to
   avoid any subsequent GETATTR or READDIR calls to the server.  If a
   client holding the delegation makes any changes to the directory, the
   delegation will not be recalled.

   Delegations can be recalled by the server at any time.  Normally, the
   server will recall the delegation when the directory changes in a way
   that is not covered by the notification, or when the directory
   changes and notifications have not been requested.

   Also if the server notices that handing out a delegation for a
   directory is causing too many notifications to be sent out, it may
   decide not to hand out a delegation for that directory or recall
   existing delegations.  If another client removes the directory for
   which a delegation has been granted, the server will recall the
   delegation.



Shepler                   Expires June 15, 2006                [Page 47]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Both the notification and recall operations need a callback path to
   exist between the client and server.  If the callback path does not
   exist, then delegation can not be granted.  Note that with the
   session extensions [talpey] that should not be an issue.  In the
   absense of sessions, the server will have to establish a callback
   path to the client to send callbacks.

4.3  Recommended Attributes in support of Directory Delegations

   supp_dir_attr_notice - notification delays on directory attributes

   supp_child_attr_notice - notification delays on child attributes

   These attributes allow the client and server to negotiate the
   frequency of notifications sent due to changes in attributes.  These
   attributes are returned as part of a GETATTR call on the directory.
   The supp_dir_attr_notice value covers all attribute changes to the
   directory and the supp_child_attr_notice covers all attribute changes
   to any child in the directory.

   These attributes are per directory.  The client needs to get these
   values by doing a GETATTR on the directory for which it wants
   notifications.  However these attributes are only required when the
   client is interested in getting attribute notifications.  For all
   other types of notifications and delegation requests without
   notifications, these attributes are not required.

   When the client calls the GET_DIR_DELEGATION operation and asks for
   attribute change notifications, it will request a notification delay
   that is within the server's supported range.  If the client violates
   what supp_attr_file_notice or supp_attr_dir_notice values are, the
   server should not commit to sending notifications for that change
   event.

   A value of zero for these attributes means the server will send the
   notification as soon as the change occurs.  It is not recommended to
   set this value to zero since that can put a lot of burden on the
   server.  A value of N means that the server will make a best effort
   guarentee that attribute notification are not delayed by more than
   that. nfstime4 values that compute to negative values are illegal.

4.4  Delegation Recall

   The server will recall the directory delegation by sending a callback
   to the client.  It will use the same callback procedure as used for
   recalling file delegations.  The server will recall the delegation
   when the directory changes in a way that is not covered by the
   notification.  However the server will not recall the delegation if



Shepler                   Expires June 15, 2006                [Page 48]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   attributes of an entry within the directory change.  Also if the
   server notices that handing out a delegation for a directory is
   causing too many notifications to be sent out, it may decide not to
   hand out a delegation for that directory.  If another client tries to
   remove the directory for which a delegation has been granted, the
   server will recall the delegation.

   The server will recall the delegation by sending a CB_RECALL callback
   to the client.  If the recall is done because of a directory changing
   event, the request making that change will need to wait while the
   client returns the delegation.

4.5  Delegation Recovery

   Crash recovery has two main goals, avoiding the necessity of breaking
   application guarantees with respect to locked files and delivery of
   updates cached at the client.  Neither of these applies to
   directories protected by read delegations and notifications.  Thus,
   the client is required to establish a new delegation on a server or
   client reboot.

5.  Introduction

   The NFSv4 protocol [2] specifies the interaction between a client
   that accesses files and a server that provides access to files and is
   responsible for coordinating access by multiple clients.  As
   described in the pNFS problem statement, this requires that all
   access to a set of files exported by a single NFSv4 server be
   performed by that server; at high data rates the server may become a
   bottleneck.

   The parallel NFS (pNFS) extensions to NFSv4 allow data accesses to
   bypass this bottleneck by permitting direct client access to the
   storage devices containing the file data.  When file data for a
   single NFSv4 server is stored on multiple and/or higher throughput
   storage devices (by comparison to the server's throughput
   capability), the result can be significantly better file access
   performance.  The relationship among multiple clients, a single
   server, and multiple storage devices for pNFS (server and clients
   have access to all storage devices) is shown in this diagram:











Shepler                   Expires June 15, 2006                [Page 49]

Internet-Draft           NFSv4 Minior Version 1            December 2005


       +-----------+
       |+-----------+                                 +-----------+
       ||+-----------+                                |           |
       |||           |        NFSv4 + pNFS            |           |
       +||  Clients  |<------------------------------>|   Server  |
        +|           |                                |           |
         +-----------+                                |           |
              |||                                     +-----------+
              |||                                           |
              |||                                           |
              ||| Storage        +-----------+              |
              ||| Protocol       |+-----------+             |
              ||+----------------||+-----------+  Control|
              |+-----------------|||           |    Protocol|
              +------------------+||  Storage  |------------+
                                  +|  Devices  |
                                   +-----------+

                                 Figure 9

   In this structure, the responsibility for coordination of file access
   by multiple clients is shared among the server, clients, and storage
   devices.  This is in contrast to NFSv4 without pNFS extensions, in
   which this is primarily the server's responsibility, some of which
   can be delegated to clients under strictly specified conditions.

   The pNFS extension to NFSv4 takes the form of new operations that
   manage data location information called a "layout".  The layout is
   managed in a similar fashion as NFSv4 data delegations (e.g., they
   are recallable and revocable).  However, they are distinct
   abstractions and are manipulated with new operations.  When a client
   holds a layout, it has rights to access the data directly using the
   location information in the layout.

   There are new attributes that describe general layout
   characteristics.  However, much of the required information cannot be
   managed solely within the attribute framework, because it will need
   to have a strictly limited term of validity, subject to invalidation
   by the server.  This requires the use of new operations to obtain,
   return, recall, and modify layouts, in addition to new attributes.

   This document specifies both the NFSv4 extensions required to
   distribute file access coordination between the server and its
   clients and a NFSv4 file storage protocol that may be used to access
   data stored on NFSv4 storage devices.

   Storage protocols used to access a variety of other storage devices
   are deliberately not specified here.  These might include:



Shepler                   Expires June 15, 2006                [Page 50]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   o  Block/volume protocols such as iSCSI ([3]), and FCP ([4]).  The
      block/volume protocol support can be independent of the addressing
      structure of the block/volume protocol used, allowing more than
      one protocol to access the same file data and enabling
      extensibility to other block/volume protocols.

   o  Object protocols such as OSD over iSCSI or Fibre Channel [5].

   o  Other storage protocols, including PVFS and other file systems
      that are in use in HPC environments.

   pNFS is designed to accommodate these protocols and be extensible to
   new classes of storage protocols that may be of interest.

   The distribution of file access coordination between the server and
   its clients increases the level of responsibility placed on clients.
   Clients are already responsible for ensuring that suitable access
   checks are made to cached data and that attributes are suitably
   propagated to the server.  Generally, a misbehaving client that hosts
   only a single-user can only impact files accessible to that single
   user.  Misbehavior by a client hosting multiple users may impact
   files accessible to all of its users.  NFSv4 delegations increase the
   level of client responsibility as a client that carries out actions
   requiring a delegation without obtaining that delegation will cause
   its user(s) to see unexpected and/or incorrect behavior.

   Some uses of pNFS extend the responsibility of clients beyond
   delegations.  In some configurations, the storage devices cannot
   perform fine-grained access checks to ensure that clients are only
   performing accesses within the bounds permitted to them by the pNFS
   operations with the server (e.g., the checks may only be possible at
   file system granularity rather than file granularity).  In situations
   where this added responsibility placed on clients creates
   unacceptable security risks, pNFS configurations in which storage
   devices cannot perform fine-grained access checks SHOULD NOT be used.
   All pNFS server implementations MUST support NFSv4 access to any file
   accessible via pNFS in order to provide an interoperable means of
   file access in such situations.  See Section 8 on Security for
   further discussion.

   Finally, there are issues about how layouts interact with the
   existing NFSv4 abstractions of data delegations and byte range
   locking.  These issues, and others, are also discussed here.

6.  General Definitions

   This protocol extension partitions the NFSv4 file system protocol
   into two parts, the control path and the data path.  The control path



Shepler                   Expires June 15, 2006                [Page 51]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   is implemented by the extended (p)NFSv4 server.  When the file system
   being exported by (p)NFSv4 uses storage devices that are visible to
   clients over the network, the data path may be implemented by direct
   communication between the extended (p)NFSv4 file system client and
   the storage devices.  This leads to a few new terms used to describe
   the protocol extension and some clarifications of existing terms.

6.1  Metadata Server

   A pNFS "server" or "metadata server" is a server as defined by
   RFC3530 [2], which additionally provides support of the pNFS minor
   extension.  When using the pNFS NFSv4 minor extension, the metadata
   server may hold only the metadata associated with a file, while the
   data can be stored on the storage devices.  However, similar to
   NFSv4, data may also be written through the metadata server.  Note:
   directory data is always accessed through the metadata server.

6.2  Client

   A pNFS "client" is a client as defined by RFC3530 [2], with the
   addition of supporting the pNFS minor extension server protocol and
   with the addition of supporting at least one storage protocol for
   performing I/O directly to storage devices.

6.3  Storage Device

   This is a device, or server, that controls the file's data, but
   leaves other metadata management up to the metadata server.  A
   storage device could be another NFS server, or an Object Storage
   Device (OSD) or a block device accessed over a SAN (e.g., either
   FiberChannel or iSCSI SAN).  The goal of this extension is to allow
   direct communication between clients and storage devices.

6.4  Storage Protocol

   This is the protocol between the pNFS client and the storage device
   used to access the file data.  Three following types have been
   described: file protocols (e.g., NFSv4), object protocols (e.g.,
   OSD), and block/volume protocols (e.g., based on SCSI-block
   commands).  These protocols are in turn realizable over a variety of
   transport stacks.  We anticipate there will be variations on these
   storage protocols, including new protocols that are unknown at this
   time or experimental in nature.  The details of the storage protocols
   will be described in other documents so that pNFS clients can be
   written to use these storage protocols.  Use of NFSv4 itself as a
   file-based storage protocol is described in Section 9.





Shepler                   Expires June 15, 2006                [Page 52]

Internet-Draft           NFSv4 Minior Version 1            December 2005


6.5  Control Protocol

   This is a protocol used by the exported file system between the
   server and storage devices.  Specification of such protocols is
   outside the scope of this draft.  Such control protocols would be
   used to control such activities as the allocation and deallocation of
   storage and the management of state required by the storage devices
   to perform client access control.  The control protocol should not be
   confused with protocols used to manage LUNs in a SAN and other
   sysadmin kinds of tasks.

   While the pNFS protocol allows for any control protocol, in practice
   the control protocol is closely related to the storage protocol.  For
   example, if the storage devices are NFS servers, then the protocol
   between the pNFS metadata server and the storage devices is likely to
   involve NFS operations.  Similarly, when object storage devices are
   used, the pNFS metadata server will likely use iSCSI/OSD commands to
   manipulate storage.

   However, this document does not mandate any particular control
   protocol.  Instead, it just describes the requirements on the control
   protocol for maintaining attributes like modify time, the change
   attribute, and the end-of-file position.

6.6  Metadata

   This is information about a file, like its name, owner, where it
   stored, and so forth.  The information is managed by the exported
   file system server (metadata server).  Metadata also includes lower-
   level information like block addresses and indirect block pointers.
   Depending the storage protocol, block-level metadata may or may not
   be managed by the metadata server, but is instead managed by Object
   Storage Devices or other servers acting as a storage device.

6.7  Layout

   A layout defines how a file's data is organized on one or more
   storage devices.  There are many possible layout types.  They vary in
   the storage protocol used to access the data, and in the aggregation
   scheme that lays out the file data on the underlying storage devices.
   Layouts are described in more detail below.

7.  pNFS protocol semantics

   This section describes the semantics of the pNFS protocol extension
   to NFSv4; this is the protocol between the client and the metadata
   server.




Shepler                   Expires June 15, 2006                [Page 53]

Internet-Draft           NFSv4 Minior Version 1            December 2005


7.1  Definitions

   This sub-section defines a number of terms necessary for describing
   layouts and their semantics.  In addition, it more precisely defines
   how layouts are identified and how they can be composed of smaller
   granularity layout segments.

7.1.1  Layout Types

   A layout describes the mapping of a file's data to the storage
   devices that hold the data.  A layout is said to belong to a specific
   "layout type" (see Section 10.1 for its RPC definition).  The layout
   type allows for variants to handle different storage protocols (e.g.,
   block/volume [6], object [7], and file [Section 9] layout types).  A
   metadata server, along with its control protocol, must support at
   least one layout type.  A private sub-range of the layout type name
   space is also defined.  Values from the private layout type range can
   be used for internal testing or experimentation.

   As an example, a file layout type could be an array of tuples (e.g.,
   deviceID, file_handle), along with a definition of how the data is
   stored across the devices (e.g., striping).  A block/volume layout
   might be an array of tuples that store <deviceID, block_number, block
   count> along with information about block size and the file offset of
   the first block.  An object layout might be an array of tuples
   <deviceID, objectID> and an additional structure (i.e., the
   aggregation map) that defines how the logical byte sequence of the
   file data is serialized into the different objects.  Note, the actual
   layouts are more complex than these simple expository examples.

   This document defines a NFSv4 file layout type using a stripe-based
   aggregation scheme (see Section 9).  Adjunct specifications are being
   drafted that precisely define other layout formats (e.g., block/
   volume [6], and object [7] layouts) to allow interoperability among
   clients and metadata servers.

7.1.2  Layout Iomode

   The iomode indicates to the metadata server the client's intent to
   perform either READs (only) or a mixture of I/O possibly containing
   WRITEs as well as READs (i.e., READ/WRITE).  For certain layout
   types, it is useful for a client to specify this intent at LAYOUTGET
   time.  E.g., for block/volume based protocols, block allocation could
   occur when a READ/WRITE iomode is specified.  A special
   LAYOUTIOMODE_ANY iomode is defined and can only be used for
   LAYOUTRETURN and LAYOUTRECALL, not for LAYOUTGET.  It specifies that
   layouts pertaining to both READ and RW iomodes are being returned or
   recalled, respectively.



Shepler                   Expires June 15, 2006                [Page 54]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   A storage device may validate I/O with regards to the iomode; this is
   dependent upon storage device implementation.  Thus, if the client's
   layout iomode differs from the I/O being performed the storage device
   may reject the client's I/O with an error indicating a new layout
   with the correct I/O mode should be fetched.  E.g., if a client gets
   a layout with a READ iomode and performs a WRITE to a storage device,
   the storage device is allowed to reject that WRITE.

   The iomode does not conflict with OPEN share modes or lock requests;
   open mode checks and lock enforcement are always enforced, and are
   logically separate from the pNFS layout level.  As well, open modes
   and locks are the preferred method for restricting user access to
   data files.  E.g., an OPEN of read, deny-write does not conflict with
   a LAYOUTGET containing an iomode of READ/WRITE performed by another
   client.  Applications that depend on writing into the same file
   concurrently may use byte range locking to serialize their accesses.

7.1.3  Layout Segments

   Until this point, layouts have been defined in a fairly vague manner.
   A layout is more precisely identified by the following tuple:
   <ClientID, FH, layout type>; the FH refers to the FH of the file on
   the metadata server.  Note, layouts describe a file, not a byte-range
   of a file.

   Since a layout that describes an entire file may be very large, there
   is a desire to manage layouts in smaller chunks that correspond to
   byte-ranges of the file.  For example, the entire layout need not be
   returned, recalled, or committed.  These chunks are called "layout
   segments" and are further identified by the byte-range they
   represent.  Layout operations require the identification of the
   layout segment (i.e., clientID, FH, layout type, and byte-range), as
   well as the iomode.  This structure allows clients and metadata
   servers to aggregate the results of layout operations into a singly
   maintained layout.

   It is important to define when layout segments overlap and/or
   conflict with each other.  For a layout segment to overlap another
   layout segment both segments must be of the same layout type,
   correspond to the same filehandle, and have the same iomode; in
   addition, the byte-ranges of the segments must overlap.  Layout
   segments conflict, when they overlap and differ in the content of the
   layout (i.e., the storage device/file mapping parameters differ).
   Note, differing iomodes do not lead to conflicting layouts.  It is
   permissible for layout segments with different iomodes, pertaining to
   the same byte range, to be held by the same client.





Shepler                   Expires June 15, 2006                [Page 55]

Internet-Draft           NFSv4 Minior Version 1            December 2005


7.1.4  Device IDs

   The "deviceID" is a short name for a storage device.  In practice, a
   significant amount of information may be required to fully identify a
   storage device.  Instead of embedding all that information in a
   layout, a level of indirection is used.  Layouts embed device IDs,
   and a new operation (GETDEVICEINFO) is used to retrieve the complete
   identity information about the storage device according to its layout
   type.  For example, the identity of a file server or object server
   could be an IP address and port.  The identity of a block device
   could be a volume label.  Due to multipath connectivity in a SAN
   environment, agreement on a volume label is considered the reliable
   way to locate a particular storage device.

   The device ID is qualified by the layout type and unique per file
   system (FSID).  This allows different layout drivers to generate
   device IDs without the need for co-ordination.  In addition to
   GETDEVICEINFO, another operation, GETDEVICELIST, has been added to
   allow clients to fetch the mappings of multiple storage devices
   attached to a metadata server.

   Clients cannot expect the mapping between device ID and storage
   device address to persist across server reboots, hence a client MUST
   fetch new mappings on startup or upon detection of a metadata server
   reboot unless it can revalidate its existing mappings.  Not all
   layout types support such revalidation, and the means of doing so is
   layout specific.  If data are reorganized from a storage device with
   a given device ID to a different storage device (i.e., if the mapping
   between storage device and data changes), the layout describing the
   data MUST be recalled rather than assigning the new storage device to
   the old device ID.

7.1.5  Aggregation Schemes

   Aggregation schemes can describe layouts like simple one-to-one
   mapping, concatenation, and striping.  A general aggregation scheme
   allows nested maps so that more complex layouts can be compactly
   described.  The canonical aggregation type for this extension is
   striping, which allows a client to access storage devices in
   parallel.  Even a one-to-one mapping is useful for a file server that
   wishes to distribute its load among a set of other file servers.

7.2  Guarantees Provided by Layouts

   Layouts delegate to the client the ability to access data out of
   band.  The layout guarantees the holder that the layout will be
   recalled when the state encapsulated by the layout becomes invalid
   (e.g., through some operation that directly or indirectly modifies



Shepler                   Expires June 15, 2006                [Page 56]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   the layout) or, possibly, when a conflicting layout is requested, as
   determined by the layout's iomode.  When a layout is recalled, and
   then returned by the client, the client retains the ability to access
   file data with normal NFSv4 I/O operations through the metadata
   server.  Only the right to do I/O out-of-band is affected.

   Holding a layout does not guarantee that a user of the layout has the
   rights to access the data represented by the layout.  All user access
   rights MUST be obtained through the appropriate open, lock, and
   access operations (i.e., those that would be used in the absence of
   pNFS).  However, if a valid layout for a file is not held by the
   client, the storage device should reject all I/Os to that file's byte
   range that originate from that client.  In summary, layouts and
   ordinary file access controls are independent.  The act of modifying
   a file for which a layout is held, does not necessarily conflict with
   the holding of the layout that describes the file being modified.
   However, with certain layout types (e.g., block/volume layouts), the
   layout's iomode must agree with the type of I/O being performed.

   Depending upon the layout type and storage protocol in use, storage
   device access permissions may be granted by LAYOUTGET and may be
   encoded within the type specific layout.  If access permissions are
   encoded within the layout, the metadata server must recall the layout
   when those permissions become invalid for any reason; for example
   when a file becomes unwritable or inaccessible to a client.  Note,
   clients are still required to perform the appropriate access
   operations as described above (e.g., open and lock ops).  The degree
   to which it is possible for the client to circumvent these access
   operations must be clearly addressed by the individual layout type
   documents, as well as the consequences of doing so.  In addition,
   these documents must be clear about the requirements and non-
   requirements for the checking performed by the server.

   If the pNFS metadata server supports mandatory byte range locks then
   byte range locks must behave as specified by the NFSv4 protocol, as
   observed by users of files.  If a storage device is unable to
   restrict access by a pNFS client who does not hold a required
   mandatory byte range lock then the metadata server must not grant
   layouts to a client, for that storage device, that permits any access
   that conflicts with a mandatory byte range lock held by another
   client.  In this scenario, it is also necessary for the metadata
   server to ensure that byte range locks are not granted to a client if
   any other client holds a conflicting layout; in this case all
   conflicting layouts must be recalled and returned before the lock
   request can be granted.  This requires the pNFS server to understand
   the capabilities of its storage devices.





Shepler                   Expires June 15, 2006                [Page 57]

Internet-Draft           NFSv4 Minior Version 1            December 2005


7.3  Getting a Layout

   A client obtains a layout through a new operation, LAYOUTGET.  The
   metadata server will give out layouts of a particular type (e.g.,
   block/volume, object, or file) and aggregation as requested by the
   client.  The client selects an appropriate layout type which the
   server supports and the client is prepared to use.  The layout
   returned to the client may not line up exactly with the requested
   byte range.  A field within the LAYOUTGET request, "minlength",
   specifies the minimum overlap that MUST exist between the requested
   layout and the layout returned by the metadata server.  The
   "minlength" field should specify a size of at least one.  A metadata
   server may give-out multiple overlapping, non-conflicting layout
   segments to the same client in response to a LAYOUTGET.

   There is no implied ordering between getting a layout and performing
   a file OPEN.  For example, a layout may first be retrieved by placing
   a LAYOUTGET operation in the same compound as the initial file OPEN.
   Once the layout has been retrieved, it can be held across multiple
   OPEN and CLOSE sequences.

   The storage protocol used by the client to access the data on the
   storage device is determined by the layout's type.  The client needs
   to select a "layout driver" that understands how to interpret and use
   that layout.  The API used by the client to talk to its drivers is
   outside the scope of the pNFS extension.  The storage protocol
   between the client's layout driver and the actual storage is covered
   by other protocols specifications such as iSCSI (block storage), OSD
   (object storage) or NFS (file storage).

   Although, the metadata server is in control of the layout for a file,
   the pNFS client can provide hints to the server when a file is opened
   or created about preferred layout type and aggregation scheme.  The
   pNFS extension introduces a LAYOUT_HINT attribute that the client can
   set at creation time to provide a hint to the server for new files.
   It is suggested that this attribute be set as one of the initial
   attributes to OPEN when creating a new file.  Setting this attribute
   separately, after the file has been created could make it difficult,
   or impossible, for the server implementation to comply.

7.4  Committing a Layout

   Due to the nature of the protocol, the file attributes, and data
   location mapping (e.g., which offsets store data vs. store holes)
   that exist on the metadata storage device may become inconsistent in
   relation to the data stored on the storage devices; e.g., when WRITEs
   occur before a layout has been committed (e.g., between a LAYOUTGET
   and a LAYOUTCOMMIT).  Thus, it is necessary to occasionally re-sync



Shepler                   Expires June 15, 2006                [Page 58]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   this state and make it visible to other clients through the metadata
   server.

   The LAYOUTCOMMIT operation is responsible for committing a modified
   layout segment to the metadata server.  Note: the data should be
   written and committed to the appropriate storage devices before the
   LAYOUTCOMMIT occurs.  Note, if the data is being written
   asynchronously through the metadata server a COMMIT to the metadata
   server is required to sync the data and make it visible on the
   storage devices (see Section 7.6 for more details).  The scope of
   this operation depends on the storage protocol in use.  For block/
   volume-based layouts, it may require updating the block list that
   comprises the file and committing this layout to stable storage.
   While, for file-layouts it requires some synchronization of
   attributes between the metadata and storage devices (i.e., mainly the
   size attribute; EOF).  It is important to note that the level of
   synchronization is from the point of view of the client who issued
   the LAYOUTCOMMIT.  The updated state on the metadata server need only
   reflect the state as of the client's last operation previous to the
   LAYOUTCOMMIT, it need not reflect a globally synchronized state
   (e.g., other clients may be performing, or may have performed I/O
   since the client's last operation and the LAYOUTCOMMIT).

   The control protocol is free to synchronize the attributes before it
   receives a LAYOUTCOMMIT, however upon successful completion of a
   LAYOUTCOMMIT, state that exists on the metadata server that describes
   the file MUST be in sync with the state existing on the storage
   devices that comprise that file as of the issuing client's last
   operation.  Thus, a client that queries the size of a file between a
   WRITE to a storage device and the LAYOUTCOMMIT may observe a size
   that does not reflects the actual data written.

7.4.1  LAYOUTCOMMIT and mtime/atime/change

   The change attribute and the modify/access times may be updated, by
   the server, at LAYOUTCOMMIT time; since for some layout types, the
   change attribute and atime/mtime can not be updated by the
   appropriate I/O operation performed at a storage device.  The
   arguments to LAYOUTCOMMIT allow the client to provide suggested
   access and modify time values to the server.  Again, depending upon
   the layout type, these client provided values may or may not be used.
   The server should sanity check the client provided values before they
   are used.  For example, the server should ensure that time does not
   flow backwards.  According to the NFSv4 specification, The client
   always has the option to set these attributes through an explicit
   SETATTR operation.

   As mentioned, for some layout protocols the change attribute and



Shepler                   Expires June 15, 2006                [Page 59]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   mtime/atime may be updated at or after the time the I/O occurred
   (e.g., if the storage device is able to communicate these attributes
   to the metadata server).  If, upon receiving a LAYOUTCOMMIT, the
   server implementation is able to determine that the file did not
   change since the last time the change attribute was updated (e.g., no
   WRITEs or over-writes occurred), the implementation need not update
   the change attribute; file-based protocols may have enough state to
   make this determination or may update the change attribute upon each
   file modification.  This also applies for mtime and atime; if the
   server implementation is able to determine that the file has not been
   modified since the last mtime update, the server need not update
   mtime at LAYOUTCOMMIT time.  Once LAYOUTCOMMIT completes, the new
   change attribute and mtime/atime should be visible if that file was
   modified since the latest previous LAYOUTCOMMIT or LAYOUTGET.

7.4.2  LAYOUTCOMMIT and size

   The file's size may be updated at LAYOUTCOMMIT time as well.  The
   LAYOUTCOMMIT operation contains an argument that indicates the last
   byte offset to which the client wrote ("last_write_offset").  Note:
   for this offset to be viewed as a file size it must be incremented by
   one byte (e.g., a write to offset 0 would map into a file size of 1,
   but the last write offset is 0).  The metadata server may do one of
   the following:

   1.  It may update the file's size based on the last write offset.
       However, to the extent possible, the metadata server should
       sanity check any value to which the file's size is going to be
       set.  E.g., it must not truncate the file based on the client
       presenting a smaller last write offset than the file's current
       size.

   2.  If it has sufficient other knowledge of file size (e.g., by
       querying the storage devices through the control protocol), it
       may ignore the client provided argument and use the query-derived
       value.

   3.  It may use the last write offset as a hint, subject to correction
       when other information is available as above.

   The method chosen to update the file's size will depend on the
   storage device's and/or the control protocol's implementation.  For
   example, if the storage devices are block devices with no knowledge
   of file size, the metadata server must rely on the client to set the
   size appropriately.  A new size flag and length are also returned in
   the results of a LAYOUTCOMMIT.  This union indicates whether a new
   size was set, and to what length it was set.  If a new size is set as
   a result of LAYOUTCOMMIT, then the metadata server must reply with



Shepler                   Expires June 15, 2006                [Page 60]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   the new size.  As well, if the size is updated, the metadata server
   in conjunction with the control protocol SHOULD ensure that the new
   size is reflected by the storage devices immediately upon return of
   the LAYOUTCOMMIT operation; e.g., a READ up to the new file size
   should succeed on the storage devices (assuming no intervening
   truncations).  Again, if the client wants to explicitly zero-extend
   or truncate a file, SETATTR must be used; it need not be used when
   simply writing past EOF.

   Since client layout holders may be unaware of changes made to the
   file's size, through LAYOUTCOMMIT or SETATTR, by other clients, an
   additional callback/notification has been added for pNFS.
   CB_SIZECHANGED is a notification that the metadata server sends to
   layout holders to notify them of a change in file size.  This is
   preferred over issuing CB_LAYOUTRECALL to each of the layout holders.

7.4.3  LAYOUTCOMMIT and layoutupdate

   The LAYOUTCOMMIT operation contains a "layoutupdate" argument.  This
   argument is a layout type specific structure.  The structure can be
   used to pass arbitrary layout type specific information from the
   client to the metadata server at LAYOUTCOMMIT time.  For example, if
   using a block/volume layout, the client can indicate to the metadata
   server which reserved or allocated blocks it used and which it did
   not.  The "layoutupdate" structure need not be the same structure as
   the layout returned by LAYOUTGET.  The structure is defined by the
   layout type and is opaque to LAYOUTCOMMIT.

7.5  Recalling a Layout

7.5.1  Basic Operation

   Since a layout protects a client's access to a file via a direct
   client-storage-device path, a layout need only be recalled when it is
   semantically unable to serve this function.  Typically, this occurs
   when the layout no longer encapsulates the true location of the file
   over the byte range it represents.  Any operation or action (e.g.,
   server driven restriping or load balancing) that changes the layout
   will result in a recall of the layout.  A layout is recalled by the
   CB_LAYOUTRECALL callback operation (see Section 14.19).  This
   callback can either recall a layout segment identified by a byte
   range, or all the layouts associated with a file system (FSID).
   However, there is no single operation to return all layouts
   associated with an FSID; multiple layout segments may be returned in
   a single compound operation.  Section 7.5.3 discusses sequencing
   issues surrounding the getting, returning, and recalling of layouts.

   The iomode is also specified when recalling a layout or layout



Shepler                   Expires June 15, 2006                [Page 61]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   segment.  Generally, the iomode in the recall request must match the
   layout, or segment, being returned; e.g., a recall with an iomode of
   RW should cause the client to only return RW layout segments (not R
   segments).  However, a special LAYOUTIOMODE_ANY enumeration is
   defined to enable recalling a layout of any type (i.e., the client
   must return both read-only and read/write layouts).

   A REMOVE operation may cause the metadata server to recall the layout
   to prevent the client from accessing a non-existent file and to
   reclaim state stored on the client.  Since a REMOVE may be delayed
   until the last close of the file has occurred, the recall may also be
   delayed until this time.  As well, once the file has been removed,
   after the last reference, the client SHOULD no longer be able to
   perform I/O using the layout (e.g., with file-based layouts an error
   such as ESTALE could be returned).

   Although, the pNFS extension does not alter the caching capabilities
   of clients, or their semantics, it recognizes that some clients may
   perform more aggressive write-behind caching to optimize the benefits
   provided by pNFS.  However, write-behind caching may impact the
   latency in returning a layout in response to a CB_LAYOUTRECALL; just
   as caching impacts DELEGRETURN with regards to data delegations.
   Client implementations should limit the amount of dirty data they
   have outstanding at any one time.  Server implementations may fence
   clients from performing direct I/O to the storage devices if they
   perceive that the client is taking too long to return a layout once
   recalled.  A server may be able to monitor client progress by
   watching client I/Os or by observing LAYOUTRETURNs of sub-portions of
   the recalled layout.  The server can also limit the amount of dirty
   data to be flushed to storage devices by limiting the byte ranges
   covered in the layouts it gives out.

   Once a layout has been returned, the client MUST NOT issue I/Os to
   the storage devices for the file, byte range, and iomode represented
   by the returned layout.  If a client does issue an I/O to a storage
   device for which it does not hold a layout, the storage device SHOULD
   reject the I/O.

7.5.2  Recall Callback Robustness

   For simplicity, the discussion thus far has assumed that pNFS client
   state for a file exactly matches the pNFS server state for that file
   and client regarding layout ranges and permissions.  This assumption
   leads to the implicit assumption that any callback results in a
   LAYOUTRETURN or set of LAYOUTRETURNs that exactly match the range in
   the callback, since both client and server agree about the state
   being maintained.  However, it can be useful if this assumption does
   not always hold.  For example:



Shepler                   Expires June 15, 2006                [Page 62]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   o  It may be useful for clients to be able to discard layout
      information without calling LAYOUTRETURN.  If conflicts that
      require callbacks are very rare, and a server can use a multi-file
      callback to recover per-client resources (e.g., via a FSID recall,
      or a multi-file recall within a single compound), the result may
      be significantly less client-server pNFS traffic.

   o  It may be similarly useful for servers to enhance information
      about what layout ranges are held by a client beyond what a client
      actually holds.  In the extreme, a server could manage conflicts
      on a per-file basis, only issuing whole-file callbacks even though
      clients may request and be granted sub-file ranges.

   o  As well, the synchronized state assumption is not robust to minor
      errors.  A more robust design would allow for divergence between
      client and server and the ability to recover.  It is vital that a
      client not assign itself layout permissions beyond what the server
      has granted and that the server not forget layout permissions that
      have been granted in order to avoid errors.  On the other hand, if
      a server believes that a client holds a layout segment that the
      client does not know about, it's useful for the client to be able
      to issue the LAYOUTRETURN that the server is expecting in response
      to a recall.

   Thus, in light of the above, it is useful for a server to be able to
   issue callbacks for layout ranges it has not granted to a client, and
   for a client to return ranges it does not hold.  A pNFS client must
   always return layout segments that comprise the full range specified
   by the recall.  Note, the full recalled layout range need not be
   returned as part of a single operation, but may be returned in
   segments.  This allows the client to stage the flushing of dirty
   data, layout commits, and returns.  Also, it indicates to the
   metadata server that the client is making progress.

   In order to ensure client/server convergence on the layout state, the
   final LAYOUTRETURN operation in a sequence of returns for a
   particular recall, SHOULD specify the entire range being recalled,
   even if layout segments pertaining to partial ranges were previously
   returned.  In addition, if the client holds no layout segment that
   overlaps the range being recalled, the client should return the
   NFS4ERR_NOMATCHING_LAYOUT error code.  This allows the server to
   update its view of the client's layout state.

7.5.3  Recall/Return Sequencing

   As with other stateful operations, pNFS requires the correct
   sequencing of layout operations.  This proposal assumes that sessions
   will precede or accompany pNFS into NFSv4.x and thus, pNFS will



Shepler                   Expires June 15, 2006                [Page 63]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   require the use of sessions.  If the sessions proposal does not
   precede pNFS, then this proposal needs to be modified to provide for
   the correct sequencing of pNFS layout operations.  Also, this
   specification is reliant on the sessions protocol to provide the
   correct sequencing between regular operations and callbacks.  It is
   the server's responsibility to avoid inconsistencies regarding the
   layouts it hands out and the client's responsibility to properly
   serialize its layout requests.

   One critical issue with operation sequencing concerns callbacks.  The
   protocol must defend against races between the reply to a LAYOUTGET
   operation and a subsequent CB_LAYOUTRECALL.  It MUST NOT be possible
   for a client to process the CB_LAYOUTRECALL for a layout that it has
   not received in a reply message to a LAYOUTGET.

7.5.3.1  Client Side Considerations

   Consider a pNFS client that has issued a LAYOUTGET and then receives
   an overlapping recall callback for the same file.  There are two
   possibilities, which the client cannot distinguish when the callback
   arrives:

   1.  The server processed the LAYOUTGET before issuing the recall, so
       the LAYOUTGET response is in flight, and must be waited for
       because it may be carrying layout info that will need to be
       returned to deal with the recall callback.

   2.  The server issued the callback before receiving the LAYOUTGET.
       The server will not respond to the LAYOUTGET until the recall
       callback is processed.

   This can cause deadlock, as the client must wait for the LAYOUTGET
   response before processing the recall in the first case, but that
   response will not arrive until after the recall is processed in the
   second case.  This deadlock can be avoided by adhering to the
   following requirements:

   o  A LAYOUTGET MUST be rejected with an error (i.e.,
      NFS4ERR_RECALLCONFLICT) if there's an overlapping outstanding
      recall callback to the same client

   o  When processing a recall, the client MUST wait for a response to
      all conflicting outstanding LAYOUTGETs before performing any
      RETURN that could be affected by any such response.

   o  The client SHOULD wait for responses to all operations required to
      complete a recall before sending any LAYOUTGETs that would
      conflict with the recall because the server is likely to return



Shepler                   Expires June 15, 2006                [Page 64]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      errors for them.

   Now the client can wait for the LAYOUTGET response, as it will be
   received in both cases.

7.5.3.2  Server Side Considerations

   Consider a related situation from the pNFS server's point of view.
   The server has issued a recall callback and receives an overlapping
   LAYOUTGET for the same file before the LAYOUTRETURN(s) that respond
   to the recall callback.  Again, there are two cases:

   1.  The client issued the LAYOUTGET before processing the recall
       callback.

   2.  The client issued the LAYOUTGET after processing the recall
       callback, but it arrived before the LAYOUTRETURN that completed
       that processing.

   The simplest approach is to always reject the overlapping LAYOUTGET.
   The client has two ways to avoid this result - it can issue the
   LAYOUTGET as a subsequent element of a COMPOUND containing the
   LAYOUTRETURN that completes the recall callback, or it can wait for
   the response to that LAYOUTRETURN.

   This leads to a more general problem; in the absence of a callback if
   a client issues concurrent overlapping LAYOUTGET and LAYOUTRETURN
   operations, it is possible for the server to process them in either
   order.  Again, a client must take the appropriate precautions in
   serializing its actions.

   [ASIDE: HighRoad forbids a client from doing this, as the per-file
   layout stateid will cause one of the two operations to be rejected
   with a stale layout stateid.  This approach is simpler and produces
   better results by comparison to allowing concurrent operations, at
   least for this sort of conflict case, because server execution of
   operations in an order not anticipated by the client may produce
   results that are not useful to the client (e.g., if a LAYOUTRETURN is
   followed by a concurrent overlapping LAYOUTGET, but executed in the
   other order, the client will not retain layout extents for the
   overlapping range).]

7.6  Metadata Server Write Propagation

   Asynchronous writes written through the metadata server may be
   propagated lazily to the storage devices.  For data written
   asynchronously through the metadata server, a client performing a
   read at the appropriate storage device is not guaranteed to see the



Shepler                   Expires June 15, 2006                [Page 65]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   newly written data until a COMMIT occurs at the metadata server.
   While the write is pending, reads to the storage device can give out
   either the old data, the new data, or a mixture thereof.  After
   either a synchronous write completes, or a COMMIT is received (for
   asynchronously written data), the metadata server must ensure that
   storage devices give out the new data and that the data has been
   written to stable storage.  If the server implements its storage in
   any way such that it cannot obey these constraints, then it must
   recall the layouts to prevent reads being done that cannot be handled
   correctly.

7.7  Crash Recovery

   Crash recovery is complicated due to the distributed nature of the
   pNFS protocol.  In general, crash recovery for layouts is similar to
   crash recovery for delegations in the base NFSv4 protocol.  However,
   the client's ability to perform I/O without contacting the metadata
   server introduces subtleties that must be handled correctly if file
   system corruption is to be avoided.

7.7.1  Leases

   The layout lease period plays a critical role in crash recovery.
   Depending on the capabilities of the storage protocol, it is crucial
   that the client is able to maintain an accurate layout lease timer to
   ensure that I/Os are not issued to storage devices after expiration
   of the layout lease period.  In order for the client to do so, it
   must know which operations renew a lease.

7.7.1.1  Lease Renewal

   The current NFSv4 specification allows for implicit lease renewals to
   occur upon receiving an I/O. However, due to the distributed pNFS
   architecture, implicit lease renewals are limited to operations
   performed at the metadata server; this includes I/O performed through
   the metadata server.  So, a client must not assume that READ and
   WRITE I/O to storage devices implicitly renew lease state.

   If sessions are required for pNFS, as has been suggested, then the
   SEQUENCE operation is to be used to explicitly renew leases.  It is
   proposed that the SEQUENCE operation be extended to return all the
   specific information that RENEW does, but not as an error as RENEW
   returns it.  Since, when using session, beginning each compound with
   the SEQUENCE op allows renews to be performed without an additional
   operation and without an additional request.  Again, the client must
   not rely on any operation to the storage devices to renew a lease.
   Using the SEQUENCE operation for renewals, simplifies the client's
   perception of lease renewal.



Shepler                   Expires June 15, 2006                [Page 66]

Internet-Draft           NFSv4 Minior Version 1            December 2005


7.7.1.2  Client Lease Timer

   Depending on the storage protocol and layout type in use, it may be
   crucial that the client not issue I/Os to storage devices if the
   corresponding layout's lease has expired.  Doing so may lead to file
   system corruption if the layout has been given out and used by
   another client.  In order to prevent this, the client must maintain
   an accurate lease timer for all layouts held.  RFC3530 has the
   following to say regarding the maintenance of a client lease timer:

      ...the client must track operations which will renew the lease
      period.  Using the time that each such request was sent and the
      time that the corresponding reply was received, the client should
      bound the time that the corresponding renewal could have occurred
      on the server and thus determine if it is possible that a lease
      period expiration could have occurred.

   To be conservative, the client should start its lease timer based on
   the time that the it issued the operation to the metadata server,
   rather than based on the time of the response.

   It is also necessary to take propagation delay into account when
   requesting a renewal of the lease:

      ...the client should subtract it from lease times (e.g., if the
      client estimates the one-way propagation delay as 200 msec, then
      it can assume that the lease is already 200 msec old when it gets
      it).  In addition, it will take another 200 msec to get a response
      back to the server.  So the client must send a lock renewal or
      write data back to the server 400 msec before the lease would
      expire.

   Thus, the client must be aware of the one-way propagation delay and
   should issue renewals well in advance of lease expiration.  Clients,
   to the extent possible, should try not to issue I/Os that may extend
   past the lease expiration time period.  However, since this is not
   always possible, the storage protocol must be able to protect against
   the effects of inflight I/Os, as is discussed later.

7.7.2  Client Recovery

   Client recovery for layouts works in much the same way as NFSv4
   client recovery works for other lock/delegation state.  When an NFSv4
   client reboots, it will lose all information about the layouts that
   it previously owned.  There are two methods by which the server can
   reclaim these resources and allow otherwise conflicting layouts to be
   provided to other clients.




Shepler                   Expires June 15, 2006                [Page 67]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   The first is through the expiry of the client's lease.  If the client
   recovery time is longer than the lease period, the client's lease
   will expire and the server will know that state may be released. for
   layouts the server may release the state immediately upon lease
   expiry or it may allow the layout to persist awaiting possible lease
   revival, as long as there are no conflicting requests.

   On the other hand, the client may recover in less time than it takes
   for the lease period to expire.  In such a case, the client will
   contact the server through the standard SETCLIENTID protocol.  The
   server will find that the client's id matches the id of the previous
   client invocation, but that the verifier is different.  The server
   uses this as a signal to release all the state associated with the
   client's previous invocation.

7.7.3  Metadata Server Recovery

   The server recovery case is slightly more complex.  In general, the
   recovery process again follows the standard NFSv4 recovery model: the
   client will discover that the metadata server has rebooted when it
   receives an unexpected STALE_STATEID or STALE_CLIENTID reply from the
   server; it will then proceed to try to reclaim its previous
   delegations during the server's recovery grace period.  However,
   layouts are not reclaimable in the same sense as data delegations;
   there is no reclaim bit, thus no guarantee of continuity between the
   previous and new layout.  This is not necessarily required since a
   layout is not required to perform I/O; I/O can always be performed
   through the metadata server.

   [NOTE: there is no reclaim bit for getting a layout.  Thus, in the
   case of reclaiming an old layout obtained through LAYOUTGET, there is
   no guarantee of continuity.  If a reclaim bit existed a block/volume
   layout type might be happier knowing it got the layout back with the
   assurance of continuity.  However, this would require the metadata
   server trusting the client in telling it the exact layout it had
   (i.e., the full block-list); however, divergence is avoided by having
   the server tell the client what is contained within the layout.]

   If the client has dirty data that it needs to write out, or an
   outstanding LAYOUTCOMMIT, the client should try to obtain a new
   layout segment covering the byte range covered by the previous layout
   segment.  However, the client might not not get the same layout
   segment it had.  The range might be different or it might get the
   same range but the content of the layout might be different.  For
   example, if using a block/volume-based layout, the blocks
   provisionally assigned by the layout might be different, in which
   case the client will have to write the corresponding blocks again; in
   the interest of simplicity, the client might decide to always write



Shepler                   Expires June 15, 2006                [Page 68]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   them again.  Alternatively, the client might be unable to obtain a
   new layout and thus, must write the data using normal NFSv4 through
   the metadata server.

   There is an important safety concern associated with layouts that
   does not come into play in the standard NFSv4 case.  If a standard
   NFSv4 client makes use of a stale delegation, while reading, the
   consequence could be to deliver stale data to an application.  If
   writing, using a stale delegation or a stale state stateid for an
   open or lock would result in the rejection of the client's write with
   the appropriate stale stateid error.

   However, the pNFS layout enables the client to directly access the
   file system storage---if this access is not properly managed by the
   NFSv4 server the client can potentially corrupt the file system data
   or metadata.  Thus, it is vitally important that the client discover
   that the metadata server has rebooted, and that the client stops
   using stale layouts before the metadata server gives them away to
   other clients.  To ensure this, the client must be implemented so
   that layouts are never used to access the storage after the client's
   lease timer has expired.  It is crucial that clients have precise
   knowledge of the lease periods of their layouts.  For specific
   details on lease renewal and client lease timers, see Section 7.7.1.

   The prohibition on using stale layouts applies to all layout related
   accesses, especially the flushing of dirty data to the storage
   devices.  If the client's lease timer expires because the client
   could not contact the server for any reason, the client MUST
   immediately stop using the layout until the server can be contacted
   and the layout can be officially recovered or reclaimed.  However,
   this is only part of the solution.  It is also necessary to deal with
   the consequences of I/Os already in flight.

   The issue of the effects of I/Os started before lease expiration and
   possibly continuing through lease expiration is the responsibility of
   the data storage protocol and as such is layout type specific.  There
   are two approaches the data storage protocol can take.  The protocol
   may adopt a global solution which prevents all I/Os from being
   executed after the lease expiration and thus is safe against a client
   who issues I/Os after lease expiration.  This is the preferred
   solution and the solution used by NFSv4 file based layouts (see
   Section 9.6); as well, the object storage device protocol allows
   storage to fence clients after lease expiration.  Alternatively, the
   storage protocol may rely on proper client operation and only deal
   with the effects of lingering I/Os.  These solutions may impact the
   client layout-driver, the metadata server layout-driver, and the
   control protocol.




Shepler                   Expires June 15, 2006                [Page 69]

Internet-Draft           NFSv4 Minior Version 1            December 2005


7.7.4  Storage Device Recovery

   Storage device crash recovery is mostly dependent upon the layout
   type in use.  However, there are a few general techniques a client
   can use if it discovers a storage device has crashed while holding
   asynchronously written, non-committed, data.  First and foremost, it
   is important to realize that the client is the only one who has the
   information necessary to recover asynchronously written data; since,
   it holds the dirty data and most probably nobody else does.  Second,
   the best solution is for the client to err on the side or caution and
   attempt to re-write the dirty data through another path.

   The client, rather than hold the asynchronously written data
   indefinitely, is encouraged to, and can make sure that the data is
   written by using other paths to that data.  The client may write the
   data to the metadata server, either synchronously or asynchronously
   with a subsequent COMMIT.  Once it does this, there is no need to
   wait for the original storage device.  In the event that the data
   range to be committed is transferred to a different storage device,
   as indicated in a new layout, the client may write to that storage
   device.  Once the data has been committed at that storage device,
   either through a synchronous write or through a commit to that
   storage device (e.g., through the NFSv4 COMMIT operation for the
   NFSv4 file layout), the client should consider the transfer of
   responsibility for the data to the new server as strong evidence that
   this is the intended and most effective method for the client to get
   the data written.  In either case, once the write is on stable
   storage (through either the storage device or metadata server), there
   is no need to continue either attempting to commit or attempting to
   synchronously write the data to the original storage device or wait
   for that storage device to become available.  That storage device may
   never be visible to the client again.

   This approach does have a "lingering write" problem, similar to
   regular NFSv4.  Suppose a WRITE is issued to a storage device for
   which no response is received.  The client breaks the connection,
   trying to re-establish a new one, and gets a recall of the layout.
   The client issues the I/O for the dirty data through an alternative
   path, for example, through the metadata server and it succeeds.  The
   client then goes on to perform additional writes that all succeed.
   If at some time later, the original write to the storage device
   succeeds, data inconsistency could result.  The same problem can
   occur in regular NFSv4.  For example, a WRITE is held in a switch for
   some period of time while other writes are issued and replied to, if
   the original WRITE finally succeeds, the same issues can occur.
   However, this is solved by sessions in NFSv4.x.





Shepler                   Expires June 15, 2006                [Page 70]

Internet-Draft           NFSv4 Minior Version 1            December 2005


8.  Security Considerations

   The pNFS extension partitions the NFSv4 file system protocol into two
   parts, the control path and the data path (i.e., storage protocol).
   The control path contains all the new operations described by this
   extension; all existing NFSv4 security mechanisms and features apply
   to the control path.  The combination of components in a pNFS system
   (see Figure 9) is required to preserve the security properties of
   NFSv4 with respect to an entity accessing data via a client,
   including security countermeasures to defend against threats that
   NFSv4 provides defenses for in environments where these threats are
   considered significant.

   In some cases, the security countermeasures for connections to
   storage devices may take the form of physical isolation or a
   recommendation not to use pNFS in an environment.  For example, it is
   currently infeasible to provide confidentiality protection for some
   storage device access protocols to protect against eavesdropping; in
   environments where eavesdropping on such protocols is of sufficient
   concern to require countermeasures, physical isolation of the
   communication channel (e.g., via direct connection from client(s) to
   storage device(s)) and/or a decision to forego use of pNFS (e.g., and
   fall back to NFSv4) may be appropriate courses of action.

   In full generality where communication with storage devices is
   subject to the same threats as client-server communication, the
   protocols used for that communication need to provide security
   mechanisms comparable to those available via RPSEC_GSS for NFSv4.
   Many situations in which pNFS is likely to be used will not be
   subject to the overall threat profile for which NFSv4 is required to
   provide countermeasures.

   pNFS implementations MUST NOT remove NFSv4's access controls.  The
   combination of clients, storage devices, and the server are
   responsible for ensuring that all client to storage device file data
   access respects NFSv4 ACLs and file open modes.  This entails
   performing both of these checks on every access in the client, the
   storage device, or both.  If a pNFS configuration performs these
   checks only in the client, the risk of a misbehaving client obtaining
   unauthorized access is an important consideration in determining when
   it is appropriate to use such a pNFS configuration.  Such
   configurations SHOULD NOT be used when client- only access checks do
   not provide sufficient assurance that NFSv4 access control is being
   applied correctly.

   The following subsections describe security considerations
   specifically applicable to each of the three major storage device
   protocol types supported for pNFS.



Shepler                   Expires June 15, 2006                [Page 71]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   [Requiring strict equivalence to NFSv4 security mechanisms is the
   wrong approach.  Will need to lay down a set of statements that each
   protocol has to make starting with access check location/properties.]

8.1  File Layout Security

   A NFSv4 file layout type is defined in Section 9; see Section 9.7 for
   additional security considerations and details.  In summary, the
   NFSv4 file layout type requires that all I/O access checks MUST be
   performed by the storage devices, as defined by the NFSv4
   specification.  If another file layout type is being used, additional
   access checks may be required.  But in all cases, the access control
   performed by the storage devices must be at least as strict as that
   specified by the NFSv4 protocol.

8.2  Object Layout Security

   The object storage protocol MUST implement the security aspects
   described in version 1 of the T10 OSD protocol definition [5].  The
   remainder of this section gives an overview of the security mechanism
   described in that standard.  The goal is to give the reader a basic
   understanding of the object security model.  Any discrepancies
   between this text and the actual standard are obviously to be
   resolved in favor of the OSD standard.

   The object storage protocol relies on a cryptographically secure
   capability to control accesses at the object storage devices.
   Capabilities are generated by the metadata server, returned to the
   client, and used by the client as described below to authenticate
   their requests to the Object Storage Device (OSD).  Capabilities
   therefore achieve the required access and open mode checking.  They
   allow the file server to define and check a policy (e.g., open mode)
   and the OSD to check and enforce that policy without knowing the
   details (e.g., user IDs and ACLs).  Since capabilities are tied to
   layouts, and since they are used to enforce access control, the
   server should recall layouts and revoke capabilities when the file
   ACL or mode changes in order to signal the clients.

   Each capability is specific to a particular object, an operation on
   that object, a byte range w/in the object, and has an explicit
   expiration time.  The capabilities are signed with a secret key that
   is shared by the object storage devices (OSD) and the metadata
   managers. clients do not have device keys so they are unable to forge
   capabilities.  The the following sketch of the algorithm should help
   the reader understand the basic model.

   LAYOUTGET returns




Shepler                   Expires June 15, 2006                [Page 72]

Internet-Draft           NFSv4 Minior Version 1            December 2005


     {CapKey = MAC<SecretKey>(CapArgs), CapArgs}

   The client uses CapKey to sign all the requests it issues for that
   object using the respective CapArgs.  In other words, the CapArgs
   appears in the request to the storage device, and that request is
   signed with the CapKey as follows:

     ReqMAC = MAC<CapKey>(Req, Nonceln)

   The following is sent to the OSD: {CapArgs, Req, Nonceln, ReqMAC}.
   The OSD uses the SecretKey it shares with the metadata server to
   compare the ReqMAC the client sent with a locally computed

     MAC<MAC<SecretKey>(CapArgs)>(Req, Nonceln)

   and if they match the OSD assumes that the capabilities came from an
   authentic metadata server and allows access to the object, as allowed
   by the CapArgs.  Therefore, if the server LAYOUTGET reply, holding
   CapKey and CapArgs, is snooped by another client, it can be used to
   generate valid OSD requests (within the CapArgs access restriction).

   To provide the required privacy requirements for the capabilities
   returned by LAYOUTGET, the GSS-API can be used, e.g. by using a
   session key known to the file server and to the client to encrypt the
   whole layout or parts of it.  Two general ways to provide privacy in
   the absence of GSS-API that are independent of NFSv4 are either an
   isolated network such as a VLAN or a secure channel provided by
   IPsec.

8.3  Block/Volume Layout Security

   As typically used, block/volume protocols rely on clients to enforce
   file access checks since the storage devices are generally unaware of
   the files they are storing and in particular are unaware of which
   blocks belongs to which file.  In such environments, the physical
   addresses of blocks are exported to pNFS clients via layouts.  An
   alternative method of block/volume protocol use is for the storage
   devices to export virtualized block addresses, which do reflect the
   files to which blocks belong.  These virtual block addresses are
   exported to pNFS clients via layouts.  This allows the storage device
   to make appropriate access checks, while mapping virtual block
   addresses to physical block addresses.

   In environments where access control is important and client-only
   access checks provide insufficient assurance of access control
   enforcement (e.g., there is concern about a malicious of
   malfunctioning client skipping the access checks) and where physical
   block addresses are exported to clients, the storage devices will



Shepler                   Expires June 15, 2006                [Page 73]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   generally be unable to compensate for these client deficiencies.

   In such threat environments, block/volume protocols SHOULD NOT be
   used with pNFS, unless the storage device is able to implement the
   appropriate access checks, via use of virtualized block addresses, or
   other means.  NFSv4 without pNFS or pNFS with a different type of
   storage protocol would be a more suitable means to access files in
   such environments.  Storage-device/protocol-specific methods (e.g.
   LUN masking/mapping) may be available to prevent malicious or high-
   risk clients from directly accessing storage devices.

9.  The NFSv4 File Layout Type

   This section describes the semantics and format of NFSv4 file-based
   layouts.

9.1  File Striping and Data Access

   The file layout type describes a method for striping data across
   multiple devices.  The data for each stripe unit is stored within an
   NFSv4 file located on a particular storage device.  The structures
   used to describe the stripe layout are as follows:

    enum stripetype4 {
           STRIPE_SPARSE = 1,
           STRIPE_DENSE = 2
    };

    struct nfsv4_file_layouthint {
            stripetype4             stripe_type;
            length4                 stripe_unit;
            uint32_t                stripe_width;
    };

    struct nfsv4_file_layout {                   /* Per data stripe */
           pnfs_deviceid4          dev_id<>;
           nfs_fh4                 fh;
    };

    struct nfsv4_file_layouttype4 {              /* Per file */
           stripetype4             stripe_type;
           length4                 stripe_unit;
           length4                 file_size;
           nfsv4_file_layout       dev_list<>;
    };

   The file layout specifies an ordered array of <deviceID, filehandle>
   tuples, as well as the stripe size, type of stripe layout (discussed



Shepler                   Expires June 15, 2006                [Page 74]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   a little later), and the file's current size as of LAYOUTGET time.
   The filehandle, "fh", identifies the file on a storage device
   identified by "dev_id", that holds a particular stripe of the file.
   The "dev_id" array can be used for multipathing and is discussed
   further in Section 9.1.3.  The stripe width is determined by the
   stripe unit size multiplied by the number of devices in the dev_list.
   The stripe held by <dev_id, fh> is determined by that tuples position
   within the device list, "dev_list".  For example, consider a dev_list
   consisting of the following <dev_id, fh> pairs:

   <(1,0x12), (2,0x13), (1,0x15)> and stripe_unit = 32KB

   The stripe width is 32KB * 3 devices = 96KB.  The first entry
   specifies that on device 1 in the data file with filehandle 0x12
   holds the first 32KB of data (and every 32KB stripe beginning where
   the file's offset % 96KB == 0).

   Devices may be repeated multiple times within the device list array;
   this is shown where storage device 1 holds both the first and third
   stripe of data.  Filehandles can only be repeated if a sparse stripe
   type is used.  Data is striped across the devices in the order listed
   in the device list array in increments of the stripe size.  A data
   file stored on a storage device MUST map to a single file as defined
   by the metadata server; i.e., data from two files as viewed by the
   metadata server MUST NOT be stored within the same data file on any
   storage device.

   The "stripe_type" field specifies how the data is laid out within the
   data file on a storage device.  It allows for two different data
   layouts: sparse and dense or packed.  The stripe type determines the
   calculation that must be made to map the client visible file offset
   to the offset within the data file located on the storage device.

   The layout hint structure is described in more detail in
   Section 10.7.  It is used, by the client, as by the FILE_LAYOUT_HINT
   attribute to specify the type of layout to be used for a newly
   created file.

9.1.1  Sparse and Dense Storage Device Data Layouts

   The stripe_type field allows for two storage device data file
   representations.  Example sparse and dense storage device data
   layouts are illustrated below:








Shepler                   Expires June 15, 2006                [Page 75]

Internet-Draft           NFSv4 Minior Version 1            December 2005


    Sparse file-layout (stripe_unit = 4KB)
    ------------------

    Is represented by the following file layout on the storage devices:

        Offset  ID:0    ID:1   ID:2
        0       +--+    +--+   +--+                 +--+  indicates a
                |//|    |  |   |  |                 |//|  stripe that
        4KB     +--+    +--+   +--+                 +--+  contains data
                |  |    |//|   |  |
        8KB     +--+    +--+   +--+
                |  |    |  |   |//|
        12KB    +--+    +--+   +--+
                |//|    |  |   |  |
        16KB    +--+    +--+   +--+
                |  |    |//|   |  |
                +--+    +--+   +--+

   The sparse file-layout has holes for the byte ranges not exported by
   that storage device.  This allows clients to access data using the
   real offset into the file, regardless of the storage device's
   position within the stripe.  However, if a client writes to one of
   the holes (e.g., offset 4-12KB on device 1), then an error MUST be
   returned by the storage device.  This requires that the storage
   device have knowledge of the layout for each file.

   When using a sparse layout, the offset into the storage device data
   file is the same as the offset into the main file.

    Dense/packed file-layout (stripe_unit = 4KB)
    ------------------------

    Is represented by the following file layout on the storage devices:

        Offset  ID:0    ID:1   ID:2
        0       +--+    +--+   +--+
                |//|    |//|   |//|
        4KB     +--+    +--+   +--+
                |//|    |//|   |//|
        8KB     +--+    +--+   +--+
                |//|    |//|   |//|
        12KB    +--+    +--+   +--+
                |//|    |//|   |//|
        16KB    +--+    +--+   +--+
                |//|    |//|   |//|
                +--+    +--+   +--+

   The dense or packed file-layout does not leave holes on the storage



Shepler                   Expires June 15, 2006                [Page 76]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   devices.  Each stripe unit is spread across the storage devices.  As
   such, the storage devices need not know the file's layout since the
   client is allowed to write to any offset.

   The calculation to determine the byte offset within the data file for
   dense storage device layouts is:

     stripe_width = stripe_unit * N; where N = |dev_list|
     dev_offset = floor(file_offset / stripe_width) * stripe_unit +
                  file_offset % stripe_unit

   Regardless of the storage device data file layout, the calculation to
   determine the index into the device array is the same:

     dev_idx = floor(file_offset / stripe_unit) mod N

   Section 9.5 describe the semantics for dealing with reads to holes
   within the striped file.  This is of particular concern, since each
   individual component stripe file (i.e., the component of the striped
   file that lives on a particular storage device) may be of different
   length.  Thus, clients may experience 'short' reads when reading off
   the end of one of these component files.

9.1.2  Metadata and Storage Device Roles

   In many cases, the metadata server and the storage device will be
   separate pieces of physical hardware.  The specification text is
   written as if that were always case.  However, it can be the case
   that the same physical hardware is used to implement both a metadata
   and storage device and in this case, the specification text's
   references to these two entities are to be understood as referring to
   the same physical hardware implementing two distinct roles and it is
   important that it be clearly understood on behalf of which role the
   hardware is executing at any given time.

   Two sub-cases can be distinguished.  In the first sub-case, the same
   physical hardware is used to implement both a metadata and data
   server in which each role is addressed through a distinct network
   interface (e.g., IP addresses for the metadata server and storage
   device are distinct).  As long as the storage device address is
   obtained from the layout and is distinct from the metadata server's
   address, using the device ID therein to obtain the appropriate
   storage device address, it is always clear, for any given request, to
   what role it is directed, based on the destination IP address.

   However, it may also be the case that even though the metadata server
   and storage device are distinct from one client's point of view, the
   roles may be reversed according to another client's point of view.



Shepler                   Expires June 15, 2006                [Page 77]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   For example, in the cluster file system model a metadata server to
   one client, may be a storage device to another client.  Thus, it is
   safer to always mark the filehandle so that operations addressed to
   storage devices can be distinguished.

   The second sub-case is where both the metadata and storage device
   have the same network address.  This requires us to make the
   distinction as to which role each request is directed, on a another
   basis.  Since the network address is the same, the request is
   understood as being directed at one or the other, based on the
   filehandle of the first current filehandle value for the request.  If
   the first current file handle is one derived from a layout (i.e., it
   is specified within the layout) (and it is recommended that these be
   distinguishable), then the request is to be considered as executed by
   a storage device.  Otherwise, the operation is to be understood as
   executed by the metadata server.

   If a current filehandle is set that is inconsistent with the role to
   which it is directed, then the error NFS4ERR_BADHANDLE should result.
   For example, if a request is directed at the storage device, because
   the first current handle is from a layout, any attempt to set the
   current filehandle to be a value not from a layout should be
   rejected.  Similarly, if the first current file handle was for a
   value not from a layout, a subsequent attempt to set the current file
   handle to a value obtained from a layout should be rejected.

9.1.3  Device Multipathing

   The NFSv4 file layout supports multipathing to 'equivalent' devices.
   Device-level multipathing is primarily of use in the case of a data
   server failure --- it allows the client to switch to another storage
   device that is exporting the same data stripe, without having to
   contact the metadata server for a new layout.

   To support device multipathing, an array of device IDs is encoded
   within the data stripe portion of the file's layout.  This array
   represents an ordered list of devices where the first element has the
   highest priority.  Each device in the list MUST be 'equivalent' to
   every other device in the list and each device must be attempted in
   the order specified.

   Equivalent devices MUST export the same system image (e.g., the
   stateids and filehandles that they use are the same) and must provide
   the same consistency guarantees.  Two equivalent storage devices must
   also have sufficient connections to the storage, such that writing to
   one storage device is equivalent to writing to another, this also
   applies to reading.  Also, if multiple copies of the same data exist,
   reading from one must provide access to all existing copies.  As



Shepler                   Expires June 15, 2006                [Page 78]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   such, it is unlikely that multipathing will provide additional
   benefit in the case of an I/O error.

   [NOTE: the error cases in which a client is expected to attempt an
   equivalent storage device should be specified.]

9.1.4  Operations Issued to Storage Devices

   Clients MUST use the filehandle described within the layout when
   accessing data on the storage devices.  When using the layout's
   filehandle, the client MUST only issue READ, WRITE, PUTFH, COMMIT,
   and NULL operations to the storage device associated with that
   filehandle.  If a client issues an operation other than those
   specified above, using the filehandle and storage device listed in
   the client's layout, that storage device SHOULD return an error to
   the client.  The client MUST follow the instruction implied by the
   layout (i.e., which filehandles to use on which devices).  As
   described in Section 7.2, a client MUST NOT issue I/Os to storage
   devices for which it does not hold a valid layout.  The storage
   devices may reject such requests.

   GETATTR and SETATTR MUST be directed to the metadata server.  In the
   case of a SETATTR of the size attribute, the control protocol is
   responsible for propagating size updates/truncations to the storage
   devices.  In the case of extending WRITEs to the storage devices, the
   new size must be visible on the metadata server once a LAYOUTCOMMIT
   has completed (see Section 7.4.2).  Section 9.5, describes the
   mechanism by which the client is to handle storage device file's that
   do not reflect the metadata server's size.

9.2  Global Stateid Requirements

   Note, there are no stateids returned embedded within the layout.  The
   client MUST use the stateid representing open or lock state as
   returned by an earlier metadata operation (e.g., OPEN, LOCK), or a
   special stateid to perform I/O on the storage devices, as in regular
   NFSv4.  Special stateid usage for I/O is subject to the NFSv4
   protocol specification.  The stateid used for I/O MUST have the same
   effect and be subject to the same validation on storage device as it
   would if the I/O was being performed on the metadata server itself in
   the absence of pNFS.  This has the implication that stateids are
   globally valid on both the metadata and storage devices.  This
   requires the metadata server to propagate changes in lock and open
   state to the storage devices, so that the storage devices can
   validate I/O accesses.  This is discussed further in Section 9.4.
   Depending on when stateids are propagated, the existence of a valid
   stateid on the storage device may act as proof of a valid layout.




Shepler                   Expires June 15, 2006                [Page 79]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   [NOTE: a number of proposals have been made that have the possibility
   of limiting the amount of validation performed by the storage device,
   if any of these proposals are accepted or obtain consensus, the
   global stateid requirement can be revisited.]

9.3  The Layout Iomode

   The layout iomode need not used by the metadata server when servicing
   NFSv4 file-based layouts, although in some circumstances it may be
   useful to use.  For example, if the server implementation supports
   reading from read-only replicas or mirrors, it would be useful for
   the server to return a layout enabling the client to do so.  As such,
   the client should set the iomode based on its intent to read or write
   the data.  The client may default to an iomode of READ/WRITE
   (LAYOUTIOMODE_RW).  The iomode need not be checked by the storage
   devices when clients perform I/O. However, the storage devices SHOULD
   still validate that the client holds a valid layout and return an
   error if the client does not.

9.4  Storage Device State Propagation

   Since the metadata server, which handles lock and open-mode state
   changes, as well as ACLs, may not be collocated with the storage
   devices where I/O access are validated, as such, the server
   implementation MUST take care of propagating changes of this state to
   the storage devices.  Once the propagation to the storage devices is
   complete, the full effect of those changes must be in effect at the
   storage devices.  However, some state changes need not be propagated
   immediately, although all changes SHOULD be propagated promptly.
   These state propagations have an impact on the design of the control
   protocol, even though the control protocol is outside of the scope of
   this specification.  Immediate propagation refers to the synchronous
   propagation of state from the metadata server to the storage
   device(s); the propagation must be complete before returning to the
   client.

9.4.1  Lock State Propagation

   Mandatory locks MUST be made effective at the storage devices before
   the request that establishes them returns to the caller.  Thus,
   mandatory lock state MUST be synchronously propagated to the storage
   devices.  On the other hand, since advisory lock state is not used
   for checking I/O accesses at the storage devices, there is no
   semantic reason for propagating advisory lock state to the storage
   devices.  However, since all lock, unlock, open downgrades and
   upgrades affect the sequence ID stored within the stateid, the
   stateid changes which may cause difficulty if this state is not
   propagated.  Thus, when a client uses a stateid on a storage device



Shepler                   Expires June 15, 2006                [Page 80]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   for I/O with a newer sequence number than the one the storage device
   has, the storage device should query the metadata server and get any
   pending updates to that stateid.  This allows stateid sequence number
   changes to be propagated lazily, on-demand.

   [NOTE: With the reliance on the sessions protocol, there is no real
   need for sequence ID portion of the stateid to be validated on I/O
   accesses.  It is proposed that the seq.  ID checking is obsoleted.]

   Since updates to advisory locks neither confer nor remove privileges,
   these changes need not be propagated immediately, and may not need to
   be propagated promptly.  The updates to advisory locks need only be
   propagated when the storage device needs to resolve a question about
   a stateid.  In fact, if byte-range locking is not mandatory (i.e., is
   advisory) the clients are advised not to use the lock-based stateids
   for I/O at all.  The stateids returned by open are sufficient and
   eliminate overhead for this kind of state propagation.

9.4.2  Open-mode Validation

   Open-mode validation MUST be performed against the open mode(s) held
   by the storage devices.  However, the server implementation may not
   always require the immediate propagation of changes.  Reduction in
   access because of CLOSEs or DOWNGRADEs do not have to be propagated
   immediately, but SHOULD be propagated promptly; whereas changes due
   to revocation MUST be propagated immediately.  On the other hand,
   changes that expand access (e.g., new OPEN's and upgrades) don't have
   to be propagated immediately but the storage device SHOULD NOT reject
   a request because of mode issues without making sure that the upgrade
   is not in flight.

9.4.3  File Attributes

   Since the SETATTR operation has the ability to modify state that is
   visible on both the metadata and storage devices (e.g., the size),
   care must be taken to ensure that the resultant state across the set
   of storage devices is consistent; especially when truncating or
   growing the file.

   As described earlier, the LAYOUTCOMMIT operation is used to ensure
   that the metadata is synced with changes made to the storage devices.
   For the file-based protocol, it is necessary to re-sync state such as
   the size attribute, and the setting of mtime/atime.  See Section 7.4
   for a full description of the semantics regarding LAYOUTCOMMIT and
   attribute synchronization.  It should be noted, that by using a file-
   based layout type, it is possible to synchronize this state before
   LAYOUTCOMMIT occurs.  For example, the control protocol can be used
   to query the attributes present on the storage devices.



Shepler                   Expires June 15, 2006                [Page 81]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Any changes to file attributes that control authorization or access
   as reflected by ACCESS calls or READs and WRITEs on the metadata
   server, MUST be propagated to the storage devices for enforcement on
   READ and WRITE I/O calls.  If the changes made on the metadata server
   result in more restrictive access permissions for any user, those
   changes MUST be propagated to the storage devices synchronously.

   Recall that the NFSv4 protocol [2] specifies that:

      ...since the NFS version 4 protocol does not impose any
      requirement that READs and WRITEs issued for an open file have the
      same credentials as the OPEN itself, the server still must do
      appropriate access checking on the READs and WRITEs themselves.

   This also includes changes to ACLs.  The propagation of access right
   changes due to changes in ACLs may be asynchronous only if the server
   implementation is able to determine that the updated ACL is not more
   restrictive for any user specified in the old ACL.  Due to the
   relative infrequency of ACL updates, it is suggested that all changes
   be propagated synchronously.

   [NOTE: it has been suggested that the NFSv4 specification is in error
   with regard to allowing principles other than those used for OPEN to
   be used for file I/O. If changes within a minor version alter the
   behavior of NFSv4 with regard to OPEN principals and stateids some
   access control checking at the storage device can be made less
   expensive. pNFS should be altered to take full advantage of these
   changes.]

9.5  Storage Device Component File Size

   A potential problem exists when a component data file on a particular
   storage device is grown past EOF; the problem exists for both dense
   and sparse layouts.  Imagine the following scenario: a client creates
   a new file (size == 0) and writes to byte 128KB; the client then
   seeks to the beginning of the file and reads byte 100.  The client
   should receive 0s back as a result of the read.  However, if the read
   falls on a different storage device to the client's original write,
   the storage device servicing the READ may still believe that the
   file's size is at 0 and return no data with the EOF flag set.  The
   storage device can only return 0s if it knows that the file's size
   has been extended.  This would require the immediate propagation of
   the file's size to all storage devices, which is potentially very
   costly, instead, another approach as outlined below.

   First, the file's size is returned within the layout by LAYOUTGET.
   This size must reflect the latest size at the metadata server as set
   by the most recent of either the last LAYOUTCOMMIT or SETATTR;



Shepler                   Expires June 15, 2006                [Page 82]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   however, it may be more recent.  Second, if a client performs a read
   that is returned short (i.e., is fully within the file's size, but
   the storage device indicates EOF and returns partial or no data), the
   client must assume that it is a hole and substitute 0s for the data
   not read up until its known local file size.  If a client extends the
   file, it must update its local file size.  Third, if the metadata
   server receives a SETATTR of the size or a LAYOUTCOMMIT that alters
   the file's size, the metadata server must send out CB_SIZECHANGED
   messages with the new size to clients holding layouts; it need not
   send a notification to the client that performed the operation that
   resulted in the size changing).  Upon reception of the CB_SIZECHANGED
   notification, clients must update their local size for that file.  As
   well, if a new file size is returned as a result to LAYOUTCOMMIT, the
   client must update their local file size.

9.6  Crash Recovery Considerations

   As described in Section 7.7, the layout type specific storage
   protocol is responsible for handling the effects of I/Os started
   before lease expiration, extending through lease expiration.  The
   NFSv4 file layout type prevents all I/Os from being executed after
   lease expiration, without relying on a precise client lease timer and
   without requiring storage devices to maintain lease timers.

   It works as follows.  In the presence of sessions, each compound
   begins with a SEQUENCE operation that contains the "clientID".  On
   the storage device, the clientID can be used to validate that the
   client has a valid layout for the I/O being performed, if it does
   not, the I/O is rejected.  Before the metadata server takes any
   action to invalidate a layout given out by a previous instance, it
   must make sure that all layouts from that previous instance are
   invalidated at the storage devices.  Note: it is sufficient to
   invalidate the stateids associated with the layout only if special
   stateids are not being used for I/O at the storage devices, otherwise
   the layout itself must be invalidated.

   This means that a metadata server may not restripe a file until it
   has contacted all of the storage devices to invalidate the layouts
   from the previous instance nor may it give out locks that conflict
   with locks embodied by the stateids associated with any layout from
   the previous instance without either doing a specific invalidation
   (as it would have to do anyway) or doing a global storage device
   invalidation.

9.7  Security Considerations

   The NFSv4 file layout type MUST adhere to the security considerations
   outlined in Section 8.  More specifically, storage devices must make



Shepler                   Expires June 15, 2006                [Page 83]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   all of the required access checks on each READ or WRITE I/O as
   determined by the NFSv4 protocol [2].  This impacts the control
   protocol and the propagation of state from the metadata server to the
   storage devices; see Section 9.4 for more details.

9.8  Alternate Approaches

   Two alternate approaches exist for file-based layouts and the method
   used by clients to obtain stateids used for I/O. Both approaches
   embed stateids within the layout.

   However, before examining these approaches it is important to
   understand the distinction between clients and owners.  Delegations
   belong to clients, while locks (e.g., record and share reservations)
   are held by owners which in turn belong to a specific client.  As
   such, delegations can only protect against inter-client conflicts,
   not intra-client conflicts.  Layouts are held by clients and SHOULD
   NOT be associated with state held by owners.  Therefore, if stateids
   used for data access are embedded within a layout, these stateids can
   only act as delegation stateids, protecting against inter-client
   conflicts; stateids pertaining to an owner can not be embedded within
   the layout.  This has the implication that the client MUST arbitrate
   among all intra-client conflicts (e.g., arbitrating among lock
   requests by different processes) before issuing pNFS operations.
   Using the stateids stored within the layout, storage devices can only
   arbitrate between clients (not owners).

   The first alternate approach is to do away with global stateids,
   stateids returned by OPEN/LOCK that are valid on the metadata server
   and storage devices, and use only stateids embedded within the
   layout.  This approach has the drawback that the stateids used for
   I/O access can not be validated against per owner state, since they
   are only associated with the client holding the layout.  It breaks
   the semantics of tieing a stateid used for I/O to an open instance.
   This has the implication that clients must delegate per owner lock
   and open requests internally, rather than push the work onto the
   storage devices.  The storage devices can still arbitrate and enforce
   inter-client lock and open state.

   The second approach is a hybrid approach.  This approach allows for
   stateids to be embedded with the layout, but also allows for the
   possibility of global stateids.  If the stateid embedded within the
   layout is a special stateid of all zeros, then the stateid referring
   to the last successful OPEN/LOCK should be used.  This approach is
   recommended if it is decided that using NFSv4 as a control protocol
   is required.

   This proposal suggests the global stateid approach due to the cleaner



Shepler                   Expires June 15, 2006                [Page 84]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   semantics it provides regarding the relationship between stateids
   used for I/O and their corresponding open instance or lock state.
   However, it does have a profound impact on the control protocol's
   implementation and the state propagation that is required (as
   described in Section 9.4).

10.  pNFS Typed Data Structures

10.1  pnfs_layouttype4

     enum pnfs_layouttype4 {
            LAYOUT_NFSV4_FILES = 1,
            LAYOUT_OSD2_OBJECTS = 2,
            LAYOUT_BLOCK_VOLUME = 3
     };

   A layout type specifies the layout being used.  The implication is
   that clients have "layout drivers" that support one or more layout
   types.  The file server advertises the layout types it supports
   through the LAYOUT_TYPES file system attribute.  A client asks for
   layouts of a particular type in LAYOUTGET, and passes those layouts
   to its layout driver.  The set of well known layout types must be
   defined.  As well, a private range of layout types is to be defined
   by this document.  This would allow custom installations to introduce
   new layout types.

   [OPEN ISSUE: Determine private range of layout types]

   New layout types must be specified in RFCs approved by the IESG
   before becoming part of the pNFS specification.

   The LAYOUT_NFSV4_FILES enumeration specifies that the NFSv4 file
   layout type is to be used.  The LAYOUT_OSD2_OBJECTS enumeration
   specifies that the object layout, as defined in [7], is to be used.
   Similarly, the LAYOUT_BLOCK_VOLUME enumeration that the block/volume
   layout, as defined in [6], is to be used.

10.2  pnfs_deviceid4

     typedef uint32_t pnfs_deviceid4;       /* 32-bit device ID */

   Layout information includes device IDs that specify a storage device
   through a compact handle.  Addressing and type information is
   obtained with the GETDEVICEINFO operation.  A client must not assume
   that device IDs are valid across metadata server reboots.  The device
   ID is qualified by the layout type and are unique per file system
   (FSID).  This allows different layout drivers to generate device IDs
   without the need for co-ordination.  See Section 7.1.4 for more



Shepler                   Expires June 15, 2006                [Page 85]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   details.

10.3  pnfs_deviceaddr4

     struct pnfs_netaddr4 {
              string           r_netid<>;   /* network ID */
              string           r_addr<>;    /* universal address */
     };

     struct pnfs_deviceaddr4 {
              pnfs_layouttype4 type;
              opaque           device_addr<>;
     };

   The device address is used to set up a communication channel with the
   storage device.  Different layout types will require different types
   of structures to define how they communicate with storage devices.
   The opaque device_addr field must be interpreted based on the
   specified layout type.

   Currently, the only defined device address is that for the NFSv4 file
   layout (struct pnfs_netaddr4), which identifies a storage device by
   network IP address and port number.  This is sufficient for the
   clients to communicate with the NFSv4 storage devices, and may also
   be sufficient for object-based storage drivers to communicate with
   OSDs.  The other device address we expect to support is a SCSI volume
   identifier.  The final protocol specification will detail the allowed
   values for device_type and the format of their associated location
   information.

   [NOTE: other device addresses will be added as the respective
   specifications mature.  It has been suggested that a separate
   device_type enumeration is used as a switch to the pnfs_deviceaddr4
   structure (e.g., if multiple types of addresses exist for the same
   layout type).  Until such a time as a real case is made and the
   respective layout types have matured, the device address structure
   will be left as is.]

10.4  pnfs_devlist_item4

     struct pnfs_devlist_item4 {
            pnfs_deviceid4          id;
            pnfs_deviceaddr4        addr;
     };

   An array of these values is returned by the GETDEVICELIST operation.
   They define the set of devices associated with a file system.




Shepler                   Expires June 15, 2006                [Page 86]

Internet-Draft           NFSv4 Minior Version 1            December 2005


10.5  pnfs_layout4

     struct pnfs_layout4 {
            offset4                 offset;
            length4                 length;
            pnfs_layoutiomode4      iomode;
            pnfs_layouttype4        type;
            opaque                  layout<>;
     };

   The pnfs_layout4 structure defines a layout for a file.  The layout
   type specific data is opaque within this structure and must be
   interepreted based on the layout type.  Currently, only the NFSv4
   file layout type is defined; see Section 9.1 for its definition.
   Since layouts are sub-dividable, the offset and length together with
   the file's filehandle, the clientid, iomode, and layout type,
   identifies the layout.

   [OPEN ISSUE: there is a discussion of moving the striping
   information, or more generally the "aggregation scheme", up to the
   generic layout level.  This creates a two-layer system where the top
   level is a switch on different data placement layouts, and the next
   level down is a switch on different data storage types.  This lets
   different layouts (e.g., striping or mirroring or redundant servers)
   to be layered over different storage devices.  This would move
   geometry information out of nfsv4_file_layouttype4 and up into a
   generic pnfs_striped_layout type that would specify a set of
   pnfs_deviceid4 and pnfs_devicetype4 to use for storage.  Instead of
   nfsv4_file_layouttype4, there would be pnfs_nfsv4_devicetype4.]

10.6  pnfs_layoutupdate4

     struct pnfs_layoutupdate4 {
            pnfs_layouttype4        type;
            opaque                  layoutupdate_data<>;
     };

   The pnfs_layoutupdate4 structure is used by the client to return
   'updated' layout information to the metadata server at LAYOUTCOMMIT
   time.  This structure provides a channel to pass layout type specific
   information back to the metadata server.  E.g., for block/volume
   layout types this could include the list of reserved blocks that were
   written.  The contents of the opaque layoutupdate_data argument are
   determined by the layout type and are defined in their context.  The
   NFSv4 file-based layout does not use this structure, thus the
   update_data field should have a zero length.





Shepler                   Expires June 15, 2006                [Page 87]

Internet-Draft           NFSv4 Minior Version 1            December 2005


10.7  pnfs_layouthint4

     struct pnfs_layouthint4 {
            pnfs_layouttype4      type;
            opaque                layouthint_data<>;
     };

   The pnfs_layouthint4 structure is used by the client to pass in a
   hint about the type of layout it would like created for a particular
   file.  It is the structure specified by the FILE_LAYOUT_HINT
   attribute described below.  The metadata server may ignore the hint,
   or may selectively ignore fields within the hint.  This hint should
   be provided at create time as part of the initial attributes within
   OPEN.  The NFSv4 file-based layout uses the "nfsv4_file_layouthint"
   structure as defined in Section 9.1.

10.8  pnfs_layoutiomode4

     enum pnfs_layoutiomode4 {
             LAYOUTIOMODE_READ          = 1,
             LAYOUTIOMODE_RW            = 2,
             LAYOUTIOMODE_ANY           = 3
     };

   The iomode specifies whether the client intends to read or write
   (with the possibility of reading) the data represented by the layout.
   The ANY iomode MUST NOT be used for LAYOUTGET, however, it can be
   used for LAYOUTRETURN and LAYOUTRECALL.  The ANY iomode specifies
   that layouts pertaining to both READ and RW iomodes are being
   returned or recalled, respectively.  The metadata server's use of the
   iomode may depend on the layout type being used.  The storage devices
   may validate I/O accesses against the iomode and reject invalid
   accesses.

11.  pNFS File Attributes

11.1  pnfs_layouttype4<> FS_LAYOUT_TYPES

   This attribute applies to a file system and indicates what layout
   types are supported by the file system.  We expect this attribute to
   be queried when a client encounters a new fsid.  This attribute is
   used by the client to determine if it has applicable layout drivers.

11.2  pnfs_layouttype4<> FILE_LAYOUT_TYPES

   This attribute indicates the particular layout type(s) used for a
   file.  This is for informational purposes only.  The client needs to
   use the LAYOUTGET operation in order to get enough information (e.g.,



Shepler                   Expires June 15, 2006                [Page 88]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   specific device information) in order to perform I/O.

11.3  pnfs_layouthint4 FILE_LAYOUT_HINT

   This attribute may be set on newly created files to influence the
   metadata server's choice for the file's layout.  It is suggested that
   this attribute is set as one of the initial attributes within the
   OPEN call.  The metadata server may ignore this attribute.  This
   attribute is a sub-set of the layout structure returned by LAYOUTGET.
   For example, instead of specifying particular devices, this would be
   used to suggest the stripe width of a file.  It is up to the server
   implementation to determine which fields within the layout it uses.

   [OPEN ISSUE: it has been suggested that the HINT is a well defined
   type other than pnfs_layoutdata4, similar to pnfs_layoutupdate4.]

11.4  uint32_t FS_LAYOUT_PREFERRED_BLOCKSIZE

   This attribute is a file system wide attribute and indicates the
   preferred block size for direct storage device access.

11.5  uint32_t FS_LAYOUT_PREFERRED_ALIGNMENT

   This attribute is a file system wide attribute and indicates the
   preferred alignment for direct storage device access.

12.  pNFS Error Definitions

   NFS4ERR_BADLAYOUT Layout specified is invalid.

   NFS4ERR_BADIOMODE Layout iomode is invalid.

   NFS4ERR_LAYOUTUNAVAILABLE Layouts are not available for the file or
      its containing file system.

   NFS4ERR_LAYOUTTRYLATER Layouts are temporarily unavailable for the
      file, client should retry later.

   NFS4ERR_NOMATCHING_LAYOUT Client has no matching layout (segment) to
      return.

   NFS4ERR_RECALLCONFLICT Layout is unavailable due to a conflicting
      LAYOUTRECALL that is in progress.

   NFS4ERR_UNKNOWN_LAYOUTTYPE Layout type is unknown.






Shepler                   Expires June 15, 2006                [Page 89]

Internet-Draft           NFSv4 Minior Version 1            December 2005


13.  Layouts and Aggregation

   This section describes several aggregation schemes in a semi-formal
   way to provide context for layout formats.  These definitions will be
   formalized in other protocols.  However, the set of understood types
   is part of this protocol in order to provide for basic
   interoperability.

   The layout descriptions include (deviceID, objectID) tuples that
   identify some storage object on some storage device.  The addressing
   formation associated with the deviceID is obtained with
   GETDEVICEINFO.  The interpretation of the objectID depends on the
   storage protocol.  The objectID could be a filehandle for an NFSv4
   storage device.  It could be a OSD object ID for an object server.
   The layout for a block device generally includes additional block map
   information to enumerate blocks or extents that are part of the
   layout.

13.1  Simple Map

   The data is located on a single storage device.  In this case the
   file server can act as the front end for several storage devices and
   distribute files among them.  Each file is limited in its size and
   performance characteristics by a single storage device.  The simple
   map consists of (deviceID, objectID).

13.2  Block Extent Map

   The data is located on a LUN in the SAN.  The layout consists of an
   array of (deviceID, blockID, offset, length) tuples.  Each entry
   describes a block extent.

13.3  Striped Map (RAID 0)

   The data is striped across storage devices.  The parameters of the
   stripe include the number of storage devices (N) and the size of each
   stripe unit (U).  A full stripe of data is N * U bytes.  The stripe
   map consists of an ordered list of (deviceID, objectID) tuples and
   the parameter value for U. The first stripe unit (the first U bytes)
   are stored on the first (deviceID, objectID), the second stripe unit
   on the second (deviceID, objectID) and so forth until the first
   complete stripe.  The data layout then wraps around so that byte
   (N*U) of the file is stored on the first (deviceID, objectID) in the
   list, but starting at offset U within that object.  The striped
   layout allows a client to read or write to the component objects in
   parallel to achieve high bandwidth.

   The striped map for a block device would be slightly different.  The



Shepler                   Expires June 15, 2006                [Page 90]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   map is an ordered list of (deviceID, blockID, blocksize), where the
   deviceID is rotated among a set of devices to achieve striping.

13.4  Replicated Map

   The file data is replicated on N storage devices.  The map consists
   of N (deviceID, objectID) tuples.  When data is written using this
   map, it should be written to N objects in parallel.  When data is
   read, any component object can be used.

   This map type is controversial because it highlights the issues with
   error recovery.  Those issues get interesting with any scheme that
   employs redundancy.  The handling of errors (e.g., only a subset of
   replicas get updated) is outside the scope of this protocol
   extension.  Instead, it is a function of the storage protocol and the
   metadata control protocol.

13.5  Concatenated Map

   The map consists of an ordered set of N (deviceID, objectID, size)
   tuples.  Each successive tuple describes the next segment of the
   file.

13.6  Nested Map

   The nested map is used to compose more complex maps out of simpler
   ones.  The map format is an ordered set of M sub-maps, each submap
   applies to a byte range within the file and has its own type such as
   the ones introduced above.  Any level of nesting is allowed in order
   to build up complex aggregation schemes.

14.  NFSv4.1 Operations

14.1  LOOKUPP - Lookup Parent Directory

   If the NFSv4 minor version is 1, then following replaces section
   14.2.14 of the NFSv4.0 specification.  The LOOKUPP operation's "over
   the wire" format is not altered, but the semantics are slightly
   modified to account for the addition of SECINFO_NO_NAME.

   SYNOPSIS



                 (cfh) -> (cfh)






Shepler                   Expires June 15, 2006                [Page 91]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   ARGUMENT



                 /* CURRENT_FH: object */
                 void;

   RESULT



                 struct LOOKUPP4res {
                 /* CURRENT_FH: directory */
                 nfsstat4        status;
                 };

   DESCRIPTION

      The current filehandle is assumed to refer to a regular directory
      or a named attribute directory.  LOOKUPP assigns the filehandle
      for its parent directory to be the current filehandle.  If there
      is no parent directory an NFS4ERR_NOENT error must be returned.
      Therefore, NFS4ERR_NOENT will be returned by the server when the
      current filehandle is at the root or top of the server's file
      tree.

      As for LOOKUP, LOOKUPP will also cross mountpoints.

      If the current filehandle is not a directory or named attribute
      directory, the error NFS4ERR_NOTDIR is returned.

      If the requester's security flavor does not match that configured
      for the parent directory, then the server SHOULD return
      NFS4ERR_WRONGSEC (a future minor revision of NFSv4 may upgrade
      this to MUST) in the LOOKUPP response.  However, if the server
      does so, it MUST support the new SECINFO_NO_NAME operation, so
      that the client can gracefully determine the correct security
      flavor.  See the discussion of the SECINFO_NO_NAME operation for a
      description.

   ERRORS

      NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_IO
      NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR
      NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
      NFS4ERR_WRONGSEC





Shepler                   Expires June 15, 2006                [Page 92]

Internet-Draft           NFSv4 Minior Version 1            December 2005


14.2  SECINFO -- Obtain Available Security

   If the NFSv4 minor version is 1, then following replaces section
   14.2.31 of the NFSv4.0 specification.  The SECINFO operation's "over
   the wire" format is not altered, but the semantics are slightly
   modified to account for the addition of SECINFO_NO_NAME.

   SYNOPSIS



                 (cfh), name -> { secinfo }

   ARGUMENT



                 struct SECINFO4args {
                 /* CURRENT_FH: directory */
                 component4     name;
                 };

   RESULT




























Shepler                   Expires June 15, 2006                [Page 93]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 enum rpc_gss_svc_t {/* From RFC 2203 */
                 RPC_GSS_SVC_NONE        = 1,
                 RPC_GSS_SVC_INTEGRITY   = 2,
                 RPC_GSS_SVC_PRIVACY     = 3
                 };

                 struct rpcsec_gss_info {
                 sec_oid4        oid;
                 qop4            qop;
                 rpc_gss_svc_t   service;
                 };

                 union secinfo4 switch (uint32_t flavor) {
                 case RPCSEC_GSS:
                 rpcsec_gss_info        flavor_info;
                 default:
                 void;
                 };

                 typedef secinfo4 SECINFO4resok<>;

                 union SECINFO4res switch (nfsstat4 status) {
                 case NFS4_OK:
                 SECINFO4resok resok4;
                 default:
                 void;
                 };

   DESCRIPTION

      The SECINFO operation is used by the client to obtain a list of
      valid RPC authentication flavors for a specific directory
      filehandle, file name pair.  SECINFO should apply the same access
      methodology used for LOOKUP when evaluating the name.  Therefore,
      if the requester does not have the appropriate access to LOOKUP
      the name then SECINFO must behave the same way and return
      NFS4ERR_ACCESS.

      The result will contain an array which represents the security
      mechanisms available, with an order corresponding to the server's
      preferences, the most preferred being first in the array.  The
      client is free to pick whatever security mechanism it both desires
      and supports, or to pick in the server's preference order the
      first one it supports.  The array entries are represented by the
      secinfo4 structure.  The field 'flavor' will contain a value of
      AUTH_NONE, AUTH_SYS (as defined in [RFC1831]), or RPCSEC_GSS (as
      defined in [RFC2203]).  The field flavor can also any other
      security flavor registered with IANA.



Shepler                   Expires June 15, 2006                [Page 94]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      For the flavors AUTH_NONE and AUTH_SYS, no additional security
      information is returned.  The same is true of many (if not most)
      other security flavors, including AUTH_DH.  For a return value of
      RPCSEC_GSS, a security triple is returned that contains the
      mechanism object id (as defined in [RFC2743]), the quality of
      protection (as defined in [RFC2743]) and the service type (as
      defined in [RFC2203]).  It is possible for SECINFO to return
      multiple entries with flavor equal to RPCSEC_GSS with different
      security triple values.

      On success, the current filehandle retains its value.

      If the name has a length of 0 (zero), or if name does not obey the
      UTF-8 definition, the error NFS4ERR_INVAL will be returned.

   IMPLEMENTATION

      The SECINFO operation is expected to be used by the NFS client
      when the error value of NFS4ERR_WRONGSEC is returned from another
      NFS operation.  This signifies to the client that the server's
      security policy is different from what the client is currently
      using.  At this point, the client is expected to obtain a list of
      possible security flavors and choose what best suits its policies.

      As mentioned, the server's security policies will determine when a
      client request receives NFS4ERR_WRONGSEC.  The operations which
      may receive this error are: LINK, LOOKUP, LOOKUPP, OPEN, PUTFH,
      PUTPUBFH, PUTROOTFH, RESTOREFH, RENAME, and indirectly READDIR.
      LINK and RENAME will only receive this error if the security used
      for the operation is inappropriate for saved filehandle.  With the
      exception of READDIR, these operations represent the point at
      which the client can instantiate a filehandle into the "current
      filehandle" at the server.  The filehandle is either provided by
      the client (PUTFH, PUTPUBFH, PUTROOTFH) or generated as a result
      of a name to filehandle translation (LOOKUP and OPEN).  RESTOREFH
      is different because the filehandle is a result of a previous
      SAVEFH.  Even though the filehandle, for RESTOREFH, might have
      previously passed the server's inspection for a security match,
      the server will check it again on RESTOREFH to ensure that the
      security policy has not changed.

      If the client wants to resolve an error return of
      NFS4ERR_WRONGSEC, the following will occur:



      *  For LOOKUP and OPEN, the client will use SECINFO with the same
         current filehandle and name as provided in the original LOOKUP



Shepler                   Expires June 15, 2006                [Page 95]

Internet-Draft           NFSv4 Minior Version 1            December 2005


         or OPEN to enumerate the available security triples.

      *  For LINK, PUTFH, PUTROOTFH, PUTPUBFH, RENAME, and RESTOREFH,
         the client will use SECINFO_NO_NAME { style = current_fh }.
         The client will prefix the SECINFO_NO_NAME operation with the
         appropriate PUTFH, PUTPUBFH, or PUTROOTFH operation that
         provides the file handled originally provided by the PUTFH,
         PUTPUBFH, PUTROOTFH, or RESTOREFH, or for the failed LINK or
         RENAME, the SAVEFH.

      *  ========================================================= NOTE:
         In NFSv4.0, the client was required to use SECINFO, and had to
         reconstruct the parent of the original file handle, and the
         component name of the original filehandle.
         ========================================================

      *  For LOOKUPP, the client will use SECINFO_NO_NAME { style =
         parent } and provide the filehandle with equals the filehandle
         originally provided to LOOKUPP.

      The READDIR operation will not directly return the
      NFS4ERR_WRONGSEC error.  However, if the READDIR request included
      a request for attributes, it is possible that the READDIR
      request's security triple did not match that of a directory entry.
      If this is the case and the client has requested the rdattr_error
      attribute, the server will return the NFS4ERR_WRONGSEC error in
      rdattr_error for the entry.

      See the section "Security Considerations" for a discussion on the
      recommendations for security flavor used by SECINFO and
      SECINFO_NO_NAME.

   ERRORS




14.3  SECINFO_NO_NAME - Get Security on Unnamed Object

   Obtain available security mechanisms with the use of the parent of an
   object or the current filehandle.

   SYNOPSIS



                 (cfh), secinfo_style -> { secinfo }




Shepler                   Expires June 15, 2006                [Page 96]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   ARGUMENT



                 enum secinfo_style_4 {
                 current_fh = 0,
                 parent = 1
                 };

                 typedef secinfo_style_4 SECINFO_NO_NAME4args;

   RESULT



                 typedef SECINFO4res SECINFO_NO_NAME4res;

   DESCRIPTION

      Like the SECINFO operation, SECINFO_NO_NAME is used by the client
      to obtain a list of valid RPC authentication flavors for a
      specific file object.  Unlike SECINFO, SECINFO_NO_NAME only works
      with objects are accessed by file handle.

      There are two styles of SECINFO_NO_NAME, as determined by the
      value of the secinfo_style_4 enumeration.  If "current_fh" is
      passed, then SECINFO_NO_NAME is querying for the required security
      for the current filehandle.  If "parent" is passed, then
      SECINFO_NO_NAME is querying for the required security of the
      current filehandles's parent.  If the style selected is "parent",
      then SECINFO should apply the same access methodology used for
      LOOKUPP when evaluating the traversal to the parent directory.
      Therefore, if the requester does not have the appropriate access
      to LOOKUPP the parent then SECINFO_NO_NAME must behave the same
      way and return NFS4ERR_ACCESS.

      Note that if PUTFH, PUTPUBFH, or PUTROOTFH return
      NFS4ERR_WRONGSEC, this is tantamount to the server asserting that
      the client will have to guess what the required security is,
      because there is no way to query.  Therefore, the client must
      iterate through the security triples available at the client and
      reattempt the PUTFH, PUTROOTFH or PUTPUBFH operation.  In the
      unfortunate event none of the MANDATORY security triples are
      supported by the client and server, the client SHOULD try using
      others that support integrity.  Failing that, the client can try
      using other forms (e.g.  AUTH_SYS and AUTH_NONE), but because such
      forms lack integrity checks, this puts the client at risk.




Shepler                   Expires June 15, 2006                [Page 97]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      The server implementor should pay particular attention to the
      section "Clarification of Security Negotiation in NFSv4.1" for
      implementation suggestions for avoiding NFS4ERR_WRONGSEC error
      returns from PUTFH, PUTROOTFH or PUTPUBFH.

      Everything else about SECINFO_NO_NAME is the same as SECINFO.  See
      the previous discussion on SECINFO.

   IMPLEMENTATION

      See the previous dicussion on SECINFO.

   ERRORS

      NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME
      NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE


14.4  CREATECLIENTID - Instantiate Clientid

   Create a clientid

   SYNOPSIS



                 client -> clientid

   ARGUMENT



                 struct CREATECLIENTID4args {
                 nfs_client_id4  clientdesc;
                 };

   RESULT












Shepler                   Expires June 15, 2006                [Page 98]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 struct CREATECLIENTID4resok {
                 clientid4       clientid;
                 verifier4       clientid_confirm;
                 };

                 union SETCLIENTID4res switch (nfsstat4 status) {
                 case NFS4_OK:
                 CREATECLIENTID4resok      resok4;
                 case NFS4ERR_CLID_INUSE:
                 void;
                 default:
                 void;
                 };

   DESCRIPTION

      The client uses the CREATECLIENTID operation to register a
      particular client identifier with the server.  The clientid
      returned from this operation will be necessary for requests that
      create state on the server and will serve as a parent object to
      sessions created by the client.  In order to verify the clientid
      it must first be used as an argument to CREATESESSION.

   IMPLEMENTATION

      A server's client record is a 5-tuple:



      1.  clientdesc.id:

             The long form client identifier, sent via the client.id
             subfield of the CREATECLIENTID4args structure

      2.  clientdesc.verifier:

             A client-specific value used to indicate reboots, sent via
             the clientdesc.verifier subfield of the CREATECLIENTID4args
             structure

      3.  principal:

             The RPCSEC_GSS principal sent via the RPC headers

      4.  clientid:

             The shorthand client identifier, generated by the server
             and returned via the clientid field in the



Shepler                   Expires June 15, 2006                [Page 99]

Internet-Draft           NFSv4 Minior Version 1            December 2005


             CREATECLIENTID4resok structure

      5.  confirmed:

             A private field on the server indicating whether or not a
             client record has been confirmed.  A client record is
             confirmed if there has been a successful CREATESESSION
             operation to confirm it.  Otherwise it is unconfirmed.  An
             unconfirmed record is established by a CREATECLIENTID call.
             Any unconfirmed record that is not confirmed within a lease
             period may be removed.

      The following identifiers represent special values for the fields
      in the records.

      id_arg:

         The value of the clientdesc.id subfield of the
         CREATECLIENTID4args structure of the current request.

      verifier_arg:

         The value of the clientdesc.verifier subfield of the
         CREATECLIENTID4args structure of the current request.

      old_verifier_arg:

         A value of the clientdesc.verifier field of a client record
         received in a previous request; this is distinct from
         verifier_arg.

      principal_arg:

         The value of the RPCSEC_GSS principal for the current request.

      old_principal_arg:

         A value of the RPCSEC_GSS principal received for a previous
         request.  This is distinct from principal_arg.

      clientid_ret:

         The value of the clientid field the server will return in the
         CREATECLIENTID4resok structure for the current request.







Shepler                   Expires June 15, 2006               [Page 100]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      old_clientid_ret:

         The value of the clientid field the server returned in the
         CREATECLIENTID4resok structure for a previous request.  This is
         distinct from clientid_ret.

      Since CREATECLIENTID is a non-idempotent operation, we must
      consider the possibility that replays may occur as a result of a
      client reboot, network partition, malfunctioning router, etc.
      Replays are identified by the value of the client field of
      CREATECLIENTID4args and the method for dealing with them is
      outlined in the scenarios below.

      The scenarios are described in terms of what client records whose
      clientdesc.id subfield have value equal to id_arg exist in the
      server's set of client records.  Any cases in which there is more
      than one record with identical values for id_arg represent a
      server implementation error.  Operation in the potential valid
      cases is summarized as follows.



      1.  Common case

             If no client records with clientdesc.id matching id_arg
             exist, a new shorthand client identifier clientid_ret is
             generated, and the following unconfirmed record is added to
             the server's state.

             { id_arg, verifier_arg, principal_arg, clientid_ret, FALSE
             }

             Subsequently, the server returns clientid_ret.

      2.  Router Replay

             If the server has the following confirmed record, then this
             request is likely the result of a replayed request due to a
             faulty router or lost connection.

             { id_arg, verifier_arg, principal_arg, clientid_ret, TRUE }

             Since the record has been confirmed, the client must have
             received the server's reply from the initial CREATECLIENTID
             request.  Since this is simply a spurious request, there is
             no modification to the server's state, and the server makes
             no reply to the client.




Shepler                   Expires June 15, 2006               [Page 101]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      3.  Client Collision

             If the server has the following confirmed record, then this
             request is likely the result of a chance collision between
             the values of the clientdesc.id subfield of
             CREATECLIENTID4args for two different clients.

             { id_arg, *, old_principal_arg, clientid_ret, TRUE }

             Since the value of the clientdesc.id subfield of each
             client record must be unique, there is no modification of
             the server's state, and NFS4ERR_CLID_INUSE is returned to
             indicate the client should retry with a different value for
             the clientdesc.id subfield of CREATECLIENTID4args.

             This scenario may also represent a malicious attempt to
             destroy a client's state on the server.  For security
             reasons, the server MUST NOT remove the client's state when
             there is a principal mismatch.

      4.  Replay

             If the server has the following unconfirmed record then
             this request is likely the result of a client replay due to
             a network partition or some other connection failure.

             { id_arg, verifier_arg, principal_arg, clientid_ret, FALSE
             }

             Since the response to the CREATECLIENTID request that
             created this record may have been lost, it is not
             acceptable to drop this duplicate request.  However, rather
             than processing it normally, the existing record is left
             unchanged and clientid_ret, which was generated for the
             previous request, is returned.

      5.  Change of Principal

             If the server has the following unconfirmed record then
             this request is likely the result of a client which has for
             whatever reasons changed principals (possibly to change
             security flavor) after calling CREATECLIENTID, but before
             calling CREATESESSION.

             { id_arg, verifier_arg, old_principal_arg, clientid_ret,
             FALSE}





Shepler                   Expires June 15, 2006               [Page 102]

Internet-Draft           NFSv4 Minior Version 1            December 2005


             Since the client has not changed, the principal field of
             the unconfirmed record is updated to principal_arg and
             clientid_ret is again returned.  There is a small
             possibility that this is merely a collision on the client
             field of CREATECLIENTID4args between unrelated clients, but
             since that is unlikely, and an unconfirmed record does not
             generally have any filesystem pertinent state, we can
             assume it is the same client without risking loss of any
             important state.

             After processing, the following record will exist on the
             server.

             { id_arg, verifier_arg, principal_arg, clientid_ret, FALSE}

      6.  Client Reboot

             If the server has the following confirmed client record,
             then this request is likely from a previously confirmed
             client which has rebooted.

             { id_arg, old_verifier_arg, principal_arg, clientid_ret,
             TRUE }

             Since the previous incarnation of the same client will no
             longer be making requests, lock and share reservations
             should be released immediately rather than forcing the new
             incarnation to wait for the lease time on the previous
             incarnation to expire.  Furthermore, session state should
             be removed since if the client had maintained that
             information across reboot, this request would not have been
             issued.  If the server does not support the
             CLAIM_DELEGATE_PREV claim type, associated delegations
             should be purged as well; otherwise, delegations are
             retained and recovery proceeds according to RFC3530.  The
             client record is updated with the new verifier and its
             status is changed to unconfirmed.

             After processing, clientid_ret is returned to the client
             and the following record will exist on the server.

             { id_arg, verifier_arg, principal_arg, clientid_ret, FALSE
             }

      7.  Reboot before confirmation

             If the server has the following unconfirmed record, then
             this request is likely from a client which rebooted before



Shepler                   Expires June 15, 2006               [Page 103]

Internet-Draft           NFSv4 Minior Version 1            December 2005


             sending a CREATESESSION request.

             { id_arg, old_verifier_arg, *, clientid_ret, FALSE }

             Since this is believed to be a request from a new
             incarnation of the original client, the server updates the
             value of clientdesc.verifier and returns the original
             clientid_ret.  After processing, the following state exists
             on the server.

             { id_arg, verifier_arg, *, clientid_ret, FALSE }

   ERRORS

      NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT


14.5  CREATESESSION - Create New Session and Confirm Clientid

   Start up session and confirm clientid.

   SYNOPSIS



                 clientid, session_args -> sessionid, session_args

   ARGUMENT






















Shepler                   Expires June 15, 2006               [Page 104]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 struct CREATESESSION4args {
                 clientid4       clientid;
                 bool            persist;
                 count4          maxrequestsize;
                 count4          maxresponsesize;
                 count4          maxrequests;
                 count4          headerpadsize;
                 switch (bool clientid_confirm) {
                 case TRUE:
                 verifier4 setclientid_confirm;
                 case FALSE:
                 void;
                 }
                 switch (channelmode4 mode) {
                 case DEFAULT:
                 void;
                 case STREAM:
                 streamchannelattrs4 streamchanattrs;
                 case RDMA:
                 rdmachannelattrs4   rdmachanattrs;
                 };
                 };

   RESULT



























Shepler                   Expires June 15, 2006               [Page 105]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 typedef opaque sessionid4[16];

                 struct CREATESESSION4resok {
                 sessionid4      sessionid;
                 bool            persist;
                 count4          maxrequestsize;
                 count4          maxresponsesize;
                 count4          maxrequests;
                 count4          headerpadsize;
                 switch (channelmode4 mode) {
                 case DEFAULT:
                 void;
                 case STREAM:
                 streamchannelattrs4 streamchanattrs;
                 case RDMA:
                 rdmachannelattrs4   rdmachanattrs;
                 };
                 };

                 union CREATESESSION4res switch (nfsstat4 status) {
                 case NFS4_OK:
                 CREATESESSION4resok     resok4;
                 default:
                 void;
                 };

   DESCRIPTION

      This operation is used by the client to create new session objects
      on the server.  Additionally the first session created with a new
      shorthand client identifier serves to confirm the creation of that
      client's state on the server.  The server returns the parameter
      values for the new session.

   IMPLEMENTATION

      To describe the implementation, the same notation for client
      records introduced in the description of CREATECLIENTID is used
      with the following addition.

      clientid_arg: The value of the clientid field of the
      CREATESESSION4args structure of the current request.

      Since CREATESESSION is a non-idempotent operation, we must
      consider the possibility that replays may occur as a result of a
      client reboot, network partition, malfunctioning router, etc.
      Replays are identified by the value of the clientid and sessionid
      fields of CREATESESSION4args and the method for dealing with them



Shepler                   Expires June 15, 2006               [Page 106]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      is outlined in the scenarios below.

      The processing of this operation is divided into two phases:
      clientid confirmation and session creation.  In case the state for
      the provided clientid has not been verified, it is confirmed
      before the session is created.  Otherwise the clientid
      confirmation phase is skipped and only the session creation phase
      occurs.  Note that since only confirmed clients may create
      sessions, the clientid confirmation stage does not depend upon
      sessionid_arg.

      CLIENTID CONFIRMATION

      The operational cases are described in terms of what client
      records whose clientid field have value equal to clientid_arg
      exist in the server's set of client records.  Any cases in which
      there is more than one record with identical values for clientid
      represent a server implementation error.  Operation in the
      potential valid cases is summarized as follows.



      1.  Common Case

             If the server has the following unconfirmed record, then
             this is the expected confirmation of an unconfirmed record.

             { *, *, principal_arg, clientid_arg, FALSE }

             The confirmed field of the record is set to TRUE and
             processing of the operation continues normally.

      2.  Stale Clientid

             If the server contains no records with clientid equal to
             clientid_arg, then most likely the client's state has been
             purged during a period of inactivity, possibly due to a
             loss of connectivity.  NFS4ERR_STALE_CLIENTID is returned,
             and no changes are made to any client records on the
             server.

      3.  Principal Change or Collision

             If the server has the following record, then the client has
             changed principals after the previous CREATECLIENTID
             request, or there has been a chance collision between
             shortand client identifiers.




Shepler                   Expires June 15, 2006               [Page 107]

Internet-Draft           NFSv4 Minior Version 1            December 2005


             { *, *, old_principal_arg, clientid_arg, * }

             Neither of these cases are permissible.  Processing stops
             and NFS4ERR_CLID_INUSE is returned to the client.  No
             changes are made to any client records on the server.

      SESSION CREATION

      To determine whether this request is a replay, the server examines
      the sessionid argument provided by the client.  If the sessionid
      matches the identifier of a previously created session, then this
      request must be interpreted as a replay.  No new state is created
      and a reply with the parameters of the existing session is
      returned to the client.  If a session corresponding to the
      sessionid does not already exist, then the request is not a replay
      and is processed as follows.

      NOTE: It is the responsibility of the client to generate
      appropriate values for sessionid.  Since the ordering of messages
      sent on different transport connections is not guaranteed,
      immediately reusing the sessionid of a previously destroyed
      session may yield unpredictable results.  Client implementations
      should avoid recently used sessionids to ensure correct behavior.

      The server examines the persist, maxrequestsize, maxresponsesize,
      maxrequests and headerpadsize arguments.  For each argument, if
      the value is acceptable to the server, it is recommended that the
      server use the provided value to create the new session.  If it is
      not acceptable, the server may use a different value, but must
      return the value used to the client.  These parameters have the
      following interpretation.



      persist:

         True if the client desires server support for "reliable"
         semantics.  For sessions in which only idempotent operations
         will be used (e.g. a read-only session), clients should set
         this value to false.  If the server does not or cannot provide
         "reliable" semantics this value must be set to false on return.

      maxrequestsize:

         The maximum size of a COMPOUND request that will be sent by the
         client including RPC headers.





Shepler                   Expires June 15, 2006               [Page 108]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      maxresponsesize:

         The maximum size of a COMPOUND reply that the client will
         accept from the server including RPC headers.  The server must
         not increase the value of this parameter.  If a client sends a
         COMPOUND request for which the size of the reply would exceed
         this value, the server will return NFS4ERR_RESOURCE.

      maxrequests:

         The maximum number of concurrent COMPOUND requests that the
         client will issue on the session.  Subsequent COMPOUND requests
         will each be assigned a slot identifier by the client on the
         range 0 to maxrequests - 1 inclusive.  A slot id cannot be
         reused until the previous request on that slot has completed.

      headerpadsize:

         The maximum amount of padding the client is willing to apply to
         ensure that write payloads are aligned on some boundary at the
         server.  The server should reply with its preferred value, or
         zero if padding is not in use.  The server may decrease this
         value but must not increase it.

      The server creates the session by recording the parameter values
      used and if the persist parameter is true and has been accepted by
      the server, allocating space for the duplicate request cache
      (DRC).

      If the session state is created successfully, the server
      associates it with the session identifier provided by the client.
      This identifier must be unique among the client's active sessions
      but there is no need for it to be globally unique.  Finally, the
      server returns the negotiated values used to create the session to
      the client.

   ERRORS

      NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID


14.6  BIND_BACKCHANNEL - Create a callback channel binding

   Establish a callback channel on the connection.






Shepler                   Expires June 15, 2006               [Page 109]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   SYNOPSIS




   ARGUMENT



                 struct BIND_BACKCHANNEL4args {
                 clientid4 clientid;
                 uint32_t  callback_program;
                 uint32_t  callback_ident;
                 count4         maxrequestsize;
                 count4         maxresponsesize;
                 count4         maxrequests;
                 switch (channelmode4 mode) {
                 case DEFAULT:
                 void;
                 case STREAM:
                 streamchannelattrs4 streamchanattrs;
                 case RDMA:
                 rdmachannelattrs4   rdmachanattrs;
                 };
                 };

   RESULT
























Shepler                   Expires June 15, 2006               [Page 110]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 struct BIND_BACKCHANNEL4resok {
                 count4         maxrequestsize;
                 count4         maxresponsesize;
                 count4         maxrequests;
                 switch (channelmode4 mode) {
                 case DEFAULT:
                 void;
                 case STREAM:
                 streamchannelattrs4 streamchanattrs;
                 case RDMA:
                 rdmachannelattrs4   rdmachanattrs;
                 };
                 };


                 union BIND_BACKCHANNEL4res switch (nfsstat4 status) {
                 case NFS4_OK:
                 BIND_BACKCHANNEL4resok   resok4;
                 default:
                 void;
                 };

   DESCRIPTION

      The BIND_BACKCHANNEL operation serves to establish the current
      connection as a designated callback channel for the specified
      session.  Normally, only one callback channel is bound, however if
      more than one are established, they are used at the server's
      prerogative, no affinity or preference is specified by the client.

      The arguments and results of the BIND_BACKCHANNEL call are a
      subset of the session parameters, and used identically to those
      values on the callback channel only.  However, not all session
      operation channel parameters are relevant to the callback channel,
      for example header padding (since writes of bulk data are not
      performed in callbacks).

   IMPLEMENTATION

      No discussion at this time.

   ERRORS

      TBD







Shepler                   Expires June 15, 2006               [Page 111]

Internet-Draft           NFSv4 Minior Version 1            December 2005


14.7  DESTROYSESSION - Destroy existing session

   Destroy existing session.

   SYNOPSIS



                 void -> status

   ARGUMENT



                 struct DESTROYSESSION4args {
                 sessionid4     sessionid;
                 };

   RESULT



                 struct SESSION_DESTROYres {
                 nfsstat status;
                 };

   DESCRIPTION

      The SESSION_DESTROY operation closes the session and discards any
      active state such as locks, leases, and server duplicate request
      cache entries.  Any remaining connections bound to the session are
      immediately unbound and may additionally be closed by the server.

      This operation must be the final, or only operation in any
      request.  Because the operation results in destruction of the
      session, any duplicate request caching for this request, as well
      as previously completed requests, will be lost.  For this reason,
      it is advisable to not place this operation in a request with
      other state-modifying operations.  In addition, a SEQUENCE
      operation is not required in the request.

      Note that because the operation will never be replayed by the
      server, a client that retransmits the request may receive an error
      in response, even though the session may have been successfully
      destroyed.






Shepler                   Expires June 15, 2006               [Page 112]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   IMPLEMENTATION

      No discussion at this time.

   ERRORS

      TBD


14.8  SEQUENCE - Supply per-procedure sequencing and control

   Supply per-procedure sequencing and control

   SYNOPSIS



                 control -> control

   ARGUMENT



                 typedef uint32_t sequenceid4;
                 typedef uint32_t slotid4;

                 struct SEQUENCE4args {
                 clientid4 clientid;
                 sessionid4     sessionid;
                 sequenceid4    sequenceid;
                 slotid4        slotid;
                 slotid4        maxslot;
                 };

   RESULT
















Shepler                   Expires June 15, 2006               [Page 113]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 struct SEQUENCE4resok {
                 clientid4 clientid;
                 sessionid4     sessionid;
                 sequenceid4    sequenceid;
                 slotid4        slotid;
                 slotid4        maxslot;
                 slotid4        target_maxslot;
                 };

                 union SEQUENCE4res switch (nfsstat4 status) {
                 case NFS4_OK:
                 SEQUENCE4resok resok4;
                 default:
                 void;
                 };

   DESCRIPTION

      The SEQUENCE operation is used to manage operational accounting
      for the session on which the operation is sent.  The contents
      include the client and session to which this request belongs,
      slotid and sequenceid, used by the server to implement session
      request control and the duplicate reply cache semantics, and
      exchanged slot counts which are used to adjust these values.  This
      operation must appear once as the first operation in each COMPOUND
      sent after the channel is successfully bound, or a protocol error
      must result.

   IMPLEMENTATION

      No discussion at this time.

   ERRORS

      NFS4ERR_BADSESSION NFS4ERR_BADSLOT


14.9  CB_RECALLCREDIT - change flow control limits

   Change flow control limits

   SYNOPSIS



                 targetcount -> status





Shepler                   Expires June 15, 2006               [Page 114]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   ARGUMENT



                 struct CB_RECALLCREDIT4args {
                 sessionid4     sessionid;
                 uint32_t  target;
                 };

   RESULT



                 struct CB_RECALLCREDIT4res {
                 nfsstat4   status;
                 };

   DESCRIPTION

      The CB_RECALLCREDIT operation requests the client to return
      session and transport credits to the server, by zero-length RDMA
      Sends or NULL NFSv4 operations.

   IMPLEMENTATION

      No discussion at this time.

   ERRORS

      NONE


14.10  CB_SEQUENCE - Supply callback channel sequencing and control

   Sequence and control

   SYNOPSIS



                 control -> control

   ARGUMENT








Shepler                   Expires June 15, 2006               [Page 115]

Internet-Draft           NFSv4 Minior Version 1            December 2005


                 typedef uint32_t sequenceid4;
                 typedef uint32_t slotid4;

                 struct CB_SEQUENCE4args {
                 clientid4 clientid;
                 sessionid4     sessionid;
                 sequenceid4    sequenceid;
                 slotid4        slotid;
                 slotid4        maxslot;
                 };

   RESULT



                 struct CB_SEQUENCE4resok {
                 clientid4 clientid;
                 sessionid4     sessionid;
                 sequenceid4    sequenceid;
                 slotid4        slotid;
                 slotid4        maxslot;
                 slotid4        target_maxslot;
                 };

                 union CB_SEQUENCE4res switch (nfsstat4 status) {
                 case NFS4_OK:
                 CB_SEQUENCE4resok   resok4;
                 default:
                 void;
                 };

   DESCRIPTION

      The CB_SEQUENCE operation is used to manage operational accounting
      for the callback channel of the session on which the operation is
      sent.  The contents include the client and session to which this
      request belongs, slotid and sequenceid, used by the server to
      implement session request control and the duplicate reply cache
      semantics, and exchanged slot counts which are used to adjust
      these values.  This operation must appear once as the first
      operation in each CB_COMPOUND sent after the callback channel is
      successfully bound, or a protocol error must result.

   IMPLEMENTATION







Shepler                   Expires June 15, 2006               [Page 116]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      No discussion at this time.

   ERRORS

      NFS4ERR_BADSESSION NFS4ERR_BADSLOT


14.11  GET_DIR_DELEGATION - Get a directory delegation

   Obtain a directory delegation.

   SYNOPSIS



       (cfh), requested notification -> (cfh), cookieverf, stateid,
       supported notification

   ARGUMENT



       struct GET_DIR_DELEGATION4args {
       dir_notification_type4      notification_type;
       attr_notice4                child_attr_delay;
       attr_notice4                dir_attr_delay;
       };

       /*
       * Notification types.
       */
       const DIR_NOTIFICATION_NONE                    = 0x00000000;
       const DIR_NOTIFICATION_CHANGE_CHILD_ATTRIBUTES  = 0x00000001;
       const DIR_NOTIFICATION_CHANGE_DIR_ATTRIBUTES   = 0x00000002;
       const DIR_NOTIFICATION_REMOVE_ENTRY            = 0x00000004;
       const DIR_NOTIFICATION_ADD_ENTRY               = 0x00000008;
       const DIR_NOTIFICATION_RENAME_ENTRY            = 0x00000010;
       const DIR_NOTIFICATION_CHANGE_COOKIE_VERIFIER  = 0x00000020;

       typedef uint32_t dir_notification_type4;

       typedef nfstime4 attr_notice4;

   RESULT







Shepler                   Expires June 15, 2006               [Page 117]

Internet-Draft           NFSv4 Minior Version 1            December 2005




       struct GET_DIR_DELEGATION4resok {
           verifier4                       cookieverf;
           /* Stateid for get_dir_delegation */
           stateid4                        stateid;
           /* Which notifications can the server support */
           dir_notification_type4          supp_notification;
           bitmap4                         child_attributes;
           bitmap4                         dir_attributes;
       };

       union GET_DIR_DELEGATION4res switch (nfsstat4 status) {
           case NFS4_OK:
           /* CURRENT_FH: delegated dir */
           GET_DIR_DELEGATION4resok      resok4;
           default:
           void;
       };

   DESCRIPTION

      The GET_DIR_DELEGATION operation is used by a client to request a
      directory delegation.  The directory is represented by the current
      filehandle.  The client also specifies whether it wants the server
      to notify it when the directory changes in certain ways by setting
      one or more bits in a bitmap.  The server may also choose not to
      grant the delegation.  In that case the server will return
      NFS4ERR_DIRDELEG_UNAVAIL.  If the server decides to hand out the
      delegation, it will return a cookie verifier for that directory.
      If the cookie verifier changes when the client is holding the
      delegation, the delegation will be recalled unless the client has
      asked for notification for this event.  In that case a
      notification will be sent to the client.

      The server will also return a directory delegation stateid in
      addition to the cookie verifier as a result of the
      GET_DIR_DELEGATION operation.  This stateid will appear in
      callback messages related to the delegation, such as notifications
      and delegation recalls.  The client will use this stateid to
      return the delegation voluntarily or upon recall.  A delegation is
      returned by calling the DELEGRETURN operation.

      The server may not be able to support notifications of certain
      events.  If the client asks for such notifications, the server
      must inform the client of its inability to do so as part of the
      GET_DIR_DELEGATION reply by not setting the appropriate bits in
      the supported notifications bitmask contained in the reply.



Shepler                   Expires June 15, 2006               [Page 118]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      The GET_DIR_DELEGATION operation can be used for both normal and
      named attribute directories.  It covers all the entries in the
      directory except the ".." entry.  That means if a directory and
      its parent both hold directory delegations, any changes to the
      parent will not cause a notification to be sent for the child even
      though the child's ".." entry points to the parent.

   IMPLEMENTATION

      Directory delegation provides the benefit of improving cache
      consistency of namespace information.  This is done through
      synchronous callbacks.  A server must support synchronous
      callbacks in order to support directory delegations.  In addition
      to that, asynchronous notifications provide a way to reduce
      network traffic as well as improve client performance in certain
      conditions.  Notifications would not be requested when the goal is
      just cache consitency.

      Notifications are specified in terms of potential changes to the
      directory.  A client can ask to be notified whenever an entry is
      added to a directory by setting notification_type to
      DIR_NOTIFICATION_ADD_ENTRY.  It can also ask for notifications on
      entry removal, renames, directory attribute changes and cookie
      verifier changes by setting notification_type flag appropriately.
      In addition to that, the client can also ask for notifications
      upon attribute changes to children in the directory to keep its
      attribute cache up to date.  However any changes made to child
      attributes do not cause the delegation to be recalled.  If a
      client is interested in directory entry caching, or negative name
      caching, it can set the notification_type appropriately and the
      server will notify it of all changes that would otherwise
      invalidate its name cache.  The kind of notification a client asks
      for may depend on the directory size, its rate of change and the
      applications being used to access that directory.  However, the
      conditions under which a client might ask for a notification, is
      out of the scope of this specification.

      The client will set one or more bits in a bitmap
      (notification_type) to let the server know what kind of
      notification(s) it is interested in.  For attribute notifications
      it will set bits in another bitmap to indicate which attributes it
      wants to be notified of.  If the server does not support
      notifications for changes to a certain attribute, it should not
      set that attribute in the supported attribute bitmap
      (supp_notification) specified in the reply.






Shepler                   Expires June 15, 2006               [Page 119]

Internet-Draft           NFSv4 Minior Version 1            December 2005


      In addition to that, the client will also let the server know if
      it wants to get the notification as soon as the attribute change
      occurs or after a certain delay by setting a delay factor,
      child_attr_delay for attribute changes to children and
      dir_attr_delay for attribute changes to the directory.  If this
      delay factor is set to zero, that indicates to the server that the
      client wants to be notified of any attribute changes as soon as
      they occur.  If the delay factor is set to N, the server will make
      a best effort guarantee that attribute updates are not out of sync
      by more than that.  One value covers all attribute changes for the
      directory and another value covers all attribute changes for all
      children in the directory.  If the client asks for a delay factor
      that the server does not support or that may cause significant
      resource consumption on the server by causing the server to send a
      lot of notifications, the server should not commit to sending out
      notifications for that attribute and therefore must not set the
      approprite bit in the child_attributes and dir_attributes bitmaps
      in the response.

      The server will let the client know about which notifications it
      can support by setting appropriate bits in a bitmap.  If it agrees
      to send attribute notifications, it will also set two attribute
      masks indicating which attributes it will send change
      notifications for.  One of the masks covers changes in directory
      attributes and the other covers atttribute changes to any files in
      the directory.

      The client should use a security flavor that the filesystem is
      exported with.  If it uses a different flavor, the server should
      return NFS4ERR_WRONGSEC.

   ERRORS

      NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR
      NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
      NFS4ERR_DIRDELEG_UNAVAIL NFS4ERR_WRONGSEC NFS4ERR_EIO
      NFS4ERR_NOTSUPP


14.12  CB_NOTIFY - Notify directory changes

   Tell the client of directory changes.








Shepler                   Expires June 15, 2006               [Page 120]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   SYNOPSIS



                 stateid, notification -> {}

   ARGUMENT



       struct CB_NOTIFY4args {
           stateid4              stateid;
           dir_notification4     changes<>;
       };

       /*
       * Notification information sent to the client.
       */
       union dir_notification4
       switch (dir_notification_type4 notification_type) {
           case DIR_NOTIFICATION_CHANGE_CHILD_ATTRIBUTES:
               dir_notification_attribute4 change_child_attributes;
           case DIR_NOTIFICATION_CHANGE_DIR_ATTRIBUTES:
               fattr4                      change_dir_attributes;
           case DIR_NOTIFICATION_REMOVE_ENTRY:
               dir_notification_remove4    remove_notification;
           case DIR_NOTIFICATION_ADD_ENTRY:
               dir_notification_add4       add_notification;
           case DIR_NOTIFICATION_RENAME_ENTRY:
               dir_notification_rename4    rename_notification;
           case DIR_NOTIFICATION_CHANGE_COOKIE_VERIFIER:
               dir_notification_verifier4  verf_notification;
       };

       /*
       * Changed entry information.
       */
       struct dir_entry {
           component4      file;
           fattr4          attrs;
       };

       struct dir_notification_attribute4 {
           dir_entry    changed_entry;
       };

       struct dir_notification_remove4 {
           dir_entry      old_entry;



Shepler                   Expires June 15, 2006               [Page 121]

Internet-Draft           NFSv4 Minior Version 1            December 2005


           nfs_cookie4    old_entry_cookie;
       };

       struct dir_notification_rename4 {
           dir_entry              old_entry;
           dir_notification_add4  new_entry;
       };

       struct dir_notification_verifier4 {
           verifier4       old_cookieverf;
           verifier4       new_cookieverf;
       };

       struct dir_notification_add4 {
           dir_entry       new_entry;
           /* what READDIR would have returned for this entry */
           nfs_cookie4     new_entry_cookie;
           bool            last_entry;
           prev_entry_info4     prev_info;
           };

       union prev_entry_info4 switch (bool isprev) {
           case TRUE:       /* A previous entry exists */
           prev_entry4 prev_entry_info;
           case FALSE:       /* we are adding to an empty
           directory */
           void;
       };

       /*
       * Previous entry information
       */
       struct prev_entry4 {
           dir_entry       prev_entry;
           /* what READDIR returned for this entry */
           nfs_cookie4     prev_entry_cookie;
       };

   RESULT



                 struct CB_NOTIFY4res {
                 nfsstat4        status;
                 };






Shepler                   Expires June 15, 2006               [Page 122]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   DESCRIPTION

      The CB_NOTIFY operation is used by the server to send
      notifications to clients about changes in a delegated directory.
      These notifications are sent over the callback path.  The
      notification is sent once the original request has been processed
      on the server.  The server will send an array of notifications for
      all changes that might have occurred in the directory.  The
      dir_notification_type4 can only have one bit set for each
      notification in the array.  If the client holding the delegation
      makes any changes in the directory that cause files or sub
      directories to be added or removed, the server will notify that
      client of the resulting change(s).  If the client holding the
      delegation is making attribute or cookie verifier changes only,
      the server does not need to send notifications to that client.
      The server will send the following information for each operation:



      *  ADDING A FILE:  The server will send information about the new
         entry being created along with the cookie for that entry.  The
         entry information contains the nfs name of the entry and
         attributes.  If this entry is added to the end of the
         directory, the server will set a last_entry flag to true.  If
         the file is added such that there is atleast one entry before
         it, the server will also return the previous entry information
         along with its cookie.  This is to help clients find the right
         location in their DNLC or directory caches where this entry
         should be cached.

      *  REMOVING A FILE:  The server will send information about the
         directory entry being deleted.  The server will also send the
         cookie value for the deleted entry so that clients can get to
         the cached information for this entry.

      *  RENAMING A FILE:  The server will send information about both
         the old entry and the new entry.  This includes name and
         attributes for each entry.  This notification is only sent if
         both entries are in the same directory.  If the rename is
         across directories, the server will send a remove notification
         to one directory and an add notification to the other
         directory, assuming both have a directory delegation.

      *  FILE/DIR ATTRIBUTE CHANGE:  The client will use the attribute
         mask to inform the server of attributes for which it wants to
         receive notifications.  This change notification can be
         requested for both changes to the attributes of the directory
         as well as changes to any file attributes in the directory by



Shepler                   Expires June 15, 2006               [Page 123]

Internet-Draft           NFSv4 Minior Version 1            December 2005


         using two separate attribute masks.  The client can not ask for
         change attribute notification per file.  One attribute mask
         covers all the files in the directory.  Upon any attribute
         change, the server will send back the values of changed
         attributes.  Notifications might not make sense for some
         filesystem wide attributes and it is up to the server to decide
         which subset it wants to support.  The client can negotiate the
         frequency of attribute notifications by letting the server know
         how often it wants to be notified of an attribute change.  The
         server will return supported notification frequencies or an
         indication that no notification is permitted for directory or
         child attributes by setting the supp_dir_attr_notice and
         supp_child_attr_notice attributes respectively.

      *  COOKIE VERIFIER CHANGE:  If the cookie verifier changes while a
         client is holding a delegation, the server will notify the
         client so that it can invalidate its cookies and reissue a
         READDIR to get the new set of cookies.

   IMPLEMENTATION



   ERRORS

      NFS4ERR_BAD_STATEID NFS4ERR_INVAL NFS4ERR_BADXDR
      NFS4ERR_SERVERFAULT


14.13  CB_RECALL_ANY - Keep any N delegations

   Notify client to return delegation and keep N of them.

   SYNOPSIS



                 N -> {}

   ARGUMENT



                 struct CB_RECALLANYY4args {
                 uint4          dlgs_to_keep;
                 }





Shepler                   Expires June 15, 2006               [Page 124]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   RESULT



                 struct CB_RECALLANY4res {
                 nfsstat4        status;
                 };

   DESCRIPTION

      The server may decide that it can not hold all the delegation
      state without running out of resources.  Since the server has no
      knowledge of which delegations are being used more than others, it
      can not implement an effective reclaim scheme that avoids
      reclaiming frequently used delegations.  In that case the server
      may issue a CB_RECALL_ANY callback to the client asking it to keep
      N delegations and return the rest.  The reason why CB_RECALL_ANY
      specifies a count of delegations the client may keep as opposed to
      a count of delegations the client must yield is as follows.  Were
      it otherwise, there is a potential for a race between a
      CB_RECALL_ANY that had a count of delegations to free with a set
      of client originated operations to return delegations.  As a
      result of the race the client and server would have differing
      ideas as to how many delegations to return.  Hence the client
      could mistakenly free too many delegations.  This operation
      applies to delegations for a regular file (read or write) as well
      as for a directory.

      The client can choose to return any type of delegation as a result
      of this callback i.e. read, write or directory delegation.  The
      client can also choose to keep more delegations than what the
      server asked for and it is up to the server to handle this
      situation.  The server must give the client enough time to return
      the delegations.  This time should not be less than the lease
      period.

   IMPLEMENTATION



   ERRORS

      NFS4ERR_RESOURCE








Shepler                   Expires June 15, 2006               [Page 125]

Internet-Draft           NFSv4 Minior Version 1            December 2005


14.14  LAYOUTGET - Get Layout Information

   SYNOPSIS

     (cfh), clientid, layout_type, iomode, offset, length,
     minlength, maxcount -> layout

   ARGUMENT

     struct LAYOUTGET4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             pnfs_layouttype4        layout_type;
             pnfs_layoutiomode4      iomode;
             offset4                 offset;
             length4                 length;
             length4                 minlength;
             count4                  maxcount;
     };

   RESULT

     struct LAYOUTGET4resok {
             pnfs_layout4            layout;
     };

     union LAYOUTGET4res switch (nfsstat4 status) {
             case NFS4_OK:
                     LAYOUTGET4resok resok4;
             default:
                     void;
     };

   DESCRIPTION

   Requests a layout for reading or writing (and reading) the file given
   by the filehandle at the byte range specified by offset and length.
   Layouts are identified by the clientid, filehandle, and layout type.
   The use of the iomode depends upon the layout type, but should
   reflect the client's data access intent.

   The LAYOUTGET operation returns layout information for the specified
   byte range, a layout segment.  To get a layout segment from a
   specific offset through the end-of-file, regardless of the file's
   length, a length field with all bits set to 1 (one) should be used.
   If the length is zero, or if a length which is not all bits set to
   one is specified, and length when added to the offset exceeds the
   maximum 64-bit unsigned integer value, the error NFS4ERR_INVAL will



Shepler                   Expires June 15, 2006               [Page 126]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   result.

   The "minlength" field specifies the minimum size overlap with the
   requested offset and length that is to be returned.  If this
   requirement cannot be met, no layout must be returned; the error
   NFS4ERR_LAYOUTTRYLATER can be returned.

   The "maxcount" field specifies the maximum layout size (in bytes)
   that the client can handle.  If the size of the layout structure
   exceeds the size specified by maxcount, the metadata server will
   return the NFS4ERR_TOOSMALL error.

   As well, the metadata server may adjust the range of the returned
   layout segment based on striping patterns and usage implied by the
   iomode.  The client must be prepared to get a layout that does not
   line up exactly with their request; there MUST be at least an overlap
   of "minlength" between the layout returned by the server and the
   client's request, or the server SHOULD reject the request.  See
   Section 7.3 for more details.

   The metadata server may also return a layout segment with an iomode
   other than that requested by the client.  If it does so, it must
   ensure that the iomode is more permissive than the iomode requested.
   E.g., this allows an implementation to upgrade read-only requests to
   read/write requests at its discretion, within the limits of the
   layout type specific protocol.  An iomode of either LAYOUTIOMODE_READ
   or LAYOUTIOMODE_RW must be returned.

   The format of the returned layout is specific to the underlying file
   system.  Layout types other than the NFSv4 file layout type should be
   specified outside of this document.

   If layouts are not supported for the requested file or its containing
   file system the server SHOULD return NFS4ERR_LAYOUTUNAVAILABLE.  If
   the layout type is not supported, the metadata server should return
   NFS4ERR_UNKNOWN_LAYOUTTYPE.  If layouts are supported but no layout
   matches the client provided layout identification, the server should
   return NFS4ERR_BADLAYOUT.  If an invalid iomode is specified, or an
   iomode of LAYOUTIOMODE_ANY is specified, the server should return
   NFS4ERR_BADIOMODE.

   If the layout for the file is unavailable due to transient
   conditions, e.g. file sharing prohibits layouts, the server must
   return NFS4ERR_LAYOUTTRYLATER.

   If the layout request is rejected due to an overlapping layout
   recall, the server must return NFS4ERR_RECALLCONFLICT.  See
   Section 7.5.3 for details.



Shepler                   Expires June 15, 2006               [Page 127]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   If the layout conflicts with a mandatory byte range lock held on the
   file, and if the storage devices have no method of enforcing
   mandatory locks, other than through the restriction of layouts, the
   metadata server should return NFS4ERR_LOCKED.

   On success, the current filehandle retains its value.

   IMPLEMENTATION

   Typically, LAYOUTGET will be called as part of a compound RPC after
   an OPEN operation and results in the client having location
   information for the file; a client may also hold a layout across
   multiple OPENs.  The client specifies a layout type that limits what
   kind of layout the server will return.  This prevents servers from
   issuing layouts that are unusable by the client.

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_LAYOUTUNAVAILABLE
      NFS4ERR_LAYOUTTRYLATER
      NFS4ERR_LOCKED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTSUPP
      NFS4ERR_RECALLCONFLICT
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_TOOSMALL
      NFS4ERR_UNKNOWN_LAYOUTTYPE


14.15  LAYOUTCOMMIT - Commit writes made using a layout
















Shepler                   Expires June 15, 2006               [Page 128]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   SYNOPSIS

     (cfh), clientid, offset, length, last_write_offset,
     time_modify, time_access, layoutupdate -> newsize


   ARGUMENT

     union newtime4 switch (bool timechanged) {
             case TRUE:
                     nfstime4           time;
             case FALSE:
                     void;
     };

     union newsize4 switch (bool sizechanged) {
             case TRUE:
                     length4            size;
             case FALSE:
                     void;
     };

     struct LAYOUTCOMMIT4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             offset4                 offset;
             length4                 length;
             length4                 last_write_offset;
             newtime4                time_modify;
             newtime4                time_access;
             pnfs_layoutupdate4      layoutupdate;
     };

   RESULT

     struct LAYOUTCOMMIT4resok {
            newsize4                 newsize;
     };

     union LAYOUTCOMMIT4res switch (nfsstat4 status) {
             case NFS4_OK:
                     LAYOUTCOMMIT4resok  resok4;
             default:
                     void;
     };

   DESCRIPTION




Shepler                   Expires June 15, 2006               [Page 129]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Commits changes in the layout segment represented by the current
   filehandle, clientid, and byte range.  Since layouts are sub-
   dividable, a smaller portion of a layout, retrieved via LAYOUTGET,
   may be committed.  The region being committed is specified through
   the byte range (length and offset).  Note: the "layoutupdate"
   structure does not include the length and offset, as they are already
   specified in the arguments.

   The LAYOUTCOMMIT operation indicates that the client has completed
   writes using a layout obtained by a previous LAYOUTGET.  The client
   may have only written a subset of the data range it previously
   requested.  LAYOUTCOMMIT allows it to commit or discard provisionally
   allocated space and to update the server with a new end of file.  The
   layout referenced by LAYOUTCOMMIT is still valid after the operation
   completes and can be continued to be referenced by the clientid,
   filehandle, byte range, and layout type.

   The "last_write_offset" field specifies the offset of the last byte
   written by the client previous to the LAYOUTCOMMIT.  Note: this value
   is never equal to the file's size (at most it is one byte less than
   the file's size).  The metadata server may use this information to
   determine whether the file's size needs to be updated.  If the
   metadata server updates the file's size as the result of the
   LAYOUTCOMMIT operation, it must return the new size as part of the
   results.

   The "time_modify" and "time_access" fields allow the client to
   suggest times it would like the metadata server to set.  The metadata
   server may use these time values or it may use the time of the
   LAYOUTCOMMIT operation to set these time values.  If the metadata
   server uses the client provided times, it should sanity check the
   values (e.g., to ensure time does not flow backwards).  If the client
   wants to force the metadata server to set an exact time, the client
   should use a SETATTR operation in a compound right after
   LAYOUTCOMMIT.  See Section 7.4 for more details.  If the new client
   desires the resultant mtime or atime, it should issue a GETATTR
   following the LAYOUTCOMMIT; e.g., later in the same compound.

   The "layoutupdate" argument to LAYOUTCOMMIT provides a mechanism for
   a client to provide layout specific updates to the metadata server.
   For example, the layout update can describe what regions of the
   original layout have been used and what regions can be deallocated.
   There is no NFSv4 file layout specific layoutupdate structure.

   The layout information is more verbose for block devices than for
   objects and files because the latter hide the details of block
   allocation behind their storage protocols.  At the minimum, the
   client needs to communicate changes to the end of file location back



Shepler                   Expires June 15, 2006               [Page 130]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   to the server, and, if desired, its view of the file modify and
   access time.  For block/volume layouts, it needs to specify precisely
   which blocks have been used.

   If the layout identified in the arguments does not exist, the error
   NFS4ERR_BADLAYOUT is returned.  The layout being committed may also
   be rejected if it does not correspond to an existing layout with an
   iomode of RW.

   On success, the current filehandle retains its value.

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_UNKNOWN_LAYOUTTYPE


14.16  LAYOUTRETURN - Release Layout Information

   SYNOPSIS

     (cfh), clientid, offset, length, iomode, layout_type -> -

   ARGUMENT

     struct LAYOUTRETURN4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             offset4                 offset;
             length4                 length;
             pnfs_layoutiomode4      iomode;
             pnfs_layouttype4        layout_type;
     };

   RESULT

     struct LAYOUTRETURN4res {
             nfsstat4        status;
     };

   DESCRIPTION




Shepler                   Expires June 15, 2006               [Page 131]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Returns the layout segment represented by the current filehandle,
   clientid, byte range, iomode, and layout type.  After this call, the
   client MUST NOT use the layout and the associated storage protocol to
   access the file data.  The layout being returned may be a subdivision
   of a layout previously fetched through LAYOUTGET.  As well, it may be
   a subset or superset of a layout specified by CB_LAYOUTRECALL.
   However, if it is a subset, the recall is not complete until the full
   byte range has been returned.  It is also permissible, and no error
   should result, for a client to return a byte range covering a layout
   it does not hold.  If the length is all 1s, the layout covers the
   range from offset to EOF.  An iomode of ANY specifies that all
   layouts that match the other arguments to LAYOUTRETURN (i.e.,
   clientid, byte range, and type) are being returned.

   Layouts may be returned when recalled or voluntarily (i.e., before
   the server has recalled them).  In either case the client must
   properly propagate state changed under the context of the layout to
   storage or to the server before returning the layout.

   If a client fails to return a layout in a timely manner, then the
   metadata server should use its control protocol with the storage
   devices to fence the client from accessing the data referenced by the
   layout.  See Section 7.5 for more details.

   If the layout identified in the arguments does not exist, the error
   NFS4ERR_BADLAYOUT is returned.  If a layout exists, but the iomode
   does not match, NFS4ERR_BADIOMODE is returned.

   On success, the current filehandle retains its value.

   [OPEN ISSUE: Should LAYOUTRETURN be modified to handle FSID
   callbacks?]

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_UNKNOWN_LAYOUTTYPE








Shepler                   Expires June 15, 2006               [Page 132]

Internet-Draft           NFSv4 Minior Version 1            December 2005


14.17  GETDEVICEINFO - Get Device Information

   SYNOPSIS

     (cfh), device_id, layout_type, maxcount -> device_addr

   ARGUMENT

     struct GETDEVICEINFO4args {
             /* CURRENT_FH: file */
             pnfs_deviceid4                  device_id;
             pnfs_layouttype4                layout_type;
             count4                          maxcount;
     };

   RESULT

     struct GETDEVICEINFO4resok {
             pnfs_deviceaddr4                device_addr;
     };

     union GETDEVICEINFO4res switch (nfsstat4 status) {
             case NFS4_OK:
                     GETDEVICEINFO4resok     resok4;
             default:
                     void;
     };

   DESCRIPTION

   Returns device type and device address information for a specified
   device.  The returned device_addr includes a type that indicates how
   to interpret the addressing information for that device.  The current
   filehandle (cfh) is used to identify the file system; device IDs are
   unique per file system (FSID) and are qualified by the layout type.

   See Section 7.1.4 for more details on device ID assignment.

   If the size of the device address exceeds maxcount bytes, the
   metadata server will return the error NFS4ERR_TOOSMALL.  If an
   invalid device ID is given, the metadata server will respond with
   NFS4ERR_INVAL.

   ERRORS

      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_TOOSMALL



Shepler                   Expires June 15, 2006               [Page 133]

Internet-Draft           NFSv4 Minior Version 1            December 2005


       NFS4ERR_UNKNOWN_LAYOUTTYPE


14.18   GETDEVICELIST - Get List of Devices

   SYNOPSIS

     (cfh), layout_type, maxcount, cookie, cookieverf ->
     cookie, cookieverf, device_addrs<>

   ARGUMENT

     struct GETDEVICELIST4args {
             /* CURRENT_FH: file */
             pnfs_layouttype4                layout_type;
             count4                          maxcount;
             nfs_cookie4                     cookie;
             verifier4                       cookieverf;
     };

   RESULT

     struct GETDEVICELIST4resok {
             nfs_cookie4                     cookie;
             verifier4                       cookieverf;
             pnfs_devlist_item4              device_addrs<>;
     };

     union GETDEVICELIST4res switch (nfsstat4 status) {
             case NFS4_OK:
                     GETDEVICELIST4resok     resok4;
             default:
                     void;
     };

   DESCRIPTION

   In some applications, especially SAN environments, it is convenient
   to find out about all the devices associated with a file system.
   This lets a client determine if it has access to these devices, e.g.,
   at mount time.

   This operation returns an array of items (pnfs_devlist_item4) that
   establish the association between the short pnfs_deviceid4 and the
   addressing information for that device, for a particular layout type.
   This operation may not be able to fetch all device information at
   once, thus it uses a cookie based approach, similar to READDIR, to
   fetch additional device information (see [2], section 14.2.24).  As



Shepler                   Expires June 15, 2006               [Page 134]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   in GETDEVICEINFO, the current filehandle (cfh) is used to identify
   the file system.

   As in GETDEVICEINFO, maxcount specifies the maximum number of bytes
   to return.  If the metadata server is unable to return a single
   device address, it will return the error NFS4ERR_TOOSMALL.  If an
   invalid device ID is given, the metadata server will respond with
   NFS4ERR_INVAL.

   ERRORS

      NFS4ERR_BAD_COOKIE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_TOOSMALL
      NFS4ERR_UNKNOWN_LAYOUTTYPE



































Shepler                   Expires June 15, 2006               [Page 135]

Internet-Draft           NFSv4 Minior Version 1            December 2005


14.19  CB_LAYOUTRECALL

   SYNOPSIS

     layout_type, iomode, layoutchanged, layoutrecall -> -

   ARGUMENT

     enum layoutrecall_type4 {
             RECALL_FILE = 1,
             RECALL_FSID = 2
     };

     struct layoutrecall_file4 {
             nfs_fh4         fh;
             offset4         offset;
             length4         length;
     };

     union layoutrecall4 switch(layoutrecall_type4 recalltype) {
             case RECALL_FILE:
                     layoutrecall_file4 layout;
             case RECALL_FSID:
                     fsid4              fsid;
     };

     struct CB_LAYOUTRECALLargs {
             pnfs_layouttype4        layout_type;
             pnfs_layoutiomode4      iomode;
             bool                    layoutchanged;
             layoutrecall4           layoutrecall;
     };

   RESULT

     struct CB_LAYOUTRECALLres {
             nfsstat4        status;
     };

   DESCRIPTION

   The CB_LAYOUTRECALL operation is used to begin the process of
   recalling a layout, a portion thereof, or all layouts pertaining to a
   particular file system (FSID).  If RECALL_FILE is specified, the
   offset and length fields specify the portion of the layout to be
   returned.  The iomode specifies the set of layouts to be returned.
   An iomode of ANY specifies that all matching layouts, regardless of
   iomode, must be returned; otherwise, only layouts that exactly match



Shepler                   Expires June 15, 2006               [Page 136]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   the iomode must be returned.

   If the "layoutchanged" field is TRUE, then the client SHOULD not
   flush its dirty data to the devices specified by the layout being
   recalled.  Instead, it is preferable for the client to flush the
   dirty data through the metadata server.  Alternatively, the client
   may attempt to obtain a new layout.  Note: in order to obtain a new
   layout the client must first return the old layout.  Since obtaining
   a new layout is not guaranteed to succeed, the client must be ready
   to flush its dirty data through the metadata server.

   If RECALL_FSID is specified, the fsid specifies the file system for
   which any outstanding layouts must be returned.  Layouts are returned
   through the LAYOUTRETURN operation.

   If the client does not hold any layout segment either matching or
   overlapping with the requested layout, it returns
   NFS4ERR_NOMATCHING_LAYOUT.  If a length of all 1s is specified then
   the layout corresponding to the byte range from "offset" to the end-
   of-file MUST be returned.

   IMPLEMENTATION

   The client should reply to the callback immediately.  Replying does
   not complete the recall except when an error is returned.  The recall
   is not complete until the layout(s) are returned using a
   LAYOUTRETURN.

   The client should complete any in-flight I/O operations using the
   recalled layout(s) before returning it/them via LAYOUTRETURN.  If the
   client has buffered dirty data there are a number of options for
   flushing that data.  If "layoutchanged" is false, the client may
   choose to write dirty data directly to storage before calling
   LAYOUTRETURN.  However, if "layoutchanged" is true, the client may
   either choose to write it later using normal NFSv4 WRITE operations
   to the metadata server or it may attempt to obtain a new layout,
   after first returning the recalled layout, using the new layout to
   flush the dirty data.  Regardless of whether the client is holding a
   layout, it may always write data through the metadata server.

   If dirty data is flushed while the layout is held, the client must
   still issue LAYOUTCOMMIT operations at the appropriate time,
   especially before issuing the LAYOUTRETURN.  If a large amount of
   dirty data is outstanding, the client may issue LAYOUTRETURNs for
   portions of the layout being recalled; this allows the server to
   monitor the client's progress and adherence to the callback.
   However, the last LAYOUTRETURN in a sequence of returns, SHOULD
   specify the full range being recalled (see Section 7.5.2 for



Shepler                   Expires June 15, 2006               [Page 137]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   details).

   ERRORS

      NFS4ERR_NOMATCHING_LAYOUT


14.20  CB_SIZECHANGED

   SYNOPSIS

     fh, size -> -

   ARGUMENT

     struct CB_SIZECHANGEDargs {
             nfs_fh4         fh;
             length4         size;
     };

   RESULT

     struct CB_SIZECHANGEDres {
             nfsstat4        status;
     };

   DESCRIPTION

   The CB_SIZECHANGED operation is used to notify the client that the
   size pertaining to the filehandle associated with "fh", has changed.
   The new size is specified.  Upon reception of this notification
   callback, the client should update its internal size for the file.
   If the layout being held for the file is of the NFSv4 file layout
   type, then the size field within that layout should be updated (see
   Section 9.5).  For other layout types see Section 7.4.2 for more
   details.

   If the handle specified is not one for which the client holds a
   layout, an NFS4ERR_BADHANDLE error is returned.

   ERRORS

      NFS4ERR_BADHANDLE


15.  References





Shepler                   Expires June 15, 2006               [Page 138]

Internet-Draft           NFSv4 Minior Version 1            December 2005


15.1  Normative References

   [1]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", March 1997.

   [2]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame,
        C., Eisler, M., and D. Noveck, "Network File System (NFS)
        version 4 Protocol", RFC 3530, April 2003.

15.2  Informative References

   [3]  Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M., and E.
        Zeidner, "Internet Small Computer Systems Interface (iSCSI)",
        RFC 3720, April 2004.

   [4]  Snively, R., "Fibre Channel Protocol for SCSI, 2nd Version
        (FCP-2)", ANSI/INCITS 350-2003, Oct 2003.

   [5]  Weber, R., "Object-Based Storage Device Commands (OSD)", ANSI/
        INCITS 400-2004, July 2004,
        <http://www.t10.org/ftp/t10/drafts/osd/osd-r10.pdf>.

   [6]  Black, D., "pNFS Block/Volume Layout", July 2005, <ftp://
        www.ietf.org/internet-drafts/draft-black-pnfs-block-01.txt>.

   [7]  Zelenka, J., Welch, B., and B. Halevy, "Object-based pNFS
        Operations", July 2005, <ftp://www.ietf.org/internet-drafts/
        draft-zelenka-pnfs-obj-01.txt>.


Author's Address

   Spencer Shepler
   Sun Microsystems, Inc.
   7808 Moonflower Drive
   Austin, TX  78750
   USA

   Phone: +1-512-349-9376
   Email: spencer.shepler@sun.com

Appendix A.  Acknowledgments

   The initial drafts for the SECINFO extensions were edited by Mike
   Eisler with contributions from Tom Talpey, Saadia Khan, and Jon
   Bauman.

   The initial drafts for the SESSIONS extensions were edited by Tom



Shepler                   Expires June 15, 2006               [Page 139]

Internet-Draft           NFSv4 Minior Version 1            December 2005


   Talpey, Spencer Shepler, Jon Bauman with contributions from Charles
   Antonelli, Brent Callaghan, Mike Eisler, John Howard, Chet Juszczak,
   Trond Myklebust, Dave Noveck, John Scott, Mike stolarchuk and Mark
   Wittle.

   The initial drafts for the Directory Delegations support were
   contributed by Saadia Khan with input from Dave Noveck, Mike Eisler,
   Carl Burnett, Ted Anderson and Tom Talpey.

   The initial drafts for the parellel NFS support were edited by Brent
   Welch and Garth Goodson.  Additional authors for those documents were
   Benny Halevy, David Black, and Andy Adamson.  Additional input came
   from the informal group which contributed to the construction of the
   initial pNFS drafts; specific acknowledgement goes to Gary Grider,
   Peter Corbett, Dave Noveck, and Peter Honeyman.  The pNFS work was
   inspired by the NASD and OSD work done by Garth Gibson.  Gary Grider
   of the national labs (LANL) has also been a champion of high-
   performance parallel I/O.

































Shepler                   Expires June 15, 2006               [Page 140]

Internet-Draft           NFSv4 Minior Version 1            December 2005


Intellectual Property Statement

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Copyright Statement

   Copyright (C) The Internet Society (2005).  This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Acknowledgment

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Shepler                   Expires June 15, 2006               [Page 141]

