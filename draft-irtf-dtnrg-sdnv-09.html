<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Using Self-Delimiting Numeric Values in Protocols</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Problems with Fixed Value Fields">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 SDNVs for DTN Protocols">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 SDNV Usage">
<link href="#rfc.section.2" rel="Chapter" title="2 Definition of SDNVs">
<link href="#rfc.section.3" rel="Chapter" title="3 Basic Algorithms">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Encoding Algorithm">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Decoding Algorithm">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Limitations of Implementations">
<link href="#rfc.section.4" rel="Chapter" title="4 Comparison to Alternatives">
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A SNDV Python Source Code">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="Self-Delimiting Numeric Values (SDNVs) have recently been introduced as a field type in proposed Delay-Tolerant Networking protocols. SDNVs encode an arbitrary-length non-negative integer or arbitrary-length bit-string with minimum overhead. They are intended to provide protocol flexibility without sacrificing economy, and to assist in future-proofing protocols under development. This document describes formats and algorithms for SDNV encoding and decoding, along with notes on implementation and usage. This document is a product of the Delay Tolerant Networking Research Group and has been reviewed by that group.  No objections to its publication as an RFC were raised." />
  <meta name="description" content="Self-Delimiting Numeric Values (SDNVs) have recently been introduced as a field type in proposed Delay-Tolerant Networking protocols. SDNVs encode an arbitrary-length non-negative integer or arbitrary-length bit-string with minimum overhead. They are intended to provide protocol flexibility without sacrificing economy, and to assist in future-proofing protocols under development. This document describes formats and algorithms for SDNV encoding and decoding, along with notes on implementation and usage. This document is a product of the Delay Tolerant Networking Research Group and has been reviewed by that group.  No objections to its publication as an RFC were raised." />
  <meta name="keywords" content="SDNV, DTN" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">W.M. Eddy</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">MTI Systems</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">E. Davies</td>
</tr>
<tr>
<td class="left">Expires: August 27, 2011</td>
<td class="right">Folly Consulting</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 23, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Using Self-Delimiting Numeric Values in Protocols<br />
  <span class="filename">draft-irtf-dtnrg-sdnv-09</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Self-Delimiting Numeric Values (SDNVs) have recently been introduced as a field type in proposed Delay-Tolerant Networking protocols. SDNVs encode an arbitrary-length non-negative integer or arbitrary-length bit-string with minimum overhead. They are intended to provide protocol flexibility without sacrificing economy, and to assist in future-proofing protocols under development. This document describes formats and algorithms for SDNV encoding and decoding, along with notes on implementation and usage. This document is a product of the Delay Tolerant Networking Research Group and has been reviewed by that group.  No objections to its publication as an RFC were raised.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 27, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Problems with Fixed Value Fields</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">SDNVs for DTN Protocols</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">SDNV Usage</a>
</li>
<li>2.   <a href="#rfc.section.2">Definition of SDNVs</a>
</li>
<li>3.   <a href="#rfc.section.3">Basic Algorithms</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Encoding Algorithm</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Decoding Algorithm</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Limitations of Implementations</a>
</li>
<li>4.   <a href="#rfc.section.4">Comparison to Alternatives</a>
</li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">SNDV Python Source Code</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This document is a product of the Internet Research Task Force (IRTF) Delay-Tolerant Networking (DTN) Research Group (DTNRG). The document has received review and support within the DTNRG, as discussed in the Acknowledgements section of this document.</p>
<p id="rfc.section.1.p.2">This document begins by describing the drawbacks of using fixed-width protocol fields. It then provides some background on the Self-Delimiting Numeric Values (SDNVs) proposed for use in DTN protocols, and motivates their potential applicability in other networking protocols. The DTNRG has created SDNVs to meet the challenges it attempts to solve, and it has been noted that SDNVs closely resemble certain constructs within ASN.1 and even older ITU protocols, so the problems are not new or unique to DTN. SDNVs focus strictly on numeric values or bitstrings, while other mechanisms have been developed for encoding more complex data structures, such as ASN.1 encoding rules, and Haverty's MSDTP <a href="#RFC0713">[RFC0713]</a>. Because of this focus, SDNVs are can be quickly implemented with only a small amount of code.</p>
<p id="rfc.section.1.p.3">SDNVs are tersely defined in both the bundle protocol <a href="#RFC5050">[RFC5050]</a> and LTP <a href="#RFC5326">[RFC5326]</a> specifications, due to the flow of document production in the DTNRG.  This document clarifies and further explains the motivations and engineering decisions behind SDNVs.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Problems with Fixed Value Fields</h1>
<p id="rfc.section.1.1.p.1">Protocol designers commonly face an optimization problem in determining the proper size for header fields. There is a strong desire to keep fields as small as possible, in order to reduce the protocol's overhead, and also allow for fast processing. Since protocols can be used many years (even decades) after they are designed, and networking technology has tended to change rapidly, it is not uncommon for the use, deployment, or performance of a particular protocol to be limited or infringed upon by the length of some header field being too short. Two well-known examples of this phenomenon are the TCP advertised receive window, and the IPv4 address length.</p>
<p id="rfc.section.1.1.p.2">TCP segments contain an advertised receive window field that is fixed at 16 bits <a href="#RFC0793">[RFC0793]</a>, encoding a maximum value of around 65 kilobytes. The purpose of this value is to provide flow control, by allowing a receiver to specify how many sent bytes its peer can have outstanding (unacknowledged) at any time, thus allowing the receiver to limit its buffer size. As network speeds have grown by several orders of magnitude since TCP's inception, the combination of the 65 kilobyte maximum advertised window and long round-trip times prevented TCP senders from being able to achieve the high throughput that the underlying network supported. This limitation was remedied through the use of the Window Scale option <a href="#RFC1323">[RFC1323]</a>, which provides a multiplier for the advertised window field. However, the Window Scale multiplier is fixed for the duration of the connection, requires support from each end of a TCP connection, and limits the precision of the advertised receive window, so this is certainly a less-than-ideal solution. Because of the field width limit in the original design however, the Window Scale is necessary for TCP to reach high sending rates.</p>
<p id="rfc.section.1.1.p.3">An IPv4 address is fixed at 32 bits <a href="#RFC0791">[RFC0791]</a> (as a historical note, an early version of the IP header format specification in <a href="#IEN21">[IEN21]</a> used variable-length addresses in multiples of 8-bits up to 120-bits). Due to the way that subnetting and assignment of address blocks was performed, the number of IPv4 addresses has been seen as a limit to the growth of the Internet <a href="#Hain05">[Hain05]</a>. Two divergent paths to solve this problem have been the use of Network Address Translators (NATs) and the development of IPv6. NATs have caused a number of other issues and problems <a href="#RFC2993">[RFC2993]</a>, leading to increased complexity and fragility, as well as forcing workarounds to be engineered for many other protocols to function within a NATed environment. The IPv6 solution's transitional work has been underway for several years, but has still only just begun to have visible impact on the global Internet.</p>
<p id="rfc.section.1.1.p.4">Of course, in both the case of the TCP receive window and IPv4 address length, the field size chosen by the designers seemed like a good idea at the time. The fields were more than big enough for the originally perceived usage of the protocols, and yet were small enough to allow the headers to remain compact and relatively easy and efficient to parse on machines of the time. The fixed sizes that were defined represented a trade off between the scalability of the protocol versus the overhead and efficiency of processing. In both cases, these engineering decisions turned out to be painfully restrictive in the longer term.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> SDNVs for DTN Protocols</h1>
<p id="rfc.section.1.2.p.1">In specifications for the DTN Bundle Protocol (BP) <a href="#RFC5050">[RFC5050]</a> and Licklider Transmission Protocol (LTP) <a href="#RFC5326">[RFC5326]</a>, SDNVs have been used for several fields including identifiers, payload/header lengths, and serial (sequence) numbers. SDNVs were developed for use in these types of fields, to avoid sending more bytes than needed, as well as avoiding fixed sizes that may not end up being appropriate. For example, since LTP is intended primarily for use in long-delay interplanetary communications <a href="#RFC5325">[RFC5325]</a>, where links may be fairly low in capacity, it is desirable to avoid the header overhead of routinely sending a 64-bit field where a 16-bit field would suffice. Since many of the nodes implementing LTP are expected to be beyond the current range of human spaceflight, upgrading their on-board LTP implementations to use longer values if the defined fields are found to be too short would also be problematic.  Furthermore, extensions similar in mechanism to TCP's Window Scale option are unsuitable for use in DTN protocols since, due to high delays, DTN protocols must avoid handshaking and configuration parameter negotiation to the greatest extent possible. All of these reasons make the choice of SDNVs for use in DTN protocols attractive.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#sdnv_usage" id="sdnv_usage">SDNV Usage</a>
</h1>
<p id="rfc.section.1.3.p.1">In short, an SDNV is simply a way of representing non-negative integers (both positive integers of arbitrary magnitude and 0), without expending much unnecessary space. This definition allows SDNVs to represent many common protocol header fields, such as:</p>
<p></p>

<ul>
<li>Random identification fields as used in the IPsec Security Parameters Index or in IP headers for fragment reassembly (Note: the 16-bit IP ID field for fragment reassembly was recently found to be too short in some environments <a href="#RFC4963">[RFC4963]</a>),</li>
<li>Sequence numbers as in TCP or SCTP,</li>
<li>Values used in cryptographic algorithms such as RSA keys, Diffie-Hellman key-agreement, or coordinates of points on elliptic curves.</li>
<li>Message lengths as used in file transfer protocols.</li>
<li>Nonces and cookies.</li>
</ul>
<p id="rfc.section.1.3.p.3">As any bit-field can be interpreted as an unsigned integer, SDNVs can also encode arbitrary-length bit-fields, including bit-fields representing signed integers or other data types; however, this document assumes SDNV encoding and decoding in terms of unsigned integers. Implementations may differ in the interface that they provide to SDNV encoding and decoding functions, in terms of whether the values are numeric, bit-fields, etc.; this detail does not alter the representation or algorithms described in this document.</p>
<p id="rfc.section.1.3.p.4">The use of SDNVs rather than fixed length fields gives protocol designers the ability to ameliorate the consequences of making difficult-to-reverse field-sizing decisions, as the SDNV format grows and shrinks depending on the particular value encoded. SDNVs do not necessarily provide optimal encodings for values of any particular length, however they allow protocol designers to avoid potential blunders in assigning fixed lengths, and remove the complexity involved with either negotiating field lengths or constructing protocol extensions. However, if SDNVs are used to encode bit-fields, it is essential that the sender and receiver have a consistent interpretation of the decoded value. This is discussed further in <a href="#definition">Section 2</a>.</p>
<p id="rfc.section.1.3.p.5">To our knowledge, at this time, no IETF transport or network-layer protocol designed for use outside of the DTN domain has proposed to use SDNVs; however there is no inherent reason not to use SDNVs more broadly in the future. The two examples cited here, of fields that have proven too small in general Internet protocols, are only a small sampling of the much larger set of similar instances that the authors can think of. Outside the Internet protocols, within ASN.1 and previous ITU protocols, constructs very similar to SDNVs have been used for many years due to engineering concerns very similar to those facing the DTNRG.</p>
<p id="rfc.section.1.3.p.6">Many protocols use a Type-Length-Value method for encoding variable length fields (e.g. TCP's options format, or many of the fields in IKEv2). An SDNV is equivalent to combining the length and value portions of this type of field, with the overhead of the length portion amortized out over the bytes of the value. The penalty paid for this in an SDNV may be several extra bytes for long values (e.g.  1024 bit RSA keys). See <a href="#comp">Section 4</a> for further discussion and a comparison.</p>
<p id="rfc.section.1.3.p.7">As is shown in later sections, for large values, the current SDNV scheme is fairly inefficient in terms of space (1/8 of the bits are overhead) and not particularly easy to encode/decode in comparison to alternatives. The best use of SDNVs may often be to define the Length field of a TLV structure to be an SDNV whose value is the length of the TLV's Value field. In this way, one can avoid forcing large numbers from being directly encoded as an SDNV, yet retain the extensibility that using SDNVs grants.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#definition" id="definition">Definition of SDNVs</a>
</h1>
<p id="rfc.section.2.p.1">Early in the work of the DTNRG, it was agreed that the properties of an SDNV were useful for DTN protocols. The exact SDNV format used by the DTNRG evolved somewhat over time before the publication of the initial RFCs on LTP and the BP. An earlier version (see <a href="#BRF04">[BRF04]</a>) bore a resemblance to the ASN.1 <a href="#ASN1">[ASN1]</a> Basic Encoding Rules (BER) <a href="#ASN1-BER">[ASN1-BER]</a> for lengths (Section 8.1.3 of X.690). The current SDNV format is the one used by ASN.1 BER for encoding tag identifiers greater than or equal to 31 (Section 8.1.2.4.2 of X.690). A comparison between the current SDNV format and the early SDNV format is made in <a href="#comp">Section 4</a>.</p>
<p></p>
<p id="rfc.section.2.p.3">The format currently used is very simple. Before encoding, an integer is represented as a left-to-right bitstring beginning with its most significant bit, and ending with its least significant bit. If the bitstring's length is not a multiple of 7, then the string is left-padded with zeros. When transmitted, the bits are encoded into a series of bytes. The low-order 7 bits of each byte in the encoded format are taken left-to-right from the integer's bitstring representation. The most significant bit of each byte specifies whether it is the final byte of the encoded value (when it holds a 0), or not (when it holds a 1).</p>
<p id="rfc.section.2.p.4">For example:</p>
<p></p>

<ul>
<li>1 (decimal) is represented by the bitstring "0000001" and encoded as the single byte 0x01 (in hexadecimal)</li>
<li>128 is represented by the bitstring "10000001 00000000" and encoded as the bytes 0x81 followed by 0x00.</li>
<li>Other values can be found in the test vectors of the source code in <a href="#append">Appendix Appendix A</a>
</li>
</ul>
<p id="rfc.section.2.p.6">To be perfectly clear, and avoid potential interoperability issues (as have occurred with ASN.1 BER time values), we explicitly state two considerations regarding zero-padding. (1) When encoding SDNVs, any leading (most significant) zero bits in the input number might be discarded by the SDNV encoder. Protocols that use SDNVs should not rely on leading-zeros being retained after encoding and decoding operations.  (2) When decoding SDNVs, the relevant number of leading zeros required to pad up to a machine word or other natural data unit might be added.  These are put in the most-significant positions in order to not change the value of the number. Protocols using SDNVs should consider situations where lost zero-padding may be problematic.</p>
<p id="rfc.section.2.p.7">The issues of zero-padding are particularly relevant where an SDNV is being used to represent a bit-field to be transmitted by a protocol. The specification of the protocol and any associated IANA registry should specify the allocation and usage of bit positions within the unencoded field. Unassigned and reserved bits in the unencoded field will be treated as zeros by the SDNV encoding prior to transmission. Assuming the bit positions are numbered starting from 0 at the least significant bit position in the integer representation, then if higher numbered positions in the field contain all zeros, the encoding process may not transmit these bits explicitly (e.g., if all the bit positions numbered 7 or higher are zeros then the transmitted SDNV can consist of just one octet). On reception the decoding process will treat any untransmitted higher numbered bits as zeros. To ensure correct operation of the protocol, the sender and receiver must have a consistent interpretation of the width of the bit-field. This can be achieved in various ways:</p>
<p></p>

<ul>
<li>the bit-field width is implicitly defined by the version of the protocol in use in the sender and receiver,</li>
<li>sending the width of the bit-field explicitly in a separate item,</li>
<li>the higher numbered bits can be safely ignored by the receiver (e.g., because they represent optimizations), or</li>
<li>marking the highest numbered bit by prepending a 1 bit to the bit-field.</li>
</ul>

<p>The protocol specification must record how the consistent interpretation is achieved.</p>
<p id="rfc.section.2.p.9">The SDNV encoding technique is also known as Variable Byte Encoding (see Section 5.3.1 of <a href="#Manning09">[Manning09]</a>) and is equivalent to Base-128 Elias Gamma Encoding (see Section 5.3.2 of <a href="#Manning09">[Manning09]</a> and Section 3.5 of <a href="#Sayood02">[Sayood02]</a>). However the primary motivation for SDNVs is to provide an extensible protocol framework rather than optimal data compression which is the motivation behind the other uses of the technique. <a href="#Manning09">[Manning09]</a> points out that the key feature of this encoding is that it is 'prefix free' meaning that no code is a prefix of any other, which an alternative way of expressing the self-delimiting property</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#basic" id="basic">Basic Algorithms</a>
</h1>
<p id="rfc.section.3.p.1">This section describes some simple algorithms for creating and parsing SDNV fields. These may not be the most efficient algorithms possible, however, they are easy to read, understand, and implement.  <a href="#append">Appendix Appendix A</a> contains Python source code implementing the routines described here. The algorithms presented here are convenient for converting between an internal data block and serialized data stream associated with a transmission device. Other approaches are possible with different efficiencies and trade-offs.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#enc" id="enc">Encoding Algorithm</a>
</h1>
<p id="rfc.section.3.1.p.1">There is a very simple algorithm for the encoding operation that converts a non-negative integer (value n, of length 1+floor(log n) bits) into an SDNV. This algorithm takes n as its only argument and returns a string of bytes:</p>
<p></p>

<ul>
<li>(Initial Step) Set a variable X to a byte sharing the least significant 7 bits of n, and with 0 in the most significant bit, and a variable Y to n, right-shifted by 7 bits.</li>
<li>(Recursion Step) If Y == 0, return X. Otherwise, set Z to the bitwise-or of 0x80 with the 7 least significant bits of Y, and append Z to X. Right-shift Y by 7 bits and repeat the Recursion Step.</li>
</ul>
<p id="rfc.section.3.1.p.3">This encoding algorithm has time complexity of O(log n), since it takes a number of steps equal to ceil(n/7), and no additional space beyond the size of the result (8/7 log n) is required. One aspect of this algorithm is that it assumes strings can be efficiently appended to new bytes. One way to implement this is to allocate a buffer for the expected length of the result and fill that buffer one byte at a time from the right end.</p>
<p id="rfc.section.3.1.p.4">If, for some reason, an implementation requires an encoded SDNV to be some specific length (possibly related to a machine word), any leftmost zero-padding included needs to properly set the high-order bit in each byte of padding.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#dec" id="dec">Decoding Algorithm</a>
</h1>
<p id="rfc.section.3.2.p.1">Decoding SDNVs is a more difficult operation than encoding them, due to the fact that no bound on the resulting value is known until the SDNV is parsed, at which point the value itself is already known.  This means that if space is allocated for decoding the value of an SDNV into, it is never known whether this space will be overflowed until it is 7 bits away from happening.</p>
<p id="rfc.section.3.2.p.2">(Initial Step) Set the result to 0. Set an index to the first byte of the encoded SDNV.</p>
<p id="rfc.section.3.2.p.3">(Recursion Step) Shift the result left 7 bits. Add the low-order 7 bits of the value at the index to the result. If the high-order bit under the pointer is a 1, advance the index by one byte within the encoded SDNV and repeat the Recursion Step, otherwise return the current value of the result.</p>
<p id="rfc.section.3.2.p.4">This decoding algorithm takes no more additional space than what is required for the result (7/8 the length of the SDNV) and the pointer.  The complication is that before the result can be left-shifted in the Recursion Step, an implementation needs to first make sure that this won't cause any bits to be lost, and re-allocate a larger piece of memory for the result, if required. The pure time complexity is the same as for the encoding algorithm given, but if re-allocation is needed due to the inability to predict the size of the result, decoding may be slower.</p>
<p id="rfc.section.3.2.p.5">These decoding steps include removal of any leftmost zero-padding that might be used by an encoder to create encodings of a certain length.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#limitations" id="limitations">Limitations of Implementations</a>
</h1>
<p id="rfc.section.3.3.p.1">Because of efficiency considerations or convenience of internal representation of decoded integers, implementations may choose to limit the number of bits in SDNVs that they will handle. To avoid interoperability problems any protocol that uses SDNVs must specify the largest number of bits in an SDNV that an implementation of that protocol is expected to handle.</p>
<p id="rfc.section.3.3.p.2">For example Section 4.1 of <a href="#RFC5050">[RFC5050]</a> specifies that implementations of the DTN Bundle Protocol are not required to handle SDNVs with more than 64 bits in their unencoded value.  Accordingly integer values transmitted in SDNVs have an upper limit and SDNV encoded flag fields must be limited to 64 bit positions in any future revisions of the protocol unless the restriction is altered.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#comp" id="comp">Comparison to Alternatives</a>
</h1>
<p id="rfc.section.4.p.1">This section compares three alternative ways of implementing the concept of SDNVs: (1) the TLV scheme commonly used in the Internet family, and many other families of protocols, (2) the old style of SDNVs (both the SDNV-8 and SDNV-16) defined in an early stage of LTP's development <a href="#BRF04">[BRF04]</a>, and (3) the current SDNV format.</p>
<p id="rfc.section.4.p.2">The TLV method uses two fixed-length fields to hold the Type and Length elements that then imply the syntax and semantics of the Value element. This is only similar to an SDNV in that the value element can grow or shrink within the bounds capable of being conveyed by the Length field. Two fundamental differences between TLVs and SDNVs are that through the Type element, TLVs also contain some notion of what their contents are semantically, while SDNVs are simply generic non-negative integers, and protocol engineers still have to choose fixed field lengths for the Type and Length fields in the TLV format.</p>
<p id="rfc.section.4.p.3">Some protocols use TLVs where the value conveyed within the Length field needs to be decoded into the actual length of the Value field.  This may be accomplished through simple multiplication, left-shifting, or a look-up table. In any case, this tactic limits the granularity of the possible Value lengths, and can contribute some degree of bloat if Values do not fit neatly within the available decoded Lengths.</p>
<p id="rfc.section.4.p.4">In the SDNV format originally used by LTP, parsing the first byte of the SDNV told an implementation how much space was required to hold the contained value. There were two different types of SDNVs defined for different ranges of use. The SDNV-8 type could hold values up to 127 in a single byte, while the SDNV-16 type could hold values up to 32,767 in 2 bytes. Both formats could encode values requiring up to N bytes in N+2 bytes, where N&lt;127. The major difference between this old SDNV format and the current SDNV format is that the new format is not as easily decoded as the old format was, but the new format also has absolutely no limitation on its length.</p>
<p id="rfc.section.4.p.5">The advantage in ease of parsing the old format manifests itself in two aspects: (1) the size of the value is determinable ahead of time, in a way equivalent to parsing a TLV, and (2) the actual value is directly encoded and decoded, without shifting and masking bits as is required in the new format. For these reasons, the old format requires less computational overhead to deal with, but is also very limited, in that it can only hold a 1024-bit number, at maximum. Since according to IETF Best Current Practices, an asymmetric cryptography key needed to last for a long term requires using moduli of over 1228 bits <a href="#RFC3766">[RFC3766]</a>, this could be seen as a severe limitation of the old-style of SDNVs, which the currently-used style does not suffer from.</p>
<p><a href="#comptab">Table 1</a> compares the maximum values that can be encoded into SDNVs of various lengths using the old SDNV-8/16 method and the current SDNV method. The only place in this table where SDNV-16 is used rather than SDNV-8 is in the 2-byte row. Starting with a single byte, the two methods are equivalent, but when using 2 bytes, the old method is a more compact encoding by one bit. From 3 to 7 bytes of length though, the current SDNV format is more compact, since it only requires one bit per byte of overhead, whereas the old format used a full byte. Thus, at 8 bytes, both schemes are equivalent in efficiency since they both use 8 bits of overhead. Up to 129 bytes, the old format is more compact than the current one, although after this limit it becomes unusable.</p>
<div id="#rfc.table.1"></div>
<div id="#comptab"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="center">Bytes</th>
<th class="center">SDNV-8/16 Maximum Value</th>
<th class="center">SDNV Maximum Value</th>
<th class="center">SDNV-8/16 Overhead Bits</th>
<th class="center">SDNV Overhead Bits</th>
</tr></thead>
<tbody>
<tr>
<td class="center">1</td>
<td class="center">127</td>
<td class="center">127</td>
<td class="center">1</td>
<td class="center">1</td>
</tr>
<tr>
<td class="center">2</td>
<td class="center">32,767</td>
<td class="center">16,383</td>
<td class="center">1</td>
<td class="center">2</td>
</tr>
<tr>
<td class="center">3</td>
<td class="center">65,535</td>
<td class="center">2,097,151</td>
<td class="center">8</td>
<td class="center">3</td>
</tr>
<tr>
<td class="center">4</td>
<td class="center">2^24 - 1</td>
<td class="center">2^28 - 1</td>
<td class="center">8</td>
<td class="center">4</td>
</tr>
<tr>
<td class="center">5</td>
<td class="center">2^32 - 1</td>
<td class="center">2^35 - 1</td>
<td class="center">8</td>
<td class="center">5</td>
</tr>
<tr>
<td class="center">6</td>
<td class="center">2^40 - 1</td>
<td class="center">2^42 - 1</td>
<td class="center">8</td>
<td class="center">6</td>
</tr>
<tr>
<td class="center">7</td>
<td class="center">2^48 - 1</td>
<td class="center">2^49 - 1</td>
<td class="center">8</td>
<td class="center">7</td>
</tr>
<tr>
<td class="center">8</td>
<td class="center">2^56 - 1</td>
<td class="center">2^56 - 1</td>
<td class="center">8</td>
<td class="center">8</td>
</tr>
<tr>
<td class="center">9</td>
<td class="center">2^64 - 1</td>
<td class="center">2^63 - 1</td>
<td class="center">8</td>
<td class="center">9</td>
</tr>
<tr>
<td class="center">10</td>
<td class="center">2^72 - 1</td>
<td class="center">2^70 - 1</td>
<td class="center">8</td>
<td class="center">10</td>
</tr>
<tr>
<td class="center">16</td>
<td class="center">2^120 - 1</td>
<td class="center">2^112 - 1</td>
<td class="center">8</td>
<td class="center">16</td>
</tr>
<tr>
<td class="center">32</td>
<td class="center">2^248 - 1</td>
<td class="center">2^224 - 1</td>
<td class="center">8</td>
<td class="center">32</td>
</tr>
<tr>
<td class="center">64</td>
<td class="center">2^504 - 1</td>
<td class="center">2^448 - 1</td>
<td class="center">8</td>
<td class="center">64</td>
</tr>
<tr>
<td class="center">128</td>
<td class="center">2^1016 - 1</td>
<td class="center">2^896 - 1</td>
<td class="center">8</td>
<td class="center">128</td>
</tr>
<tr>
<td class="center">129</td>
<td class="center">2^1024 - 1</td>
<td class="center">2^903 - 1</td>
<td class="center">8</td>
<td class="center">129</td>
</tr>
<tr>
<td class="center">130</td>
<td class="center">N/A</td>
<td class="center">2^910 - 1</td>
<td class="center">N/A</td>
<td class="center">130</td>
</tr>
<tr>
<td class="center">256</td>
<td class="center">N/A</td>
<td class="center">2^1792 - 1</td>
<td class="center">N/A</td>
<td class="center">256</td>
</tr>
</tbody>
</table>
<p id="rfc.section.4.p.7">Suggested usages of the SDNV format that leverage its strengths and limit the effects of its weaknesses are discussed in <a href="#sdnv_usage">Section 1.3</a>.</p>
<p id="rfc.section.4.p.8">Another aspect of comparison between SDNVs and alternatives using fixed-length fields is the result of errors in transmission. Bit-errors in an SDNV can result in either errors in the decoded value, or parsing errors in subsequent fields of the protocol. In fixed-length fields, bit errors always result in errors to the decoded value rather than parsing errors in subsequent fields. If the decoded values from either type of field encoding (SDNV or fixed-length) are used as indexes, offsets, or lengths of further fields in the protocol, similar failures result.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Security Considerations</h1>
<p id="rfc.section.5.p.1">The only security considerations with regards to SDNVs are that code which parses SDNVs should have bounds-checking logic and be capable of handling cases where an SDNV's value is beyond the code's ability to parse. These precautions can prevent potential exploits involving SDNV decoding routines.</p>
<p id="rfc.section.5.p.2">Stephen Farrell noted that very early definitions of SDNVs also allowed negative integers. This was considered a potential security hole, since it could expose implementations to underflow attacks during SDNV decoding. There is a precedent in that many existing TLV decoders map the Length field to a signed integer and are vulnerable in this way.  An SDNV decoder should be based on unsigned types and not have this issue.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> IANA Considerations</h1>
<p id="rfc.section.6.p.1">This document has no IANA considerations.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Acknowledgements</h1>
<p id="rfc.section.7.p.1">Scott Burleigh, Manikantan Ramadas, Michael Demmer, Stephen Farrell, and other members of the IRTF DTN Research Group contributed to the development and usage of SDNVs in DTN protocols. George Jones and Keith Scott from Mitre, Lloyd Wood, Gerardo Izquierdo, Joel Halpern, Peter TB Brett, Kevin Fall, and Elwyn Davies also contributed useful comments on and criticisms of this document. DTNRG last call comments on the draft were sent to the mailing list by Lloyd Wood, Will Ivancic, Jim Wyllie, William Edwards, Hans Kruse, Janico Greifenberg, Teemu Karkkainen, Stephen Farrell, and Scott Burleigh. Further constructive comments were incorporated from Dave Crocker, Lachlan Andrew and Michael Welzl.</p>
<p id="rfc.section.7.p.2">Work on this document was performed at NASA's Glenn Research Center, in support of the NASA Space Communications Architecture Working Group (SCAWG), NASA's Earth Science Technology Office (ESTO), and the FAA/Eurocontrol Future Communications Study (FCS) in the 2005-2007 time frame, while the editor was an employee of Verizon Federal Network Systems.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC0713">[RFC0713]</b></td>
<td class="top">
<a href="mailto:JFH@MIT-DMS" title="Massachusetts Institute of Technology (MIT)">Haverty, J.</a>, "<a href="http://tools.ietf.org/html/rfc713">MSDTP-Message Services Data Transmission Protocol</a>", RFC 713, April 1976.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1323">[RFC1323]</b></td>
<td class="top">
<a href="mailto:van@CSAM.LBL.GOV" title="University of California Berkeley, Lawrence Berkeley Laboratory">Jacobson, V.</a>, <a href="mailto:Braden@ISI.EDU" title="University of Southern California (USC), Information Sciences Institute">Braden, B.</a> and <a href="mailto:dab@cray.com" title="Cray Research">D. Borman</a>, "<a href="http://tools.ietf.org/html/rfc1323">TCP Extensions for High Performance</a>", RFC 1323, May 1992.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0791">[RFC0791]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>", STD 5, RFC 791, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2993">[RFC2993]</b></td>
<td class="top">
<a>Hain, T.</a>, "<a href="http://tools.ietf.org/html/rfc2993">Architectural Implications of NAT</a>", RFC 2993, November 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3766">[RFC3766]</b></td>
<td class="top">
<a>Orman, H.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc3766">Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</a>", BCP 86, RFC 3766, April 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4963">[RFC4963]</b></td>
<td class="top">
<a>Heffner, J.</a>, <a>Mathis, M.</a> and <a>B. Chandler</a>, "<a href="http://tools.ietf.org/html/rfc4963">IPv4 Reassembly Errors at High Data Rates</a>", RFC 4963, July 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5050">[RFC5050]</b></td>
<td class="top">
<a>Scott, K.</a> and <a>S. Burleigh</a>, "<a href="http://tools.ietf.org/html/rfc5050">Bundle Protocol Specification</a>", RFC 5050, November 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5325">[RFC5325]</b></td>
<td class="top">
<a>Burleigh, S.</a>, <a>Ramadas, M.</a> and <a>S. Farrell</a>, "<a href="http://tools.ietf.org/html/rfc5325">Licklider Transmission Protocol - Motivation</a>", RFC 5325, September 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5326">[RFC5326]</b></td>
<td class="top">
<a>Ramadas, M.</a>, <a>Burleigh, S.</a> and <a>S. Farrell</a>, "<a href="http://tools.ietf.org/html/rfc5326">Licklider Transmission Protocol - Specification</a>", RFC 5326, September 2008.</td>
</tr>
<tr>
<td class="reference"><b id="IEN21">[IEN21]</b></td>
<td class="top">
<a>Cerf, V.</a> and <a>J. Postel</a>, "<a>Specification of Internetwork Transmission Control Program: TCP Version 3</a>", Internet Experimental Note 21, January 1978.</td>
</tr>
<tr>
<td class="reference"><b id="Hain05">[Hain05]</b></td>
<td class="top">
<a>Hain, T.</a>, "<a>A Pragmatic Report on IPv4 Address Space Consumption</a>", Internet Protocol Journal Vol. 8, No. 3, September 2005.</td>
</tr>
<tr>
<td class="reference"><b id="BRF04">[BRF04]</b></td>
<td class="top">
<a>Burleigh, S.</a>, <a>Ramadas, M.</a> and <a>S. Farrell</a>, "<a>Licklider Transmission Protocol</a>", draft-irtf-dtnrg-ltp-00 (replaced), May 2004.</td>
</tr>
<tr>
<td class="reference"><b id="ASN1">[ASN1]</b></td>
<td class="top">
<a>ITU-T Rec. X.680</a>, "<a>Abstract Syntax Notation One (ASN.1). Specification of Basic Notation</a>", ISO/IEC 8824-1:2002, 2002.</td>
</tr>
<tr>
<td class="reference"><b id="ASN1-BER">[ASN1-BER]</b></td>
<td class="top">
<a>ITU-T Rec. X.690</a>, "<a>Abstract Syntax Notation One (ASN.1). Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO/IEC 8825-1:2002, 2002.</td>
</tr>
<tr>
<td class="reference"><b id="Sayood02">[Sayood02]</b></td>
<td class="top">
<a>Sayood, K.</a>, "<a>Lossless Data Compression</a>", Academic Press ISBN-13: 978-0126208610, December 2002.</td>
</tr>
<tr>
<td class="reference"><b id="Manning09">[Manning09]</b></td>
<td class="top">
<a>Manning, c.d.</a>, <a>Raghavan, P.</a> and <a>H. Schuetze</a>, "<a>Introduction to Information Retrieval</a>", Cambridge University Press ISBN-13: 978-0521865715, 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#append" id="append">SNDV Python Source Code</a>
</h1>
<div id="#rfc.figure.1"></div>
<pre>
# sdnv_decode() takes a string argument (s), which is assumed to be
#   an SDNV, and optionally a number (slen) for the maximum number of
#   bytes to parse from the string.  The function returns a pair of
#   the non-negative integer n that is the numeric value encoded in
#   the SDNV, and integer that is the distance parsed into the input
#   string.  If the slen argument is not given (or is not a non-zero
#   number) then, s is parsed up to the first byte whose high-order
#   bit is 0 -- the length of the SDNV portion of s does not have to
#   be pre-computed by calling code.  If the slen argument is given
#   as a non-zero value, then slen bytes of s are parsed.  The value
#   for n of -1 is returned for any type of parsing error.
#
# NOTE: In python, integers can be of arbitrary size.  In other
#   languages, such as C, SDNV-parsing routines should take
#   precautions to avoid overflow (e.g. by using the Gnu MP library,
#   or similar). 
#
def sdnv_decode(s, slen=0):
  n = long(0)
  for i in range(0, len(s)):
    v = ord(s[i])
    n = n&lt;&lt;7
    n = n + (v &amp; 0x7F)
    if v&gt;&gt;7 == 0:
      slen = i+1
      break
    elif i == len(s)-1 or (slen != 0 and i &gt; slen):
      n = -1 # reached end of input without seeing end of SDNV
  return (n, slen)

# sdnv_encode() returns the SDNV-encoded string that represents n.
#   An empty string is returned if n is not a non-negative integer
def sdnv_encode(n):
  r = ""
  # validate input
  if n &gt;= 0 and (type(n) in [type(int(1)), type(long(1))]):
    flag = 0
    done = False
    while not done:
      # encode lowest 7 bits from n
      newbits = n &amp; 0x7F
      n = n&gt;&gt;7
      r = chr(newbits + flag) + r
      if flag == 0:
        flag = 0x80
      if n == 0:
        done = True
  return r


# test cases from LTP and BP internet-drafts, only print failures
def sdnv_test():
  tests = [(0xABC, chr(0x95) + chr(0x3C)),
           (0x1234, chr(0xA4) + chr (0x34)),
           (0x4234, chr(0x81) + chr(0x84) + chr(0x34)),
           (0x7F, chr(0x7F))]
  
  for tp in tests:
    # test encoding function
    if sdnv_encode(tp[0]) != tp[1]:
      print "sdnv_encode fails on input %s" % hex(tp[0])
    # test decoding function
    if sdnv_decode(tp[1])[0] != tp[0]:
      print "sdnv_decode fails on input %s, giving %s" % \
            (hex(tp[0]), sdnv_decode(tp[1]))
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Wesley M. Eddy</span> 
	  <span class="n hidden">
		<span class="family-name">Eddy</span>
	  </span>
	</span>
	<span class="org vcardline">MTI Systems</span>
	<span class="adr">
	  <span>NASA Glenn Research Center</span>
<span>MS 500-ASRC; 21000 Brookpark Rd</span>

	  <span class="vcardline">
		<span class="locality">Cleveland</span>,  
		<span class="region">OH</span> 
		<span class="code">44135</span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">Phone: 216-433-6682</span>

<span class="vcardline">EMail: <a href="mailto:wes@mti-systems.com">wes@mti-systems.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Elwyn Davies</span> 
	  <span class="n hidden">
		<span class="family-name">Davies</span>
	  </span>
	</span>
	<span class="org vcardline">Folly Consulting</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Soham</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:elwynd@folly.org.uk">elwynd@folly.org.uk</a></span>

  </address>
</div>

</body>
</html>