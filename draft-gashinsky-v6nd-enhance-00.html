<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Operational Neighbor Discovery Problems and Enhancements.</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Applicability">
<link href="#rfc.section.2" rel="Chapter" title="2 The Problem">
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology">
<link href="#rfc.section.4" rel="Chapter" title="4 Background">
<link href="#rfc.section.5" rel="Chapter" title="5 Neighbor Discovery Overview">
<link href="#rfc.section.6" rel="Chapter" title="6 Operational Mitigation Options">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Filtering of unused address space.">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Appropriate Subnet Sizing.">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Routing Mitigation.">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Tuning of the NDP Queue Rate Limit.">
<link href="#rfc.section.7" rel="Chapter" title="7 Recommendations for Implementors.">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Priortize NDP Activities">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Queue Tuning.">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 NDP Protocol Gratuitous NA">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 ND cache priming and refresh">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Text goes here.">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="In IPv4, subnets are generally small, made just large enough to cover the actual number of machines on the subnet.  In contrast, the default IPv6 subnet size is a /64, a number so large it covers trillions of addresses, the overwhelming number of which will be unassigned. Consequently, simplistic implementations of Neighbor Discovery can be vulnerable to denial of service attacks whereby they attempt to perform address resolution for large numbers of unassigned addresses.  Such denial of attacks can be launched intentionally (by an attacker), or result from legitimate operational tools that scan networks for inventory and other purposes. As a result of these vulnerabilities, new devices may not be able to "join" a network, it may be impossible to establish new IPv6 flows, and existing ipv6 transported flows may be interrupted." />
  <meta name="description" content="In IPv4, subnets are generally small, made just large enough to cover the actual number of machines on the subnet.  In contrast, the default IPv6 subnet size is a /64, a number so large it covers trillions of addresses, the overwhelming number of which will be unassigned. Consequently, simplistic implementations of Neighbor Discovery can be vulnerable to denial of service attacks whereby they attempt to perform address resolution for large numbers of unassigned addresses.  Such denial of attacks can be launched intentionally (by an attacker), or result from legitimate operational tools that scan networks for inventory and other purposes. As a result of these vulnerabilities, new devices may not be able to "join" a network, it may be impossible to establish new IPv6 flows, and existing ipv6 transported flows may be interrupted." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">W. Kumari</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">I. Gashinsky</td>
</tr>
<tr>
<td class="left">Expires: January 01, 2012</td>
<td class="right">Yahoo!</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Jaeggli</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Zynga</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 30, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Operational Neighbor Discovery Problems and Enhancements.<br />
  <span class="filename">draft-gashinsky-v6nd-enhance-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>In IPv4, subnets are generally small, made just large enough to cover the actual number of machines on the subnet.  In contrast, the default IPv6 subnet size is a /64, a number so large it covers trillions of addresses, the overwhelming number of which will be unassigned. Consequently, simplistic implementations of Neighbor Discovery can be vulnerable to denial of service attacks whereby they attempt to perform address resolution for large numbers of unassigned addresses.  Such denial of attacks can be launched intentionally (by an attacker), or result from legitimate operational tools that scan networks for inventory and other purposes. As a result of these vulnerabilities, new devices may not be able to "join" a network, it may be impossible to establish new IPv6 flows, and existing ipv6 transported flows may be interrupted.</p>
<p>This document describes the problem in detail and suggests possible implementation improvements as well as operational mitigation techniques that can in some cases to protect against such attacks. It also discusses possible modifications to the <a href="#RFC4861">traditional</a> <cite title="NONE">[RFC4861]</cite> neighbor discovery protocol itself.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 01, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Applicability</a>
</li>
<li>2.   <a href="#rfc.section.2">The Problem</a>
</li>
<li>3.   <a href="#rfc.section.3">Terminology</a>
</li>
<li>4.   <a href="#rfc.section.4">Background</a>
</li>
<li>5.   <a href="#rfc.section.5">Neighbor Discovery Overview</a>
</li>
<li>6.   <a href="#rfc.section.6">Operational Mitigation Options</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Filtering of unused address space.</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Appropriate Subnet Sizing.</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Routing Mitigation.</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Tuning of the NDP Queue Rate Limit.</a>
</li>
<li>7.   <a href="#rfc.section.7">Recommendations for Implementors.</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Priortize NDP Activities</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Queue Tuning.</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">NDP Protocol Gratuitous NA</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">ND cache priming and refresh</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.references">References</a>
</li>
<li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Text goes here.</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document describes implementation issues with IPv6's Neighbor Discovery protocol that can result in vulnerabilities when a network is scanned, either by an intruder or through the use of scanning tools that peform network inventory, security audits, etc. (e.g., "nmap"). </p>
<p id="rfc.section.1.p.2">This document describes the problem in detail and suggests possible implementation improvements as well as operational mitigation techniques that can in some cases to protect against such attacks. It also discusses possible modifications to the <a href="#RFC4861">traditional</a> <cite title="NONE">[RFC4861]</cite> neighbor discovery protocol itself.</p>
<p id="rfc.section.1.p.3">The RFC series documents generally describe on-the-wire behavior of protocols, that is, "what" is to be done by a protocol, but not exactly "how" it is to be implemented. The exact details of how best to implement a protocol will depend on the overall hardware and software architecture of a particular device. The actual "how" decisions are (correctly) left in the hands of implementers, so long as implementations produce proper on-the-wire behavior.</p>
<p id="rfc.section.1.p.4">While reading this document, it is important to keep in mind that discussions of how things have been implemented beyond basic compliance with the specification is not in the scope of the neighbor discovery RFCs.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Applicability</h1>
<p id="rfc.section.1.1.p.1">This document is primarily intended for operators of IPV6 networks and implementors of <a href="#RFC4861">[RFC4861]</a>. The Document provides some operational consideration as well as recommendations to increase the resilience of the Neighbor Discovery protocol.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> The Problem</h1>
<p id="rfc.section.2.p.1">In IPv4, subnets are generally small, made just large enough to cover the actual number of machines on the subnet.  For example, an IPv4 /20 contains only 4096 address.  In contrast, the default IPv6 subnet size is a /64, a number so large it covers literally billions of billions of addresses, the overwhelming number of which will be unassigned. Consequently, simplistic implementations of Neighbor Discovery can be vulnerable to denial of service attacks whereby they perform address resolution for large numbers of unassigned addresses.  Such denial of attacks can be launched intentionally (by an attacker), or result from legitimate operational tools that scan networks for inventory and other purposes. As a result of these vulnerabilities, new devices may not be able to "join" a network, it may be impossible to establish new IPv6 flows, and existing ipv6 transport flows may be interrupted. </p>
<p id="rfc.section.2.p.2">Network scans attempt to find and probe devices on a network.  Typically, scans are performed on a range of target addresses, or all the addresses on a particular subnet. When such probes are directed via a router, and the target addresses are on a directly attached network, the router will to attempt to perform address resolution on a large number of destinations (i.e., some fraction of the 2^64 addresses on the subnet). The process of testing for the (non)existance of neighbors can induce a denial of service condition, where the number of Neighbor Discovery requests overwhelms the implementation's capacity to process them, exhausts available memory, replaces existing in-use mappings with incomplete entries that will never be completed, etc. The result can be network disruption, where existing traffic may be impacted, and devices that join the net find that address resolutions fails.</p>
<p id="rfc.section.2.p.3">In order to alleviate risk associated with this DOS threat, some router implementations have taken steps to rate-limit the processing rate of Neighbor Solicitations (NS). While these mitigations do help, they do not fully address the issue and may introduce their own set of potential liabilities to the neighbor discovery process.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Terminology</h1>
<p></p>

<dl>
<dt>Address Resolution</dt>
<dd style="margin-left: 8">Address resolution is the process through which a node determines the link-layer address of a neighbor given only its IP address. In IPv6, address resolution is performed as part of Neighbor Discovery <a href="#RFC4861">[RFC4861]</a>, p60</dd>
<dt>Forwarding Plane</dt>
<dd style="margin-left: 8">That part of a router responsible for forwarding packets. In higher-end routers, the forwarding plane is typically implemented in specialized hardware optimized for performance. Forwarding steps include determining the correct outgoing interface for a packet, decrementing its Time To Live (TTL), verifying and updating the checksum, placing the correct link-layer header on the packet, and forwarding it. </dd>
<dt>Control Plane</dt>
<dd style="margin-left: 8">That part of the router implementation that maintains the data structures that determine where packets should be forwarded. The control plane is typically implemented as a "slower" software process running on a general purpose processor and is responsible for such functions as the routing protocols, performing management and resolving the correct link-layer address for adjacent neighbors. The control plane "controls" the forwarding plane by programming it with the information needed for packet forwarding.</dd>
<dt>Neighbor Cache</dt>
<dd style="margin-left: 8">As described in <a href="#RFC4861">[RFC4861]</a>, the data structure that holds the cache of (amongst other things) IP address to link-layer address mappings for connected nodes. The forwarding plane accesses the Neighbor Cache on every forwarded packet. Thus it is usually implemented in an ASIC .</dd>
<dt>Neighbor Discovery Process</dt>
<dd style="margin-left: 8">The Neighbor Discovery Process (NDP) is that part of the control plane that implements the Neighbor Discovery protocol. NDP is responsible for performing address resolution and maintaining the Neighbor Cache. When forwarding packets, the forwarding plane accesses entries within the Neighbor Cache. Whenever the forwarding plane processes a packet for which the corresponding Neighbor Cache Entry is missing or incomplete, it notifies NDP to take appropriate action (typically via a shared queue). NDP picks up requests from the shared queue and performs any necessary actions. In many implementations it is also responsible for responding to router solicitation messages, Neighbor Unreachability Detection (NUD), etc.</dd>
</dl>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Background</h1>
<p id="rfc.section.4.p.1">Modern router architectures separate the forwarding of packets (forwarding plane) from the decisions needed to decide where the packets should go (control plane). In order to deal with the high number of packets per second the forwarding plane is generally implemented in hardware and is highly optimized for the task of forwarding packets. In contrast, the NDP control plane is mostly implemented in software processes running on a general purpose processor. </p>
<p id="rfc.section.4.p.2">When a router needs to forward an IP packet, the forwarding plane logic performs the longest match lookup to determine where to send the packet and what outgoing interface to use. To deliver the packet to an adjacent node, It encapsulates the packet in a link-layer frame (which contains a header with the link-layer destination address). The forwarding plane logic checks the Neighbor Cache to see if it already has a suitable link-layer destination, and if not, places the request for the required information into a queue, and signals the control plane (i.e., NDP) that it needs the link-layer address resolved.  </p>
<p id="rfc.section.4.p.3">In order to protect NDP specifically and the control plane generally from being overwhelmed with these requests, appropriate steps must be taken. For example, the size and rate of the queue might be limited. NDP running in the control plane of the router dequeues requests and performs the address resolution function (by performing a neighbor solicitation and listening for a neighbor advertisement). This process is usually also responsible for other activities needed to maintain link-layer information, such as Neighbor Unreachability Detection (NUD).</p>
<p id="rfc.section.4.p.4">An attacker sending the appropriate packets to addresses on a given subnet can cause the router to queue attempts to resolve so many addresses that it crowds out attempts to resolve "legitimate" addresses (and in many cases becomes unable to perform maintenance of existing entries in the neighbor cache, and unable to answer Neighbor Solicitiation). This condition can result the inability to resolve new neighbors and loss of reachability to neighbors with existing ND-Cache entries. During testing it was concluded that 4 simultaneous nmap sessions from a low-end computer was sufficient to make a router's neighbor discovery process unhappy and therefore forwarding unusable.</p>
<p id="rfc.section.4.p.5">This behavior has been observed across multiple platforms and implementations.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Neighbor Discovery Overview</h1>
<p id="rfc.section.5.p.1">When a packet arrives at (or is generated by) a router for a destination on an attached link, the router needs to determine the correct link-layer address to send the packet to. The router checks the Neighbor Cache for an existing Neighbor Cache Entry for the neighbor, and if none exists, invokes the address resolution portions of the <a href="#RFC4861">IPv6 Neighbor Discovery </a> <cite title="NONE">[RFC4861]</cite> protocol to determine the link-layer address.</p>
<p id="rfc.section.5.p.2">RFC4861 Section 5.2 (Conceptual Sending Algorithm) outlines how this process works. A very high level summary is that the device creates a new Neighbor Cache Entry for the neighbor, sets the state to INCOMPLETE, queues the packet and initiates the actual address resolution process. The device then sends out one or more Neighbor Solicitiations, and when it receives a correpsonding Neighbor Advertisement, completes the Neighbor Cache Entry and sends the queued packet.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Operational Mitigation Options</h1>
<p id="rfc.section.6.p.1">This section provides some feasible mitigation options that can be employed today by network operators in order to protect network availability while vendors implement more effective protection measures. It can be stipulated that some of these options are "kludges", and are operationally difficult to manage. They are presented, as they represent options we currently have. It is each operator's responsibility to evaluate and understand the impact of changes to their network due to these measures.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Filtering of unused address space.</h1>
<p id="rfc.section.6.1.p.1">The DOS condition is induced by making a router try to resolve addresses on the subnet at a high rate. By carefully addressing machines into a small portion of a subnet (such as the lowest numbered addresses), it is possible to filter access to addresses not in that portion. This will prevent the attacker from making the router attempt to resolve unused addresses. For example if there are only 50 hosts connected to an interface, you may be able to filter any address above the first 64 addresses of that subnet by nullrouting the subnet carrying a more specific /122 route.</p>
<p id="rfc.section.6.1.p.2">As mentioned at the beginning of this section, it is fully understood that this is ugly (and difficult to manage); but failing other options, it may be a useful technique especially when responding to an attack.</p>
<p id="rfc.section.6.1.p.3">This solution requires that the hosts be statically or statefully addressed (as is often done in a datacenter) and may not interact well with networks using <a href="#RFC4862">[RFC4862]</a></p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Appropriate Subnet Sizing.</h1>
<p id="rfc.section.6.2.p.1">By sizing subnets to reflect the number of addresses actually in use, the problem can be avoided. For example <a href="#RFC6164">[RFC6164]</a> recommends sizing the subnet for inter-router links to only have 2 addresses. It is worth noting that this practice is common in IPv4 networks, partly to protect against the harmful effects of ARP flooding attacks.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Routing Mitigation.</h1>
<p id="rfc.section.6.3.p.1">One very effective technique is to route the subnet to a discard interface (most modern router platforms can discard traffic in hardware / the forwarding plane) and then have individual hosts announce routes for their IP addresses into the network (or use some method to inject much more specific addresses into the local routing domain). For example the network 2001:db8:1:2:3::/64 could be routed to a discard interface on "border" routers, and then individual hosts could announce 2001:db8:1:2:3::10/128, 2001:db8:1:2:3::66/128 into the IGP. This is typically done by having the IP address bound to a virtual interface on the host (for example the loopback interface), enabling IP forwarding on the host and having it run a routing daemon.  For obvious reasons, host participation in the IGP makes many operators uncomfortable, but can be a very powerful technique if used in a disciplined and controlled manner.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Tuning of the NDP Queue Rate Limit.</h1>
<p id="rfc.section.6.4.p.1">Many implementations provide a means to control the rate of resolution of unknown addresses. By tuning this rate, it may be possibly to amerlorate the isse, although, as with most tuning knobs (especially those that deal with rate limiting), you may be "completing the attack". By excissivly lowing this rate you may negatively impact how long the device takes to learn new addresses under normal conditions (for example, after clearing the neighbor cache or when the router first boots) and, under attack conditions you may be unable to resolve "legitimate" addresses sooner than if you had just the the knob alone.</p>
<p id="rfc.section.6.4.p.2">It is worth noting that this technique is only worth investigationg if the device has separate queue for resolution of unknown addresses versus maintaice of existing entries.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Recommendations for Implementors.</h1>
<p id="rfc.section.7.p.1">The section provides some recommendations to implementors of IPv4 Neighbor Discovery.</p>
<p id="rfc.section.7.p.2">At a high-level, implementors should program defensively. That is, they should assume that intruders will attempt to exploit implementation weaknesses, and should ensure that implementations are robust to various attacks. In the case of Neighbor Discovery, the following general considerations apply:</p>
<p></p>

<dl>
<dt>Manage Resources Explicitely</dt>
<dd style="margin-left: 8">- Resources such as processor cycles, memory, etc. are never infinite, yet with IPv6's large subnets it is easy to cause NDP to generate large numbers of address resolution requests for non-existant destinations. Implementations need to limit resources devoted to processing Neighbor Discovery requests in a thoughtful manner.  </dd>
<dt>Prioritize</dt>
<dd style="margin-left: 8">- Some NDP requests are more important than others. For example, when resources are limited, responding to Neighbor Solicitations for one's own address is more important than initiating address resolution requests that create new entries. Likewise, performing Neighbor Unreachability Detection, which by definition is only invoked on destinations that are actively being used, is more important than creating new entries for possibly non-existant neighbors.  </dd>
</dl>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Priortize NDP Activities</h1>
<p id="rfc.section.7.1.p.1">Not all Neighbor Discovery activies are equally important. Specifically, requests to perform large numbers of address resolutions on non-existant Neighbor Cache Entries should not come at the expense of servicing requests related to keeping existing, in-use entries properly up-to-date. Thus, implementations should divide work activities into categories having different priorities. The following gives examples of different activities and their importance in rough priority order.</p>
<p id="rfc.section.7.1.p.2">1. It is critical to respond to Neighbor Solicitations for one's own address, especially when a router. Whether for address resolution or Neighbor Unreachability Detection, failure to respond to Neighbor Solicitations results in immediate problems. Failure to respond to NS requests that are part of NUD can cause neighbors to delete the NCE for that address, and will result in followup NS messages using multicast. Once an entry has been flushed, existing traffic for destinations using that entry can no longer be forwarded until address resolution completes succesfully. In other words, not responding to NS messages further increases the NDP load, and causes on-going communication to fail.</p>
<p id="rfc.section.7.1.p.3">2. It is critical to revalidate one's own existing NCEs in need of refresh. As part of NUD, ND is required to frequently revalidate existing, in-use entries. Failure to do so can result in the entry being discarded. For in-use entries, discarding the entry will almost certainly result in a subsquent request to perform address resolution on the entry, but this time using multicast. As above, once the entry has been flushed, existing traffic for destinations using that entry can no longer be forwarded until address resolution completes succesfully. </p>
<p id="rfc.section.7.1.p.4">3. To maintin the stability of the control plane, Neighbor Discovery activity related to traffic sourced by the router (as opposed to traffic being forwarded by the router) should be given high priority. Whenever network problems occur, debugging and making other operational changes requires being able to query and access the router. In addition, routing protocols may begin to react (negatively) to perceived connectivity problems, causing addition undesirable ripple effects. </p>
<p id="rfc.section.7.1.p.5">4. Activities related to the sending and recieving  of Router Advertisements also impact address resolutions. [XXX say more?] </p>
<p id="rfc.section.7.1.p.6">5. Traffic to unknown addresses should be given lowest priority. Indeed, it may be useful to distinguish between "never seen" addresses and those that have been seen before, but that do not have a corresponding NCE. Specifically, the conceptual processing algorithm in <a href="#RFC4861">IPv6 Neighbor Discovery </a> <cite title="NONE">[RFC4861]</cite> calls for deleting NCEs under certain conditions. Rather than delete them completely, however, it might be useful to at least keep track of the fact that an entry at one time existed, in order to prioritize address resolution requests for such neighbors compared with neighbors that have never been seen before.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Queue Tuning.</h1>
<p id="rfc.section.7.2.p.1">On implementations in which requests to NDP are submitted via a single queue, router vendors SHOULD provide operators with means to control both the rate of link-layer address resolution requests placed into the queue and the size of the queue. This will allow operators to tune Neighbour Discovery for their specific environment. The ability to set or have per interface or subnet queue limits at a rate below that of the global queue limit might limit the damage to the neighbor discovery process to the taret network.</p>
<p id="rfc.section.7.2.p.2">Setting those values must be a very careful balancing act - the lower the rate of entry into the queue, the less load there will be on the ND process, however, it also means that it will take the router longer to learn legitimate destinations. In a datacenter with 6,000 hosts attached to a single router, setting that value to be under 1000 would mean that resolving all of the addresses from an initial state (or something that invalidates the address cache, such as a STP TCN) may take over 6 seconds. Similarly, the lower the size of the queue, the higher the likelihood of an attack being able to knock out legitimate traffic (but less memory utilization on the router).</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> NDP Protocol Gratuitous NA</h1>
<p id="rfc.section.7.3.p.1">Per <a href="#RFC4861">RFC 4861, section 7.2.5 and 7.2.6</a> <cite title="NONE">[RFC4861]</cite> requires that unsolicited neighbor advertisements result in the receiver setting it's neighbor cache entry to STALE, kicking off the resolution of the neighbor using neighbor solicitation. If the link layer address in an unsolicited neighbor advertisement matches that of the existing ND cache entry, routers SHOULD retain the existing entry updating it's status with regards to LRU retention policy.</p>
<p id="rfc.section.7.3.p.2">Hosts MAY be configured to send unsolicited Neighbor advertisement at a rate set at the discretion of the operators. The rate SHOULD be appropriate to the sizing of ND cache parameters and the host count on the subnet. An unsolicited NA rate parameter MUST NOT be enabled by default. The unsolicted rate interval as interpreted by hosts must jitter the value for the interval between transmissions. Hosts receiving a neighbor solicitation requests from a router following each of three subsequent gratuitous NA intervals MUST revert to RFC 4861 behavior.</p>
<p id="rfc.section.7.3.p.3">Implementation of new behavior for unsolicited neighbor advertisement would make it possible under appropriate circumstances to greatly reduce the dependence on the neighbor solicitation process for retaining existing ND cache entries.</p>
<p id="rfc.section.7.3.p.4">This may impact the detection of one-way reachability.</p>
<p id="rfc.section.7.3.p.5">It is understood that this section may need to be moved into a separate document -- it is (currently) provided here for discussion purposes.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> ND cache priming and refresh</h1>
<p id="rfc.section.7.4.p.1">With all of the above recommendations implemented, it should be possible to survive a "scan attack" with very little impact to the network, however, adding new hosts to the network (and the sending of traffic to them) may still be negatively impacted. Traffic to those new hosts would have to go through the unknown Neighbor Resolution queue, which is where the attack traffic would end up as well. A solution to this would be that any new host that joins the network would "announce" itself, and be added to the cache, therefore not requiring packets destined to it to go through the unknown NDP queue. This could be done by sending a ping packet to the all-routers multicast address, which would then trigger the router's own neighbor resolution process, which should be in a different queue then other packets. </p>
<p id="rfc.section.7.4.p.2">All attempts should be made to keep these addresses in cache, since any eviction of legitimate hosts from the cache could potentially place resolutions for them into the same queue as the attack traffic. At present, <a href="#RFC4861">[RFC4861]</a> states that there should be MAX_UNICAST_SOLICIT (3) attempts, RETRANS_TIMER 1 second apart, so if there is an interruption in the network or control plane processing for longer then 3 seconds during the refresh, the entry would be evicted from the ND Cache.  Any network event which takes longer then 3 seconds to converge (UDLD, STP, etc may take 30+ seconds) while under an attack, would result in ND cache eviction. If an entry is evicted during a scan, connectivity could be lost for an extended period of time.</p>
<p id="rfc.section.7.4.p.3">NDP refresh timers could be revised as suggested in <a href="http://tools.ietf.org/html/draft-nordmark-6man-impatient-nud-00">draft-nordmark-6man-impatient-nud-00</a> and SHOULD have a configurable value for MAX_UNICAST_SOLICIT and RETRANS_TIMER, and include capabilities for binary/exponential backoff.</p>
<p id="rfc.section.7.4.p.4">A suggested algorithm, which retains backward compatiblity with <a href="#RFC4861">[RFC4861]</a> is: operator configurable values for MAX_UNICAST_SOLICIT, RETRANS_TIMER, and a way to set adaptive back-of multiple, simmilar to ipv4 -- call it BACKOFF_MULTIPLE), so that we could implement:</p>
<p id="rfc.section.7.4.p.5">next_retrans = ($BACKOFF_MULTIPLE^$solicit_attempt_num)*$RETRANS_TIMER + jittered value.</p>
<p id="rfc.section.7.4.p.6">The recommended behavior is to have 5 attempts, with timing spacing of 0 (initial request), 1 second later, 3 seconds later, then 9, and then 27, which represents:</p>
<p id="rfc.section.7.4.p.7">MAX_UNICAST_SOLICIT=5</p>
<p id="rfc.section.7.4.p.8">RETRANS_TIMER=1 (default)</p>
<p id="rfc.section.7.4.p.9">BACKOFF_MULTIPLE=3</p>
<p id="rfc.section.7.4.p.10">If BACKOFF_MULTIPLE=1 (which should be the default value), and MAX_UNICAST_SOLICIT=3, you would get the backwards-compatible RFC behavior, but operators should be able to adjust the values as necessary to insure that they are sufficiently aggressive about retaining ND entries in cache.</p>
<p id="rfc.section.7.4.p.11">An Implementation following this algorithm would if the request was not answered at first due for example to a transitory condition, retry immediately, and then back off for progressively longer periods. This would allow for a reasonably fast resolution time when the transitory condition clears. </p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> IANA Considerations</h1>
<p id="rfc.section.8.p.1">No IANA resources or consideration are requested in this draft.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Security Considerations</h1>
<p id="rfc.section.9.p.1">This document outlines mitigation options that operators can use to protect themselves from Denial of Service attacks. Implementation advice to router vendors aimed at ameliorating known problems carries the risk of previously unforeseen consequences. It is not believed that these techniques create additional security or DOS exposure</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> Acknowledgements</h1>
<p id="rfc.section.10.p.1">The authors would like to thank Ron Bonica, Troy Bonin, John Jason Brzozowski, Randy Bush, Vint Cerf, Jason Fesler Erik Kline, Jared Mauch, Chris Morrow and Suran De Silva. Special thanks to Thomas Narten for detailed review and (even more so) for providing text!</p>
<p id="rfc.section.10.p.2">Apologies for anyone we may have missed; it was not intentional.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4861">[RFC4861]</b></td>
<td class="top">
<a>Narten, T.</a>, <a>Nordmark, E.</a>, <a>Simpson, W.</a> and <a>H. Soliman</a>, "<a href="http://tools.ietf.org/html/rfc4861">Neighbor Discovery for IP version 6 (IPv6)</a>", RFC 4861, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4398">[RFC4398]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4398">Storing Certificates in the Domain Name System (DNS)</a>", RFC 4398, March 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4862">[RFC4862]</b></td>
<td class="top">
<a>Thomson, S.</a>, <a>Narten, T.</a> and <a>T. Jinmei</a>, "<a href="http://tools.ietf.org/html/rfc4862">IPv6 Stateless Address Autoconfiguration</a>", RFC 4862, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6164">[RFC6164]</b></td>
<td class="top">
<a>Kohno, M.</a>, <a>Nitzan, B.</a>, <a>Bush, R.</a>, <a>Matsuzaki, Y.</a>, <a>Colitti, L.</a> and <a>T. Narten</a>, "<a href="http://tools.ietf.org/html/rfc6164">Using 127-Bit IPv6 Prefixes on Inter-Router Links</a>", RFC 6164, April 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC4255">[RFC4255]</b></td>
<td class="top">
<a>Schlyter, J.</a> and <a>W. Griffin</a>, "<a href="http://tools.ietf.org/html/rfc4255">Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints</a>", RFC 4255, January 2006.</td>
</tr></tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> Text goes here.</h1>
<p id="rfc.section.Appendix A.p.1">TBD</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Warren Kumari</span> 
	  <span class="n hidden">
		<span class="family-name">Kumari</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:warren@kumari.net">warren@kumari.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Igor</span> 
	  <span class="n hidden">
		<span class="family-name">Gashinsky</span>
	  </span>
	</span>
	<span class="org vcardline">Yahoo!</span>
	<span class="adr">
	  <span>45 W 18th St</span>

	  <span class="vcardline">
		<span class="locality">New York</span>,  
		<span class="region">NY</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:igor@yahoo-inc.com">igor@yahoo-inc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Joel</span> 
	  <span class="n hidden">
		<span class="family-name">Jaeggli</span>
	  </span>
	</span>
	<span class="org vcardline">Zynga</span>
	<span class="adr">
	  <span>111 Evelyn</span>

	  <span class="vcardline">
		<span class="locality">Sunnyvale</span>,  
		<span class="region">CA</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jjaeggli@zynga.com">jjaeggli@zynga.com</a></span>

  </address>
</div>

</body>
</html>