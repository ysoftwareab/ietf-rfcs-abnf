


Network                                                         B. Welch
Internet-Draft                                                 B. Halevy
Expires: January 16, 2006                                        Panasas
                                                              G. Goodson
                                                                  NetApp
                                                                D. Black
                                                                     EMC
                                                              A. Adamson
                                                                    CITI
                                                           July 15, 2005


                            pNFS Operations
                      draft-welch-pnfs-ops-03.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on January 16, 2006.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   This Internet-Draft provides a description of the pNFS extension for
   NFSv4.



Welch, et al.           Expires January 16, 2006                [Page 1]

Internet-Draft               pNFS Operations                   July 2005


   The key feature of the protocol extension is the ability for clients
   to perform read and write operations that go directly from the client
   to individual storage system elements without funneling all such
   accesses through a single file server.  Of course, the file server
   must provide sufficient coordination of the client I/O so that the
   file system retains its integrity.

   The extension adds operations that query and manage layout
   information that allows parallel I/O between clients and storage
   system elements.  The layouts are managed in a similar way to
   delegations in that they are associated with leases and can be
   recalled by the server, but layout information is independent of
   delegations.

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].
































Welch, et al.           Expires January 16, 2006                [Page 2]

Internet-Draft               pNFS Operations                   July 2005


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  6
   2.  General Definitions  . . . . . . . . . . . . . . . . . . . . .  8
     2.1   Metadata Server  . . . . . . . . . . . . . . . . . . . . .  8
     2.2   Client . . . . . . . . . . . . . . . . . . . . . . . . . .  8
     2.3   Storage Device . . . . . . . . . . . . . . . . . . . . . .  8
     2.4   Storage Protocol . . . . . . . . . . . . . . . . . . . . .  9
     2.5   Management Protocol  . . . . . . . . . . . . . . . . . . .  9
     2.6   Metadata . . . . . . . . . . . . . . . . . . . . . . . . .  9
     2.7   Layout . . . . . . . . . . . . . . . . . . . . . . . . . . 10
   3.  Layouts and Aggregation  . . . . . . . . . . . . . . . . . . . 10
     3.1   Layout Structure . . . . . . . . . . . . . . . . . . . . . 10
       3.1.1   Device IDs . . . . . . . . . . . . . . . . . . . . . . 11
       3.1.2   Aggregation Schemes  . . . . . . . . . . . . . . . . . 11
     3.2   Basic Layout Semantics . . . . . . . . . . . . . . . . . . 12
       3.2.1   Layouts and access control . . . . . . . . . . . . . . 12
       3.2.2   Layout Iomode  . . . . . . . . . . . . . . . . . . . . 13
       3.2.3   Operation Sequencing . . . . . . . . . . . . . . . . . 13
     3.3   Obtaining a Layout . . . . . . . . . . . . . . . . . . . . 14
       3.3.1   Identifying Layouts  . . . . . . . . . . . . . . . . . 14
       3.3.2   Overlapping Layouts  . . . . . . . . . . . . . . . . . 15
       3.3.3   Copy-on-write  . . . . . . . . . . . . . . . . . . . . 15
     3.4   Recalling a Layout . . . . . . . . . . . . . . . . . . . . 15
     3.5   Committing a Layout  . . . . . . . . . . . . . . . . . . . 16
       3.5.1   LAYOUTCOMMIT and mtime/atime/change  . . . . . . . . . 17
       3.5.2   LAYOUTCOMMIT and size  . . . . . . . . . . . . . . . . 18
       3.5.3   LAYOUTCOMMIT and layoutupdate  . . . . . . . . . . . . 19
     3.6   Crash Recovery . . . . . . . . . . . . . . . . . . . . . . 19
       3.6.1   Leases . . . . . . . . . . . . . . . . . . . . . . . . 19
       3.6.2   Client Recovery  . . . . . . . . . . . . . . . . . . . 21
       3.6.3   Metadata Server Recovery . . . . . . . . . . . . . . . 21
   4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 23
     4.1   File Layout Security . . . . . . . . . . . . . . . . . . . 24
     4.2   Object Layout Security . . . . . . . . . . . . . . . . . . 24
     4.3   Block Layout Security  . . . . . . . . . . . . . . . . . . 25
   5.  NFSv4 File Layout Type . . . . . . . . . . . . . . . . . . . . 26
     5.1   File Striping and Data Access  . . . . . . . . . . . . . . 26
       5.1.1   Sparse and Dense Storage Device Data Layouts . . . . . 28
       5.1.2   Operations Issued to Storage Devices . . . . . . . . . 29
     5.2   Global Stateid Requirements  . . . . . . . . . . . . . . . 30
     5.3   The Layout Iomode  . . . . . . . . . . . . . . . . . . . . 30
     5.4   Storage Device State Propagation . . . . . . . . . . . . . 31
       5.4.1   Lock State Propagation . . . . . . . . . . . . . . . . 31
       5.4.2   Open-mode Validation . . . . . . . . . . . . . . . . . 32
       5.4.3   File Attributes  . . . . . . . . . . . . . . . . . . . 32
     5.5   Extending file size  . . . . . . . . . . . . . . . . . . . 33
       5.5.1   READs and EOF  . . . . . . . . . . . . . . . . . . . . 33



Welch, et al.           Expires January 16, 2006                [Page 3]

Internet-Draft               pNFS Operations                   July 2005


       5.5.2   LAYOUTCOMMIT and EOF . . . . . . . . . . . . . . . . . 33
     5.6   Crash Recovery Considerations  . . . . . . . . . . . . . . 34
     5.7   Security Considerations  . . . . . . . . . . . . . . . . . 35
     5.8   Alternate Approaches . . . . . . . . . . . . . . . . . . . 35
   6.  pNFS Typed Data Structures . . . . . . . . . . . . . . . . . . 36
     6.1   pnfs_layouttype4 . . . . . . . . . . . . . . . . . . . . . 36
     6.2   pnfs_deviceid4 . . . . . . . . . . . . . . . . . . . . . . 36
     6.3   pnfs_devaddr4  . . . . . . . . . . . . . . . . . . . . . . 37
     6.4   pnfs_devlist_item4 . . . . . . . . . . . . . . . . . . . . 37
     6.5   pnfs_layout4 . . . . . . . . . . . . . . . . . . . . . . . 37
     6.6   pnfs_layoutupdate4 . . . . . . . . . . . . . . . . . . . . 38
     6.7   pnfs_layoutiomode4 . . . . . . . . . . . . . . . . . . . . 38
   7.  pNFS File Attributes . . . . . . . . . . . . . . . . . . . . . 38
     7.1   pnfs_layouttype4<> FS_LAYOUT_TYPES . . . . . . . . . . . . 39
     7.2   pnfs_layouttype4<> FILE_LAYOUT_TYPE  . . . . . . . . . . . 39
     7.3   pnfs_layouttypes4 FILE_LAYOUT_HINT . . . . . . . . . . . . 39
     7.4   uint32_t FS_LAYOUT_PREFERRED_BLOCKSIZE . . . . . . . . . . 39
     7.5   uint32_t FS_LAYOUT_PREFERRED_ALIGNMENT . . . . . . . . . . 39
   8.  pNFS Error Definitions . . . . . . . . . . . . . . . . . . . . 39
   9.  pNFS Operations  . . . . . . . . . . . . . . . . . . . . . . . 40
     9.1   LAYOUTGET - Get Layout Information . . . . . . . . . . . . 40
     9.2   LAYOUTCOMMIT - Commit writes made using a layout . . . . . 42
     9.3   LAYOUTRETURN - Release Layout Information  . . . . . . . . 46
     9.4   GETDEVICEINFO - Get Device Information . . . . . . . . . . 47
     9.5   GETDEVICELIST - Get List of Devices  . . . . . . . . . . . 49
   10.   Callback Operations  . . . . . . . . . . . . . . . . . . . . 50
     10.1  CB_LAYOUTRECALL  . . . . . . . . . . . . . . . . . . . . . 50
     10.2  CB_SIZECHANGED . . . . . . . . . . . . . . . . . . . . . . 52
   11.   Usage Scenarios  . . . . . . . . . . . . . . . . . . . . . . 52
     11.1  Basic Read Scenario  . . . . . . . . . . . . . . . . . . . 53
     11.2  Multiple Reads to a File . . . . . . . . . . . . . . . . . 53
     11.3  Multiple Reads to a File with Delegations  . . . . . . . . 53
     11.4  Read with existing writers . . . . . . . . . . . . . . . . 53
     11.5  Read with later conflict . . . . . . . . . . . . . . . . . 54
     11.6  Basic Write Case . . . . . . . . . . . . . . . . . . . . . 54
     11.7  Large Write Case . . . . . . . . . . . . . . . . . . . . . 55
     11.8  Create with special layout . . . . . . . . . . . . . . . . 55
   12.   Layouts and Aggregation  . . . . . . . . . . . . . . . . . . 55
     12.1  Simple Map . . . . . . . . . . . . . . . . . . . . . . . . 55
     12.2  Block Map  . . . . . . . . . . . . . . . . . . . . . . . . 55
     12.3  Striped Map (RAID 0) . . . . . . . . . . . . . . . . . . . 56
     12.4  Replicated Map . . . . . . . . . . . . . . . . . . . . . . 56
     12.5  Concatenated Map . . . . . . . . . . . . . . . . . . . . . 56
     12.6  Nested Map . . . . . . . . . . . . . . . . . . . . . . . . 56
   13.   Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
     13.1  Storage Protocol Negotiation . . . . . . . . . . . . . . . 57
     13.2  Storage Errors . . . . . . . . . . . . . . . . . . . . . . 57
   14.   Normative References . . . . . . . . . . . . . . . . . . . . 57



Welch, et al.           Expires January 16, 2006                [Page 4]

Internet-Draft               pNFS Operations                   July 2005


       Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 57
   A.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 58
       Intellectual Property and Copyright Statements . . . . . . . . 59
















































Welch, et al.           Expires January 16, 2006                [Page 5]

Internet-Draft               pNFS Operations                   July 2005


1.  Introduction

   The NFSv4 protocol [2] specifies the interaction between a client
   that accesses files and a server that provides access to files and is
   responsible for coordinating access by multiple clients.  As
   described in the pNFS problem statement, this requires that all
   access to a set of files exported by a single NFSv4 server be
   performed by that server; at high data rates the server may become a
   bottleneck.

   The parallel NFS (pNFS) extensions to NFSv4 allow data accesses to
   bypass this bottleneck by permitting direct client access to the
   storage devices containing the file data.  When file data for a
   single NFSv4 server is stored on multiple and/or higher throughput
   storage devices (by comparison to the server's throughput
   capability), the result can be significantly better file access
   performance.  The relationship among multiple clients, a single
   server, and multiple storage devices for pNFS (server and clients
   have access to all storage devices) is shown in this diagram:

       +-----------+
       |+-----------+                                 +-----------+
       ||+-----------+                                |           |
       |||           |        NFSv4 + pNFS            |           |
       +||  Clients  |<------------------------------>|   Server  |
        +|           |                                |           |
         +-----------+                                |           |
              |||                                     +-----------+
              |||                                           |
              |||                                           |
              ||| Storage        +-----------+              |
              ||| Protocol       |+-----------+             |
              ||+----------------||+-----------+  Management|
              |+-----------------|||           |    Protocol|
              +------------------+||  Storage  |------------+
                                  +|  Devices  |
                                   +-----------+

                                 Figure 1

   In this structure, the responsibility for coordination of file access
   by multiple clients is shared among the server, clients, and storage
   devices.  This is in contrast to NFSv4 without pNFS extensions, in
   which this is primarily the server's responsibility, some of which
   can be delegated to clients under strictly specified conditions.

   The pNFS extension to NFSv4 takes the form of new operations that
   manage data location information called a "layout".  The layout is



Welch, et al.           Expires January 16, 2006                [Page 6]

Internet-Draft               pNFS Operations                   July 2005


   managed in a similar fashion as NFSv4 data delegations (e.g., they
   are recallable and revocable).  However, they are distinct
   abstractions and are manipulated with new operations that are
   described in Section 9.  When a client holds a layout, it has rights
   to access the data directly using the location information in the
   layout.

   There are new attributes that describe general layout
   characteristics.  However, much of the required information cannot be
   managed solely within the attribute framework, because it will need
   to have a strictly limited term of validity, subject to invalidation
   by the server.  This requires the use of new operations to obtain,
   return, recall, and modify layouts, in addition to new attributes.

   This document specifies both the NFSv4 extensions required to
   distribute file access coordination between the server and its
   clients and a NFSv4 file storage protocol that may be used to access
   data stored on NFSv4 storage devices.

   Storage protocols used to access a variety of other storage devices
   are deliberately not specified here.  These might include:

   o  Block protocols such as iSCSI, parallel SCSI, and FCP (SCSI over
      Fibre Channel) [refs].  The block protocol support can be
      independent of the addressing structure of the block protocol
      used, allowing more than one protocol to access the same file data
      and enabling extensibility to other block protocols.

   o  Object protocols such as OSD over iSCSI or Fibre Channel [3].

   o  Other storage protocols, including PVFS and other file systems
      that are in use in HPC environments.

   pNFS is designed to accommodate these protocols and be extensible to
   new classes of storage protocols that may be of interest.

   The distribution of file access coordination between the server and
   its clients increases the level of responsibility placed on clients.
   Clients are already responsible for ensuring that suitable access
   checks are made to cached data and that attributes are suitably
   propagated to the server.  Generally, a misbehaving client that hosts
   only a single-user can only impact files accessible to that single
   user.  Misbehavior by a client hosting multiple users may impact
   files accessible to all of its users.  NFSv4 delegations increase the
   level of client responsibility as a client that carries out actions
   requiring a delegation without obtaining that delegation will cause
   its user(s) to see unexpected and/or incorrect behavior.




Welch, et al.           Expires January 16, 2006                [Page 7]

Internet-Draft               pNFS Operations                   July 2005


   Some uses of pNFS extend the responsibility of clients beyond
   delegations.  In some configurations, the storage devices cannot
   perform fine-grained access checks to ensure that clients are only
   performing accesses within the bounds permitted to them by the pNFS
   operations with the server (e.g., the checks may only be possible at
   file system granularity rather than file granularity).  In situations
   where this added responsibility placed on clients creates
   unacceptable security risks, pNFS configurations in which storage
   devices cannot perform fine-grained access checks SHOULD NOT be used.
   All pNFS server implementations MUST support NFSv4 access to any file
   accessible via pNFS in order to provide an interoperable means of
   file access in such situations.  See Section 4 on Security for
   further discussion.

   Finally, there are issues about how layouts interact with the
   existing NFSv4 abstractions of data delegations and byte range
   locking.  These issues (and more) are also discussed here.

2.  General Definitions

   This protocol extension partitions the NFSv4 file system protocol
   into two parts, the control path and the data path.  The control path
   is implemented by the extended (p)NFSv4 server.  When the file system
   being exported by (p)NFSv4 uses storage devices that are visible to
   clients over the network, the data path may be implemented by direct
   communication between the extended (p)NFSv4 file system client and
   the storage devices.  This leads to a few new terms used to describe
   the protocol extension and some clarifications of existing terms.

2.1  Metadata Server

   A pNFS "server" or "metadata server" is a server as defined by
   RFC3530 [2], which additionally provides support of the pNFS minor
   extension.  When using the pNFS NFSv4 minor extension, the metadata
   server may hold only the metadata associated with a file, while the
   data is stored on the storage devices.  Note: directory data is
   always accessed through the metadata server.

2.2  Client

   A pNFS "client" is a client as defined by RFC3530 [2], with the
   addition of supporting the pNFS minor extension server protocol and
   with the addition of supporting at least one storage protocol (for
   performing I/O directly to storage devices).

2.3  Storage Device

   This is a device, or server, that controls the file's data, but



Welch, et al.           Expires January 16, 2006                [Page 8]

Internet-Draft               pNFS Operations                   July 2005


   leaves other metadata management up to the metadata server.  A
   storage device could be another NFS server, or an Object Storage
   Device (OSD) or a block device accessed over a SAN (either
   FiberChannel or iSCSI SAN).  The goal of this extension is to allow
   direct communication between clients and storage devices.

2.4  Storage Protocol

   This is the protocol between the pNFS client and the storage device
   used to access the file data.  Three following types have been
   described: file protocols (such as NFSv4 or NFSv3), object protocols
   (OSD), and block protocols (SCSI-block commands, or "SBC").  These
   protocols are in turn layered over transport protocols such as RPC/
   TCP/IP or iSCSI/TCP/IP or FC/SCSI.  We anticipate there will be
   variations on these storage protocols, including new protocols that
   are unknown at this time or experimental in nature.  The details of
   the storage protocols will be described in other documents so that
   pNFS clients can be written to use these storage protocols.  Use of
   NFSv4 itself as a file-based storage protocol is described in
   Section 5.

2.5  Management Protocol

   This is a protocol used by the exported file system between the
   server and storage devices.  Specification of such protocols is
   outside the scope of this draft.  Such management protocols would be
   used to control such activities as the allocation and deallocation of
   storage and the management of state required by the storage devices
   to perform client access control.  The management protocol should not
   be confused with protocols used to manage LUNs in a SAN and other
   sysadmin kinds of tasks.

   While the pNFS protocol allows for any management protocol, in
   practice the management protocol is closely related to the storage
   protocol.  For example, if the storage devices are NFS servers, then
   the protocol between the pNFS metadata server and the storage devices
   is likely to involve NFS operations.  Similarly, when object storage
   devices are used, the pNFS metadata server will likely use iSCSI/OSD
   commands to manipulate storage.

   However, this document does not mandate any particular management
   protocol.  Instead, it just describes the requirements on the
   management protocol for maintaining attributes like modify time, the
   change attribute, and the end-of-file position.

2.6  Metadata

   This is information about a file, like its name, owner, where it



Welch, et al.           Expires January 16, 2006                [Page 9]

Internet-Draft               pNFS Operations                   July 2005


   stored, and so forth.  The information is managed by the exported
   file system server (metadata server).  Metadata also includes lower-
   level information like block addresses and indirect block pointers.
   Depending the storage protocol, block-level metadata may or may not
   be managed by the metadata server, but is instead managed by Object
   Storage Devices or other servers acting as a storage device.

2.7  Layout

   A layout defines how a file's data is organized on one or more
   storage devices.  There are many possible layout types.  They vary in
   the storage protocol used to access the data, and in the aggregation
   scheme that lays out the file data on the underlying storage devices.
   Layouts are described in more detail below.

3.  Layouts and Aggregation

3.1  Layout Structure

   The layout is a typed data structure that has variants to handle
   different storage protocols (block, object, and file).  A layout
   describes a range of a file's contents (e.g., the set of storage
   devices on which a specific byte range of the file's data reside and
   a method for identifying the data on those devices).  A specific
   layout structure belongs to a "layout type" (e.g., blocks, objects,
   files).  A metadata server, along with its management protocol, must
   support at least one layout type.  See Section 6.1 for the RPC
   definition of a layout type.  A private sub-range of the layout type
   name space can be defined (e.g., a type with the high bit set to
   one).  This private sub-range can be used for internal testing or
   experimentation.

   For example, a file layout type could be an array of tuples
   (deviceID, file_handle), along with a definition (or aggregation
   scheme) of how the data is stored across the devices (e.g.,
   striping).  A block layout might be an array of tuples that store
   (deviceID, block_number, block count) along with information about
   block size and the file offset of the first block.  An object layout
   is an array of tuples (deviceID, objectID) and an additional
   structure (i.e., the aggregation map) that defines how the logical
   byte sequence of the file data is serialized into the different
   objects.

   This document defines a NFSv4 file layout type using a stripe-based
   aggregation scheme (see Section 5).  Adjunct specifications must
   exist that precisely define other layout formats (e.g., blocks,
   objects, or other file-based layouts) to allow interoperability among
   clients and metadata servers.



Welch, et al.           Expires January 16, 2006               [Page 10]

Internet-Draft               pNFS Operations                   July 2005


3.1.1  Device IDs

   The "deviceID" is a short name for a storage device.  In practice, a
   significant amount of information may be required to fully identify a
   storage device.  Instead of embedding all that information in a
   layout, a level of indirection is used.  Layouts embed device IDs,
   and a new op (GETDEVICEINFO) is used to retrieve the complete
   identity information about the storage device (according to its
   layout type).  For example, the identity of a file server or object
   server could be an IP address and port.  The identity of a block
   device could be a volume label.  Due to multipath connectivity in a
   SAN environment, agreement on a volume label is considered the
   reliable way to locate a particular storage device.

   The device ID is qualified by the layout type.  This allows different
   layout drivers to generate device IDs without the need for co-
   ordination.  In addition to GETDEVICEINFO, another operation,
   GETDEVICELIST, has been added to allow clients to fetch the mappings
   of multiple storage devices attached to a metadata server.

   Clients SHOULD NOT expect the mapping between device ID and storage
   device address to exist across metadata server reboots (i.e., clients
   should fetch new mappings upon startup or upon detection of a
   metadata server reboot).  If data are reorganized from a storage
   device with a given device ID to a different storage device (i.e., if
   the mapping between storage device and data changes), the layout
   describing the data MUST be recalled rather than assigning the new
   storage device to the old device ID.

   [OPEN ISSUE: we could associate leases with device IDs; this seems
   overly complex.  As well, we could introduce an invalidation process,
   instead of recalling layouts if mapping changes; again seems overly
   complex.]

3.1.2  Aggregation Schemes

   Aggregation schemes can describe layouts like simple one-to-one
   mapping, concatenation, and striping.  A general aggregation scheme
   allows nested maps so that more complex layouts can be compactly
   described.  The canonical aggregation type for this extension is
   striping, which allows a client to access storage devices in
   parallel.  Even a one-to-one mapping is useful for a file server that
   wishes to distribute its load among a set of other file servers.
   There are also experimental aggregation types such as writable
   mirrors and client-implemented RAID that could be defined.

   [OPEN ISSUE: should aggregation schemes (striping) be moved up a
   level and made not opaque.  I.e., there would exist a generic



Welch, et al.           Expires January 16, 2006               [Page 11]

Internet-Draft               pNFS Operations                   July 2005


   striping mechanisms that could be shared by file/block/object
   specifications.]

3.2  Basic Layout Semantics

   Layouts delegate to the client the ability to access data out of
   band.  The layout guarantees the holder that the layout will be
   recalled when the state encapsulated by the layout becomes invalid
   (e.g., through some operation that directly or indirectly modifies
   the layout) or, possibly, when a conflicting layout is requested, as
   determined by the layout's iomode.  When a layout is recalled, and
   then returned by the client, the client retains the ability to access
   file data with normal NFSv4 I/O operations through the metadata
   server.  Only the right to do I/O out-of-band is affected.

3.2.1  Layouts and access control

   Holding a layout does not guarantee that a user of the layout has the
   rights to access the data represented by the layout.  All user access
   rights MUST be obtained through the appropriate open, lock, and
   access operations.  However, if a valid layout for a file is not held
   by the client, the storage device will reject all I/Os to that file's
   byte range that originate from that client.  In summary, layouts and
   ordinary file access controls are independent.  The act of modifying
   a file for which a layout is held, does not necessarily conflict with
   the holding of the layout (that describes the file being modified).
   However, with certain layout types (e.g., block layouts), the
   layout's iomode must agree with the type of I/O being performed.

   Depending upon the layout type and storage protocol in use, storage
   device access permissions may be granted by LAYOUTGET and may be
   encoded within the type specific layout.  If access permissions are
   encoded within the layout, the metadata server should recall the
   layout when the file's ACL or mode changes.  For example, the object
   layout protocol encodes access permissions within the capability
   embedded within the layout; if these permissions change, the layout
   is recalled and the capability revoked.  Note, clients are still
   required to perform the appropriate access operations as described
   above (e.g., open and lock ops).  The degree to which it is possible
   for the client to circumvent these access operations must be clearly
   addressed by the individual layout type documents, as well as the
   consequences of doing so.  In addition, these documents must be clear
   about the requirements and non-requirements for the checking
   performed by the server.

   If the pNFS metadata server supports mandatory byte range locks then
   byte range locks must behave as specified by the NFSv4 protocol (as
   seen by users of files).  If a storage device is unable to restrict



Welch, et al.           Expires January 16, 2006               [Page 12]

Internet-Draft               pNFS Operations                   July 2005


   access by a pNFS client who does not hold a required mandatory byte
   range lock then the metadata server must not grant layouts to a
   client, for that storage device, that permits any access that
   conflicts with a mandatory byte range lock held by another client.
   In this scenario, it is also necessary for the metadata server to
   ensure that byte range locks are not granted to a client if any other
   client holds a conflicting layout; in this case all conflicting
   layouts must be recalled and returned before the lock request can be
   granted.  This requires the pNFS server to understand the
   capabilities of its storage devices.

3.2.2  Layout Iomode

   When requesting a layout (through LAYOUTGET), the client MUST request
   a layout pertaining to an "iomode" of either READ or READ/WRITE.  The
   iomode indicates to the metadata server the client's intent to
   perform either READs (only) or a mixture of I/O possibly containing
   WRITEs as well (READ/WRITE).  For certain layout types, it is useful
   for a client to specify this intent at LAYOUTGET time.  E.g., for
   block based protocols, block allocation could occur when a READ/WRITE
   iomode is specified.  A storage device may validate I/O with regards
   to the iomode; this is dependent upon storage device implementation.
   Thus, if the client's layout iomode differs from the I/O being
   performed the storage device may reject the client's I/O with an
   error indicating a new layout with the correct I/O mode should be
   fetched.  E.g., if a client gets a layout with a READ iomode and
   performs a WRITE to a storage device, the storage device is allowed
   to reject that WRITE.

   The iomode does not conflict with OPEN share modes or lock requests,
   and these are the preferred method for restricting user access to
   data files.  E.g., an OPEN of read, deny-write does not conflict with
   a LAYOUTGET containing an iomode of READ/WRITE performed by another
   client.  Applications that depend on writing into the same file
   concurrently may use byte range locking to serialize their accesses.

3.2.3  Operation Sequencing

   As with other stateful operations, pNFS requires the correct
   sequencing of layout operations.  This proposal assumes that sessions
   will precede pNFS into NFSv4.x and thus, pNFS will require the use of
   sessions.  If the sessions proposal does not precede pNFS, then this
   proposal needs to be modified to provide for the correct sequencing
   of pNFS layout operations.  It is the server's responsibility to
   avoid inconsistencies regarding the layouts it hands out.

   One critical issue with operation sequencing concerns callbacks.  The
   protocol must defend against races between the reply to a LAYOUTGET



Welch, et al.           Expires January 16, 2006               [Page 13]

Internet-Draft               pNFS Operations                   July 2005


   operation and a subsequent CB_LAYOUTRECALL.  It MUST NOT be possible
   for a client to process the CB_LAYOUTRECALL for a layout that it has
   not received in a reply message to a LAYOUTGET.

   [OPEN ISSUE: the mechanism for doing this is still an open issue.  It
   may be sufficient to add a seqid to LAYOUTGET/LAYOUTRETURN.]

3.3  Obtaining a Layout

   The metadata server will give out layouts of a particular type
   (block, object, or file) and aggregation as requested by the client.
   A client obtains a layout through a new operation (LAYOUTGET).  The
   client selects an appropriate layout type which the server supports
   and the client is prepared to use.  The layout returned to the client
   may not line up exactly with the requested byte range.  However, at
   least a single byte overlap MUST exist between the requested layout
   and the layout returned by the metadata server.

   There is no implied ordering between getting a layout and performing
   a file OPEN.  For example, a layout may first be retrieved by placing
   a LAYOUTGET operation in the same compound as the initial file OPEN.
   Once the layout has been retrieved, it can be held across multiple
   OPEN and CLOSE sequences.

   The storage protocol used by the client to access the data on the
   storage device is determined by the layout's type.  The client needs
   to select a "layout driver" that understands how to interpret and use
   that layout.  The API used by the client to talk to its drivers is
   outside the scope of the pNFS extension.  The storage protocol
   between the client's layout driver and the actual storage is covered
   by other protocols specifications such as SBC (block storage), OSD
   (object storage) or NFS (file storage).

   Although, the metadata server is in control of the layout for a file,
   the pNFS client can provide hints to the server when a file is opened
   or created about preferred layout type and aggregation scheme.  The
   pNFS extension introduces a LAYOUT_HINT attribute that the client can
   set at creation time to provide a hint to the server for new files.
   It is suggested that this attribute be set as one of the initial
   attributes to OPEN when creating a new file.  Setting this attribute
   separately, after the file has been created could make it difficult
   (or impossible) for the server implementation to comply.

3.3.1  Identifying Layouts

   A layout is identified by the following tuple: (ClientID, FH, offset,
   length, layout type, iomode); the FH refers to the FH of the file on
   the metadata server, the offset and length specify the byte range of



Welch, et al.           Expires January 16, 2006               [Page 14]

Internet-Draft               pNFS Operations                   July 2005


   the file covered by the layout.  The iomode specifies the client's
   intent for data access (as described previously).  Including the
   iomode in the layout allows for distinct read-only and writable (and
   readable) layouts to be held, possibly simultaneously (depending on
   the layout type specific protocol).

   Since there is a desire to manage layouts as sub-dividable entities,
   layouts are range-based and are identified in such a manner.  Sub-
   dividable layouts have the benefit of being returnable/recallable or
   committable in smaller chunks without having to return, recall, or
   commit the entire layout.  E.g., this may be useful when the layout
   is very large and a client is only actively using a small range of
   the layout, thus the client may not want to commit the entire layout,
   rather it could commit just the range of the layout it is using.

3.3.2  Overlapping Layouts

   A metadata server may hand-out layouts, to the same client, that
   overlap, as long as the overlapping regions specify the same storage
   device/file mapping; i.e., the records within the overlapping layouts
   should specify the same storage device mapping for the same byte
   ranges they represent.  If two overlapping layouts, of the same type
   and iomode, differ, the old layout should be recalled and returned,
   before giving out the new layout.

3.3.3  Copy-on-write

   [OPEN ISSUE]

   For block-based protocols, it is useful to have the ability to direct
   a client to read data from one group of blocks, but write to a
   different group; e.g., to implement a snapshotting blocks system.
   The client cannot make the choice of where to place data, it requires
   help from the metadata server, most probably communicated through the
   layout.  A single layout with the ability to mark (and re-mark)
   portions read-only vs. read/write is sufficient for this to work.
   Alternatively, separate read-only vs. read/write layouts, as
   identified by the iomode, may be given out.

3.4  Recalling a Layout

   Since a layout protects a client's access to a file via a direct
   client-data-server path, a layout need only be recalled when it is
   semantically unable to serve this function.  Typically, this occurs
   when the layout no longer encapsulates the true location of the file
   over the byte range it represents.  Any operation or action (e.g.,
   server driven restriping or load balancing) that changes the layout
   will result in a recall of the layout.  A layout is recalled by the



Welch, et al.           Expires January 16, 2006               [Page 15]

Internet-Draft               pNFS Operations                   July 2005


   CB_LAYOUTRECALL callback operation (see Section 10.1).  This callback
   can either recall a layout identified by a byte range, or all the
   layouts associated with a file system (FSID).  The iomode must also
   be specified when recalling layouts.  A special LAYOUTIOMODE_ANY
   enumeration is defined to enable recalling a layout of any type
   (i.e., the client must return both read-only and read/write layouts).

   A REMOVE operation may cause the metadata server to recall the layout
   to prevent the client from accessing a non-existent file and to
   reclaim state stored on the client.  Since a REMOVE may be delayed
   until the last close of the file has occurred, the recall may also be
   delayed until this time.  As well, once the file has been removed
   (after the last reference), the client SHOULD no longer be able to
   perform I/O using the layout (e.g., with file-based layouts an error
   such as ESTALE could be returned).

   Although, the pNFS extension does not alter the caching capabilities
   of clients (or their semantics) it recognizes that some clients may
   perform more aggressive write-behind caching to optimize the benefits
   provided by pNFS.  However, write-behind caching may impact the
   latency in returning a layout in response to a CB_LAYOUTRECALL; just
   as caching impacts DELEGRETURN with regards to data delegations.
   Client implementations should limit the amount of dirty data they
   have outstanding at any one time.  Server implementations may fence
   clients from performing direct I/O to the storage devices if they
   perceive that the client is taking too long to return a layout once
   recalled.  A server may be able to monitor client progress by
   watching client I/Os or by observing LAYOUTRETURNs of sub-portions of
   the recalled layout.  The server can also limit the amount of dirty
   data to be flushed to storage devices by limiting the byte ranges
   covered in the layouts it gives out.

   Once a layout has been returned, the client should no longer issue
   I/Os to the storage devices for the file, byte range, and iomode
   represented by the returned layout.  If a client does issue an I/O to
   a storage device for which it does not hold a layout, the storage
   device may reject the I/O.

3.5  Committing a Layout

   Due to the nature of the protocol, the file attributes that exist on
   the metadata storage device may become inconsistent in relation to
   the data stored on the storage devices; e.g., when WRITEs occur
   before a layout has been committed (e.g., between a LAYOUTGET and a
   LAYOUTCOMMIT).  Thus, it is necessary to occasionally re-sync this
   state and make it visible to other clients through the metadata
   server.




Welch, et al.           Expires January 16, 2006               [Page 16]

Internet-Draft               pNFS Operations                   July 2005


   The LAYOUTCOMMIT operation is responsible for committing the modified
   layout to the metadata server.  Note: the data should be written (and
   committed) to the appropriate storage devices before the LAYOUTCOMMIT
   occurs.  The scope of this operation depends on the storage protocol
   in use.  For block-based layouts, it may require updating the block
   list that comprises the file and committing this layout to stable
   storage.  While, for file-layouts it requires some synchronization of
   attributes between the metadata and storage devices (mainly the size
   attribute; EOF).  It is important to note that the level of
   synchronization is from the point of view of the client who issued
   the LAYOUTCOMMIT.  The updated state on the metadata server need only
   reflect the state as of the client's last operation (previous to the
   LAYOUTCOMMIT), it need not reflect a globally synchronized state
   (e.g., other clients may be performing, or may have performed I/O
   since the client's last operation and the LAYOUTCOMMIT).

   The management protocol is free to synchronize the attributes before
   it receives a LAYOUTCOMMIT, however upon successful completion of a
   LAYOUTCOMMIT, state that exists on the metadata server that describes
   the file MUST be in sync with the state existing on the storage
   devices that comprise that file as of the issuing client's last
   operation.  Thus, a client that queries the size of a file between a
   WRITE to a storage device and the LAYOUTCOMMIT may observe a size
   that does not reflects the actual data written.

3.5.1  LAYOUTCOMMIT and mtime/atime/change

   The change attribute and the modify/access times may be updated, by
   the server, at LAYOUTCOMMIT time; since for some layout types, the
   change attribute (and atime/mtime) can not be updated by the
   appropriate I/O operation performed at a storage device.  The
   arguments to LAYOUTCOMMIT allow the client to provide suggested
   access and modify time values to the server.  Again, depending upon
   the layout type, these client provided values may or may not be used.
   The server should sanity check the client provided values before they
   are used.  For example, the server should ensure that time does not
   flow backwards.  The client always has the option to set these
   attributes (according to the NFSv4 specification) through an explicit
   SETATTR operation.

   As mentioned, for some layout protocols the change attribute and
   mtime/atime may be updated at or after the time the I/O occurred
   (e.g., if the storage device is able to communicate these attributes
   to the metadata server).  If, upon receiving a LAYOUTCOMMIT, the
   server implementation is able to determine that the file did not
   change since the last time the change attribute was updated (e.g., no
   WRITEs or over-writes occurred), the implementation need not update
   the change attribute (file-based protocols may have enough state to



Welch, et al.           Expires January 16, 2006               [Page 17]

Internet-Draft               pNFS Operations                   July 2005


   make this determination or may update the change attribute upon each
   file modification).  This also applies for mtime and atime; if the
   server implementation is able to determine that the file has not been
   modified since the last mtime update, the server need not update
   mtime at LAYOUTCOMMIT time.  Once LAYOUTCOMMIT completes, the new
   change attribute and mtime/atime should be visible if that file was
   modified since the latest previous LAYOUTCOMMIT or LAYOUTGET.

3.5.2  LAYOUTCOMMIT and size

   The file's size may be updated at LAYOUTCOMMIT time as well.  The
   LAYOUTCOMMIT operation contains an argument that indicates the last
   byte offset to which the client wrote ("lastbytewritten").  Note: for
   this offset to be viewed as a file size it must be incremented by one
   byte (a write to offset 0 would map into a file size of 1, but the
   last byte written is 0).  The metadata server may do one of the
   following:

   1.  It may update the file's size based on the last byte written
       offset.  However, to the extent possible, the metadata server
       should sanity check any value to which the file's size is going
       to be set.  E.g., it must not truncate the file based on the
       client presenting a smaller last byte written offset than the
       file's current size.

   2.  If it has sufficient other knowledge of file size (e.g., by
       querying the storage devices through the management protocol), it
       may ignore the client provided argument and use the query-derived
       value.

   3.  It may use the last byte written offset as a hint, subject to
       correction when other information is available as above.

   The method chosen to update the file's size will depend on the
   storage device's and/or the management protocol's implementation.
   For example, if the storage devices are block devices with no
   knowledge of file size, the metadata server must rely on the client
   to set the size appropriately.  A new size flag and length are also
   returned in the results of a LAYOUTCOMMIT.  This union indicates
   whether a new size was set, and to what length it was set.  If a new
   size is set as a result of LAYOUTCOMMIT, then the metadata server
   must reply with the new size.  As well, if the size is updated, the
   metadata server in conjunction with the management protocol SHOULD
   ensure that the new size is reflected by the storage devices
   immediately upon return of the LAYOUTCOMMIT operation; e.g., a READ
   up to the new file size should succeed on the storage devices
   (assuming no intervening truncations).  Again, if the client wants to
   explicitly grow or shrink a file, SETATTR must be used.



Welch, et al.           Expires January 16, 2006               [Page 18]

Internet-Draft               pNFS Operations                   July 2005


   Since client layout holders may be unaware of changes made to the
   file's size (through LAYOUTCOMMIT or SETATTR) by other clients, an
   additional callback/notification has been added for pNFS.
   CB_SIZECHANGED is a notification that the metadata server sends to
   layout holders to notify them of a change in file size.  This is
   preferred over issuing CB_LAYOUTRECALL to each of the layout holders.

3.5.3  LAYOUTCOMMIT and layoutupdate

   The LAYOUTCOMMIT operation contains a "layoutupdate" argument.  This
   argument is a layout type specific structure.  The structure can be
   used to pass arbitrary layout type specific information from the
   client to the metadata server at LAYOUTCOMMIT time.  For example, if
   using a block layout, the client can indicate to the metadata server
   which reserved or allocated blocks it used and which it did not.  The
   "layoutupdate" structure need not be the same structure as the layout
   returned by LAYOUTGET.  The structure is defined by the layout type
   and is opaque to LAYOUTCOMMIT.

3.6  Crash Recovery

   Crash recovery is complicated due to the distributed nature of the
   pNFS protocol.  In general, crash recovery for layouts is similar to
   crash recovery for delegations in the base NFSv4 protocol.  However,
   the client's ability to perform I/O without contacting the metadata
   server introduces subtleties that must be handled correctly if file
   system corruption is to be avoided.

3.6.1  Leases

   The layout lease period plays a critical role in crash recovery.
   Depending on the capabilities of the storage protocol, it is crucial
   that the client is able to maintain an accurate layout lease timer to
   ensure that I/Os are not issued to storage devices after expiration
   of the layout lease period.  In order for the client to do so, it
   must know which operations renew a lease.

3.6.1.1  Lease Renewal

   The current NFSv4 specification allows for implicit lease renewals to
   occur upon receiving an I/O. However, due to the distributed pNFS
   architecture, implicit lease renewals are limited to operations
   performed at the metadata server (including I/O performed through the
   metadata server).  So, a client must not assume that READ and WRITE
   I/O to storage devices implicitly renew lease state.

   If sessions are required for pNFS, as has been suggested, then the
   SEQUENCE operation is to be used to explicitly renew leases.  It is



Welch, et al.           Expires January 16, 2006               [Page 19]

Internet-Draft               pNFS Operations                   July 2005


   proposed that the SEQUENCE operation be extended to return all the
   specific information that RENEW does, but not as an error as RENEW
   returns it.  Since, when using session, beginning each compound with
   the SEQUENCE op allows renews to be performed without an additional
   operation and without an additional request.  Again, the client must
   not rely on any operation to the storage devices to renew a lease.
   Using the SEQUENCE operation for renewals, simplifies the client's
   perception of lease renewal.

3.6.1.2  Client Lease Timer

   Depending on the storage protocol and layout type in use, it may be
   crucial that the client not issue I/Os to storage devices if the
   corresponding layout's lease has expired.  Doing so may lead to file
   system corruption if the layout has been given out and used by
   another client.  In order to prevent this, the client must maintain
   an accurate lease timer for all layouts held.  RFC3530 has the
   following to say regarding the maintenance of a client lease timer:

      ...the client must track operations which will renew the lease
      period.  Using the time that each such request was sent and the
      time that the corresponding reply was received, the client should
      bound the time that the corresponding renewal could have occurred
      on the server and thus determine if it is possible that a lease
      period expiration could have occurred.

   To be conservative, the client should start its lease timer based on
   the time that the it issued the operation to the metadata server,
   rather than based on the time of the response.

   It is also necessary to take propagation delay into account when
   requesting a renewal of the lease:

      ...the client should subtract it from lease times (e.g., if the
      client estimates the one-way propagation delay as 200 msec, then
      it can assume that the lease is already 200 msec old when it gets
      it).  In addition, it will take another 200 msec to get a response
      back to the server.  So the client must send a lock renewal or
      write data back to the server 400 msec before the lease would
      expire.

   Thus, the client must be aware of the one-way propagation delay and
   should issue renewals well in advance of lease expiration.  Clients,
   to the extent possible, should try not to issue I/Os that may extend
   past the lease expiration time period.  However, since this is not
   always possible, the storage protocol must be able to protect against
   the effects of inflight I/Os, as is discussed later.




Welch, et al.           Expires January 16, 2006               [Page 20]

Internet-Draft               pNFS Operations                   July 2005


3.6.2  Client Recovery

   Client recovery for layouts works in much the same way as NFSv4
   client recovery works for other lock/delegation state.  When an NFSv4
   client reboots, it will lose all information about the layouts that
   it previously owned.  There are two methods by which the server can
   reclaim these resources and allow otherwise conflicting layouts to be
   provided to other clients.

   The first is through the expiry of the client's lease.  If the client
   recovery time is longer than the lease period, the client's lease
   will expire and the server will know that state may be released. for
   layouts the server may release the state immediately upon lease
   expiry or it may allow the layout to persist awaiting possible lease
   revival, as long as there are no conflicting requests.

   On the other hand, the client may recover in less time than it takes
   for the lease period to expire.  In such a case, the client will
   contact the server through the standard SETCLIENTID protocol.  The
   server will find that the client's id matches the id of the previous
   client invocation, but that the verifier is different.  The server
   uses this as a signal to release all the state associated with the
   client's previous invocation.

3.6.3  Metadata Server Recovery

   The server recovery case is slightly more complex.  In general, the
   recovery process again follows the standard NFSv4 recovery model: the
   client will discover that the metadata server has rebooted when it
   receives an unexpected STALE_STATEID or STALE_CLIENTID reply from the
   server; it will then proceed to try to reclaim its previous
   delegations during the server's recovery grace period.  However,
   layouts are not reclaimable in the same sense as data delegations;
   there is no reclaim bit, thus no guarantee of continuity between the
   previous and new layout.

   [OPEN ISSUE: there is no reclaim bit for getting a layout.  Currently
   layouts obtained through LAYOUTGET make no guarantee of continuity in
   the case of reclaiming an old layout.  Recall, a layout is not
   required to perform I/O. I/O can always be performed through the
   metadata server.  If a reclaim bit existed a block layout type might
   be happier knowing it got the layout back with the assurance of
   continuity.  However, this would require the metadata server trusting
   the client in telling it the exact layout it had (i.e., the full
   block-list); maybe too much trust?]

   If the client has dirty data that it needs to write out, or an
   outstanding LAYOUTCOMMIT, the client should try to obtain a new



Welch, et al.           Expires January 16, 2006               [Page 21]

Internet-Draft               pNFS Operations                   July 2005


   layout covering the byte range covering the previous layout.
   However, the client might not not get the same layout it had.  The
   range might be different or it might get the same range but the
   content of the layout might be different.  For example, if using a
   block-based layout, the blocks provisionally assigned by the layout
   might be different, in which case the client will have to write the
   corresponding blocks again (and it might decide in the interests of
   simplicity to always write them again).  Alternatively, the client
   might be unable to obtain a new layout and thus, must write the data
   using normal NFSv4 through the metadata server.

   There is an important safety concern associated with layouts that
   does not come into play in the standard NFSv4 case.  If a standard
   NFSv4 client makes use of a stale delegation, while reading, the
   consequence could be to deliver stale data to an application.  If
   writing, using a stale delegation or a stale state stateid for an
   open or lock would result in the rejection of the client's write with
   the appropriate stale stateid error.

   However, the pNFS layout enables the client to directly access the
   file system storage---if this access is not properly managed by the
   NFSv4 server the client can potentially corrupt the file system data
   or metadata.  Thus, it is vitally important that the client discover
   that the metadata server has rebooted, and that the client stops
   using stale layouts before the metadata server gives them away to
   other clients.  To ensure this, the client must be implemented so
   that layouts are never used to access the storage after the client's
   lease timer has expired.  It is crucial that clients have precise
   knowledge of the lease periods of their layouts.  For specific
   details on lease renewal and client lease timers, see Section 3.6.1.

   The prohibition on using stale layouts applies to all layout related
   accesses, especially the flushing of dirty data to the storage
   devices.  If the client's lease timer expires because the client
   could not contact the server for any reason, the client MUST
   immediately stop using the layout until the server can be contacted
   and the layout can be officially recovered or reclaimed.  However,
   this is only part of the solution.  It is also necessary to deal with
   the consequences of I/Os already in flight.

   The issue of the effects of I/Os started before lease expiration and
   possibly continuing through lease expiration is the responsibility of
   the data storage protocol and as such is layout type specific.  There
   are two approaches the data storage protocol can take.  The protocol
   may adopt a global solution which prevents all I/Os from being
   executed after the lease expiration (and thus is safe against a
   client who issues I/Os after lease expiration).  This is the
   preferred solution and the solution used by NFSv4 file based layouts



Welch, et al.           Expires January 16, 2006               [Page 22]

Internet-Draft               pNFS Operations                   July 2005


   (see Section 5.6).  Alternatively, the storage protocol may rely on
   proper client operation and only deal with the effects of lingering
   I/Os.  These solutions may impact the client layout-driver, the
   metadata server layout-driver, and the management protocol.

4.  Security Considerations

   The pNFS extension partitions the NFSv4 file system protocol into two
   parts, the control path and the data path (storage protocol).  The
   control path contains all the new operations described by this
   extension; all existing NFSv4 security mechanisms and features apply
   to the control path.  The combination of components in a pNFS system
   (see Figure 1) is required to preserve the security properties of
   NFSv4 with respect to an entity accessing data via a client,
   including security countermeasures to defend against threats that
   NFSv4 provides defenses for in environments where these threats are
   considered significant.

   In some cases, the security countermeasures for connections to
   storage devices may take the form of physical isolation or a
   recommendation not to use pNFS in an environment.  For example, it is
   currently infeasible to provide confidentiality protection for some
   storage device access protocols to protect against eavesdropping; in
   environments where eavesdropping on such protocols is of sufficient
   concern to require countermeasures, physical isolation of the
   communication channel (e.g., via direct connection from client(s) to
   storage device(s)) and/or a decision to forego use of pNFS (e.g., and
   fall back to NFSv4) may be appropriate courses of action.

   In full generality where communication with storage devices is
   subject to the same threats as client-server communication, the
   protocols used for that communication need to provide security
   mechanisms comparable to those available via RPSEC_GSS for NFSv4.
   Many situations in which pNFS is likely to be used will not be
   subject to the overall threat profile for which NFSv4 is required to
   provide countermeasures.

   pNFS implementations MUST NOT remove NFSv4's access controls.  The
   combination of clients, storage devices, and the server are
   responsible for ensuring that all client to storage device file data
   access respects NFSv4 ACLs and file open modes.  This entails
   performing both of these checks on every access in the client, the
   storage device, or both.  If a pNFS configuration performs these
   checks only in the client, the risk of a misbehaving client obtaining
   unauthorized access is an important consideration in determining when
   it is appropriate to use such a pNFS configuration.  Such
   configurations SHOULD NOT be used when client- only access checks do
   not provide sufficient assurance that NFSv4 access control is being



Welch, et al.           Expires January 16, 2006               [Page 23]

Internet-Draft               pNFS Operations                   July 2005


   applied correctly.

   The following subsections describe security considerations
   specifically applicable to each of the three major storage device
   protocol types supported for pNFS.

   [Additional security info - the object protocol needs this, but it
   may be out-of-band; the OSD experts will know for sure.  For Block
   and File an approach of the client being expected to know what it
   needs when it sees what it's being asked to access probably suffices,
   although we might be able to help (e.g., pass iSCSI CHAP
   authentication identities, but NOT secrets, via pNFS).  For File in
   particular, defaulting to the NFSv4 principal is probably a good
   idea, although it's not strictly necessary.]

   [Requiring strict equivalence to NFSv4 security mechanisms is the
   wrong approach.  Will need to lay down a set of statements that each
   protocol has to make starting with access check location/properties.]

4.1  File Layout Security

   A NFSv4 file layout type is defined in Section 5; see Section 5.7 for
   additional security considerations and details.  In summary, the
   NFSv4 file layout type requires that all I/O access checks MUST be
   performed by the storage devices, as defined by the NFSv4
   specification.  If another file layout type is being used, additional
   access checks may be required.  But in all cases, the access control
   performed by the storage devices must be at least as strict as that
   specified by the NFSv4 protocol.

4.2  Object Layout Security

   The object storage protocol relies on a cryptographically secure
   capability to control accesses at the object storage devices.
   Capabilities are generated by the metadata server, returned to the
   client, and used by the client as described below to authenticate
   their requests to the Object Storage Device (OSD).  Capabilities
   therefore achieve the required access and open mode checking.  They
   allow the file server to define and check a policy (e.g., open mode)
   and the OSD to check and enforce that policy without knowing the
   details (e.g., user IDs and ACLs).  Since capabilities are tied to
   layouts, and since they are used to enforce access control, the
   server should recall layouts and revoke capabilities when the file
   ACL or mode changes in order to signal the clients.

   Each capability is specific to a particular object, an operation on
   that object, a byte range w/in the object, and has an explicit
   expiration time.  The capabilities are signed with a secret key that



Welch, et al.           Expires January 16, 2006               [Page 24]

Internet-Draft               pNFS Operations                   July 2005


   is shared by the object storage devices (OSD) and the metadata
   managers. clients do not have device keys so they are unable to forge
   capabilities.

   The details of the security and privacy model for Object Storage are
   out of scope of this document and will be specified in the Object
   Storage version of the storage protocol definition.  However, the
   following sketch of the algorithm should help the reader understand
   the basic model.

   LAYOUTGET returns

     {CapKey = MAC<SecretKey>(CapArgs), CapArgs}

   The client uses CapKey to sign all the requests it issues for that
   object using the respective CapArgs.  In other words, the CapArgs
   appears in the request to the storage device, and that request is
   signed with the CapKey as follows:

     ReqMAC = MAC<CapKey>(Req, Nonceln)

   The following is sent to the OSD: {CapArgs, Req, Nonceln, ReqMAC}.
   The OSD uses the SecretKey it shares with the metadata server to
   compare the ReqMAC the client sent with a locally computed

     MAC<MAC<SecretKey>(CapArgs)>(Req, Nonceln)

   and if they match the OSD assumes that the capabilities came from an
   authentic metadata server and allows access to the object, as allowed
   by the CapArgs.  Therefore, if the server LAYOUTGET reply, holding
   CapKey and CapArgs, is snooped by another client, it can be used to
   generate valid OSD requests (within the CapArgs access restriction).

   To provide the required privacy requirements for the capabilities
   returned by LAYOUTGET, the GSS-API can be used, e.g. by using a
   session key known to the file server and to the client to encrypt the
   whole layout or parts of it.  Two general ways to provide privacy in
   the absence of GSS-API that are independent of NFSv4 are either an
   isolated network such as a VLAN or a secure channel provided by
   IPsec.

4.3  Block Layout Security

   As typically used, block protocols rely on clients to enforce file
   access checks since the storage devices are generally unaware of the
   files they are storing (and in particular are unaware of which blocks
   belongs to which file).  In such environments, the physical addresses
   of blocks are exported to pNFS clients via layouts.  An alternative



Welch, et al.           Expires January 16, 2006               [Page 25]

Internet-Draft               pNFS Operations                   July 2005


   method of block protocol use is for the storage devices to export
   virtualized block addresses, which do reflect the files to which
   blocks belong.  These virtual block addresses are exported to pNFS
   clients via layouts.  This allows the storage device to make
   appropriate access checks, while mapping virtual block addresses to
   physical block addresses.

   In environments where access control is important and client-only
   access checks provide insufficient assurance of access control
   enforcement (e.g., there is concern about a malicious of
   malfunctioning client skipping the access checks) and where physical
   block addresses are exported to clients, the storage devices will
   generally be unable to compensate for these client deficiencies.

   In such threat environments, block protocols SHOULD NOT be used with
   pNFS, unless the data server is able to implement the appropriate
   access checks, via use of virtualized block addresses, or other
   means.  NFSv4 without pNFS or pNFS with a different type of storage
   protocol would be a more suitable means to access files in such
   environments.  Storage-device/protocol-specific methods (e.g.  LUN
   masking/mapping) may be available to prevent malicious or high-risk
   clients from directly accessing storage devices.

5.  NFSv4 File Layout Type

   This section describes the semantics and format of NFSv4 file-based
   layouts.

5.1  File Striping and Data Access

   The file layout type describes a method for striping data across
   multiple devices.  The data for each stripe unit is stored within an
   NFSv4 file located on a particular storage device.  The structures
   used to describe the stripe layout are as follows:

















Welch, et al.           Expires January 16, 2006               [Page 26]

Internet-Draft               pNFS Operations                   July 2005


    enum stripetype4 {
           STRIPE_SPARSE = 1,
           STRIPE_DENSE = 2
    };

    struct nfsv4_file_layout {                   /* Per device info */
           pnfs_deviceid4          dev_id;
           nfs_fh4                 fh;
    };

    struct nfsv4_file_layouttype4 {
           stripetype4             stripe_type;
           uint64_t                stripe_unit;
           length4                 file_size;
           nfsv4_file_layout       dev_list<>;
    };

   The file layout specifies an ordered array of (deviceID, filehandle)
   tuples, as well as the stripe size, type of stripe layout (discussed
   a little later), and the file's current size (current as of LAYOUTGET
   time).  The filehandle, "fh", identifies the file on a storage device
   identified by "dev_id", that holds a particular stripe of the file.
   The stripe width is determined by the stripe unit size multiplied by
   the number of devices in the dev_list.  The stripe held by (dev_id,
   fh) is determined by that tuples position within the device list,
   "dev_list".  For example, consider a dev_list consisting of the
   following (dev_id, fh) pairs:

   <(1,0x12), (2,0x13), (1,0x15)> and stripe_unit = 32KB

   The stripe width is 32KB * 3 devices = 96KB.  The first entry
   specifies that on device 1 in the data file with filehandle 0x12
   holds the first 32KB of data (and every 32KB stripe beginning where
   the file's offset % 96KB == 0).

   Notice, devices and filehandles may be repeated multiple times within
   the device list array (as is shown where storage device 1 holds both
   the first and third stripe of data).  Data is striped across the
   devices in the order listed in the device list array in increments of
   the stripe size.  A data file stored on a storage device MUST map to
   a single file as defined by the metadata server; i.e., data from two
   files as viewed by the metadata server MUST NOT be stored within the
   same data file on any storage device.

   The "stripe_type" field specifies how the data is laid out within the
   data file on a storage device.  It allows for two different data
   layouts: sparse and dense or packed.  The stripe type determines the
   calculation that must be made to map the file's offset (as visible to



Welch, et al.           Expires January 16, 2006               [Page 27]

Internet-Draft               pNFS Operations                   July 2005


   the client) to the offset within the data file located on the storage
   device.

5.1.1  Sparse and Dense Storage Device Data Layouts

   The stripe_type field allows for two storage device data file
   representations.  Example sparse and dense storage device data
   layouts are illustrated below:

    Sparse file-layout (stripe_unit = 4KB)
    ------------------

    Is represented by the following file layout on the storage devices:

        Offset  ID:0    ID:1   ID:2
        0       +--+    +--+   +--+                 +--+  indicates a
                |//|    |  |   |  |                 |//|  stripe that
        4KB     +--+    +--+   +--+                 +--+  contains data
                |  |    |//|   |  |
        8KB     +--+    +--+   +--+
                |  |    |  |   |//|
        12KB    +--+    +--+   +--+
                |//|    |  |   |  |
        16KB    +--+    +--+   +--+
                |  |    |//|   |  |
                +--+    +--+   +--+

   The sparse file-layout has holes for the byte ranges not exported by
   that storage device.  This allows clients to access data using the
   real offset into the file, regardless of the storage device's
   position within the stripe.  However, if a client writes to one of
   the holes (e.g., offset 4-12KB on device 1), then an error MUST be
   returned by the storage device.  This requires that the storage
   device have knowledge of the layout for each file.

   When using a sparse layout, the offset into the storage device data
   file is the same as the offset into the main file.














Welch, et al.           Expires January 16, 2006               [Page 28]

Internet-Draft               pNFS Operations                   July 2005


    Dense/packed file-layout (stripe_unit = 4KB)
    ------------------------

    Is represented by the following file layout on the storage devices:

        Offset  ID:0    ID:1   ID:2
        0       +--+    +--+   +--+
                |//|    |//|   |//|
        4KB     +--+    +--+   +--+
                |//|    |//|   |//|
        8KB     +--+    +--+   +--+
                |//|    |//|   |//|
        12KB    +--+    +--+   +--+
                |//|    |//|   |//|
        16KB    +--+    +--+   +--+
                |//|    |//|   |//|
                +--+    +--+   +--+

   The dense or packed file-layout does not leave holes on the storage
   devices.  Each stripe unit is spread across the storage devices.  As
   such, the storage devices need not know the file's layout since the
   client is allowed to write to any offset.

   The calculation to determine the byte offset within the data file for
   dense storage device layouts is:

     stripe_width = stripe_unit * N; where N = |dev_list|
     dev_offset = floor(file_offset / stripe_width) * stripe_unit +
                  file_offset % stripe_unit

   Regardless of the storage device data file layout, the calculation to
   determine the index into the device array is the same:

     dev_idx = floor(file_offset / stripe_unit) mod N


5.1.2  Operations Issued to Storage Devices

   Clients MUST use the filehandle described within the layout when
   accessing data on the storage devices.  When using the layout's
   filehandle, the client MUST only issue READ, WRITE, PUTFH, COMMIT,
   and NULL operations to the storage device associated with that
   filehandle.  If a client issues an operation other than those
   specified above, using the filehandle and storage device listed in
   the client's layout, that storage device SHOULD return an error to
   the client.  The client MUST follow the instruction implied by the
   layout (which filehandles to use on which devices).  As described in
   Section 3.2, a client MUST NOT issue I/Os to storage devices for



Welch, et al.           Expires January 16, 2006               [Page 29]

Internet-Draft               pNFS Operations                   July 2005


   which it does not hold a valid layout.  The storage devices may
   reject such requests.

   [OPEN ISSUE: Should SHOULD be should]

   GETATTR and SETATTR MUST be directed to the metadata server.  In the
   case of a SETATTR of the size attribute, the management protocol is
   responsible for propagating size updates/truncations to the storage
   devices.  In the case of extending WRITEs to the storage devices, the
   new size must be visible on the metadata server once a LAYOUTCOMMIT
   has completed (see Section 3.5.2, Section 5.5.2).  All size attribute
   updates MUST be effective on the storage devices immediately (by the
   time the metadata operation returns), so that READs past EOF can be
   recognized.

5.2  Global Stateid Requirements

   Note, there are no stateids returned embedded within the layout.  The
   client MUST use the stateid representing open or lock state as
   returned by an earlier metadata operation (e.g., OPEN, LOCK), or a
   special stateid to perform I/O on the data-servers (as in regular
   NFSv4).  Special stateid usage for I/O is subject to the NFSv4
   protocol specification.  The stateid used for I/O MUST have the same
   effect and be subject to the same validation on storage device as it
   would if the I/O was being performed on the metadata server itself
   (in the absence of pNFS).  This has the implication that stateids are
   globally valid on both the metadata and storage devices.  This
   requires the metadata server to propagate changes in lock and open
   state to the data-servers, so that the data-servers can validate I/O
   accesses.  This is discussed further in Section 5.4.

5.3  The Layout Iomode

   The layout iomode need not used by the metadata server when servicing
   NFSv4 file-based layouts, although in some circumstances it may be
   useful to use.  For example, if the server implementation supports
   reading from read-only replicas or mirrors, it would be useful for
   the server to return a layout enabling the client to do so.  As such,
   the client should set the iomode based on its intent to read or write
   the data.  The client may default to an iomode of READ/WRITE.  The
   iomode need not be checked by the storage devices when clients
   perform I/O. However, the storage devices SHOULD still validate that
   the client holds a valid layout and return an error if the client
   does not.

   [OPEN ISSUE: Again, requiring storage devices to validate that
   clients hold valid layouts, requires propagating layouts to storage
   devices.  This is not possible if using vanilla NFSv4 storage



Welch, et al.           Expires January 16, 2006               [Page 30]

Internet-Draft               pNFS Operations                   July 2005


   devices.]

5.4  Storage Device State Propagation

   Since the metadata server, which handles lock and open-mode state
   changes, as well as ACLs, may not be collocated with the storage
   devices (where I/O access is validated), the server implementation
   MUST take care of propagating changes of this state to the storage
   devices.  Once the propagation to the storage devices is complete,
   the full effect of those changes must be in effect at the storage
   devices.  However, some state changes need not be propagated
   immediately, although all changes SHOULD be propagated promptly.
   These state propagations have an impact on the design of the
   management protocol, even though the management protocol is outside
   of the scope of this specification.  Immediate propagation refers to
   the synchronous propagation of state from the metadata server to the
   storage device(s); the propagation must be complete before returning
   to the client.

5.4.1  Lock State Propagation

   Mandatory locks MUST be made effective at the storage devices before
   the request that establishes them returns to the caller.  Thus,
   mandatory lock state MUST be synchronously propagated to the storage
   devices.  On the other hand, since advisory lock state is not used
   for checking I/O accesses at the storage devices, there is no
   semantic reason for propagating advisory lock state to the storage
   devices.  However, since all lock, unlock, open downgrades and
   upgrades affect the sequence ID stored within the stateid, the
   stateid changes which may cause difficulty if this state is not
   propagated.  Thus, when a client uses a stateid on a storage device
   for I/O with a newer sequence number than the one the storage device
   has, the storage device should query the metadata server and get any
   pending updates to that stateid.  This allows stateid sequence number
   changes to be propagated lazily, on-demand.

   [OPEN ISSUE: How does the requirement of sessions affect the
   propagation of stateid sequence numbers?]

   Since updates to advisory locks neither confer nor remove privileges,
   these changes need not be propagated immediately, and may not need to
   be propagated promptly.  The updates to advisory locks need only be
   propagated when the storage device needs to resolve a question about
   a stateid.  In fact, if byte-range locking is not mandatory (is
   advisory) the clients are advised not to use the lock-based stateids
   for I/O at all.  The stateids returned by open are sufficient and
   eliminate overhead for this kind of state propagation.




Welch, et al.           Expires January 16, 2006               [Page 31]

Internet-Draft               pNFS Operations                   July 2005


5.4.2  Open-mode Validation

   Open-mode validation MUST be performed against the open mode(s) held
   by the storage devices.  However, the server implementation may not
   always require the immediate propagation of changes.  Reduction in
   access because of CLOSEs or DOWNGRADEs do not have to be propagated
   immediately, but SHOULD be propagated promptly (whereas changes due
   to revocation MUST be propagated immediately).  On the other hand,
   changes that expand access (e.g., new OPEN's and upgrades) don't have
   to be propagated immediately but the storage device SHOULD NOT reject
   a request because of mode issues without making sure that the upgrade
   is not in flight.

5.4.3  File Attributes

   Since the SETATTR operation has the ability to modify state that is
   visible on both the metadata and storage devices (e.g., the size),
   care must be taken to ensure that the resultant state (across the set
   of storage devices) is consistent; especially when truncating or
   growing the file.

   As described earlier, the LAYOUTCOMMIT operation is used to ensure
   that the metadata is synced with changes made to the storage devices.
   For the file-based protocol, it is necessary to re-sync state such as
   the size attribute, and the setting of mtime/atime.  See Section 3.5
   for a full description of the semantics regarding LAYOUTCOMMIT and
   attribute synchronization.  It should be noted, that by using a file-
   based layout type, it is possible to synchronize this state before
   LAYOUTCOMMIT occurs.  For example, the management protocol can be
   used to query the attributes present on the storage devices.

   Any changes to file attributes that control authorization (or access)
   as reflected by ACCESS calls or READs and WRITEs on the metadata
   server, MUST be propagated to the storage devices for enforcement on
   READ and WRITE I/O calls.  If the changes made on the metadata server
   result in more restrictive access permissions for any user, those
   changes MUST be propagated to the storage devices synchronously.

   Recall that the NFSv4 protocol [2] specifies that:

      ...since the NFS version 4 protocol does not impose any
      requirement that READs and WRITEs issued for an open file have the
      same credentials as the OPEN itself, the server still must do
      appropriate access checking on the READs and WRITEs themselves.

   This also includes changes to ACLs.  The propagation of access right
   changes due to changes in ACLs may be asynchronous only if the server
   implementation is able to determine that the updated ACL is not more



Welch, et al.           Expires January 16, 2006               [Page 32]

Internet-Draft               pNFS Operations                   July 2005


   restrictive for any user specified in the old ACL.  Due to the
   relative infrequency of ACL updates, it is suggested that all changes
   be propagated synchronously.

   [OPEN ISSUE: it has been suggested that the NFSv4 specification is in
   error with regard to allowing principles other than those used for
   OPEN to be used for file I/O. It has been suggested that it should be
   fixed here by pNFS].

5.5  Extending file size

5.5.1  READs and EOF

   A potential problem exists when a data file on a particular storage
   device is grown past EOF; it exists for both dense and sparse
   layouts.  Imagine the following scenario: a client creates a new file
   (size == 0) and writes to byte 128KB; the client then seeks to the
   beginning of the file and reads byte 100.  The client should receive
   0s back as a result of the read.  However, if the read falls on a
   different storage device to the client's original write, the storage
   device servicing the READ may still believe that the file's size is
   at 0 and return no data (with the EOF flag set).  The storage device
   can only return 0s if it knows that the file's size has been
   extended.  This would require the immediate propagation of the file's
   size to all storage devices, which is potentially very costly,
   instead, another approach as outlined below.

   First, the file's size is returned within the layout by LAYOUTGET.
   This size must reflect the latest size at the metadata server as set
   by the most recent of either the last LAYOUTCOMMIT or SETATTR;
   however, it may be more recent.  Second, if a client performs a read
   that is returned short (i.e., is fully within the file's size, but
   the storage device indicates EOF and returns partial or no data), the
   client must assume that it is a hole and substitute 0s for the data
   not read (up until its known local file size).  If a client extends
   the file, it must update its local file size.  Third, if the metadata
   server receives a SETATTR of the size or a LAYOUTCOMMIT that alters
   the file's size, the metadata server MUST send out CB_SIZECHANGED
   messages with the new size to clients holding layouts (it need not
   send a notification to the client that performed the operation that
   resulted in the size changing).  Upon reception of the CB_SIZECHANGED
   notification, clients must update their local size for that file.  As
   well, if a new file size is returned as a result to LAYOUTCOMMIT, the
   client must update their local file size.

5.5.2  LAYOUTCOMMIT and EOF

   Another complication can arise due to EOF.  If a file has been grown



Welch, et al.           Expires January 16, 2006               [Page 33]

Internet-Draft               pNFS Operations                   July 2005


   by a set of WRITEs prior to a LAYOUTCOMMIT, the management protocol
   must ensure that the corresponding file on each storage device is
   grown (possibly sparsely) up until the offset represented by the EOF
   length before LAYOUTCOMMIT returns.

   For example: Imagine a file is striped across four storage devices,
   using a sparse file layout, with 64KB on each storage device.  A
   WRITE of 64KB occurs starting at offset 192KB (the first stripe on
   the 4th storage device) followed by a LAYOUTCOMMIT.  The new EOF
   offset is now at 256KB, however the corresponding file size on the
   first three storage devices is 0, since they did not service any
   WRITE operations.  Immediately upon completion of LAYOUTCOMMIT, the
   server implementation MUST ensure that READs to any of the storage
   devices, at an offset below EOF, succeed; indeed, in this example, a
   read to any of the first three storage devices (below EOF) must
   return all 0s.  The easiest way to accomplish this is to set the file
   size on each of the storage devices to EOF.  Note, this only need
   occur at LAYOUTCOMMIT time or upon the reception of a SETATTR that
   modifies the size.

5.6  Crash Recovery Considerations

   As described in Section 3.6, the layout type specific storage
   protocol is responsible for handling the effects of I/Os started
   before lease expiration, extending through lease expiration.  The
   NFSv4 file layout type prevents all I/Os from being executed after
   lease expiration, without relying on a precise client lease timer and
   without requiring storage devices to maintain lease timers.

   It works as follows.  In the presence of sessions, each compound
   begins with a SEQUENCE operation that contains the "clientID".  On
   the storage device, the clientID can be used to validate that the
   client has a valid layout for the I/O being performed, if it does
   not, the I/O is rejected.  Before the metadata server takes any
   action to invalidate a layout given out by a previous instance, it
   must make sure that all layouts from that previous instance are
   invalidated at the storage devices.  Note: it is sufficient to
   invalidate the stateids associated with the layout only if special
   stateids are not being used for I/O at the storage devices, otherwise
   the layout itself must be invalidated.

   This means that a metadata server may not restripe a file until it
   has contacted all of the storage devices to invalidate the layouts
   from the previous instance nor may it give out locks that conflict
   with locks embodied by the stateids associated with any layout from
   the previous instance without either doing a specific invalidation
   (as it would have to do anyway) or doing a global storage device
   invalidation.



Welch, et al.           Expires January 16, 2006               [Page 34]

Internet-Draft               pNFS Operations                   July 2005


5.7  Security Considerations

   The NFSv4 file layout type MUST adhere to the security considerations
   outlined in Section 4.  More specifically, storage devices must make
   all of the required access checks on each READ or WRITE I/O as
   determined by the NFSv4 protocol [2].  This impacts the management
   protocol and the propagation of state from the metadata server to the
   storage devices; see Section 5.4 for more details.

5.8  Alternate Approaches

   Two alternate approaches exist for file-based layouts and the method
   used by clients to obtain stateids used for I/O. Both approaches
   embed stateids within the layout.

   However, before examining these approaches it is important to
   understand the distinction between clients and owners.  Delegations
   belong to clients, while locks (record and share reservations) are
   held by owners (who in turn belong to a specific client).  As such,
   delegations can only protect against inter-client conflicts, not
   intra-client conflicts.  Layouts are held by clients and SHOULD NOT
   be associated with state held by owners.  Therefore, if stateids used
   for data access are embedded within a layout, these stateids can only
   act as delegation stateids, protecting against inter-client
   conflicts; stateids pertaining to an owner can not be embedded within
   the layout.  This has the implication that the client MUST arbitrate
   among all intra-client conflicts (such as arbitrating among lock
   requests by different processes) before issuing pNFS operations.
   Using the stateids stored within the layout, storage devices can only
   arbitrate between clients (not owners).

   The first alternate approach is to do away with global stateids
   (stateids returned by OPEN/LOCK that are valid on the metadata server
   and storage devices) and use only stateids embedded within the
   layout.  This approach has the drawback that the stateids used for
   I/O access can not be validated against per owner state (rather they
   are validated against per client state), since they are only
   associated with the client holding the layout.  It breaks the
   semantics of tieing a stateid used for I/O to an open instance.  This
   has the implication that clients must delegate per owner lock and
   open requests internally, rather than push the work onto the storage
   devices.  The storage devices can still arbitrate and enforce inter-
   client lock and open state.

   The second approach is a hybrid approach.  This approach allows for
   stateids to be embedded with the layout, but also allows for the
   possibility of global stateids.  If the stateid embedded within the
   layout is a special stateid of all zeros, then the stateid referring



Welch, et al.           Expires January 16, 2006               [Page 35]

Internet-Draft               pNFS Operations                   July 2005


   to the last successful OPEN/LOCK should be used (as a global stateid
   presented earlier in the proposal).  This approach is recommended if
   it is decided that using NFSv4 as a management protocol is required.

   This proposal suggests the global stateid approach due to the cleaner
   semantics it provides regarding the relationship between stateids
   used for I/O and their corresponding open instance (or lock state).
   However, it does have a profound impact on the management protocol's
   implementation and the state propagation that is required (as
   described in Section 5.4).

6.  pNFS Typed Data Structures

6.1  pnfs_layouttype4

     enum pnfs_layouttype4 {
            LAYOUT_NFSV4_FILES = 1
     };

   A layout type specifies the layout being used.  The implication is
   that clients have "layout drivers" that support one or more layout
   types.  The file server advertises the layout types it supports
   through the LAYOUT_TYPES file system attribute.  A client asks for
   layouts of a particular type in LAYOUTGET, and passes those layouts
   to its layout driver.  The set of well known layout types must be
   defined.  As well, a private range of layout types should exist and
   also be well defined.  This would allow custom installations to
   introduce new layout types.

   [OPEN ISSUE: It must be decided whether IANA should control the
   namespace of layout types, or whether each new layout type must go
   through the specification process (probably as a minor version
   extension)]

   The LAYOUT_NFSV4_FILES enumeration specifies that the NFSv4 file
   layout type is to be used.

6.2  pnfs_deviceid4

     typedef uint32_t pnfs_deviceid4;       /* 32-bit device ID */

   Layout information includes device IDs that specify a storage device
   through a compact handle.  Addressing and type information is
   obtained with the GETDEVICEINFO operation.  A client must not assume
   that device IDs are valid across metadata server reboots.  The device
   ID is qualified by the layout type.  This allows different layout
   drivers to generate device IDs without the need for co-ordination.
   See Section 3.1.1 for more details.



Welch, et al.           Expires January 16, 2006               [Page 36]

Internet-Draft               pNFS Operations                   July 2005


6.3  pnfs_devaddr4

     union pnfs_devaddr4 switch (pnfs_layouttype4 layout_type) {
            case LAYOUT_NFSV4_FILES:
                   string           r_netid<>;   /* network ID */
                   string           r_addr<>;    /* universal address */
            default:
                   opaque           devaddr<>;   /* For other layouts */
     };

   The device address is used to set up a communication channel with the
   storage device.  Different layout types will require different types
   of structures to define how they communicate with storage devices.
   The union is switched on the layout type.  Currently, the only device
   address defined is that for the NFSv4 file layout, which identifies a
   storage device by network IP address and port number.  This is
   sufficient for the clients to communicate with the NFSv4 storage
   devices, and may also be sufficient for object-based storage drivers
   to communicate with OSDs.

6.4  pnfs_devlist_item4

     struct pnfs_devlist_item4 {
            pnfs_deviceid4          id;
            pnfs_deviceaddr4        addr;
     };

   An array of these values is returned by the GETDEVICELIST operation.
   They define the set of devices associated with a file system.

6.5  pnfs_layout4

     union pnfs_layouttypes4 switch (pnfs_layouttype4 layout_type) {
            case LAYOUT_NFSV4_FILES:
                   pnfs_nfsv4_layouttype4 file_layout;
            default:
                   opaque           layout_data<>;
     };

     struct pnfs_layout4 {
            offset4                 offset;
            length4                 length;
            pnfs_layoutiomode4      iomode;
            pnfs_layouttypes4       layout;
     };

   The pnfs_layout4 structure defines a layout for a file.  The
   pnfs_layouttypes4 union contains the portion of the layout specific



Welch, et al.           Expires January 16, 2006               [Page 37]

Internet-Draft               pNFS Operations                   July 2005


   to the layout type.  Currently, only the NFSv4 file layout type is
   defined; see Section 5.1 for its definition.  Since layouts are sub-
   dividable, the offset and length (together with the file's
   filehandle, the clientid, iomode, and layout type), identifies the
   layout.

   [OPEN ISSUE: it has been suggested that the layout type include a
   generic striping layer, as defined in Section 5.1.  This has not yet
   been done.]

6.6  pnfs_layoutupdate4

     union pnfs_layoutupdate4 switch (pnfs_layouttype4 layout_type) {
            case LAYOUT_NFSV4_FILES:
                   void;
            default:
                   opaque           layout_data<>;
     };

   The pnfs_layoutupdate4 structure is used by the client to return
   'updated' layout information to the metadata server at LAYOUTCOMMIT
   time.  This provides a channel to pass layout type specific
   information back to the metadata server.  E.g., for block layout
   types this could include the list of reserved blocks that were
   written.  The contents of the structure are determined by the layout
   type and are defined in their context.

6.7  pnfs_layoutiomode4

     enum pnfs_layoutiomode4 {
             LAYOUTIOMODE_READ          = 1,
             LAYOUTIOMODE_RW            = 2,
             LAYOUTIOMODE_ANY           = 3,
     };

   The iomode specifies whether the client intends to read or write
   (with the possibility of reading) the data represented by the layout.
   The ANY iomode MUST NOT be used for LAYOUTGET, however, it can be
   used for LAYOUTRETURN and LAYOUTRECALL.  The ANY iomode specifies
   that layouts pertaining to both READ and RW are being returned or
   recalled, respectively.  The metadata server's use of the iomode may
   depend on the layout type being used.  The storage devices may
   validate I/O accesses against the iomode (and reject invalid
   accesses).

7.  pNFS File Attributes





Welch, et al.           Expires January 16, 2006               [Page 38]

Internet-Draft               pNFS Operations                   July 2005


7.1  pnfs_layouttype4<> FS_LAYOUT_TYPES

   This attribute applies to a file system and indicates what layout
   types are supported by the file system.  We expect this attribute to
   be queried when a client encounters a new fsid.  This attribute is
   used by the client to determine if it has applicable layout drivers.

7.2  pnfs_layouttype4<> FILE_LAYOUT_TYPE

   This attribute indicates the particular layout type(s) used for a
   file.  This is for informational purposes only.  The client needs to
   use the LAYOUTGET operation in order to get enough information (e.g.,
   specific device information) in order to perform I/O.

7.3  pnfs_layouttypes4 FILE_LAYOUT_HINT

   This attribute may be set on newly created files to influence the
   metadata server's choice for the file's layout.  It is suggested that
   this attribute is set as one of the initial attributes within the
   OPEN call.  The metadata server may ignore this attribute.  This
   attribute is a sub-set of the layout returned by LAYOUTGET.  For
   example, instead of specifying particular devices, this would be used
   to suggest the stripe width of a file.  It is up to the server
   implementation to determine which fields within the layout it uses.

7.4  uint32_t FS_LAYOUT_PREFERRED_BLOCKSIZE

   This attribute is a file system wide attribute and indicates the
   preferred block size for direct storage device access.

7.5  uint32_t FS_LAYOUT_PREFERRED_ALIGNMENT

   This attribute is a file system wide attribute and indicates the
   preferred alignment for direct storage device access.

8.  pNFS Error Definitions

   NFS4ERR_BADLAYOUT Layout specified is invalid.

   NFS4ERR_BADIOMODE Layout iomode is invalid.

   NFS4ERR_LAYOUTUNAVAILABLE Layouts are not available for the file or
      its containing file system.

   NFS4ERR_LAYOUTTRYLATER Layouts are temporarily unavailable for the
      file, client should retry later.





Welch, et al.           Expires January 16, 2006               [Page 39]

Internet-Draft               pNFS Operations                   July 2005


   NFS4ERR_UNKNOWN_LAYOUTTYPE Layout type is unknown.


9.  pNFS Operations

9.1  LAYOUTGET - Get Layout Information

   SYNOPSIS

     (cfh), clientid, layout_type, iomode, offset, length,
     maxcount -> layout


   ARGUMENT

     struct LAYOUTGET4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             pnfs_layouttype4        layout_type;
             pnfs_layoutiomode4      iomode;
             offset4                 offset;
             length4                 length;
             count4                  maxcount;
     };

   RESULT

     struct LAYOUTGET4resok {
             pnfs_layout4            layout;
     };

     union LAYOUTGET4res switch (nfsstat4 status) {
             case NFS4_OK:
                     LAYOUTGET4resok resok4;
             default:
                     void;
     };

   DESCRIPTION

   Requests a layout for reading or writing the file given by the
   filehandle at the byte range specified by offset and length.  Layouts
   are identified through the clientid, filehandle, byte range (offset,
   length pair), and iomode.  The use of the iomode depends upon the
   layout type, but should reflect the client's data access intent.

   The LAYOUTGET operation returns layout information for the specified
   byte range.  To get a layout from a specific offset through the end-



Welch, et al.           Expires January 16, 2006               [Page 40]

Internet-Draft               pNFS Operations                   July 2005


   of-file (no matter how long the file actually is) use a length field
   with all bits set to 1 (one).  If the length is zero, or if a length
   which is not all bits set to one is specified, and length when added
   to the offset exceeds the maximum 64-bit unsigned integer value, the
   error NFS4ERR_INVAL will result.  The "maxcount" field specifies the
   maximum layout size (in bytes) that the client can handle.  If the
   layout exceeds the size specified by maxcount, the metadata server
   will return the NFS4ERR_TOOSMALL error.

   As well, the metadata server may adjust the range of the returned
   layout based on striping patterns and usage implied by the iomode.
   The client must be prepared to get a layout that does not line up
   exactly with their request; there MUST be at least one byte of
   overlap between the layout returned by the server and the client's
   request, or the server SHOULD reject the request.  See Section 3.3
   for more details.

   The metadata server may also return a layout with an iomode other
   than that requested by the client.  If it does so, it must ensure
   that the iomode is more permissive than the iomode requested.  E.g.,
   this allows an implementation to upgrade read-only requests to read/
   write requests at its discretion (within the limits of the layout
   type specific protocol).  An iomode of either LAYOUTIOMODE_READ or
   LAYOUTIOMODE_RW must be returned.

   The format of the returned layout is specific to the underlying file
   system.  Layout types other than the NFSv4 file layout type should be
   specified outside of this document.

   If layouts are not supported for the requested file or its containing
   file system the server SHOULD return NFS4ERR_LAYOUTUNAVAILABLE.  If
   the layout type is not supported, the metadata server should return
   NFS4ERR_UNKNOWN_LAYOUTTYPE.  If layouts are supported but no layout
   matches the client provided layout identification, the server should
   return NFS4ERR_BADLAYOUT.  If an invalid iomode is specified, or an
   iomode of LAYOUTIOMODE_ANY is specified, the server should return
   NFS4ERR_BADIOMODE.

   If the layout for the file is unavailable due to transient
   conditions, e.g. file sharing prohibits layouts, the server should
   return NFS4ERR_LAYOUTTRYLATER.

   If the layout conflicts with a mandatory byte range lock held on the
   file, and if the storage devices have no method of enforcing
   mandatory locks, other than through the restriction of layouts, the
   metadata server should return NFS4ERR_LOCKED.

   On success, the current filehandle retains its value.



Welch, et al.           Expires January 16, 2006               [Page 41]

Internet-Draft               pNFS Operations                   July 2005


   IMPLEMENTATION

   Typically, LAYOUTGET will be called as part of a compound RPC after
   an OPEN operation and results in the client having location
   information for the file; a client may also hold a layout across
   multiple OPENs.  The client specifies a layout type that limits what
   kind of layout the server will return.  This prevents servers from
   issuing layouts that are unusable by the client.

   [Comment: The notion of the layout class indicating a sub-set of
   possible layout types is gone.  Now that the class is a flat number
   space, there is no official way to reference a "class" of layouts
   (e.g., files, blocks, or objects).  This means that the type in the
   LAYOUTGET may be too restrictive, or that it is up to the server to
   decide if it can give out a "closely associated" layout that the
   client may be able to use.]

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_LAYOUTUNAVAILABLE
      NFS4ERR_LAYOUTTRYLATER
      NFS4ERR_LOCKED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTSUPP
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_TOOSMALL
      NFS4ERR_UNKNOWN_LAYOUTTYPE


9.2  LAYOUTCOMMIT - Commit writes made using a layout
















Welch, et al.           Expires January 16, 2006               [Page 42]

Internet-Draft               pNFS Operations                   July 2005


   SYNOPSIS

     (cfh), clientid, offset, length, lastbytewritten,
     time_modify, time_access, layoutupdate -> newsize


   ARGUMENT

     union newtime4 switch (bool timechanged) {
             case TRUE:
                     nfstime4           time;
             case FALSE:
                     void;
     };

     union newsize4 switch (bool sizechanged) {
             case TRUE:
                     length4            size;
             case FALSE:
                     void;
     };

     struct LAYOUTCOMMIT4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             offset4                 offset;
             length4                 length;
             length4                 lastbytewritten;
             newtime4                time_modify;
             newtime4                time_access;
             pnfs_layoutupdate4      layoutupdate;
     };

   RESULT

     struct LAYOUTCOMMIT4resok {
            newsize4                 newsize;
     };

     union LAYOUTCOMMIT4res switch (nfsstat4 status) {
             case NFS4_OK:
                     LAYOUTCOMMIT4resok  resok4;
             default:
                     void;
     };

   DESCRIPTION




Welch, et al.           Expires January 16, 2006               [Page 43]

Internet-Draft               pNFS Operations                   July 2005


   Commits changes in the layout portion represented by the current
   filehandle, clientid, and byte range.  Since layouts are sub-
   dividable, a smaller portion of a layout, retrieved via LAYOUTGET,
   may be committed.  The region being committed is specified through
   the byte range (length and offset).  Note: the "layoutupdate"
   structure does not include the length and offset, as they are already
   specified in the arguments.

   The LAYOUTCOMMIT operation indicates that the client has completed
   writes using a layout obtained by a previous LAYOUTGET.  The client
   may have only written a subset of the data range it previously
   requested.  LAYOUTCOMMIT allows it to commit or discard provisionally
   allocated space and to update the server with a new end of file.  The
   layout referenced by LAYOUTCOMMIT is still valid after the operation
   completes and can be continued to be referenced by the clientid,
   filehandle, byte range, and layout type.

   The "lastbytewritten" field specifies the offset of the last byte
   written by the client previous to the LAYOUTCOMMIT.  Note: this value
   is never equal to the file's size (at most it is 1 byte less than the
   file's size).  The metadata server may use this information to
   determine whether the file's size needs to be updated.  If the
   metadata server updates the file's size as the result of the
   LAYOUTCOMMIT operation, it must return the new size as part of the
   results.

   The "time_modify" and "time_access" fields allow the client to
   suggest times it would like the metadata server to set.  The metadata
   server may use these time values or it may use the time of the
   LAYOUTCOMMIT operation to set these time values.  If the metadata
   server uses the client provided times, it should sanity check the
   values (e.g., to ensure time does not flow backwards).  If the client
   wants to force the metadata server to set an exact time, the client
   should use a SETATTR operation in a compound right after
   LAYOUTCOMMIT.  See Section 3.5 for more details.

   The "layoutupdate" argument to LAYOUTCOMMIT provides a mechanism for
   a client to provide layout specific updates to the metadata server.
   For example, the layout update can describe what regions of the
   original layout have been used and what regions can be deallocated.
   There is no NFSv4 file layout specific layoutupdate structure.

   The layout information is more verbose for block devices than for
   objects and files because the latter hide the details of block
   allocation behind their storage protocols.  At the minimum, the
   client needs to communicate changes to the end of file location back
   to the server, and its view of the file modify and access times
   (unless it wants the server to set those times to the time of



Welch, et al.           Expires January 16, 2006               [Page 44]

Internet-Draft               pNFS Operations                   July 2005


   LAYOUTCOMMIT).  For blocks, it needs to specify precisely which
   blocks have been used.

   If the layout identified in the arguments does not exist, the error
   NFS4ERR_BADLAYOUT is returned.  The layout being committed may also
   be rejected if it does not correspond to an existing layout with an
   iomode of RW.

   On success, the current filehandle retains its value.

   [OPEN ISSUE: is it good enough to allow the metadata server to update
   the change attribute, or should the client be able to direct the
   metadata server to update it.]

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_UNKNOWN_LAYOUTTYPE



























Welch, et al.           Expires January 16, 2006               [Page 45]

Internet-Draft               pNFS Operations                   July 2005


9.3  LAYOUTRETURN - Release Layout Information

   SYNOPSIS

     (cfh), clientid, offset, length, iomode, layout_type -> -

   ARGUMENT

     struct LAYOUTRETURN4args {
             /* CURRENT_FH: file */
             clientid4               clientid;
             offset4                 offset;
             length4                 length;
             pnfs_layoutiomode4      iomode;
             pnfs_layouttype4        layout_type;
     };

   RESULT

     struct LAYOUTRETURN4res {
             nfsstat4        status;
     };

   DESCRIPTION

   Returns the layout represented by the current filehandle, clientid,
   byte range, iomode, and layout type.  After this call, the client
   MUST NOT use the layout and the associated storage protocol to access
   the file data.  The layout being returned may be a subdivision of a
   layout previously fetched through LAYOUTGET.  If the length is all
   1s, the layout covers the range from offset to EOF.  An iomode of ANY
   specifies that all layouts that match the other arguments to
   LAYOUTRETURN (i.e., clientid, byte range, and type) are being
   returned.

   Layouts may be returned when recalled or voluntarily (i.e., before
   the server has recalled them).  In either case the client must
   properly propagate state changed under the context of the layout to
   storage or to the server before returning the layout.

   If a client fails to return a layout in a timely manner, then the
   metadata server should use its management protocol with the storage
   devices to fence the client from accessing the data referenced by the
   layout.  See Section 3.4 for more details.

   If the layout identified in the arguments does not exist, the error
   NFS4ERR_BADLAYOUT is returned.  If a layout exists, but the iomode
   does not match, NFS4ERR_BADIOMODE is returned.



Welch, et al.           Expires January 16, 2006               [Page 46]

Internet-Draft               pNFS Operations                   July 2005


   On success, the current filehandle retains its value.

   [OPEN ISSUE: Should LAYOUTRETURN be modified to handle FSID
   callbacks?]

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_UNKNOWN_LAYOUTTYPE


9.4  GETDEVICEINFO - Get Device Information

   SYNOPSIS

     (cfh), device_id, layout_type, maxcount -> device_addr

   ARGUMENT

     struct GETDEVICEINFO4args {
             /* CURRENT_FH: file */
             pnfs_deviceid4                  device_id;
             pnfs_layouttype4                layout_type;
             count4                          maxcount;
     };

   RESULT

     struct GETDEVICEINFO4resok {
             pnfs_devaddr4                   device_addr;
     };

     union GETDEVICEINFO4res switch (nfsstat4 status) {
             case NFS4_OK:
                     GETDEVICEINFO4resok     resok4;
             default:
                     void;
     };

   DESCRIPTION

   Returns device type and device address information for a specified



Welch, et al.           Expires January 16, 2006               [Page 47]

Internet-Draft               pNFS Operations                   July 2005


   device.  The returned device_addr includes a type that indicates how
   to interpret the addressing information for that device.  The current
   filehandle (cfh) is used to identify the file system; device IDs are
   unique per file system (FSID) and are qualified by the layout type.

   At this time we expect two main kinds of device addresses, either IP
   address and port numbers, or SCSI volume identifiers.  The final
   protocol specification will detail the allowed values for device_type
   and the format of their associated location information.

   See Section 3.1.1 for more details on device ID assignment.

   If the size of the device address exceeds maxcount bytes, the
   metadata server will return the error NFS4ERR_TOOSMALL.  If an
   invalid device ID is given, the metadata server will respond with
   NFS4ERR_INVAL.

   ERRORS

      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_TOOSMALL
      NFS4ERR_UNKNOWN_LAYOUTTYPE




























Welch, et al.           Expires January 16, 2006               [Page 48]

Internet-Draft               pNFS Operations                   July 2005


9.5   GETDEVICELIST - Get List of Devices

   SYNOPSIS

     (cfh), layout_type, maxcount, cookie, cookie_verf ->
     device_addrs<>

   ARGUMENT

     struct GETDEVICELIST4args {
             /* CURRENT_FH: file */
             pnfs_layouttype4                layout_type;
             count4                          maxcount;
             nfs_cookie4                     cookie;
             verifier4                       cookieverf;
     };

   RESULT

     struct GETDEVICELIST4resok {
             pnfs_devlist_item4              device_addrs<>;
     };

     union GETDEVICEINFO4res switch (nfsstat4 status) {
             case NFS4_OK:
                     GETDEVICEINFO4resok     resok4;
             default:
                     void;
     };

   DESCRIPTION

   In some applications, especially SAN environments, it is convenient
   to find out about all the devices associated with a file system.
   This lets a client determine if it has access to these devices, e.g.,
   at mount time.

   This operation returns a list of items that establish the association
   between the short pnfs_deviceid4 and the addressing information for
   that device, for a particular layout type.  This operation may not be
   able to fetch all device information at once, thus it uses a cookie
   based approach, similar to READDIR, to fetch additional device
   information.  As in GETDEVICEINFO, the current filehandle (cfh) is
   used to identify the file system.

   If the metadata server is unable to return a single device address,
   it will return the error NFS4ERR_TOOSMALL.  If an invalid device ID
   is given, the metadata server will respond with NFS4ERR_INVAL.



Welch, et al.           Expires January 16, 2006               [Page 49]

Internet-Draft               pNFS Operations                   July 2005


   ERRORS

      NFS4ERR_BAD_COOKIE
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_TOOSMALL
      NFS4ERR_UNKNOWN_LAYOUTTYPE


10.  Callback Operations

10.1  CB_LAYOUTRECALL

   SYNOPSIS

     layout_type, iomode, layoutrecall -> -

   ARGUMENT

     enum layoutrecall_type4 {
             RECALL_FILE = 1,
             RECALL_FSID = 2
     };

     union layoutrecall4 switch(layoutrecall_type4 recalltype) {
             case RECALL_FILE:
                     nfs_fh4         fh;
                     offset4         offset;
                     length4         length;
             case RECALL_FSID:
                     fsid4           fsid;
     };

     struct CB_LAYOUTRECALLargs {
             pnfs_layouttype4        layout_type;
             pnfs_layoutiomode4      iomode;
             layoutrecall4           layoutrecall;
     };

   RESULT

     struct CB_LAYOUTRECALLres {
             nfsstat4        status;
     };

   DESCRIPTION

   The CB_LAYOUTRECALL operation is used to begin the process of



Welch, et al.           Expires January 16, 2006               [Page 50]

Internet-Draft               pNFS Operations                   July 2005


   recalling a layout, a portion thereof, or all layouts pertaining to a
   particular file system (FSID).  If RECALL_FILE is specified, the
   offset and length fields specify the portion of the layout to be
   returned.  The iomode specifies the set of layouts to be returned.
   An iomode of ANY specifies that all matching layouts, regardless of
   iomode, must be returned; otherwise, only layouts that exactly match
   the iomode must be returned.

   If RECALL_FSID is specified, the fsid specifies the file system for
   which any outstanding layouts must be returned.  Layouts are returned
   through the LAYOUTRETURN operation.

   If RECALL_FILE is specified and the layout byte range specified does
   not correspond to a valid layout for the file specified by the
   filehandle, an NFS4ERR_BADLAYOUT is returned.  If the byte range
   overlaps with a layout being held, the portion of the layout
   represented by the overlap MUST be returned.  If a length of all 1s
   is specified then the layout corresponding to the byte range from
   "offset" to the end-of-file MUST be returned.

   If the layout specified is not held by the client, an
   NFS4ERR_BADLAYOUT error is returned.  If the layout type is unknown
   to the client, then an NFS4ERR_UNKNOWN_LAYOUTTYPE is returned.  If a
   layout exists, but the iomode does not match, then an
   NFS4ERR_BADIOMODE is returned.

   IMPLEMENTATION

   The client should reply to the callback immediately.  Replying does
   not complete the recall except when an error is returned.  The recall
   is not complete until the layout(s) are returned using a
   LAYOUTRETURN.

   The client should complete any in-flight I/O operations using the
   recalled layout(s) before returning it/them via LAYOUTRETURN.  If the
   client has buffered dirty data, it may chose to write it directly to
   storage before calling LAYOUTRETURN, or to write it later using
   normal NFSv4 WRITE operations to the metadata server.  If a large
   amount of dirty data is outstanding, the client may issue
   LAYOUTRETURNs for portions of the layout being recalled; this allows
   the server to monitor the client's progress and adherence to the
   callback.

   ERRORS

      NFS4ERR_BADLAYOUT
      NFS4ERR_BADIOMODE
      NFS4ERR_UNKNOWN_LAYOUTTYPE



Welch, et al.           Expires January 16, 2006               [Page 51]

Internet-Draft               pNFS Operations                   July 2005


   [OPEN ISSUE: Should we add a callback type for returning some
   percentage of the layouts held by a client (something in between all
   and one)?]

10.2  CB_SIZECHANGED

   SYNOPSIS

     fh, size -> -

   ARGUMENT

     struct CB_SIZECHANGEDargs {
             nfs_fh4         fh;
             length4         size;
     };

   RESULT

     struct CB_SIZECHANGEDres {
             nfsstat4        status;
     };

   DESCRIPTION

   The CB_SIZECHANGED operation is used to notify the client that the
   size pertaining to the filehandle associated with "fh", has changed.
   The new size is specified.  Upon reception of this notification
   callback, the client should update its internal size for the file.
   If the layout being held for the file is of the NFSv4 file layout
   type, then the size field within that layout should be updated (see
   Section 5.5.1).  For other layout types see Section 3.5.2 for more
   details.

   If the handle specified is not one for which the client holds a
   layout, an NFS4ERR_BADHANDLE error is returned.

   ERRORS

      NFS4ERR_BADHANDLE


11.  Usage Scenarios

   This section has a description of common open, close, read, write
   interactions and how those work with layout delegations.  [TODO: this
   section feels rough and I'm not sure it adds value in its present
   form.]



Welch, et al.           Expires January 16, 2006               [Page 52]

Internet-Draft               pNFS Operations                   July 2005


11.1  Basic Read Scenario

   Client does an OPEN to get a file handle.  Client does a LAYOUTGET
   for a range of the file, gets back a layout.  Client uses the storage
   protocol and the layout to access the file.  Client returns the
   layout with LAYOUTRETURN.  Client closes stateID and open delegation
   with CLOSE.

   This is rather boring as the client is careful to clean up all server
   state after only a single use of the file.

11.2  Multiple Reads to a File

   Client does an OPEN to get a file handle.  Client does a LAYOUTGET
   for a range of the file, gets back a layout.  Client uses the storage
   protocol and the layout to access the file.  Client closes stateID
   and with CLOSE.

   Client does an OPEN to get a file handle.  Client finds cached layout
   associated with file handle.  Client uses the storage protocol and
   the layout to access the file.  Client closes stateID and with CLOSE.

   A bit more interesting as we've saved the LAYOUTGET operation, but we
   are still doing server round-trips.

11.3  Multiple Reads to a File with Delegations

   Client does an OPEN to get a file handle and an open delegation.
   Client does a LAYOUTGET for a range of the file, gets back a layout.
   Client uses the storage protocol and the layout to access the file.
   Application does a close(), but client keeps state under the
   delegation. (time passes) Application does another open(), which
   client handles under the delegation.  Client finds cached layout
   associated with file handle.  Client uses the storage protocol and
   the layout to access the file. (pattern continues until open
   delegation and/or layout is recalled)

   This illustrates the efficiency of combining open delegations and
   layouts to eliminate interactions with the file server altogether.
   Of course, we assume the client's operating system is only allowing
   the local open() to succeed based on the file permissions.  The use
   of layouts does not change anything about the semantics of open
   delegations.

11.4  Read with existing writers

   NOTE: This scenario was under some debate, but we have resolved that
   the server is able to give out overlapping/conflicting layout



Welch, et al.           Expires January 16, 2006               [Page 53]

Internet-Draft               pNFS Operations                   July 2005


   information to different clients.  In these cases we assume that
   clients are using an external mechanism such as MPI-IO to synchronize
   and serialize access to shared data.  One can argue that even
   unsynchronized clients get the same open-to-close consistency
   semantics as NFS already provides, even when going direct to storage.

   Client does an OPEN to get an open stateID and open delegation.  The
   file is open for writing elsewhere by different clients and so no
   open delegation is returned.  Client does a LAYOUT get and gets a
   layout from the server.  Client either synchronizes with the writers,
   or not, and accesses data via the layout and storage protocol.  There
   are no guarantees about when data that is written by the writer is
   visible to the reader.  Once the writer has closed the file and
   flushed updates to storage, then they are visible to the client.

   [We should state explicitly that COMMIT and LAYOUTCOMMIT represent
   explicit points where changes should be visible to other clients.]

11.5  Read with later conflict

   ClientA does an OPEN to get an open stateID and open delegation.
   ClientA does a LAYOUTGET for a range of the file, gets back a map and
   layout stateid.  ClientA uses the storage protocol to access the file
   data.  ClientB opens the file for WRITE.  File server issues
   CB_RECALL to ClientA.  ClientA issues DELEGRETURN.

   ClientA continues to use the storage protocol to access file data.
   If it is accessing data from its cache, it will periodically check
   that its data is still up-to-date because it has no open delegation.
   [This is an odd scenario that mixes in open delegations for no real
   value.  Basically this is a "regular writer" being mixed with a pNFS
   reader.  I guess this example shows that no particular semantics are
   provided during the simultaneous access.  If the server so chose, it
   could also recall the layout with CB_LAYOUTRECALL to force the
   different clients to serialize at the file server.]

11.6  Basic Write Case

   Client does an OPEN to get a file handle.  Client does a LAYOUTGET
   for a range of the file, gets back a layout and layout stateid.
   Client writes to the file using the storage protocol.  Client uses
   LAYOUTCOMMIT to communicate new EOF position.  Client does SETATTR to
   update timestamps.  Client does a LAYOUTRETURN.  Client does a CLOSE.

   Again, the boring case where the client cleans up all of its server
   state by returning the layout.





Welch, et al.           Expires January 16, 2006               [Page 54]

Internet-Draft               pNFS Operations                   July 2005


11.7  Large Write Case

   Client does an OPEN to get a file handle. (loop.)  Client does a
   LAYOUTGET for a range of the file, gets back a layout and layout
   stateid.  Client writes to the file using the storage protocol.
   Client fills up the range covered by the layout.  Client updates the
   server with LAYOUTCOMMIT, communicating about new EOF position.
   Client does SETATTR to update timestamps.  Client releases the layout
   with LAYOUTRELEASE. (end loop.)  Client does a CLOSE.

11.8  Create with special layout

   Client does an OPEN and a SETATTR that specifies a particular layout
   type using the LAYOUT_HINT attribute.  Client gets back an open
   stateID and file handle. (etc)

12.  Layouts and Aggregation

   This section describes several layout formats in a semi-formal way to
   provide context for the layout delegations.  These definitions will
   be formalized in other protocols.  However, the set of understood
   types is part of this protocol in order to provide for basic
   interoperability.

   The layout descriptions include (deviceID, objectID) tuples that
   identify some storage object on some storage device.  The addressing
   formation associated with the deviceID is obtained with
   GETDEVICEINFO.  The interpretation of the objectID depends on the
   storage protocol.  The objectID could be a filehandle for an NFSv4
   storage device.  It could be a OSD object ID for an object server.
   The layout for a block device generally includes additional block map
   information to enumerate blocks or extents that are part of the
   layout.

12.1  Simple Map

   The data is located on a single storage device.  In this case the
   file server can act as the front end for several storage devices and
   distribute files among them.  Each file is limited in its size and
   performance characteristics by a single storage device.  The simple
   map consists of (deviceID, objectID).

12.2  Block Map

   The data is located on a LUN in the SAN.  The layout consists of an
   array of (deviceID, blockID, blocksize) tuples.  Alternatively, the
   blocksize could be specified once to apply to all entries in the
   layout.



Welch, et al.           Expires January 16, 2006               [Page 55]

Internet-Draft               pNFS Operations                   July 2005


12.3  Striped Map (RAID 0)

   The data is striped across storage devices.  The parameters of the
   stripe include the number of storage devices (N) and the size of each
   stripe unit (U).  A full stripe of data is N * U bytes.  The stripe
   map consists of an ordered list of (deviceID, objectID) tuples and
   the parameter value for U. The first stripe unit (the first U bytes)
   are stored on the first (deviceID, objectID), the second stripe unit
   on the second (deviceID, objectID) and so forth until the first
   complete stripe.  The data layout then wraps around so that byte
   (N*U) of the file is stored on the first (deviceID, objectID) in the
   list, but starting at offset U within that object.  The striped
   layout allows a client to read or write to the component objects in
   parallel to achieve high bandwidth.

   The striped map for a block device would be slightly different.  The
   map is an ordered list of (deviceID, blockID, blocksize), where the
   deviceID is rotated among a set of devices to achieve striping.

12.4  Replicated Map

   The file data is replicated on N storage devices.  The map consists
   of N (deviceID, objectID) tuples.  When data is written using this
   map, it should be written to N objects in parallel.  When data is
   read, any component object can be used.

   This map type is controversial because it highlights the issues with
   error recovery.  Those issues get interesting with any scheme that
   employs redundancy.  The handling of errors (e.g., only a subset of
   replicas get updated) is outside the scope of this protocol
   extension.  Instead, it is a function of the storage protocol and the
   metadata management protocol.

12.5  Concatenated Map

   The map consists of an ordered set of N (deviceID, objectID, size)
   tuples.  Each successive tuple describes the next segment of the
   file.

12.6  Nested Map

   The nested map is used to compose more complex maps out of simpler
   ones.  The map format is an ordered set of M sub-maps, each submap
   applies to a byte range within the file and has its own type such as
   the ones introduced above.  Any level of nesting is allowed in order
   to build up complex aggregation schemes.





Welch, et al.           Expires January 16, 2006               [Page 56]

Internet-Draft               pNFS Operations                   July 2005


13.  Issues

13.1  Storage Protocol Negotiation

   Clients may want to negotiate with the metadata server about their
   preferred storage protocol, and to find out what storage protocols
   the server offers.  Client can do this by querying the LAYOUT_TYPES
   file system attribute.  They respond by specifying a particular
   layout type in their LAYOUTGET operation.

13.2  Storage Errors

   There may be a need for the client to communicate about errors it has
   when accessing storage directly.  The client may do so in a layout
   type dependent way through the layoutupdate field in LAYOUTCOMMIT.

14.  Normative References

   [1]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", March 1997.

   [2]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame,
        C., Eisler, M., and D. Noveck, "Network File System (NFS)
        version 4 Protocol", RFC 3530, April 2003.

   [3]  Weber, R., "Object-Based Storage Device Commands (OSD)",
        INCITS 400-2004, July 2004,
        <http://www.t10.org/ftp/t10/drafts/osd/osd-r10.pdf>.

   [4]  Gibson, G., "pNFS Problem Statement", July 2004, <ftp://
        www.ietf.org/internet-drafts/
        draft-gibson-pnfs-problem-statement-01.txt>.


Authors' Addresses

   Brent Welch
   Panasas, Inc.
   6520 Kaiser Drive
   Fremont, CA  95444
   USA

   Phone: +1-650-608-7770
   Email: welch@panasas.com
   URI:   http://www.panasas.com/






Welch, et al.           Expires January 16, 2006               [Page 57]

Internet-Draft               pNFS Operations                   July 2005


   Benny Halevy
   Panasas, Inc.
   1501 Reedsdale St., #400
   Pittsburgh, PA  15233
   USA

   Phone: +1-412-323-3500
   Email: bhalevy@panasas.com
   URI:   http://www.panasas.com/


   Garth Goodson
   Network Appliance
   495 E. Java Dr
   Sunnyvale, CA  94089
   USA

   Phone: +1-408-822-6847
   Email: goodson@netapp.com


   David L. Black
   EMC Corporation
   176 South Street
   Hopkinton, MA  01748
   USA

   Phone: +1-508-293-7953
   Email: black_david@emc.com


   Andy Adamson
   CITI University of Michigan
   519 W. William
   Ann Arbor, MI  48103-4943
   USA

   Phone: +1-734-764-9465
   Email: andros@umich.edu

Appendix A.  Acknowledgments

   Many members of the pNFS informal working group have helped
   considerably.  The authors would like to thank Gary Grider, Peter
   Corbett, Dave Noveck, and Peter Honeyman.  This work is inspired by
   the NASD and OSD work done by Garth Gibson.  Gary Grider of the
   national labs (LANL) has been a champion of high-performance parallel
   I/O.



Welch, et al.           Expires January 16, 2006               [Page 58]

Internet-Draft               pNFS Operations                   July 2005


Intellectual Property Statement

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Copyright Statement

   Copyright (C) The Internet Society (2005).  This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Acknowledgment

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




Welch, et al.           Expires January 16, 2006               [Page 59]

