<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>IPv6 UDP Checksum Considerations</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Document Structure">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Background">
<link href="#rfc.section.1.2.1" rel="Chapter" title="1.2.1 The Role of a Transport Endpoint">
<link href="#rfc.section.1.2.2" rel="Chapter" title="1.2.2 The UDP Checksum">
<link href="#rfc.section.1.2.3" rel="Chapter" title="1.2.3 Differences between IPv6 and IPv4">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Use of UDP Tunnels ">
<link href="#rfc.section.1.3.1" rel="Chapter" title="1.3.1 Motivation for new approaches">
<link href="#rfc.section.1.3.2" rel="Chapter" title="1.3.2 Reducing forwarding cost">
<link href="#rfc.section.1.3.3" rel="Chapter" title="1.3.3 Need to inspect the entire packet">
<link href="#rfc.section.1.3.4" rel="Chapter" title="1.3.4 Interactions with middleboxes">
<link href="#rfc.section.1.3.5" rel="Chapter" title="1.3.5 Support for load balancing">
<link href="#rfc.section.2" rel="Chapter" title="2 Standards-Track Transports">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 UDP with Standard Checksum">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 UDP-Lite">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Using UDP-Lite as a Tunnel Encapsulation">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 General Tunnel Encapsulations">
<link href="#rfc.section.3" rel="Chapter" title="3 Issues Requiring Consideration">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Effect of packet modification in the network">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Corruption of the destination IP address">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Corruption of the source IP address">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Corruption of Port Information">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 Delivery to an unexpected port">
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 Corruption of Fragmentation Information">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Validating the network path">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Applicability of method">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Impact on non-supporting devices or applications">
<link href="#rfc.section.4" rel="Chapter" title="4 Evaluation of proposal to update RFC 2460 to support zero checksum">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Alternatives to the Standard Checksum">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Comparison">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Middlebox Traversal">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Load Balancing">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 Ingress and Egress Performance Implications">
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 Deployability">
<link href="#rfc.section.4.2.5" rel="Chapter" title="4.2.5 Corruption Detection Strength">
<link href="#rfc.section.4.2.6" rel="Chapter" title="4.2.6 Comparison Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Requirements on the specification of transported protocols">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Constraints required on usage of a zero checksum">
<link href="#rfc.section.6" rel="Chapter" title="6 Summary">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Document Change History">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This document examines the role of the UDP transport checksum when used with IPv6, as defined in RFC2460. It presents a summary of the trade-offs for evaluating the safety of updating RFC 2460 to permit an IPv6 UDP endpoint to use a zero value in the checksum field as an indication that no checksum is present. This method is compared with some other possibilities. The document also describes the issues and design principles that need to be considered when UDP is used with IPv6 to support tunnel encapsulations. It concludes that UDP with a zero checksum in IPv6 can safely be used for this purpose, provided that this usage is governed by a set of constraints." />
  <meta name="description" content="This document examines the role of the UDP transport checksum when used with IPv6, as defined in RFC2460. It presents a summary of the trade-offs for evaluating the safety of updating RFC 2460 to permit an IPv6 UDP endpoint to use a zero value in the checksum field as an indication that no checksum is present. This method is compared with some other possibilities. The document also describes the issues and design principles that need to be considered when UDP is used with IPv6 to support tunnel encapsulations. It concludes that UDP with a zero checksum in IPv6 can safely be used for this purpose, provided that this usage is governed by a set of constraints." />
  <meta name="keywords" content="template" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">M. Westerlund</td>
</tr>
<tr>
<td class="left">Expires: October 23, 2011</td>
<td class="right">Ericsson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">April 21, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">IPv6 UDP Checksum Considerations<br />
  <span class="filename">draft-ietf-6man-udpzero-03</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document examines the role of the UDP transport checksum when used with IPv6, as defined in RFC2460. It presents a summary of the trade-offs for evaluating the safety of updating RFC 2460 to permit an IPv6 UDP endpoint to use a zero value in the checksum field as an indication that no checksum is present. This method is compared with some other possibilities. The document also describes the issues and design principles that need to be considered when UDP is used with IPv6 to support tunnel encapsulations. It concludes that UDP with a zero checksum in IPv6 can safely be used for this purpose, provided that this usage is governed by a set of constraints.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 23, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Document Structure</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Background</a>
</li>
<li>1.2.1.   <a href="#rfc.section.1.2.1">The Role of a Transport Endpoint</a>
</li>
<li>1.2.2.   <a href="#rfc.section.1.2.2">The UDP Checksum</a>
</li>
<li>1.2.3.   <a href="#rfc.section.1.2.3">Differences between IPv6 and IPv4</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Use of UDP Tunnels </a>
</li>
<li>1.3.1.   <a href="#rfc.section.1.3.1">Motivation for new approaches</a>
</li>
<li>1.3.2.   <a href="#rfc.section.1.3.2">Reducing forwarding cost</a>
</li>
<li>1.3.3.   <a href="#rfc.section.1.3.3">Need to inspect the entire packet</a>
</li>
<li>1.3.4.   <a href="#rfc.section.1.3.4">Interactions with middleboxes</a>
</li>
<li>1.3.5.   <a href="#rfc.section.1.3.5">Support for load balancing</a>
</li>
<li>2.   <a href="#rfc.section.2">Standards-Track Transports</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">UDP with Standard Checksum</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">UDP-Lite</a>
</li>
<li>2.2.1.   <a href="#rfc.section.2.2.1">Using UDP-Lite as a Tunnel Encapsulation</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">General Tunnel Encapsulations</a>
</li>
<li>3.   <a href="#rfc.section.3">Issues Requiring Consideration</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Effect of packet modification in the network</a>
</li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">Corruption of the destination IP address</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Corruption of the source IP address</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Corruption of Port Information</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">Delivery to an unexpected port</a>
</li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">Corruption of Fragmentation Information</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Validating the network path</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Applicability of method</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Impact on non-supporting devices or applications</a>
</li>
<li>4.   <a href="#rfc.section.4">Evaluation of proposal to update RFC 2460 to support zero checksum</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Alternatives to the Standard Checksum</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Comparison</a>
</li>
<li>4.2.1.   <a href="#rfc.section.4.2.1">Middlebox Traversal</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Load Balancing</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">Ingress and Egress Performance Implications</a>
</li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">Deployability</a>
</li>
<li>4.2.5.   <a href="#rfc.section.4.2.5">Corruption Detection Strength</a>
</li>
<li>4.2.6.   <a href="#rfc.section.4.2.6">Comparison Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Requirements on the specification of transported protocols</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Constraints required on usage of a zero checksum</a>
</li>
<li>6.   <a href="#rfc.section.6">Summary</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Document Change History</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#sec-intro" id="sec-intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The <a href="#RFC0768">User Datagram Protocol (UDP)</a> <cite title="NONE">[RFC0768]</cite> transport is defined for <a href="#RFC0791">the Internet Protocol (IPv4)</a> <cite title="NONE">[RFC0791]</cite> and is defined in <a href="#RFC2460">Internet Protocol, Version 6 (IPv6)</a> <cite title="NONE">[RFC2460]</cite> for IPv6 hosts and routers. The UDP transport protocol has a minimal set of features. This limited set has enabled a wide range of applications to use UDP, but these application do need to provide many important transport functions on top of UDP. The <a href="#RFC5405">UDP Usage Guidelines</a> <cite title="NONE">[RFC5405]</cite> provides overall guidance for application designers, including the use of UDP to support tunneling. The key difference between UDP usage with IPv4 and IPv6 is that IPv6 mandates use of the UDP checksum, i.e. a non-zero value, due to the lack of an IPv6 header checksum.</p>
<p id="rfc.section.1.p.2">The lack of a possibility to use UDP with a zero-checksum in IPv6 has been observed as a real problem for certain classes of application, primarily tunnel applications. This class of application has been deployed with a zero checksum using IPv4. The design of IPv6 raises different issues when considering the safety of using a zero checksum for UDP with IPv6. These issues can significantly affect applications, both when an endpoint is the intended user and when an innocent bystander (received by a different endpoint to that intended). The document examines these issues and compares the strengths and weaknesses of a number of proposed solutions. This analysis presents a set of issues that must be considered and mitigated to be able to safely deploy UDP with a zero checksum over IPv6. The provided comparison of methods is expected to also be useful when considering applications that have different goals from the ones that initiated the writing of this document, especially the use of already standardized methods.</p>
<p id="rfc.section.1.p.3">The analysis concludes that using UDP with a zero checksum is the best method of the proposed alternatives to meet the goals for certain tunnel applications. Unfortunately, this usage is expected to have some deployment issues related to middleboxes, limiting the usability more than desired in the currently deployed internet. However, this limitation will be largest initially and will reduce as updates for support of UDP zero checksum for IPv6 are provided to middleboxes. The document therefore derives a set of constraints required to ensure safe deployment of zero checksum in UDP. It also identifies some issues that require future consideration and possibly additional research.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Document Structure</h1>
<p><a href="#sec-intro">Section 1</a> provides a background to key issues, and introduces the use of UDP as a tunnel transport protocol.</p>
<p><a href="#sec-standards">Section 2</a> describes a set of standards-track datagram transport protocols that may be used to support tunnels.</p>
<p><a href="#Issues">Section 3</a> discusses issues with a zero checksum in UDP for IPv6. It considers the impact of corruption, the need for validation of the path and when it is suitable to use a zero checksum.</p>
<p><a href="#Proposal">Section 4</a> evaluates a set of proposals to update the UDP transport behaviour and other alternatives intended to improve support for tunnel protocols. It focuses on a proposal to allow a zero checksum for this use-case with IPv6 and assess the trade-offs that would arise.</p>
<p><a href="#sec-constraints">Section 5.1</a> lists the constraints perceived for safe deployment of zero-checksum.</p>
<p><a href="#sec-summary">Section 6</a> provides the recommendations for standardization of zero-checksum with a summary of the findings and notes remaining issues needing future work.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Background</h1>
<p id="rfc.section.1.2.p.1">This section provides a background on topics relevant to the following discussion.</p>
<h1 id="rfc.section.1.2.1">
<a href="#rfc.section.1.2.1">1.2.1.</a> The Role of a Transport Endpoint</h1>
<p id="rfc.section.1.2.1.p.1">An Internet transport endpoint should concern itself with the following issues:</p>
<p></p>

<ul>
<li>Protection of the endpoint transport state from unnecessary extra state (e.g. Invalid state from rogue packets).</li>
<li>Protection of the endpoint transport state from corruption of internal state.</li>
<li>Pre-filtering by the endpoint of erroneous data, to protect the transport from unnecessary processing and from corruption that it can not itself reject.</li>
<li>Pre-filtering of incorrectly addressed destination packets, before responding to a source address.</li>
</ul>
<p></p>
<h1 id="rfc.section.1.2.2">
<a href="#rfc.section.1.2.2">1.2.2.</a> The UDP Checksum</h1>
<p id="rfc.section.1.2.2.p.1">UDP, as defined in <a href="#RFC0768">[RFC0768]</a>, supports two checksum behaviours when used with IPv4. The normal behaviour is for the sender to calculate a checksum over a block of data that includes a pseudo header and the UDP datagram payload. The UDP header includes a 16-bit one's complement checksum that provides a statistical guarantee that the payload was not corrupted in transit.  This also allows a receiver to verify that the endpoint was the intended destination of the datagram, because the transport pseudo header covers the IP addresses, port numbers, transport payload length, and Next Header/Protocol value corresponding to the UDP transport protocol <a href="#RFC1071">[RFC1071]</a>. The length field verifies that the datagram is not truncated or padded. The checksum therefore protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent.  Although the IPv4 <a href="#RFC0768">UDP</a> <cite title="NONE">[RFC0768]</cite> checksum may be disabled, applications are recommended to enable UDP checksums <a href="#RFC5405">[RFC5405]</a>.</p>
<p id="rfc.section.1.2.2.p.2">The network-layer fields that are validated by a transport checksum are:</p>
<p></p>

<ul>
<li>Endpoint IP source address (always included in the pseudo header of the checksum)</li>
<li>Endpoint IP destination address (always included in the pseudo header of the checksum)</li>
<li>Upper layer payload type (always included in the pseudo header of the checksum)</li>
<li>IP length of payload (always included in the pseudo header of the checksum)</li>
<li>Length of the network layer extension headers (i.e. by correct position of the checksum bytes)</li>
</ul>
<p id="rfc.section.1.2.2.p.4">The transport-layer fields that are validated by a transport checksum are:</p>

<ul>
<li>Transport demultiplexing, i.e. ports (always included in the checksum)</li>
<li>Transport payload size (always included in the checksum)</li>
</ul>
<p id="rfc.section.1.2.2.p.5">Transport endpoints also need to verify the correctness of reassembly of any fragmented datagram. For UDP, this is normally provided as a part of the integrity check. Disabling the IPv4 checksum prevents this check. A lack of the UDP header and checksum in fragments can lead to issues in a translator or middlebox. For example, many IPv4 Network Address Translators, NATs, rely on port numbers to find the mappings, packet fragments do not carry port numbers, so fragments get dropped. <a href="#RFC2765">RFC2765</a> <cite title="NONE">[RFC2765]</cite> provides some guidance on the processing of fragmented IPv4 UDP datagrams that do not carry a UDP checksum.</p>
<p id="rfc.section.1.2.2.p.6">IPv4 UDP checksum control is often a kernel-wide configuration control (e.g. In Linux and BSD), rather than a per socket call.  There are also Networking Interface Cards (NICs) that automatically calculate <a href="#RFC0793">TCP </a> <cite title="NONE">[RFC0793]</cite> and UDP checksums on transmission when a checksum of zero is sent to the NIC, using a method known as checksum offloading.</p>
<h1 id="rfc.section.1.2.3">
<a href="#rfc.section.1.2.3">1.2.3.</a> Differences between IPv6 and IPv4</h1>
<p id="rfc.section.1.2.3.p.1">IPv6 does not provide a network-layer integrity check. The removal of the header checksum from the IPv6 specification released routers from a need to update a network-layer checksum for each router hop as the IPv6 Hop Count is changed (in contrast to the checksum update needed when an IPv4 router modifies the Time-To-Live (TTL)).</p>
<p id="rfc.section.1.2.3.p.2">The IP header checksum calculation was seen as redundant for most traffic (with UDP or TCP checksums enabled), and people wanted to avoid this extra processing. However, there was concern that the removal of the IP header checksum in IPv6 combined with a UDP checksum set to zero would lessen the protection of the source/destination IP addresses and result in a significant (a multiplier of ~32,000) increase in the number of times that a UDP packet was accidentally delivered to the wrong destination address and/or apparently sourced from the wrong source address. This would have had implications on the detectability of mis-delivery of a packet to an incorrect endpoint/socket, and the robustness of the Internet infrastructure. The use of the UDP checksum is therefore required <a href="#RFC2460">[RFC2460]</a> when endpoint applications transmit UDP datagrams over IPv6.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Use of UDP Tunnels </h1>
<p id="rfc.section.1.3.p.1">One increasingly popular use of UDP is as a tunneling protocol, where a tunnel endpoint encapsulates the packets of another protocol inside UDP datagrams and transmits them to another tunnel endpoint.  Using UDP as a tunneling protocol is attractive when the payload protocol is not supported by the middleboxes that may exist along the path, because many middleboxes support transmission using UDP. In this use, the receiving endpoint decapsulates the UDP datagrams and forwards the original packets contained in the payload <a href="#RFC5405">[RFC5405]</a>. Tunnels establish virtual links that appear to directly connect locations that are distant in the physical Internet topology and can be used to create virtual (private) networks.</p>
<h1 id="rfc.section.1.3.1">
<a href="#rfc.section.1.3.1">1.3.1.</a> Motivation for new approaches</h1>
<p id="rfc.section.1.3.1.p.1">A number of tunnel encapsulations deployed over IPv4 have used the UDP transport with a zero checksum. Users of these protocols expect a similar solution for IPv6.</p>
<p id="rfc.section.1.3.1.p.2">A number of tunnel protocols are also currently being defined (e.g. Automated Multicast Tunnels, <a href="#AMT">AMT</a> <cite title="NONE">[AMT]</cite>, and the Locator/Identifier Separation Protocol, <a href="#LISP">LISP</a> <cite title="NONE">[LISP]</cite>). These protocols have proposed an update to IPv6 UDP checksum processing. These tunnel protocols could benefit from simpler checksum processing for various reasons:</p>

<ul>
<li>Reducing forwarding costs, motivated by redundancy present in the encapsulated packet header, since in tunnel encapsulations, payload integrity and length verification may be provided by higher layer encapsulations (often using the IPv4, UDP, UDP-Lite, or TCP checksums).</li>
<li>Eliminating a need to access the entire packet when forwarding the packet by a tunnel endpoint.</li>
<li>Enhancing ability to traverse middleboxes, especially Network Address Translators, NATs.</li>
<li>A desire to use the port number space to enable load-sharing.</li>
</ul>
<h1 id="rfc.section.1.3.2">
<a href="#rfc.section.1.3.2">1.3.2.</a> Reducing forwarding cost</h1>
<p id="rfc.section.1.3.2.p.1">It is a common requirement to terminate a large number of tunnels on a single router/host. Processing per tunnel concerns both state (memory requirements) and per-packet processing costs.</p>
<p id="rfc.section.1.3.2.p.2">Automatic IP Multicast Without Explicit Tunnels, known as <a href="#AMT">AMT</a> <cite title="NONE">[AMT]</cite> currently specifies UDP as the transport protocol for packets carrying tunneled IP multicast packets. The current specification for AMT requires that the UDP checksum in the outer packet header should be 0 (see <a href="#AMT">Section 6.6 of</a> <cite title="NONE">[AMT]</cite>). It argues that the computation of an additional checksum, when an inner packet is already adequately protected, is an unwarranted burden on nodes implementing lightweight tunneling protocols. The AMT protocol needs to replicate a multicast packet to each gateway tunnel. In this case, the outer IP addresses are different for each tunnel and therefore require a different pseudo header to be built for each UDP replicated encapsulation.</p>
<p id="rfc.section.1.3.2.p.3">The argument concerning redundant processing costs is valid regarding the integrity of a tunneled packet. In some architectures (e.g. PC-based routers), other mechanisms may also significantly reduce checksum processing costs: There are implementations that have optimised checksum processing algorithms, including the use of checksum-offloading. This processing is readily available for IPv4 packets at high line rates. Such processing may be anticipated for IPv6 endpoints, allowing receivers to reject corrupted packets without further processing. However, there are certain classes of tunnel end-points where this off-loading is not available and unlikely to become available in the near future.</p>
<h1 id="rfc.section.1.3.3">
<a href="#rfc.section.1.3.3">1.3.3.</a> Need to inspect the entire packet</h1>
<p id="rfc.section.1.3.3.p.1">The currently-deployed hardware in many routers uses a fast-path processing that only provides the first n bytes of a packet to the forwarding engine, where typically n &lt;= 128. This prevents fast processing of a transport checksum over an entire (large) packet.  Hence the currently defined IPv6 UDP checksum is poorly suited to use within a router that is unable to access the entire packet and does not provide checksum-offloading. Thus enabling checksum calculation over the complete packet can impact router design, performance improvement, energy consumption and/or cost.</p>
<h1 id="rfc.section.1.3.4">
<a href="#rfc.section.1.3.4">1.3.4.</a> Interactions with middleboxes</h1>
<p id="rfc.section.1.3.4.p.1">In IPv4, UDP-encapsulation may be desirable for NAT traversal, since UDP support is commonly provided. It is also necessary due to the almost ubiquitous deployment of IPv4 NATs. There has also been discussion of NAT for IPv6, although not for the same reason as in IPv4. If IPv6 NAT becomes a reality they hopefully do not present the same protocol issues as for IPv4. If NAT is defined for IPv6, it should take UDP zero checksum into consideration.</p>
<p id="rfc.section.1.3.4.p.2">The requirements for IPv6 firewall traversal are likely be to be similar to those for IPv4. In addition, it can be reasonably expected that a firewall conforming to RFC 2460 will not regard UDP datagrams with a zero checksum as valid packets. If an zero-checksum for UDP were to be allowed for IPv6, this would need firewalls to be updated before full utility of the change is available.</p>
<p id="rfc.section.1.3.4.p.3">It can be expected that UDP with zero-checksum will initially not have the same middlebox traversal characteristics as regular UDP.  However, if standardized we can expect an improvement over time of the traversal capabilities. We also note that deployment of IPv6-capable middleboxes is still in its initial phases. Thus, it might be that the number of non-updated boxes quickly become a very small percentage of the deployed middleboxes.</p>
<h1 id="rfc.section.1.3.5">
<a href="#rfc.section.1.3.5">1.3.5.</a> Support for load balancing</h1>
<p id="rfc.section.1.3.5.p.1">The UDP port number fields have been used as a basis to design load-balancing solutions for IPv4. This approach has also been leveraged for IPv6. An alternate method would be to utilise the IPv6 Flow Label as basis for entropy for the load balancing. This would have the desirable effect of releasing IPv6 load-balancing devices from the need to assume semantics for the use of the transport port field and also works for all type of transport protocols. This use of the flow-label is consistent with the intended use, although further clarity may be needed to ensure the field can be consistently used for this purpose, (e.g. Equal-Cost Multi-Path routing, ECMP <a href="#ECMP">[ECMP]</a>).</p>
<p id="rfc.section.1.3.5.p.2">Router vendors could be encouraged to start using the IPv6 Flow Label as a part of the flow hash, providing support for ECMP without requiring use of UDP. However, the method for populating the outer IPv6 header with a value for the flow label is not trivial: If the inner packet uses IPv6, then the flow label value could be copied to the outer packet header. However, many current end-points set the flow label to a zero value (thus no entropy). The ingress of a tunnel seeking to provide good entropy in the flow label field would therefore need to create a random flow label value and keep corresponding state, so that all packets that were associated with a flow would be consistently given the same flow label. Although possible, this complexity may not be desirable in a tunnel ingress.</p>
<p id="rfc.section.1.3.5.p.3">The end-to-end use of flow labels for load balancing is a long-term solution. Even if the usage of the flow label is clarified, there would be a transition time before a significant proportion of end-points start to assign a good quality flow label to the flows that they originate, with continued use of load balancing using the transport header fields until any widespread deployment is finally achieved.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#sec-standards" id="sec-standards">Standards-Track Transports</a>
</h1>
<p id="rfc.section.2.p.1">The IETF has defined a set of transport protocols that may be applicable for tunnels with IPv6. There are also a set of network layer encapsulation tunnels such as IP-in-IP and GRE. These already standardized solutions are discussed here prior to the issues, as background for the issue description and some comparison of where the issue may already occur.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> UDP with Standard Checksum</h1>
<p><a href="#RFC0768">UDP</a> <cite title="NONE">[RFC0768]</cite> with standard checksum behaviour is defined in RFC 2460 has already been discussed. UDP usage guidelines are provided in <a href="#RFC5405">[RFC5405]</a>.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> UDP-Lite</h1>
<p id="rfc.section.2.2.p.1">UDP-Lite <a href="#RFC3828">[RFC3828]</a> offers an alternate transport to UDP, specified as a proposed standard, RFC 3828. A MIB is defined in RFC 5097 and unicast usage guidelines in <a href="#RFC5405">[RFC5405]</a>. There is at least one open source implementation as a part of the Linux kernel since version 2.6.20.</p>
<p id="rfc.section.2.2.p.2">UDP-Lite provides a checksum with optional partial coverage. When using this option, a datagram is divided into a sensitive part (covered by the checksum) and an insensitive part (not covered by the checksum). When the checksum covers the entire packet, UDP-Lite is fully equivalent with UDP. Errors/corruption in the insensitive part will not cause the datagram to be discarded by the transport layer at the receiving endpoint. A minor side-effect of using UDP-Lite is that this was specified for damage-tolerant payloads, and some link-layers may employ different link encapsulations when forwarding UDP-Lite segments (e.g. radio access bearers). Most link-layers will cover the insensitive part with the same strong layer 2 frame CRC that covers the sensitive part.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> Using UDP-Lite as a Tunnel Encapsulation</h1>
<p id="rfc.section.2.2.1.p.1">Tunnel encapsulations can use UDP-Lite (e.g. Control And Provisioning of Wireless Access Points, CAPWAP <a href="#RFC5415">[RFC5415]</a>), since UDP-Lite provides a transport-layer checksum, including an IP pseudo header checksum, in IPv6, without the need for a router/middelbox to traverse the entire packet payload. This provides most of the delivery verifications and still keep the complexity of the checksumming operation low. UDP-Lite may set the length of checksum coverage on a per packet basis. This feature could be used if a tunnel protocol is designed to only verify delivery of the tunneled payload and uses full checksumming for control information.</p>
<p id="rfc.section.2.2.1.p.2">There is currently poor support for middlebox traversal using UDP-Lite, because UDP-Lite uses a different IPv6 network-layer Next Header value to that of UDP, and few middleboxes are able to interpret UDP-Lite and take appropriate actions when forwarding the packet. This makes UDP-Lite less suited to protocols needing general Internet support, until such time that UDP-Lite has achieved better support in middleboxes and end-points.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> General Tunnel Encapsulations</h1>
<p id="rfc.section.2.3.p.1">The IETF has defined a set of tunneling protocols or network layer encapsulations, like IP-in-IP and GRE. These either do not include a checksum or use a checksum that is optional, since tunnel encapsulations are typically layered directly over the Internet layer (identified by the upper layer type in the IPv6 Next Header field) and are also not used as endpoint transport protocols. There is little chance of confusing a tunnel-encapsulated packet with other application data that could result in corruption of application state or data.</p>
<p id="rfc.section.2.3.p.2">From the end-to-end perspective, the principal difference is that the network-layer Next Header field identifies a separate transport, which reduces the probability that corruption could result in the packet being delivered to the wrong endpoint or application.  Specifically, packets are only delivered to protocol modules that process a specific next header value. The next header field therefore provides a first-level check of correct demultiplexing. In contrast, the UDP port space is shared by many diverse applications and therefore UDP demultiplexing relies solely on the port numbers.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#Issues" id="Issues">Issues Requiring Consideration</a>
</h1>
<p id="rfc.section.3.p.1">This section evaluates issues around the proposal to update IPv6 [RFC2460], to provide the option of using a UDP transport checksum set to zero. Some of the identified issues are shared with other protocols already in use.</p>
<p id="rfc.section.3.p.2">The decision by IPv6 to omit an integrity check at the network level has meant that the transport check was overloaded with many functions, including validating: </p>

<ul>
<li>the endpoint address was not corrupted within a router - i.e. A packet was intended to be received by this destination and a wrong header has not been spliced to a different payload;</li>
<li>that extension header processing is correctly delimited - i.e.  The start of data has not been corrupted. In this case, reception of a valid next header value provides some protection;</li>
<li>reassembly processing, when used;</li>
<li>the length of the payload;</li>
<li>the port values - i.e. The correct application receives the payload (applications should also check the expected use of source ports/addresses);</li>
<li>the payload integrity.</li>
</ul>
<p id="rfc.section.3.p.3">In IPv4, the first four checks are performed using the IPv4 header checksum.</p>
<p id="rfc.section.3.p.4">In IPv6, these checks occur within the endpoint stack using the UDP checksum information. An IPv6 node also relies on the header information to determine whether to send an ICMPv6 error message <a href="#RFC4443">[RFC4443]</a> and to determine the node to which this is sent. Corrupted information may lead to misdelivery to an unintended application socket on an unexpected host.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Effect of packet modification in the network</h1>
<p id="rfc.section.3.1.p.1">IP packets may be corrupted as they traverse an Internet path.  Evidence has been presented <a href="#Sigcomm2000">[Sigcomm2000]</a> to show that this was once an issue with IPv4 routers, and occasional corruption could result from bad internal router processing in routers or hosts. These errors are not detected by the strong frame checksums employed at the link-layer <a href="#RFC3819">[RFC3819]</a>. There is no current evidence that such cases are rare in the modern Internet, nor that they may not be applicable to IPv6. It therefore seems prudent not to relax this constraint. The emergence of low-end IPv6 routers and the proposed use of NAT with IPv6 further motivate the need to protect from this type of error.</p>
<p id="rfc.section.3.1.p.2">Corruption in the network may result in: </p>

<ul>
<li>A datagram being mis-delivered to the wrong host/router or the wrong transport entity within an endpoint. Such a datagram needs to be discarded;</li>
<li>A datagram payload being corrupted, but still delivered to the intended host/router transport entity. Such a datagram needs to be either discarded or correctly processed by an application that provides its own integrity checks;</li>
<li>A datagram payload being truncated by corruption of the length field. Such a datagram needs to be discarded.</li>
</ul>
<p id="rfc.section.3.1.p.3">When a checksum is used, this significantly reduces the impact of errors, reducing the probability of undetected corruption of state (and data) on both the host stack and the applications using the transport service.</p>
<p id="rfc.section.3.1.p.4">The following sections examine the impact of modifying each of these header fields.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> Corruption of the destination IP address</h1>
<p id="rfc.section.3.1.1.p.1">An IP endpoint destination address could be modified in the network (e.g. corrupted by an error). This is not a concern for IPv4, because the IP header checksum will result in this packet being discarded by the receiving IP stack. Such modification in the network can not be detected at the network layer when using IPv6.</p>
<p id="rfc.section.3.1.1.p.2">There are two possible outcomes:</p>
<p></p>

<ul>
<li>Delivery to a destination address that is not in use (the packet will not be delivered, but could result in an error report);</li>
<li>Delivery to a different destination address. This modification will normally be detected by the transport checksum, resulting in silent discard. Without this checksum, the packet would be passed to the endpoint port demultiplexing function. If an application is bound to the associated ports, the packet payload will be passed to the application (see the subsequent section on port processing).</li>
</ul>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> Corruption of the source IP address</h1>
<p id="rfc.section.3.1.2.p.1">This section examines what happens when the source address is corrupted in transit. This is not a concern in IPv4, because the IP header checksum will normally result in this packet being discarded by the receiving IP stack.</p>
<p id="rfc.section.3.1.2.p.2">Corruption of an IPv6 source address does not result in the IP packet being delivered to a different endpoint protocol or destination address. If only the source address is corrupted, the datagram will likely be processed in the intended context, although with erroneous origin information. The result will depend on the application or protocol that processes the packet. Some examples are:</p>
<p></p>

<ul>
<li>An application that requires a per-established context may disregard the datagram as invalid, or could map this to another context (if a context for the modified source address was already activated).</li>
<li>A stateless application will process the datagram outside of any context, a simple example is the ECHO server, which will respond with a datagram directed to the modified source address.  This would create unwanted additional processing load, and generate traffic to the modified endpoint address.</li>
<li>Some datagram applications build state using the information from packet headers. A previously unused source address would result in receiver processing and the creation of unnecessary transport-layer state at the receiver. For example, Real Time Protocol (RTP) <a href="#RFC3550">[RFC3550]</a> sessions commonly employ a source independent receiver port. State is created for each received flow. Reception of a datagram with a corrupted source address will therefore result in accumulation of unnecessary state in the RTP state machine, including collision detection and response (since the same synchronization source, SSRC, value will appear to arrive from multiple source IP addresses).</li>
</ul>
<p id="rfc.section.3.1.2.p.4">In general, the effect of corrupting the source address will depend upon the protocol that processes the packet and its robustness to this error. For the case where the packet is received by a tunnel endpoint, the tunnel application is expected to correctly handle a corrupted source address.</p>
<p id="rfc.section.3.1.2.p.5">The impact of source address modification is more difficult to quantify when the receiving application is not that originally intended and several fields have been modified in transit.</p>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> Corruption of Port Information</h1>
<p id="rfc.section.3.1.3.p.1">This section describes what happens if one or both of the UDP port values are corrupted in transit. This can also happen with IPv4 in the zero checksum case, but not when UDP checksums are enabled or with UDP-Lite. If the ports carried in the transport header of an IPv6 packet were corrupted in transit, packets may be delivered to the wrong process (on the intended machine) and/or responses or errors sent to the wrong application process (on the intended machine).</p>
<h1 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> Delivery to an unexpected port</h1>
<p id="rfc.section.3.1.4.p.1">If one combines the corruption effects, such as destination address and ports, there is a number of potential outcomes when traffic arrives at an unexpected port. This section discusses these possibilities and their outcomes for a packet that does not use the UDP checksum validation:</p>
<p></p>

<ul>
<li>Delivery to a port that is not in use. The packet is discarded, but could generate an ICMPv6 message (e.g. port unreachable).</li>
<li>It could be delivered to a different node that implements the same application, where the packet may be accepted, generating side-effects or accumulated state.</li>
<li>It could be delivered to an application that does not implement the tunnel protocol, where the packet may be incorrectly parsed, and may be misinterpreted, generating side-effects or accumulated state.</li>
</ul>
<p id="rfc.section.3.1.4.p.3">The probability of each outcome depends on the statistical probability that the address or the port information for the source or destination becomes corrupt in the datagram such that they match those of an existing flow or server port. Unfortunately, such a match may be more likely for UDP than for connection-oriented transports, because:</p>

<ol>
<li>There is no handshake prior to communication and no sequence numbers (as in TCP, DCCP, or SCTP). Together, this makes it hard to verify that an application is given only the data associated with a transport session.</li>
<li>Applications writers often bind to wild-card values in endpoint identifiers and do not always validate correctness of datagrams they receive (guidance on this topic is provided in <a href="#RFC5405">[RFC5405]</a>).</li>
</ol>

<p>While these rules could, in principle, be revised to declare naive applications as "Historic". This remedy is not realistic: the transport owes it to the stack to do its best to reject bogus datagrams.</p>
<p id="rfc.section.3.1.4.p.4">If checksum coverage is suppressed, the application therefore needs to provide a method to detect and discard the unwanted data. A tunnel protocol would need to perform its own integrity checks on any control information if transported in UDP with zero-checksum. If the tunnel payload is another IP packet, the packets requiring checksums can be assumed to have their own checksums provided that the rate of corrupted packets is not significantly larger due to the tunnel encapsulation. If a tunnel transports other inner payloads that do not use IP, the assumptions of corruption detection for that particular protocol must be fulfilled, this may require an additional checksum/CRC and/or integrity protection of the payload and tunnel headers.</p>
<p id="rfc.section.3.1.4.p.5">A protocol using UDP zero-checksum can never assume that it is the only protocol using a zero checksum. Therefore, it needs to gracefully handle misdelivery. It must be robust to reception of malformed packets received on a listening port and expect that these packets may contain corrupted data or data associated with a completely different protocol.</p>
<h1 id="rfc.section.3.1.5">
<a href="#rfc.section.3.1.5">3.1.5.</a> Corruption of Fragmentation Information</h1>
<p id="rfc.section.3.1.5.p.1">The fragmentation information in IPv6 employs a 32-bit identity field, compared to only a 16-bit filed in IPv4, a 13-bit fragment offset and a 1-bit flag, indicating if there are more fragments.  Corruption of any of these field may result in one of two outcomes:</p>
<p></p>

<dl>
<dt>Reassembly failure: </dt>
<dd style="margin-left: 8">An error in the "More Fragments" field for the last fragment will for example result in the packet never being considered complete and will eventually be timed out and discarded. A corruption in the ID field will result in the fragment not being delivered to the intended context thus leaving the rest incomplete, unless that packet has been duplicated prior to corruption. The incomplete packet will eventually be timed out and discarded.</dd>
<dt>Erroneous reassembly:</dt>
<dd style="margin-left: 8">The re-assemblied packet did not match the original packet. This can occur when the ID field of a fragment is corrupted, resulting in a fragment becoming associated with another packet and taking the place of another fragment. Corruption in the offset information can cause the fragment to be misaligned in the reassembly buffer, resulting in incorrect reassembly. Corruption can cause the packet to become shorter or longer, however completion of reassembly is much less probable, since this would requires consistent corruption of the IPv6 headers payload length field and the offset field. The possibility of mis-assembly requires the reassembling stack to provide strong checks that detect overlap or missing data, note however that this is not guaranteed and has recently been clarified in <a href="#RFC5722">"Handling of Overlapping IPv6 Fragments"</a> <cite title="NONE">[RFC5722]</cite>.</dd>
</dl>

<p>The erroneous reassembly of packets is a general concern and such packets should be discarded instead of being passed to higher layer processes. The primary detector of packet length changes is the IP payload length field, with a secondary check by the transport checksum. The Upper-Layer Packet length field included in the pseudo header assists in verifying correct reassembly, since the Internet checksum has a low probability of detecting insertion of data or overlap errors (due to misplacement of data). The checksum is also incapable of detecting insertion or removal of all zero-data that occurs in a multiple of a 16-bit chunk.</p>
<p id="rfc.section.3.1.5.p.3">The most significant risk of corruption results following mis-association of a fragment with a different packet. This risk can be significant, since the size of fragments is often the same (e.g.  fragments resulting when the path MTU results in fragmentation of a larger packet, common when addition of a tunnel encapsulation header expands the size of a packet). Detection of this type of error requires a checksum or other integrity check of the headers and the payload. Such protection is anyway desirable for tunnel encapsulations using IPv4, since the small fragmentation ID can easily result in wrap-around <a href="#RFC4963">[RFC4963]</a>, this is especially the case for tunnels that perform flow aggregation <a href="#I-D.ietf-intarea-tunnels">[I-D.ietf-intarea-tunnels]</a>.</p>
<p id="rfc.section.3.1.5.p.4">Tunnel fragmentation behavior matters. There can be outer or inner fragmentation <a href="#I-D.ietf-intarea-tunnels">"Tunnels in the Internet Architecture"</a> <cite title="NONE">[I-D.ietf-intarea-tunnels]</cite>. If there is inner fragmentation by the tunnel, the outer headers will never be fragmented and thus a zero-checksum in the outer header will not affect the reassembly process. When a tunnel performs outer header fragmentation, the tunnel egress needs to perform reassembly of the outer fragments into an inner packet. The inner packet is either a complete packet or a fragment. If it is a fragment, the destination endpoint of the fragment will perform reassembly of the received fragments. The complete packet or the reassembled fragments will then be processed according to the packet next header field. The receiver may only detect reassembly anomalies when it uses a protocol with a checksum. The larger the number of reassembly processes to which a packet has been subjected, the greater the probability of an error.</p>
<p></p>

<ul>
<li>An IP-in-IP tunnel that performs inner fragmentation has similar properties to a UDP tunnel with a zero-checksum that also performs inner fragmentation.</li>
<li>An IP-in-IP tunnel that performs outer fragmentation has similar properties to a UDP tunnel with a zero checksum that performs outer fragmentation.</li>
<li>A tunnel that performs outer fragmentation can result in a higher level of corruption due to both inner and outer fragmentation, enabling more chances for reassembly errors to occur.</li>
<li>Recursive tunneling can result in fragmentation at more than one header level, even for inner fragmentation unless it goes to the inner most IP header.</li>
<li>Unless there is verification at each reassembly the probability for undetected error will increase with the number of times fragmentation is recursively applied. Making IP-in-IP and UDP with zero checksum equal subject to this effect.</li>
</ul>
<p id="rfc.section.3.1.5.p.6">In conclusion fragmentation of packets with a zero-checksum does not worsen the situation compared to some other commonly used tunnel encapsulations. However, caution is needed for recursive tunneling without any additional verification at the different tunnel layers.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> Validating the network path</h1>
<p id="rfc.section.3.2.p.1">IP transports designed for use in the general Internet should not assume specific path characteristics. Network protocols may reroute packets that change the set of routers and middleboxes along a path.  Therefore transports such as TCP, SCTP and DCCP have been designed to negotiate protocol parameters, adapt to different network path characteristics, and receive feedback to verify that the current path is suited to the intended application. Applications using UDP and UDP-Lite need to provide their own mechanisms to confirm the validity of the current network path.</p>
<p id="rfc.section.3.2.p.2">The zero-checksum in UDP is explicitly disallowed in RFC2460. Thus it may be expected that any device on the path that has a reason to look beyond the IP header will consider such a packet as erroneous or illegal and may likely discard it, unless the device is updated to support a new behavior. A pair of end-points intending to use a new behavior will therefore not only need to ensure support at each end-point, but also that the path between them will deliver packets with the new behavior. This may require negotiation or an explicit mandate to use the new behavior by all nodes intended to use a new protocol.</p>
<p id="rfc.section.3.2.p.3">Support along the path between end points may be guaranteed in limited deployments by appropriate configuration. In general, it can be expected to take time for deployment of any updated behaviour to become ubiquitous. A sender will need to probe the path to verify the expected behavior. Path characteristics may change, and usage therefore should be robust and able to detect a failure of the path under normal usage and re-negotiate. This will require periodic validation of the path, adding complexity to any solution using the new behavior.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> Applicability of method</h1>
<p id="rfc.section.3.3.p.1">The expectation of the present proposal defined in <a href="#I-D.ietf-6man-udpchecksums">[I-D.ietf-6man-udpchecksums]</a> is that this change would only apply to IPv6 router nodes that implement specific protocols that permit omission of UDP checksums. However, the distinction between a router and a host is not always clear, especially at the transport level. Systems (such as unix-based operating systems) routinely provide both functions. There is also no way to identify the role of a receiver from a received packet.</p>
<p id="rfc.section.3.3.p.2">Any new method would therefore need a specific applicability statement indicating when the mechanism can (and can not) be used.  Enabling this, and ensuring correct interactions with the stack, implies much more than simply disabling the checksum algorithm for specific packets at the transport interface.</p>
<p id="rfc.section.3.3.p.3">The IETF should carefully consider constraints on sanctioning the use of any new transport mode. If this is specified and widely available, it may be expected to be used by applications that are perceived to gain benefit. Any solution that uses an end-to-end transport protocol, rather than an IP-in-IP encapsulation, needs to minimise the possibility that end-hosts could confuse a corrupted or wrongly delivered packet with that of data addressed to an application running on their endpoint unless they accept that behavior.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Impact on non-supporting devices or applications</h1>
<p id="rfc.section.3.4.p.1">It is important to consider what potential impact the zero-checksum behavior may have on end-points, devices or applications that are not modified to support the new behavior or by default or preference, use the regular behavior. These applications must not be significantly impacted by the changes.</p>
<p id="rfc.section.3.4.p.2">To illustrate a potential issue, consider the implications of a node that were to enable use of a zero-checksum at the interface level: This would result in all applications that listen to a UDP socket receiving datagram where the checksum was not verified. This could have a significant impact on an application that was not designed with the additional robustness needed to handle received packets with corruption, creating state or destroying existing state in the application.</p>
<p id="rfc.section.3.4.p.3">In contrast, the use of a zero-checksum could be enabled only for individual ports using an explicit request by the application. In this case, applications using other ports would maintain the current IPv6 behavior, discarding incoming UDP datagrams with a zero-checksum.  These other applications would not be effected by this changed behavior. An application that allows the changed behavior should be aware of the risk for corruption and the increased level of misdirected traffic, and can be designed robustly to handle this risk.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#Proposal" id="Proposal">Evaluation of proposal to update RFC 2460 to support zero checksum</a>
</h1>
<p id="rfc.section.4.p.1">This section evaluates the proposal to update IPv6 [RFC2460], to provide the option that some nodes may suppress generation and checking of the UDP transport checksum. It also compares the proposal with other alternatives.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Alternatives to the Standard Checksum</h1>
<p id="rfc.section.4.1.p.1">There are several alternatives to the normal method for calculating the UDP Checksum that do not require a tunnel endpoint to inspect the entire packet when computing a checksum. These include (in decreasing order of complexity):</p>

<ul>
<li>Delta computation of the checksum from an encapsulated checksum field. Since the checksum is a cumulative sum <a href="#RFC1624">[RFC1624]</a>, an encapsulating header checksum can be derived from the new pseudo header, the inner checksum and the sum of the other network-layer fields not included in the pseudo header of the encapsulated packet, in a manner resembling incremental checksum update <a href="#RFC1141">[RFC1141]</a>. This would not require access to the whole packet, but does require fields to be collected across the header, and arithmetic operations on each packet. The method would only work for packets that contain a 2's complement transport checksum (i.e. it would not be appropriate for SCTP or when IP fragmentation is used).</li>
<li>UDP-Lite with the checksum coverage set to only the header portion of a packet. This requires a pseudo header checksum calculation only on the encapsulating packet header. The computed checksum value may be cached (before adding the Length field) for each flow/destination and subsequently combined with the Length of each packet to minimise per-packet processing. This value is combined with the UDP payload length for the pseudo header, however this length is expected to be known when performing packet forwarding.</li>
<li>The proposed UDP Tunnel Transport, UDPTT <a href="#UDPTT">[UDPTT]</a> suggested a method where UDP would be modified to derive the checksum only from the encapsulating packet protocol header. This value does not change between packets in a single flow. The value may be cached per flow/destination to minimise per-packet processing.</li>
<li>There has been a proposal to simply ignore the UDP checksum value on reception at the tunnel egress, allowing a tunnel ingress to insert any value correct or false. For tunnel usage, a non standard checksum value may be used, forcing an RFC 2460 receiver to drop the packet. The main downside is that it would be impossible to identify a UDP packet (in the network or an endpoint) that is treated in this way compared to a packet that has actually been corrupted.</li>
<li>A method has been proposed that uses a new (to be defined) IPv6 Destination Options Header to provide an end-to-end validation check at the network layer. This would allow an endpoint to verify delivery to an appropriate end point, but would also require IPv6 nodes to correctly handle the additional header, and would require changes to middlebox behavior (e.g. when used with a NAT that always adjusts the checksum value).</li>
<li>
<a href="#I-D.ietf-6man-udpchecksums">UDP modified to disable checksum processing</a> <cite title="NONE">[I-D.ietf-6man-udpchecksums]</cite>. This requires no checksum calculation, but would require constraints on appropriate usage and updates to end-points and middleboxes.</li>
<li>IP-in-IP tunneling. As this method completely dispenses with a transport protocol in the outer-layer it has reduced overhead and complexity, but also reduced functionality. There is no outer checksum over the packet and also no ports to perform demultiplexing between different tunnel types. This reduces the information available upon which a load balancer may act.</li>
</ul>

<p>These options are compared and discussed further in the following sections.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Comparison</h1>
<p id="rfc.section.4.2.p.1">This section compares the above listed methods to support datagram tunneling. It includes proposals for updating the behaviour of UDP.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> Middlebox Traversal</h1>
<p id="rfc.section.4.2.1.p.1">Regular UDP with a standard checksum or the delta encoded optimization for creating correct checksums have the best possibilities for successful traversal of a middlebox. No new support is required.</p>
<p id="rfc.section.4.2.1.p.2">A method that ignores the UDP checksum on reception is expected to have a good probability of traversal, because most middleboxes perform an incremental checksum update. UDPTT may also traverse a middlebox with this behaviour. However, a middlebox on the path that attempts to verify a standard checksum will not forward packets using either of these methods, preventing traversal. The methods that ignores the checksum has an additional downside in that middlebox traversal can not be improved, because there is no way to identify which packets use the modified checksum behaviour.</p>
<p id="rfc.section.4.2.1.p.3">IP-in-IP or GRE tunnels offer good traversal of middleboxes that have not been designed for security, e.g. firewalls. However, firewalls may be expected to be configured to block general tunnels as they present a large attack surface.</p>
<p id="rfc.section.4.2.1.p.4">A new IPv6 Destination Options header will suffer traversal issues with middleboxes, especially Firewalls and NATs, and will likely require them to be updated before the extension header is passed.</p>
<p id="rfc.section.4.2.1.p.5">Packets using UDP with a zero checksum will not be passed by any middlebox that validates the checksum using RFC 2460 or updates the checksum field, such as NAT or firewalls. This would require an update to correctly handle the zero checksum packets.</p>
<p id="rfc.section.4.2.1.p.6">UDP-Lite will require an update of almost all type of middleboxes, because it requires support for a separate network-layer protocol number. Once enabled, the method to support incremental checksum update would be identical to that for UDP, but different for checksum validation.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> Load Balancing</h1>
<p id="rfc.section.4.2.2.p.1">The usefulness of solutions for load balancers depends on the difference in entropy in the headers for different flows that can be included in a hash function. All the proposals that use the UDP protocol number have equal behavior. UDP-Lite has the potential for equally good behavior as for UDP. However, UDP-Lite is currently likely to not be supported by deployed hashing mechanisms, which may cause a load balancer to not use the transport header in the computed hash. A load balancer that only uses the IP header will have low entropy, but could be improved by including the IPv6 the flow label, providing that the tunnel ingress ensures that different flow labels are assigned to different flows. However, a transition to the common use of good quality flow labels is likely to take time to deploy.</p>
<h1 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> Ingress and Egress Performance Implications</h1>
<p id="rfc.section.4.2.3.p.1">IP-in-IP tunnels are often considered efficient, because they introduce very little processing and low data overhead. The other proposals introduce a UDP-like header incurring associated data overhead. Processing is minimised for the zero-checksum method, ignoring the checksum on reception, and only slightly higher for UDPTT, the extension header and UDP-Lite. The delta-calculation scheme operates on a few more fields, but also introduces serious failure modes that can result in a need to calculate a checksum over the complete packet. Regular UDP is clearly the most costly to process, always requiring checksum calculation over the entire packet.</p>
<p id="rfc.section.4.2.3.p.2">It is important to note that the zero-checksum method, ignoring checksum on reception, the Option Header, UDPTT and UDP-Lite will likely incur additional complexities in the application to incorporate a negotiation and validation mechanism.</p>
<h1 id="rfc.section.4.2.4">
<a href="#rfc.section.4.2.4">4.2.4.</a> Deployability</h1>
<p id="rfc.section.4.2.4.p.1">The major factors influencing deployability of these solutions are a need to update both end-points, a need for negotiation and the need to update middleboxes. These are summarised below:</p>

<ul>
<li>The solution with the best deployability is regular UDP. This requires no changes and has good middlebox traversal characteristics.</li>
<li>The next easiest to deploy is the delta checksum solution.  This does not modify the protocol on the wire and only needs changes in tunnel ingress.</li>
<li>IP-in-IP tunnels should not require changes to the end-points, but raise issues when traversing firewalls and other security-type devices, which are expected to require updates.</li>
<li>Ignoring the checksum on reception will require changes at both end-points. The never ceasing risk of path failure requires additional checks to ensure this solution is robust and will require changes or additions to the tunneling control protocol to negotiate support and validate the path.</li>
<li>The remaining solutions offer similar deployability. UDP-Lite requires support at both end-points and in middleboxes. UDPTT and Zero-checksum with or without an Extension header require support at both end-points and in middleboxes. UDP-Lite, UDPTT, and Zero-checksum and Extension header may additionally require changes or additions to the tunneling control protocol to negotiate support and path validation.</li>
</ul>
<h1 id="rfc.section.4.2.5">
<a href="#rfc.section.4.2.5">4.2.5.</a> Corruption Detection Strength</h1>
<p id="rfc.section.4.2.5.p.1">The standard UDP checksum and the delta checksum can both provide some verification at the tunnel egress. This can significantly reduce the probability that a corrupted inner packet is forwarded.  UDP-Lite, UDPTT and the extension header all provide some verification against corruption, but do not verify the inner packet.  They only provide a strong indication that the delivered packet was intended for the tunnel egress and was correctly delimited. The Zero-checksum, ignoring the checksum on reception and IP-and-IP encapsulation provide no verification that a received packet was intended to be processed by a specific tunnel egress or that the inner packet was correct.</p>
<h1 id="rfc.section.4.2.6">
<a href="#rfc.section.4.2.6">4.2.6.</a> Comparison Summary</h1>
<p id="rfc.section.4.2.6.p.1">The comparisons above may be summarised as "there is no silver bullet that will slay all the issues". One has to select which down side(s) can best be lived with. Focusing on the existing solutions, this can be summarized as:</p>
<p></p>

<dl>
<dt>Regular UDP:</dt>
<dd style="margin-left: 8">Good middlebox traversal and load balancing and multiplexing, requiring a checksum in the outer headers covering the whole packet.</dd>
<dt>IP in IP:</dt>
<dd style="margin-left: 8">A low complexity encapsulation, with limited middlebox traversal, no multiplexing support, and currently poor load balancing support that could improve over time.</dd>
<dt>UDP-Lite:</dt>
<dd style="margin-left: 8">A medium complexity encapsulation, with good multiplexing support, limited middlebox traversal, but possible to improve over time, currently poor load balancing support that could improve over time, in most cases requiring application level negotiation and validation.</dd>
</dl>

<p>The delta-checksum is an optimization in the processing of UDP, as such it exhibits some of the drawbacks of using regular UDP.</p>
<p id="rfc.section.4.2.6.p.3">The remaining proposals may be described in similar terms:</p>
<p></p>

<dl>
<dt>Zero-Checksum:</dt>
<dd style="margin-left: 8">A low complexity encapsulation, with good multiplexing support, limited middlebox traversal that could improve over time, good load balancing support, in most cases requiring application level negotiation and validation.</dd>
<dt>UDPTT:</dt>
<dd style="margin-left: 8">A medium complexity encapsulation, with good multiplexing support, limited middlebox traversal, but possible to improve over time, good load balancing support, in most cases requiring application level negotiation and validation.</dd>
<dt>IPv6 Destination Option IP in IP tunneling:</dt>
<dd style="margin-left: 8">A medium complexity, with no multiplexing support, limited middlebox traversal, currently poor load balancing support that could improve over time, in most cases requiring application level negotiation and validation.</dd>
<dt>IPv6 Destination Option combined with UDP Zero-checksuming:</dt>
<dd style="margin-left: 8">A medium complexity encapsulation, with good multiplexing support, limited load balancing support that could improve over time, in most cases requiring application level negotiation and validation.</dd>
<dt>Ignore the checksum on reception:</dt>
<dd style="margin-left: 8">A low complexity encapsulation, with good multiplexing support, medium middlebox traversal that never can improve, good load balancing support, in most cases requiring application level negotiation and validation.</dd>
</dl>
<p id="rfc.section.4.2.6.p.5">There is no clear single optimum solution. If the most important need is to traverse middleboxes, then the best choice is to stay with regular UDP and consider the optimizations that may be required to perform the checksumming. If one can live with limited middlebox traversal, low complexity is necessary and one does not require load balancing, then IP-in-IP tunneling is the simplest. If one wants strengthened error detection, but with currently limited middlebox traversal and load-balancing. UDP-Lite is appropriate. UDP Zero-checksum addresses another set of constraints, low complexity and a need for load balancing from the current Internet, providing it can live with currently limited middlebox traversal.</p>
<p id="rfc.section.4.2.6.p.6">Techniques for load balancing and middlebox traversal do continue to evolve. Over a long time, developments in load balancing have good potential to improve. This time horizon is long since it requires both load balancer and end-point updates to get full benefit. The challenges of middlebox traversal are also expected to change with time, as device capabilities evolve. Middleboxes are very prolific with a larger proportion of end-user ownership, and therefore may be expected to take long time cycles to evolve. One potential advantage is that the deployment of IPv6 capable middleboxes are still in its initial phase and the quicker zero-checksum becomes standardized the fewer boxes will be non-compliant.</p>
<p></p>
<p id="rfc.section.4.2.6.p.8">Thus, the question of whether to allow UDP with a zero-checksum for IPv6 under reasonable constraints, is therefore best viewed as a trade-off between a number of more subjective questions:</p>
<p></p>

<ul>
<li>Is there sufficient interest in zero-checksum with the given constraints (summarised below)?</li>
<li>Are there other avenues of change that will resolve the issue in a better way and sufficiently quickly ?</li>
<li>Do we accept the complexity cost of having one more solution in the future?</li>
</ul>

<p>The authors do think the answer to the above questions are such that zero-checksum should be standardized for use by tunnel encapsulations.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Requirements on the specification of transported protocols</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec-constraints" id="sec-constraints">Constraints required on usage of a zero checksum</a>
</h1>
<p id="rfc.section.5.1.p.1">If a zero checksum approach were to be adopted by the IETF, the specification should consider adding the following constraints on usage:</p>
<p></p>

<ol>
<li>IPv6 protocol stack implementations should not by default allow the new method. The default node receiver behaviour must discard all IPv6 packets carrying UDP packets with a zero checksum.</li>
<li>Implementations must provide a way to signal the set of ports that will be enabled to receive UDP datagrams with a zero checksum. An IPv6 node that enables reception of UDP packets with a zero-checksum, must enable this only for a specific port or port-range. This may be implemented via a socket API call, or similar mechanism.</li>
<li>RFC 2460 specifies that IPv6 nodes should log UDP datagrams with a zero-checksum. This should remain the case for any datagram received on a port that does not explicitly enable zero-checksum processing. A port for which zero-checksum has been enabled must not log the datagram.</li>
<li>A stack may separately identify UDP datagrams that are discarded with a zero checksum. It should not add these to the standard log, since the endpoint has not been verified.</li>
<li>Tunnels that encapsulate IP may rely on the inner packet integrity checks provided that the tunnel will not significantly increase the rate of corruption of the inner IP packet. If a significantly increased corruption rate can occur, then the tunnel must provide an additional integrity verification mechanism. An integrity mechanisms is always recommended at the tunnel layer to ensure that corruption rates of the inner most packet are not increased.</li>
<li>Tunnels that encapsulate Non-IP packets must have a CRC or other mechanism for checking packet integrity, unless the Non-IP packet specifically is designed for transmission over lower layers that do not provide any packet integrity guarantee. In particular, the application must be designed so that corruption of this information does not result in accumulated state or incorrect processing of a tunneled payload.</li>
<li>UDP applications that support use of a zero-checksum, should not rely upon correct reception of the IP and UDP protocol information (including the length of the packet) when decoding and processing the packet payload. In particular, the application must be designed so that corruption of this information does not result in accumulated state or incorrect processing of a tunneled payload.</li>
<li>If a method proposes recursive tunnels, it needs to provide guidance that is appropriate for all use-cases. Restrictions may be needed to the use of a tunnel encapsulations and the use of recursive tunnels (e.g. Necessary when the endpoint is not verified).</li>
<li>IPv6 nodes that receive ICMPv6 messages that refer to packets with a zero UDP checksum must provide appropriate checks concerning the consistency of the reported packet to verify that the reported packet actually originated from the node, before acting upon the information (e.g. validating the address and port numbers in the ICMPv6 message body).</li>
</ol>
<p id="rfc.section.5.1.p.3">Deployment of the new method needs to remain restricted to endpoints that explicitly enable this mode and adopt the above procedures. Any middlebox that examines or interact with the UDP header over IPv6 should support the new method.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec-summary" id="sec-summary">Summary</a>
</h1>
<p id="rfc.section.6.p.1">This document examines the role of the transport checksum when used with IPv6, as defined in RFC2460.</p>
<p id="rfc.section.6.p.2">It presents a summary of the trade-offs for evaluating the safety of updating RFC 2460 to permit an IPv6 UDP endpoint to use a zero value in the checksum field to indicate that no checksum is present. A decision not to include a UDP checksum in received IPv6 datagrams could impact a tunnel application that receives these packets. However, a well-designed tunnel application should include consistency checks to validate any header information encapsulated with a packet. In most cases tunnels encapsulating IP packets can rely on the inner packets own integrity protection. When correctly implemented, such a tunnel endpoint will not be negatively impacted by omission of the transport-layer checksum.  Recursive tunneling and fragmentation is a potential issues that can raise corruption rates significantly, and requires careful consideration.</p>
<p id="rfc.section.6.p.3">Other applications at the intended destination node or another IPv6 node can be impacted if they are allowed to receive datagrams without a transport-layer checksum. It is particularly important that already deployed applications are not impacted by any change at the transport layer. If these applications execute on nodes that implement RFC 2460, they will reject all datagrams with a zero UDP checksum, thus this is not an issue. For nodes that implement support for zero-checksum it is important to ensure that only UDP applications that desire zero-checksum can receive and originate zero-checksum packets. Thus, the enabling of zero-checksum needs to be at a port level, not for the entire host or for all use of an interface.</p>
<p id="rfc.section.6.p.4">The implications on firewalls, NATs and other middleboxes need to be considered. It is not expected that IPv6 NATs handle IPv6 UDP datagrams in the same way that they handle IPv4 UDP datagrams. This possibly reduces the need to update the checksum. Firewalls are intended to be configured, and therefore may need to be explicitly updated to allow new services or protocols. IPv6 middlebox deployment is not yet as prolific as it is in IPv4. Thus, relatively few current middleboxes may actually block IPv6 UDP with a zero checksum.</p>
<p id="rfc.section.6.p.5">In general, UDP-based applications need to employ a mechanism that allows a large percentage of the corrupted packets to be removed before they reach an application, both to protect the applications data stream and the control plane of higher layer protocols. These checks are currently performed by the UDP checksum for IPv6, or the reduced checksum for UDP-Lite when used with IPv6.</p>
<p id="rfc.section.6.p.6">The use of UDP with no checksum has merits for some applications, such as tunnel encapsulation, and is widely used in IPv4. However, there are dangers for IPv6: There is a bigger risk of corruption and miss-delivery when using zero-checksum in IPv6 compared to IPv4 due to the removed IP header checksum. Thus, applications needs to make a new evaluation of the risks of enabling a zero-checksum. Some applications will need to re-consider their usage of zero-checksum, and possibly consider a solution that at least provides the same delivery protection as for IPv4, for example by utilizing UDP-Lite, or by enabling the UDP checksum. Tunnel applications using UDP for encapsulation can in many case use zero-checksum without significant impact on the corruption rate. In some cases, the use of checksum off-loading may help alleviate the checksum processing cost.</p>
<p id="rfc.section.6.p.7">Recursive tunneling and fragmentation is a difficult issue relating to tunnels in general. There is an increased risk of an error in the inner-most packet when fragmentation when several layers of tunneling and several different reassembly processes are run without any verification of correctness. This issue requires future thought and consideration.</p>
<p id="rfc.section.6.p.8">The conclusion is that UDP zero checksum in IPv6 should be standardized, as it satisfies usage requirements that are currently difficult to address. We do note that a safe deployment of zero-checksum will need to follow a set of constraints listed in <a href="#sec-constraints">Section 5.1</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.7.p.1">Brian Haberman, Brian Carpenter, Magaret Wasserman, Lars Eggert, others in the TSV directorate.</p>
<p id="rfc.section.7.p.2">Thanks also to: R&#233;mi Denis-Courmont, Pekka Savola and many others who contributed comments and ideas via the 6man, behave, lisp and mboned lists.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document does not require any actions by IANA.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">Transport checksums provide the first stage of protection for the stack, although they can not be considered authentication mechanisms.  These checks are also desirable to ensure packet counters correctly log actual activity, and can be used to detect unusual behaviours.</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC0791">[RFC0791]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc791">Internet Protocol</a>", STD 5, RFC 791, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1071">[RFC1071]</b></td>
<td class="top">
<a title="USC/Information Sciences Institute">Braden, R.</a>, <a title="Cray Research">Borman, D.</a>, <a title="Bolt Baranek and Newman (BBN) Laboratories">Partridge, C.</a> and <a title="Bolt Beranek and Newman, Inc. (BBN)">W. Plummer</a>, "<a href="http://tools.ietf.org/html/rfc1071">Computing the Internet checksum</a>", RFC 1071, September 1988.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2460">[RFC2460]</b></td>
<td class="top">
<a href="mailto:deering@cisco.com" title="Cisco Systems, Inc.">Deering, S.E.</a> and <a href="mailto:hinden@iprg.nokia.com" title="Nokia">R.M. Hinden</a>, "<a href="http://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>", RFC 2460, December 1998.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="AMT">[AMT]</b></td>
<td class="top">
<a title="Internet draft, draft-ietf-mboned-auto-multicast-10">, </a>, "<a>Automatic IP Multicast Without Explicit Tunnels (AMT)</a>", March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="UDPTT">[UDPTT]</b></td>
<td class="top">
<a>G Fairhurst, </a>, "<a>The UDP Tunnel Transport mode</a>", Feb 2010.</td>
</tr>
<tr>
<td class="reference"><b id="LISP">[LISP]</b></td>
<td class="top">
<a title="Internet draft, draft-farinacci-lisp-12.txt">D. Farinacci et al, </a>, "<a>Locator/ID Separation Protocol (LISP)</a>", March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="Sigcomm2000">[Sigcomm2000]</b></td>
<td class="top">
<a title="http://conferences.sigcomm.org/sigcomm/2000/conf/abstract/9-1.htm">Jonathan Stone and Craig Partridge , </a>, "<a>When the CRC and TCP Checksum Disagree</a>", 2000.</td>
</tr>
<tr>
<td class="reference"><b id="ECMP">[ECMP]</b></td>
<td class="top">
<a>Using the IPv6 flow label for equal cost multipath routing in tunnels (draft-carpenter-flow-ecmp)</a>", .</td>, "</tr>
<tr>
<td class="reference"><b id="RFC0768">[RFC0768]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>", STD 6, RFC 768, August 1980.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1141">[RFC1141]</b></td>
<td class="top">
<a href="mailto:tmallory@CCV.BBN.COM" title="Bolt Baranek and Newman Communications Corporation">Mallory, T.</a> and <a href="mailto:akullberg@BBN.COM" title="Bolt Baranek and Newman Communications Corporation">A. Kullberg</a>, "<a href="http://tools.ietf.org/html/rfc1141">Incremental updating of the Internet checksum</a>", RFC 1141, January 1990.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1624">[RFC1624]</b></td>
<td class="top">
<a href="mailto:anil@levers.enet.dec.com" title="Digital Equipment Corporation">Rijsinghani, A.</a>, "<a href="http://tools.ietf.org/html/rfc1624">Computation of the Internet Checksum via Incremental Update</a>", RFC 1624, May 1994.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4443">[RFC4443]</b></td>
<td class="top">
<a>Conta, A.</a>, <a>Deering, S.</a> and <a>M. Gupta</a>, "<a href="http://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>", RFC 4443, March 2006.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-intarea-tunnels">[I-D.ietf-intarea-tunnels]</b></td>
<td class="top">
<a>Touch, J</a> and <a>M Townsley</a>, "<a href="http://tools.ietf.org/html/draft-ietf-intarea-tunnels-00">Tunnels in the Internet Architecture</a>", Internet-Draft draft-ietf-intarea-tunnels-00, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2765">[RFC2765]</b></td>
<td class="top">
<a href="mailto:nordmark@sun.com" title="Sun Microsystems, Inc.">Nordmark, E.</a>, "<a href="http://tools.ietf.org/html/rfc2765">Stateless IP/ICMP Translation Algorithm (SIIT)</a>", RFC 2765, February 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3550">[RFC3550]</b></td>
<td class="top">
<a>Schulzrinne, H.</a>, <a>Casner, S.</a>, <a>Frederick, R.</a> and <a>V. Jacobson</a>, "<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>", STD 64, RFC 3550, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3819">[RFC3819]</b></td>
<td class="top">
<a>Karn, P.</a>, <a>Bormann, C.</a>, <a>Fairhurst, G.</a>, <a>Grossman, D.</a>, <a>Ludwig, R.</a>, <a>Mahdavi, J.</a>, <a>Montenegro, G.</a>, <a>Touch, J.</a> and <a>L. Wood</a>, "<a href="http://tools.ietf.org/html/rfc3819">Advice for Internet Subnetwork Designers</a>", BCP 89, RFC 3819, July 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3828">[RFC3828]</b></td>
<td class="top">
<a>Larzon, L-A.</a>, <a>Degermark, M.</a>, <a>Pink, S.</a>, <a>Jonsson, L-E.</a> and <a>G. Fairhurst</a>, "<a href="http://tools.ietf.org/html/rfc3828">The Lightweight User Datagram Protocol (UDP-Lite)</a>", RFC 3828, July 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4963">[RFC4963]</b></td>
<td class="top">
<a>Heffner, J.</a>, <a>Mathis, M.</a> and <a>B. Chandler</a>, "<a href="http://tools.ietf.org/html/rfc4963">IPv4 Reassembly Errors at High Data Rates</a>", RFC 4963, July 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5405">[RFC5405]</b></td>
<td class="top">
<a>Eggert, L.</a> and <a>G. Fairhurst</a>, "<a href="http://tools.ietf.org/html/rfc5405">Unicast UDP Usage Guidelines for Application Designers</a>", BCP 145, RFC 5405, November 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5415">[RFC5415]</b></td>
<td class="top">
<a>Calhoun, P.</a>, <a>Montemurro, M.</a> and <a>D. Stanley</a>, "<a href="http://tools.ietf.org/html/rfc5415">Control And Provisioning of Wireless Access Points (CAPWAP) Protocol Specification</a>", RFC 5415, March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5722">[RFC5722]</b></td>
<td class="top">
<a>Krishnan, S.</a>, "<a href="http://tools.ietf.org/html/rfc5722">Handling of Overlapping IPv6 Fragments</a>", RFC 5722, December 2009.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-6man-udpchecksums">[I-D.ietf-6man-udpchecksums]</b></td>
<td class="top">
<a>Eubanks, M</a> and <a>P Chimento</a>, "<a href="http://tools.ietf.org/html/draft-ietf-6man-udpchecksums-01">UDP Checksums for Tunneled Packets</a>", Internet-Draft draft-ietf-6man-udpchecksums-01, October 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> Document Change History</h1>
<p id="rfc.section.Appendix A.p.1">{RFC EDITOR NOTE: This section must be deleted prior to publication}</p>
<p></p>

<dl>
<dt>Individual Draft 00 </dt>
<dd style="margin-left: 8">This is the first DRAFT of this document - It contains a compilation of various discussions and contributions from a variety of IETF WGs, including: mboned, tsv, 6man, lisp, and behave. This includes contributions from Magnus with text on RTP, and various updates.</dd>
<dt>Individual Draft 01</dt>
<dd style="margin-left: 8"><ul><li>This version corrects some typos and editorial NiTs and adds discussion of the need to negotiate and verify operation of a new mechanism (3.3.4).</li></ul></dd>
<dt>Individual Draft 02</dt>
<dd style="margin-left: 8"><ul>
<li>Version -02 corrects some typos and editorial NiTs.</li>
<li>Added reference to ECMP for tunnels.</li>
<li>Clarifies the recommendations at the end of the document.</li>
</ul></dd>
<dt>Working Group Draft 00</dt>
<dd style="margin-left: 8"><ul><li>Working Group Version -00 corrects some typos and removes much of rationale for UDPTT. It also adds some discussion of IPv6 extension header.</li></ul></dd>
<dt>Working Group Draft 01</dt>
<dd style="margin-left: 8"><ul><li>Working Group Version -01 updates the rules and incorporates off-list feedback. This version is intended for wider review within the 6man working group.</li></ul></dd>
<dt>Working Group Draft 02</dt>
<dd style="margin-left: 8"><ul>
<li>This version is the result of a major rewrite and re-ordering of the document.</li>
<li>A new section comparing the results have been added.</li>
<li>The constraints list has been significantly altered by removing some and rewording other constraints.</li>
<li>This contains other significant language updates to clarify the intent of this draft.</li>
</ul></dd>
<dt>Working Group Draft 03</dt>
<dd style="margin-left: 8"><ul><li>Editorial updates</li></ul></dd>
</dl>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Godred Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  <span>School of Engineering</span>

	  <span class="vcardline">
		<span class="locality">Aberdeen, AB24 3UE</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Scotland, UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

<span class="vcardline">URI: <a href="http://www.erg.abdn.ac.uk/users/gorry">http://www.erg.abdn.ac.uk/users/gorry</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Magnus Westerlund</span> 
	  <span class="n hidden">
		<span class="family-name">Westerlund</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span>Farogatan 6</span>

	  <span class="vcardline">
		<span class="locality">Stockholm</span>,  
		<span class="region"></span>
		<span class="code">SE-164 80</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">Phone: +46 8 719 0000</span>

<span class="vcardline">EMail: <a href="mailto:magnus.westerlund@ericsson.com">magnus.westerlund@ericsson.com</a></span>

  </address>
</div>

</body>
</html>