<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Application Bridging for Federated Access Beyond Web (ABFAB) Architecture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Application Bridging for Federated Access Beyond Web (ABFAB) Architecture">
<meta name="keywords" content="Internet-Draft, Federated Authentication, AAA, RADIUS, Diameter, GSS-API, EAP, SASL">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">ABFAB</td><td class="header">J. Howlett</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">JANET(UK)</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">S. Hartmann</td></tr>
<tr><td class="header">Expires: June 24, 2011</td><td class="header">Painless Security</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">H. Tschofenig</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Nokia Siemens Networks</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">E. Lear</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Cisco Systems GmbH</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">December 21, 2010</td></tr>
</table></td></tr></table>
<h1><br />Application Bridging for Federated Access Beyond Web (ABFAB) Architecture<br />draft-lear-abfab-arch-01.txt</h1>

<h3>Abstract</h3>

<p>Over the last decade a substantial amount of work has occurred in
  the space of federated authentication and authorization.  Most of
  this effort has focused on two common use cases: network and
  web-based access, with few common building blocks within the
  architecture.  This memo describes an architecture that makes use of
  extensions to the commonly used mechanisms for both federated and
  non-federated authentication and authorization, including
  Radius/Diameter, GSS/GS2, and SAML, to primarily address non-web
  based authentication, in a that will scale to large numbers of
  federations.

</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on June 24, 2011.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.1.</a>&nbsp;
Federation Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.2.</a>&nbsp;
Design Goals<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.3.</a>&nbsp;
Use of Radius<br />
<a href="#terminology">2.</a>&nbsp;
Terminology<br />
<a href="#anchor4">3.</a>&nbsp;
Architecture<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.1.</a>&nbsp;
Federation Substrate<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.2.</a>&nbsp;
Subject To Identity Provider<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.3.</a>&nbsp;
Application to Service<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.4.</a>&nbsp;
Personalization Layer<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.5.</a>&nbsp;
Tieing Layers Together<br />
<a href="#anchor10">4.</a>&nbsp;
Application Security Services<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.1.</a>&nbsp;
Server (Mutual) Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.</a>&nbsp;
GSS-API Channel Binding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.3.</a>&nbsp;
Host-Based Service Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.4.</a>&nbsp;
Per-Message Tokens<br />
<a href="#privacy-cons">5.</a>&nbsp;
Privacy Considerations<br />
<a href="#anchor15">6.</a>&nbsp;
Deployment Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">6.1.</a>&nbsp;
EAP Channel Binding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">6.2.</a>&nbsp;
AAA Proxy Behavior<br />
<a href="#sec-cons">7.</a>&nbsp;
Security Considerations<br />
<a href="#iana">8.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor18">9.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>XXX This document is a first draft.  Comments and contributions are
  requested.

</p>
<p>The Internet makes uses of numerous authentication methods to grant
access to various resources.  These mechanisms have been generalized
and scaled over the last decade through mechanisms such as
  GS2, <a class='info' href='#OASIS.saml-core-2.0-os'>Security Assertion Markup Language (SAML)<span> (</span><span class='info'>Cantor, S., Kemp, J., Philpott, R., and E. Maler, &ldquo;Assertions and Protocol for the OASIS Security Assertion Markup Language             (SAML) V2.0,&rdquo; March&nbsp;2005.</span><span>)</span></a> [OASIS.saml&#8209;core&#8209;2.0&#8209;os],
Radius, and Diameter.  So-called "federated" access has evolved over
the last decade between web servers through such standards as SAML,
OpenID, and OAUTH, allowing entire domains of individuals to be
authorized for resources.  The key scaling points that have been
addressed are the following:
</p>
<ul class="text">
<li>An Internet service need not copy manually authentication
  information from a domain to allow for authentication and
  authorization.

</li>
<li>Individual users are able to make use of a single credential to
  authenticate to such services.

</li>
</ul><p>

</p>
<p>As the number of such federated services has proliferated, however,
  the role of the individual has become ambiguous in certain
  circumstances.  For example, a school might provide online access to
  grades to a parent who is also a teacher.  She must
  clearly distinguish her role upon access.  After all, she is
  probably not allowed to edit her own child's grades.

</p>
<p>Similarly, as the number of federations proliferates, it becomes
  increasingly difficult to discover which identity provider a user is
  associated with.  This is true for both the web and non-web case,
  but particularly acute for the latter ans many non-web
  authentication systems are not semantically rich enough on their own
  to allow for such ambiguities.  For instance, in the case of an
  email provider, the use of SMTP and IMAP protocols does not on its
  own provide for a way to select a federation.  However, the building
  blocks do exist to add this functionality.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Federation Description</h3>

<p>The typical setup for a three party protocol involves the following entities:
      
</p>
<p>
      </p>
<ul class="text">
<li>the End Host,
</li>
<li>the Identity Provider, and 
</li>
<li>the Relying Party.
</li>
</ul><p>
      
</p>
<p>
      These entities are illustrated graphically in <a class='info' href='#framework'>Figure&nbsp;1<span> (</span><span class='info'>Three Party Authentication Framework</span><span>)</span></a>.
      
</p>
<p>
        <br /><hr class="insert" />
<a name="framework"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                       -----
                     /-     -\
                   //         \\
                   /           \
                  |             |
 ,----------\    |               |   ,---------\
 | Identity |    |               |   | Relying |
 | Provider +----+   Federation  +---+ Party   |
 `----------'    |               |   '---------'
          &lt;      |               |        &gt;
           \      |             |        /
            \      \           /        /
             \     \\         //       /
             \       \-     -/        /
              \        -----         /
               \                    /
                \  +------------+  /
                 \ |            | /
                  v|  End Host  |v
                   |            |
                   +------------+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Three Party Authentication Framework&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<p><a class='info' href='#framework'>Figure&nbsp;1<span> (</span><span class='info'>Three Party Authentication Framework</span><span>)</span></a> also shows the logical entity
        'Federation'.  In a federation, policy is agreed upon by some
        form of administrative management, and then instantiated through an
        operational framework that the members use, and where
        compliance is measured in some fashion.  Some deployments
        may be required to deploy message routing intermediaries, such as application layer relays or proxies, to offer the required technical functionality while in other deployments those are missing.
      
</p>
<p>Often a real world entity is associated with the end host and
        responsible for interacting with the identity provider, even if it is
        only as weak as completing a web form and confirming the verification email. The outcome of
        this initial registration step is that credentials are made available to the identity
        provider and to the end host.
        It is important to highlight that in some
        scenarios there might indeed be a human behind the device denoted as end host and in other
        cases there is no human involved in the actual protocol execution.
</p>
<p>To support the more generic deployment case, we assume that the identity provider and the relying party belong to different
        administrative domains. The nature of federation dictates that there is some form of relationship between the identity
        provider and the relying party. This is particularly important when the relying party wants
        to use information obtained from the identity provider for authorization decisions and when
        the identity provider does not want to release information to every relying party (or only
        under certain conditions). While it is possible to have a bilateral agreement between every
        identity provider and every relying party; on an Internet scale this setup requires the introduction of a
        federation concept, as the management of such pair-wise
        relationships would otherwise prove burdensome.
        While many of the non-technical aspects of such a federation, such as business practices and operational arrangements, are outside the
        scope of the IETF they still impact the architecture setup on how to ensure the dynamic establishment of trust. 
</p>
<p>
The steps taken generally in an ABFAB federated authentication/authorization
exchange are as follows (XXX not complete):

</p>
<p>
</p>
<ol class="text">
<li>Principal provides NAI to Application: Somehow the client is
  configured with at least the realm portion of 
  an NAI, which represents the IdP to be discovered.

</li>
<li>
Authentication mechanism selection: this is the step necessary to
indicate that the GSS-EAP SASL/GS2 mechanism will be used for
authentication/authorization.

</li>
<li>
Client Application provides NAI to RP: At the conclusion of mechanism
selection the NAI must be provided to the RP for discovery.

</li>
<li>
Discovery of federated IdP: 
This is discussed in detail below.  Either the RP is configured with
authorized IdPs, or it makes use of a federation proxy.

</li>
<li>
Request from Relying Party to IdP: Once the RP knows who the IdP is,
 it or its agent will forward RADIUS 
 request that encapsulates a GSS/EAP access request to an IdP.  This
 may or may not contain a SAML request as a series of attributes.. At
 this stage, the RP will likely  have no idea who the principal is.
 The RP claims its identity to the  IdP in AAA attributes.

</li>
<li>
IdP informs the principal of which EAP method to use: The available
and appropriate methods are discussed below in this memo.

</li>
<li>
A bunch of EAP messages happen between the endpoints: Messages are
exchanged between the principal and the IdP until a 
result is determined.  The number and content of those messages will
depend on the EAP method.  If the IdP is unable to authenticate the
principal, the process concludes here.  As part of this process, the
principal will, under protection of EAP, assert the identity of the
RP to which it intends to authenticate.

</li>
<li>
Successful Authentication: At the very least the EAP server / IdP has
authenticated the 
principal, and the principal has authenticated the IdP.  As a result
of this step, the principal and the EAP server hold two cryptographic
keys- a Master Session Key (MSK), and an Extended MSK (EMSK).  If the
asserted identity of the RP by the principal matches the identity the
RP itself asserted, there is some confidence that the RP is now
authenticated to the IdP.

</li>
<li> 
Local IdP Policy Check: At this stage, the IdP checks local policy to
determine whether the RP 
and principal are authorized for the assertion to be made.  Additional
policy checks will likely have been made earlier just through the
process of discovery (see later discussion).

</li>
<li>
Response from the IdP to the Relying Party: Once the IdP has made a
determination of whether and how to 
authenticate or authorize the principal to the RP, it returns either a
negative answer to the RP, or it returns the identity of the principal
to the RP, as well as an optional set of attributes associated with the
principal. XXX XXX XXX this needs work!!!

</li>
<li>
Return results to principal: Once the RP has a response it must inform
the client application of 
the result.  If all has gone well, all are authenticated, and the
application proceeds with appropriate authorization levels.

</li>
</ol><p>

</p>
<p>
An example communication flow is given below:

</p>
<p>
 </p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    Relying Party    Client App       IdP

       |              (1)             | Client App gets NAI (somehow)
       |               |              |
       |&lt;-----(2)-----&gt;|              | Mechanism Selection
       |               |              |
       |&lt;-----(3)-----&lt;|              | NAI transmitted to RP
       |               |              |
       |&lt;=====(4)====================&gt;| Discovery
       |               |              |
       |&gt;=====(5)====================&gt;| Access request from RP to IdP
       |               |              |
       |               |&lt; - - (6) - -&lt;| EAP method to Principal
       |               |              |
       |               |&lt; - - (7) - -&gt;| EAP Exchange to authenticate
       |               |              | Principal
       |               |              |
       |               |           (8 &amp; 9) Local Policy Check
       |               |              |
       |&lt;====(10)====================&lt;| IdP Assertion to RP
       |               |              |
       |&gt;----(11)-----&gt;|              | Results to client app.



     ----- = Between Client App and RP
     ===== = Between RP and IdP
     - - - = Between Client App and IdP



</pre></div><p>


</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Design Goals</h3>

<p>Our key design goals are as follows:
</p>
<p>
</p>
<ul class="text">
<li>Each party of a transaction will be authenticated, and the
  principal will be authorized for access to a specific resource .
</li>
<li>Means of authentication is decoupled so as to allow for multiple
  authentication methods.
</li>
<li>Hence, the architecture requires no sharing of long term private
  keys.
</li>
<li>The system will scale to large numbers of identity providers,
  relying parties, and users.
</li>
<li>The system will be designed primarily for non-Web-based
  authentication.
</li>
<li>The system will build upon existing standards, components, and
  operational practices.

</li>
</ul><p>

</p>
<p>Designing new three party authentication and authorization
        protocols is hard and frought with risk of cryptographic
        flaws. Achieving widespead deployment is even more
        difficult. A lot of attention on federated access has been devoted to the Web. This document instead
        focuses on a non-Web-based environment and focuses on those protocols where HTTP is not
        used. Despite the increased excitement for layering every protocol on top of HTTP there are
        still a number of protocols available that do not use HTTP-based transports. Many of these
        protocols are lacking a native authentication and authorization framework of the style shown in
          <a class='info' href='#framework'>Figure&nbsp;1<span> (</span><span class='info'>Three Party Authentication Framework</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Use of Radius</h3>

<p>Interestingly, for network access authentication the usage of the AAA framework with RADIUS
          <a class='info' href='#RFC2865'>[RFC2865]<span> (</span><span class='info'>Rigney, C., Willens, S., Rubens, A., and W. Simpson, &ldquo;Remote Authentication Dial In User Service (RADIUS),&rdquo; June&nbsp;2000.</span><span>)</span></a> and Diameter <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J. Arkko, &ldquo;Diameter Base Protocol,&rdquo; September&nbsp;2003.</span><span>)</span></a> was quite successful from a
        deployment point of view. To map the terminology used in <a class='info' href='#framework'>Figure&nbsp;1<span> (</span><span class='info'>Three Party Authentication Framework</span><span>)</span></a> to the
        AAA framework the identity provider corresponds to the AAA server, the relying party
        corresponds to the AAA client, and the technical building blocks of a federation are AAA proxies, relays
        and redirect agents
        (particularly if they are operated by third parties, such as AAA brokers and clearing
        houses). The front-end, i.e. the end host to AAA client communication, is in case of network
        access authentication offered by link layer protocols that forward authentication protocol
        exchanges back-and-forth.  An example of a large scale
          Radius-based federation
          is <a href='http://www.eduroam.org'>EDUROAM</a>.
</p>
<p>Is it possible to design a system that builds on top of successful protocols to offer
        non-Web-based protocols with a solid starting point for authentication and authorization in
        a distributed system? 
</p>
<a name="terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>This document uses identity management and privacy terminology from <a class='info' href='#I-D.hansen-privacy-terminology'>[I&#8209;D.hansen&#8209;privacy&#8209;terminology]<span> (</span><span class='info'>Pfitzmann, A., Hansen, M., and H. Tschofenig, &ldquo;Terminology for Talking about Privacy by Data Minimization: Anonymity, Unlinkability, Undetectability, Unobservability, Pseudonymity, and Identity Management,&rdquo; August&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Architecture</h3>

<p><a class='info' href='#introduction'>Section&nbsp;1<span> (</span><span class='info'>Introduction</span><span>)</span></a> already introduced the federated access architecture, with the illustration
       of the different actors that need to interact, but it did not expand on the specifics of providing support for non-Web based applications. This section details this aspect and motivates
      design decisions. The main theme of the work described in this document is focused on re-using existing building blocks that have been deployed already and to re-arrange them in a novel way.
</p>
<p>
        Although this architecture assumes updates to both the relying party as well as to the end host for application integration, those changes
        are kept at a minimum.  A mechanism that can
        demonstrate deployment benefits (based on ease of update of existing
        software, low implementation effort, etc.)is preferred and there may be a need
        to specify multiple mechanisms to support the range of different
        deployment scenarios.
        
</p>
<p>There are a number of ways for encapsulating EAP into an application protocol. For ease of integration with a wide range of non-Web based application protocols the usage of the GSS-API was chosen. Encapsulating EAP into the GSS-API also allows EAP to be used in SASL. A description of the technical specification can be found in <a class='info' href='#I-D.ietf-abfab-gss-eap'>[I&#8209;D.ietf&#8209;abfab&#8209;gss&#8209;eap]<span> (</span><span class='info'>Hartman, S. and J. Howlett, &ldquo;A GSS-API Mechanism for the Extensible Authentication Protocol,&rdquo; October&nbsp;2010.</span><span>)</span></a>. Other alternatives exist as well and may be considered later, such as "TLS using EAP Authentication" <a class='info' href='#I-D.nir-tls-eap'>[I&#8209;D.nir&#8209;tls&#8209;eap]<span> (</span><span class='info'>Nir, Y., Sheffer, Y., Tschofenig, H., and P. Gutmann, &ldquo;TLS using EAP Authentication,&rdquo; July&nbsp;2010.</span><span>)</span></a>.
</p>
<p>There are several architectural layers in the system; this section discusses the individual layers.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Federation Substrate</h3>

<p>The federation substrate is responsible for the connunication between the relying party and the identity provider. This layer is responsible for the inter-domain communication and for the technical mechanisms necessary to establish inter-domain trust.
</p>
<p>A key design goal is the re-use of an existing infrastructure,
      we build upon the AAA framework as utilized by RADIUS
      <a class='info' href='#RFC2138'>[RFC2138]<span> (</span><span class='info'>Rigney, C., Rigney, C., Rubens, A., Simpson, W., and S. Willens, &ldquo;Remote Authentication Dial In User Service (RADIUS),&rdquo; April&nbsp;1997.</span><span>)</span></a> and Diameter
      <a class='info' href='#RFC3588'>[RFC3588]<span> (</span><span class='info'>Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J. Arkko, &ldquo;Diameter Base Protocol,&rdquo; September&nbsp;2003.</span><span>)</span></a>. Since this document does not aim to
      re-describe the AAA framework the interested reader is referred
      to <a class='info' href='#RFC2904'>[RFC2904]<span> (</span><span class='info'>Vollbrecht, J., Calhoun, P., Farrell, S., Gommans, L., Gross, G., de Bruijn, B., de Laat, C., Holdrege, M., and D. Spence, &ldquo;AAA Authorization Framework,&rdquo; August&nbsp;2000.</span><span>)</span></a>. Building on the AAA infrastructure,
      and RADIUS and Diameter as protocols, modifications to that
      infrastructure is to be avoided. Also, modifications to AAA
      servers should be kept at a minimum.
</p>
<p>One demand that the AAA substrate must make of the upper
  layers is that they must properly identify the end points of the
  communication.  That is-  it must be possible for the AAA server at
  the RP to determine where to send each radius or diameter message.
  Otherwise, it is the RP's responsibility to determine the identity
  of the principal on its own, without the assistance of an IdP.  This
  architecture makes use of the Network Access Identifier (NAI), where
  the IdP is indicated in the realm component <a class='info' href='#RFC4282'>[RFC4282]<span> (</span><span class='info'>Aboba, B., Beadles, M., Arkko, J., and P. Eronen, &ldquo;The Network Access Identifier,&rdquo; December&nbsp;2005.</span><span>)</span></a>.  The NAI is represented and consumed by the GSS-API
  layer as GSS_C_NT_USER_NAME as specified in <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a>. XXX Where is EAP here?

</p>
<p>Once an IdP has been determined by the RP, it or its proxy agent
  must determine whether or not the IdP itself is authorized to make
  assertions, as it will likely not blindly accept any old provider.
  Federations serve this purpose.  This architecture provides for
  three approaches to resolve whether an IdP is authorized:

</p>
<p>
</p>
<blockquote class="text"><dl>
<dt>Static Configuration: </dt>
<dd>
In this case, the federation provides the RP or its proxy agent with
a static list of IdPs that it may trust.

</dd>
<dt>Federation Dynamic Referral</dt>
<dd>
In this case, the federation provides a proxy of its own that will
in some way authorize the IdP to the RP, and visa versa, as not all
RPs may be authorized to use all IdPs for all purposes within a
federation.  N.B., because the identity of the principal is likely
unknown at this point, it will not be possible for a federation to
authorize an IdP to an RP based on the identity of the principal.

</dd>
<dt>Federation Proxy: </dt>
<dd>
In this case, the authentication request is forwarded to a federation
proxy, who then further forwards the request to the IdP.

</dd>
</dl></blockquote><p>

</p>
<p>
In the first two cases, it is expected that RPs will be configured to consult
multiple federations, as a matter of practice.  The first successful
query is sufficient for the RP to then contact the IdP's AAA server.

</p>
<p>The astute reader will notice that RADIUS and Diameter have
  substantially similar characteristics.  Why not pick one?  A key
  difference is that today RADIUS is largely transported upon UDP, and
  its use is largely, though not exclusively, intra-domain.  Diameter
  itself was designed to scale to broader uses.  We leave as a
  deployment decision, which protocol will be appropriate.

</p>
<p>Through the integrity protection mechanisms in the AAA framework, the relying party can establish technical trust that messages are being sent by the appropriate relying party. Any given interaction will be associated with one federation at the policy level. The legal or business relationship defines what statements the identity provider is trusted to make and how these statements are interpreted by the relying party. The AAA framework also permits the relying party or elements between the relying party and identity provider to make statements about the relying party. 
</p>
<p>The AAA framework provides transport for attributes. Statements made about the subject by the identity provider, statements made about the relying party and other information is transported as attributes.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Subject To Identity Provider</h3>

<p>Traditional web federation does not describe how a subject
	communicates with an identity provider. As a result, this
	communication is not standardized. There are several
	disadvantages to this approach. It is difficult to have
	subjects that are machines rather than humans that use some
	sort of programatic credential. In addition, use of browsers
	for authentication restricts the deployment of more secure
	forms of authentication beyond plaintext username and password
	known by the server. In a number of cases the authentication
	interface may be presented before the subject has adequately
	validated they are talking to the intended server. By giving
	control of the authentication interface to a potential
	attacker, then the security of the system may be reduced and
	phishing opportunities introduced.
</p>
<p>As a result, it is desirable to choose some standardized
	approach for communication between the subject's end-host and
	the identity provider. There are a number of requirements this
	approach must meet.
</p>
<p>Experience has taught us one key security and scalability requirement:
        it is important that the relying party not get in possession of the
        long-term secret of the entity being authenticated by the AAA
        server. Aside from a valuable secret being exposed, a
        synchronization problem can also often develop.
Since there is
        no single authentication mechanism that will be used everywhere there is another associated
        requirement: The authentication framework must allow for the flexible integration of
        authentication mechanisms. For instance, some identity
        providers may require hardware tokens while others may use
        passwords.  A service provider would want to support both
        sorts of federations, and others.
</p>
<p>Fortunately, these requirements can be met by utilizing standardized and successfully deployed technology, namely by the Extensible Authentication
            Protocol (EAP) framework
            <a class='info' href='#RFC3748'>[RFC3748]<span> (</span><span class='info'>Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, &ldquo;Extensible Authentication Protocol (EAP),&rdquo; June&nbsp;2004.</span><span>)</span></a>.
      <a class='info' href='#abfab-arch'>Figure&nbsp;2<span> (</span><span class='info'>Architecture for Federated Access of non-Web based Applications</span><span>)</span></a> illustrates the integration graphically.
</p>
<p>  EAP is an end-to-end framework; it provides for two-way
            communication between a peer (i.e,service client or
            principal) through the
            authenticator (i.e., service provider) to the back-end (i.e.,
            identity provider).  Conveniently, this is precisely the
            communication path that is needed for federated identity.
        Although EAP support is already integrated in AAA systems (see
            <a class='info' href='#RFC3579'>[RFC3579]<span> (</span><span class='info'>Aboba, B. and P. Calhoun, &ldquo;RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP),&rdquo; September&nbsp;2003.</span><span>)</span></a> and <a class='info' href='#RFC4072'>[RFC4072]<span> (</span><span class='info'>Eronen, P., Hiller, T., and G. Zorn, &ldquo;Diameter Extensible Authentication Protocol (EAP) Application,&rdquo; August&nbsp;2005.</span><span>)</span></a>)
            several challenges remain: one is to carry EAP payloads
            from the end host to the relying party. Another is to
            verify statements the relying party has made to the
            subject, confirm these statements are consistent with
            statements made to the identity provider and confirm all
            the above are consistent with the federation and any
            federation-specific policy or configuration. Another
            challenge is choosing which identity provider to use for
            which service.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Application to Service</h3>

<p>One of the remaining layers is responsible for integration
	of federated authentication into the application. There are a
	number of approaches that applications have adopted for
	security. So, there may need to be multiple strategies for
	integration of federated authentication into
	applications. However, we have started with a strategy that
	provides integration to a large number of application
	protocols.
</p>
<p>Many applications such as SSH <a class='info' href='#RFC4462'>[RFC4462]<span> (</span><span class='info'>Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, &ldquo;Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol,&rdquo; May&nbsp;2006.</span><span>)</span></a>, NFS
	<a class='info' href='#RFC2203'>[RFC2203]<span> (</span><span class='info'>Eisler, M., Chiu, A., and L. Ling, &ldquo;RPCSEC_GSS Protocol Specification,&rdquo; September&nbsp;1997.</span><span>)</span></a>, DNS <a class='info' href='#RFC3645'>[RFC3645]<span> (</span><span class='info'>Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J., and R. Hall, &ldquo;Generic Security Service Algorithm for Secret Key Transaction Authentication for DNS (GSS-TSIG),&rdquo; October&nbsp;2003.</span><span>)</span></a> and
	several non-IETF applications support the Generic Security
	Services Application Programming Interface <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a>. Many applications such as IMAP, SMTP, XMPP
	and LDAP support e Simple Authentication and Security Layer
	(SASL) <a class='info' href='#RFC4422'>[RFC4422]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a> framework. These two
	approaches work together nicely: by creating a GSS-API
	mechanism, SASL integration is also addressed <a class='info' href='#RFC5801'>[RFC5801]<span> (</span><span class='info'>Josefsson, S. and N. Williams, &ldquo;Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family,&rdquo; July&nbsp;2010.</span><span>)</span></a>. In effect, using a GSS-API mechanism with
	SASL simply requires placing some headers on the front of the
	mechanism and constraining certain GSS-API options.
</p>
<p>GSS-API is specified in terms of an abstract set of
	operations which can be mapped into a programming language to
	form an API. When people are first introduced to GSS-API, they
	focus on it as an API. However, from the prospective of
	authentication for non-web applications, GSS-API should be
	thought of as a protocol not an API. It consists of some
	abstract operations such as the initial context exchange,
	which includes two sub-operations (gss_init_sec_context and
	gss_accept_sec_context). An application defines which abstract
	operations it is going to use and where messages produced by
	these operations fit into the application architecture. A
	GSS-API mechanism will define what actual protocol messages
	result from that abstract message for a given abstract
	operation. So, since this work is focusing on a particular
	GSS-API mechanism, we generally focus on protocol elements
	rather than the API view of GSS-API.
</p>
<p>The API view has significant value. Since the abstract
	operations are well defined, the set of information that a
	mechanism gets from the application is well defined. Also, the
	set of assumptions the application is permitted to make  is
	generally well defined. As a result, an application protocol
	that supports GSS-API or SASL is very likely to be usable with
	a new approach to authentication including this one with no
	required modifications. In some cases, support for a new
	authentication mechanism has been added using plugin
	interfaces to applications without the application being
	modified at all. Even when modifications are required, they
	can often be limited to supporting a new naming and
	authorization model. For example, this work focuses on
	privacy; an application that assumes it will always obtain an
	identifier for the principal will need to be modified to
	support anonymity, unlinkability or pseudonymity.
</p>
<p>So, we use GSS-API and SASL because a number of the
	application protocols we wish to federate support these
	strategies for security integration. What does this mean from
	a protocol standpoint and how does this relate to other
	layers? This means we need to design a concrete GSS-API
	mechanism. We have chosen to use a GSS-API mechanism that
	encapsulates EAP authentication. So, GSS-API (and SASL)
	encapsulate EAP between the end-host and the service. The AAA
	framework encapsulates EAP between the relying party and the
	identity provider. The GSS-API mechanism includes rules about
	how principals and services are named as well as per-message
	security and other facilities required by the applications we
	wish to support.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Personalization Layer</h3>

<p>The AAA framework provides a way to transport statements
	from the identity provider to the relying party. However, we
	also need to say more about the content of these
	statements. In simple cases, attributes particular to the AAA
	protocol can be defined. However in more complicated
	situations it is strongly desirable to re-use an existing
	protocol for asking questions and receiving information about
	subjects. SAML is used for this. 
</p>
<p>SAML usage may be as simple as the identity provider
	including a SAML Response message in the AAA
	response. Alternatively the relying party may generate a SAML request.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Tieing Layers Together</h3>

<p>
        <br /><hr class="insert" />
<a name="abfab-arch"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                 +--------------+
                                 |  AAA Server  |
                                 |  (Identity   |
                                 |  Provider)   |
                                 +-^----------^-+
                                   * EAP      | RADIUS/
                                   *          | Diameter
                                 --v----------v--
                              ///                \\\
                            //                      \\   ***
                           |        Federation        |  back-
                           |                          |  end
                            \\                      //   ***
                              \\\                ///
                                 --^----------^--
                                   * EAP      | RADIUS/
                 Application       *          | Diameter
+-------------+  Data            +-v----------v--+
|             |&lt;----------------&gt;|               |
| Client      |  EAP/EAP Method  | Server Side   |
| Application |&lt;****************&gt;| Application   |
| @ End Host  |  GSS-API         |(Relying Party)|
|             |&lt;----------------&gt;|               |
|             |  Application     |               |
|             |  Protocol        |               |
|             |&lt;================&gt;|               |
+-------------+                  +---------------+
               *** front-end ***

Legend:

 &lt;****&gt;: End-to-end exchange
 &lt;----&gt;: Hop-by-hop exchange
 &lt;====&gt;: Protocol through which GSS-API/GS2 exchanges are tunnelled
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Architecture for Federated Access of non-Web based Applications&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

      
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Application Security Services</h3>

<p>One of the key goals is to integrate federated authentication
      into existing application protocols and where possible, existing
      implementations of these protocols. Another goal is to perform
      this integration while meeting the best security practices of
      the technologies used to perform the integration. This section
      describes security services and properties required by the EAP
      GSS-API mechanism in order to meet these goals. This information
      could be viewed as specific to that mechanism. However, other
      future application integration strategies are very likely to
      need similar services. So, it is likely that these services will
      be expanded across application integration strategies if new
      application integration strategies are adopted.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Server (Mutual) Authentication</h3>

<p>GSS-API provides an optional security service called mutual
	authentication. This service means that in addition to the
	initiator providing (potentially anonymous or pseudonymous)
	identity to the acceptor, the acceptor confirms its identity
	to the initiator. Especially for the ABFAB context, this
	service is confusingly named. We still say that mutual
	authentication is provided when the identity of an acceptor is
	strongly authenticated to an anonymous initiator.
</p>
<p>RFC 2743 does not explicitly talk about what mutual
	authentication means. Within the GSS-API community successful mutual
	authentication has come to mean:</p>
<ul class="text">
<li>If a target name is supplied by the initiator, then the
	initiator trusts that the supplied target name describes the
	acceptor. This implies both that appropriate cryptographic
	exchanges took place for the initiator to make such a trust
	decision, and that after evaluating the results of these
	exchanges, the initiator's policy trusts that the target name
	is accurate.
</li>
<li>The initiator trusts that its idea of the acceptor name
	correctly names the entity it is communicating with.
</li>
<li>Both the initiator and acceptor have the same key
	material for per-message keys and both parties have confirmed
	they actually have the key material. In EAP terms, there is a
	protected indication of success.
</li>
</ul>

<p>Mutual authentication is an important defense against
	certain aspects of phishing. Intuitively, users would like to
	assume that if some party asks for their credentials as part
	of authentication, successfully gaining access to the resource
	means that they are talking to the expected party. Without
	mutual authentication, the acceptor could "grant access"
	regardless of what credentials are supplied. Mutual
	authentication better matches this user intuition.
</p>
<p>The GSS-EAP mechanism MUST implement mutual
	authentication. That is, an initiator needs to be able to
	request mutual authentication. When mutual authentication is
	requested, only EAP methods capabale of providing the
	necessary service can be used, and appropriate steps need to
	be taken to provide mutual authentication. A broader set of
	EAP methods could be supported when a particular application
	does not request mutual authentication. It is an open question
	whether the mechanism will permit this.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
GSS-API Channel Binding</h3>

<p><a class='info' href='#RFC5056'>[RFC5056]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; November&nbsp;2007.</span><span>)</span></a> defines a concept of channel
	binding to prevent man-in-the-middle attacks. It is common to
	provide SASL and GSS-API with another layer to provide
	transport security; Transport Layer Security (TLS) is the most
	common such layer. TLS provides its own server
	authentication. However there are a variety of situations
	where this authentication is not checked for policy or
	usability reasons. Even when it is checked, if the trust
	infrastructure behind the TLS authentication is different from
	the trust infrastructure behind the GSS-API mutual
	authentication. If the endpoints of the GSS-API authentication
	are different than the endpoints of the lower layer, this is a
	strong indication of a problem such as a man-in-the-middle
	attack. Channel binding provides a facility to determine
	whether these endpoints are the same.
</p>
<p>The GSS-EAP mechanism needs to support channel
	binding. When an application provides channel binding data,
	the mechanism needs to confirm this is the same on both sides
	consistent with the GSS-API specification. XXXThere is an open
	question here as to the details; today RFC 5554 governs. We
	could use that and the current draft assumes we will. However
	in Beijing we became aware of some changes to these details
	that would make life much better for GSS authentication of
	HTTP. We should resolve this with kitten and replace this note
	with a reference to the spec we're actually following.
</p>
<p>Typically when considering channel binding, people think of
	channel binding in combination with mutual
	authentication. This is sufficiently common that without
	additional qualification channel binding should be assumed to
	imply mutual authentication. Without mutual authentication, only one party
	knows that the endpoints are correct. That's sometimes
	useful. Consider for example a user who wishes to access a
	protected resource from a shared whiteboard in a conference
	room. The whiteboard is the initiator; it does not need to
	actually authenticate that it is talking to the correct
	resource because the user will be able to recognize whether
	the displayed content is correct. If channel binding were used
	without mutual authentication, it would in effect be a request
	to only disclose the resource in the context of a particular
	channel. Such an authentication would be similar in concept to
	a holder-of-key SAML assertion. However, also note that while
	it is not happening in the protocol, mutual authentication is
	happening in the overall system: the user is able to visually
	authenticate the content. This is consistent with all uses of
	channel binding without protocol level mutual authentication
	found so far.
</p>
<p>RFC 5056 channel binding (also called GSS-API channel
	binding when GSS-API is involved) is not the same thing as EAP
	channel binding. EAP channel binding is also used in the ABFAB
	context in order to implement acceptor naming and mutual
	authentication. Details are discussed in the mechanisms
	specification <a class='info' href='#I-D.ietf-abfab-gss-eap'>[I&#8209;D.ietf&#8209;abfab&#8209;gss&#8209;eap]<span> (</span><span class='info'>Hartman, S. and J. Howlett, &ldquo;A GSS-API Mechanism for the Extensible Authentication Protocol,&rdquo; October&nbsp;2010.</span><span>)</span></a>.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Host-Based Service Names</h3>

<p>IETF security mechanisms typically take the name of a
	service entered by a user and make some trust decision about
	whether the remote party in an interaction is the intended
	party. GSS-API has a relatively flexible naming
	architecture. However most of the IETF applications that use
	GSS-API, including SSH, NFS, IMAP, LDAP and XMPP, have chosen
	to use host-based service names when they use GSS-API. In this
	model, the initiator names an acceptor based on a service such
	as "imap" or "host" (for login services such as SSH) and a
	host name.
</p>
<p>Using host-based service names leads to a challenging trust
	delegation problem. Who is allowed to decide whether a
	particular hostname maps to an entity. The public-key
	infrastructure (PKI) used by the web has chosen to have a
	number of trust anchors (root certificate authorities) each of
	wich can map any name to a public key. A number of GSS-API
	mechanisms suchs as Kerberos <a class='info' href='#RFC1964'>[RFC1964]<span> (</span><span class='info'>Linn, J., &ldquo;The Kerberos Version 5 GSS-API Mechanism,&rdquo; June&nbsp;1996.</span><span>)</span></a> split
	the problem into two parts. A new concept called a realm is
	introduced. Then the mechanism decides what realm is
	responsible for a given name. That realm is responsible for
	deciding if the acceptor entity is allowed to claim the
	name. ABFAB needs to adopt this approach.
</p>
<p>Host-based service names do not work ideally when different
	instances of a service are running on different ports. Also,
	these do not work ideally when SRV record or other insecure
	referrals are used.
</p>
<p>The GSS-EAP mechanism needs to support host-based service
	names in order to work with existing IETF protocols.
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Per-Message Tokens</h3>

<p>GSs-API provides per-message security services that can
	provide confidentiality and integrity. Some IETF protocols
	such as NFS and SSH take advantage of these services. As a
	result GSS-EAP needs to support these services. As with mutual
	authentication, per-message services will limit the set of EAP
	methods that are available. Any method that produces a Master
	Session Key (MSK) should be able to support per-message
	security services.
</p>
<p>GSS-API provides a pseudo-random function. While the
	pseudo-random function does not involve sending data over the
	wire, it provides an algorithm that both the initiator and
	acceptor can run in order to arrive at the same key
	value. This is useful for designs where a successful
	authentication is used to key some other function. This is
	similar in concept to the TLS extractor. No current IETF
	protocols require this. However GSS-EAP supports this service
	because it is valuable for the future and easy to do given
	per-message services. Non-IETF protocols are expected to take
	advantage of this in the near future.
</p>
<a name="privacy-cons"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Privacy Considerations</h3>

<p>Sharing identity information may lead to privacy violations. A future verison of this document
      will provide a discussion of privacy considerations in a federated access environment.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Deployment Considerations</h3>

<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
EAP Channel Binding</h3>

<p>Discuss the implications of needing EAP channel
	binding.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
AAA Proxy Behavior</h3>

<p>Discuss deployment implications of our proxy requirements.
</p>
<a name="sec-cons"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>This entire document is about security. A future version of the document will highlight some important security concepts.
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>This document does not require actions by IANA.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgments</h3>

<p>We would like to thank Mayutan Arumaithurai and        Klaas Wierenga for their feedback. Additionally, we would like to
      thank Eve Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, and Luke Howard for their feedback on the
      federation terminology question.
</p>
<p>Furthermore, we would like to thank Klaas Wierenga for his review of the pre-00 draft version.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text"><a href="mailto:jlinn@rsasecurity.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2743.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2865">[RFC2865]</a></td>
<td class="author-text">Rigney, C., Willens, S., Rubens, A., and W. Simpson, &ldquo;<a href="http://tools.ietf.org/html/rfc2865">Remote Authentication Dial In User Service (RADIUS)</a>,&rdquo; RFC&nbsp;2865, June&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2865.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3588">[RFC3588]</a></td>
<td class="author-text">Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J. Arkko, &ldquo;<a href="http://tools.ietf.org/html/rfc3588">Diameter Base Protocol</a>,&rdquo; RFC&nbsp;3588, September&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3588.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3748">[RFC3748]</a></td>
<td class="author-text">Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, &ldquo;<a href="http://tools.ietf.org/html/rfc3748">Extensible Authentication Protocol (EAP)</a>,&rdquo; RFC&nbsp;3748, June&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3748.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3579">[RFC3579]</a></td>
<td class="author-text">Aboba, B. and P. Calhoun, &ldquo;<a href="http://tools.ietf.org/html/rfc3579">RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)</a>,&rdquo; RFC&nbsp;3579, September&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3579.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4072">[RFC4072]</a></td>
<td class="author-text">Eronen, P., Hiller, T., and G. Zorn, &ldquo;<a href="http://tools.ietf.org/html/rfc4072">Diameter Extensible Authentication Protocol (EAP) Application</a>,&rdquo; RFC&nbsp;4072, August&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4072.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4282">[RFC4282]</a></td>
<td class="author-text">Aboba, B., Beadles, M., Arkko, J., and P. Eronen, &ldquo;<a href="http://tools.ietf.org/html/rfc4282">The Network Access Identifier</a>,&rdquo; RFC&nbsp;4282, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4282.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.hansen-privacy-terminology">[I-D.hansen-privacy-terminology]</a></td>
<td class="author-text">Pfitzmann, A., Hansen, M., and H. Tschofenig, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-hansen-privacy-terminology-01.txt">Terminology for Talking about Privacy by Data Minimization: Anonymity, Unlinkability, Undetectability, Unobservability, Pseudonymity, and Identity Management</a>,&rdquo; draft-hansen-privacy-terminology-01 (work in progress), August&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-hansen-privacy-terminology-01.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-abfab-gss-eap">[I-D.ietf-abfab-gss-eap]</a></td>
<td class="author-text">Hartman, S. and J. Howlett, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-abfab-gss-eap-00.txt">A GSS-API Mechanism for the Extensible Authentication Protocol</a>,&rdquo; draft-ietf-abfab-gss-eap-00 (work in progress), October&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-abfab-gss-eap-00.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.nir-tls-eap">[I-D.nir-tls-eap]</a></td>
<td class="author-text">Nir, Y., Sheffer, Y., Tschofenig, H., and P. Gutmann, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-nir-tls-eap-08.txt">TLS using EAP Authentication</a>,&rdquo; draft-nir-tls-eap-08 (work in progress), July&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-nir-tls-eap-08.txt">TXT</a>, <a href="http://www.ietf.org/internet-drafts/draft-nir-tls-eap-08.ps">PS</a>, <a href="http://www.ietf.org/internet-drafts/draft-nir-tls-eap-08.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1964">[RFC1964]</a></td>
<td class="author-text"><a href="mailto:John.Linn@ov.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1964">The Kerberos Version 5 GSS-API Mechanism</a>,&rdquo; RFC&nbsp;1964, June&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc1964.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2203">[RFC2203]</a></td>
<td class="author-text"><a href="mailto:mre@eng.sun.com">Eisler, M.</a>, <a href="mailto:hacker@eng.sun.com">Chiu, A.</a>, and <a href="mailto:lling@eng.sun.com">L. Ling</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2203">RPCSEC_GSS Protocol Specification</a>,&rdquo; RFC&nbsp;2203, September&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2203.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2203.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2203.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3645">[RFC3645]</a></td>
<td class="author-text">Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J., and R. Hall, &ldquo;<a href="http://tools.ietf.org/html/rfc3645">Generic Security Service Algorithm for Secret Key Transaction Authentication for DNS (GSS-TSIG)</a>,&rdquo; RFC&nbsp;3645, October&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3645.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2138">[RFC2138]</a></td>
<td class="author-text"><a href="mailto:cdr@livingston.com">Rigney, C.</a>, <a href="mailto:cdr@livingston.com">Rigney, C.</a>, <a href="mailto:acr@merit.edu">Rubens, A.</a>, <a href="mailto:wsimpson@greendragon.com">Simpson, W.</a>, and <a href="mailto:steve@livingston.com">S. Willens</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2138">Remote Authentication Dial In User Service (RADIUS)</a>,&rdquo; RFC&nbsp;2138, April&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2138.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2138.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2138.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4462">[RFC4462]</a></td>
<td class="author-text">Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, &ldquo;<a href="http://tools.ietf.org/html/rfc4462">Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol</a>,&rdquo; RFC&nbsp;4462, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4462.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4422">[RFC4422]</a></td>
<td class="author-text">Melnikov, A. and K. Zeilenga, &ldquo;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>,&rdquo; RFC&nbsp;4422, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4422.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5056">[RFC5056]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>,&rdquo; RFC&nbsp;5056, November&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5056.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5801">[RFC5801]</a></td>
<td class="author-text">Josefsson, S. and N. Williams, &ldquo;<a href="http://tools.ietf.org/html/rfc5801">Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family</a>,&rdquo; RFC&nbsp;5801, July&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5801.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="OASIS.saml-core-2.0-os">[OASIS.saml-core-2.0-os]</a></td>
<td class="author-text"><a href="mailto:cantor.2@osu.edu">Cantor, S.</a>, <a href="mailto:John.Kemp@nokia.com">Kemp, J.</a>, <a href="mailto:rphilpott@rsasecurity.com">Philpott, R.</a>, and <a href="mailto:eve.maler@sun.com">E. Maler</a>, &ldquo;<a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">Assertions and Protocol for the OASIS Security Assertion Markup Language
            (SAML) V2.0</a>,&rdquo; OASIS Standard&nbsp;saml-core-2.0-os, March&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2904">[RFC2904]</a></td>
<td class="author-text">Vollbrecht, J., Calhoun, P., Farrell, S., Gommans, L., Gross, G., de Bruijn, B., de Laat, C., Holdrege, M., and D. Spence, &ldquo;<a href="http://tools.ietf.org/html/rfc2904">AAA Authorization Framework</a>,&rdquo; RFC&nbsp;2904, August&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2904.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Josh Howlett</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">JANET(UK)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:Josh.Howlett@ja.net">Josh.Howlett@ja.net</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sam Hartman</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Painless Security</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text"></td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hartmans-ietf@mit.edu">hartmans-ietf@mit.edu</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Hannes Tschofenig</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nokia Siemens Networks</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Linnoitustie 6</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Espoo  02600</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358 (50) 4871445</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:Hannes.Tschofenig@gmx.net">Hannes.Tschofenig@gmx.net</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.tschofenig.priv.at">http://www.tschofenig.priv.at</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Eliot Lear</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems GmbH</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Richtistrasse 7</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Wallisellen, ZH  CH-8304</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Switzerland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+41 44 878 9200</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:lear@cisco.com">lear@cisco.com</a></td></tr>
</table>
</body></html>
