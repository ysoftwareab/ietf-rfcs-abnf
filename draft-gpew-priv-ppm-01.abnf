payload = context.Seal(nonce || extensions, input_share)

context = SetupBaseR(helper_share.enc, sk,
                        "pda input share" || task_id || server_role)
input_share = context.Open(nonce || extensions, helper_share)

encrypted_agg_share = context.Seal(batch_interval, agg_share)

   where pk is the HPKE public key encoded by the collector's HPKE key
   configuration, task_id is AggregateShareReq.task_id and server_role
   is the role of the server (0x01 for the leader and 0x00 for the
   helper). agg_share is the serialized AggregateShare, and
   batch_interval is obtained from the AggregateShareReq.

   This encryption prevents the leader from learning the actual result,
   as it only has its own share and not the helper's share, which is
   encrypted for the collector.  The helper responds to the collector
   with HTTP status 200 OK and a body consisting of the following
   structure:

   struct {
     HpkeConfigId collector_hpke_config_id;
     opaque enc<1..2^16-1>;
     opaque payload<1..2^16>;
   } EncryptedAggregateShare;

   *  collector_hpke_config_id is collector_config.id from the task
      parameters corresponding to CollectReq.task_id.

   *  enc is the HPKE encapsulated key, used by the collector to decrypt
      the aggregate share.

   *  payload is an encrypted AggregateShare.

   The leader uses the helper's aggregate share response to respond to
   the collector's collect request (see Section 4.4).

