<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The WebSocket protocol</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Background">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Protocol overview">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Opening handshake">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Closing handshake">
<link href="#rfc.section.1.5" rel="Chapter" title="1.5 Design philosophy">
<link href="#rfc.section.1.6" rel="Chapter" title="1.6 Security model">
<link href="#rfc.section.1.7" rel="Chapter" title="1.7 Relationship to TCP and HTTP">
<link href="#rfc.section.1.8" rel="Chapter" title="1.8 Establishing a connection">
<link href="#rfc.section.1.9" rel="Chapter" title="1.9 Subprotocols using the WebSocket protocol">
<link href="#rfc.section.2" rel="Chapter" title="2 Conformance requirements">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 WebSocket URIs">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Parsing WebSocket URIs">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Constructing WebSocket URIs">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Valid WebSocket URIs">
<link href="#rfc.section.4" rel="Chapter" title="4 Data Framing">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Overview">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Base Framing Protocol">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Client-to-Server Masking">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Fragmentation">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Control Frames">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Close">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Ping">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Pong">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Data Frames">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Examples">
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Extensibility">
<link href="#rfc.section.5" rel="Chapter" title="5 Opening Handshake">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Client Requirements">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Server-side requirements">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Reading the client's opening handshake">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Sending the server's opening handshake">
<link href="#rfc.section.6" rel="Chapter" title="6 Error Handling">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Handling errors in UTF-8 from the server">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Handling errors in UTF-8 from the client">
<link href="#rfc.section.7" rel="Chapter" title="7 Closing the connection">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Definitions">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Close the WebSocket Connection">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Start the WebSocket Closing Handshake">
<link href="#rfc.section.7.1.3" rel="Chapter" title="7.1.3 The WebSocket Connection Is Closed">
<link href="#rfc.section.7.1.4" rel="Chapter" title="7.1.4 Fail the WebSocket Connection">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Abnormal closures">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Client-initiated closure">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Server-initiated closure">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Normal closure of connections">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Status codes">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Defined Status Codes">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 Reserved status code ranges">
<link href="#rfc.section.8" rel="Chapter" title="8 Extensions">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Negotiating extensions">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Known extensions">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 Compression">
<link href="#rfc.section.9" rel="Chapter" title="9 Security considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 IANA considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Registration of ws: scheme">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Registration of wss: scheme">
<link href="#rfc.section.10.3" rel="Chapter" title='10.3 Registration of the "WebSocket" HTTP Upgrade keyword'>
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Sec-WebSocket-Key">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Sec-WebSocket-Extensions">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Sec-WebSocket-Accept">
<link href="#rfc.section.10.7" rel="Chapter" title="10.7 Sec-WebSocket-Origin">
<link href="#rfc.section.10.8" rel="Chapter" title="10.8 Sec-WebSocket-Protocol">
<link href="#rfc.section.10.9" rel="Chapter" title="10.9 Sec-WebSocket-Version">
<link href="#rfc.section.11" rel="Chapter" title="11 Using the WebSocket protocol from other specifications">
<link href="#rfc.section.12" rel="Chapter" title="12 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="The WebSocket protocol enables two-way communication between a user agent running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers. The protocol consists of an initial handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or <iframe>s and long polling). " />
  <meta name="description" content="The WebSocket protocol enables two-way communication between a user agent running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers. The protocol consists of an initial handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or <iframe>s and long polling). " />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">HyBi Working Group</td>
<td class="right">I.F. Fette</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Google, Inc.</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">April 23, 2011</td>
</tr>
<tr>
<td class="left">Expires: October 25, 2011</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The WebSocket protocol<br />
  <span class="filename">draft-ietf-hybi-thewebsocketprotocol-07</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The WebSocket protocol enables two-way communication between a user agent running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers. The protocol consists of an initial handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or &lt;iframe&gt;s and long polling). </p>
<p>Please send feedback to the hybi@ietf.org mailing list.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 25, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Background</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Protocol overview</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Opening handshake</a>
</li>
<li>1.4.   <a href="#rfc.section.1.4">Closing handshake</a>
</li>
<li>1.5.   <a href="#rfc.section.1.5">Design philosophy</a>
</li>
<li>1.6.   <a href="#rfc.section.1.6">Security model</a>
</li>
<li>1.7.   <a href="#rfc.section.1.7">Relationship to TCP and HTTP</a>
</li>
<li>1.8.   <a href="#rfc.section.1.8">Establishing a connection</a>
</li>
<li>1.9.   <a href="#rfc.section.1.9">Subprotocols using the WebSocket protocol</a>
</li>
<li>2.   <a href="#rfc.section.2">Conformance requirements</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">WebSocket URIs</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Parsing WebSocket URIs</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Constructing WebSocket URIs</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Valid WebSocket URIs</a>
</li>
<li>4.   <a href="#rfc.section.4">Data Framing</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">Overview</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Base Framing Protocol</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Client-to-Server Masking</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Fragmentation</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Control Frames</a>
</li>
<li>4.5.1.   <a href="#rfc.section.4.5.1">Close</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Ping</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Pong</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Data Frames</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Examples</a>
</li>
<li>4.8.   <a href="#rfc.section.4.8">Extensibility</a>
</li>
<li>5.   <a href="#rfc.section.5">Opening Handshake</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Client Requirements</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Server-side requirements</a>
</li>
<li>5.2.1.   <a href="#rfc.section.5.2.1">Reading the client's opening handshake</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Sending the server's opening handshake</a>
</li>
<li>6.   <a href="#rfc.section.6">Error Handling</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">Handling errors in UTF-8 from the server</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Handling errors in UTF-8 from the client</a>
</li>
<li>7.   <a href="#rfc.section.7">Closing the connection</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Definitions</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">Close the WebSocket Connection</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Start the WebSocket Closing Handshake</a>
</li>
<li>7.1.3.   <a href="#rfc.section.7.1.3">The WebSocket Connection Is Closed</a>
</li>
<li>7.1.4.   <a href="#rfc.section.7.1.4">Fail the WebSocket Connection</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Abnormal closures</a>
</li>
<li>7.2.1.   <a href="#rfc.section.7.2.1">Client-initiated closure</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Server-initiated closure</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Normal closure of connections</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Status codes</a>
</li>
<li>7.4.1.   <a href="#rfc.section.7.4.1">Defined Status Codes</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">Reserved status code ranges</a>
</li>
<li>8.   <a href="#rfc.section.8">Extensions</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Negotiating extensions</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Known extensions</a>
</li>
<li>8.2.1.   <a href="#rfc.section.8.2.1">Compression</a>
</li>
<li>9.   <a href="#rfc.section.9">Security considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">IANA considerations</a>
</li>
<li>10.1.   <a href="#rfc.section.10.1">Registration of ws: scheme</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Registration of wss: scheme</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Registration of the "WebSocket" HTTP Upgrade keyword</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Sec-WebSocket-Key</a>
</li>
<li>10.5.   <a href="#rfc.section.10.5">Sec-WebSocket-Extensions</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Sec-WebSocket-Accept</a>
</li>
<li>10.7.   <a href="#rfc.section.10.7">Sec-WebSocket-Origin</a>
</li>
<li>10.8.   <a href="#rfc.section.10.8">Sec-WebSocket-Protocol</a>
</li>
<li>10.9.   <a href="#rfc.section.10.9">Sec-WebSocket-Version</a>
</li>
<li>11.   <a href="#rfc.section.11">Using the WebSocket protocol from other specifications</a>
</li>
<li>12.   <a href="#rfc.section.12">Acknowledgements</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Background</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.1.p.2">Historically, creating an instant messenger chat client as a Web application has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls.<a href="#RFC6202">[RFC6202]</a></p>
<p id="rfc.section.1.1.p.3">This results in a variety of problems: </p>

<ul>
<li>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client, and a new one for each incoming message.</li>
<li>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.</li>
<li>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.</li>
</ul>

<p> </p>
<p id="rfc.section.1.1.p.4">A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket protocol provides. Combined with the WebSocket API, it provides an alternative to HTTP polling for two-way communication from a Web page to a remote server. <a href="#WSAPI">[WSAPI]</a> </p>
<p id="rfc.section.1.1.p.5">The same technique can be used for a variety of Web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Protocol overview</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.2.p.2">The protocol has two parts: a handshake, and then the data transfer.</p>
<p id="rfc.section.1.2.p.3">The handshake from the client looks as follows:</p>
<div id="#rfc.figure.1"></div>
<pre>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 7
          </pre>
<p id="rfc.section.1.2.p.4">The handshake from the server looks as follows:</p>
<div id="#rfc.figure.2"></div>
<pre>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     Sec-WebSocket-Protocol: chat
          </pre>
<p id="rfc.section.1.2.p.5">The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in <a href="#RFC2616">[RFC2616]</a>.  </p>
<p id="rfc.section.1.2.p.6">After the leading line in both cases come an unordered set of header fields. The meaning of these header fields is specified in <a href="#handshake">Section 5</a> of this document. Additional header fields may also be present, such as cookies <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a> required to identify the user. The format and parsing of headers is as defined in <a href="#RFC2616">[RFC2616]</a>.  </p>
<p><br><br></p>
<p id="rfc.section.1.2.p.8">Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.</p>
<p id="rfc.section.1.2.p.9">Clients and servers, after a successful handshake, transfer data back and forth in conceptual units referred to in this specification as "messages". A message is a complete unit of data at an application level, with the expectation that many or most applications implementing this protocol (such as web user agents) provide APIs in terms of sending and receiving messages. The websocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced, or vice versa, e.g. by an intermediary.</p>
<p id="rfc.section.1.2.p.10">Data is sent on the wire in the form of frames that have an associated type. A message is composed of one or more frames, all of which contain the same type of data. Broadly speaking, there are types for textual data, which is interpreted as UTF-8 <a href="#RFC3629">[RFC3629]</a> text, binary data (whose interpretation is left up to the application), and control frames, which are not intended to carry data for the application, but instead for protocol-level signaling, such as to signal that the connection should be closed. This version of the protocol defines six frame types and leaves ten reserved for future use.</p>
<p id="rfc.section.1.2.p.11">The WebSocket protocol uses this framing so that specifications that use the WebSocket protocol can expose such connections using an event-based mechanism instead of requiring users of those specifications to implement buffering and piecing together of messages manually.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> Opening handshake</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.3.p.2">The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client's handshake is an HTTP Upgrade request:</p>
<div id="#rfc.figure.3"></div>
<pre>
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-Protocol: chat, superchat
     Sec-WebSocket-Version: 7
          </pre>
<p id="rfc.section.1.3.p.3">Headers in the handshake are sent by the client in a random order; the order is not meaningful.</p>
<p id="rfc.section.1.3.p.4">The "Request-URI" of the GET method <a href="#RFC2616">[RFC2616]</a> is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.<br><br></p>
<p id="rfc.section.1.3.p.5">The client includes the hostname in the Host header of its handshake as per <a href="#RFC2616">[RFC2616]</a>, so that both the client and the server can verify that they agree on which host is in use.</p>
<p id="rfc.section.1.3.p.6">Additional headers are used to select options in the WebSocket protocol. Options available in this version are the subprotocol selector, |Sec-WebSocket-Protocol|, and |Cookie|, which can used for sending cookies to the server (e.g. as an authentication mechanism). The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket protocol) are acceptable to the client. The server selects one of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.</p>
<div id="#rfc.figure.4"></div>
<pre>     Sec-WebSocket-Protocol: chat</pre>
<p id="rfc.section.1.3.p.7">The |Sec-WebSocket-Origin| header is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the |WebSocket| API in a Web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to abort the connection. This header is sent by browser clients, for non-browser clients this header may be sent if it makes sense in the context of those clients.</p>
<p id="rfc.section.1.3.p.8">Finally, the server has to prove to the client that it received the client's WebSocket handshake, so that the server doesn't accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully-crafted packets using |XMLHttpRequest| or a |form| submission.</p>
<p id="rfc.section.1.3.p.9">To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header in the client handshake:</p>
<div id="#rfc.figure.5"></div>
<pre>
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
          </pre>
<p id="rfc.section.1.3.p.10">For this header, the server has to take the value (as present in the header, e.g. the base64-encoded <a href="#RFC4648">[RFC4648]</a> version minus leading and trailing whitespace), and concatenate this with the GUID "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket protocol. A SHA-1 hash, base64-encoded, of this concatenation is then returned in the server's handshake <a href="#FIPS.180-2.2002">[FIPS.180-2.2002]</a>.  </p>
<p id="rfc.section.1.3.p.11">Concretely, if as in the example above, header |Sec-WebSocket-Key| had the value "dGhlIHNhbXBsZSBub25jZQ==", the server would concatenate the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=". This value would then be echoed in the header |Sec-WebSocket-Accept|.</p>
<p><br><br></p>
<p id="rfc.section.1.3.p.13">The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:<br><br></p>
<div id="#rfc.figure.6"></div>
<pre>     HTTP/1.1 101 Switching Protocols</pre>
<p id="rfc.section.1.3.p.14">Any status code other than 101 indicates that the WebSocket handshake has not completed, and that the semantics of HTTP still apply. The headers follow the status code.</p>
<p id="rfc.section.1.3.p.15">The |Connection| and |Upgrade| headers complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header indicates whether the server is willing to accept the connection. If present, this header must include a hash of the client's nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.<br><br></p>
<div id="#rfc.figure.7"></div>
<pre>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
          </pre>
<p id="rfc.section.1.3.p.16">These fields are checked by the Web browser when it is acting as a |WebSocket| client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, or if the header is missing, or if the HTTP status code is not 101, the connection will not be established and WebSockets frames will not be sent.</p>
<p id="rfc.section.1.3.p.17">Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. Web browsers verify that the server included one of the values as was specified in the WebSocket client' handshake. A server that speaks multiple subprotocols has to make sure it selects one based on the client's handshake and specifies it in its handshake.<br><br></p>
<div id="#rfc.figure.8"></div>
<pre>     Sec-WebSocket-Protocol: chat</pre>
<p id="rfc.section.1.3.p.18">The server can also set cookie-related option fields to <em>set</em> cookies, as in HTTP.  </p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> Closing handshake</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.4.p.2">The closing handshake is far simpler than the opening handshake.</p>
<p id="rfc.section.1.4.p.3">Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake (detailed in <a href="#closeframe">Section 4.5.1</a>). Upon receiving such a frame, the other peer sends a close frame in response, if it hasn't already sent one. Upon receiving <em>that</em> control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.</p>
<p id="rfc.section.1.4.p.4">After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.</p>
<p id="rfc.section.1.4.p.5">It is safe for both peers to initiate this handshake simultaneously.</p>
<p id="rfc.section.1.4.p.6">The closing handshake is intended to replace the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of man-in-the-middle proxies and other intermediaries.</p>
<p id="rfc.section.1.4.p.7">By sending a close frame and waiting for a close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.</p>
<h1 id="rfc.section.1.5">
<a href="#rfc.section.1.5">1.5.</a> Design philosophy</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.5.p.2">The WebSocket protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based, and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (HTTP).</p>
<p id="rfc.section.1.5.p.3">Conceptually, WebSocket is really just a layer on top of TCP that adds a Web "origin"-based security model for browsers; adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address; layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits; and re-implements the closing handshake in-band. Other than that, it adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It's also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request mechanism also.</p>
<p id="rfc.section.1.5.p.4">The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.</p>
<h1 id="rfc.section.1.6">
<a href="#rfc.section.1.6">1.6.</a> Security model</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.6.p.2">The WebSocket protocol uses the origin model used by Web browsers to restrict which Web pages can contact a WebSocket server when the WebSocket protocol is used from a Web page. Naturally, when the WebSocket protocol is used by a dedicated client directly (i.e. not from a Web page through a Web browser), the origin model is not useful, as the client can provide any arbitrary origin string.</p>
<p id="rfc.section.1.6.p.3">This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP <a href="#RFC5321">[RFC5321]</a> and HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake, and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).</p>
<p id="rfc.section.1.6.p.4">It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example as might happen if an HTML |form| were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts which themselves can only be sent by a WebSocket handshake. In particular, at the time of writing of this specification, fields starting with |Sec-| cannot be set by an attacker from a Web browser using only HTML and JavaScript APIs such as |XMLHttpRequest|.</p>
<h1 id="rfc.section.1.7">
<a href="#rfc.section.1.7">1.7.</a> Relationship to TCP and HTTP</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.7.p.2">The WebSocket protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.</p>
<p id="rfc.section.1.7.p.3">By default the WebSocket protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over TLS <a href="#RFC2818">[RFC2818]</a>.</p>
<h1 id="rfc.section.1.8">
<a href="#rfc.section.1.8">1.8.</a> Establishing a connection</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.8.p.2">When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer.  In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket protocol to be deployed.  In more elaborate setups (e.g. with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage. At the time of writing of this specification, it should be noted that connections on port 80 and 443 have significantly different success rates, with connections on port 443 being significantly more likely to succeed, though this may change with time.  </p>
<h1 id="rfc.section.1.9">
<a href="#rfc.section.1.9">1.9.</a> Subprotocols using the WebSocket protocol</h1>
<p><em>This section is non-normative.</em></p>
<p id="rfc.section.1.9.p.2">The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.</p>
<p id="rfc.section.1.9.p.3">These subprotocol names do not need to be registered, but if a subprotocol is intended to be implemented by multiple independent WebSocket servers, potential clashes with the names of subprotocols defined independently can be avoided by using names that contain the domain name of the subprotocol's originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it "chat.example.com". If the Example Organization called their competing subprotocol "example.org's&#160;chat&#160;protocol", then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.</p>
<p id="rfc.section.1.9.p.4">Subprotocols can be versioned in backwards-incompatible ways by changing the subprotocol name, e.g. going from "bookings.example.net" to "v2.bookings.example.net". These subprotocols would be considered completely separate by WebSocket clients. Backwards-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Conformance requirements</h1>
<p id="rfc.section.2.p.1">All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.</p>
<p id="rfc.section.2.p.2">The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in RFC2119. <a href="#RFC2119">[RFC2119]</a> </p>
<p id="rfc.section.2.p.3">Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc) used in introducing the algorithm.</p>
<p id="rfc.section.2.p.4">Conformance requirements phrased as algorithms or specific steps MAY be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)</p>
<p id="rfc.section.2.p.5">Implementations MAY impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.</p>
<p id="rfc.section.2.p.6">The conformance classes defined by this specification are user agents and servers.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Terminology</h1>
<p><strong>ASCII</strong> shall mean the character-encoding scheme defined in  <a href="#ANSI.X3-4.1986">[ANSI.X3-4.1986]</a>.  </p>
<p><strong>Converting a string to ASCII lowercase</strong> means replacing all characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).  </p>
<p id="rfc.section.2.1.p.3">Comparing two strings in an <strong>ASCII case-insensitive</strong> manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.  </p>
<p id="rfc.section.2.1.p.4">The term "URI" is used in this document as defined in <a href="#RFC3986">[RFC3986]</a>.  </p>
<p id="rfc.section.2.1.p.5">When an implementation is required to <em>send</em> data as part of the WebSocket protocol, the implementation MAY delay the actual transmission arbitrarily, e.g. buffering data so as to send fewer IP packets.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#ws_urls" id="ws_urls">WebSocket URIs</a>
</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#parsing_ws_urls" id="parsing_ws_urls">Parsing WebSocket URIs</a>
</h1>
<p id="rfc.section.3.1.p.1">The steps to <strong>parse a WebSocket URI's components</strong> from a string /uri/ are as follows. These steps return either a /host/, a /port/, a /resource name/, and a /secure/ flag, or they fail.  </p>

<ol>
<li>If the /uri/ string is not an absolute URI, then fail this algorithm. <a href="#RFC3986">[RFC3986]</a> </li>
<li>Resolve the /uri/ string using the resolve a Web address algorithm defined by the Web addresses specification, with the URI character encoding set to UTF-8. <a href="#RFC3629">[RFC3629]</a> <a href="#RFC3986">[RFC3986]</a> <a href="#RFC3987">[RFC3987]</a> <br><br> NOTE: It doesn't matter what it is resolved relative to, since we already know it is an absolute URI at this point.  </li>
<li>If /uri/ does not have a &lt;scheme&gt; component whose value, when converted to ASCII lowercase, is either "ws" or "wss", then fail this algorithm.</li>
<li>If /uri/ has a &lt;fragment&gt; component, then fail this algorithm.</li>
<li>If the &lt;scheme&gt; component of /uri/ is "ws", set /secure/ to false; otherwise, if the &lt;scheme&gt; component is "wss", set /secure/ to true; if neither of the above apply, fail this algorithm.</li>
<li>Let /host/ be the value of the &lt;host&gt; component of /uri/, converted to ASCII lowercase.</li>
<li>If /uri/ has a &lt;port&gt; component, then let /port/ be that component's value; otherwise, there is no explicit /port/.</li>
<li>If there is no explicit /port/, then: if /secure/ is false, let /port/ be 80, otherwise let /port/ be 443.</li>
<li>Let /resource name/ be the value of the &lt;path&gt; component (which might be empty) of /uri/.</li>
<li>If /resource name/ is the empty string, set it to a single character U+002F SOLIDUS (/).</li>
<li>If /uri/ has a &lt;query&gt; component, then append a single U+003F QUESTION MARK character (?) to /resource name/, followed by the value of the &lt;query&gt; component.</li>
<li>Return /host/, /port/, /resource name/, and /secure/.</li>
</ol>

<p> </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#constructwsuri" id="constructwsuri">Constructing WebSocket URIs</a>
</h1>
<p id="rfc.section.3.2.p.1">The steps to <strong>construct a WebSocket URI</strong> from a /host/, a /port/, a /resource name/, and a /secure/ flag, are as follows: </p>

<ol>
<li>Let /uri/ be the empty string.</li>
<li>If the /secure/ flag is false, then append the string "ws://" to /uri/. Otherwise, append the string "wss://" to /uri/.</li>
<li>Append /host/ to /uri/.</li>
<li>If the /secure/ flag is false and port is not 80, or if the /secure/ flag is true and port is not 443, then append the string ":" followed by /port/ to /uri/.</li>
<li>Append /resource name/ to /uri/.</li>
<li>Return /uri/.</li>
</ol>

<p> </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#valid_ws_urls" id="valid_ws_urls">Valid WebSocket URIs</a>
</h1>
<p id="rfc.section.3.3.p.1">For a WebSocket URI to be considered valid, the following conditions MUST hold.  </p>

<ul>
<li>The /host/ MUST be ASCII-only (i.e. it MUST have been punycode-encoded <a href="#RFC3492">[RFC3492]</a> already if necessary, and MUST NOT contain any characters above U+007E).</li>
<li>The /resource name/ string MUST be a non-empty string of characters in the range U+0021 to U+007E and MUST start with a U+002F SOLIDUS character (/).  </li>
</ul>

<p> </p>
<p id="rfc.section.3.3.p.2">Any WebSocket URIs not meeting the above criteria are considered invalid. A client MUST NOT attempt to make a connection to an invalid WebSocket URI. A client SHOULD attempt to parse a URI obtained from any external source (such as a web site or a user) using the steps specified in <a href="#parsing_ws_urls">Section 3.1</a> to obtain a valid WebSocket URI, but MUST NOT attempt to connect with such an unparsed URI, and instead only use the parsed version and only if that version is considered valid by the criteria above.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#framing" id="framing">Data Framing</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Overview</h1>
<p id="rfc.section.4.1.p.1">In the WebSocket protocol, data is transmitted using a sequence of frames. Frames sent from the client to the server are masked to avoid confusing network intermediaries, such as intercepting proxies. Frames sent from the server to the client are not masked.</p>
<p id="rfc.section.4.1.p.2">The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for extension and application data, which together define the <em>payload</em> data. Certain bits and opcodes are reserved for future expansion of the protocol. As such, in the absence of extensions negotiated during the opening handshake (<a href="#handshake">Section 5</a>), all reserved bits MUST be 0 and reserved opcode values MUST NOT be used.</p>
<p id="rfc.section.4.1.p.3">A data frame MAY be transmitted by either the client or the server at any time after handshake completion and before that endpoint has sent a close message (<a href="#closeframe">Section 4.5.1</a>).</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#baseframing" id="baseframing">Base Framing Protocol</a>
</h1>
<p id="rfc.section.4.2.p.1">This wire format for the data transfer part is described by the ABNF <a href="#RFC5234">[RFC5234]</a> given in detail in this section. A high level overview of the framing is given in the following figure.  <br><br> </p>
<div id="#rfc.figure.9"></div>
<pre>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-------+-+-------------+-------------------------------+
  |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
  |I|S|S|S|  (4)  |A|     (7)     |             (16/63)           |
  |N|V|V|V|       |S|             |   (if payload len==126/127)   |
  | |1|2|3|       |K|             |                               |
  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  |     Extended payload length continued, if payload len == 127  |
  + - - - - - - - - - - - - - - - +-------------------------------+
  |                               |Masking-key, if MASK set to 1  |
  +-------------------------------+-------------------------------+
  | Masking-key (continued)       |          Payload Data         |
  +-------------------------------- - - - - - - - - - - - - - - - +
  :                     Payload Data continued ...                :
  + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
  |                     Payload Data continued ...                |
  +---------------------------------------------------------------+
          </pre>
<p></p>

<dl>
<dt>FIN:</dt>
<dd style="margin-left: 8">1 bit <br><br> Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment.  </dd>
<dt>RSV1, RSV2, RSV3:</dt>
<dd style="margin-left: 8">1 bit each <br><br> Must be 0 unless an extension is negotiated which defines meanings for non-zero values </dd>
<dt>Opcode:</dt>
<dd style="margin-left: 8">4 bits <br><br> Defines the interpretation of the payload data </dd>
<dt>Mask:</dt>
<dd style="margin-left: 8">1 bit <br><br> Defines whether the payload data is masked. If set to 1, a masking key is present in Masking-key, and this is used to unmask the payload data as per <a href="#masking">Section 4.3</a>. All frames sent from client to server have this bit set to 1.  </dd>
<dt>Payload length:</dt>
<dd style="margin-left: 8">7 bits, 7+16 bits, or 7+64 bits <br><br> The length of the payload: if 0-125, that is the payload length.  If 126, the following 2 bytes interpreted as a 16 bit unsigned integer are the payload length.  If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. Multibyte length quantities are expressed in network byte order. The payload length is the length of the Extension data + the length of the Application data. The length of the Extension data may be zero, in which case the Payload length is the length of the Application data. The length of this field is always at least 7 bits. If the value of the first 7 bits is 0-125, the length of this field is 7 bits. If the value is 126, there exist 16 additional bits with a 16-bit length. If the value is 127, there exist 64 additional bits with a 63-bit length (the most significant bit MUST be 0).  </dd>
<dt>Masking-key:</dt>
<dd style="margin-left: 8">0 or 4 bytes <br><br> All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the Mask bit is set to 1, and is absent if the Mask bit is set to 0. See <a href="#masking">Section 4.3</a> for further information on client-to-server masking.  </dd>
<dt>Payload data:</dt>
<dd style="margin-left: 8">n bytes <br><br> The payload data is defined as Extension Data concatenated with Application Data.  </dd>
<dt>Extension data:</dt>
<dd style="margin-left: 8">n bytes <br><br> The extension data is 0 bytes unless an extension has been negotiated. Any extension MUST specify the length of the extension data, or how that length may be calculated, and how the extension use MUST be negotiated during the handshake.  If present, the extension data is included in the total payload length.  </dd>
<dt>Application data:</dt>
<dd style="margin-left: 8">n bytes <br><br> Arbitrary application data, taking up the remainder of the frame after any extension data. The length of the Application data is equal to the payload length minus the length of the Extension data.  </dd>
</dl>
<p id="rfc.section.4.2.p.3">The base framing protocol is formally defined by the following ABNF <a href="#RFC5234">[RFC5234]</a>:</p>
<div id="#rfc.figure.10"></div>
<pre>
   ws-frame                = frame-fin
                             frame-rsv1
                             frame-rsv2
                             frame-rsv3
                             frame-opcode
                             frame-masked
                             frame-payload-length
                             [ frame-masking-key ]
                             frame-payload-data

   frame-fin               = %x0 ; more frames of this message follow
                           / %x1 ; final frame of message

   frame-rsv1              = %x0 ; 1 bit, MUST be 0

   frame-rsv2              = %x0 ; 1 bit, MUST be 0

   frame-rsv3              = %x0 ; 1 bit, MUST be 0

   frame-opcode            = %x0 ; continuation frame
                           / %x1 ; text frame
                           / %x2 ; binary frame
                           / %3-7 ; reserved for further non-control frames
                           / %x8 ; connection close
                           / %x9 ; ping
                           / %xA ; pong
                           / %xB-F ; reserved for further control frames

   frame-masked            = %x0 ; frame is not masked, no frame-masking-key
                           = %x1 ; frame is masked, frame-masking-key present

   frame-payload-length    = %x00-7D
                           / %x7E frame-payload-length-16
                           / %x7F frame-payload-length-63

   frame-payload-length-16 = %x0000-FFFF

   frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF

   frame-masking-key       = &lt;4&gt;( %0x00-FF ) ; present only if frame-masked is 1

   frame-payload-data      = (frame-masked-extension-data
                              frame-masked-application-data)   ; frame-masked 1
                           / (frame-unmasked-extension-data
                              frame-unmasked-application-data) ; frame-masked 0

   frame-masked-extension-data     = *( %x00-FF ) ; to be defined later

   frame-masked-application-data   = *( %x00-FF )

   frame-unmasked-extension-data   = *( %x00-FF ) ; to be defined later

   frame-unmasked-application-data = *( %x00-FF )
</pre>
<p></p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#masking" id="masking">Client-to-Server Masking</a>
</h1>
<p id="rfc.section.4.3.p.1">The client MUST mask all frames sent to the server. A server MUST close the connection upon receiving a frame with the MASK bit set to 0.  In this case, a server MAY send a close frame with a status code of 1002 (protocol error) as defined in <a href="#closestatus">Section 7.4.1</a>.  </p>
<p id="rfc.section.4.3.p.2">A masked frame MUST have the field frame-masked set to 1, as defined in <a href="#baseframing">Section 4.2</a>.  </p>
<p id="rfc.section.4.3.p.3">The masking key is contained completely within the frame, as defined in <a href="#baseframing">Section 4.2</a> as frame-masking-key. It is used to mask the payload data defined in the same section as frame-payload-data, which includes extension and application data.</p>
<p id="rfc.section.4.3.p.4">The masking key is a 32-bit value chosen at random by the client.  The masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server to predict the masking key for a subsequent frame.</p>
<p id="rfc.section.4.3.p.5">The masking does not affect the length of the payload data. To convert masked data into unmasked data, or vice versa, the following algorithm is applied. The same algorithm applies regardless of the direction of the translation - e.g. the same steps are applied to mask the data as to unmask the data.</p>
<p id="rfc.section.4.3.p.6">Octet i of the transformed data ("transformed-octet-i") is the XOR of octet i of the original data ("original-octet-i") with octet i modulo 4 of the masking key ("masking-key-octet-j"):</p>
<div id="#rfc.figure.11"></div>
<pre>
  j                   = i MOD 4
  transformed-octet-i = original-octet-i XOR masking-key-octet-j
            
          </pre>
<p id="rfc.section.4.3.p.7">When preparing a masked frame, the client MUST pick a fresh masking key uniformly at random from the set of allowed 32-bit values. The unpredictability of the masking-nonce is essential to prevent the author of malicious application data from selecting the bytes that appear on the wire.</p>
<p id="rfc.section.4.3.p.8">The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. It is the length of the payload data, e.g. the number of bytes following the masking key.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Fragmentation</h1>
<p id="rfc.section.4.4.p.1">The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn't be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before first byte is sent. With fragmentation, a server or intermediary may choose a reasonable size buffer, and when the buffer is full write a fragment to the network.  </p>
<p id="rfc.section.4.4.p.2">A secondary use-case for fragmentation is for multiplexing, where it is not desirable for a large message on one logical channel to monopolize the output channel, so the MUX needs to be free to split the message into smaller fragments to better share the output channel.  </p>
<p id="rfc.section.4.4.p.3">The following rules apply to fragmentation: </p>

<ul>
<li>An unfragmented message consists of a single frame with the FIN bit set and an opcode other than 0.</li>
<li>A fragmented message consists of a single frame with the FIN bit clear and an opcode other than 0, followed by zero or more frames with the FIN bit clear and the opcode set to 0, and terminated by a single frame with the FIN bit set and an opcode of 0. Its content is the concatenation of the application data (and any extension data that may be present) from each of those frames in order. As an example, for a text message sent as three fragments, the first fragment would have an opcode of 0x4 and a FIN bit clear, the second fragment would have an opcode of 0x0 and a FIN bit clear, and the third fragment would have an opcode of 0x0 and a FIN bit that is set.</li>
<li>Control frames MAY be injected in the middle of a fragmented message. Control frames themselves MUST NOT be fragmented.</li>
<li>An endpoint MUST be capable of handling control frames in the middle of a fragmented message.</li>
<li><em>Note: if control frames could not be interjected, the latency of a ping, for example, would be very long if behind a large message. Hence, the requirement of handling control frames in the middle of a fragmented message.</em></li>
<li>A sender MAY create fragments of any size for non control messages.</li>
<li>Clients and servers MUST support receiving both fragmented and unfragmented messages.  </li>
<li>As control frames cannot be fragmented, an intermediary MUST NOT attempt to change the fragmentation of a control frame.</li>
<li>An intermediary MUST NOT change the fragmentation of a message if any reserved bit values are used and the meaning of these values is not known to the intermediary.</li>
<li>An intermediary MUST NOT change the fragmentation of any message in the context of a connection where extensions have been negotiated and the intermediary is not aware of the semantics of the negotiated extensions.</li>
<li>As a consequence of these rules, all fragments of a message are of the same type, as set by the first fragment&#8217;s opcode. Since Control frames cannot be fragmented, the type for all fragments in a message MUST be either text or binary, or one of the reserved opcodes.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#controlframes" id="controlframes">Control Frames</a>
</h1>
<p id="rfc.section.4.5.p.1">Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.</p>
<p id="rfc.section.4.5.p.2">Control frames are used to communicate state about the websocket. Control frames can be interjected in the middle of a fragmented message.  </p>
<p id="rfc.section.4.5.p.3">All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.</p>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#closeframe" id="closeframe">Close</a>
</h1>
<p id="rfc.section.4.5.1.p.1">The Close message contains an opcode of 0x8.</p>
<p id="rfc.section.4.5.1.p.2">The Close message MAY contain a body (the "application data" portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a message too large, or an endpoint having received a message that does not conform to the format expected by the other endpoint. If there is a body, the first two bytes of the body MUST be a 2-byte integer (in network byte order) representing a status code defined in <a href="#status_codes">Section 7.4</a>. Following the 2-byte integer the body MAY contain UTF-8 encoded data, the interpretation of which is not defined by this specification. This data is not necessarily human readable, but may be useful for debugging or passing information relevant to the script that opened the connection.</p>
<p id="rfc.section.4.5.1.p.3">The application MUST NOT send any more data frames after sending a close message.</p>
<p id="rfc.section.4.5.1.p.4">If an endpoint receives a Close message and that endpoint did not previously send a Close message, the endpoint MUST send a Close message in response. It SHOULD do so as soon as is practical.  </p>
<p id="rfc.section.4.5.1.p.5">After both sending and receiving a close message, an endpoint considers the websocket connection closed, and SHOULD close the underlying TCP connection.</p>
<p id="rfc.section.4.5.1.p.6">If a client and server both send a Close message at the same time, both endpoints will have sent and received a Close message and should consider the websocket connection closed and close the underlying TCP connection.</p>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> Ping</h1>
<p id="rfc.section.4.5.2.p.1">The Ping message contains an opcode of 0x9.</p>
<p id="rfc.section.4.5.2.p.2">Upon receipt of a Ping message, an endpoint MUST send a Pong message in response. It SHOULD do so as soon as is practical. The message bodies (i.e. both the Extension data (if any) and the Application data) of the Ping and Pong MUST be the same.  </p>
<p id="rfc.section.4.5.2.p.3">An endpoint MAY send a Ping message any time after the connection is established and before the connection is closed. NOTE: A ping message may serve either as a keepalive, or to verify that the remote endpoint is still responsive.</p>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> Pong</h1>
<p id="rfc.section.4.5.3.p.1">The Pong message contains an opcode of 0xA.</p>
<p id="rfc.section.4.5.3.p.2">Upon receipt of a Ping message, an endpoint MUST send a Pong message in response. It SHOULD do so as soon as is practical. The message bodies (i.e. both the Extension data (if any) and the Application data) of the Ping and Pong MUST be the same. In the case multiple Pings have been received, a Pong MUST be issued only in response to the most recent Ping.</p>
<p id="rfc.section.4.5.3.p.3">A Pong message MAY be sent unsolicited. This serves as a unidirectional heartbeat. A response to an unsolicited pong is not expected.</p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> Data Frames</h1>
<p id="rfc.section.4.6.p.1">Data frames (e.g. non control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.</p>
<p id="rfc.section.4.6.p.2">Data frames carry application-layer or extension-layer data. The opcode determines the interpretation of the data: </p>

<dl>
<dt>Text</dt>
<dd style="margin-left: 8">
<br><br> The payload data is text data encoded as UTF-8.  </dd>
<dt>Binary</dt>
<dd style="margin-left: 8">
<br><br> The payload data is arbitrary binary data whose interpretation is solely up to the application layer.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> Examples</h1>
<p><em>This section is non-normative.</em></p>
<p></p>

<ul>
<li>A single-frame unmasked text message <ul><li>0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains "Hello")</li></ul>
<p> </p>
</li>
<li>A single-frame masked text message <ul><li>0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains "Hello")</li></ul>
<p> </p>
</li>
<li>A fragmented unmasked text message <ul>
<li>0x01 0x03 0x48 0x65 0x6c (contains "Hel")</li>
<li>0x80 0x02 0x6c 0x6f (contains "lo")</li>
</ul>
<p> </p>
</li>
<li>Ping request and response <ul>
<li>0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of "Hello", but the contents of the body are arbitrary)</li>
<li>0x8a 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of "Hello", matching the body of the ping)</li>
</ul>
<p> </p>
</li>
<li>256 bytes binary message in a single unmasked frame <ul><li>0x82 0x7E 0x0100 [256 bytes of binary data]</li></ul>
<p> </p>
</li>
<li>64KiB binary message in a single unmasked frame <ul><li>0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]</li></ul>
<p> </p>
</li>
</ul>
<h1 id="rfc.section.4.8">
<a href="#rfc.section.4.8">4.8.</a> Extensibility</h1>
<p id="rfc.section.4.8.p.1">The protocol is designed to allow for extensions, which will add capabilities to the base protocols. The endpoints of a connection MUST negotiate the use of any extensions during the handshake. This specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the extension data field, and the frame-rsv1, frame-rsv2, and frame-rsv3 bits of the frame header for use by extensions. The negotiation of extensions is discussed in further detail in <a href="#negotiation">Section 8.1</a>.  Below are some anticipated uses of extensions. This list is neither complete nor proscriptive.  </p>

<ul>
<li>Extension data may be placed in the payload before the application data.</li>
<li>Reserved bits can be allocated for per-frame needs.</li>
<li>Reserved opcode values can be defined.</li>
<li>Reserved bits can be allocated to the opcode field if more opcode values are needed.</li>
<li>A reserved bit or an "extension" opcode can be defined which allocates additional bits out of the payload area to define larger opcodes or more per-frame bits.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#handshake" id="handshake">Opening Handshake</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> Client Requirements</h1>
<p id="rfc.section.5.1.p.1">User agents running in controlled environments, e.g. browsers on mobile handsets tied to specific carriers, may offload the management of the connection to another agent on the network. In such a situation, the user agent for the purposes of conformance is considered to include both the handset software and any such agents.</p>
<div id="#rfc.figure.12"></div>
<pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
              </pre>
<div id="#rfc.figure.13"></div>
<pre>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
              </pre>
<p id="rfc.section.5.1.p.2">When the user agent is to <strong>establish a WebSocket connection</strong> given either a WebSocket URI /uri/ or the constituent components of a URI as specified in <a href="#otherspecs">Section 11</a>, it MUST meet the following requirements. In the following text, we will use terms from <a href="#ws_urls">Section 3</a> such as "/host/" and "/secure/ flag" as defined in that section.  </p>

<ol>
<li>The WebSocket URI and its components derived by applying the steps defined in <a href="#valid_ws_urls">Section 3.3</a>, or if the following algorithm was supplied with the constituent components as defined in <a href="#otherspecs">Section 11</a> then those components provided, MUST be valid according to <a href="#valid_ws_urls">Section 3.3</a>. If any of the requirements are not met, the client MUST fail the WebSocket connection and abort these steps.</li>
<li>If the user agent already has a WebSocket connection to the remote host (IP address) identified by /host/ and port /port/ pair, even if the remote host is known by another name, the user agent MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in a CONNECTING state. If multiple connections to the same IP address are attempted simultaneously, the user agent MUST serialize them so that there is no more than one connection at a time running through the following steps.  <br><br> If the user agent cannot determine the IP address of the remote host (for example because all communication is being done through a proxy server that performs DNS queries itself), then the user agent MUST assume for the purposes of this step that each host name refers to a distinct remote host, but should instead limit the total number of simultaneous connections that are not established to a reasonably low number (e.g., in a Web browser, to the number of tabs the user has open).  <br><br> NOTE: This makes it harder for a script to perform a denial of service attack by just opening a large number of WebSocket connections to a remote host. A server can further reduce the load on itself when attacked by making use of this by pausing before closing the connection, as that will reduce the rate at which the client reconnects.  <br><br> NOTE: There is no limit to the number of established WebSocket connections a user agent can have with a single remote host.  Servers can refuse to accept connections from hosts with an excessive number of existing connections, or disconnect resource-hogging connections when suffering high load.</li>
<li>
<em>Proxy Usage</em>: If the user agent is configured to use a proxy when using the WebSocket protocol to connect to host /host/ and/or port /port/, then the user agent SHOULD connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.  <ul class="empty">
<li>EXAMPLE: For example, if the user agent uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server: <br><br> </li>
<li>If there was a password, the connection might look like: <br><br> </li>
</ul>
<p> If the user agent is not configured to use a proxy, then a direct TCP connection SHOULD be opened to the host given by /host/ and the port given by /port/.  </p>
<br><br> NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.  <br><br> For the purpose of proxy autoconfiguration scripts, the URI to pass the function MUST be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the steps to construct a WebSocket URI as given in <a href="#constructwsuri">Section 3.2</a>.  <br><br> NOTE: The WebSocket protocol can be identified in proxy autoconfiguration scripts from the scheme ("ws:" for unencrypted connections and "wss:" for encrypted connections).</li>
<li>If the connection could not be opened, either because a direct connection failed or because any proxy used returned an error, then the user agent MUST fail the WebSocket connection and abort the connection attempt.</li>
<li>If /secure/ is true, the user agent MUST perform a TLS handshake over the connection <a href="#RFC2818">[RFC2818]</a>. If this fails (e.g. the server's certificate could not be verified), then the user agent MUST fail the WebSocket connection and abort the connection. Otherwise, all further communication on this channel MUST run through the encrypted tunnel. <a href="#RFC5246">[RFC5246]</a> <br><br> User agents MUST use the Server Name Indication extension in the TLS handshake. <a href="#RFC6066">[RFC6066]</a>
</li>
</ol>

<p> </p>
<p id="rfc.section.5.1.p.3">Once a connection to the server has been established (including a connection via a proxy or over a TLS-encrypted tunnel), the client MUST send a handshake to the server. The handshake consists of an HTTP upgrade request, along with a list of required and optional headers.  The requirements for this handshake are as follows.  </p>

<ol>
<li>The handshake MUST be a valid HTTP request as specified by <a href="#RFC2616">[RFC2616]</a>.</li>
<li>The Method of the request MUST be GET and the HTTP version MUST be at least 1.1.  <br><br> For example, if the WebSocket URI is "ws://example.com/chat", The first line sent should be "GET /chat HTTP/1.1"</li>
<li>The request MUST contain a "Request-URI" as part of the GET method. This MUST match the /resource name/ <a href="#ws_urls">Section 3</a>.</li>
<li>The request MUST contain a "Host" header whose value is equal to /host/</li>
<li>The request MUST contain an "Upgrade" header whose value is equal to "websocket".</li>
<li>The request MUST contain a "Connection" header whose value MUST include the "Upgrade" token.</li>
<li>The request MUST include a header with the name "Sec-WebSocket-Key". The value of this header MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded <a href="#RFC3548">[RFC3548]</a>. The nonce MUST be selected randomly for each connection. <br><br> NOTE: As an example, if the randomly selected value was the sequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header would be "AQIDBAUGBwgJCgsMDQ4PEC=="</li>
<li>The request MUST include a header with the name "Sec-WebSocket-Origin" if the request is coming from a browser client. If the connection is from a non-browser client, the request MAY include this header if the semantics of that client match the use-case described here for browser clients.  The value of this header MUST be the ASCII serialization of origin of the context in which the code establishing the connection is running, and MUST be lower-case.  The value MUST NOT contain letters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) <a href="#I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</a>.  <br><br> As an example, if code is running on www.example.com attempting to establish a connection to ww2.example.com, the value of the header would be "http://www.example.com".</li>
<li>The request MUST include a header with the name "Sec-WebSocket-Version". The value of this header MUST be 7.  </li>
<li>The request MAY include a header with the name "Sec-WebSocket-Protocol". If present, this value indicates the subprotocol(s) the client wishes to speak. The elements that comprise this value MUST be non-empty strings with characters in the range U+0021 to U+007E and MUST all be unique strings. The ABNF for the value of this header is 1#(token | quoted-string), where the definitions of constructs and rules are as given in <a href="#RFC2616">[RFC2616]</a>.</li>
<li>The request MAY include a header with the name "Sec-WebSocket-Extensions". If present, this value indicates the protocol-level extension(s) the client wishes to speak. The interpretation and format of this header is described in <a href="#negotiation">Section 8.1</a>.</li>
<li>The request MAY include headers associated with sending cookies, as defined by the appropriate specifications <a href="#I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</a>.</li>
</ol>

<p> </p>
<p id="rfc.section.5.1.p.4">Once the client's opening handshake has been sent, the client MUST wait for a response from the server before sending any further data.  The client MUST validate the server's response as follows: </p>

<ul>
<li>If the status code received from the server is not 101, the client handles the response per HTTP procedures. Otherwise, proceed as follows.</li>
<li>If the response lacks an Upgrade header or the Upgrade header contains a value that is not an ASCII case-insensitive match for the value "websocket", the client MUST fail the WebSocket connection.</li>
<li>If the response lacks a Connection header or the Connection header contains a value that is not an ASCII case-insensitive match for the value "Upgrade", the client MUST fail the WebSocket connection.</li>
<li>If the response lacks a Sec-WebSocket-Accept header or the Sec-WebSocket-Accept contains a value other than the base64-encoded SHA-1 of the concatenation of the Sec-WebSocket-Key (as a string, not base64-decoded) with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", the client MUST fail the WebSocket connection.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.p.5">Where the algorithm above requires that a user agent fail the WebSocket connection, the user agent MAY first read an arbitrary number of further bytes from the connection (and then discard them) before actually <strong>failing the WebSocket connection</strong>. Similarly, if a user agent can show that the bytes read from the connection so far are such that there is no subsequent sequence of bytes that the server can send that would not result in the user agent being required to <strong>fail the WebSocket connection</strong>, the user agent MAY immediately <strong>fail the WebSocket connection</strong> without waiting for those bytes.</p>
<p id="rfc.section.5.1.p.6">NOTE: The previous paragraph is intended to make it conforming for user agents to implement the algorithm in subtly different ways that are equivalent in all ways except that they terminate the connection at earlier or later points. For example, it enables an implementation to buffer the entire handshake response before checking it, or to verify each field as it is received rather than collecting all the fields and then checking them as a block.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Server-side requirements</h1>
<p><em>This section only applies to servers.</em></p>
<p id="rfc.section.5.2.p.2">Servers MAY offload the management of the connection to other agents on the network, for example load balancers and reverse proxies.  In such a situation, the server for the purposes of conformance is considered to include all parts of the server-side infrastructure from the first device to terminate the TCP connection all the way to the server that processes requests and sends responses.</p>
<p id="rfc.section.5.2.p.3">EXAMPLE: For example, a data center might have a server that responds to WebSocket requests with an appropriate handshake, and then passes the connection to another server to actually process the data frames. For the purposes of this specification, the "server" is the combination of both computers.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> Reading the client's opening handshake</h1>
<p id="rfc.section.5.2.1.p.1">When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.</p>
<p id="rfc.section.5.2.1.p.2">The client handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below, the server MUST abort the WebSocket connection.  </p>

<ol>
<li>An HTTP/1.1 or higher GET request, including a "Request-URI" <a href="#RFC2616">[RFC2616]</a> that should be interpreted as a /resource name/ <a href="#ws_urls">Section 3</a>. </li>
<li>A "Host" header containing the server's authority.</li>
<li>A "Sec-WebSocket-Key" header with a base64-encoded value that, when decoded, is 16 bytes in length.</li>
<li>A "Sec-WebSocket-Version" header, with a value of 7.</li>
<li>Optionally, a "Sec-WebSocket-Origin" header. This header is sent by all browser clients. A connection attempt lacking this header SHOULD NOT be interpreted as coming from a browser client.</li>
<li>Optionally, a "Sec-WebSocket-Protocol" header, with a list of values indicating which protocols the client would like to speak, ordered by preference.</li>
<li>Optionally, a "Sec-WebSocket-Extensions" header, with a list of values indicating which extensions the client would like to speak. The interpretation of this header is discussed in <a href="#negotiation">Section 8.1</a>.</li>
<li>Optionally, other headers, such as those used to send cookies to a server. Unknown headers MUST be ignored.</li>
</ol>

<p> </p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#server_handshake" id="server_handshake">Sending the server's opening handshake</a>
</h1>
<p id="rfc.section.5.2.2.p.1">When a client establishes a WebSocket connection to a server, the server MUST complete the following steps to accept the connection and send the server's opening handshake.  </p>

<ol>
<li>If the server supports encryption, perform a TLS handshake over the connection. If this fails (e.g. the client indicated a host name in the extended client hello "server_name" extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server handshake) MUST run through the encrypted tunnel. <a href="#RFC5246">[RFC5246]</a>
</li>
<li>Establish the following information: <dl>
<dt>/origin/</dt>
<dd style="margin-left: 8">
<br> The |Sec-WebSocket-Origin| header in the client's handshake indicates the origin of the script establishing the connection.  The origin is serialized to ASCII and converted to lowercase.  The server MAY use this information as part of a determination of whether to accept the incoming connection. If the server does not validate the origin, it will accept connections from anywhere.  For more detail, refer to <a href="#securityconsiderations">Section 9</a>.</dd>
<dt>/key/</dt>
<dd style="margin-left: 8">
<br> The |Sec-WebSocket-Key| header in the client's handshake includes a base64-encoded value that, if decoded, is 16 bytes in length. This (encoded) value is used in the creation of the server's handshake to indicate an acceptance of the connection. It is not necessary for the server to base64-decode the Sec-WebSocket-Key value.</dd>
<dt>/version/</dt>
<dd style="margin-left: 8">
<br> The |Sec-WebSocket-Version| header in the client's handshake includes the version of the WebSocket protocol the client is attempting to communicate with. If this version does not match a version understood by the server, the server MUST abort the WebSocket connection. The server MAY send a non-200 response code with a |Sec-WebSocket-Version| header indicating the version(s) the server is capable of understanding.</dd>
<dt>/resource name/</dt>
<dd style="margin-left: 8">
<br> An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client's handshake from the Request-URI <a href="#RFC2616">[RFC2616]</a> of the GET method.</dd>
<dt>/subprotocol/</dt>
<dd style="margin-left: 8">
<br> Either a single value or null, representing the subprotocol the server is ready to use. If the server supports multiple subprotocols, then the value MUST be derived from the client's handshake, specifically by selecting one of the values from the "Sec-WebSocket-Protocol" field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes, and is not a legal value for this field. The ABNF for the value of this header is (token | quoted-string), where the definitions of constructs and rules are as given in <a href="#RFC2616">[RFC2616]</a>.</dd>
<dt>/extensions/</dt>
<dd style="margin-left: 8">
<br> A (possibly empty) list representing the protocol-level extensions the server is ready to use. If the server supports multiple extensions, then the value MUST be derived from the client's handshake, specifically by selecting one or more of the values from the "Sec-WebSocket-Extensions" field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes. Extensions not listed by the client MUST NOT be listed.  The method by which these values should be selected and interpreted is discussed in <a href="#negotiation">Section 8.1</a>.</dd>
</dl>
<p> </p>
</li>
<li>If the server chooses to accept the incoming connection, it MUST reply with a valid HTTP response indicating the following.  <ol>
<li>A 101 response code. Such a response could look like "HTTP/1.1 101 Switching Protocols"</li>
<li>A "Sec-WebSocket-Accept" header. The value of this header is constructed by concatenating /key/, defined above in <a href="#server_handshake_info">[server_handshake_info]</a> of <a href="#server_handshake">Section 5.2.2</a>, with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this concatenated value to obtain a 20-byte value, and base64-encoding this 20-byte hash.  <br><br> NOTE: As an example, if the value of the "Sec-WebSocket-Key" header in the client's handshake were "dGhlIHNhbXBsZSBub25jZQ==", the server would append the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11".  The server would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", which would be returned in the "Sec-WebSocket-Accept" header.</li>
<li>Optionally, a "Sec-WebSocket-Protocol" header, with a value /subprotocol/ as defined in <a href="#server_handshake_info">[server_handshake_info]</a> of <a href="#server_handshake">Section 5.2.2</a>.</li>
<li>Optionally, a "Sec-WebSocket-Extensions" header, with a value /extensions/ as defined in <a href="#server_handshake_info">[server_handshake_info]</a> of <a href="#server_handshake">Section 5.2.2</a>.</li>
</ol>
<p> </p>
</li>
</ol>

<p> </p>
<p id="rfc.section.5.2.2.p.2">This completes the server's handshake. If the server finishes these steps without aborting the WebSocket connection, and if the client does not then fail the WebSocket connection, then the connection is established and the server may begin sending and receiving data.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Error Handling</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Handling errors in UTF-8 from the server</h1>
<p id="rfc.section.6.1.p.1">When a client is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, then any bytes or sequences of bytes that are not valid UTF-8 sequences MUST be interpreted as a U+FFFD REPLACEMENT CHARACTER.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#utf8errorclient" id="utf8errorclient">Handling errors in UTF-8 from the client</a>
</h1>
<p id="rfc.section.6.2.p.1">When a server is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, behavior is undefined. A server could close the connection, convert invalid byte sequences to U+FFFD REPLACEMENT CHARACTERs, store the data verbatim, or perform application-specific processing. Subprotocols layered on the WebSocket protocol might define specific behavior for servers.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#closing_connection" id="closing_connection">Closing the connection</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Definitions</h1>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#close_wsc" id="close_wsc">Close the WebSocket Connection</a>
</h1>
<p id="rfc.section.7.1.1.p.1">To <em>Close the WebSocket Connection</em>, an endpoint closes the underlying TCP connection. An endpoint SHOULD use a method that cleanly closes the TCP connection, as well as the TLS session, if applicable, discarding any trailing bytes that may be received. An endpoint MAY close the connection via any means available when necessary, such as when under attack.  </p>
<p id="rfc.section.7.1.1.p.2">As an example of how to obtain a clean closure in C using Berkeley sockets, one would call shutdown() with SHUT_WR on the socket, call recv() until obtaining a return value of 0 indicating that the peer has also performed an orderly shutdown, and finally calling close() on the socket.  </p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#start_closing" id="start_closing">Start the WebSocket Closing Handshake</a>
</h1>
<p id="rfc.section.7.1.2.p.1">To <em>start the WebSocket closing handshake</em>, an endpoint MUST send a Close control frame, as described in <a href="#closeframe">Section 4.5.1</a>.  Once an endpoint has both sent and received a Close control frame, that endpoint SHOULD <em>Close the WebSocket Connection</em> as defined in <a href="#close_wsc">Section 7.1.1</a>.  </p>
<h1 id="rfc.section.7.1.3">
<a href="#rfc.section.7.1.3">7.1.3.</a> <a href="#is_closed" id="is_closed">The WebSocket Connection Is Closed</a>
</h1>
<p id="rfc.section.7.1.3.p.1">When the underlying TCP connection is closed, it is said that <em>the WebSocket connection is closed</em>.  If the tcp connection was closed after the WebSocket closing handshake was completed, the WebSocket connection is said to have been closed <em>cleanly</em>.  </p>
<h1 id="rfc.section.7.1.4">
<a href="#rfc.section.7.1.4">7.1.4.</a> <a href="#fail_ws" id="fail_ws">Fail the WebSocket Connection</a>
</h1>
<p id="rfc.section.7.1.4.p.1">Certain algorithms and specifications require a user agent to <em>fail the WebSocket connection</em>. To do so, the user agent MUST <em>Close the WebSocket Connection</em>, and MAY report the problem to the user (which would be especially useful for developers) in an appropriate manner.  </p>
<p id="rfc.section.7.1.4.p.2">Except as indicated above or as specified by the application layer (e.g. a script using the WebSocket API), user agents SHOULD NOT close the connection.  </p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Abnormal closures</h1>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> Client-initiated closure</h1>
<p id="rfc.section.7.2.1.p.1">Certain algorithms, namely during the initial handshake, require the user agent to <strong>fail the WebSocket connection</strong>. To do so, the user agent MUST <em>Close the WebSocket connection</em> as previously defined, and MAY report the problem to the user via an appropriate mechanism (which would be especially useful for developers).  </p>
<p id="rfc.section.7.2.1.p.2">Except as indicated above or as specified by the application layer (e.g. a script using the WebSocket API), user agents SHOULD NOT close the connection.  </p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> Server-initiated closure</h1>
<p id="rfc.section.7.2.2.p.1">Certain algorithms require or recommend that the server <em>abort the WebSocket connection</em> during the opening handshake. To do so, the server MUST simply <em>close the WebSocket connection</em> (<a href="#close_wsc">Section 7.1.1</a>).  </p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> Normal closure of connections</h1>
<p id="rfc.section.7.3.p.1">Servers MAY close the WebSocket connection whenever desired. User agents SHOULD NOT close the WebSocket connection arbitrarily. In either case, an endpoint initiates a closure by following the procedures to <em>start the WebSocket closing handshake</em> (<a href="#start_closing">Section 7.1.2</a>).  </p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#status_codes" id="status_codes">Status codes</a>
</h1>
<p id="rfc.section.7.4.p.1">When closing an established connection (e.g. when sending a Close frame, after the handshake has completed), an endpoint MAY indicate a reason for closure. The interpretation of this reason by an endpoint, and the action an endpoint should take given this reason, are left undefined by this specification. This specification defines a set of pre-defined status codes, and specifies which ranges may be used by extensions, frameworks, and end applications. The status code and any associated textual message are optional components of a Close frame.  </p>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#closestatus" id="closestatus">Defined Status Codes</a>
</h1>
<p id="rfc.section.7.4.1.p.1">Endpoints MAY use the following pre-defined status codes when sending a Close frame.  </p>

<dl>
<dt>1000</dt>
<dd style="margin-left: 8">
<br><br> 1000 indicates a normal closure, meaning whatever purpose the connection was established for has been fulfilled.  </dd>
<dt>1001</dt>
<dd style="margin-left: 8">
<br><br> 1001 indicates that an endpoint is "going away", such as a server going down, or a browser having navigated away from a page.  </dd>
<dt>1002</dt>
<dd style="margin-left: 8">
<br><br> 1002 indicates that an endpoint is terminating the connection due to a protocol error.  </dd>
<dt>1003</dt>
<dd style="margin-left: 8">
<br><br> 1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g.  an endpoint that understands only text data MAY send this if it receives a binary message).  </dd>
<dt>1004</dt>
<dd style="margin-left: 8">
<br><br> 1004 indicates that an endpoint is terminating the connection because it has received a message that is too large.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> Reserved status code ranges</h1>
<p></p>

<dl>
<dt>0-999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 0-999 are not used.  </dd>
<dt>1000-1999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 1000-1999 are reserved for definition by this protocol.  </dd>
<dt>2000-2999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 2000-2999 are reserved for use by extensions.  </dd>
<dt>3000-3999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 3000-3999 MAY be used by libraries and frameworks. The interpretation of these codes is undefined by this protocol. End applications MUST NOT use status codes in this range.  </dd>
<dt>4000-4999</dt>
<dd style="margin-left: 8">
<br><br> Status codes in the range 4000-4999 MAY be used by application code. The interpretation of these codes is undefined by this protocol.  </dd>
</dl>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#extensions" id="extensions">Extensions</a>
</h1>
<p id="rfc.section.8.p.1">WebSocket clients MAY request extensions to this specification, and WebSocket servers MAY accept some or all extensions requested by the client. A server MUST NOT respond with any extension not requested by the client. If extension parameters are included in negotiations between the client and the server, those parameters MUST be chosen in accordance with the specification of the extension to which the parameters apply.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#negotiation" id="negotiation">Negotiating extensions</a>
</h1>
<p id="rfc.section.8.1.p.1">A client requests extensions by including a "Sec-WebSocket-Extensions" header, which follows the normal rules for HTTP headers (see <a href="#RFC2616">[RFC2616]</a> section 4.2) and the value of the header is defined by the following ABNF. Note that unlike other section of the document this section is using ABNF syntax/rules from <a href="#RFC2616">[RFC2616]</a>.</p>
<div id="#rfc.figure.14"></div>
<pre>
      extension-list = 1#extension
      extension = extension-token *( ";" extension-param )
      extension-token = registered-token | private-use-token
      registered-token = token
      private-use-token = "x-" token
      extension-param = token [ "=" ( token | quoted-string ) ]
          </pre>
<p id="rfc.section.8.1.p.2">Note that like other HTTP headers, this header MAY be split or combined across multiple lines. Ergo, the following are equivalent:</p>
<div id="#rfc.figure.15"></div>
<pre>
      Sec-WebSocket-Extensions: foo
      Sec-WebSocket-Extensions: bar; baz=2
          </pre>
<p id="rfc.section.8.1.p.3">is exactly equivalent to</p>
<div id="#rfc.figure.16"></div>
<pre>
      Sec-WebSocket-Extensions: foo, bar; baz=2
          </pre>
<p id="rfc.section.8.1.p.4">Any extension-token used MUST either be a registered token (registration TBD), or have a prefix of "x-" to indicate a private-use token. The parameters supplied with any given extension MUST be defined for that extension. Note that the client is only offering to use any advertised extensions, and MUST NOT use them unless the server indicates that it wishes to use the extension.</p>
<p id="rfc.section.8.1.p.5">Note that the order of extensions is significant. Any interactions between multiple extensions MAY be defined in the documents defining the extensions. In the absence of such definition, the interpretation is that the headers listed by the client in its request represent a preference of the headers it wishes to use, with the first options listed being most preferable. The extensions listed by the server in response represent the extensions actually in use for the connection.  Should the extensions modify the data and/or framing, the order of operations on the data should be assumed to be the same as the order in which the extensions are listed in the server's response in the opening handshake.</p>
<p id="rfc.section.8.1.p.6">For example, if there are two extensions "foo" and "bar", if the header |Sec-WebSocket-Extensions| sent by the server has the value "foo, bar" then operations on the data will be made as bar(foo(data)), be those changes to the data itself (such as compression) or changes to the framing thay may "stack".</p>
<p id="rfc.section.8.1.p.7">Non-normative examples of acceptable extension headers:</p>
<div id="#rfc.figure.17"></div>
<pre>
      Sec-WebSocket-Extensions: deflate-stream
      Sec-WebSocket-Extensions: mux; max-channels=4; flow-control, deflate-stream
      Sec-WebSocket-Extensions: x-private-extension
          </pre>
<p id="rfc.section.8.1.p.8">A server accepts one or more extensions by including a |Sec-WebSocket-Extensions| header containing one or more extensions which were requested by the client. The interpretation of any extension parameters, and what constitutes a valid response by a server to a requested set of parameters by a client, will be defined by each such extension.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Known extensions</h1>
<p id="rfc.section.8.2.p.1">Extensions provide a mechanism for implementations to opt-in to additional protocol features. This section defines the meaning of well-known extensions but implementations MAY use extensions defined separately as well.</p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> Compression</h1>
<p id="rfc.section.8.2.1.p.1">The registered extension token for this compression extension is "deflate-stream".</p>
<p id="rfc.section.8.2.1.p.2">The extension does not have any per message extension data and it does not define the use of any WebSocket reserved bits or op codes.  </p>
<p id="rfc.section.8.2.1.p.3">Senders using this extension MUST apply RFC 1951 encodings to all bytes of the data stream following the handshake including both data and control messages. The data stream MAY include multiple blocks of both compressed and uncompressed types as defined by <a href="#RFC1951">[RFC1951]</a>.</p>
<p id="rfc.section.8.2.1.p.4">Senders MUST NOT delay the transmission of any portion of a WebSocket message because the deflate encoding of the message does not end on a byte boundary. The encodings for adjacent messages MAY appear in the same byte if no delay in transmission is occurred by doing so.</p>
<p id="rfc.section.8.2.1.p.5">Historically there have been some confusion and interoperability problems around the specification of compression algorithms. In this specification "deflate-stream" requires a <a href="#RFC1951">[RFC1951]</a> deflate encoding. It MUST NOT be wrapped in any of the header formats often associated with RFC 1951 such as "zlib" <a href="#RFC1950">[RFC1950]</a>. This requirement is given special attention with this note because of confusion in this area, the presence of some popular open source libraries that create both formats under a single API call with confusing naming conventions, and the fact that the popular HTTP <a href="#RFC2616">[RFC2616]</a> specification defines "deflate" compression differently than this specification.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#securityconsiderations" id="securityconsiderations">Security considerations</a>
</h1>
<p id="rfc.section.9.p.1">While this protocol is intended to be used by scripts in Web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf, and can therefore send fake "Origin" fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins, and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.</p>
<p id="rfc.section.9.p.2">EXAMPLE: For example, if the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.</p>
<p><br><br></p>
<p id="rfc.section.9.p.4">Servers that are not intended to process input from any Web page but only for certain sites SHOULD verify the "Origin" field is an origin they expect, and should only respond with the corresponding "Sec-WebSocket-Origin" if it is an accepted origin. Servers that only accept input from one origin can just send back that value in the "Sec-WebSocket-Origin" field, without bothering to check the client's value.</p>
<p><br><br></p>
<p id="rfc.section.9.p.6">If at any time a server is faced with data that it does not understand, or that violates some criteria by which the server determines safety of input, or when the server sees a handshake that does not correspond to the values the server is expecting (e.g. incorrect path or origin), the server SHOULD just disconnect. It is always safe to disconnect.</p>
<p><br><br></p>
<p id="rfc.section.9.p.8">The biggest security risk when sending text data using this protocol is sending data using the wrong encoding. If an attacker can trick the server into sending data encoded as ISO-8859-1 verbatim (for instance), rather than encoded as UTF-8, then the attacker could inject arbitrary frames into the data stream.</p>
<p><br><br></p>
<p id="rfc.section.9.p.10">In addition to endpoints being the target of attacks via WebSockets, other parts of web infrastructure, such as proxies, may be the subject of an attack. In particular, an intermediary may interpret a WebSocket message from a client as a request, and a message from the server as a response to that request. For instance, an attacker could get a browser to establish a connection to its server, get the browser to send a message that looks to an intermediary like a GET request for a common piece of JavaScript on another domain, and send back a message that is interpreted as a cacheable response to that request, thus poisioning the cache for other users. To prevent this attack, messages sent from clients are masked on the wire with a 32-bit value, to prevent an attacker from controlling the bits on the wire and thus lessen the probability of an attacker being able to construct a message that can be misinterpreted by a proxy as a non-WebSocket request.</p>
<p><br><br></p>
<p id="rfc.section.9.p.12">As mentioned in <a href="#utf8errorclient">Section 6.2</a>, servers must be extremely cautious interpreting invalid UTF-8 data from the client. A naive UTF-8 parsing implementation can result in buffer overflows in the case of invalid input data.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> IANA considerations</h1>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> Registration of ws: scheme</h1>
<div id="#rfc.figure.18"></div>
<pre>        "ws" ":" hier-part [ "?" query ]</pre>
<p id="rfc.section.10.1.p.1">A |ws:| URI identifies a WebSocket server and resource name.  </p>

<dl>
<dt>URI scheme name.</dt>
<dd style="margin-left: 8">
<br>ws </dd>
<dt>Status.</dt>
<dd style="margin-left: 8">
<br>Permanent.  </dd>
<dt>URI scheme syntax.</dt>
<dd style="margin-left: 8">
<br>In ABNF terms using the terminals from the URI specifications: <a href="#RFC5234">[RFC5234]</a><a href="#RFC3986">[RFC3986]</a><br><br><br><br> The &lt;path&gt; <a href="#RFC3986">[RFC3986]</a> and &lt;query&gt; components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.  </dd>
<dt>URI scheme semantics.</dt>
<dd style="margin-left: 8">
<br>The only operation for this scheme is to open a connection using the WebSocket protocol.  </dd>
<dt>Encoding considerations.</dt>
<dd style="margin-left: 8">
<br>Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by applying the IDNA ToASCII algorithm to the Unicode host name, with both the AllowUnassigned and UseSTD3ASCIIRules flags set, and using the result of this algorithm as the host in the URI. <a href="#RFC3490">[RFC3490]</a><br><br> Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specifications. <a href="#RFC3986">[RFC3986]</a> <a href="#RFC3987">[RFC3987]</a> </dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd style="margin-left: 8">
<br>WebSocket protocol.  </dd>
<dt>Interoperability considerations.</dt>
<dd style="margin-left: 8">
<br>None.  </dd>
<dt>Security considerations.</dt>
<dd style="margin-left: 8">
<br>See "Security considerations" section above.  </dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br>HYBI WG &lt;hybi@ietf.org&gt; </dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br>IETF &lt;iesg@ietf.org&gt; </dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
</dl>

<p> </p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> Registration of wss: scheme</h1>
<div id="#rfc.figure.19"></div>
<pre>        "wss" ":" hier-part [ "?" query ]</pre>
<p id="rfc.section.10.2.p.1">A |wss:| URI identifies a WebSocket server and resource name, and indicates that traffic over that connection is to be encrypted.  </p>

<dl>
<dt>URI scheme name.</dt>
<dd style="margin-left: 8">
<br>wss </dd>
<dt>Status.</dt>
<dd style="margin-left: 8">
<br>Permanent.  </dd>
<dt>URI scheme syntax.</dt>
<dd style="margin-left: 8">
<br>In ABNF terms using the terminals from the URI specifications: <a href="#RFC5234">[RFC5234]</a><a href="#RFC3986">[RFC3986]</a><br><br><br><br> The &lt;path&gt; and &lt;query&gt; components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.  </dd>
<dt>URI scheme semantics.</dt>
<dd style="margin-left: 8">
<br>The only operation for this scheme is to open a connection using the WebSocket protocol, encrypted using TLS.  </dd>
<dt>Encoding considerations.</dt>
<dd style="margin-left: 8">
<br>Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by applying the IDNA ToASCII algorithm to the Unicode host name, with both the AllowUnassigned and UseSTD3ASCIIRules flags set, and using the result of this algorithm as the host in the URI. <a href="#RFC3490">[RFC3490]</a><br><br> Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specification. <a href="#RFC3986">[RFC3986]</a> <a href="#RFC3987">[RFC3987]</a> </dd>
<dt>Applications/protocols that use this URI scheme name.</dt>
<dd style="margin-left: 8">
<br>WebSocket protocol over TLS.  </dd>
<dt>Interoperability considerations.</dt>
<dd style="margin-left: 8">
<br>None.  </dd>
<dt>Security considerations.</dt>
<dd style="margin-left: 8">
<br>See "Security considerations" section above.  </dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br>HYBI WG &lt;hybi@ietf.org&gt; </dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br>IETF &lt;iesg@ietf.org&gt; </dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
</dl>

<p> </p>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> Registration of the "WebSocket" HTTP Upgrade keyword</h1>
<p></p>

<dl>
<dt>Name of token.</dt>
<dd style="margin-left: 8">
<br>WebSocket </dd>
<dt>Author/Change controller.</dt>
<dd style="margin-left: 8">
<br>IETF &lt;iesg@ietf.org&gt; </dd>
<dt>Contact.</dt>
<dd style="margin-left: 8">
<br>HYBI &lt;hybi@ietf.org&gt; </dd>
<dt>References.</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
</dl>
<h1 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> Sec-WebSocket-Key</h1>
<p id="rfc.section.10.4.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Key </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket handshake.  </dd>
</dl>
<p id="rfc.section.10.4.p.3">The |Sec-WebSocket-Key| header is used in the WebSocket handshake. It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket handshake. This helps ensure that the server does not accept connections from non-WebSocket clients (e.g. HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.</p>
<h1 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> Sec-WebSocket-Extensions</h1>
<p id="rfc.section.10.5.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Extensions </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket handshake.  </dd>
</dl>
<p id="rfc.section.10.5.p.3">The |Sec-WebSocket-Extensions| header is used in the WebSocket handshake. It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection.</p>
<h1 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> Sec-WebSocket-Accept</h1>
<p id="rfc.section.10.6.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Accept </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket handshake.  </dd>
</dl>
<p id="rfc.section.10.6.p.3">The |Sec-WebSocket-Accept| header is used in the WebSocket handshake. It is sent from the server to the client to confirm that the server is willing to initiate the connection. </p>
<h1 id="rfc.section.10.7">
<a href="#rfc.section.10.7">10.7.</a> Sec-WebSocket-Origin</h1>
<p id="rfc.section.10.7.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Origin </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket handshake.  </dd>
</dl>
<p id="rfc.section.10.7.p.3">The |Sec-WebSocket-Origin| header is used in the WebSocket handshake. It is sent from the server to the client to confirm the origin of the script that opened the connection. This enables user agents to verify that the server is willing to serve the script that opened the connection.</p>
<h1 id="rfc.section.10.8">
<a href="#rfc.section.10.8">10.8.</a> Sec-WebSocket-Protocol</h1>
<p id="rfc.section.10.8.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Protocol </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket handshake.  </dd>
</dl>
<p id="rfc.section.10.8.p.3">The |Sec-WebSocket-Protocol| header is used in the WebSocket handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.</p>
<h1 id="rfc.section.10.9">
<a href="#rfc.section.10.9">10.9.</a> Sec-WebSocket-Version</h1>
<p id="rfc.section.10.9.p.1">This section describes a header field for registration in the Permanent Message Header Field Registry. <a href="#RFC3864">[RFC3864]</a> </p>
<p></p>

<dl>
<dt>Header field name</dt>
<dd style="margin-left: 8">
<br>Sec-WebSocket-Version </dd>
<dt>Applicable protocol</dt>
<dd style="margin-left: 8">
<br>http </dd>
<dt>Status</dt>
<dd style="margin-left: 8">
<br>standard </dd>
<dt>Author/Change controller</dt>
<dd style="margin-left: 8">
<br>IETF </dd>
<dt>Specification document(s)</dt>
<dd style="margin-left: 8">
<br>RFC XXXX </dd>
<dt>Related information</dt>
<dd style="margin-left: 8">
<br>This header field is only used for WebSocket handshake.  </dd>
</dl>
<p id="rfc.section.10.9.p.3">The |Sec-WebSocket-Version| header is used in the WebSocket handshake. It is sent from the client to the server to indicate the protocol version of the connection. This enables servers to correctly interpret the handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#otherspecs" id="otherspecs">Using the WebSocket protocol from other specifications</a>
</h1>
<p id="rfc.section.11.p.1">The WebSocket protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g. in a specification defining a scripted API.</p>
<p id="rfc.section.11.p.2">Such a specification first needs to "establish a WebSocket connection", providing that algorithm with: </p>

<ul>
<li>The destination, consisting of a /host/ and a /port/.</li>
<li>A /resource name/, which allows for multiple services to be identified at one host and port.</li>
<li>A /secure/ flag, which is true if the connection is to be encrypted, and false otherwise.</li>
<li>An ASCII serialization of an origin that is being made responsible for the connection. <a href="#I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</a> </li>
<li>Optionally a string identifying a protocol that is to be layered over the WebSocket connection.</li>
</ul>

<p> </p>
<p id="rfc.section.11.p.3">The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI's components. These steps fail if the URI does not specify a WebSocket.</p>
<p id="rfc.section.11.p.4">If a connection can be established, then it is said that the "WebSocket connection is established".</p>
<p id="rfc.section.11.p.5">If at any time the connection is to be closed, then the specification needs to use the "close the WebSocket connection" algorithm.</p>
<p id="rfc.section.11.p.6">When the connection is closed, for any reason including failure to establish the connection in the first place, it is said that the "WebSocket connection is closed".</p>
<p id="rfc.section.11.p.7">While a connection is open, the specification will need to handle the cases when "a WebSocket message has been received" with text /data/.</p>
<p id="rfc.section.11.p.8">To send some text /data/ to an open connection, the specification needs to "send /data/ using the WebSocket".</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> Acknowledgements</h1>
<p id="rfc.section.12.p.1">Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification at http://whatwg.org/html5.  </p>
<p id="rfc.section.12.p.2">Special thanks also to John Tamplin for providing a significant amount of text for the Data Framing section of this specification.</p>
<p id="rfc.section.12.p.3">Special thanks also to Adam Barth for providing a significant amount of text and background research for the Data Masking section of this specification.</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ANSI.X3-4.1986">[ANSI.X3-4.1986]</b></td>
<td class="top">
<a>American National Standards Institute</a>, "<a>Coded Character Set - 7-bit American Standard Code for Information Interchange</a>", ANSI X3.4, 1986.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS.180-2.2002">[FIPS.180-2.2002]</b></td>
<td class="top">
<a>National Institute of Standards and Technology</a>, "<a>Secure Hash Standard</a>", FIPS PUB 180-2, August 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1951">[RFC1951]</b></td>
<td class="top">
<a href="mailto:ghost@aladdin.com" title="Aladdin Enterprises">Deutsch, P.</a>, "<a href="http://tools.ietf.org/html/rfc1951">DEFLATE Compressed Data Format Specification version 1.3</a>", RFC 1951, May 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2818">[RFC2818]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3490">[RFC3490]</b></td>
<td class="top">
<a>Faltstrom, P.</a>, <a>Hoffman, P.</a> and <a>A. Costello</a>, "<a href="http://tools.ietf.org/html/rfc3490">Internationalizing Domain Names in Applications (IDNA)</a>", RFC 3490, March 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3492">[RFC3492]</b></td>
<td class="top">
<a>Costello, A.</a>, "<a href="http://tools.ietf.org/html/rfc3492">Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)</a>", RFC 3492, March 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3548">[RFC3548]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc3548">The Base16, Base32, and Base64 Data Encodings</a>", RFC 3548, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3864">[RFC3864]</b></td>
<td class="top">
<a>Klyne, G.</a>, <a>Nottingham, M.</a> and <a>J. Mogul</a>, "<a href="http://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>", BCP 90, RFC 3864, September 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3987">[RFC3987]</b></td>
<td class="top">
<a>Duerst, M.</a> and <a>M. Suignard</a>, "<a href="http://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>", RFC 3987, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="WSAPI">[WSAPI]</b></td>
<td class="top">
<a title="Google, Inc.">Hickson, I.E.</a>, "<a>The Web Sockets API</a>", August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-httpstate-cookie">[I-D.ietf-httpstate-cookie]</b></td>
<td class="top">
<a>Barth, A</a>, "<a href="http://tools.ietf.org/html/draft-ietf-httpstate-cookie-20">HTTP State Management Mechanism</a>", Internet-Draft draft-ietf-httpstate-cookie-20, December 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-websec-origin">[I-D.ietf-websec-origin]</b></td>
<td class="top">
<a>Barth, A</a>, "<a href="http://tools.ietf.org/html/draft-ietf-websec-origin-00">The Web Origin Concept</a>", Internet-Draft draft-ietf-websec-origin-00, December 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1950">[RFC1950]</b></td>
<td class="top">
<a href="mailto:ghost@aladdin.com" title="Aladdin Enterprises">Deutsch, L.P.</a> and <a>J-L. Gailly</a>, "<a href="http://tools.ietf.org/html/rfc1950">ZLIB Compressed Data Format Specification version 3.3</a>", RFC 1950, May 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5321">[RFC5321]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="http://tools.ietf.org/html/rfc5321">Simple Mail Transfer Protocol</a>", RFC 5321, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6202">[RFC6202]</b></td>
<td class="top">
<a>Loreto, S.</a>, <a>Saint-Andre, P.</a>, <a>Salsano, S.</a> and <a>G. Wilkins</a>, "<a href="http://tools.ietf.org/html/rfc6202">Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</a>", RFC 6202, April 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Fette</span> 
	  <span class="n hidden">
		<span class="family-name">Fette</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ifette+ietf@google.com">ifette+ietf@google.com</a></span>

<span class="vcardline">URI: <a href="http://www.ianfette.com/">http://www.ianfette.com/</a></span>

  </address>
</div>

</body>
</html>