<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
<meta content="Eric Rescorla" name="author">
<meta content="Hannes Tschofenig" name="author">
<meta content="Nagendra Modadugu" name="author">
<meta content="
       This document specifies Version 1.3 of the Datagram Transport Layer Security
(DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the
Internet in a way that is designed to prevent eavesdropping, tampering, and message
forgery. 
       The DTLS 1.3 protocol is intentionally based on the Transport Layer Security (TLS)
1.3 protocol and provides equivalent security guarantees with the exception of order protection/non-replayability.  Datagram semantics of the underlying transport are preserved by the DTLS protocol. 
    " name="description">
<meta content="xml2rfc 2.40.1" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-ietf-tls-dtls13-37" name="ietf.draft">
<link href="/tmp/draft-ietf-tls-dtls13-37-021psq0q.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Avoid wrapping of URLs in references */
@media screen {
  .references a {
    white-space: nowrap;
  }
}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin: 0 0 0.25em 0;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/*
  The margin-left: 0 on <dd> removes all distinction
  between levels from nested <dl>s.  Undo that.
*/
dl.olPercent > dd,
dd {
  margin-left: revert;
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">DTLS 1.3</td>
<td class="right">March 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Rescorla, et al.</td>
<td class="center">Expires 10 September 2020</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">TLS</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-tls-dtls13-37</dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a href="https://www.rfc-editor.org/rfc/rfc6347" class="eref">6347</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2020-03-09" class="published">9 March 2020</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2020-09-10">10 September 2020</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">E. Rescorla</div>
<div class="org">RTFM, Inc.</div>
</div>
<div class="author">
      <div class="author-name">H. Tschofenig</div>
<div class="org">Arm Limited</div>
</div>
<div class="author">
      <div class="author-name">N. Modadugu</div>
<div class="org">Google, Inc.</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document specifies Version 1.3 of the Datagram Transport Layer Security
(DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the
Internet in a way that is designed to prevent eavesdropping, tampering, and message
forgery.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
<p id="section-abstract-2">The DTLS 1.3 protocol is intentionally based on the Transport Layer Security (TLS)
1.3 protocol and provides equivalent security guarantees with the exception of order protection/non-replayability.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.<a href="#section-abstract-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 10 September 2020.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-3">
            This document may contain material from IETF Documents or IETF
            Contributions published or made publicly available before November
            10, 2008. The person(s) controlling the copyright in some of this
            material may not have granted the IETF Trust the right to allow
            modifications of such material outside the IETF Standards Process.
            Without obtaining an adequate license from the person(s)
            controlling the copyright in such materials, this document may not
            be modified outside the IETF Standards Process, and derivative
            works of it may not be created outside the IETF Standards Process,
            except to format it for publication as an RFC or to translate it
            into languages other than English.<a href="#section-boilerplate.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a><a href="#section-toc.1-1.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-conventions-and-terminology" class="xref">Conventions and Terminology</a><a href="#section-toc.1-1.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-dtls-design-rationale-and-o" class="xref">DTLS Design Rationale and Overview</a><a href="#section-toc.1-1.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-packet-loss" class="xref">Packet Loss</a><a href="#section-toc.1-1.3.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-reordering" class="xref">Reordering</a><a href="#section-toc.1-1.3.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.  <a href="#name-message-size" class="xref">Message Size</a><a href="#section-toc.1-1.3.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="xref">3.4</a>.  <a href="#name-replay-detection" class="xref">Replay Detection</a><a href="#section-toc.1-1.3.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-the-dtls-record-layer" class="xref">The DTLS Record Layer</a><a href="#section-toc.1-1.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-determining-the-header-form" class="xref">Determining the Header Format</a><a href="#section-toc.1-1.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-sequence-number-and-epoch" class="xref">Sequence Number and Epoch</a><a href="#section-toc.1-1.4.2.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="xref">4.2.1</a>.  <a href="#name-processing-guidelines" class="xref">Processing Guidelines</a><a href="#section-toc.1-1.4.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="xref">4.2.2</a>.  <a href="#name-reconstructing-the-sequence" class="xref">Reconstructing the Sequence Number and Epoch</a><a href="#section-toc.1-1.4.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2.2.3">
                    <p id="section-toc.1-1.4.2.2.2.3.1"><a href="#section-4.2.3" class="xref">4.2.3</a>.  <a href="#name-sequence-number-encryption" class="xref">Sequence Number Encryption</a><a href="#section-toc.1-1.4.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-transport-layer-mapping" class="xref">Transport Layer Mapping</a><a href="#section-toc.1-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-pmtu-issues" class="xref">PMTU Issues</a><a href="#section-toc.1-1.4.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-record-payload-protection" class="xref">Record Payload Protection</a><a href="#section-toc.1-1.4.2.5.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.5.2.1">
                    <p id="section-toc.1-1.4.2.5.2.1.1"><a href="#section-4.5.1" class="xref">4.5.1</a>.  <a href="#name-anti-replay" class="xref">Anti-Replay</a><a href="#section-toc.1-1.4.2.5.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.5.2.2">
                    <p id="section-toc.1-1.4.2.5.2.2.1"><a href="#section-4.5.2" class="xref">4.5.2</a>.  <a href="#name-handling-invalid-records" class="xref">Handling Invalid Records</a><a href="#section-toc.1-1.4.2.5.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-the-dtls-handshake-protocol" class="xref">The DTLS Handshake Protocol</a><a href="#section-toc.1-1.5.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-denial-of-service-counterme" class="xref">Denial-of-Service Countermeasures</a><a href="#section-toc.1-1.5.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-dtls-handshake-message-form" class="xref">DTLS Handshake Message Format</a><a href="#section-toc.1-1.5.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-clienthello-message" class="xref">ClientHello Message</a><a href="#section-toc.1-1.5.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.  <a href="#name-handshake-message-fragmenta" class="xref">Handshake Message Fragmentation and Reassembly</a><a href="#section-toc.1-1.5.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="xref">5.5</a>.  <a href="#name-end-of-early-data" class="xref">End Of Early Data</a><a href="#section-toc.1-1.5.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.6">
                <p id="section-toc.1-1.5.2.6.1"><a href="#section-5.6" class="xref">5.6</a>.  <a href="#name-dtls-handshake-flights" class="xref">DTLS Handshake Flights</a><a href="#section-toc.1-1.5.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.7">
                <p id="section-toc.1-1.5.2.7.1"><a href="#section-5.7" class="xref">5.7</a>.  <a href="#name-timeout-and-retransmission" class="xref">Timeout and Retransmission</a><a href="#section-toc.1-1.5.2.7.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.7.2.1">
                    <p id="section-toc.1-1.5.2.7.2.1.1"><a href="#section-5.7.1" class="xref">5.7.1</a>.  <a href="#name-state-machine" class="xref">State Machine</a><a href="#section-toc.1-1.5.2.7.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.7.2.2">
                    <p id="section-toc.1-1.5.2.7.2.2.1"><a href="#section-5.7.2" class="xref">5.7.2</a>.  <a href="#name-timer-values" class="xref">Timer Values</a><a href="#section-toc.1-1.5.2.7.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.8">
                <p id="section-toc.1-1.5.2.8.1"><a href="#section-5.8" class="xref">5.8</a>.  <a href="#name-certificateverify-and-finis" class="xref">CertificateVerify and Finished Messages</a><a href="#section-toc.1-1.5.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.9">
                <p id="section-toc.1-1.5.2.9.1"><a href="#section-5.9" class="xref">5.9</a>.  <a href="#name-cryptographic-label-prefix" class="xref">Cryptographic Label Prefix</a><a href="#section-toc.1-1.5.2.9.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.10">
                <p id="section-toc.1-1.5.2.10.1"><a href="#section-5.10" class="xref">5.10</a>. <a href="#name-alert-messages" class="xref">Alert Messages</a><a href="#section-toc.1-1.5.2.10.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.11">
                <p id="section-toc.1-1.5.2.11.1"><a href="#section-5.11" class="xref">5.11</a>. <a href="#name-establishing-new-associatio" class="xref">Establishing New Associations with Existing Parameters</a><a href="#section-toc.1-1.5.2.11.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-example-of-handshake-with-t" class="xref">Example of Handshake with Timeout and Retransmission</a><a href="#section-toc.1-1.6.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-epoch-values-and-rekeying" class="xref">Epoch Values and Rekeying</a><a href="#section-toc.1-1.6.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-ack-message" class="xref">ACK Message</a><a href="#section-toc.1-1.7.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-sending-acks" class="xref">Sending ACKs</a><a href="#section-toc.1-1.7.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-receiving-acks" class="xref">Receiving ACKs</a><a href="#section-toc.1-1.7.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-key-updates" class="xref">Key Updates</a><a href="#section-toc.1-1.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-connection-id-updates" class="xref">Connection ID Updates</a><a href="#section-toc.1-1.9.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-connection-id-example" class="xref">Connection ID Example</a><a href="#section-toc.1-1.9.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-application-data-protocol" class="xref">Application Data Protocol</a><a href="#section-toc.1-1.10.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-security-considerations" class="xref">Security Considerations</a><a href="#section-toc.1-1.11.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="xref">12</a>. <a href="#name-changes-to-dtls-12" class="xref">Changes to DTLS 1.2</a><a href="#section-toc.1-1.12.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="xref">13</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a><a href="#section-toc.1-1.13.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-14" class="xref">14</a>. <a href="#name-references" class="xref">References</a><a href="#section-toc.1-1.14.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#section-14.1" class="xref">14.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a><a href="#section-toc.1-1.14.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14.2.2">
                <p id="section-toc.1-1.14.2.2.1"><a href="#section-14.2" class="xref">14.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a><a href="#section-toc.1-1.14.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-appendix.a" class="xref">Appendix A</a>.  <a href="#name-protocol-data-structures-an" class="xref">Protocol Data Structures and Constant Values</a><a href="#section-toc.1-1.15.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.15.2.1">
                <p id="section-toc.1-1.15.2.1.1"><a href="#section-a.1" class="xref">A.1</a>.  <a href="#name-record-layer" class="xref">Record Layer</a><a href="#section-toc.1-1.15.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15.2.2">
                <p id="section-toc.1-1.15.2.2.1"><a href="#section-a.2" class="xref">A.2</a>.  <a href="#name-handshake-protocol" class="xref">Handshake Protocol</a><a href="#section-toc.1-1.15.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15.2.3">
                <p id="section-toc.1-1.15.2.3.1"><a href="#section-a.3" class="xref">A.3</a>.  <a href="#name-acks" class="xref">ACKs</a><a href="#section-toc.1-1.15.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15.2.4">
                <p id="section-toc.1-1.15.2.4.1"><a href="#section-a.4" class="xref">A.4</a>.  <a href="#name-connection-id-management" class="xref">Connection ID Management</a><a href="#section-toc.1-1.15.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#section-appendix.b" class="xref">Appendix B</a>.  <a href="#name-history" class="xref">History</a><a href="#section-toc.1-1.16.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#section-appendix.c" class="xref">Appendix C</a>.  <a href="#name-working-group-information" class="xref">Working Group Information</a><a href="#section-toc.1-1.17.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#section-appendix.d" class="xref">Appendix D</a>.  <a href="#name-contributors" class="xref">Contributors</a><a href="#section-toc.1-1.18.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19">
            <p id="section-toc.1-1.19.1"><a href="#section-appendix.e" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a><a href="#section-toc.1-1.19.1" class="pilcrow">¶</a></p>
</li>
</ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">The source for this draft is maintained in GitHub. Suggested changes
should be submitted as pull requests at https://github.com/tlswg/dtls13-spec.
Instructions are on that page as well. Editorial changes can be managed in GitHub,
but any substantive change should be discussed on the TLS mailing list.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">The primary goal of the TLS protocol is to establish an authenticated, 
confidentiality and integrity protected channel between two communicating peers. 
The TLS protocol is composed of two layers:
the TLS Record Protocol and the TLS Handshake Protocol. However, TLS must
run over a reliable transport channel - typically TCP <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span>.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">There are applications that use UDP <span>[<a href="#RFC0768" class="xref">RFC0768</a>]</span> as a transport and to offer communication
security protection for those applications the Datagram Transport Layer
Security (DTLS) protocol has been developed. DTLS is deliberately designed to be
as similar to TLS as possible, both to minimize new security invention and to
maximize the amount of code and infrastructure reuse.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">DTLS 1.0 <span>[<a href="#RFC4347" class="xref">RFC4347</a>]</span> was originally defined as a delta from TLS 1.1 <span>[<a href="#RFC4346" class="xref">RFC4346</a>]</span> and
DTLS 1.2 <span>[<a href="#RFC6347" class="xref">RFC6347</a>]</span> was defined as a series of deltas to TLS 1.2 <span>[<a href="#RFC5246" class="xref">RFC5246</a>]</span>.  There
is no DTLS 1.1; that version number was skipped in order to harmonize version numbers
with TLS.  This specification describes the most current version of the DTLS protocol
based on TLS 1.3 <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">Implementations that speak both DTLS 1.2 and DTLS 1.3 can interoperate with those
that speak only DTLS 1.2 (using DTLS 1.2 of course), just as TLS 1.3 implementations
can interoperate with TLS 1.2 (see Appendix D of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span> for details).
While backwards compatibility with DTLS 1.0 is possible the use of DTLS 1.0 is not
recommended as explained in Section 3.1.2 of RFC 7525 <span>[<a href="#RFC7525" class="xref">RFC7525</a>]</span>.<a href="#section-1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="conventions-and-terminology">
<section id="section-2">
      <h2 id="name-conventions-and-terminology">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-terminology" class="section-name selfRef">Conventions and Terminology</a>
      </h2>
<p id="section-2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span>
when, and only when, they appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">The following terms are used:<a href="#section-2-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-2-3.1">client: The endpoint initiating the DTLS connection.<a href="#section-2-3.1" class="pilcrow">¶</a>
</li>
<li id="section-2-3.2">connection: A transport-layer connection between two endpoints.<a href="#section-2-3.2" class="pilcrow">¶</a>
</li>
<li id="section-2-3.3">endpoint: Either the client or server of the connection.<a href="#section-2-3.3" class="pilcrow">¶</a>
</li>
<li id="section-2-3.4">handshake: An initial negotiation between client and server that establishes
the parameters of their transactions.<a href="#section-2-3.4" class="pilcrow">¶</a>
</li>
<li id="section-2-3.5">peer: An endpoint. When discussing a particular endpoint, "peer" refers to
the endpoint that is remote to the primary subject of discussion.<a href="#section-2-3.5" class="pilcrow">¶</a>
</li>
<li id="section-2-3.6">receiver: An endpoint that is receiving records.<a href="#section-2-3.6" class="pilcrow">¶</a>
</li>
<li id="section-2-3.7">sender: An endpoint that is transmitting records.<a href="#section-2-3.7" class="pilcrow">¶</a>
</li>
<li id="section-2-3.8">session: An association between a client and a server resulting from a handshake.<a href="#section-2-3.8" class="pilcrow">¶</a>
</li>
<li id="section-2-3.9">server: The endpoint which did not initiate the DTLS connection.<a href="#section-2-3.9" class="pilcrow">¶</a>
</li>
<li id="section-2-3.10">CID: Connection ID<a href="#section-2-3.10" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-2-4">The reader is assumed to be familiar with the TLS 1.3 specification since this
document is defined as a delta from TLS 1.3. As in TLS 1.3 the HelloRetryRequest has
the same format as a ServerHello message but for convenience we use the term
HelloRetryRequest throughout this document as if it were a distinct message.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">Figures in this document illustrate various combinations of the DTLS protocol exchanges and the symbols have the following meaning:<a href="#section-2-5" class="pilcrow">¶</a></p>
<ul>
<li id="section-2-6.1">'+'  indicates noteworthy extensions sent in the previously noted message.<a href="#section-2-6.1" class="pilcrow">¶</a>
</li>
<li id="section-2-6.2">'*'  indicates optional or situation-dependent messages/extensions that are not always sent.<a href="#section-2-6.2" class="pilcrow">¶</a>
</li>
<li id="section-2-6.3">'{}' indicates messages protected using keys derived from a [sender]_handshake_traffic_secret.<a href="#section-2-6.3" class="pilcrow">¶</a>
</li>
<li id="section-2-6.4">'[]' indicates messages protected using keys derived from traffic_secret_N.<a href="#section-2-6.4" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="dtls-rational">
<section id="section-3">
      <h2 id="name-dtls-design-rationale-and-o">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-dtls-design-rationale-and-o" class="section-name selfRef">DTLS Design Rationale and Overview</a>
      </h2>
<p id="section-3-1">The basic design philosophy of DTLS is to construct "TLS over datagram transport".
Datagram transport does not require nor provide reliable or in-order delivery of data.
The DTLS protocol preserves this property for application data.
Applications such as media streaming, Internet telephony, and online gaming use
datagram transport for communication due to the delay-sensitive nature
of transported data.  The behavior of such applications is unchanged when the
DTLS protocol is used to secure communication, since the DTLS protocol
does not compensate for lost or reordered data traffic.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">TLS cannot be used directly in datagram environments for the following five reasons:<a href="#section-3-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3-3">
        <li id="section-3-3.1">TLS relies on an implicit sequence number on records.  If a record is not
received, then the recipient will use the wrong sequence number when
attempting to remove record protection from subsequent records. DTLS solves
this problem by adding sequence numbers.<a href="#section-3-3.1" class="pilcrow">¶</a>
</li>
<li id="section-3-3.2">The TLS handshake is a lock-step cryptographic handshake.  Messages must be
transmitted and received in a defined order; any other order is an error.
DTLS handshake messages are also assigned sequence numbers to enable
reassembly in the correct order in case datagrams are lost or reordered.<a href="#section-3-3.2" class="pilcrow">¶</a>
</li>
<li id="section-3-3.3">During the handshake, messages are implicitly acknowledged by other handshake
messages, but the last flight of messages and post-handshake messages (such
as the NewSessionTicket message) do not result in any direct response that
would allow the sender to detect loss. DTLS adds an acknowledgment message to
enable better loss recovery.<a href="#section-3-3.3" class="pilcrow">¶</a>
</li>
<li id="section-3-3.4">Handshake messages are potentially larger than can be contained in a single
datagram.  DTLS adds fields to handshake messages to support fragmentation
and reassembly.<a href="#section-3-3.4" class="pilcrow">¶</a>
</li>
<li id="section-3-3.5">Datagram transport protocols, like UDP, are susceptible to abusive behavior
effecting denial of service attacks against nonparticipants.  DTLS adds a
return-routability check that uses the TLS HelloRetryRequest message (see
<a href="#dos" class="xref">Section 5.1</a> for details).<a href="#section-3-3.5" class="pilcrow">¶</a>
</li>
</ol>
<div id="packet-loss">
<section id="section-3.1">
        <h3 id="name-packet-loss">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-packet-loss" class="section-name selfRef">Packet Loss</a>
        </h3>
<p id="section-3.1-1">DTLS uses a simple retransmission timer to handle packet loss.
<a href="#dtls-retransmission" class="xref">Figure 1</a> demonstrates the basic concept, using the first
phase of the DTLS handshake:<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<span id="name-dtls-retransmission-example"></span><div id="dtls-retransmission">
<figure id="figure-1">
          <div class="artwork art-text alignLeft" id="section-3.1-2.1">
<pre>
         Client                                   Server
         ------                                   ------
         ClientHello           ------&gt;

                                 X&lt;-- HelloRetryRequest
                                                  (lost)

         [Timer Expires]

         ClientHello           ------&gt;
         (retransmit)
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-dtls-retransmission-example" class="selfRef">DTLS retransmission example</a>
          </figcaption></figure>
</div>
<p id="section-3.1-3">Once the client has transmitted the ClientHello message, it expects
to see a HelloRetryRequest or a ServerHello from the server. However, if the
server's message is lost, the client knows that either the
ClientHello or the response from the server has been lost and retransmits.
When the server receives the retransmission, it knows to retransmit.<a href="#section-3.1-3" class="pilcrow">¶</a></p>
<p id="section-3.1-4">The server also maintains a retransmission timer and retransmits when
that timer expires.<a href="#section-3.1-4" class="pilcrow">¶</a></p>
<p id="section-3.1-5">Note that timeout and retransmission do not apply to the
HelloRetryRequest since this would require creating state on the
server.  The HelloRetryRequest is designed to be small enough that
it will not itself be fragmented, thus avoiding concerns about
interleaving multiple HelloRetryRequests.<a href="#section-3.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reordering">
<section id="section-3.2">
        <h3 id="name-reordering">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-reordering" class="section-name selfRef">Reordering</a>
        </h3>
<p id="section-3.2-1">In DTLS, each handshake message is assigned a specific sequence
number.  When a peer receives a handshake
message, it can quickly determine whether that message is the next
message it expects.  If it is, then it processes it.  If not, it
queues it for future handling once all previous messages have been
received.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="message-size">
<section id="section-3.3">
        <h3 id="name-message-size">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-message-size" class="section-name selfRef">Message Size</a>
        </h3>
<p id="section-3.3-1">TLS and DTLS handshake messages can be quite large (in theory up to
2^24-1 bytes, in practice many kilobytes).  By contrast, UDP
datagrams are often limited to less than 1500 bytes if IP fragmentation is not
desired.  In order to compensate for this limitation, each DTLS
handshake message may be fragmented over several DTLS records, each
of which is intended to fit in a single UDP datagram.  Each DTLS
handshake message contains both a fragment offset and a fragment
length.  Thus, a recipient in possession of all bytes of a handshake
message can reassemble the original unfragmented message.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="replay-detection">
<section id="section-3.4">
        <h3 id="name-replay-detection">
<a href="#section-3.4" class="section-number selfRef">3.4. </a><a href="#name-replay-detection" class="section-name selfRef">Replay Detection</a>
        </h3>
<p id="section-3.4-1">DTLS optionally supports record replay detection.  The technique used
is the same as in IPsec AH/ESP, by maintaining a bitmap window of
received records.  Records that are too old to fit in the window and
records that have previously been received are silently discarded.
The replay detection feature is optional, since packet duplication is
not always malicious, but can also occur due to routing errors.
Applications may conceivably detect duplicate packets and accordingly
modify their data transmission strategy.<a href="#section-3.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="the-dtls-record-layer">
<section id="section-4">
      <h2 id="name-the-dtls-record-layer">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-the-dtls-record-layer" class="section-name selfRef">The DTLS Record Layer</a>
      </h2>
<p id="section-4-1">The DTLS 1.3 record layer is different from the TLS 1.3 record layer and 
also different from the DTLS 1.2 record layer.<a href="#section-4-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4-2">
        <li id="section-4-2.1">The DTLSCiphertext structure omits the superfluous version number and
type fields.<a href="#section-4-2.1" class="pilcrow">¶</a>
</li>
<li id="section-4-2.2">DTLS adds an epoch and sequence number to the TLS record header.
This sequence number allows the recipient to correctly verify the DTLS MAC.
However, the number of bits used for the epoch and sequence number fields in
the DTLSCiphertext structure have been reduced from those in previous
versions.<a href="#section-4-2.2" class="pilcrow">¶</a>
</li>
<li id="section-4-2.3">The DTLSCiphertext structure has a variable length header.<a href="#section-4-2.3" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-4-3">DTLSPlaintext records are used to send unprotected records and DTLSCiphertext
records are used to send protected records.<a href="#section-4-3" class="pilcrow">¶</a></p>
<p id="section-4-4">The DTLS record formats are shown below. Unless explicitly stated the
meaning of the fields is unchanged from previous TLS / DTLS versions.<a href="#section-4-4" class="pilcrow">¶</a></p>
<span id="name-dtls-13-record-format"></span><div id="dtls-record">
<figure id="figure-2">
        <div class="artwork art-text alignLeft" id="section-4-5.1">
<pre>
struct {
    ContentType type;
    ProtocolVersion legacy_record_version;
    uint16 epoch = 0
    uint48 sequence_number;
    uint16 length;
    opaque fragment[DTLSPlaintext.length];
} DTLSPlaintext;

struct {
     opaque content[DTLSPlaintext.length];
     ContentType type;
     uint8 zeros[length_of_padding];
} DTLSInnerPlaintext;

struct {
    opaque unified_hdr[variable];
    opaque encrypted_record[length];
} DTLSCiphertext;
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-dtls-13-record-format" class="selfRef">DTLS 1.3 Record Format</a>
        </figcaption></figure>
</div>
<dl class="dlParallel" id="section-4-6">
        <dt id="section-4-6.1">unified_hdr:</dt>
<dd id="section-4-6.2">
  The unified_hdr is a field of variable length, as shown in <a href="#cid_hdr" class="xref">Figure 3</a>.<a href="#section-4-6.2" class="pilcrow">¶</a>
</dd>
<dt id="section-4-6.3">encrypted_record:</dt>
<dd id="section-4-6.4">
  Identical to the encrypted_record field in a TLS 1.3 record.<a href="#section-4-6.4" class="pilcrow">¶</a>
</dd>
</dl>
<p id="section-4-7">The DTLSCiphertext header is tightly bit-packed, as shown below:<a href="#section-4-7" class="pilcrow">¶</a></p>
<span id="name-dtls-13-ciphertext-header"></span><div id="cid_hdr">
<figure id="figure-3">
        <div class="artwork art-text alignLeft" id="section-4-8.1">
<pre>
0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|0|0|1|C|S|L|E E|
+-+-+-+-+-+-+-+-+
| Connection ID |   Legend:
| (if any,      |
/  length as    /   C   - Connection ID (CID) present
|  negotiated)  |   S   - Sequence number length
+-+-+-+-+-+-+-+-+   L   - Length present
|  8 or 16 bit  |   E   - Epoch
|Sequence Number|
+-+-+-+-+-+-+-+-+
| 16 bit Length |
| (if present)  |
+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-dtls-13-ciphertext-header" class="selfRef">DTLS 1.3 CipherText Header</a>
        </figcaption></figure>
</div>
<dl class="dlParallel" id="section-4-9">
        <dt id="section-4-9.1">Fixed Bits:</dt>
<dd id="section-4-9.2">
  The three high bits of the first byte of the DTLSCiphertext header are set to
001.<a href="#section-4-9.2" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.3">C:</dt>
<dd id="section-4-9.4">
  The C bit (0x10) is set if the Connection ID is present.<a href="#section-4-9.4" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.5">S:</dt>
<dd id="section-4-9.6">
  The S bit (0x08) indicates the size of the sequence number.
0 means an 8-bit sequence number, 1 means 16-bit.<a href="#section-4-9.6" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.7">L:</dt>
<dd id="section-4-9.8">
  The L bit (0x04) is set if the length is present.<a href="#section-4-9.8" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.9">E:</dt>
<dd id="section-4-9.10">
  The two low bits (0x03) include the low order two bits of the epoch.<a href="#section-4-9.10" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.11">Connection ID:</dt>
<dd id="section-4-9.12">
  Variable length CID. The CID concept
is described in <span>[<a href="#I-D.ietf-tls-dtls-connection-id" class="xref">I-D.ietf-tls-dtls-connection-id</a>]</span>. An example
can be found in <a href="#connection-id-example" class="xref">Section 9.1</a>.<a href="#section-4-9.12" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.13">Sequence Number:</dt>
<dd id="section-4-9.14">
  The low order 8 or 16 bits of the record sequence number.  This value is 16
bits if the S bit is set to 1, and 8 bits if the S bit is 0.<a href="#section-4-9.14" class="pilcrow">¶</a>
</dd>
<dt id="section-4-9.15">Length:</dt>
<dd id="section-4-9.16">
  Identical to the length field in a TLS 1.3 record.<a href="#section-4-9.16" class="pilcrow">¶</a>
</dd>
</dl>
<p id="section-4-10">As with previous versions of DTLS, multiple DTLSPlaintext
and DTLSCiphertext records can be included in the same
underlying transport datagram.<a href="#section-4-10" class="pilcrow">¶</a></p>
<p id="section-4-11"><a href="#hdr_examples" class="xref">Figure 4</a> illustrates different record layer header types.<a href="#section-4-11" class="pilcrow">¶</a></p>
<span id="name-header-examples"></span><div id="hdr_examples">
<figure id="figure-4">
        <div class="artwork art-text alignLeft" id="section-4-12.1">
<pre>
 0 1 2 3 4 5 6 7       0 1 2 3 4 5 6 7        0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
| Content Type  |     |0|0|1|1|1|1|E E|     |0|0|1|0|0|0|E E|
+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
|   16 bit      |     |    16 bit     |     |8-bit Seq. No. |
|   Version     |     |Sequence Number|     +-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     |               |
|   16 bit      |     |               |     |   Encrypted   |
|    Epoch      |     / Connection ID /     /   Record      /
+-+-+-+-+-+-+-+-+     |               |     |               |
|               |     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
|               |     |   16 bit      |
|   48 bit      |     |   Length      |       DTLSCiphertext
|Sequence Number|     +-+-+-+-+-+-+-+-+         Structure
|               |     |               |         (minimal)
|               |     |  Encrypted    |
+-+-+-+-+-+-+-+-+     /  Record       /
|    16 bit     |     |               |
|    Length     |     +-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+
|               |      DTLSCiphertext
|               |        Structure
/   Fragment    /          (full)
|               |
+-+-+-+-+-+-+-+-+

 DTLSPlaintext
   Structure
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-header-examples" class="selfRef">Header Examples</a>
        </figcaption></figure>
</div>
<p id="section-4-13">The length field MAY be omitted by clearing the L bit, which means that the
record consumes the entire rest of the datagram in the lower
level transport. In this case it is not possible to have multiple
DTLSCiphertext format records without length fields in the same datagram.
Omitting the length field MUST only be used for the last record in a
datagram.<a href="#section-4-13" class="pilcrow">¶</a></p>
<p id="section-4-14">Implementations which send multiple records in the same datagram
SHOULD omit the connection id from all but the first record; receiving
implementations MUST assume that any subsequent records without
connection IDs belong to the same assocatiation.  Sending
implementations MUST NOT mix records from multiple DTLS associations
in the same datagram. If the second or later record has a connection
ID which does not correspond to the same association used
for previous records, the rest of the datagram MUST be discarded.<a href="#section-4-14" class="pilcrow">¶</a></p>
<p id="section-4-15">When expanded, the epoch and sequence number can be combined into an
unpacked RecordNumber structure, as shown below:<a href="#section-4-15" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4-16">
<pre>
    struct {
        uint16 epoch;
        uint48 sequence_number;
    } RecordNumber;
</pre><a href="#section-4-16" class="pilcrow">¶</a>
</div>
<p id="section-4-17">This 64-bit value is used in the ACK message as well as in the "record_sequence_number"
input to the AEAD function.<a href="#section-4-17" class="pilcrow">¶</a></p>
<p id="section-4-18">The entire header value shown in <a href="#hdr_examples" class="xref">Figure 4</a> (but prior to record number
encryption) is used as as the additional data value for the AEAD
function. For instance, if the minimal variant is used,
the AAD is 2 octets long. Note that this design is different from the additional data
calculation for DTLS 1.2 and for DTLS 1.2 with Connection ID.<a href="#section-4-18" class="pilcrow">¶</a></p>
<div id="determining-the-header-format">
<section id="section-4.1">
        <h3 id="name-determining-the-header-form">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-determining-the-header-form" class="section-name selfRef">Determining the Header Format</a>
        </h3>
<p id="section-4.1-1">Implementations can distinguish the two header formats by examining
the first byte:<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.1-2.1">If the first byte is alert(21), handshake(22), or ack(proposed, 26),
the record MUST be interpreted as a DTLSPlaintext record.<a href="#section-4.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-4.1-2.2">If the first byte is any other value, then receivers
MUST check to see if the leading bits of the first byte are
001. If so, the implementation MUST process the record as
DTLSCiphertext; the true content type will be inside the
protected portion.<a href="#section-4.1-2.2" class="pilcrow">¶</a>
</li>
<li id="section-4.1-2.3">Otherwise, the record MUST be rejected as if it had failed
deprotection, as described in <a href="#handling-invalid-records" class="xref">Section 4.5.2</a>.<a href="#section-4.1-2.3" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="sequence-number-and-epoch">
<section id="section-4.2">
        <h3 id="name-sequence-number-and-epoch">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-sequence-number-and-epoch" class="section-name selfRef">Sequence Number and Epoch</a>
        </h3>
<p id="section-4.2-1">DTLS uses an explicit or partly explicit sequence number, rather than an implicit one,
carried in the sequence_number field of the record.  Sequence numbers
are maintained separately for each epoch, with each sequence_number
initially being 0 for each epoch.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">The epoch number is initially zero and is incremented each time
keying material changes and a sender aims to rekey. More details
are provided in <a href="#dtls-epoch" class="xref">Section 6.1</a>.<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<div id="processing-guidelines">
<section id="section-4.2.1">
          <h4 id="name-processing-guidelines">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-processing-guidelines" class="section-name selfRef">Processing Guidelines</a>
          </h4>
<p id="section-4.2.1-1">Because DTLS records could be reordered, a record from epoch
M may be received after epoch N (where N &gt; M) has begun.  In general,
implementations SHOULD discard records from earlier epochs, but if
packet loss causes noticeable problems implementations MAY choose to
retain keying material from previous epochs for up to the default MSL
specified for TCP <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span> to allow for packet reordering.  (Note that
the intention here is that implementers use the current guidance from
the IETF for MSL, as specified in <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span> or successors
not that they attempt to interrogate the MSL that
the system TCP stack is using.)<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1-2">Conversely, it is possible for records that are protected with the
new epoch to be received prior to the completion of a
handshake.  For instance, the server may send its Finished message
and then start transmitting data.  Implementations MAY either buffer
or discard such records, though when DTLS is used over reliable
transports (e.g., SCTP <span>[<a href="#RFC4960" class="xref">RFC4960</a>]</span>), they SHOULD be buffered and
processed once the handshake completes.  Note that TLS's restrictions
on when records may be sent still apply, and the receiver treats the
records as if they were sent in the right order.<a href="#section-4.2.1-2" class="pilcrow">¶</a></p>
<p id="section-4.2.1-3">Implementations MUST send retransmissions of lost messages using the same
epoch and keying material as the original transmission.<a href="#section-4.2.1-3" class="pilcrow">¶</a></p>
<p id="section-4.2.1-4">Implementations MUST either abandon an association or re-key prior to
allowing the sequence number to wrap.<a href="#section-4.2.1-4" class="pilcrow">¶</a></p>
<p id="section-4.2.1-5">Implementations MUST NOT allow the epoch to wrap, but instead MUST
establish a new association, terminating the old association.<a href="#section-4.2.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reconstructing">
<section id="section-4.2.2">
          <h4 id="name-reconstructing-the-sequence">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-reconstructing-the-sequence" class="section-name selfRef">Reconstructing the Sequence Number and Epoch</a>
          </h4>
<p id="section-4.2.2-1">When receiving protected DTLS records message, the recipient does not
have a full epoch or sequence number value and so there is some
opportunity for ambiguity.  Because the full epoch and sequence number
are used to compute the per-record nonce, failure to reconstruct these
values leads to failure to deprotect the record, and so implementations
MAY use a mechanism of their choice to determine the full values.
This section provides an algorithm which is comparatively simple
and which implementations are RECOMMENDED to follow.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2-2">If the epoch bits match those of the current epoch, then
implementations SHOULD reconstruct the sequence number by computing
the full sequence number which is numerically closest to one plus the
sequence number of the highest successfully deprotected record.<a href="#section-4.2.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2.2-3">During the handshake phase, the epoch bits unambiguously indicate the
correct key to use. After the
handshake is complete, if the epoch bits do not match those from the
current epoch implementations SHOULD use the most recent past epoch
which has matching bits, and then reconstruct the sequence number as
described above.<a href="#section-4.2.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sne">
<section id="section-4.2.3">
          <h4 id="name-sequence-number-encryption">
<a href="#section-4.2.3" class="section-number selfRef">4.2.3. </a><a href="#name-sequence-number-encryption" class="section-name selfRef">Sequence Number Encryption</a>
          </h4>
<p id="section-4.2.3-1">In DTLS 1.3, when records are encrypted, record sequence numbers are
also encrypted. The basic pattern is that the underlying encryption
algorithm used with the AEAD algorithm is used to generate a mask
which is then XORed with the sequence number.<a href="#section-4.2.3-1" class="pilcrow">¶</a></p>
<p id="section-4.2.3-2">When the AEAD is based on AES, then the Mask is generated by
computing AES-ECB on the first 16 bytes of the ciphertext:<a href="#section-4.2.3-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.2.3-3">
<pre>
  Mask = AES-ECB(sn_key, Ciphertext[0..15])
</pre><a href="#section-4.2.3-3" class="pilcrow">¶</a>
</div>
<p id="section-4.2.3-4">When the AEAD is based on ChaCha20, then the mask is generated
by treating the first 4 bytes of the ciphertext as the block
counter and the next 12 bytes as the nonce, passing them to the ChaCha20
block function (Section 2.3 of <span>[<a href="#CHACHA" class="xref">CHACHA</a>]</span>):<a href="#section-4.2.3-4" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.2.3-5">
<pre>
  Mask = ChaCha20(sn_key, Ciphertext[0..3], Ciphertext[4..15])
</pre><a href="#section-4.2.3-5" class="pilcrow">¶</a>
</div>
<p id="section-4.2.3-6">The sn_key is computed as follows:<a href="#section-4.2.3-6" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-4.2.3-7">
<pre>
   [sender]_sn_key  = HKDF-Expand-Label(Secret, "sn" , "", key_length)
</pre><a href="#section-4.2.3-7" class="pilcrow">¶</a>
</div>
<p id="section-4.2.3-8">[sender] denotes the sending side. The Secret value to be used is described
in Section 7.3 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.<a href="#section-4.2.3-8" class="pilcrow">¶</a></p>
<p id="section-4.2.3-9">The encrypted sequence number is computed by XORing the leading
bytes of the Mask with the sequence number. Decryption is
accomplished by the same process.<a href="#section-4.2.3-9" class="pilcrow">¶</a></p>
<p id="section-4.2.3-10">This procedure requires the ciphertext length be at least 16 bytes. Receivers
MUST reject shorter records as if they had failed deprotection, as described in
<a href="#handling-invalid-records" class="xref">Section 4.5.2</a>. Senders MUST pad short plaintexts out (using the
conventional record padding mechanism) in order to make a suitable-length
ciphertext. Note most of the DTLS AEAD algorithms have a 16-byte authentication
tag and need no padding. However, some algorithms such as
TLS_AES_128_CCM_8_SHA256 have a shorter authentication tag and may require padding
for short inputs.<a href="#section-4.2.3-10" class="pilcrow">¶</a></p>
<p id="section-4.2.3-11">Note that sequence number encryption is only applied to the DTLSCiphertext
structure and not to the DTLSPlaintext structure, which also contains a
sequence number.<a href="#section-4.2.3-11" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="transport-layer-mapping">
<section id="section-4.3">
        <h3 id="name-transport-layer-mapping">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-transport-layer-mapping" class="section-name selfRef">Transport Layer Mapping</a>
        </h3>
<p id="section-4.3-1">DTLS messages MAY be fragmented into multiple DTLS records.
Each DTLS record MUST fit within a single datagram.  In order to
avoid IP fragmentation, clients of the DTLS record layer SHOULD
attempt to size records so that they fit within any PMTU estimates
obtained from the record layer.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">Multiple DTLS records MAY be placed in a single datagram.  Records are encoded
consecutively.  The length field from DTLS records containing that field can be
used to determine the boundaries between records.  The final record in a
datagram can omit the length field.  The first byte of the datagram payload MUST
be the beginning of a record.  Records MUST NOT span datagrams.<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<p id="section-4.3-3">DTLS records without CIDs do not contain any association
identifiers and applications must arrange to multiplex between associations.
With UDP, the host/port number is used to look up the appropriate security
association for incoming records.<a href="#section-4.3-3" class="pilcrow">¶</a></p>
<p id="section-4.3-4">Some transports, such as DCCP <span>[<a href="#RFC4340" class="xref">RFC4340</a>]</span>, provide their own sequence
numbers.  When carried over those transports, both the DTLS and the
transport sequence numbers will be present.  Although this introduces
a small amount of inefficiency, the transport layer and DTLS sequence
numbers serve different purposes; therefore, for conceptual simplicity,
it is superior to use both sequence numbers.<a href="#section-4.3-4" class="pilcrow">¶</a></p>
<p id="section-4.3-5">Some transports provide congestion control for traffic
carried over them.  If the congestion window is sufficiently narrow,
DTLS handshake retransmissions may be held rather than transmitted
immediately, potentially leading to timeouts and spurious
retransmission.  When DTLS is used over such transports, care should
be taken not to overrun the likely congestion window. <span>[<a href="#RFC5238" class="xref">RFC5238</a>]</span>
defines a mapping of DTLS to DCCP that takes these issues into account.<a href="#section-4.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="pmtu-issues">
<section id="section-4.4">
        <h3 id="name-pmtu-issues">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-pmtu-issues" class="section-name selfRef">PMTU Issues</a>
        </h3>
<p id="section-4.4-1">In general, DTLS's philosophy is to leave PMTU discovery to the application.
However, DTLS cannot completely ignore PMTU for three reasons:<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.4-2.1">The DTLS record framing expands the datagram size, thus lowering
the effective PMTU from the application's perspective.<a href="#section-4.4-2.1" class="pilcrow">¶</a>
</li>
<li id="section-4.4-2.2">In some implementations, the application may not directly talk to
the network, in which case the DTLS stack may absorb ICMP
<span>[<a href="#RFC1191" class="xref">RFC1191</a>]</span> "Datagram Too Big" indications or ICMPv6 <span>[<a href="#RFC4443" class="xref">RFC4443</a>]</span>
"Packet Too Big" indications.<a href="#section-4.4-2.2" class="pilcrow">¶</a>
</li>
<li id="section-4.4-2.3">The DTLS handshake messages can exceed the PMTU.<a href="#section-4.4-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-4.4-3">In order to deal with the first two issues, the DTLS record layer
SHOULD behave as described below.<a href="#section-4.4-3" class="pilcrow">¶</a></p>
<p id="section-4.4-4">If PMTU estimates are available from the underlying transport
protocol, they should be made available to upper layer
protocols. In particular:<a href="#section-4.4-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.4-5.1">For DTLS over UDP, the upper layer protocol SHOULD be allowed to
obtain the PMTU estimate maintained in the IP layer.<a href="#section-4.4-5.1" class="pilcrow">¶</a>
</li>
<li id="section-4.4-5.2">For DTLS over DCCP, the upper layer protocol SHOULD be allowed to
obtain the current estimate of the PMTU.<a href="#section-4.4-5.2" class="pilcrow">¶</a>
</li>
<li id="section-4.4-5.3">For DTLS over TCP or SCTP, which automatically fragment and
reassemble datagrams, there is no PMTU limitation.  However, the
upper layer protocol MUST NOT write any record that exceeds the
maximum record size of 2^14 bytes.<a href="#section-4.4-5.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-4.4-6">Note that DTLS does not defend against spoofed ICMP messages;
implementations SHOULD ignore any such messages that indicate
PMTUs below the IPv4 and IPv6 minimums of 576 and 1280 bytes
respectively<a href="#section-4.4-6" class="pilcrow">¶</a></p>
<p id="section-4.4-7">The DTLS record layer SHOULD allow the upper layer protocol to
discover the amount of record expansion expected by the DTLS
processing.<a href="#section-4.4-7" class="pilcrow">¶</a></p>
<p id="section-4.4-8">If there is a transport protocol indication (either via ICMP or via a
refusal to send the datagram as in Section 14 of <span>[<a href="#RFC4340" class="xref">RFC4340</a>]</span>), then the
DTLS record layer MUST inform the upper layer protocol of the error.<a href="#section-4.4-8" class="pilcrow">¶</a></p>
<p id="section-4.4-9">The DTLS record layer SHOULD NOT interfere with upper layer protocols
performing PMTU discovery, whether via <span>[<a href="#RFC1191" class="xref">RFC1191</a>]</span> or <span>[<a href="#RFC4821" class="xref">RFC4821</a>]</span>
mechanisms.  In particular:<a href="#section-4.4-9" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.4-10.1">Where allowed by the underlying transport protocol, the upper
layer protocol SHOULD be allowed to set the state of the DF bit
(in IPv4) or prohibit local fragmentation (in IPv6).<a href="#section-4.4-10.1" class="pilcrow">¶</a>
</li>
<li id="section-4.4-10.2">If the underlying transport protocol allows the application to
request PMTU probing (e.g., DCCP), the DTLS record layer SHOULD
honor this request.<a href="#section-4.4-10.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-4.4-11">The final issue is the DTLS handshake protocol.  From the perspective
of the DTLS record layer, this is merely another upper layer
protocol.  However, DTLS handshakes occur infrequently and involve
only a few round trips; therefore, the handshake protocol PMTU
handling places a premium on rapid completion over accurate PMTU
discovery.  In order to allow connections under these circumstances,
DTLS implementations SHOULD follow the following rules:<a href="#section-4.4-11" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.4-12.1">If the DTLS record layer informs the DTLS handshake layer that a
message is too big, it SHOULD immediately attempt to fragment it,
using any existing information about the PMTU.<a href="#section-4.4-12.1" class="pilcrow">¶</a>
</li>
<li id="section-4.4-12.2">If repeated retransmissions do not result in a response, and the
PMTU is unknown, subsequent retransmissions SHOULD back off to a
smaller record size, fragmenting the handshake message as
appropriate.  This standard does not specify an exact number of
retransmits to attempt before backing off, but 2-3 seems
appropriate.<a href="#section-4.4-12.2" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="record-payload-protection">
<section id="section-4.5">
        <h3 id="name-record-payload-protection">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-record-payload-protection" class="section-name selfRef">Record Payload Protection</a>
        </h3>
<p id="section-4.5-1">Like TLS, DTLS transmits data as a series of protected records.  The
rest of this section describes the details of that format.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<div id="anti-replay">
<section id="section-4.5.1">
          <h4 id="name-anti-replay">
<a href="#section-4.5.1" class="section-number selfRef">4.5.1. </a><a href="#name-anti-replay" class="section-name selfRef">Anti-Replay</a>
          </h4>
<p id="section-4.5.1-1">Each DTLS record contains a sequence number to provide replay protection.
Sequence number verification SHOULD be performed using the following
sliding window procedure, borrowed from Section 3.4.3 of <span>[<a href="#RFC4303" class="xref">RFC4303</a>]</span>.<a href="#section-4.5.1-1" class="pilcrow">¶</a></p>
<p id="section-4.5.1-2">The received record counter for a session MUST be initialized to
zero when that session is established. For each received record, the
receiver MUST verify that the record contains a sequence number that
does not duplicate the sequence number of any other record received
during the lifetime of the session. This check SHOULD happen after
deprotecting the record; otherwise the record discard might itself
serve as a timing channel for the record number. Note that decompressing
the records number is still a potential timing channel for the record
number, though a less powerful one than whether it was deprotected.<a href="#section-4.5.1-2" class="pilcrow">¶</a></p>
<p id="section-4.5.1-3">Duplicates are rejected through the use of a sliding receive window.
(How the window is implemented is a local matter, but the following
text describes the functionality that the implementation must
exhibit.) The receiver SHOULD pick a window large enough to handle
any plausible reordering, which depends on the data rate.
(The receiver does not notify the sender of the window
size.)<a href="#section-4.5.1-3" class="pilcrow">¶</a></p>
<p id="section-4.5.1-4">The "right" edge of the window represents the highest validated
sequence number value received on the session.  Records that contain
sequence numbers lower than the "left" edge of the window are
rejected.  Records falling within the window are checked against a
list of received records within the window.  An efficient means for
performing this check, based on the use of a bit mask, is described in
Section 3.4.3 of <span>[<a href="#RFC4303" class="xref">RFC4303</a>]</span>. If the received record falls within the
window and is new, or if the record is to the right of the window,
then the record is new.<a href="#section-4.5.1-4" class="pilcrow">¶</a></p>
<p id="section-4.5.1-5">The window MUST NOT be updated until the record has been deprotected
successfully.<a href="#section-4.5.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="handling-invalid-records">
<section id="section-4.5.2">
          <h4 id="name-handling-invalid-records">
<a href="#section-4.5.2" class="section-number selfRef">4.5.2. </a><a href="#name-handling-invalid-records" class="section-name selfRef">Handling Invalid Records</a>
          </h4>
<p id="section-4.5.2-1">Unlike TLS, DTLS is resilient in the face of invalid records (e.g.,
invalid formatting, length, MAC, etc.).  In general, invalid records
SHOULD be silently discarded, thus preserving the association;
however, an error MAY be logged for diagnostic purposes.
Implementations which choose to generate an alert instead, MUST
generate error alerts to avoid attacks where the attacker
repeatedly probes the implementation to see how it responds to
various types of error.  Note that if DTLS is run over UDP, then any
implementation which does this will be extremely susceptible to
denial-of-service (DoS) attacks because UDP forgery is so easy.
Thus, this practice is NOT RECOMMENDED for such transports, both
to increase the reliability of DTLS service and to avoid the risk
of spoofing attacks sending traffic to unrelated third parties.<a href="#section-4.5.2-1" class="pilcrow">¶</a></p>
<p id="section-4.5.2-2">If DTLS is being carried over a transport that is resistant to
forgery (e.g., SCTP with SCTP-AUTH), then it is safer to send alerts
because an attacker will have difficulty forging a datagram that will
not be rejected by the transport layer.<a href="#section-4.5.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="dtls">
<section id="section-5">
      <h2 id="name-the-dtls-handshake-protocol">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-the-dtls-handshake-protocol" class="section-name selfRef">The DTLS Handshake Protocol</a>
      </h2>
<p id="section-5-1">DTLS 1.3 re-uses the TLS 1.3 handshake messages and flows, with
the following changes:<a href="#section-5-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-5-2">
        <li id="section-5-2.1">To handle message loss, reordering, and fragmentation modifications to
the handshake header are necessary.<a href="#section-5-2.1" class="pilcrow">¶</a>
</li>
<li id="section-5-2.2">Retransmission timers are introduced to handle message loss.<a href="#section-5-2.2" class="pilcrow">¶</a>
</li>
<li id="section-5-2.3">A new ACK content type has been added for reliable message delivery of handshake messages.<a href="#section-5-2.3" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-5-3">Note that TLS 1.3 already supports a cookie extension, which is used to
prevent denial-of-service attacks. This DoS prevention mechanism is
described in more detail below since UDP-based protocols are more vulnerable
to amplification attacks than a connection-oriented transport like TCP
that performs return-routability checks as part of the connection establishment.<a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4">DTLS implementations do not use the TLS 1.3 "compatibility mode" described in
Section D.4 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.  DTLS servers MUST NOT echo the
"session_id" value from the client and endpoints MUST NOT send ChangeCipherSpec
messages.<a href="#section-5-4" class="pilcrow">¶</a></p>
<p id="section-5-5">With these exceptions, the DTLS message formats, flows, and logic are
the same as those of TLS 1.3.<a href="#section-5-5" class="pilcrow">¶</a></p>
<div id="dos">
<section id="section-5.1">
        <h3 id="name-denial-of-service-counterme">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-denial-of-service-counterme" class="section-name selfRef">Denial-of-Service Countermeasures</a>
        </h3>
<p id="section-5.1-1">Datagram security protocols are extremely susceptible to a variety of
DoS attacks.  Two attacks are of particular concern:<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-5.1-2">
          <li id="section-5.1-2.1">An attacker can consume excessive resources on the server by
transmitting a series of handshake initiation requests, causing
the server to allocate state and potentially to perform
expensive cryptographic operations.<a href="#section-5.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-5.1-2.2">An attacker can use the server as an amplifier by sending
connection initiation messages with a forged source of the
victim.  The server then sends its response to the victim
machine, thus flooding it. Depending on the selected
parameters this response message can be quite large, as it
is the case for a Certificate message.<a href="#section-5.1-2.2" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-5.1-3">In order to counter both of these attacks, DTLS borrows the stateless
cookie technique used by Photuris <span>[<a href="#RFC2522" class="xref">RFC2522</a>]</span> and IKE <span>[<a href="#RFC7296" class="xref">RFC7296</a>]</span>.  When
the client sends its ClientHello message to the server, the server
MAY respond with a HelloRetryRequest message. The HelloRetryRequest message,
as well as the cookie extension, is defined in TLS 1.3.
The HelloRetryRequest message contains a stateless cookie generated using
the technique of <span>[<a href="#RFC2522" class="xref">RFC2522</a>]</span>. The client MUST retransmit the ClientHello
with the cookie added as an extension.  The server then verifies the cookie
and proceeds with the handshake only if it is valid.  This mechanism forces
the attacker/client to be able to receive the cookie, which makes DoS attacks
with spoofed IP addresses difficult.  This mechanism does not provide any defense
against DoS attacks mounted from valid IP addresses.<a href="#section-5.1-3" class="pilcrow">¶</a></p>
<p id="section-5.1-4">The DTLS 1.3 specification changes the way how cookies are exchanged
compared to DTLS 1.2. DTLS 1.3 re-uses the HelloRetryRequest message
and conveys the cookie to the client via an extension. The client
receiving the cookie uses the same extension to place
the cookie subsequently into a ClientHello message.
DTLS 1.2 on the other hand used a separate message, namely the HelloVerifyRequest,
to pass a cookie to the client and did not utilize the extension mechanism.
For backwards compatibility reasons, the cookie field in the ClientHello
is present in DTLS 1.3 but is ignored by a DTLS 1.3 compliant server
implementation.<a href="#section-5.1-4" class="pilcrow">¶</a></p>
<p id="section-5.1-5">The exchange is shown in <a href="#dtls-cookie-exchange" class="xref">Figure 5</a>. Note that
the figure focuses on the cookie exchange; all other extensions
are omitted.<a href="#section-5.1-5" class="pilcrow">¶</a></p>
<span id="name-dtls-exchange-with-helloret"></span><div id="dtls-cookie-exchange">
<figure id="figure-5">
          <div class="artwork art-text alignLeft" id="section-5.1-6.1">
<pre>
      Client                                   Server
      ------                                   ------
      ClientHello           ------&gt;

                            &lt;----- HelloRetryRequest
                                    + cookie

      ClientHello           ------&gt;
       + cookie

      [Rest of handshake]
</pre>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-dtls-exchange-with-helloret" class="selfRef">DTLS exchange with HelloRetryRequest containing the "cookie" extension</a>
          </figcaption></figure>
</div>
<p id="section-5.1-7">The cookie extension is defined in Section 4.2.2 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>. When sending the
initial ClientHello, the client does not have a cookie yet. In this case,
the cookie extension is omitted and the legacy_cookie field in the ClientHello
message MUST be set to a zero length vector (i.e., a single zero byte length field).<a href="#section-5.1-7" class="pilcrow">¶</a></p>
<p id="section-5.1-8">When responding to a HelloRetryRequest, the client MUST create a new
ClientHello message following the description in Section 4.1.2 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.<a href="#section-5.1-8" class="pilcrow">¶</a></p>
<p id="section-5.1-9">If the HelloRetryRequest message is used, the initial ClientHello and
the HelloRetryRequest are included in the calculation of the
transcript hash. The computation of the
message hash for the HelloRetryRequest is done according to the description
in Section 4.4.1 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.<a href="#section-5.1-9" class="pilcrow">¶</a></p>
<p id="section-5.1-10">The handshake transcript is not reset with the second ClientHello
and a stateless server-cookie implementation requires the transcript
of the HelloRetryRequest to be stored in the cookie or the internal state
of the hash algorithm, since only the hash of the transcript is required
for the handshake to complete.<a href="#section-5.1-10" class="pilcrow">¶</a></p>
<p id="section-5.1-11">When the second ClientHello is received, the server can verify that
the cookie is valid and that the client can receive packets at the
given IP address. If the client's apparent IP address is embedded
in the cookie, this prevents an attacker from generating an acceptable
ClientHello apparently from another user.<a href="#section-5.1-11" class="pilcrow">¶</a></p>
<p id="section-5.1-12">One potential attack on this scheme is for the attacker to collect a
number of cookies from different addresses where it controls endpoints
and then reuse them to attack the server.
The server can defend against this attack by
changing the secret value frequently, thus invalidating those
cookies. If the server wishes to allow legitimate clients to
handshake through the transition (e.g., a client received a cookie with
Secret 1 and then sent the second ClientHello after the server has
changed to Secret 2), the server can have a limited window during
which it accepts both secrets.  <span>[<a href="#RFC7296" class="xref">RFC7296</a>]</span> suggests adding a key
identifier to cookies to detect this case. An alternative approach is
simply to try verifying with both secrets. It is RECOMMENDED that
servers implement a key rotation scheme that allows the server
to manage keys with overlapping lifetime.<a href="#section-5.1-12" class="pilcrow">¶</a></p>
<p id="section-5.1-13">Alternatively, the server can store timestamps in the cookie and
reject cookies that were generated outside a certain
interval of time.<a href="#section-5.1-13" class="pilcrow">¶</a></p>
<p id="section-5.1-14">DTLS servers SHOULD perform a cookie exchange whenever a new
handshake is being performed.  If the server is being operated in an
environment where amplification is not a problem, the server MAY be
configured not to perform a cookie exchange.  The default SHOULD be
that the exchange is performed, however.  In addition, the server MAY
choose not to do a cookie exchange when a session is resumed or, more 
generically, when the DTLS handshake uses a PSK-based key exchange.
Clients MUST be prepared to do a cookie exchange with every
handshake.<a href="#section-5.1-14" class="pilcrow">¶</a></p>
<p id="section-5.1-15">If a server receives a ClientHello with an invalid cookie, it
MUST NOT terminate the handshake with an "illegal_parameter" alert.
This allows the client to restart the connection from
scratch without a cookie.<a href="#section-5.1-15" class="pilcrow">¶</a></p>
<p id="section-5.1-16">As described in Section 4.1.4 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>, clients MUST
abort the handshake with an "unexpected_message" alert in response
to any second HelloRetryRequest which was sent in the same connection
(i.e., where the ClientHello was itself in response to a HelloRetryRequest).<a href="#section-5.1-16" class="pilcrow">¶</a></p>
</section>
</div>
<div id="dtls-handshake-message-format">
<section id="section-5.2">
        <h3 id="name-dtls-handshake-message-form">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-dtls-handshake-message-form" class="section-name selfRef">DTLS Handshake Message Format</a>
        </h3>
<p id="section-5.2-1">In order to support message loss, reordering, and message
fragmentation, DTLS modifies the TLS 1.3 handshake header:<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.2-2">
<pre>
enum {
    client_hello(1),
    server_hello(2),
    new_session_ticket(4),
    end_of_early_data(5),
    encrypted_extensions(8),
    certificate(11),
    certificate_request(13),
    certificate_verify(15),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
} HandshakeType;

struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* bytes in message */
    uint16 message_seq;        /* DTLS-required field */
    uint24 fragment_offset;    /* DTLS-required field */
    uint24 fragment_length;    /* DTLS-required field */
    select (HandshakeType) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    } body;
} Handshake;
</pre><a href="#section-5.2-2" class="pilcrow">¶</a>
</div>
<p id="section-5.2-3">The first message each side transmits in each association always has
message_seq = 0.  Whenever a new message is generated, the
message_seq value is incremented by one. When a message is
retransmitted, the old message_seq value is re-used, i.e., not
incremented. From the perspective of the DTLS record layer, the retransmission is
a new record.  This record will have a new
DTLSPlaintext.sequence_number value.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<p id="section-5.2-4">Note: In DTLS 1.2 the message_seq was reset to zero in case of a
rehandshake (i.e., renegotiation). On the surface, a rehandshake in DTLS 1.2
shares similarities with a post-handshake message exchange in DTLS 1.3. However,
in DTLS 1.3 the message_seq is not reset to allow distinguishing a
retransmission from a previously sent post-handshake message from a newly
sent post-handshake message.<a href="#section-5.2-4" class="pilcrow">¶</a></p>
<p id="section-5.2-5">DTLS implementations maintain (at least notionally) a
next_receive_seq counter.  This counter is initially set to zero.
When a handshake message is received, if its message_seq value matches
next_receive_seq, next_receive_seq is incremented and the message is
processed.  If the sequence number is less than next_receive_seq, the
message MUST be discarded.  If the sequence number is greater than
next_receive_seq, the implementation SHOULD queue the message but MAY
discard it.  (This is a simple space/bandwidth tradeoff).<a href="#section-5.2-5" class="pilcrow">¶</a></p>
<p id="section-5.2-6">In addition to the handshake messages that are deprecated by the TLS 1.3
specification, DTLS 1.3 furthermore deprecates the HelloVerifyRequest message
originally defined in DTLS 1.0. DTLS 1.3-compliant implements MUST NOT
use the HelloVerifyRequest to execute a return-routability check. A
dual-stack DTLS 1.2/DTLS 1.3 client MUST, however, be prepared to
interact with a DTLS 1.2 server.<a href="#section-5.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="clienthello-message">
<section id="section-5.3">
        <h3 id="name-clienthello-message">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-clienthello-message" class="section-name selfRef">ClientHello Message</a>
        </h3>
<p id="section-5.3-1">The format of the ClientHello used by a DTLS 1.3 client differs from the
TLS 1.3 ClientHello format as shown below.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.3-2">
<pre>
uint16 ProtocolVersion;
opaque Random[32];

uint8 CipherSuite[2];    /* Cryptographic suite selector */

struct {
    ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
    Random random;
    opaque legacy_session_id&lt;0..32&gt;;
    opaque legacy_cookie&lt;0..2^8-1&gt;;                  // DTLS
    CipherSuite cipher_suites&lt;2..2^16-2&gt;;
    opaque legacy_compression_methods&lt;1..2^8-1&gt;;
    Extension extensions&lt;8..2^16-1&gt;;
} ClientHello;
</pre><a href="#section-5.3-2" class="pilcrow">¶</a>
</div>
<dl class="dlParallel" id="section-5.3-3">
          <dt id="section-5.3-3.1">legacy_version:</dt>
<dd id="section-5.3-3.2">
  In previous versions of DTLS, this field was used for version
negotiation and represented the highest version number supported by
the client. Experience has shown that many servers do not properly
implement version negotiation, leading to "version intolerance" in
which the server rejects an otherwise acceptable ClientHello with a
version number higher than it supports. In DTLS 1.3, the client
indicates its version preferences in the "supported_versions"
extension (see Section 4.2.1 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>) and the
legacy_version field MUST be set to {254, 253}, which was the version
number for DTLS 1.2. The version fields for DTLS 1.0 and DTLS 1.2 are
0xfeff and 0xfefd (to match the wire versions) but the version field
for DTLS 1.3 is 0x0304.<a href="#section-5.3-3.2" class="pilcrow">¶</a>
</dd>
<dt id="section-5.3-3.3">random:</dt>
<dd id="section-5.3-3.4">
  Same as for TLS 1.3.<a href="#section-5.3-3.4" class="pilcrow">¶</a>
</dd>
<dt id="section-5.3-3.5">legacy_session_id:</dt>
<dd id="section-5.3-3.6">
  Same as for TLS 1.3.<a href="#section-5.3-3.6" class="pilcrow">¶</a>
</dd>
<dt id="section-5.3-3.7">legacy_cookie:</dt>
<dd id="section-5.3-3.8">
  A DTLS 1.3-only client MUST set the legacy_cookie field to zero length.
If a DTLS 1.3 ClientHello is received with any other value in this field,
the server MUST abort the handshake with an "illegal_parameter" alert.<a href="#section-5.3-3.8" class="pilcrow">¶</a>
</dd>
<dt id="section-5.3-3.9">cipher_suites:</dt>
<dd id="section-5.3-3.10">
  Same as for TLS 1.3.<a href="#section-5.3-3.10" class="pilcrow">¶</a>
</dd>
<dt id="section-5.3-3.11">legacy_compression_methods:</dt>
<dd id="section-5.3-3.12">
  Same as for TLS 1.3.<a href="#section-5.3-3.12" class="pilcrow">¶</a>
</dd>
<dt id="section-5.3-3.13">extensions:</dt>
<dd id="section-5.3-3.14">
  Same as for TLS 1.3.<a href="#section-5.3-3.14" class="pilcrow">¶</a>
</dd>
</dl>
</section>
</div>
<div id="handshake-message-fragmentation-and-reassembly">
<section id="section-5.4">
        <h3 id="name-handshake-message-fragmenta">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-handshake-message-fragmenta" class="section-name selfRef">Handshake Message Fragmentation and Reassembly</a>
        </h3>
<p id="section-5.4-1">Each DTLS message MUST fit within a single
transport layer datagram.  However, handshake messages are
potentially bigger than the maximum record size.  Therefore, DTLS
provides a mechanism for fragmenting a handshake message over a
number of records, each of which can be transmitted separately, thus
avoiding IP fragmentation.<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<p id="section-5.4-2">When transmitting the handshake message, the sender divides the
message into a series of N contiguous data ranges. The ranges MUST NOT
overlap.  The sender then creates N handshake messages, all with the
same message_seq value as the original handshake message.  Each new
message is labeled with the fragment_offset (the number of bytes
contained in previous fragments) and the fragment_length (the length
of this fragment).  The length field in all messages is the same as
the length field of the original message.  An unfragmented message is
a degenerate case with fragment_offset=0 and fragment_length=length.
Each range MUST be delivered in a single UDP datagram.<a href="#section-5.4-2" class="pilcrow">¶</a></p>
<p id="section-5.4-3">When a DTLS implementation receives a handshake message fragment, it
MUST buffer it until it has the entire handshake message.  DTLS
implementations MUST be able to handle overlapping fragment ranges.
This allows senders to retransmit handshake messages with smaller
fragment sizes if the PMTU estimate changes.<a href="#section-5.4-3" class="pilcrow">¶</a></p>
<p id="section-5.4-4">Note that as with TLS, multiple handshake messages may be placed in
the same DTLS record, provided that there is room and that they are
part of the same flight.  Thus, there are two acceptable ways to pack
two DTLS messages into the same datagram: in the same record or in
separate records.<a href="#section-5.4-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="end-of-early-data">
<section id="section-5.5">
        <h3 id="name-end-of-early-data">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-end-of-early-data" class="section-name selfRef">End Of Early Data</a>
        </h3>
<p id="section-5.5-1">The DTLS 1.3 handshake has one important difference from the
TLS 1.3 handshake: the EndOfEarlyData message is omitted both
from the wire and the handshake transcript: because DTLS
records have epochs, EndOfEarlyData is not necessary to determine
when the early data is complete, and because DTLS is lossy,
attackers can trivially mount the deletion attacks that EndOfEarlyData
prevents in TLS. Servers SHOULD aggressively
age out the epoch 1 keys upon receiving the first epoch 2 record
and SHOULD NOT accept epoch 1 data after the first epoch 3 record
is received. (See <a href="#dtls-epoch" class="xref">Section 6.1</a> for the definitions of each epoch.)<a href="#section-5.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="dtls-handshake-flights">
<section id="section-5.6">
        <h3 id="name-dtls-handshake-flights">
<a href="#section-5.6" class="section-number selfRef">5.6. </a><a href="#name-dtls-handshake-flights" class="section-name selfRef">DTLS Handshake Flights</a>
        </h3>
<p id="section-5.6-1">DTLS messages are grouped into a series of message flights, according
to the diagrams below.<a href="#section-5.6-1" class="pilcrow">¶</a></p>
<span id="name-message-flights-for-a-full-"></span><div id="dtls-full">
<figure id="figure-6">
          <div class="artwork art-text alignLeft" id="section-5.6-2.1">
<pre>
Client                                             Server

ClientHello                                                 +----------+
 + key_share*                                               | Flight 1 |
 + pre_shared_key*      --------&gt;                           +----------+

                                                            +----------+
                        &lt;--------        HelloRetryRequest  | Flight 2 |
                                          + cookie          +----------+


ClientHello                                                 +----------+
 + key_share*                                               | Flight 3 |
 + pre_shared_key*      --------&gt;                           +----------+
 + cookie

                                               ServerHello
                                              + key_share*
                                         + pre_shared_key*  +----------+
                                     {EncryptedExtensions}  | Flight 4 |
                                     {CertificateRequest*}  +----------+
                                            {Certificate*}
                                      {CertificateVerify*}
                        &lt;--------               {Finished}
                                       [Application Data*]


 {Certificate*}                                             +----------+
 {CertificateVerify*}                                       | Flight 5 |
 {Finished}             --------&gt;                           +----------+
 [Application Data]

                                                            +----------+
                        &lt;--------                    [ACK]  | Flight 6 |
                                       [Application Data*]  +----------+

 [Application Data]     &lt;-------&gt;      [Application Data]
</pre>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-message-flights-for-a-full-" class="selfRef">Message flights for a full DTLS Handshake (with cookie exchange)</a>
          </figcaption></figure>
</div>
<span id="name-message-flights-for-resumpt"></span><div id="dtls-psk">
<figure id="figure-7">
          <div class="artwork art-text alignLeft" id="section-5.6-3.1">
<pre>
 ClientHello                                              +----------+
  + pre_shared_key                                        | Flight 1 |
  + key_share*         --------&gt;                          +----------+


                                             ServerHello
                                        + pre_shared_key  +----------+
                                            + key_share*  | Flight 2 |
                                   {EncryptedExtensions}  +----------+
                       &lt;--------              {Finished}
                                     [Application Data*]
                                                          +----------+
 {Finished}            --------&gt;                          | Flight 3 |
 [Application Data*]                                      +----------+

                                                          +----------+
                       &lt;--------                   [ACK]  | Flight 4 |
                                     [Application Data*]  +----------+

 [Application Data]    &lt;-------&gt;      [Application Data]
</pre>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-message-flights-for-resumpt" class="selfRef">Message flights for resumption and PSK handshake (without cookie exchange)</a>
          </figcaption></figure>
</div>
<span id="name-message-flights-for-the-zer"></span><div id="dtls-zero-rtt">
<figure id="figure-8">
          <div class="artwork art-text alignLeft" id="section-5.6-4.1">
<pre>
Client                                            Server

 ClientHello
  + early_data
  + psk_key_exchange_modes                                +----------+
  + key_share*                                            | Flight 1 |
  + pre_shared_key                                        +----------+
 (Application Data*)     --------&gt;

                                             ServerHello
                                        + pre_shared_key
                                            + key_share*  +----------+
                                   {EncryptedExtensions}  | Flight 2 |
                                              {Finished}  +----------+
                       &lt;--------     [Application Data*]


                                                          +----------+
 {Finished}            --------&gt;                          | Flight 3 |
 [Application Data*]                                      +----------+

                                                          +----------+
                       &lt;--------                   [ACK]  | Flight 4 |
                                     [Application Data*]  +----------+

 [Application Data]    &lt;-------&gt;      [Application Data]
</pre>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-message-flights-for-the-zer" class="selfRef">Message flights for the Zero-RTT handshake</a>
          </figcaption></figure>
</div>
<span id="name-message-flights-for-the-new"></span><div id="dtls-post-handshake-ticket">
<figure id="figure-9">
          <div class="artwork art-text alignLeft" id="section-5.6-5.1">
<pre>
Client                                            Server

                                                          +----------+
                       &lt;--------       [NewSessionTicket] | Flight 1 |
                                                          +----------+

                                                          +----------+
[ACK]                  --------&gt;                          | Flight 2 |
                                                          +----------+
</pre>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-message-flights-for-the-new" class="selfRef">Message flights for the new session ticket message</a>
          </figcaption></figure>
</div>
<p id="section-5.6-6">Note: The application data sent by the client is not included in the
timeout and retransmission calculation.<a href="#section-5.6-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="timeout-and-retransmission">
<section id="section-5.7">
        <h3 id="name-timeout-and-retransmission">
<a href="#section-5.7" class="section-number selfRef">5.7. </a><a href="#name-timeout-and-retransmission" class="section-name selfRef">Timeout and Retransmission</a>
        </h3>
<div id="state-machine">
<section id="section-5.7.1">
          <h4 id="name-state-machine">
<a href="#section-5.7.1" class="section-number selfRef">5.7.1. </a><a href="#name-state-machine" class="section-name selfRef">State Machine</a>
          </h4>
<p id="section-5.7.1-1">DTLS uses a simple timeout and retransmission scheme with the
state machine shown in <a href="#dtls-timeout-state-machine" class="xref">Figure 10</a>.
Because DTLS clients send the first message
(ClientHello), they start in the PREPARING state.  DTLS servers start
in the WAITING state, but with empty buffers and no retransmit timer.<a href="#section-5.7.1-1" class="pilcrow">¶</a></p>
<span id="name-dtls-timeout-and-retransmis"></span><div id="dtls-timeout-state-machine">
<figure id="figure-10">
            <div class="artwork art-text alignLeft" id="section-5.7.1-2.1">
<pre>
                             +-----------+
                             | PREPARING |
                +----------&gt; |           |
                |            |           |
                |            +-----------+
                |                  |
                |                  | Buffer next flight
                |                  |
                |                 \|/
                |            +-----------+
                |            |           |
                |            |  SENDING  |&lt;------------------+
                |            |           |                   |
                |            +-----------+                   |
        Receive |                  |                         |
           next |                  | Send flight or partial  |
         flight |                  | flight                  |
                |  +---------------+                         |
                |  |               | Set retransmit timer    |
                |  |              \|/                        |
                |  |         +-----------+                   |
                |  |         |           |                   |
                +--)---------|  WAITING  |-------------------+
                |  |  +-----&gt;|           |   Timer expires   |
                |  |  |      +-----------+                   |
                |  |  |          |  |   |                    |
                |  |  |          |  |   |                    |
                |  |  +----------+  |   +--------------------+
                |  | Receive record |   Read retransmit or ACK
        Receive |  |  Send ACK      |
           last |  |                |
         flight |  |                | Receive ACK
                |  |                | for last flight
               \|/\|/               |
                                    |
            +-----------+           |
            |           | &lt;---------+
            | FINISHED  |
            |           |
            +-----------+
                |  /|\
                |   |
                |   |
                +---+

          Server read retransmit
              Retransmit ACK
</pre>
</div>
<figcaption><a href="#figure-10" class="selfRef">Figure 10</a>:
<a href="#name-dtls-timeout-and-retransmis" class="selfRef">DTLS timeout and retransmission state machine</a>
            </figcaption></figure>
</div>
<p id="section-5.7.1-3">The state machine has four basic states: PREPARING, SENDING, WAITING,
and FINISHED.<a href="#section-5.7.1-3" class="pilcrow">¶</a></p>
<p id="section-5.7.1-4">In the PREPARING state, the implementation does whatever computations
are necessary to prepare the next flight of messages.  It then
buffers them up for transmission (emptying the buffer first) and
enters the SENDING state.<a href="#section-5.7.1-4" class="pilcrow">¶</a></p>
<p id="section-5.7.1-5">In the SENDING state, the implementation transmits the buffered
flight of messages. If the implementation has received one or more
ACKs (see <a href="#ack-msg" class="xref">Section 7</a>) from the peer, then it SHOULD omit any messages or
message fragments which have already been ACKed. Once the messages
have been sent, the implementation then enters the FINISHED state
if this is the last flight in the handshake.  Or, if the
implementation expects to receive more messages, it sets a
retransmit timer and then enters the WAITING state.<a href="#section-5.7.1-5" class="pilcrow">¶</a></p>
<p id="section-5.7.1-6">There are four ways to exit the WAITING state:<a href="#section-5.7.1-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-5.7.1-7">
            <li id="section-5.7.1-7.1">The retransmit timer expires: the implementation transitions to
the SENDING state, where it retransmits the flight, resets the
retransmit timer, and returns to the WAITING state.<a href="#section-5.7.1-7.1" class="pilcrow">¶</a>
</li>
<li id="section-5.7.1-7.2">The implementation reads an ACK from the peer: upon receiving
an ACK for a partial flight (as mentioned in <a href="#sending-acks" class="xref">Section 7.1</a>),
the implementation transitions
to the SENDING state, where it retransmits the unacked portion
of the flight, resets the retransmit timer, and returns to the
WAITING state. Upon receiving an ACK for a complete flight,
the implementation cancels all retransmissions and either
remains in WAITING, or, if the ACK was for the final flight,
transitions to FINISHED.<a href="#section-5.7.1-7.2" class="pilcrow">¶</a>
</li>
<li id="section-5.7.1-7.3">The implementation reads a retransmitted flight from the peer: the
implementation transitions to the SENDING state, where it
retransmits the flight, resets the retransmit timer, and returns
to the WAITING state.  The rationale here is that the receipt of a
duplicate message is the likely result of timer expiry on the peer
and therefore suggests that part of one's previous flight was
lost.<a href="#section-5.7.1-7.3" class="pilcrow">¶</a>
</li>
<li id="section-5.7.1-7.4">The implementation receives some or all next flight of messages: if
this is the final flight of messages, the implementation
transitions to FINISHED.  If the implementation needs to send a new
flight, it transitions to the PREPARING state. Partial reads
(whether partial messages or only some of the messages in the
flight) may also trigger the implementation to send an ACK, as
described in <a href="#sending-acks" class="xref">Section 7.1</a>.<a href="#section-5.7.1-7.4" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-5.7.1-8">Because DTLS clients send the first message (ClientHello), they start
in the PREPARING state.  DTLS servers start in the WAITING state, but
with empty buffers and no retransmit timer.<a href="#section-5.7.1-8" class="pilcrow">¶</a></p>
<p id="section-5.7.1-9">In addition, for at least twice the default Maximum Segment Lifetime
(MSL) defined for <span>[<a href="#RFC0793" class="xref">RFC0793</a>]</span>, when in the FINISHED state, the server
MUST respond to retransmission of the client's second flight with
a retransmit of its ACK.<a href="#section-5.7.1-9" class="pilcrow">¶</a></p>
<p id="section-5.7.1-10">Note that because of packet loss, it is possible for one side to be
sending application data even though the other side has not received
the first side's Finished message.  Implementations MUST either
discard or buffer all application data records for the new epoch
until they have received the Finished message for that epoch.
Implementations MAY treat receipt of application data with a new
epoch prior to receipt of the corresponding Finished message as
evidence of reordering or packet loss and retransmit their final
flight immediately, shortcutting the retransmission timer.<a href="#section-5.7.1-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="timer-values">
<section id="section-5.7.2">
          <h4 id="name-timer-values">
<a href="#section-5.7.2" class="section-number selfRef">5.7.2. </a><a href="#name-timer-values" class="section-name selfRef">Timer Values</a>
          </h4>
<p id="section-5.7.2-1">Though timer values are the choice of the implementation, mishandling
of the timer can lead to serious congestion problems; for example, if
many instances of a DTLS time out early and retransmit too quickly on
a congested link.  Implementations SHOULD use an initial timer value
of 100 msec (the minimum defined in RFC 6298 <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>) and double
the value at each retransmission, up to no less than the RFC 6298
maximum of 60 seconds. Application specific profiles, such as those
used for the Internet of Things environment, may recommend longer
timer values. Note that a 100 msec timer is recommended
rather than the 3-second RFC 6298 default in order to improve latency
for time-sensitive applications.  Because DTLS only uses
retransmission for handshake and not dataflow, the effect on
congestion should be minimal.<a href="#section-5.7.2-1" class="pilcrow">¶</a></p>
<p id="section-5.7.2-2">Implementations SHOULD retain the current timer value until a
transmission without loss occurs, at which time the value may be
reset to the initial value.  After a long period of idleness, no less
than 10 times the current timer value, implementations may reset the
timer to the initial value.<a href="#section-5.7.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="certificateverify-and-finished-messages">
<section id="section-5.8">
        <h3 id="name-certificateverify-and-finis">
<a href="#section-5.8" class="section-number selfRef">5.8. </a><a href="#name-certificateverify-and-finis" class="section-name selfRef">CertificateVerify and Finished Messages</a>
        </h3>
<p id="section-5.8-1">CertificateVerify and Finished messages have the same format as in
TLS 1.3.  Hash calculations include entire handshake messages, including
DTLS-specific fields: message_seq, fragment_offset, and
fragment_length.  However, in order to remove sensitivity to
handshake message fragmentation, the CertificateVerify and the Finished messages MUST be computed as
if each handshake message had been sent as a single fragment following
the algorithm described in Section 4.4.3 and Section 4.4.4 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>, respectively.<a href="#section-5.8-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="cryptographic-label-prefix">
<section id="section-5.9">
        <h3 id="name-cryptographic-label-prefix">
<a href="#section-5.9" class="section-number selfRef">5.9. </a><a href="#name-cryptographic-label-prefix" class="section-name selfRef">Cryptographic Label Prefix</a>
        </h3>
<p id="section-5.9-1">Section 7.1 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span> specifies that HKDF-Expand-Label uses
a label prefix of "tls13 ". For DTLS 1.3, that label SHALL be
"dtls13".  This ensures key separation between DTLS 1.3 and
TLS 1.3. Note that there is no trailing space; this is necessary
in order to keep the overall label size inside of one hash
iteration because "DTLS" is one letter longer than "TLS".<a href="#section-5.9-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="alert-messages">
<section id="section-5.10">
        <h3 id="name-alert-messages">
<a href="#section-5.10" class="section-number selfRef">5.10. </a><a href="#name-alert-messages" class="section-name selfRef">Alert Messages</a>
        </h3>
<p id="section-5.10-1">Note that Alert messages are not retransmitted at all, even when they
occur in the context of a handshake.  However, a DTLS implementation
which would ordinarily issue an alert SHOULD generate a new alert
message if the offending record is received again (e.g., as a
retransmitted handshake message).  Implementations SHOULD detect when
a peer is persistently sending bad messages and terminate the local
connection state after such misbehavior is detected.<a href="#section-5.10-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="establishing-new-associations-with-existing-parameters">
<section id="section-5.11">
        <h3 id="name-establishing-new-associatio">
<a href="#section-5.11" class="section-number selfRef">5.11. </a><a href="#name-establishing-new-associatio" class="section-name selfRef">Establishing New Associations with Existing Parameters</a>
        </h3>
<p id="section-5.11-1">If a DTLS client-server pair is configured in such a way that
repeated connections happen on the same host/port quartet, then it is
possible that a client will silently abandon one connection and then
initiate another with the same parameters (e.g., after a reboot).
This will appear to the server as a new handshake with epoch=0.  In
cases where a server believes it has an existing association on a
given host/port quartet and it receives an epoch=0 ClientHello, it
SHOULD proceed with a new handshake but MUST NOT destroy the existing
association until the client has demonstrated reachability either by
completing a cookie exchange or by completing a complete handshake
including delivering a verifiable Finished message.  After a correct
Finished message is received, the server MUST abandon the previous
association to avoid confusion between two valid associations with
overlapping epochs.  The reachability requirement prevents
off-path/blind attackers from destroying associations merely by
sending forged ClientHellos.<a href="#section-5.11-1" class="pilcrow">¶</a></p>
<p id="section-5.11-2">Note: it is not always possible to distinguish which association
a given record is from. For instance, if the client performs
a handshake, abandons the connection, and then immediately starts
a new handshake, it may not be possible to tell which connection
a given protected record is for. In these cases, trial decryption
MAY be necessary, though implementations could use the CID concept.<a href="#section-5.11-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="example-of-handshake-with-timeout-and-retransmission">
<section id="section-6">
      <h2 id="name-example-of-handshake-with-t">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-example-of-handshake-with-t" class="section-name selfRef">Example of Handshake with Timeout and Retransmission</a>
      </h2>
<p id="section-6-1">The following is an example of a handshake with lost packets and
retransmissions.<a href="#section-6-1" class="pilcrow">¶</a></p>
<span id="name-example-dtls-exchange-illus"></span><div id="dtls-msg-loss">
<figure id="figure-11">
        <div class="artwork art-text alignLeft" id="section-6-2.1">
<pre>
Client                                                Server
------                                                ------

 Record 0                  --------&gt;
 ClientHello
 (message_seq=0)

                             X&lt;-----                 Record 0
                             (lost)               ServerHello
                                              (message_seq=1)
                                          EncryptedExtensions
                                              (message_seq=2)
                                                  Certificate
                                              (message_seq=3)


                           &lt;--------                 Record 1
                                            CertificateVerify
                                              (message_seq=4)
                                                     Finished
                                              (message_seq=5)

 Record 1                  --------&gt;
 ACK [1]


                           &lt;--------                 Record 2
                                                  ServerHello
                                              (message_seq=1)
                                          EncryptedExtensions
                                              (message_seq=2)
                                                  Certificate
                                              (message_seq=3)

 Record 2                  --------&gt;
 Certificate
 (message_seq=1)
 CertificateVerify
 (message_seq=2)
 Finished
 (message_seq=3)

                           &lt;--------               Record 3
                                                    ACK [2]

</pre>
</div>
<figcaption><a href="#figure-11" class="selfRef">Figure 11</a>:
<a href="#name-example-dtls-exchange-illus" class="selfRef">Example DTLS exchange illustrating message loss</a>
        </figcaption></figure>
</div>
<div id="dtls-epoch">
<section id="section-6.1">
        <h3 id="name-epoch-values-and-rekeying">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-epoch-values-and-rekeying" class="section-name selfRef">Epoch Values and Rekeying</a>
        </h3>
<p id="section-6.1-1">A recipient of a DTLS message needs to select the correct keying material
in order to process an incoming message. With the possibility of message
 loss and re-order an identifier is needed to determine which cipher state
has been used to protect the record payload. The epoch value fulfills this
role in DTLS. In addition to the key derivation steps described in
Section 7 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span> triggered by the states during the handshake
a sender may want to rekey at any time during
the lifetime of the connection and has to have a way to indicate that it is
updating its sending cryptographic keys.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">This version of DTLS assigns dedicated epoch values to messages in the
protocol exchange to allow identification of the correct cipher state:<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-6.1-3.1">epoch value (0) is used with unencrypted messages. There are
three unencrypted messages in DTLS, namely ClientHello, ServerHello,
and HelloRetryRequest.<a href="#section-6.1-3.1" class="pilcrow">¶</a>
</li>
<li id="section-6.1-3.2">epoch value (1) is used for messages protected using keys derived
from client_early_traffic_secret. Note this epoch is skipped if
the client does not offer early data.<a href="#section-6.1-3.2" class="pilcrow">¶</a>
</li>
<li id="section-6.1-3.3">epoch value (2) is used for messages protected using keys derived
from [sender]_handshake_traffic_secret. Messages transmitted during
the initial handshake, such as EncryptedExtensions,
CertificateRequest, Certificate, CertificateVerify, and Finished
belong to this category. Note, however, post-handshake are
protected under the appropriate application traffic key and are not included in this category.<a href="#section-6.1-3.3" class="pilcrow">¶</a>
</li>
<li id="section-6.1-3.4">epoch value (3) is used for payloads protected using keys derived
from the initial [sender]_application_traffic_secret_0. This may include
handshake messages, such as post-handshake messages (e.g., a
NewSessionTicket message).<a href="#section-6.1-3.4" class="pilcrow">¶</a>
</li>
<li id="section-6.1-3.5">epoch value (4 to 2^16-1) is used for payloads protected using keys from
the [sender]_application_traffic_secret_N (N&gt;0).<a href="#section-6.1-3.5" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-6.1-4">Using these reserved epoch values a receiver knows what cipher state
has been used to encrypt and integrity protect a
message. Implementations that receive a payload with an epoch value
for which no corresponding cipher state can be determined MUST
generate a "unexpected_message" alert. For example, client incorrectly
uses epoch value 5 when sending early application data in a 0-RTT
exchange. A server will not be able to compute the appropriate keys
and will therefore have to respond with an alert.<a href="#section-6.1-4" class="pilcrow">¶</a></p>
<p id="section-6.1-5">Note that epoch values do not wrap. If a DTLS implementation would
need to wrap the epoch value, it MUST terminate the connection.<a href="#section-6.1-5" class="pilcrow">¶</a></p>
<p id="section-6.1-6">The traffic key calculation is described in Section 7.3 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.<a href="#section-6.1-6" class="pilcrow">¶</a></p>
<p id="section-6.1-7"><a href="#dtls-msg-epoch" class="xref">Figure 12</a> illustrates the epoch values in an example DTLS handshake.<a href="#section-6.1-7" class="pilcrow">¶</a></p>
<span id="name-example-dtls-exchange-with-"></span><div id="dtls-msg-epoch">
<figure id="figure-12">
          <div class="artwork art-text alignLeft" id="section-6.1-8.1">
<pre>
Client                                             Server
------                                             ------

 ClientHello
 (epoch=0)
                            --------&gt;

                            &lt;--------       HelloRetryRequest
                                                    (epoch=0)

 ClientHello                --------&gt;
 (epoch=0)

                            &lt;--------             ServerHello
                                                    (epoch=0)
                                        {EncryptedExtensions}
                                                    (epoch=2)
                                                {Certificate}
                                                    (epoch=2)
                                          {CertificateVerify}
                                                    (epoch=2)
                                                   {Finished}
                                                    (epoch=2)

 {Certificate}              --------&gt;
 (epoch=2)
 {CertificateVerify}
 (epoch=2)
 {Finished}
 (epoch=2)

                            &lt;--------                   [ACK]
                                                    (epoch=3)

 [Application Data]         --------&gt;
 (epoch=3)

                            &lt;--------      [Application Data]
                                                    (epoch=3)

                         Some time later ...
                 (Post-Handshake Message Exchange)

                            &lt;--------      [NewSessionTicket]
                                                    (epoch=3)

 [ACK]                      --------&gt;
 (epoch=3)

                         Some time later ...
                           (Rekeying)

                            &lt;--------      [Application Data]
                                                    (epoch=4)
 [Application Data]         --------&gt;
 (epoch=4)
</pre>
</div>
<figcaption><a href="#figure-12" class="selfRef">Figure 12</a>:
<a href="#name-example-dtls-exchange-with-" class="selfRef">Example DTLS exchange with epoch information</a>
          </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<div id="ack-msg">
<section id="section-7">
      <h2 id="name-ack-message">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-ack-message" class="section-name selfRef">ACK Message</a>
      </h2>
<p id="section-7-1">The ACK message is used by an endpoint to indicate handshake-containing
the TLS records it has received from the other side. ACK is not
a handshake message but is rather a separate content type,
with code point TBD (proposed, 25). This avoids having ACK being added
to the handshake transcript. Note that ACKs can still be
sent in the same UDP datagram as handshake records.<a href="#section-7-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7-2">
<pre>
struct {
    RecordNumber record_numbers&lt;0..2^16-1&gt;;
} ACK;
</pre><a href="#section-7-2" class="pilcrow">¶</a>
</div>
<dl class="dlParallel" id="section-7-3">
        <dt id="section-7-3.1">record_numbers:</dt>
<dd id="section-7-3.2">
  a list of the records containing handshake messages in the current
flight which the endpoint has received and either processed or buffered,
in numerically increasing
order.<a href="#section-7-3.2" class="pilcrow">¶</a>
</dd>
</dl>
<p id="section-7-4">Implementations MUST NOT acknowledge records containing
non-duplicative handshake messages or fragments which have not been
processed or buffered. Otherwise, deadlock can ensue.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">During the handshake, ACKs only cover the current outstanding flight (this is
possible because DTLS is generally a lockstep protocol). Thus, an ACK
from the server would not cover both the ClientHello and the client's
Certificate. Implementations can accomplish this by clearing their ACK
list upon receiving the start of the next flight.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">After the handshake, ACKs SHOULD be sent once for each received
and processed record (potentially subject to some delay) and MAY
cover more than one flight.<a href="#section-7-6" class="pilcrow">¶</a></p>
<p id="section-7-7">ACK records MUST be sent with an epoch that is equal to or higher
than the record which is being acknowledged. Implementations SHOULD
simply use the current key.<a href="#section-7-7" class="pilcrow">¶</a></p>
<div id="sending-acks">
<section id="section-7.1">
        <h3 id="name-sending-acks">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-sending-acks" class="section-name selfRef">Sending ACKs</a>
        </h3>
<p id="section-7.1-1">When an implementation receives a partial flight, it SHOULD generate
an ACK that covers the messages from that flight which it has
received so far. Implementations have some discretion about when
to generate ACKs, but it is RECOMMENDED that they do so under
two circumstances:<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-7.1-2.1">When they receive a message or fragment which is out of order,
either because it is not the next expected message or because
it is not the next piece of the current message. Implementations
MUST NOT send ACKs for handshake messages which they discard
as out-of-order, because otherwise those messages will not be
retransmitted.<a href="#section-7.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-7.1-2.2">When they have received part of a flight and do not immediately
receive the rest of the flight (which may be in the same UDP
datagram). A reasonable approach here is to
set a timer for 1/4 the current retransmit timer value when
the first record in the flight is received and then send an
ACK when that timer expires.<a href="#section-7.1-2.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-7.1-3">In addition, implementations MUST send ACKs upon receiving
all of any flight which they do not respond to with their
own messages. Specifically, this means the client's final
flight of the main handshake, the server's transmission
of the NewSessionTicket, and KeyUpdate messages.
ACKs SHOULD NOT be sent for other
complete flights because they are implicitly acknowledged
by the receipt of the next flight, which generally
immediately follows the flight. Each NewSessionTicket
or KeyUpdate is an individual flight; in particular, a KeyUpdate
sent in response to a KeyUpdate with update_requested does not
implicitly acknowledge that message. Implementations MAY
acknowledge the records corresponding to each transmission of
that flight or simply acknowledge the most recent one.<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<p id="section-7.1-4">ACKs MUST NOT be sent for other records of any content type
other than handshake or for records which cannot be unprotected.<a href="#section-7.1-4" class="pilcrow">¶</a></p>
<p id="section-7.1-5">Note that in some cases it may be necessary to send an ACK which
does not contain any record numbers. For instance, a client
might receive an EncryptedExtensions message prior to receiving
a ServerHello. Because it cannot decrypt the EncryptedExtensions,
it cannot safely acknowledge it (as it might be damaged). If the client
does not send an ACK, the server will eventually retransmit
its first flight, but this might take far longer than the
actual round trip time between client and server. Having
the client send an empty ACK shortcuts this process.<a href="#section-7.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="receiving-acks">
<section id="section-7.2">
        <h3 id="name-receiving-acks">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-receiving-acks" class="section-name selfRef">Receiving ACKs</a>
        </h3>
<p id="section-7.2-1">When an implementation receives an ACK, it SHOULD record that the
messages or message fragments sent in the records being
ACKed were received and omit them from any future
retransmissions. Upon receipt of an ACK for only some messages
from a flight, an implementation SHOULD retransmit the remaining
messages or fragments. Note that this requires implementations to
track which messages appear in which records. Once all the messages in a flight have been
acknowledged, the implementation MUST cancel all retransmissions
of that flight. As noted above, the receipt of any record responding
to a given flight MUST be taken as an implicit acknowledgement for the entire
flight.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="key-updates">
<section id="section-8">
      <h2 id="name-key-updates">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-key-updates" class="section-name selfRef">Key Updates</a>
      </h2>
<p id="section-8-1">As with TLS 1.3, DTLS 1.3 implementations send a KeyUpdate message to
indicate that they are updating their sending keys.  As with other
handshake messages with no built-in response, KeyUpdates MUST be
acknowledged.  In order to facilitate epoch reconstruction
<a href="#reconstructing" class="xref">Section 4.2.2</a> implementations MUST NOT send with the new keys or
send a new KeyUpdate until the previous KeyUpdate has been
acknowledged (this avoids having too many epochs in active use).<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">Due to loss and/or re-ordering, DTLS 1.3 implementations
may receive a record with an older epoch than the
current one (the requirements above preclude receiving
a newer record). They SHOULD attempt to process those records
with that epoch (see <a href="#reconstructing" class="xref">Section 4.2.2</a> for information
on determining the correct epoch), but MAY opt to discard
such out-of-epoch records.<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">Although KeyUpdate MUST be acknowledged, it is possible for the ACK to be
lost, in which case the sender of the KeyUpdate will retransmit it.
Implementations MUST retain the ability to ACK the KeyUpdate for
up to 2MSL. It is RECOMMENDED that they do so by retaining the
pre-update keying material, but they MAY do so by responding
to messages which appear to be out-of-epoch with a canned ACK
message; in this case, implementations SHOULD rate limit how
often they send such ACKs.<a href="#section-8-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="connection-id-updates">
<section id="section-9">
      <h2 id="name-connection-id-updates">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-connection-id-updates" class="section-name selfRef">Connection ID Updates</a>
      </h2>
<p id="section-9-1">If the client and server have negotiated the "connection_id"
extension <span>[<a href="#I-D.ietf-tls-dtls-connection-id" class="xref">I-D.ietf-tls-dtls-connection-id</a>]</span>, either side
can send a new CID which it wishes the other side to use
in a NewConnectionId message.<a href="#section-9-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-9-2">
<pre>
enum {
    cid_immediate(0), cid_spare(1), (255)
} ConnectionIdUsage;

opaque ConnectionId&lt;0..2^8-1&gt;;

struct {
    ConnectionIds cids&lt;0..2^16-1&gt;;
    ConnectionIdUsage usage;
} NewConnectionId;
</pre><a href="#section-9-2" class="pilcrow">¶</a>
</div>
<dl class="dlParallel" id="section-9-3">
        <dt id="section-9-3.1">cid</dt>
<dd id="section-9-3.2">
  Indicates the set of CIDs which the sender wishes the peer to use.<a href="#section-9-3.2" class="pilcrow">¶</a>
</dd>
<dt id="section-9-3.3">usage</dt>
<dd id="section-9-3.4">
  Indicates whether the new CIDs should be used immediately or are
spare.  If usage is set to "cid_immediate", then one of the new CID
MUST be used immediately for all future records. If it is set to
"cid_spare", then either existing or new CID MAY be used.<a href="#section-9-3.4" class="pilcrow">¶</a>
</dd>
</dl>
<p id="section-9-4">Endpoints SHOULD use receiver-provided CIDs in the order they were provided.
Endpoints MUST NOT have more than one NewConnectionId message outstanding.<a href="#section-9-4" class="pilcrow">¶</a></p>
<p id="section-9-5">If the client and server have negotiated the "connection_id" extension,
either side can request a new CID using the RequestConnectionId message.<a href="#section-9-5" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-9-6">
<pre>
struct {
  uint8 num_cids;
} RequestConnectionId;
</pre><a href="#section-9-6" class="pilcrow">¶</a>
</div>
<dl class="dlParallel" id="section-9-7">
        <dt id="section-9-7.1">num_cids</dt>
<dd id="section-9-7.2">
  The number of CIDs desired.<a href="#section-9-7.2" class="pilcrow">¶</a>
</dd>
</dl>
<p id="section-9-8">Endpoints SHOULD respond to RequestConnectionId by sending a
NewConnectionId with usage "cid_spare" containing num_cid CIDs soon as
possible.  Endpoints MUST NOT send a RequestConnectionId message
when an existing request is still unfulfilled; this implies that
endpoints needs to request new CIDs well in advance.  An endpoint MAY
ignore requests, which it considers excessive (though they MUST be
acknowledged as usual).<a href="#section-9-8" class="pilcrow">¶</a></p>
<p id="section-9-9">Endpoints MUST NOT send either of these messages if they did not negotiate a
CID. If an implementation receives these messages when CIDs
were not negotiated, it MUST abort the connection with an unexpected_message
alert.<a href="#section-9-9" class="pilcrow">¶</a></p>
<div id="connection-id-example">
<section id="section-9.1">
        <h3 id="name-connection-id-example">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-connection-id-example" class="section-name selfRef">Connection ID Example</a>
        </h3>
<p id="section-9.1-1">Below is an example exchange for DTLS 1.3 using a single
CID in each direction.<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<p id="section-9.1-2">Note: The connection_id extension is defined in
<span>[<a href="#I-D.ietf-tls-dtls-connection-id" class="xref">I-D.ietf-tls-dtls-connection-id</a>]</span>, which is used
in ClientHello and ServerHello messages.<a href="#section-9.1-2" class="pilcrow">¶</a></p>
<span id="name-example-dtls-13-exchange-wi"></span><div id="dtls-example">
<figure id="figure-13">
          <div class="artwork art-text alignLeft" id="section-9.1-3.1">
<pre>
Client                                             Server
------                                             ------

ClientHello
(connection_id=5)
                            --------&gt;


                            &lt;--------       HelloRetryRequest
                                                     (cookie)

ClientHello                 --------&gt;
(connection_id=5)
  +cookie

                            &lt;--------             ServerHello
                                          (connection_id=100)
                                          EncryptedExtensions
                                                      (cid=5)
                                                  Certificate
                                                      (cid=5)
                                            CertificateVerify
                                                      (cid=5)
                                                     Finished
                                                      (cid=5)

Certificate                --------&gt;
(cid=100)
CertificateVerify
(cid=100)
Finished
(cid=100)
                           &lt;--------                      Ack
                                                      (cid=5)

Application Data           ========&gt;
(cid=100)
                           &lt;========         Application Data
                                                      (cid=5)
</pre>
</div>
<figcaption><a href="#figure-13" class="selfRef">Figure 13</a>:
<a href="#name-example-dtls-13-exchange-wi" class="selfRef">Example DTLS 1.3 Exchange with CIDs</a>
          </figcaption></figure>
</div>
<p id="section-9.1-4">If no CID is negotiated, then the receiver MUST reject any
records it receives that contain a CID.<a href="#section-9.1-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="application-data-protocol">
<section id="section-10">
      <h2 id="name-application-data-protocol">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-application-data-protocol" class="section-name selfRef">Application Data Protocol</a>
      </h2>
<p id="section-10-1">Application data messages are carried by the record layer and are fragmented
and encrypted based on the current connection state. The messages
are treated as transparent data to the record layer.<a href="#section-10-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-considerations">
<section id="section-11">
      <h2 id="name-security-considerations">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-11-1">Security issues are discussed primarily in <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>.<a href="#section-11-1" class="pilcrow">¶</a></p>
<p id="section-11-2">The primary additional security consideration raised by DTLS is that
of denial of service.  DTLS includes a cookie exchange designed to
protect against denial of service.  However, implementations that do
not use this cookie exchange are still vulnerable to DoS.  In
particular, DTLS servers that do not use the cookie exchange may be
used as attack amplifiers even if they themselves are not
experiencing DoS.  Therefore, DTLS servers SHOULD use the cookie
exchange unless there is good reason to believe that amplification is
not a threat in their environment.  Clients MUST be prepared to do a
cookie exchange with every handshake.<a href="#section-11-2" class="pilcrow">¶</a></p>
<p id="section-11-3">DTLS implementations MUST NOT update their sending address in response
to packets from a different address unless they first perform some
reachability test; no such test is defined in this specification. Even
with such a test, An on-path adversary can also black-hole traffic or
create a reflection attack against third parties because a DTLS peer
has no means to distinguish a genuine address update event (for
example, due to a NAT rebinding) from one that is malicious. This
attack is of concern when there is a large asymmetry of
request/response message sizes.<a href="#section-11-3" class="pilcrow">¶</a></p>
<p id="section-11-4">With the exception of order protection and non-replayability, the security
guarantees for DTLS 1.3 are the same as TLS 1.3. While TLS always provides
order protection and non-replayability, DTLS does not provide order protection
and may not provide replay protection.<a href="#section-11-4" class="pilcrow">¶</a></p>
<p id="section-11-5">Unlike TLS implementations, DTLS implementations SHOULD NOT respond
to invalid records by terminating the connection.<a href="#section-11-5" class="pilcrow">¶</a></p>
<p id="section-11-6">If implementations process out-of-epoch records as recommended in
<a href="#key-updates" class="xref">Section 8</a>, then this creates a denial of service risk since an adversary could
inject records with fake epoch values, forcing the recipient
to compute the next-generation application_traffic_secret using the
HKDF-Expand-Label construct to only find out that the message was
does not pass the AEAD cipher processing. The impact of this
attack is small since the HKDF-Expand-Label only performs symmetric
key hashing operations. Implementations which are concerned about
this form of attack can discard out-of-epoch records.<a href="#section-11-6" class="pilcrow">¶</a></p>
<p id="section-11-7">The security and privacy properties of the CID for DTLS 1.3 builds
on top of what is described in <span>[<a href="#I-D.ietf-tls-dtls-connection-id" class="xref">I-D.ietf-tls-dtls-connection-id</a>]</span>. There are,
however, several improvements:<a href="#section-11-7" class="pilcrow">¶</a></p>
<ul>
<li id="section-11-8.1">The use of the Post-Handshake message allows the client and the server
to update their CIDs and those values are exchanged with confidentiality
protection.<a href="#section-11-8.1" class="pilcrow">¶</a>
</li>
<li id="section-11-8.2">With multi-homing, an adversary is able to correlate the communication
interaction over the two paths, which adds further privacy concerns. In order
to prevent this, implementations SHOULD attempt to use fresh CIDs
whenever they change local addresses or ports (though this is not always
possible to detect). The RequestConnectionId message can be used by a peer
to ask for new CIDs to ensure that a pool of suitable CIDs is available.<a href="#section-11-8.2" class="pilcrow">¶</a>
</li>
<li id="section-11-8.3">Switching CID based on certain events, or even regularly, helps against
tracking by on-path adversaries but the sequence numbers can still allow
linkability. For this reason this specification defines an algorithm for encrypting
sequence numbers, see <a href="#sne" class="xref">Section 4.2.3</a>. Note that sequence number encryption is used for
all encrypted DTLS 1.3 records irrespectively of the use of a CID.<a href="#section-11-8.3" class="pilcrow">¶</a>
</li>
<li id="section-11-8.4">DTLS 1.3 encrypts handshake messages much earlier than in previous
DTLS versions. Therefore, less information identifying the DTLS client, such as
the client certificate, is available to an on-path adversary.<a href="#section-11-8.4" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="changes-to-dtls-12">
<section id="section-12">
      <h2 id="name-changes-to-dtls-12">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-changes-to-dtls-12" class="section-name selfRef">Changes to DTLS 1.2</a>
      </h2>
<p id="section-12-1">Since TLS 1.3 introduces a large number of changes to TLS 1.2, the list
of changes from DTLS 1.2 to DTLS 1.3 is equally large. For this reason
this section focuses on the most important changes only.<a href="#section-12-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-12-2.1">New handshake pattern, which leads to a shorter message exchange<a href="#section-12-2.1" class="pilcrow">¶</a>
</li>
<li id="section-12-2.2">Only AEAD ciphers are supported. Additional data calculation has been simplified.<a href="#section-12-2.2" class="pilcrow">¶</a>
</li>
<li id="section-12-2.3">Removed support for weaker and older cryptographic algorithms<a href="#section-12-2.3" class="pilcrow">¶</a>
</li>
<li id="section-12-2.4">HelloRetryRequest of TLS 1.3 used instead of HelloVerifyRequest<a href="#section-12-2.4" class="pilcrow">¶</a>
</li>
<li id="section-12-2.5">More flexible ciphersuite negotiation<a href="#section-12-2.5" class="pilcrow">¶</a>
</li>
<li id="section-12-2.6">New session resumption mechanism<a href="#section-12-2.6" class="pilcrow">¶</a>
</li>
<li id="section-12-2.7">PSK authentication redefined<a href="#section-12-2.7" class="pilcrow">¶</a>
</li>
<li id="section-12-2.8">New key derivation hierarchy utilizing a new key derivation construct<a href="#section-12-2.8" class="pilcrow">¶</a>
</li>
<li id="section-12-2.9">Improved version negotiation<a href="#section-12-2.9" class="pilcrow">¶</a>
</li>
<li id="section-12-2.10">Optimized record layer encoding and thereby its size<a href="#section-12-2.10" class="pilcrow">¶</a>
</li>
<li id="section-12-2.11">Added CID functionality<a href="#section-12-2.11" class="pilcrow">¶</a>
</li>
<li id="section-12-2.12">Sequence numbers are encrypted.<a href="#section-12-2.12" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="iana-considerations">
<section id="section-13">
      <h2 id="name-iana-considerations">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-13-1">IANA is requested to allocate a new value in the "TLS ContentType"
registry for the ACK message, defined in <a href="#ack-msg" class="xref">Section 7</a>, with content type 26.
The value for the "DTLS-OK" column is "Y".  IANA is requested to reserve
the content type range 32-63 so that content types in this range are not
allocated.<a href="#section-13-1" class="pilcrow">¶</a></p>
<p id="section-13-2">IANA is requested to allocate two values in the "TLS Handshake Type"
registry, defined in <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>, for RequestConnectionId (TBD), and
NewConnectionId (TBD), as defined in this document.  The value for the
"DTLS-OK" columns are "Y".<a href="#section-13-2" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-14">
      <h2 id="name-references">
<a href="#section-14" class="section-number selfRef">14. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-14.1">
        <h3 id="name-normative-references">
<a href="#section-14.1" class="section-number selfRef">14.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="CHACHA">[CHACHA]</dt>
<dd>
<span class="refAuthor">Nir, Y.</span><span class="refAuthor"> and A. Langley</span>, <span class="refTitle">"ChaCha20 and Poly1305 for IETF Protocols"</span>, <span class="seriesInfo">RFC 8439</span>, <span class="seriesInfo">DOI 10.17487/RFC8439</span>, <time datetime="2018-06">June 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8439">https://www.rfc-editor.org/info/rfc8439</a>&gt;</span>. </dd>
<dt id="I-D.ietf-tls-dtls-connection-id">[I-D.ietf-tls-dtls-connection-id]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span><span class="refAuthor">, Tschofenig, H.</span><span class="refAuthor">, and T. Fossati</span>, <span class="refTitle">"Connection Identifiers for DTLS 1.2"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tls-dtls-connection-id-07</span>, <time datetime="2019-10-21">21 October 2019</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-dtls-connection-id-07.txt">http://www.ietf.org/internet-drafts/draft-ietf-tls-dtls-connection-id-07.txt</a>&gt;</span>. </dd>
<dt id="RFC0768">[RFC0768]</dt>
<dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"User Datagram Protocol"</span>, <span class="seriesInfo">STD 6</span>, <span class="seriesInfo">RFC 768</span>, <span class="seriesInfo">DOI 10.17487/RFC0768</span>, <time datetime="1980-08">August 1980</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc768">https://www.rfc-editor.org/info/rfc768</a>&gt;</span>. </dd>
<dt id="RFC0793">[RFC0793]</dt>
<dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Transmission Control Protocol"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 793</span>, <span class="seriesInfo">DOI 10.17487/RFC0793</span>, <time datetime="1981-09">September 1981</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;</span>. </dd>
<dt id="RFC1191">[RFC1191]</dt>
<dd>
<span class="refAuthor">Mogul, J.C.</span><span class="refAuthor"> and S.E. Deering</span>, <span class="refTitle">"Path MTU discovery"</span>, <span class="seriesInfo">RFC 1191</span>, <span class="seriesInfo">DOI 10.17487/RFC1191</span>, <time datetime="1990-11">November 1990</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1191">https://www.rfc-editor.org/info/rfc1191</a>&gt;</span>. </dd>
<dt id="RFC2119">[RFC2119]</dt>
<dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dt id="RFC4443">[RFC4443]</dt>
<dd>
<span class="refAuthor">Conta, A.</span><span class="refAuthor">, Deering, S.</span><span class="refAuthor">, and M. Gupta, Ed.</span>, <span class="refTitle">"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification"</span>, <span class="seriesInfo">STD 89</span>, <span class="seriesInfo">RFC 4443</span>, <span class="seriesInfo">DOI 10.17487/RFC4443</span>, <time datetime="2006-03">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4443">https://www.rfc-editor.org/info/rfc4443</a>&gt;</span>. </dd>
<dt id="RFC4821">[RFC4821]</dt>
<dd>
<span class="refAuthor">Mathis, M.</span><span class="refAuthor"> and J. Heffner</span>, <span class="refTitle">"Packetization Layer Path MTU Discovery"</span>, <span class="seriesInfo">RFC 4821</span>, <span class="seriesInfo">DOI 10.17487/RFC4821</span>, <time datetime="2007-03">March 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4821">https://www.rfc-editor.org/info/rfc4821</a>&gt;</span>. </dd>
<dt id="RFC6298">[RFC6298]</dt>
<dd>
<span class="refAuthor">Paxson, V.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, and M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dt id="RFC8174">[RFC8174]</dt>
<dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dt id="TLS13">[TLS13]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
</dl>
</section>
<section id="section-14.2">
        <h3 id="name-informative-references">
<a href="#section-14.2" class="section-number selfRef">14.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC2522">[RFC2522]</dt>
<dd>
<span class="refAuthor">Karn, P.</span><span class="refAuthor"> and W. Simpson</span>, <span class="refTitle">"Photuris: Session-Key Management Protocol"</span>, <span class="seriesInfo">RFC 2522</span>, <span class="seriesInfo">DOI 10.17487/RFC2522</span>, <time datetime="1999-03">March 1999</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2522">https://www.rfc-editor.org/info/rfc2522</a>&gt;</span>. </dd>
<dt id="RFC4303">[RFC4303]</dt>
<dd>
<span class="refAuthor">Kent, S.</span>, <span class="refTitle">"IP Encapsulating Security Payload (ESP)"</span>, <span class="seriesInfo">RFC 4303</span>, <span class="seriesInfo">DOI 10.17487/RFC4303</span>, <time datetime="2005-12">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4303">https://www.rfc-editor.org/info/rfc4303</a>&gt;</span>. </dd>
<dt id="RFC4340">[RFC4340]</dt>
<dd>
<span class="refAuthor">Kohler, E.</span><span class="refAuthor">, Handley, M.</span><span class="refAuthor">, and S. Floyd</span>, <span class="refTitle">"Datagram Congestion Control Protocol (DCCP)"</span>, <span class="seriesInfo">RFC 4340</span>, <span class="seriesInfo">DOI 10.17487/RFC4340</span>, <time datetime="2006-03">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4340">https://www.rfc-editor.org/info/rfc4340</a>&gt;</span>. </dd>
<dt id="RFC4346">[RFC4346]</dt>
<dd>
<span class="refAuthor">Dierks, T.</span><span class="refAuthor"> and E. Rescorla</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.1"</span>, <span class="seriesInfo">RFC 4346</span>, <span class="seriesInfo">DOI 10.17487/RFC4346</span>, <time datetime="2006-04">April 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4346">https://www.rfc-editor.org/info/rfc4346</a>&gt;</span>. </dd>
<dt id="RFC4347">[RFC4347]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span><span class="refAuthor"> and N. Modadugu</span>, <span class="refTitle">"Datagram Transport Layer Security"</span>, <span class="seriesInfo">RFC 4347</span>, <span class="seriesInfo">DOI 10.17487/RFC4347</span>, <time datetime="2006-04">April 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4347">https://www.rfc-editor.org/info/rfc4347</a>&gt;</span>. </dd>
<dt id="RFC4960">[RFC4960]</dt>
<dd>
<span class="refAuthor">Stewart, R., Ed.</span>, <span class="refTitle">"Stream Control Transmission Protocol"</span>, <span class="seriesInfo">RFC 4960</span>, <span class="seriesInfo">DOI 10.17487/RFC4960</span>, <time datetime="2007-09">September 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4960">https://www.rfc-editor.org/info/rfc4960</a>&gt;</span>. </dd>
<dt id="RFC5238">[RFC5238]</dt>
<dd>
<span class="refAuthor">Phelan, T.</span>, <span class="refTitle">"Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)"</span>, <span class="seriesInfo">RFC 5238</span>, <span class="seriesInfo">DOI 10.17487/RFC5238</span>, <time datetime="2008-05">May 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5238">https://www.rfc-editor.org/info/rfc5238</a>&gt;</span>. </dd>
<dt id="RFC5246">[RFC5246]</dt>
<dd>
<span class="refAuthor">Dierks, T.</span><span class="refAuthor"> and E. Rescorla</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.2"</span>, <span class="seriesInfo">RFC 5246</span>, <span class="seriesInfo">DOI 10.17487/RFC5246</span>, <time datetime="2008-08">August 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5246">https://www.rfc-editor.org/info/rfc5246</a>&gt;</span>. </dd>
<dt id="RFC6347">[RFC6347]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span><span class="refAuthor"> and N. Modadugu</span>, <span class="refTitle">"Datagram Transport Layer Security Version 1.2"</span>, <span class="seriesInfo">RFC 6347</span>, <span class="seriesInfo">DOI 10.17487/RFC6347</span>, <time datetime="2012-01">January 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6347">https://www.rfc-editor.org/info/rfc6347</a>&gt;</span>. </dd>
<dt id="RFC7296">[RFC7296]</dt>
<dd>
<span class="refAuthor">Kaufman, C.</span><span class="refAuthor">, Hoffman, P.</span><span class="refAuthor">, Nir, Y.</span><span class="refAuthor">, Eronen, P.</span><span class="refAuthor">, and T. Kivinen</span>, <span class="refTitle">"Internet Key Exchange Protocol Version 2 (IKEv2)"</span>, <span class="seriesInfo">STD 79</span>, <span class="seriesInfo">RFC 7296</span>, <span class="seriesInfo">DOI 10.17487/RFC7296</span>, <time datetime="2014-10">October 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7296">https://www.rfc-editor.org/info/rfc7296</a>&gt;</span>. </dd>
<dt id="RFC7525">[RFC7525]</dt>
<dd>
<span class="refAuthor">Sheffer, Y.</span><span class="refAuthor">, Holz, R.</span><span class="refAuthor">, and P. Saint-Andre</span>, <span class="refTitle">"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"</span>, <span class="seriesInfo">BCP 195</span>, <span class="seriesInfo">RFC 7525</span>, <span class="seriesInfo">DOI 10.17487/RFC7525</span>, <time datetime="2015-05">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7525">https://www.rfc-editor.org/info/rfc7525</a>&gt;</span>. </dd>
</dl>
</section>
</section>
<div id="protocol-data-structures-and-constant-values">
<section id="section-appendix.a">
      <h2 id="name-protocol-data-structures-an">
<a href="#section-appendix.a" class="section-number selfRef">Appendix A. </a><a href="#name-protocol-data-structures-an" class="section-name selfRef">Protocol Data Structures and Constant Values</a>
      </h2>
<p id="section-appendix.a-1">This section provides the normative protocol types and constants definitions.<a href="#section-appendix.a-1" class="pilcrow">¶</a></p>
<div id="record-layer">
<section id="section-a.1">
        <h2 id="name-record-layer">
<a href="#section-a.1" class="section-number selfRef">A.1. </a><a href="#name-record-layer" class="section-name selfRef">Record Layer</a>
        </h2>
<div class="artwork art-text alignLeft" id="section-a.1-1">
<pre>
struct {
    ContentType type;
    ProtocolVersion legacy_record_version;
    uint16 epoch = 0
    uint48 sequence_number;
    uint16 length;
    opaque fragment[DTLSPlaintext.length];
} DTLSPlaintext;

struct {
     opaque content[DTLSPlaintext.length];
     ContentType type;
     uint8 zeros[length_of_padding];
} DTLSInnerPlaintext;

struct {
    opaque unified_hdr[variable];
    opaque encrypted_record[length];
} DTLSCiphertext;

0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|0|0|1|C|S|L|E E|
+-+-+-+-+-+-+-+-+
| Connection ID |   Legend:
| (if any,      |
/  length as    /   C   - Connection ID (CID) present
|  negotiated)  |   S   - Sequence number length
+-+-+-+-+-+-+-+-+   L   - Length present
|  8 or 16 bit  |   E   - Epoch
|Sequence Number|
+-+-+-+-+-+-+-+-+
| 16 bit Length |
| (if present)  |
+-+-+-+-+-+-+-+-+
</pre><a href="#section-a.1-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="handshake-protocol">
<section id="section-a.2">
        <h2 id="name-handshake-protocol">
<a href="#section-a.2" class="section-number selfRef">A.2. </a><a href="#name-handshake-protocol" class="section-name selfRef">Handshake Protocol</a>
        </h2>
<div class="artwork art-text alignLeft" id="section-a.2-1">
<pre>
enum {
    hello_request_RESERVED(0),
    client_hello(1),
    server_hello(2),
    hello_verify_request_RESERVED(3),
    new_session_ticket(4),
    end_of_early_data(5),
    hello_retry_request_RESERVED(6),
    encrypted_extensions(8),
    certificate(11),
    server_key_exchange_RESERVED(12),
    certificate_request(13),
    server_hello_done_RESERVED(14),
    certificate_verify(15),
    client_key_exchange_RESERVED(16),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
} HandshakeType;

struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* bytes in message */
    uint16 message_seq;        /* DTLS-required field */
    uint24 fragment_offset;    /* DTLS-required field */
    uint24 fragment_length;    /* DTLS-required field */
    select (HandshakeType) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    } body;
} Handshake;

uint16 ProtocolVersion;
opaque Random[32];

uint8 CipherSuite[2];    /* Cryptographic suite selector */

struct {
    ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
    Random random;
    opaque legacy_session_id&lt;0..32&gt;;
    opaque legacy_cookie&lt;0..2^8-1&gt;;                  // DTLS
    CipherSuite cipher_suites&lt;2..2^16-2&gt;;
    opaque legacy_compression_methods&lt;1..2^8-1&gt;;
    Extension extensions&lt;8..2^16-1&gt;;
} ClientHello;
</pre><a href="#section-a.2-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="acks">
<section id="section-a.3">
        <h2 id="name-acks">
<a href="#section-a.3" class="section-number selfRef">A.3. </a><a href="#name-acks" class="section-name selfRef">ACKs</a>
        </h2>
<div class="artwork art-text alignLeft" id="section-a.3-1">
<pre>
struct {
    RecordNumber record_numbers&lt;0..2^16-1&gt;;
} ACK;
</pre><a href="#section-a.3-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="connection-id-management">
<section id="section-a.4">
        <h2 id="name-connection-id-management">
<a href="#section-a.4" class="section-number selfRef">A.4. </a><a href="#name-connection-id-management" class="section-name selfRef">Connection ID Management</a>
        </h2>
<div class="artwork art-text alignLeft" id="section-a.4-1">
<pre>
enum {
    cid_immediate(0), cid_spare(1), (255)
} ConnectionIdUsage;

opaque ConnectionId&lt;0..2^8-1&gt;;

struct {
    ConnectionIds cids&lt;0..2^16-1&gt;;
    ConnectionIdUsage usage;
} NewConnectionId;

struct {
  uint8 num_cids;
} RequestConnectionId;
</pre><a href="#section-a.4-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="history">
<section id="section-appendix.b">
      <h2 id="name-history">
<a href="#section-appendix.b" class="section-number selfRef">Appendix B. </a><a href="#name-history" class="section-name selfRef">History</a>
      </h2>
<p id="section-appendix.b-1">RFC EDITOR: PLEASE REMOVE THE THIS SECTION<a href="#section-appendix.b-1" class="pilcrow">¶</a></p>
<p id="section-appendix.b-2">IETF Drafts<a href="#section-appendix.b-2" class="pilcrow">¶</a></p>
<p id="section-appendix.b-3">draft-37:
- Fix the other place where we have ACK.<a href="#section-appendix.b-3" class="pilcrow">¶</a></p>
<p id="section-appendix.b-4">draft-36:
- Some editorial changes.
- Changed the content type to not conflict with existing allocations (*)<a href="#section-appendix.b-4" class="pilcrow">¶</a></p>
<p id="section-appendix.b-5">draft-35:
- I-D.ietf-tls-dtls-connection-id became a normative reference
- Removed duplicate reference to I-D.ietf-tls-dtls-connection-id.
- Fix figure 11 to have the right numbers andno cookie in message 1.
- Clarify when you can ACK.
- Clarify additional data computation.<a href="#section-appendix.b-5" class="pilcrow">¶</a></p>
<p id="section-appendix.b-6">draft-33:
- Key separation between TLS and DTLS. Issue #72.<a href="#section-appendix.b-6" class="pilcrow">¶</a></p>
<p id="section-appendix.b-7">draft-32:
- Editorial improvements and clarifications.<a href="#section-appendix.b-7" class="pilcrow">¶</a></p>
<p id="section-appendix.b-8">draft-31:
- Editorial improvements in text and figures.
- Added normative reference to ChaCha20 and Poly1305.<a href="#section-appendix.b-8" class="pilcrow">¶</a></p>
<p id="section-appendix.b-9">draft-30:
- Changed record format
- Added text about end of early data
- Changed format of the Connection ID Update message
- Added Appendix A "Protocol Data Structures and Constant Values"<a href="#section-appendix.b-9" class="pilcrow">¶</a></p>
<p id="section-appendix.b-10">draft-29:
- Added support for sequence number encryption
- Update to new record format
- Emphasize that compatibility mode isn't used.<a href="#section-appendix.b-10" class="pilcrow">¶</a></p>
<p id="section-appendix.b-11">draft-28:
- Version bump to align with TLS 1.3 pre-RFC version.<a href="#section-appendix.b-11" class="pilcrow">¶</a></p>
<p id="section-appendix.b-12">draft-27:
- Incorporated unified header format.
- Added support for CIDs.<a href="#section-appendix.b-12" class="pilcrow">¶</a></p>
<p id="section-appendix.b-13">draft-04 - 26:
- Submissions to align with TLS 1.3 draft versions<a href="#section-appendix.b-13" class="pilcrow">¶</a></p>
<p id="section-appendix.b-14">draft-03
- Only update keys after KeyUpdate is ACKed.<a href="#section-appendix.b-14" class="pilcrow">¶</a></p>
<p id="section-appendix.b-15">draft-02
- Shorten the protected record header and introduce an ultra-short
  version of the record header.
- Reintroduce KeyUpdate, which works properly now that we have ACK.
- Clarify the ACK rules.<a href="#section-appendix.b-15" class="pilcrow">¶</a></p>
<p id="section-appendix.b-16">draft-01
- Restructured the ACK to contain a list of records and also
  be a record rather than a handshake message.<a href="#section-appendix.b-16" class="pilcrow">¶</a></p>
<p id="section-appendix.b-17">draft-00
- First IETF Draft<a href="#section-appendix.b-17" class="pilcrow">¶</a></p>
<p id="section-appendix.b-18">Personal Drafts
draft-01
- Alignment with version -19 of the TLS 1.3 specification<a href="#section-appendix.b-18" class="pilcrow">¶</a></p>
<p id="section-appendix.b-19">draft-00<a href="#section-appendix.b-19" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.b-20.1">Initial version using TLS 1.3 as a baseline.<a href="#section-appendix.b-20.1" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-20.2">Use of epoch values instead of KeyUpdate message<a href="#section-appendix.b-20.2" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-20.3">Use of cookie extension instead of cookie field in
ClientHello and HelloVerifyRequest messages<a href="#section-appendix.b-20.3" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-20.4">Added ACK message<a href="#section-appendix.b-20.4" class="pilcrow">¶</a>
</li>
<li id="section-appendix.b-20.5">Text about sequence number handling<a href="#section-appendix.b-20.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="working-group-information">
<section id="section-appendix.c">
      <h2 id="name-working-group-information">
<a href="#section-appendix.c" class="section-number selfRef">Appendix C. </a><a href="#name-working-group-information" class="section-name selfRef">Working Group Information</a>
      </h2>
<p id="section-appendix.c-1">The discussion list for the IETF TLS working group is located at the e-mail
address <a href="mailto:tls@ietf.org">tls@ietf.org</a>. Information on the group and information on how to
subscribe to the list is at <a href="https://www1.ietf.org/mailman/listinfo/tls">https://www1.ietf.org/mailman/listinfo/tls</a><a href="#section-appendix.c-1" class="pilcrow">¶</a></p>
<p id="section-appendix.c-2">Archives of the list can be found at:
<a href="https://www.ietf.org/mail-archive/web/tls/current/index.html">https://www.ietf.org/mail-archive/web/tls/current/index.html</a><a href="#section-appendix.c-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="contributors">
<section id="section-appendix.d">
      <h2 id="name-contributors">
<a href="#section-appendix.d" class="section-number selfRef">Appendix D. </a><a href="#name-contributors" class="section-name selfRef">Contributors</a>
      </h2>
<p id="section-appendix.d-1">Many people have contributed to previous DTLS versions and they are acknowledged
in prior versions of DTLS specifications or in the referenced specifications. The
sequence number encryption concept is taken from the QUIC specification. We would
like to thank the authors of the QUIC specification for their work.<a href="#section-appendix.d-1" class="pilcrow">¶</a></p>
<p id="section-appendix.d-2">In addition, we would like to thank:<a href="#section-appendix.d-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-appendix.d-3">
<pre>
* David Benjamin
  Google
  davidben@google.com
</pre><a href="#section-appendix.d-3" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-4">
<pre>
* Thomas Fossati
  Arm Limited
  Thomas.Fossati@arm.com
</pre><a href="#section-appendix.d-4" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-5">
<pre>
* Tobias Gondrom
  Huawei
  tobias.gondrom@gondrom.org
</pre><a href="#section-appendix.d-5" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-6">
<pre>
* Ilari Liusvaara
  Independent
  ilariliusvaara@welho.com
</pre><a href="#section-appendix.d-6" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-7">
<pre>
* Martin Thomson
  Mozilla
  martin.thomson@gmail.com
</pre><a href="#section-appendix.d-7" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-8">
<pre>
* Christopher A. Wood
  Apple Inc.
  cawood@apple.com
</pre><a href="#section-appendix.d-8" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-9">
<pre>
* Yin Xinxing
  Huawei
  yinxinxing@huawei.com
</pre><a href="#section-appendix.d-9" class="pilcrow">¶</a>
</div>
<div class="artwork art-text alignLeft" id="section-appendix.d-10">
<pre>
* Hanno Becker
  Arm Limited
  Hanno.Becker@arm.com
</pre><a href="#section-appendix.d-10" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="section-appendix.e">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Eric Rescorla</span></div>
<div dir="auto" class="left"><span class="org">RTFM, Inc.</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ekr@rtfm.com" class="email">ekr@rtfm.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Hannes Tschofenig</span></div>
<div dir="auto" class="left"><span class="org">Arm Limited</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:hannes.tschofenig@arm.com" class="email">hannes.tschofenig@arm.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Nagendra Modadugu</span></div>
<div dir="auto" class="left"><span class="org">Google, Inc.</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:nagendra@cs.stanford.edu" class="email">nagendra@cs.stanford.edu</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
