<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>RTP Requirements for RTC-Web</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Expected Topologies">
<link href="#rfc.section.2" rel="Chapter" title="2 Requirements from RTP">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 RTP Multiplexing Points">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 RTP Session Multiplexing">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Why RTP Sessions Should be Demultiplexed by the Transport">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Arguments for a single transport flow">
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Summary">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Signalling for RTP sessions">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 (Lack of) Signalling for Payload Format Changes">
<link href="#rfc.section.3" rel="Chapter" title="3 RTP Session Multiplexing">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 DCCP Based Solution">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 SHIM layer">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 RTP Internal Multiplexing">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Issues with SSRC RTP Multiplexing">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Executing on this Proposal">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Conclusion">
<link href="#rfc.section.4" rel="Chapter" title="4 RTP Profile">
<link href="#rfc.section.5" rel="Chapter" title="5 RTP and RTCP Guidelines">
<link href="#rfc.section.6" rel="Chapter" title="6 RTP Optimisations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 RTP and RTCP Multiplexing">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Reduced Size RTCP">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Symmetric RTP/RTCP">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Generation of the RTCP Canonical Name (CNAME)">
<link href="#rfc.section.7" rel="Chapter" title="7 RTP Extensions">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 RTP Conferencing Extensions">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 RTCP Feedback Message: Full Intra Request">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 RTCP Feedback Message: Picture Loss Indicator">
<link href="#rfc.section.7.1.3" rel="Chapter" title="7.1.3 RTCP Feedback Message: Temporary Maximum Media Stream Bit Rate Request">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 RTP Header Extensions">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Rapid Synchronisation Extensions">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Client to Mixer Audio Level">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Mixer to Client Audio Level">
<link href="#rfc.section.8" rel="Chapter" title="8 Improving RTP Transport Robustness">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 RTP Retransmission">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Forward Error Correction (FEC)">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 Basic Redundancy">
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 Block Based">
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 Recommendations for FEC">
<link href="#rfc.section.9" rel="Chapter" title="9 RTP Rate Control and Media Adaptation">
<link href="#rfc.section.10" rel="Chapter" title="10 RTP Performance Monitoring">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="14 References">
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This memo discusses use of RTP in the context of the RTC-Web activity. It discusses important features of RTP that need to be considered by other parts of the RTC-Web framework, describes which RTP profile to use in this environment, and outlines what RTP extensions should be supported." />
  <meta name="description" content="This memo discusses use of RTP in the context of the RTC-Web activity. It discusses important features of RTP that need to be considered by other parts of the RTC-Web framework, describes which RTP profile to use in this environment, and outlines what RTP extensions should be supported." />
  <meta name="keywords" content="" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">C. S. Perkins</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. Westerlund</td>
</tr>
<tr>
<td class="left">Expires: January 12, 2012</td>
<td class="right">Ericsson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Ott</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Aalto University</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 11, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">RTP Requirements for RTC-Web<br />
  <span class="filename">draft-perkins-rtcweb-rtp-usage-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This memo discusses use of RTP in the context of the RTC-Web activity. It discusses important features of RTP that need to be considered by other parts of the RTC-Web framework, describes which RTP profile to use in this environment, and outlines what RTP extensions should be supported.</p>
<p>This document is a candidate to become a work item of the RTCWEB working group as &lt;WORKING GROUP DRAFT "MEDIA TRANSPORTS"&gt;.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 12, 2012.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>1.1.   <a href="#rfc.section.1.1">Expected Topologies</a>
</li>
<li>2.   <a href="#rfc.section.2">Requirements from RTP</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">RTP Multiplexing Points</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">RTP Session Multiplexing</a>
</li>
<li>2.2.1.   <a href="#rfc.section.2.2.1">Why RTP Sessions Should be Demultiplexed by the Transport</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Arguments for a single transport flow</a>
</li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Summary</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Signalling for RTP sessions</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">(Lack of) Signalling for Payload Format Changes</a>
</li>
<li>3.   <a href="#rfc.section.3">RTP Session Multiplexing</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">DCCP Based Solution</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">SHIM layer</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">RTP Internal Multiplexing</a>
</li>
<li>3.3.1.   <a href="#rfc.section.3.3.1">Issues with SSRC RTP Multiplexing</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Executing on this Proposal</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Conclusion</a>
</li>
<li>4.   <a href="#rfc.section.4">RTP Profile</a>
</li>
<li>5.   <a href="#rfc.section.5">RTP and RTCP Guidelines</a>
</li>
<li>6.   <a href="#rfc.section.6">RTP Optimisations</a>
</li>
<li>6.1.   <a href="#rfc.section.6.1">RTP and RTCP Multiplexing</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Reduced Size RTCP</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Symmetric RTP/RTCP</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Generation of the RTCP Canonical Name (CNAME)</a>
</li>
<li>7.   <a href="#rfc.section.7">RTP Extensions</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">RTP Conferencing Extensions</a>
</li>
<li>7.1.1.   <a href="#rfc.section.7.1.1">RTCP Feedback Message: Full Intra Request</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">RTCP Feedback Message: Picture Loss Indicator</a>
</li>
<li>7.1.3.   <a href="#rfc.section.7.1.3">RTCP Feedback Message: Temporary Maximum Media Stream Bit Rate Request</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">RTP Header Extensions</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Rapid Synchronisation Extensions</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Client to Mixer Audio Level</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Mixer to Client Audio Level</a>
</li>
<li>8.   <a href="#rfc.section.8">Improving RTP Transport Robustness</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">RTP Retransmission</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Forward Error Correction (FEC)</a>
</li>
<li>8.2.1.   <a href="#rfc.section.8.2.1">Basic Redundancy</a>
</li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">Block Based</a>
</li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">Recommendations for FEC</a>
</li>
<li>9.   <a href="#rfc.section.9">RTP Rate Control and Media Adaptation</a>
</li>
<li>10.   <a href="#rfc.section.10">RTP Performance Monitoring</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Acknowledgements</a>
</li>
<li>14.   <a href="#rfc.references">References</a>
</li>
<li>14.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This memo discusses the <a href="#RFC3550">Real-time Transport Protocol (RTP)</a> <cite title="NONE">[RFC3550]</cite> in the context of the RTC-Web activity. The work in the IETF Audio/Video Transport Working Group, and it's successors, has been about providing building blocks for real-time multimedia transport, and has not specified who should use which building blocks.  The selection of building blocks and functionalities can really only be done in the context of some application, for example RTC-Web. We have selected a set of RTP features and extensions that are suitable for a number of applications that fit the RTC-Web context. Thus, applications such as VoIP, audio and video conferencing, and on-demand multimedia streaming are considered. Applications that rely on IP multicast have not been considered likely to be applicable to RTC-Web, thus extensions related to multicast have been excluded. We believe that RTC-Web will greatly benefit in interoperability if a reasonable set of RTP functionalities and extensions are selected. This memo is intended as a starting point for discussion of those features in the RTC-Web framework.</p>
<p id="rfc.section.1.p.2">This memo is structured into different topics. For each topic, one or several recommendations from the authors are given. When it comes to the importance of extensions, or the need for implementation support, we use three requirement levels to indicate the importance of the feature to the RTC-Web specification:</p>
<p></p>

<dl>
<dt>REQUIRED:</dt>
<dd style="margin-left: 8">Functionality that is absolutely needed to make the RTC-Web solution work well, or functionality of low complexity that provides high value.</dd>
<dt>RECOMMENDED:</dt>
<dd style="margin-left: 8">Should be included as its brings significant benefit, but the solution can potentially work without it.</dd>
<dt>OPTIONAL:</dt>
<dd style="margin-left: 8">Something that is useful in some cases, but not always a benefit.</dd>
</dl>
<p id="rfc.section.1.p.4">When this memo discusses RTP, it includes the RTP Control Protocol (RTCP) unless explicitly stated otherwise. RTCP is a fundamental and integral part of the RTP protocol, and is REQUIRED to be implemented.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Expected Topologies</h1>
<p id="rfc.section.1.1.p.1">As RTC-Web is focused on peer to peer connections established from clients in web browsers the following topologies further discussed in <a href="#RFC5117">RTP Topologies</a> <cite title="NONE">[RFC5117]</cite> are primarily considered.  The topologies are depicted and briefly explained here for ease of the reader.</p>
<div id="#rfc.figure.1"></div>
<div id="#fig-p2p"></div>
<pre>
+---+         +---+
| A |&lt;-------&gt;| B |
+---+         +---+
</pre>
<p><a href="#fig-p2p">point to point topology</a> <cite title="NONE">[fig-p2p]</cite> is going to be very common in any single user to single user applications.</p>
<div id="#rfc.figure.2"></div>
<div id="#fig-multiU"></div>
<pre>
+---+      +---+
| A |&lt;----&gt;| B |
+---+      +---+
  ^         ^
   \       /
    \     /
     v   v
     +---+
     | C |
     +---+
</pre>
<p id="rfc.section.1.1.p.3">For small multiparty sessions it is practical enough to create RTP sessions by letting every participant send individual unicast RTP/UDP flows to each of the other participants. This is called multi-unicast and is unfortunately not discussed in the <a href="#RFC5117">RTP Topologies</a> <cite title="NONE">[RFC5117]</cite>. This topology has the benefit of not requiring central nodes. The downside is that it increases the used bandwidth at each sender by requiring one copy of the media streams for each participant that are part of the same session beyond the sender itself. Thus this is limited to scenarios with few end-points unless the media is very low bandwidth.</p>
<p id="rfc.section.1.1.p.4">It needs to be noted that, if this topology is to be supported by the RTC-Web framework, it needs to be possible to connect one RTP session to multiple established peer to peer flows that are individually established.</p>
<div id="#rfc.figure.3"></div>
<div id="#fig-mixer"></div>
<pre>
+---+      +------------+      +---+
| A |&lt;----&gt;|            |&lt;----&gt;| B |
+---+      |            |      +---+
           |   Mixer    |
+---+      |            |      +---+
| C |&lt;----&gt;|            |&lt;----&gt;| D |
+---+      +------------+      +---+
</pre>
<p><a href="#fig-mixer">RTP mixer</a> <cite title="NONE">[fig-mixer]</cite> is a centralised point that selects or mixes content in a conference to optimise the RTP session so that each end-point only needs connect to one entity, the mixer. The mixer also reduces the bit-rate needs as the media sent from the mixer to the end-point can be optimised in different ways. These optimisations include methods like only choosing media from the currently most active speaker or mixing together audio so that only one audio stream is required in stead of 3 in the depicted scenario. The downside of the mixer is that someone is required to provide the actual mixer.</p>
<div id="#rfc.figure.4"></div>
<div id="#fig-relay"></div>
<pre>
+---+      +------------+      +---+
| A |&lt;----&gt;|            |&lt;----&gt;| B |
+---+      |            |      +---+
           | Translator |
+---+      |            |      +---+
| C |&lt;----&gt;|            |&lt;----&gt;| D |
+---+      +------------+      +---+
</pre>
<p id="rfc.section.1.1.p.6">If one wants a less complex central node it is possible to use an <a href="#fig-relay">relay (called an Transport Translator)</a> <cite title="NONE">[fig-relay]</cite> that takes on the role of forwarding the media to the other end-points but doesn't perform any media processing. It simply forwards the media from all other to all the other. Thus one endpoint A will only need to send a media once to the relay, but it will still receive 3 RTP streams with the media if B, C and D all currently transmits.</p>
<div id="#rfc.figure.5"></div>
<div id="#fig-translator"></div>
<pre>
           +------------+
           |            |
+---+      |            |      +---+
| A |&lt;----&gt;| Translator |&lt;----&gt;| B |
+---+      |            |      +---+
           |            |
           +------------+
</pre>
<p id="rfc.section.1.1.p.7">To support legacy end-point (B) that don't fulfil the requirements of RTC-Web it is possible to insert a <a href="#fig-translator">Translator</a> <cite title="NONE">[fig-translator]</cite> that takes on the role to ensure that from A's perspective B looks like a fully compliant end-point. Thus it is the combination of the Translator and B that looks like the end-point B. The intention is that the presence of the translator is transparent to A, however it is not certain that is possible. Thus this case is include so that it can be discussed if any mechanism specified to be used for RTC-Web results in such issues and how to handle them.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Requirements from RTP</h1>
<p id="rfc.section.2.p.1">This section discusses some requirements <a href="#RFC3550">RTP and RTCP</a> <cite title="NONE">[RFC3550]</cite> place on their underlying transport protocol, the signalling channel, etc.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> RTP Multiplexing Points</h1>
<p id="rfc.section.2.1.p.1">There are three fundamental points of multiplexing within the RTP framework:</p>
<p></p>

<dl>
<dt>Use of separate RTP Sessions:</dt>
<dd style="margin-left: 8">The first, and the most important, multiplexing point is the RTP session. This multiplexing point does not have an identifier within the RTP protocol itself, but instead relies on the lower layer to separate the different RTP sessions. This is most often done by separating different RTP sessions onto different UDP ports, or by sending to different IP multicast addresses. The distinguishing feature of an RTP session is that it has a separate SSRC identifier space; a single RTP session can span multiple transport connections provided packets are gatewayed such that participants are known to each other. Different RTP sessions are used to separate different types of media within a multimedia session. For example, audio and video flows are sent on separate RTP sessions. But also completely different usages of the same media type, e.g. video of the presenter and the slide video, benefits from being separated.</dd>
<dt>Multiplexing using the SSRC within an RTP session:</dt>
<dd style="margin-left: 8">The second multiplexing point is the SSRC that separates different sources of media within a single RTP session. An example might be different participants in a multiparty teleconference, or different camera views of a presentation. In most cases, each participant within an RTP session has a single SSRC, although this may change over time if collisions are detected. However, in some more complex scenarios participants may generate multiple media streams of the same type simultaneously (e.g., if they have two cameras, and so send two video streams at once) and so will have more than one SSRC in use at once. The RTCP CNAME can be used to distinguish between a single participant using two SSRC values (where the RTCP CNAME will be the same for each SSRC), and two participants (who will have different RTCP CNAMEs).</dd>
<dt>Multiplexing using the Payload Type within an RTP session:</dt>
<dd style="margin-left: 8">If different media encodings of the same media type (audio, video, text, etc) are to be used at different times within an RTP session, for example a single participant that can switch between two different audio codecs, the payload type is used to identify how the media from that particular source is encoded. When changing media formats within an RTP Session, the SSRC of the sender remains unchanged, but the RTP Payload Type changes to indicate the change in media format.</dd>
</dl>
<p id="rfc.section.2.1.p.3">These multiplexing points area fundamental part of the design of RTP and are discussed in Section 5.2 of <a href="#RFC3550">[RFC3550]</a>. Of special importance is the need to separate different RTP sessions using a multiplexing mechanism at some lower layer than RTP, rather than trying to combine several RTP sessions implicitly into one lower layer flow. This will be further discussed in the next section.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> RTP Session Multiplexing</h1>
<p id="rfc.section.2.2.p.1">In today's network with prolific use of Network Address Translators (NAT) and Firewalls (FW), there is a desire to reduce the number of transport layer ports used by an real-time media application using RTP. This has led some to suggest multiplexing two or more RTP sessions on a single transport layer flow, using either the Payload Type or SSRC to demultiplex the sessions, in violation of the rules outlined above. It is not the first time some people look at RTP and question the need for using RTP sessions for different media types, and even more the potential need to separate different media streams of the same type into different session due to their different purposes. Section 5.2 of <a href="#RFC3550">[RFC3550]</a> outlines some of those problems; we elaborate on that discussion, and on other problems that occurs if one violates this part of the RTP design and architecture.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> Why RTP Sessions Should be Demultiplexed by the Transport</h1>
<p id="rfc.section.2.2.1.p.1">As discussed in Section 5.2 of <a href="#RFC3550">[RFC3550]</a>, multiplexing several RTP sessions (e.g., audio and video) onto a single transport layer flow introduces the following problems:</p>
<p></p>

<dl>
<dt>Payload Identification:</dt>
<dd style="margin-left: 8">If two RTP sessions of the same type are multiplexed onto a single transport layer flow using the same SSRC but relying on the Payload Type to distinguish the session, and one were to change encodings and thus acquire a different RTP payload type, there would be no general way of identifying which stream had changed encodings.  This can be avoided by partitioning the SSRC space between the two sessions, but that causes other problems as discussed below.</dd>
<dt>Timing and Sequence Number Space:</dt>
<dd style="margin-left: 8">An RTP SSRC is defined to identify a single timing and sequence number space.  Interleaving multiple payload types would require different timing spaces if the media clock rates differ and would require different sequence number spaces to tell which payload type suffered packet loss. Using multiple clock rates in a single RTP session is problematic, as discussed in <a href="#I-D.ietf-avtext-multiple-clock-rates">[I-D.ietf-avtext-multiple-clock-rates]</a>. This can be avoided by partitioning the SSRC space between the two sessions, but that causes other problems as discussed below.</dd>
<dt>RTCP Reception Reports:</dt>
<dd style="margin-left: 8">RTCP sender reports and receiver reports can only describe one timing and sequence number space per SSRC, and do not carry a payload type field.  Multiplexing sessions based on the payload type breaks RTCP.  This can be avoided by partitioning the SSRC space between the two sessions, but that causes other problems as discussed below.</dd>
<dt>RTP Mixers:</dt>
<dd style="margin-left: 8">Multiplexing RTP sessions of incompatible media type (e.g., audio and video) onto a single transport layer flow breaks the operation of RTP mixers, since they are unable to combine the flows together.</dd>
<dt>RTP Translators:</dt>
<dd style="margin-left: 8">Multiplexing RTP sessions of incompatible media type (e.g., audio and video) onto a single transport layer flow breaks the operation of RTP some types of RTP translator, for example media transcoders, which rely on the RTP requirement that all media are of the same type.</dd>
<dt>Quality of Service:</dt>
<dd style="margin-left: 8">Carrying multiple media in one RTP session precludes the use of different network paths or network resource allocations that are flow based if appropriate.  It also makes reception of a subset of the media, for example just audio if video would exceed the available bandwidth, difficult without the use of an RTP translator within the network to filter out the unwanted media which unless they are trusted devices (and included in the key-exchange). This is difficult to combine with media security functions.</dd>
<dt>Separate Endpoints:</dt>
<dd style="margin-left: 8">Multiplexing several sessions into one transport layer flow prevents use of a distributed endpoint implementation, where audio and video are rendered by different processes and/or systems.</dd>
</dl>
<p id="rfc.section.2.2.1.p.3">We do note that some of the above issues are resolved as long as there is explicit separation of the RTP sessions when transported over the same lower layer transport, for example by inserting a multiplexing layer in between the lower transport and the RTP/RTCP headers. But a number of the above issue are not resolved by this.</p>
<p id="rfc.section.2.2.1.p.4">In the RTCWEB context, i.e. web browsers running on various end-points it might appear unlikely that flow based QoS is available on the end-points that will support RTCWEB. The authors don't disagree that it is unlikely for the common case of users in their home-network or at WiFi hotspots will have flow-based QoS available.  However, if one considers enterprise users, especially using intranet applications, the availability and desire to use QoS is not implausible. There are also web users who use networks that are more resource-constrained than wired networks and WIFI networks, for example cellular network. The current access network QoS mechanism for user traffic in cellular technology from 3GPP are flow based.</p>
<p id="rfc.section.2.2.1.p.5">RTP's design hasn't been changed, although session multiplexing related topics have been discussed at various points of RTP's 20 year history. The fact is that numerous RTP mechanism and extensions have been defined assuming that one can perform session multiplexing when needed. Mechanism that has been identified as problematic if one doesn't do session separation are:</p>
<p></p>

<dl>
<dt>Scalability:</dt>
<dd style="margin-left: 8">RTP was built with media scalability in consideration. The simplest way of achieving separation between different scalability layers is placing them in different RTP sessions, and using the same SSRC and CNAME in each session to bind them together. This is most commonly done in multicast, and not particularly applicable to RTC-Web, but gatewaying of such a session would then require more alterations and likely stateful translation.</dd>
<dt>RTP Retransmission in Session Multiplexing mode:</dt>
<dd style="margin-left: 8">
<a href="#RFC4588">RTP Retransmission</a> <cite title="NONE">[RFC4588]</cite> does have a mode for session multiplexing. This would not be the main mode used in RTC-Web, but for interoperability and reduced cost in translation support for different RTP Sessions are beneficial.</dd>
<dt>Forward Error Correction:</dt>
<dd style="margin-left: 8">The <a href="#RFC2733">"An RTP Payload Format for Generic Forward Error Correction"</a> <cite title="NONE">[RFC2733]</cite> and its update <a href="#RFC5109">[RFC5109]</a> can only be used on media formats that produce RTP packets that are smaller than half the MTU if the FEC flow and media flow being protected are to be sent in the same RTP session, this is due to <a href="#RFC2198">"RTP Payload for Redundant Audio Data"</a> <cite title="NONE">[RFC2198]</cite>. This is because the SSRC value of the original flow is recovered from the FEC packets SSRC field. So for anything that desires to use these format with RTP payloads that are close to MTU needs to put the FEC data in a separate RTP session compared to the original transmissions. The usage of this type of FEC data has not been decided on in RTCWEB.</dd>
<dt>SSRC Allocation and Collision:</dt>
<dd style="margin-left: 8">The SSRC identifier is a random 32-bit number that is required to be globally unique within an RTP session, and that is reallocated to a new random value if an SSRC collision occurs between participants. If two or more RTP sessions share a transport layer flow, there is no guarantee that their choice of SSRC values will be distinct, and there is no way in standard RTP to signal which SSRC values are used by which RTP session. RTP is explicitly a group-based communication protocol, and new participants can join an RTP session at any time; these new participants may chose SSRC values that conflict with the SSRC values used in any of the multiplexed RTP sessions. This problem can be avoided by partitioning the SSRC space, and signalling how the space is to be subdivided, but this is not backwards compatible with any existing RTP system. In addition, subdividing the SSRC space makes it difficult to gateway between multiplexed RTP sessions and standard RTP sessions: the standard sessions may use parts of the SSRC space reserved in the multiplexed RTP sessions, requiring the gateway to rewrite RTCP packets, as well as the SSRC and CSRC list in RTP data packets. Rewriting RTCP is a difficult task, especially when one considers extensions such as RTCP XR.</dd>
<dt>Conflicting RTCP Report Types:</dt>
<dd style="margin-left: 8">The extension mechanisms used in RTCP depend on separation of RTP sessions for different media types. For example, the RTCP Extended Report block for VoIP is suitable for conversational audio, but clearly not useful for Video. This may cause unusable or unwanted reports to be generated for some streams, wasting capacity and confusing monitoring systems. While this is problem may be unlikely for VoIP reports, it may be an issue for the more detailed media agnostic reports which are sometimes be used for different media types. Also, this makes the implementation of RTCP more complex, since partitioning the SSRC space by media type needs not only to be one the media processing side, but also on the RTCP reporting</dd>
<dt>RTCP Reporting and Scheduling:</dt>
<dd style="margin-left: 8">The RTCP reporting interval and its packet scheduling will be affected if several RTP sessions are multiplexed onto the same transport layer flow.  The reporting interval is determined by the session bandwidth, and the reporting interval chosen for a high-rate video session will be different to the interval chosen by a low-rate VoIP session. If such sessions are multiplexed, then participants in one session will see the SSRC values of the other session. This will cause them to overestimate the number of participants in the session by a factor of two, thus doubling their RTCP reporting interval, and making their feedback less timely. In the worst case, when an RTP session with very low RTCP bandwidth is multiplexed with an RTP session with high RTCP bandwidth, this may cause repeated RTCP timer reconsideration, leading to the members of the low bandwidth session timing out.  Participants in an RTP session configured with high bandwidth (and short RTCP reporting interval) will see RTCP reports from participants in the low bandwidth session much less often than expected, potentially causing them to repeatedly timeout and re-create state for those participants. The split of RTCP bandwidth between senders and receivers (where at least 25% of the RTCP bandwidth is allocated to senders) will be disrupted if a session with few senders (e.g., a VoIP session) is multiplexed with a session with many senders (e.g., a video session). These issues can be resolved if the partition of the SSRC is signalled, but this is not backwards compatible with any existing RTP system. The partition would require re-implementing large part of the RTCP processing to take the individual sessions into account.</dd>
<dt>Sampling Group Membership:</dt>
<dd style="margin-left: 8">The mechanism defined in RFC2762 to sample the group membership, allowing participants to keep less state, assumes a single flat 32-bit SSRC space, and breaks if the SSRC space is shared between several RTP sessions.</dd>
</dl>
<p id="rfc.section.2.2.1.p.7">As can be seen, the requirement that separate RTP sessions are carried in separate transport-layer flows is fundamental to the design of RTP. Due to this design principle, implementors of various services or applications using RTP have not commonly violated this model, and have separated RTP sessions onto different transport layer flows. After 15 years of deployment of RTP in its current form, any move to change this assumption must carefully consider the backwards compatibility problems that this will cause. In particular, since widespread use of multiplexed RTP sessions in RTC-Web will almost certainly cause their use in other scenarios, the discussion regarding compatibility must be wider than just whether multiplexing works for the extremely limited subset of RTP use cases currently being considered in the RTC-Web group. Any such multiplexing extension to RTP must therefore be developed by the AVTCORE working group, since it has much broader applicability and scope than RTC-Web.</p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> Arguments for a single transport flow</h1>
<p id="rfc.section.2.2.2.p.1">The arguments the authors are aware of for why it is desirable to use a single underlying transport (e.g., UDP) flow for all media, rather than one flow for each type of media are the following:</p>
<p></p>

<dl>
<dt>End-Point Port Consumption:</dt>
<dd style="margin-left: 8">A given IP address only has 16-bits of available port space per transport protocol for any consumer of ports that exists on the machine. This is normally never an issue for a end-user machine. It can become an issue for servers that has large number of simultaneous flows.  However, in RTCWEB where we will use authenticated STUN requests a server can serve multiple end-point from the same local port, and use the whole 5-tuple (source and destination address, source and destination port, protocol) as identifier of flows.  Thus, in theory, the minimal number of media server ports needed are the maximum number of simultaneous RTP sessions a single end-point may use, when in practice implementation probably benefit from using more.</dd>
<dt>NAT State:</dt>
<dd style="margin-left: 8">If an end-point is behind a NAT each flow it generates to an external address will result in state on that NAT. That state is a limited resource, either from memory or processing stand-point in home or SOHO NATs, or for large scale NATs serving many internal end-points, the available ports run-out. We see this primarily as a problem for larger centralised NATs where end-point independent mapping do require each flow mapping to use one port for the external IP address, thus affecting the the maximum aggregation of internal users per external IP address. However, we would like to point out that a RTCWEB session with audio and video are likely using 2 or 3 UDP flows. This can be contrasted with that certain web applications that can result that 100+ TCP flows are opened to various servers. Sure they are recovered more quickly due to the explicit session teardown when no longer need, at the same time more web sites may be simultaneously communicated in various browser tabs. So the question is if the UDP mapping space is as heavily used as the TCP mapping space, and that TCP will continue to be the limiting factor for the amount of internal users a particular NAT can support.</dd>
<dt>NAT Traversal taking additional time:</dt>
<dd style="margin-left: 8">When doing NAT/FW traversal it takes additional time to open additional ports. And it takes time in a phase of communication between accepting to communicate and the media path being established which is a fairly critical. The best case scenario for how much extra time it can take following the specified ICE procedures are. 1.5*RTT + Ta*(Additional_Flows-1), where Ta is the pacing timer, which ICE specifies to be no smaller than 20 ms. That assumes a message in one direction, and then an immediate triggered check back. This as ICE first finds one candidate pair that works prior to establish multiple flows. Thus, there is no extra time until one has found a working candidate pair, from that is only the time it takes to in parallel establish the additional flows which in most case are 1 or 2 more additional flows.</dd>
<dt>NAT Traversal Failure Rate:</dt>
<dd style="margin-left: 8">In cases when one needs more than a single flow to be established through the NAT there is some risk that one succeed in establishing the first flow but fails with one or more of the additional flows. The risk that this happens are hard to quantify. However, that risk should be fairly low as one has just prior successfully established one flow from the same interfaces. Thus only rare events as NAT resource overload, or selecting particular port numbers that are filtered etc, should be reasons for failure.</dd>
</dl>
<h1 id="rfc.section.2.2.3">
<a href="#rfc.section.2.2.3">2.2.3.</a> Summary</h1>
<p id="rfc.section.2.2.3.p.1">As we have noted in the preceding sections, implicit multiplexing of multiple RTP sessions onto a single transport flow raises a large number of backwards compatibility issues. It has been argued that these issues are either not important, since the RTP features disrupted are not of interest to the current set of RTC-Web use cases, or can be solved by somehow explicitly dividing the SSRC space into different regions for different RTP sessions. We believe the first argument is short-sighted: those RTP features may not be important today, but the successful deployment of simple RTC-Web applications will generate interest to try more advanced scenarios, which may well need those features. Partitioning the SSRC space to separate RTP sessions results in new set of issues, where the biggest from our point of view is that it effectively creates a new variant of the RTP protocol, which is incompatible with standard RTP. Having two different variants of the core functionality of RTP will make it much more difficult to develop future protocol extensions, and the new variant will likely also have different set of extensions that work. In addition the two versions aren't directly interoperable, and will force anyone that want to interconnect the two version to deploy (complex) gateways. It also reduces the common user base and interest in maintaining and developing either version.</p>
<p id="rfc.section.2.2.3.p.2">On the other hand, we are sympathetic to the argument that using a single transport flow does save some time in setup processing, it will save some resources on NATs and FWs that are in between the end-points communicating, it may have somewhat higher success rate of session establishment.</p>
<p id="rfc.section.2.2.3.p.3">Thus the authors considered it REQUIRED that RTP sessions are multiplexed using an explicit mechanism outside RTP. We strongly RECOMMENDED that the mechanism used to accomplish this multiplexing is to use unique UDP flows for each RTP session, based on simplicity and interoperability. However, we can accept a WG consensus that using a single transport layer flow between peers is the default, and that also the fallback of using separate UDP flows are supported, under one constraint: that the RTP sessions are explicitly multiplexed in such a way existing mechanism or extensions to RTP are not prevented to work, and that the solution does not result in that an alternative variant of RTP is created (i.e., it must not disrupt RTCP processing, and the RTP semantics).  In this later case we RECOMMEND that some type of multiplexing layer is inserted between UDP flow and the RTP/RTCP headers to separate the RTP sessions, since removing this shim-layer and gatewaying to standard RTP sessions is simpler than trying to separate RTP sessions that are multiplexed together to gateway them to standard RTP sessions. We discuss possible multiplexing layers in <a href="#sec-mux-solutions">Section 3</a>.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#sdp" id="sdp">Signalling for RTP sessions</a>
</h1>
<p id="rfc.section.2.3.p.1">RTP is built with the assumption of an external to RTP/RTCP signalling channel to configure the RTP sessions and its functions.  The basic configuration of an RTP session consists of the following parameters:</p>
<p></p>

<dl>
<dt>RTP Profile:</dt>
<dd style="margin-left: 8">The name of the RTP profile to be used in session. The <a href="#RFC3551">RTP/AVP</a> <cite title="NONE">[RFC3551]</cite> and <a href="#RFC4585">RTP/AVPF</a> <cite title="NONE">[RFC4585]</cite> profiles can interoperate on basic level, as can their secure variants <a href="#RFC3711">RTP/SAVP</a> <cite title="NONE">[RFC3711]</cite> and <a href="#RFC5124">RTP/SAVPF</a> <cite title="NONE">[RFC5124]</cite>. The secure variants of the profiles do not directly interoperate with the non-secure variants, due to the presence of additional header fields in addition to any cryptographic transformation of the packet content.</dd>
<dt>Transport Information:</dt>
<dd style="margin-left: 8">Source and destination address(s) and ports for RTP and RTCP must be signalled for each RTP session. If <a href="#RFC5761">RTP and RTCP multiplexing</a> <cite title="NONE">[RFC5761]</cite> is to be used, such that a single port is used for RTP and RTCP flows, this must be signalled.</dd>
<dt>RTP Payload Types, media formats, and media format parameters:</dt>
<dd style="margin-left: 8">The mapping between media type names (and hence the RTP payload formats to be used) and the RTP payload type numbers must be signalled. Each media type may also have a number of media type parameters that must also be signalled to configure the codec and RTP payload format (the "a=fmtp:" line from SDP).</dd>
<dt>RTP Extensions:</dt>
<dd style="margin-left: 8">The RTP extensions one intends to use need to be agreed upon, including any parameters for each respective extension. At the very least, this will help avoiding using bandwidth for features that the other end-point will ignore.  But for certain mechanisms there is requirement for this to happen as interoperability failure otherwise happens.</dd>
<dt>RTCP Bandwidth:</dt>
<dd style="margin-left: 8">Support for exchanging RTCP Bandwidth values to the end-points will be necessary, as described in <a href="#RFC3556">"Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth"</a> <cite title="NONE">[RFC3556]</cite>, or something semantically equivalent. This also ensures that the end-points have a common view of the RTCP bandwidth, this is important as too different view of the bandwidths may lead to failure to interoperate.</dd>
</dl>
<p id="rfc.section.2.3.p.3">These parameters are often expressed in SDP messages conveyed within an offer/answer exchange. RTP does not depend on SDP or on the offer/answer model, but does require all the necessary parameters to be agreed somehow, and provided to the RTP implementation. We note that in RTCWEB context it will depend on the signalling model and API how these parameters need to be configured but they will be need to either set in the API or explicitly signalled between the peers.</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> (Lack of) Signalling for Payload Format Changes</h1>
<p id="rfc.section.2.4.p.1">As discussed in <a href="#sdp">Section 2.3</a>, the mapping between media type name, and its associated RTP payload format, and the RTP payload type number to be used for that format must be signalled as part of the session setup. An endpoint may signal support for multiple media formats, or multiple configurations of a single format, each using a different RTP payload type number. If multiple formats are signalled by an endpoint, that endpoint is REQUIRED to be prepared to receive data encoded in any of those formats at any time. RTP does not require advance signalling for changes between formats that were signalled during the session setup. This is needed for rapid rate adaptation.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#sec-mux-solutions" id="sec-mux-solutions">RTP Session Multiplexing</a>
</h1>
<p id="rfc.section.3.p.1">This section explores a few different possible solutions for how to achieve explicit multiplexing between RTP sessions and possible other UDP based flows, such as STUN and protocols carrying application data.  But before diving into the proposals we should consider a bit what requirements we can derive from the previous discussion and the intended goals.</p>
<p id="rfc.section.3.p.2">General Requirements for this multiplexing solution as we understand them are:</p>
<p></p>

<dl>
<dt>On top of a single flow:</dt>
<dd style="margin-left: 8">To get the full set of benefits of reducing the number of transport flows between two peers one should be able to multiplex all peer traffic from one application instance over a single transport flow.</dd>
<dt>On top of UDP:</dt>
<dd style="margin-left: 8">The primary transport protocol that meets real-time requirements and has reasonable NAT/FW traversal properties are UDP. So the solution are REQUIRED to work over this.</dd>
<dt>Fallback Protocol:</dt>
<dd style="margin-left: 8">If UDP fails to traverse the NAT/FW including using TURN when available a fallback option has been discussed. This would be <a href="#I-D.ietf-hybi-thewebsocketprotocol">WebSocket</a> <cite title="NONE">[I-D.ietf-hybi-thewebsocketprotocol]</cite> or over <a href="#RFC2616">HTTP(S)</a> <cite title="NONE">[RFC2616]</cite>. Over HTTP one likely need to consider the media stream as parts of a unknown length binary object and thus provide framing and multiplexing between what would be sent as individual IP packets. WebSocket provides framing, but here multiplexing is needed.</dd>
<dt>Protocols to Multiplex:</dt>
<dd style="margin-left: 8">The protocols that need to be multiplexed over this lower layer transport are: <ol>
<li>
<a href="#RFC5389">STUN</a> <cite title="NONE">[RFC5389]</cite> or something similar to enable the <a href="#RFC5245">ICE-like connectivity checks</a> <cite title="NONE">[RFC5245]</cite> to be performed.</li>
<li>RTP Sessions: One or more for each media type (audio and video) that the application desires to setup. For example we may need more than one RTP session to allow easy separation of video streams showing the person speaking and a slide video stream.  There has also been proposal for supporting simulcasting to enable non-transcoding centralised conferencing.</li>
<li>DTLS-SRTP or ZRTP are two proposals for how to do key-management for SRTP. Both are in-band key-management schemes that will be sent on the same flow as SRTP will be sent as soon as the key-management has completed. Thus they must also successfully be multiplexed. In addition there is a question if each RTP session needs its own keying context, then also the different DTLS handshakes needs to be separated.</li>
<li>Protocols for non-RTP media data. Such protocols provide a datagram service to the application that is congestion controlled and secured. The exact protocol is not yet decided.  For securing this DTLS is a likely candidate, however the order of the protocols are not clear. If it is foo over DTLS or DTLS over foo is yet to be decided.</li>
<li>Reliable Data transmission protocol. There has been some interest for a reliable data transport between the peer. It is uncertain if this is going to be defined from the start, later or not at all.</li>
</ol>
</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
</dl>

<p>Please keep these general requirements in mind when we look at some possible solutions.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> DCCP Based Solution</h1>
<p id="rfc.section.3.1.p.1">The most reasonable approach is to use DCCP as common multiplexing layer, at least for RTP and non-RTP data and use DCCP's function for congestion control in both cases. This would result in a stack picture that looks like this:</p>
<div id="#rfc.figure.6"></div>
<pre>
       +-------------+------+
       |    Media    | FOO  |
       +------+------+  |   + 
       | SRTP | DTLS | DTLS | 
+------+------+------+------+ 
| STUN |        DCCP        |
+------+--------------------+
|            UDP            |
+---------------------------+
</pre>
<p id="rfc.section.3.1.p.2">STUN and DCCP can be demultiplexed simply as long as the DCCP source port are in the range 16384-65535. The great benefit of this solution is that it can support large number of parallel explicitly multiplexed datagram flows. Another great benefit is a common place for congestion control implementation for both RTP and non-RTP data.  It also provides a negotiation mechanism for transport features, including congestion control algorithms, enabling future development of this layer.</p>
<p id="rfc.section.3.1.p.3">The above leaves out the question of a reliable transport solution.  This can be done in two major ways as far as we can see. Either build reliability extensions on top of DCCP or put a protocol in parallel with STUN and DCCP. The downside with the latter is that we again end up in a situation where we have several protocols that can occur in the outer UDP payload requiring implicit demultiplexing based on actual data, rather than on a field. As DCCP has a negotiation mechanism for both what service that uses DCCP and DCCP options and features both becomes viable methods for defining reliability extensions.</p>
<p id="rfc.section.3.1.p.4">Note: that the main reason not also putting STUN on top of DCCP is the fact that DCCP do require a handshake on transport parameters when establishing a new flow. Thus performing that negotiation prior to doing verification of connection increase both the amount of data that will be transmitted to a not yet consenting peer and the the increased delay.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> SHIM layer</h1>
<p id="rfc.section.3.2.p.1">A very straightforward design would be adding a one or two byte shim layer on top of the transport payload prior to the actual multiplexed protocols. This allows both for static assignment of shim code-points like for STUN and for dynamically agreed on usages, either explicitly through signalling or implicitly by application context.</p>
<div id="#rfc.figure.7"></div>
<pre>
       +-------------+------+
       |    Media    | DTLS |
+------+------+------+------+ 
| STUN | SRTP | DTLS | FOO  | 
+------+------+------+------+ 
|            SHIM           |
+---------------------------+ 
|            UDP            | 
+---------------------------+ </pre>
<p id="rfc.section.3.2.p.2">The Internet Draft <a href="#I-D.cbran-rtcweb-data">"RTC-Web Non-Media Data Transport Requirements"</a> <cite title="NONE">[I-D.cbran-rtcweb-data]</cite> dismisses the idea of a generic SHIM layer for a number of reasons:</p>
<p></p>

<dl>
<dt>Breaking interoperability with existing inspection gear:</dt>
<dd style="margin-left: 8">The authors of <a href="#I-D.cbran-rtcweb-data">[I-D.cbran-rtcweb-data]</a> point out the need for recognising the specific SSRC for recognising the special magic cookie. A device upgraded to perform this kind of a matching could also be modified to inspect a SHIM layer. Assuming that a SHIM layer will be introduced in the IETF anyway, it appears more beneficial to have a single upgrade to networking gear capable of supporting a set of protocols than defining application-specific extensions.</dd>
<dt>Adding complexity through another muxing layer:</dt>
<dd style="margin-left: 8">Removing an extra fixed size header is trivial. In contrast to SSRC-based demultiplexing, this could even be easily supported by the operating system. It should also be noted that both SSRC-based and SHIM layer-based demultiplexing require all media streams to terminate within the same application process and hence similar application-internal mechanisms to forward media data to the correct media engine for processing. It is thus hard to see the "adding complexity" reasoning.</dd>
<dt>Increase packet overhead further:</dt>
<dd style="margin-left: 8">A reasonably designed SHIM layer would only add a few bytes of overhead. Given that the entire discussion is motivated by audio/video calls and video packets would dominate a media stream both in number and in size, the relative overhead is minimal and the point appear moot.</dd>
<dt>Shim is a mistake which cannot be undone later:</dt>
<dd style="margin-left: 8">One can argue the same for overloading the SSRC identifier space. SHIM layers have repeatedly been discussed in the IETF because new protocols, such as DCCP and SCTP, face deployment problems in the real-world Internet as they use previously unknown IP protocol numbers. The only issue is that the IETF has not yet decided on a (common) SHIM layer. And if the shim layer is explicitly signalled and there exist fallback solution to using separate UDP flows, then it can in fact be undone.</dd>
</dl>
<p id="rfc.section.3.2.p.4">A shim layer has low overhead combined with explicitness and great flexibility on what to put on top. In addition to definition of the shim itself some signalling will needed, either explicit or implicit depending on how the signalling model and the API. The signalling needs to assign meaning to what a particular multiplexing code-point means in the particular underlying transport flow.</p>
<p id="rfc.section.3.2.p.5">Although a reliable protocol isn't included in the above example it can easily be included and be anything that can put in a UDP payload such as TCP, RMT based, home grown. Thus ensuring maximum flexibility to add additional protocols on top of the single UDP flow.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> RTP Internal Multiplexing</h1>
<p id="rfc.section.3.3.p.1">The main point with RTP internal multiplexing is to enable multiplexing RTP sessions without adding any extra layer between the RTP header and the lower transport, e.g. single UDP flow, that things are multiplex on. <a href="#I-D.rosenberg-rtcweb-rtpmux">Rosenberg </a> <cite title="NONE">[I-D.rosenberg-rtcweb-rtpmux]</cite> suggests one method for RTP Internal Multiplexing. In addition to this there are suggestion in <a href="#I-D.cbran-rtcweb-data">"RTC-Web Non-Media Data Transport Requirements"</a> <cite title="NONE">[I-D.cbran-rtcweb-data]</cite> to multiplex also the non-RTP data on the same level using implicit identification of data packets that separate them from DTLS-SRTP packets, RTP/RTCP packets and STUN packets. This results in a stack picture that looks like this:</p>
<div id="#rfc.figure.8"></div>
<pre>
       +-------------+------+
       |    Media    | DTLS |
+------+------+------+------+ 
| STUN | SRTP | DTLS | FOO  | 
+------+------+------+------+ 
|            UDP            | 
+---------------------------+ </pre>
<p id="rfc.section.3.3.p.2">Where Foo is the protocol suggested by <a href="#I-D.cbran-rtcweb-data">"RTC-Web Non-Media Data Transport Requirements"</a> <cite title="NONE">[I-D.cbran-rtcweb-data]</cite>.</p>
<p id="rfc.section.3.3.p.3">These proposals rely on the idea that a receiver can look at a number of the bytes of the UDP payload to identify the type of packet.  So assuming DTLS-SRTP key management and a datagram non-RTP data transport we have at least four protocols to separate. If one have successfully identified the protocol as (S)RTP then one looks at the SSRC field to find out media type and stream IDs.</p>
<p id="rfc.section.3.3.p.4">There are a number of issues with the current proposals which we will raise below. We also discuss what is going to be needed to drive this work.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> Issues with SSRC RTP Multiplexing</h1>
<p id="rfc.section.3.3.1.p.1">The first argument against this design is that it further proliferates this bad design of implicit packet identification that started with STUN. And instead of trying to break out of this pattern we appear to pile on more protocols that is supposed to identified despite that all these protocols actually have protocol fields that have a purpose in these overlapping bytes that we attempt to perform identification in. At some point a protocol extension in either of the protocols will result in a collision breaking the demultiplexing mechanism.</p>
<p id="rfc.section.3.3.1.p.2">Secondly, the design restricts RTCWEB to a subset of RTP functionality. By redefining the SSRC field this creates in practice an alternative RTP protocol that can't fully interoperate with RTP as currently defined. The inclusion of a magic word that allows Deep Packet Inspection and other interpreters to commonly identify the versions correctly is a clear admission to this fact, even if not state explicitly in the text. This new version is forever prevented from using any of the features that has been identified as not being compatible with this design. In addition it either forces future RTP extensions to take this severe limitation in into account or create additional extensions that are not compatible. Forking the RTP protocol into two versions is really not desirable.</p>
<p id="rfc.section.3.3.1.p.3">Thirdly, a significantly limited size stream ID field requires someone to manage and ensure that unique stream IDs are used by each end-point. This would not be an issue if the only use case ever would be communication between two end-points. However, we at this point have use cases and requirements for centralised conferencing scenarios. Even a basic star scenario requires extra complexities as the central node needs to be able to force the node that aren't at the centre to use the IDs that the central node dictates. This usage then becomes much more complex at the very moment someone attempts to interconnect two stars. This is in fact likely to happen when one needs either scalability or geographical optimisation. With geographical optimisation I mean one entity in Asia and one in Africa that performs media mixing or transport relaying to reduce the delay and traffic load. In addition to the centralised conferencing usage, it looks plausible that RTCWEB could allow for an ad-hoc conferencing mesh. Without a central point beyond the web server, only the web server could ensure the uniqueness requirements. All of the above cases is easily handled by regular RTP without any control at all. Showing that this proposal brings extra complexities.</p>
<p id="rfc.section.3.3.1.p.4">Fourth, if any legacy interoperation is considered one should be aware that it occurs that the same SSRC value is used in different RTP session in the same communication session. Commonly for providing quick association of media streams in the different sessions, sometime due to implementation choices, and sometime due to that an extension requires this, like the <a href="#RFC4588">session mode of RTP retransmission</a> <cite title="NONE">[RFC4588]</cite>.</p>
<p id="rfc.section.3.3.1.p.5">Fifth, there is a need to support more than a single session context per media type. As shown in <a href="#I-D.westerlund-avtcore-multistream-and-simulcast">"RTP Multiple Stream Sessions and Simulcast"</a> <cite title="NONE">[I-D.westerlund-avtcore-multistream-and-simulcast]</cite> there are clear benefits in using multiple RTP sessions for separating intent with different media streams. This is already occurring in video conferencing to separate main video (e.g. active speaker) from alternative video (e.g. non-active speaker, audience) and document or slide video streams. We will not deny that the web server could track the flows and their purpose through other mechanisms and signalling channels. However, it complicates any interop with legacy and forces more functionality and additional APIs into any gateway function.</p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> Executing on this Proposal</h1>
<p id="rfc.section.3.3.2.p.1">If RTCWEB WG decides that despite the issues associated with RTP internal multiplexing wants to pursue this approach the WG needs to be aware that this WG doesn't have the right to redefine RTP semantics. The IETF has an active WG chartered for maintaining and extending RTP in the AVTCORE WG, and proposal for change needs to be handled in that WG. This means that all RTCWEB WG can do for the RTP multiplexing part is to provide requirements to AVTCORE. The WG participants would then be encouraged to engage in proposing and be proponents for the work in the AVTCORE WG.</p>
<p id="rfc.section.3.3.2.p.2">Considering that not only RTCWEB is has voiced the need for a multiplexing solution and that this likely have significant impact on RTP for the future, any proposal for a solution needs to be generally applicable. For example most of the arguments dismissed in <a href="#I-D.rosenberg-rtcweb-rtpmux">"Multiplexing of Real-Time Transport Protocol (RTP) Traffic for Browser based Real-Time Communications (RTC)"</a> <cite title="NONE">[I-D.rosenberg-rtcweb-rtpmux]</cite> as not being applicable for RTCWEB will need to be reconsidered in the light of more general applications.</p>
<p id="rfc.section.3.3.2.p.3">So some requirements on this solution are from the authors of this draft:</p>
<p></p>

<ol>
<li>Possible to multiplex more than a single RTP session of the same media type.</li>
<li>Be possible to use all relevant RTP/RTCP extensions and RTP payload formats.</li>
<li>Be possible to use a particular SSRC value in more than a single RTP session simultaneously.</li>
<li>Be possible to interconnect through a gateway the RTP sessions that are multiplexed on a single transport flow back to using multiple transport flows to a legacy end-point otherwise supporting the applications RTP configuration. This should preferably done with minimal state, especially avoid per SSRC state.</li>
</ol>
<p></p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> Conclusion</h1>
<p id="rfc.section.3.4.p.1">Looking at these proposals we authors are clearly in favour of a shim layer unless DCCP is being selected anyway as datagram or media transport protocol which in case one should strongly consider having both data and media over the same protocol to enable that it is used as multiplexing layer.</p>
<p id="rfc.section.3.4.p.2">We don't see RTP internal as a realistic contender for the first phase of RTCWEB specifications. It has documented issues. The only way forward for the WG is to develop requirements for what RTCWEB needs and share these with AVTCORE. If there are proponents for driving a solution, they take the design of a generalised protocol in AVTCORE that takes into consideration the existing specification. It might find a suitable solution, it may not. When this is done we might have something stable to start deploying in two years from now or the WG has decided to drop the work as non feasible.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> RTP Profile</h1>
<p id="rfc.section.4.p.1">The <a href="#RFC5124">"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)"</a> <cite title="NONE">[RFC5124]</cite> is REQUIRED to be implemented. This builds on the basic <a href="#RFC3551">RTP/AVP profile</a> <cite title="NONE">[RFC3551]</cite>, the <a href="#RFC4585">RTP/AVPF feedback profile</a> <cite title="NONE">[RFC4585]</cite>, and the secure <a href="#RFC3711">RTP/SAVP profile</a> <cite title="NONE">[RFC3711]</cite>.</p>
<p id="rfc.section.4.p.2">The RTP/AVPF part of RTP/SAVPF is required to get the improved RTCP timer model, that allows more flexible transmission of RTCP packets in response to events, rather than strictly according to bandwidth. This also saves RTCP bandwidth and will commonly only use the full amount when there is a lot of events on which to send feedback. This functionality is needed to make use of the RTP conferencing extensions discussed in <a href="#conf-ext">Section 7.1</a>.</p>
<p id="rfc.section.4.p.3">The RTP/SAVP part of RTP/SAVPF is for support for <a href="#RFC3711">Secure RTP (SRTP)</a> <cite title="NONE">[RFC3711]</cite>. This provides media encryption, integrity protection, replay protection and a limited form of source authentication. It does not contain a specific keying mechanism, so that, and the set of security transforms, will be required to be chosen. It is possible that a security mechanism operating on a lower layer than RTP can be used instead and that should be evaluated.  However, the reasons for the design of SRTP should be taken into consideration in that discussion.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> RTP and RTCP Guidelines</h1>
<p id="rfc.section.5.p.1">RTP and RTCP are two flexible and extensible protocols that allow, on the one hand, choosing from a variety of building blocks and combining those to meet application needs, and on the other hand, create extensions where existing mechanisms are not sufficient: from new payload formats to RTP extension headers to additional RTCP control packets.</p>
<p id="rfc.section.5.p.2">Different informational documents provide guidelines to the use and particularly the extension of RTP and RTCP, including the following: <a href="#RFC2736">Guidelines for Writers of RTP Payload Format Specifications</a> <cite title="NONE">[RFC2736]</cite> and <a href="#RFC5968">Guidelines for Extending the RTP Control Protocol</a> <cite title="NONE">[RFC5968]</cite>.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> RTP Optimisations</h1>
<p id="rfc.section.6.p.1">This section discusses some optimisations that makes RTP/RTCP work better and more efficient and therefore are considered.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> RTP and RTCP Multiplexing</h1>
<p id="rfc.section.6.1.p.1">Historically, RTP and RTCP have been run on separate UDP ports.  With the increased use of Network Address/Port Translation (NAPT) this has become problematic, since maintaining multiple NAT bindings can be costly. It also complicates firewall administration, since multiple ports must be opened to allow RTP traffic. To reduce these costs and session setup times, support for multiplexing RTP data packets and RTCP control packets on a single port <a href="#RFC5761">[RFC5761]</a> is REQUIRED. Supporting this specification is generally a simplification in code, since it relaxes the tests in <a href="#RFC3550">[RFC3550]</a>.</p>
<p id="rfc.section.6.1.p.2">Note that the use of RTP and RTCP multiplexed on a single port ensures that there is occasional traffic sent on that port, even if there is no active media traffic. This may be useful to keep-alive NAT bindings.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Reduced Size RTCP</h1>
<p id="rfc.section.6.2.p.1">RTCP packets are usually sent as compound RTCP packets; and RFC 3550 demands that those compound packets always start with an SR or RR packet. However, especially when using frequent feedback messages, these general statistics are not needed in every packet and unnecessarily increase the mean RTCP packet size and thus limit the frequency at which RTCP packets can be sent within the RTCP bandwidth share.</p>
<p id="rfc.section.6.2.p.2">RFC5506 <a href="#RFC5506">"Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences"</a> <cite title="NONE">[RFC5506]</cite> specifies how to reduce the mean RTCP message and allow for more frequent feedback. Frequent feedback, in turn, is essential to make real-time application quickly aware of changing network conditions and allow them to adapt their transmission and encoding behaviour.</p>
<p id="rfc.section.6.2.p.3">Support for RFC5506 is REQUIRED.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Symmetric RTP/RTCP</h1>
<p id="rfc.section.6.3.p.1">RTP entities choose the RTP and RTCP transport addresses, i.e., IP addresses and port numbers, to receive packets on and bind their respective sockets to those. When sending RTP packets, however, they may use a different IP address or port number for RTP, RTCP, or both; e.g., when using a different socket instance for sending and for receiving. Symmetric RTP/RTCP requires that the IP address and port number for sending and receiving RTP/RTCP packets are identical.</p>
<p id="rfc.section.6.3.p.2">The reasons for using symmetric RTP is primarily to avoid issues with NAT and Firewalls by ensuring that the flow is actually bi-directional and thus kept alive and registered as flow the intended recipient actually wants. In addition it saves resources in the form of ports at the end-points, but also in the network as NAT mappings or firewall state is not unnecessary bloated. Also the number of QoS state are reduced.</p>
<p id="rfc.section.6.3.p.3">Using <a href="#RFC4961">Symmetric RTP and RTCP</a> <cite title="NONE">[RFC4961]</cite> is REQUIRED.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Generation of the RTCP Canonical Name (CNAME)</h1>
<p id="rfc.section.6.4.p.1">The RTCP Canonical Name (CNAME) provides a persistent transport-level identifier for an RTP endpoint. While the Synchronisation Source (SSRC) identifier for an RTP endpoint may change if a collision is detected, or when the RTP application is restarted, it's RTCP CNAME is meant to stay unchanged, so that RTP endpoints can be uniquely identified and associated with their RTP media streams. For proper functionality, RTCP CNAMEs should be unique among the participants of an RTP session.</p>
<p id="rfc.section.6.4.p.2">The <a href="#RFC3550">RTP specification</a> <cite title="NONE">[RFC3550]</cite> includes guidelines for choosing a unique RTP CNAME, but these are not sufficient in the presence of NAT devices. In addition, some may find long-term persistent identifiers problematic from a privacy viewpoint.  Accordingly, support for generating a short-term persistent RTCP CNAMEs following method (b) as specified in Section 4.2 of <a href="#RFC6222">"Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)"</a> <cite title="NONE">[RFC6222]</cite> is RECOMMENDED, since this addresses both concerns.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> RTP Extensions</h1>
<p id="rfc.section.7.p.1">There are a number of RTP extensions that could be very useful in the RTC-Web context. One set is related to conferencing, others are more generic in nature.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#conf-ext" id="conf-ext">RTP Conferencing Extensions</a>
</h1>
<p id="rfc.section.7.1.p.1">RTP is inherently defined for group communications, whether using IP multicast, multi-unicast, or based on a centralised server. In today's practice, however, overlay-based conferencing dominates, typically using one or a few so-called conference bridges or servers to connect endpoints in a star or flat tree topology. Quite diverse conferencing topologies can be created using the basic elements of RTP mixers and translators as defined in RFC 3550.</p>
<p id="rfc.section.7.1.p.2">An number of conferencing topologies are defined in <a href="#RFC5117">[RFC5117]</a> out of the which the following ones are the more common (and most likely in practice workable) ones:</p>
<p id="rfc.section.7.1.p.3">1) RTP Translator (Relay) with Only Unicast Paths (RFC 5117, section 3.3)</p>
<p id="rfc.section.7.1.p.4">2) RTP Mixer with Only Unicast Paths (RFC 5117, section 3.4)</p>
<p id="rfc.section.7.1.p.5">3) Point to Multipoint Using a Video Switching MCU (RFC 5117, section 3.5)</p>
<p id="rfc.section.7.1.p.6">4) Point to Multipoint Using Content Modifying MCUs (RFC 5117, section 3.6)</p>
<p id="rfc.section.7.1.p.7">We note that 3 and 4 are not well utilising the functions of RTP and in some cases even violates the RTP specifications. Thus we recommend that one focus on 1 and 2.</p>
<p id="rfc.section.7.1.p.8">RTP protocol extensions to be used with conferencing are included because they are important in the context of centralised conferencing, where one RTP Mixer (Conference Focus) receives a participants media streams and distribute them to the other participants. These messages are defined in the <a href="#RFC4585">Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)</a> <cite title="NONE">[RFC4585]</cite> and the <a href="#RFC5104">"Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)" (CCM)</a> <cite title="NONE">[RFC5104]</cite> and are fully usable by the <a href="#RFC5124">Secure variant of this profile (RTP/SAVPF)</a> <cite title="NONE">[RFC5124]</cite>.</p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> RTCP Feedback Message: Full Intra Request</h1>
<p id="rfc.section.7.1.1.p.1">The Full Intra Request is defined in Sections 3.5.1 and 4.3.1 of <a href="#RFC5104">CCM</a> <cite title="NONE">[RFC5104]</cite>. It is used to have the mixer request from a session participants a new Intra picture. This is used when switching between sources to ensure that the receivers can decode the video or other predicted media encoding with long prediction chains. It is RECOMMENDED that this feedback message is supported.</p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> RTCP Feedback Message: Picture Loss Indicator</h1>
<p id="rfc.section.7.1.2.p.1">The Picture Loss Indicator is defined in Section 6.3.1 of <a href="#RFC4585">AVPF</a> <cite title="NONE">[RFC4585]</cite>. It is used by a receiver to tell the encoder that it lost the decoder context and would like to have it repaired somehow. This is semantically different from the Full Intra Request above. It is RECOMMENDED that this feedback message is supported as a loss tolerance mechanism.</p>
<h1 id="rfc.section.7.1.3">
<a href="#rfc.section.7.1.3">7.1.3.</a> RTCP Feedback Message: Temporary Maximum Media Stream Bit Rate Request</h1>
<p id="rfc.section.7.1.3.p.1">This feedback message is defined in Section 3.5.4 and 4.2.1 in <a href="#RFC5104">CCM</a> <cite title="NONE">[RFC5104]</cite>. This message and its notification message is used by a media receiver, to inform the sending party that there is a current limitation on the amount of bandwidth available to this receiver. This can be for various reasons, and can for example be used by an RTP mixer to limit the media sender being forwarded by the mixer (without doing media transcoding) to fit the bottlenecks existing towards the other session participants. It is RECOMMENDED that this feedback message is supported.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> RTP Header Extensions</h1>
<p id="rfc.section.7.2.p.1">The <a href="#RFC3550">RTP specification</a> <cite title="NONE">[RFC3550]</cite> provides a capability to extend the RTP header with in-band data, but the format and semantics of the extensions are poorly specified. Accordingly, if header extensions are to be used, it is REQUIRED that they be formatted and signalled according to the general mechanism of RTP header extensions defined in <a href="#RFC5285">[RFC5285]</a>.</p>
<p id="rfc.section.7.2.p.2">As noted in <a href="#RFC5285">[RFC5285]</a>, the requirement from the RTP specification that header extensions are "designed so that the header extension may be ignored" <a href="#RFC3550">[RFC3550]</a> stands. To be specific, header extensions must only be used for data that can safely be ignored by the recipient without affecting interoperability, and must not be used when the presence of the extension has changed the form or nature of the rest of the packet in a way that is not compatible with the way the stream is signalled (e.g., as defined by the payload type). Valid examples might include metadata that is additional to the usual RTP information.</p>
<p id="rfc.section.7.2.p.3">The <a href="#RFC6051">RTP rapid synchronisation header extension</a> <cite title="NONE">[RFC6051]</cite> is recommended, as discussed in <a href="#rapid-sync">Section 7.3</a> we also recommend the <a href="#I-D.ietf-avtext-client-to-mixer-audio-level">client to mixer audio level</a> <cite title="NONE">[I-D.ietf-avtext-client-to-mixer-audio-level]</cite>, and consider the <a href="#I-D.ietf-avtext-mixer-to-client-audio-level">mixer to client audio level</a> <cite title="NONE">[I-D.ietf-avtext-mixer-to-client-audio-level]</cite> as optional feature.</p>
<p id="rfc.section.7.2.p.4">Currently the other header extensions are not recommended to be included at this time. But we do include a list of the available ones for information below:</p>
<p></p>

<dl>
<dt>Transmission Time offsets:</dt>
<dd style="margin-left: 8">
<a href="#RFC5450">[RFC5450]</a> defines a format for including an RTP timestamp offset of the actual transmission time of the RTP packet in relation to capture/display timestamp present in the RTP header. This can be used to improve jitter determination and buffer management.</dd>
<dt>Associating Time-Codes with RTP Streams:</dt>
<dd style="margin-left: 8">
<a href="#RFC5484">[RFC5484]</a> defines how to associate SMPTE times codes with the RTP streams.</dd>
</dl>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#rapid-sync" id="rapid-sync">Rapid Synchronisation Extensions</a>
</h1>
<p id="rfc.section.7.3.p.1">Many RTP sessions require synchronisation between audio, video, and other content. This synchronisation is performed by receivers, using information contained in RTCP SR packets, as described in the <a href="#RFC3550">RTP specification</a> <cite title="NONE">[RFC3550]</cite>. This basic mechanism can be slow, however, so it is RECOMMENDED that the rapid RTP synchronisation extensions described in <a href="#RFC6051">[RFC6051]</a> be implemented.  The rapid synchronisation extensions use the general RTP header extension mechanism <a href="#RFC5285">[RFC5285]</a>, which requires signalling, but are otherwise backwards compatible.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> Client to Mixer Audio Level</h1>
<p id="rfc.section.7.4.p.1">The <a href="#I-D.ietf-avtext-client-to-mixer-audio-level">Client to Mixer Audio Level</a> <cite title="NONE">[I-D.ietf-avtext-client-to-mixer-audio-level]</cite> is an RTP header extension used by a client to inform a mixer about the level of audio activity in the packet the header is attached to. This enables a central node to make mixing or selection decisions without decoding or detailed inspection of the payload. Thus reducing the needed complexity in some types of central RTP nodes.</p>
<p id="rfc.section.7.4.p.2">Assuming that the <a href="#I-D.ietf-avtext-client-to-mixer-audio-level">Client to Mixer Audio Level</a> <cite title="NONE">[I-D.ietf-avtext-client-to-mixer-audio-level]</cite> is published as a finished specification prior to RTCWEB's first RTP specification then it is RECOMMENDED that this extension is included.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> Mixer to Client Audio Level</h1>
<p id="rfc.section.7.5.p.1">The <a href="#I-D.ietf-avtext-mixer-to-client-audio-level">Mixer to Client Audio Level header extension</a> <cite title="NONE">[I-D.ietf-avtext-mixer-to-client-audio-level]</cite> provides the client with the audio level of the different sources mixed into a common mix from the RTP mixer. Thus enabling a user interface to indicate the relative activity level of a session participant, rather than just being included or not based on the CSRC field. This is a pure optimisations of non critical functions and thus optional functionality.</p>
<p id="rfc.section.7.5.p.2">Assuming that the <a href="#I-D.ietf-avtext-client-to-mixer-audio-level">Mixer to Client Audio Level</a> <cite title="NONE">[I-D.ietf-avtext-client-to-mixer-audio-level]</cite> is published as a finished specification prior to RTCWEB's first RTP specification then it is OPTIONAL that this extension is included.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Improving RTP Transport Robustness</h1>
<p id="rfc.section.8.p.1">There are some tools that can make RTP flows robust against Packet loss and reduce the impact on media quality. However they all add extra bits compared to a non-robust stream. These extra bits needs to be considered and the aggregate bit-rate needs to be rate controlled. Thus improving robustness might require a lower base encoding quality but has the potential to give that quality with fewer errors in it.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> RTP Retransmission</h1>
<p id="rfc.section.8.1.p.1">Support for RTP retransmission as defined by <a href="#RFC4588">"RTP Retransmission Payload Format"</a> <cite title="NONE">[RFC4588]</cite> is RECOMMENDED.</p>
<p id="rfc.section.8.1.p.2">The retransmission scheme in RTP allows flexible application of retransmissions. Only selected missing packets can be requested by the receiver. It also allows for the sender to prioritise between missing packets based on senders knowledge about their content. Compared to TCP, RTP retransmission also allows one to give up on a packet that despite retransmission(s) still has not been received within a time window.</p>
<p><a href="#I-D.cbran-rtcweb-data">"RTC-Web Media Transport Requirements"</a> <cite title="NONE">[I-D.cbran-rtcweb-data]</cite> raises two issues that they think makes RTP Retransmission unsuitable for RTCWEB. We here consider these issues and explain why they are in fact not a reason to exclude RTP retransmission from the tool box available to RTCWEB media sessions.</p>
<p></p>

<dl>
<dt>The additional latency added by [RFC4588] will exceed the latency threshold for interactive voice and video:</dt>
<dd style="margin-left: 8">RTP Retransmission will require at least one round trip time for a retransmission request and repair packet to arrive. Thus the general suitability of using retransmissions will depend on the actual network path latency between the end-points. In many of the actual usages the latency between two end-points will be low enough for RTP retransmission to be effective. Interactive communication with end-to-end delays of 400 ms still provide a fair quality. Even removing half of that in end-point delays allows functional retransmission between end-points on the continent. In addition in some applications one may accept temporary delay spikes to allow for retransmission of crucial codec information such an parameter sets, intra picture etc, rather than getting no media at all.</dd>
<dt>The undesirable increase in packet transmission at the point when congestion occurs:</dt>
<dd style="margin-left: 8">Congestion loss will impact the rate controls view of available bit-rate for transmission. When using retransmission one will have to prioritise between performing retransmissions and the quality one can achieve with ones adaptable codecs. In many use cases one prefer error free or low rates of error with reduced base quality over high degrees of error at a higher base quality.</dd>
</dl>

<p>The RTCWEB end-point implementations will need to both select when to enable RTP retransmissions based on API settings and measurements of the actual round trip time. In addition for each NACK request that a media sender receives it will need to make a prioritisation based on the importance of the requested media, the probability that the packet will reach the receiver in time for being usable, the consumption of available bit-rate and the impact of the media quality for new encodings.</p>
<p id="rfc.section.8.1.p.5">To conclude, the issues raised are implementation concerns that an implementation needs to take into consideration, they are not arguments against including a highly versatile and efficient packet loss repair mechanism.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Forward Error Correction (FEC)</h1>
<p id="rfc.section.8.2.p.1">Support of some type of FEC to combat the effects of packet loss is beneficial, but is heavily application dependent. However, some FEC mechanisms are encumbered.</p>
<p id="rfc.section.8.2.p.2">The main benefit from FEC is the relatively low additional delay needed to protect against packet losses. The transmission of any repair packets should preferably be done with a time delay that is just larger than any loss events normally encountered. That way the repair packet isn't also lost in the same event as the source data.</p>
<p id="rfc.section.8.2.p.3">The amount of repair packets needed are also highly dynamically and depends on two main factors, the amount and pattern of lost packets to be recovered and the mechanism one use to derive repair data. The later choice also effects the the additional delay required to both encode the repair packets and in the receiver to be able to recover the lost packet(s).</p>
<p></p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> Basic Redundancy</h1>
<p id="rfc.section.8.2.1.p.1">The method for providing basic redundancy is to simply retransmit an some time earlier sent packet. This is relatively simple in theory, i.e. one saves any outgoing source (original) packet in a buffer marked with a timestamp of actual transmission, some X ms later one transmit this packet again. Where X is selected to be longer than the common loss events. Thus any loss events shorter than X can be recovered assuming that one doesn't get an another loss event before all the packets lost in the first event has been received.</p>
<p id="rfc.section.8.2.1.p.2">The downside of basic redundancy is the overhead. To provide each packet with once chance of recovery, then the transmission rate increases with 100% as one needs to send each packet twice. It is possible to only redundantly send really important packets thus reducing the overhead below 100% for some other trade-off is overhead.</p>
<p id="rfc.section.8.2.1.p.3">In addition the basic retransmission of the same packet using the same SSRC in the same RTP session is not possible in RTP context.  The reason is that one would then destroy the RTCP reporting if one sends the same packet twice with the same sequence number. Thus one needs more elaborate mechanisms.</p>
<p></p>

<dl>
<dt>RTP Payload for Redundant Audio Data:</dt>
<dd style="margin-left: 8">This audio and text redundancy format defined in <a href="#RFC2198">[RFC2198]</a> allows for multiple levels of redundancy with different delay in their transmissions, as long as the source plus payload parts to be redundantly transmitted together fits into one MTU. This should work fine for most interactive use cases as both the codec bit-rates and the framing intervals normally allow for this requirement to hold.  This payload format also don't increase the packet rate, as original data and redundant data are sent together. This format does not allow perfect recovery, only recovery of information deemed necessary for audio, for example the sequence number of the original data is lost.</dd>
<dt>RTP Retransmission Format:</dt>
<dd style="margin-left: 8">The <a href="#RFC4588">RTP Retransmission Payload format</a> <cite title="NONE">[RFC4588]</cite> can be used to pro-actively send redundant packets using either SSRC or session multiplexing. By using different SSRCs or a different session for the redundant packets the RTCP receiver reports will be correct. The retransmission payload format is used to recover the packets original data thus enabling a perfect recovery.</dd>
<dt>Duplication Grouping Semantics in the Session Description Protocol:</dt>
<dd style="margin-left: 8">
<a href="#I-D.begen-mmusic-redundancy-grouping">This</a> <cite title="NONE">[I-D.begen-mmusic-redundancy-grouping]</cite> is proposal for new SDP signalling to indicate media stream duplication using different RTP sessions, or different SSRCs to separate the source and the redundant copy of the stream.</dd>
</dl>
<h1 id="rfc.section.8.2.2">
<a href="#rfc.section.8.2.2">8.2.2.</a> Block Based</h1>
<p id="rfc.section.8.2.2.p.1">Block based redundancy collects a number of source packets into a data block for processing. The processing results in some number of repair packets that is then transmitted to the other end allowing the receiver to attempt to recover some number of lost packets in the block. The benefit of block based approaches is the overhead which can be lower than 100% and still recover one or more lost source packet from the block. The optimal block codes allows for each received repair packet to repair a single loss within the block. Thus 3 repair packets that are received should allow for any set of 3 packets within the block to be recovered. In reality one commonly don't reach this level of performance for any block sizes and number of repair packets, and taking the computational complexity into account there are even more trade-offs to make among the codes.</p>
<p id="rfc.section.8.2.2.p.2">One result of the block based approach is the extra delay, as one needs to collect enough data together before being able to calculate the repair packets. In addition sufficient amount of the block needs to be received prior to recovery. Thus additional delay are added on both sending and receiving side to ensure possibility to recover any packet within the block.</p>
<p id="rfc.section.8.2.2.p.3">The redundancy overhead and the transmission pattern of source and repair data can be altered from block to block, thus allowing a adaptive process adjusting to meet the actual amount of loss seen on the network path and reported in RTCP.</p>
<p id="rfc.section.8.2.2.p.4">The alternatives that exist for block based FEC with RTP are the following:</p>
<p></p>

<dl>
<dt>RTP Payload Format for Generic Forward Error Correction:</dt>
<dd style="margin-left: 8">
<a href="#RFC5109">This RTP payload format</a> <cite title="NONE">[RFC5109]</cite> defines an XOR based recovery packet. This is the simplest processing wise that an block based FEC scheme can be. It also results in some limited properties, as each repair packet can only repair a single loss. To handle multiple close losses a scheme of hierarchical encodings are need. Thus increasing the overhead significantly.</dd>
<dt>Forward Error Correction (FEC) Framework:</dt>
<dd style="margin-left: 8">
<a href="#I-D.ietf-fecframe-framework">This framework</a> <cite title="NONE">[I-D.ietf-fecframe-framework]</cite> defines how not only RTP packets but how arbitrary packet flows can be protected. Some solutions produced or under development in FECFRAME WG are RTP specific. There exist alternatives supporting block codes such as Reed-Salomon and Raptor.</dd>
</dl>
<h1 id="rfc.section.8.2.3">
<a href="#rfc.section.8.2.3">8.2.3.</a> Recommendations for FEC</h1>
<p id="rfc.section.8.2.3.p.1">(tbd)</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> RTP Rate Control and Media Adaptation</h1>
<p id="rfc.section.9.p.1">It is REQUIRED to have an RTP Rate Control mechanism using Media adaptation to ensure that the generated RTP flows are network friendly, and maintain the user experience in the presence of network problems.</p>
<p id="rfc.section.9.p.2">The biggest issue is that there are no standardised and ready to use mechanism that can simply be included in RTC-Web. Thus there will be need for the IETF to produce such a specification. A potential starting point for defining a solution is <a href="#rtp-tfrc">"RTP with TCP Friendly Rate Control"</a> <cite title="NONE">[rtp-tfrc]</cite>.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> RTP Performance Monitoring</h1>
<p id="rfc.section.10.p.1">RTCP does contains a basic set of RTP flow monitoring points like packet loss and jitter. There exist a number of extensions that could be included in the set to be supported. However, in most cases which RTP monitoring that is needed depends on the application, which makes it difficult to select which to include when the set of applications is very large.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">This memo makes no request of IANA.</p>
<p id="rfc.section.11.p.2">Note to RFC Editor: this section may be removed on publication as an RFC.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">RTP and its various extensions each have their own security considerations. These should be taken into account when considering the security properties of the complete suite. We currently don't think this suite creates any additional security issues or properties. The use of SRTP will provide protection or mitigation against all the fundamental issues by offering confidentiality, integrity and partial source authentication. We don't discuss the key-management aspect of SRTP in this memo, that needs to be done taking the RTC-Web communication model into account.</p>
<p id="rfc.section.12.p.2">In the context of RTC-Web the actual security properties required from RTP are currently not fully understood. Until security goals and requirements are specified it will be difficult to determine what security features in addition to SRTP and a suitable key-management, if any, that are needed.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p></p>
<h1 id="rfc.references">
<a href="#rfc.references">14.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">14.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3550">[RFC3550]</b></td>
<td class="top">
<a>Schulzrinne, H.</a>, <a>Casner, S.</a>, <a>Frederick, R.</a> and <a>V. Jacobson</a>, "<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>", STD 64, RFC 3550, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2736">[RFC2736]</b></td>
<td class="top">
<a href="mailto:mjh@aciri.org" title="AT&amp;T Center for Internet Research at ICSI, International Computer Science Institute">Handley, M.</a> and <a href="mailto:C.Perkins@cs.ucl.ac.uk" title="University College London, Dept of Computer Science">C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc2736">Guidelines for Writers of RTP Payload Format Specifications</a>", BCP 36, RFC 2736, December 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3551">[RFC3551]</b></td>
<td class="top">
<a>Schulzrinne, H.</a> and <a>S. Casner</a>, "<a href="http://tools.ietf.org/html/rfc3551">RTP Profile for Audio and Video Conferences with Minimal Control</a>", STD 65, RFC 3551, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3556">[RFC3556]</b></td>
<td class="top">
<a>Casner, S.</a>, "<a href="http://tools.ietf.org/html/rfc3556">Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth</a>", RFC 3556, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3711">[RFC3711]</b></td>
<td class="top">
<a>Baugher, M.</a>, <a>McGrew, D.</a>, <a>Naslund, M.</a>, <a>Carrara, E.</a> and <a>K. Norrman</a>, "<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>", RFC 3711, March 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4585">[RFC4585]</b></td>
<td class="top">
<a>Ott, J.</a>, <a>Wenger, S.</a>, <a>Sato, N.</a>, <a>Burmeister, C.</a> and <a>J. Rey</a>, "<a href="http://tools.ietf.org/html/rfc4585">Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)</a>", RFC 4585, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4588">[RFC4588]</b></td>
<td class="top">
<a>Rey, J.</a>, <a>Leon, D.</a>, <a>Miyazaki, A.</a>, <a>Varsa, V.</a> and <a>R. Hakenberg</a>, "<a href="http://tools.ietf.org/html/rfc4588">RTP Retransmission Payload Format</a>", RFC 4588, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4961">[RFC4961]</b></td>
<td class="top">
<a>Wing, D.</a>, "<a href="http://tools.ietf.org/html/rfc4961">Symmetric RTP / RTP Control Protocol (RTCP)</a>", BCP 131, RFC 4961, July 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5104">[RFC5104]</b></td>
<td class="top">
<a>Wenger, S.</a>, <a>Chandra, U.</a>, <a>Westerlund, M.</a> and <a>B. Burman</a>, "<a href="http://tools.ietf.org/html/rfc5104">Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)</a>", RFC 5104, February 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5109">[RFC5109]</b></td>
<td class="top">
<a>Li, A.</a>, "<a href="http://tools.ietf.org/html/rfc5109">RTP Payload Format for Generic Forward Error Correction</a>", RFC 5109, December 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5124">[RFC5124]</b></td>
<td class="top">
<a>Ott, J.</a> and <a>E. Carrara</a>, "<a href="http://tools.ietf.org/html/rfc5124">Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)</a>", RFC 5124, February 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5285">[RFC5285]</b></td>
<td class="top">
<a>Singer, D.</a> and <a>H. Desineni</a>, "<a href="http://tools.ietf.org/html/rfc5285">A General Mechanism for RTP Header Extensions</a>", RFC 5285, July 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5450">[RFC5450]</b></td>
<td class="top">
<a>Singer, D.</a> and <a>H. Desineni</a>, "<a href="http://tools.ietf.org/html/rfc5450">Transmission Time Offsets in RTP Streams</a>", RFC 5450, March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5484">[RFC5484]</b></td>
<td class="top">
<a>Singer, D.</a>, "<a href="http://tools.ietf.org/html/rfc5484">Associating Time-Codes with RTP Streams</a>", RFC 5484, March 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5506">[RFC5506]</b></td>
<td class="top">
<a>Johansson, I.</a> and <a>M. Westerlund</a>, "<a href="http://tools.ietf.org/html/rfc5506">Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences</a>", RFC 5506, April 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5761">[RFC5761]</b></td>
<td class="top">
<a>Perkins, C.</a> and <a>M. Westerlund</a>, "<a href="http://tools.ietf.org/html/rfc5761">Multiplexing RTP Data and Control Packets on a Single Port</a>", RFC 5761, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6051">[RFC6051]</b></td>
<td class="top">
<a>Perkins, C.</a> and <a>T. Schierl</a>, "<a href="http://tools.ietf.org/html/rfc6051">Rapid Synchronisation of RTP Flows</a>", RFC 6051, November 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6222">[RFC6222]</b></td>
<td class="top">
<a>Begen, A.</a>, <a>Perkins, C.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc6222">Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)</a>", RFC 6222, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-avtext-multiple-clock-rates">[I-D.ietf-avtext-multiple-clock-rates]</b></td>
<td class="top">
<a>Petit-Huguenin, M</a>, "<a href="http://tools.ietf.org/html/draft-ietf-avtext-multiple-clock-rates-01">Support for multiple clock rates in an RTP session</a>", Internet-Draft draft-ietf-avtext-multiple-clock-rates-01, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-avtext-mixer-to-client-audio-level">[I-D.ietf-avtext-mixer-to-client-audio-level]</b></td>
<td class="top">
<a>Ivov, E</a>, <a>Marocco, E</a> and <a>J Lennox</a>, "<a href="http://tools.ietf.org/html/draft-ietf-avtext-mixer-to-client-audio-level-06">A Real-Time Transport Protocol (RTP) Header Extension for Mixer-to- Client Audio Level Indication</a>", Internet-Draft draft-ietf-avtext-mixer-to-client-audio-level-06, November 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-avtext-client-to-mixer-audio-level">[I-D.ietf-avtext-client-to-mixer-audio-level]</b></td>
<td class="top">
<a>Lennox, J</a>, <a>Ivov, E</a> and <a>E Marocco</a>, "<a href="http://tools.ietf.org/html/draft-ietf-avtext-client-to-mixer-audio-level-06">A Real-Time Transport Protocol (RTP) Header Extension for Client-to- Mixer Audio Level Indication</a>", Internet-Draft draft-ietf-avtext-client-to-mixer-audio-level-06, November 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">14.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="rtp-tfrc">[rtp-tfrc]</b></td>
<td class="top">
<a>Gharai, L.</a>, "<a>RTP with TCP Friendly Rate Control (draft-gharai-avtcore-rtp-tfrc-00)</a>", March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2198">[RFC2198]</b></td>
<td class="top">
<a href="mailto:c.perkins@cs.ucl.ac.uk" title="Department of Computer Science">Perkins, C.</a>, <a href="mailto:i.kouvelas@cs.ucl.ac.uk" title="Department of Computer Science">Kouvelas, I.</a>, <a href="mailto:o.hodson@cs.ucl.ac.uk" title="Department of Computer Science">Hodson, O.</a>, <a href="mailto:v.hardman@cs.ucl.ac.uk" title="Department of Computer Science">Hardman, V.</a>, <a href="mailto:mjh@isi.edu" title="USC Information Sciences Institute">Handley, M.</a>, <a href="mailto:bolot@sophia.inria.fr" title="INRIA Sophia Antipolis">Bolot, J.</a>, <a href="mailto:avega@sophia.inria.fr" title="INRIA Sophia Antipolis">Vega-Garcia, A.</a> and <a href="mailto:sfosse@sophia.inria.fr" title="INRIA Sophia Antipolis">S. Fosse-Parisis</a>, "<a href="http://tools.ietf.org/html/rfc2198">RTP Payload for Redundant Audio Data</a>", RFC 2198, September 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2733">[RFC2733]</b></td>
<td class="top">
<a href="mailto:jdrosen@dynamicsoft.com" title="dynamicsoft">Rosenberg, J.</a> and <a href="mailto:schulzrinne@cs.columbia.edu" title="Columbia University, M/S 0401">H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc2733">An RTP Payload Format for Generic Forward Error Correction</a>", RFC 2733, December 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5117">[RFC5117]</b></td>
<td class="top">
<a>Westerlund, M.</a> and <a>S. Wenger</a>, "<a href="http://tools.ietf.org/html/rfc5117">RTP Topologies</a>", RFC 5117, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="http://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5389">[RFC5389]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5968">[RFC5968]</b></td>
<td class="top">
<a>Ott, J.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc5968">Guidelines for Extending the RTP Control Protocol (RTCP)</a>", RFC 5968, September 2010.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-hybi-thewebsocketprotocol">[I-D.ietf-hybi-thewebsocketprotocol]</b></td>
<td class="top">
<a>Fette, I</a> and <a>A Melnikov</a>, "<a href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17">The WebSocket protocol</a>", Internet-Draft draft-ietf-hybi-thewebsocketprotocol-17, September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.rosenberg-rtcweb-rtpmux">[I-D.rosenberg-rtcweb-rtpmux]</b></td>
<td class="top">
<a>Rosenberg, J</a>, <a>Jennings, C</a>, <a>Peterson, J</a>, <a>Kaufman, M</a>, <a>Rescorla, E</a> and <a>T Terriberry</a>, "<a href="http://tools.ietf.org/html/draft-rosenberg-rtcweb-rtpmux-00">Multiplexing of Real-Time Transport Protocol (RTP) Traffic for Browser based Real-Time Communications (RTC)</a>", Internet-Draft draft-rosenberg-rtcweb-rtpmux-00, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.cbran-rtcweb-data">[I-D.cbran-rtcweb-data]</b></td>
<td class="top">
<a>Bran, C</a> and <a>C Jennings</a>, "<a href="http://tools.ietf.org/html/draft-cbran-rtcweb-data-00">RTC-Web Non-Media Data Transport Requirements</a>", Internet-Draft draft-cbran-rtcweb-data-00, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.westerlund-avtcore-multistream-and-simulcast">[I-D.westerlund-avtcore-multistream-and-simulcast]</b></td>
<td class="top">
<a>Westerlund, M</a> and <a>B Burman</a>, "<a href="http://tools.ietf.org/html/draft-westerlund-avtcore-multistream-and-simulcast-00">RTP Multiple Stream Sessions and Simulcast</a>", Internet-Draft draft-westerlund-avtcore-multistream-and-simulcast-00, July 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.begen-mmusic-redundancy-grouping">[I-D.begen-mmusic-redundancy-grouping]</b></td>
<td class="top">
<a>Begen, A</a>, <a>Cai, Y</a> and <a>H Ou</a>, "<a href="http://tools.ietf.org/html/draft-begen-mmusic-redundancy-grouping-02">Duplication Grouping Semantics in the Session Description Protocol</a>", Internet-Draft draft-begen-mmusic-redundancy-grouping-02, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-fecframe-framework">[I-D.ietf-fecframe-framework]</b></td>
<td class="top">
<a>Watson, M</a>, <a>Begen, A</a> and <a>V Roca</a>, "<a href="http://tools.ietf.org/html/draft-ietf-fecframe-framework-15">Forward Error Correction (FEC) Framework</a>", Internet-Draft draft-ietf-fecframe-framework-15, June 2011.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span>School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow</span>,  
		<span class="region"></span>
		<span class="code">G12 8QQ</span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Magnus Westerlund</span> 
	  <span class="n hidden">
		<span class="family-name">Westerlund</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span>Farogatan 6</span>

	  <span class="vcardline">
		<span class="locality">SE-164 80 Kista</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">Phone: +46 10 714 82 87</span>

<span class="vcardline">EMail: <a href="mailto:magnus.westerlund@ericsson.com">magnus.westerlund@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Joerg Ott</span> 
	  <span class="n hidden">
		<span class="family-name">Ott</span>
	  </span>
	</span>
	<span class="org vcardline">Aalto University</span>
	<span class="adr">
	  <span>School of Electrical Engineering</span>

	  <span class="vcardline">
		<span class="locality">Espoo</span>,  
		<span class="region"></span>
		<span class="code">02150</span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jorg.ott@aalto.fi">jorg.ott@aalto.fi</a></span>

  </address>
</div>

</body>
</html>