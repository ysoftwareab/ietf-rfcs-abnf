D_ITER = 0x00 in the iterations of the LM-OTS algorithms

D_PBLC = 0x01 when computing the hash of all of the iterates in
D_MESG = 0x02 when computing the hash of the message in the LM-
D_LEAF = 0x03 when computing the hash of the leaf of an LMS
D_INTR = 0x04 when computing the hash of an interior node of an
D_PRG = 0x05 in the recommended pseudorandom process for
tmp = x[i]
tmp = H(S || tmp || u16str(i) || u8str(j) || D_ITER)
K = H(S || y[0] || ... || y[p-1] || D_PBLC)

sum = 0
sum = sum + (2^w - 1) - coef(S, i, w)
Q = H(S || C || message || D_MESG )
a = coef(Q || Cksm(Q), i, w)
tmp = x[i]
tmp = H(S || tmp || u16str(i) || u8str(j) || D_ITER)
Q = H(S || C || message || D_MESG)
a = coef(Q || Cksm(Q), i, w)
tmp = y[i]
tmp = H(S || tmp || u16str(i) || u8str(j) || D_ITER)
Kc = H(S || z[0] || z[1] || ... || z[p-1] || D_PBLC)

S = I || q
node_num = 2^h + q
tmp = H(I || Kc || u32str(node_num) || D_LEAF)
i = 0
tmp = H(I || path[i] || tmp || u32str(node_num/2) || D_INTR)
tmp = H(I || tmp || path[i] || u32str(node_num/2) || D_INTR)
node_num = node_num/2
i = i + 1
Tc = tmp

key = pub
sig = siglist[i]
msg = publist[i]
key = msg
lmots_reserved       = 0,
lmots_sha256_n32_w1  = 1,
lmots_sha256_n32_w2  = 2,
lmots_sha256_n32_w4  = 3,
lmots_sha256_n32_w8  = 4
hbs_reserved       = 0,
lms_sha256_n32_h5  = 5,
lms_sha256_n32_h10 = 6,
lms_sha256_n32_h15 = 7,
lms_sha256_n32_h20 = 8,
lms_sha256_n32_h25 = 9,
c = Cksm(H(message)) (see Section 4.6).  To attempt a forgery, an
a = coef(h, j, w), and

b = coef(c, k, w), and

u = ceil(8*n/w)
v = ceil((floor(lg((2^w - 1) * u)) + 1) / w)
ls = (number of bits in sum) - (v * w)
p = u + v

r = i + num_lmots_keys;
temp = H(I || OTS_PUBKEY[i] || u32str(r) || D_LEAF)
j = i;
r = (r - 1)/2; j = (j-1) / 2;
left_size = pop(data stack);
temp = H(I || left_side || temp || u32str(r) || D_INTR)
public_key = pop(data stack)

