<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard%20http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Real Time Streaming Protocol 2.0 (RTSP)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol Overview">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Presentation Description">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Session Establishment">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Media Delivery Control">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Session Parameter Manipulations">
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Media Delivery">
<link href="#rfc.section.2.5.1" rel="Chapter" title="2.5.1 Media Delivery Manipulations">
<link href="#rfc.section.2.6" rel="Chapter" title="2.6 Session Maintenance and Termination">
<link href="#rfc.section.2.7" rel="Chapter" title="2.7 Extending RTSP">
<link href="#rfc.section.3" rel="Chapter" title="3 Document Conventions">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Notational Conventions">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Terminology">
<link href="#rfc.section.4" rel="Chapter" title="4 Protocol Parameters">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 RTSP Version">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 RTSP IRI and URI">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Session Identifiers">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 SMPTE Relative Timestamps">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Normal Play Time">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Absolute Time">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Feature-Tags">
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Message Body Tags">
<link href="#rfc.section.4.9" rel="Chapter" title="4.9 Media Properties">
<link href="#rfc.section.4.9.1" rel="Chapter" title="4.9.1 Random Access and Seeking">
<link href="#rfc.section.4.9.2" rel="Chapter" title="4.9.2 Retention">
<link href="#rfc.section.4.9.3" rel="Chapter" title="4.9.3 Content Modifications">
<link href="#rfc.section.4.9.4" rel="Chapter" title="4.9.4 Supported Scale Factors">
<link href="#rfc.section.4.9.5" rel="Chapter" title="4.9.5 Mapping to the Attributes">
<link href="#rfc.section.5" rel="Chapter" title="5 RTSP Message">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Message Types">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Message Headers">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Message Body">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Message Length">
<link href="#rfc.section.6" rel="Chapter" title="6 General Header Fields">
<link href="#rfc.section.7" rel="Chapter" title="7 Request">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Request Line">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Request Header Fields">
<link href="#rfc.section.8" rel="Chapter" title="8 Response">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Status-Line">
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 Status Code and Reason Phrase">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Response Headers">
<link href="#rfc.section.9" rel="Chapter" title="9 Message Body">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Message-Body Header Fields">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Message Body">
<link href="#rfc.section.10" rel="Chapter" title="10 Connections">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Reliability and Acknowledgements">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Using Connections">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Closing Connections">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Timing Out Connections and RTSP Messages">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Showing Liveness">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Use of IPv6">
<link href="#rfc.section.10.7" rel="Chapter" title="10.7 Overload Control">
<link href="#rfc.section.11" rel="Chapter" title="11 Capability Handling">
<link href="#rfc.section.12" rel="Chapter" title="12 Pipelining Support">
<link href="#rfc.section.13" rel="Chapter" title="13 Method Definitions">
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 OPTIONS">
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 DESCRIBE">
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 SETUP">
<link href="#rfc.section.13.3.1" rel="Chapter" title="13.3.1 Changing Transport Parameters">
<link href="#rfc.section.13.4" rel="Chapter" title="13.4 PLAY">
<link href="#rfc.section.13.4.1" rel="Chapter" title="13.4.1 General Usage">
<link href="#rfc.section.13.4.2" rel="Chapter" title="13.4.2 Aggregated Sessions">
<link href="#rfc.section.13.4.3" rel="Chapter" title="13.4.3 Updating current PLAY Requests">
<link href="#rfc.section.13.4.4" rel="Chapter" title="13.4.4 Playing On-Demand Media">
<link href="#rfc.section.13.4.5" rel="Chapter" title="13.4.5 Playing Dynamic On-Demand Media">
<link href="#rfc.section.13.4.6" rel="Chapter" title="13.4.6 Playing Live Media">
<link href="#rfc.section.13.4.7" rel="Chapter" title="13.4.7 Playing Live with Recording">
<link href="#rfc.section.13.4.8" rel="Chapter" title="13.4.8 Playing Live with Time-Shift">
<link href="#rfc.section.13.5" rel="Chapter" title="13.5 PLAY_NOTIFY">
<link href="#rfc.section.13.5.1" rel="Chapter" title="13.5.1 End-of-Stream">
<link href="#rfc.section.13.5.2" rel="Chapter" title="13.5.2 Media-Properties-Update">
<link href="#rfc.section.13.5.3" rel="Chapter" title="13.5.3 Scale-Change">
<link href="#rfc.section.13.6" rel="Chapter" title="13.6 PAUSE">
<link href="#rfc.section.13.7" rel="Chapter" title="13.7 TEARDOWN">
<link href="#rfc.section.13.7.1" rel="Chapter" title="13.7.1 Client to Server">
<link href="#rfc.section.13.7.2" rel="Chapter" title="13.7.2 Server to Client">
<link href="#rfc.section.13.8" rel="Chapter" title="13.8 GET_PARAMETER">
<link href="#rfc.section.13.9" rel="Chapter" title="13.9 SET_PARAMETER">
<link href="#rfc.section.13.10" rel="Chapter" title="13.10 REDIRECT">
<link href="#rfc.section.14" rel="Chapter" title="14 Embedded (Interleaved) Binary Data">
<link href="#rfc.section.15" rel="Chapter" title="15 Status Code Definitions">
<link href="#rfc.section.15.1" rel="Chapter" title="15.1 Success 1xx">
<link href="#rfc.section.15.1.1" rel="Chapter" title="15.1.1 100 Continue">
<link href="#rfc.section.15.2" rel="Chapter" title="15.2 Success 2xx">
<link href="#rfc.section.15.2.1" rel="Chapter" title="15.2.1 200 OK">
<link href="#rfc.section.15.3" rel="Chapter" title="15.3 Redirection 3xx">
<link href="#rfc.section.15.3.1" rel="Chapter" title="15.3.1 301 Moved Permanently">
<link href="#rfc.section.15.3.2" rel="Chapter" title="15.3.2 302 Found">
<link href="#rfc.section.15.3.3" rel="Chapter" title="15.3.3 303 See Other">
<link href="#rfc.section.15.3.4" rel="Chapter" title="15.3.4 304 Not Modified">
<link href="#rfc.section.15.3.5" rel="Chapter" title="15.3.5 305 Use Proxy">
<link href="#rfc.section.15.4" rel="Chapter" title="15.4 Client Error 4xx">
<link href="#rfc.section.15.4.1" rel="Chapter" title="15.4.1 400 Bad Request">
<link href="#rfc.section.15.4.2" rel="Chapter" title="15.4.2 401 Unauthorized">
<link href="#rfc.section.15.4.3" rel="Chapter" title="15.4.3 402 Payment Required">
<link href="#rfc.section.15.4.4" rel="Chapter" title="15.4.4 403 Forbidden">
<link href="#rfc.section.15.4.5" rel="Chapter" title="15.4.5 404 Not Found">
<link href="#rfc.section.15.4.6" rel="Chapter" title="15.4.6 405 Method Not Allowed">
<link href="#rfc.section.15.4.7" rel="Chapter" title="15.4.7 406 Not Acceptable">
<link href="#rfc.section.15.4.8" rel="Chapter" title="15.4.8 407 Proxy Authentication Required">
<link href="#rfc.section.15.4.9" rel="Chapter" title="15.4.9 408 Request Timeout">
<link href="#rfc.section.15.4.10" rel="Chapter" title="15.4.10 410 Gone">
<link href="#rfc.section.15.4.11" rel="Chapter" title="15.4.11 411 Length Required">
<link href="#rfc.section.15.4.12" rel="Chapter" title="15.4.12 412 Precondition Failed">
<link href="#rfc.section.15.4.13" rel="Chapter" title="15.4.13 413 Request Message Body Too Large">
<link href="#rfc.section.15.4.14" rel="Chapter" title="15.4.14 414 Request-URI Too Long">
<link href="#rfc.section.15.4.15" rel="Chapter" title="15.4.15 415 Unsupported Media Type">
<link href="#rfc.section.15.4.16" rel="Chapter" title="15.4.16 451 Parameter Not Understood">
<link href="#rfc.section.15.4.17" rel="Chapter" title="15.4.17 452 reserved">
<link href="#rfc.section.15.4.18" rel="Chapter" title="15.4.18 453 Not Enough Bandwidth">
<link href="#rfc.section.15.4.19" rel="Chapter" title="15.4.19 454 Session Not Found">
<link href="#rfc.section.15.4.20" rel="Chapter" title="15.4.20 455 Method Not Valid in This State">
<link href="#rfc.section.15.4.21" rel="Chapter" title="15.4.21 456 Header Field Not Valid for Resource">
<link href="#rfc.section.15.4.22" rel="Chapter" title="15.4.22 457 Invalid Range">
<link href="#rfc.section.15.4.23" rel="Chapter" title="15.4.23 458 Parameter Is Read-Only">
<link href="#rfc.section.15.4.24" rel="Chapter" title="15.4.24 459 Aggregate Operation Not Allowed">
<link href="#rfc.section.15.4.25" rel="Chapter" title="15.4.25 460 Only Aggregate Operation Allowed">
<link href="#rfc.section.15.4.26" rel="Chapter" title="15.4.26 461 Unsupported Transport">
<link href="#rfc.section.15.4.27" rel="Chapter" title="15.4.27 462 Destination Unreachable">
<link href="#rfc.section.15.4.28" rel="Chapter" title="15.4.28 463 Destination Prohibited">
<link href="#rfc.section.15.4.29" rel="Chapter" title="15.4.29 464 Data Transport Not Ready Yet">
<link href="#rfc.section.15.4.30" rel="Chapter" title="15.4.30 465 Notification Reason Unknown">
<link href="#rfc.section.15.4.31" rel="Chapter" title="15.4.31 466 Key Management Error">
<link href="#rfc.section.15.4.32" rel="Chapter" title="15.4.32 470 Connection Authorization Required">
<link href="#rfc.section.15.4.33" rel="Chapter" title="15.4.33 471 Connection Credentials not accepted">
<link href="#rfc.section.15.4.34" rel="Chapter" title="15.4.34 472 Failure to establish secure connection">
<link href="#rfc.section.15.5" rel="Chapter" title="15.5 Server Error 5xx">
<link href="#rfc.section.15.5.1" rel="Chapter" title="15.5.1 500 Internal Server Error">
<link href="#rfc.section.15.5.2" rel="Chapter" title="15.5.2 501 Not Implemented">
<link href="#rfc.section.15.5.3" rel="Chapter" title="15.5.3 502 Bad Gateway">
<link href="#rfc.section.15.5.4" rel="Chapter" title="15.5.4 503 Service Unavailable">
<link href="#rfc.section.15.5.5" rel="Chapter" title="15.5.5 504 Gateway Timeout">
<link href="#rfc.section.15.5.6" rel="Chapter" title="15.5.6 505 RTSP Version Not Supported">
<link href="#rfc.section.15.5.7" rel="Chapter" title="15.5.7 551 Option not supported">
<link href="#rfc.section.16" rel="Chapter" title="16 Header Field Definitions">
<link href="#rfc.section.16.1" rel="Chapter" title="16.1 Accept">
<link href="#rfc.section.16.2" rel="Chapter" title="16.2 Accept-Credentials">
<link href="#rfc.section.16.3" rel="Chapter" title="16.3 Accept-Encoding">
<link href="#rfc.section.16.4" rel="Chapter" title="16.4 Accept-Language">
<link href="#rfc.section.16.5" rel="Chapter" title="16.5 Accept-Ranges">
<link href="#rfc.section.16.6" rel="Chapter" title="16.6 Allow">
<link href="#rfc.section.16.7" rel="Chapter" title="16.7 Authorization">
<link href="#rfc.section.16.8" rel="Chapter" title="16.8 Bandwidth">
<link href="#rfc.section.16.9" rel="Chapter" title="16.9 Blocksize">
<link href="#rfc.section.16.10" rel="Chapter" title="16.10 Cache-Control">
<link href="#rfc.section.16.11" rel="Chapter" title="16.11 Connection">
<link href="#rfc.section.16.12" rel="Chapter" title="16.12 Connection-Credentials">
<link href="#rfc.section.16.13" rel="Chapter" title="16.13 Content-Base">
<link href="#rfc.section.16.14" rel="Chapter" title="16.14 Content-Encoding">
<link href="#rfc.section.16.15" rel="Chapter" title="16.15 Content-Language">
<link href="#rfc.section.16.16" rel="Chapter" title="16.16 Content-Length">
<link href="#rfc.section.16.17" rel="Chapter" title="16.17 Content-Location">
<link href="#rfc.section.16.18" rel="Chapter" title="16.18 Content-Type">
<link href="#rfc.section.16.19" rel="Chapter" title="16.19 CSeq">
<link href="#rfc.section.16.20" rel="Chapter" title="16.20 Date">
<link href="#rfc.section.16.21" rel="Chapter" title="16.21 Expires">
<link href="#rfc.section.16.22" rel="Chapter" title="16.22 From">
<link href="#rfc.section.16.23" rel="Chapter" title="16.23 If-Match">
<link href="#rfc.section.16.24" rel="Chapter" title="16.24 If-Modified-Since">
<link href="#rfc.section.16.25" rel="Chapter" title="16.25 If-None-Match">
<link href="#rfc.section.16.26" rel="Chapter" title="16.26 Last-Modified">
<link href="#rfc.section.16.27" rel="Chapter" title="16.27 Location">
<link href="#rfc.section.16.28" rel="Chapter" title="16.28 Media-Properties">
<link href="#rfc.section.16.29" rel="Chapter" title="16.29 Media-Range">
<link href="#rfc.section.16.30" rel="Chapter" title="16.30 MTag">
<link href="#rfc.section.16.31" rel="Chapter" title="16.31 Notify-Reason">
<link href="#rfc.section.16.32" rel="Chapter" title="16.32 Pipelined-Requests">
<link href="#rfc.section.16.33" rel="Chapter" title="16.33 Proxy-Authenticate">
<link href="#rfc.section.16.34" rel="Chapter" title="16.34 Proxy-Authorization">
<link href="#rfc.section.16.35" rel="Chapter" title="16.35 Proxy-Require">
<link href="#rfc.section.16.36" rel="Chapter" title="16.36 Proxy-Supported">
<link href="#rfc.section.16.37" rel="Chapter" title="16.37 Public">
<link href="#rfc.section.16.38" rel="Chapter" title="16.38 Range">
<link href="#rfc.section.16.39" rel="Chapter" title="16.39 Referrer">
<link href="#rfc.section.16.40" rel="Chapter" title="16.40 Request-Status">
<link href="#rfc.section.16.41" rel="Chapter" title="16.41 Require">
<link href="#rfc.section.16.42" rel="Chapter" title="16.42 Retry-After">
<link href="#rfc.section.16.43" rel="Chapter" title="16.43 RTP-Info">
<link href="#rfc.section.16.44" rel="Chapter" title="16.44 Scale">
<link href="#rfc.section.16.45" rel="Chapter" title="16.45 Seek-Style">
<link href="#rfc.section.16.46" rel="Chapter" title="16.46 Server">
<link href="#rfc.section.16.47" rel="Chapter" title="16.47 Session">
<link href="#rfc.section.16.48" rel="Chapter" title="16.48 Speed">
<link href="#rfc.section.16.49" rel="Chapter" title="16.49 Supported">
<link href="#rfc.section.16.50" rel="Chapter" title="16.50 Terminate-Reason">
<link href="#rfc.section.16.51" rel="Chapter" title="16.51 Timestamp">
<link href="#rfc.section.16.52" rel="Chapter" title="16.52 Transport">
<link href="#rfc.section.16.53" rel="Chapter" title="16.53 Unsupported">
<link href="#rfc.section.16.54" rel="Chapter" title="16.54 User-Agent">
<link href="#rfc.section.16.55" rel="Chapter" title="16.55 Vary">
<link href="#rfc.section.16.56" rel="Chapter" title="16.56 Via">
<link href="#rfc.section.16.57" rel="Chapter" title="16.57 WWW-Authenticate">
<link href="#rfc.section.17" rel="Chapter" title="17 Proxies">
<link href="#rfc.section.17.1" rel="Chapter" title="17.1 Proxies and Protocol Extensions">
<link href="#rfc.section.17.2" rel="Chapter" title="17.2 Multiplexing and Demultiplexing of Messages">
<link href="#rfc.section.18" rel="Chapter" title="18 Caching">
<link href="#rfc.section.18.1" rel="Chapter" title="18.1  Validation Model">
<link href="#rfc.section.18.1.1" rel="Chapter" title="18.1.1 Last-Modified Dates ">
<link href="#rfc.section.18.1.2" rel="Chapter" title="18.1.2 Message Body Tag Cache Validators">
<link href="#rfc.section.18.1.3" rel="Chapter" title="18.1.3 Weak and Strong Validators">
<link href="#rfc.section.18.1.4" rel="Chapter" title="18.1.4 Rules for When to Use Message Body Tags and Last-Modified Dates">
<link href="#rfc.section.18.1.5" rel="Chapter" title="18.1.5 Non-validating Conditionals">
<link href="#rfc.section.18.2" rel="Chapter" title="18.2 Invalidation After Updates or Deletions">
<link href="#rfc.section.19" rel="Chapter" title="19 Security Framework">
<link href="#rfc.section.19.1" rel="Chapter" title="19.1 RTSP and HTTP Authentication">
<link href="#rfc.section.19.2" rel="Chapter" title="19.2 RTSP over TLS">
<link href="#rfc.section.19.3" rel="Chapter" title="19.3 Security and Proxies">
<link href="#rfc.section.19.3.1" rel="Chapter" title="19.3.1 Accept-Credentials">
<link href="#rfc.section.19.3.2" rel="Chapter" title="19.3.2 User approved TLS procedure">
<link href="#rfc.section.20" rel="Chapter" title="20 Syntax">
<link href="#rfc.section.20.1" rel="Chapter" title="20.1 Base Syntax">
<link href="#rfc.section.20.2" rel="Chapter" title="20.2 RTSP Protocol Definition">
<link href="#rfc.section.20.2.1" rel="Chapter" title="20.2.1 Generic Protocol elements">
<link href="#rfc.section.20.2.2" rel="Chapter" title="20.2.2 Message Syntax">
<link href="#rfc.section.20.2.3" rel="Chapter" title="20.2.3 Header Syntax">
<link href="#rfc.section.20.3" rel="Chapter" title="20.3 SDP extension Syntax">
<link href="#rfc.section.21" rel="Chapter" title="21 Security Considerations">
<link href="#rfc.section.21.1" rel="Chapter" title="21.1 Remote denial of Service Attack">
<link href="#rfc.section.22" rel="Chapter" title="22 IANA Considerations">
<link href="#rfc.section.22.1" rel="Chapter" title="22.1 Feature-tags">
<link href="#rfc.section.22.1.1" rel="Chapter" title="22.1.1 Description">
<link href="#rfc.section.22.1.2" rel="Chapter" title="22.1.2 Registering New Feature-tags with IANA">
<link href="#rfc.section.22.1.3" rel="Chapter" title="22.1.3 Registered entries">
<link href="#rfc.section.22.2" rel="Chapter" title="22.2 RTSP Methods">
<link href="#rfc.section.22.2.1" rel="Chapter" title="22.2.1 Description">
<link href="#rfc.section.22.2.2" rel="Chapter" title="22.2.2 Registering New Methods with IANA">
<link href="#rfc.section.22.2.3" rel="Chapter" title="22.2.3 Registered Entries">
<link href="#rfc.section.22.3" rel="Chapter" title="22.3 RTSP Status Codes">
<link href="#rfc.section.22.3.1" rel="Chapter" title="22.3.1 Description">
<link href="#rfc.section.22.3.2" rel="Chapter" title="22.3.2 Registering New Status Codes with IANA">
<link href="#rfc.section.22.3.3" rel="Chapter" title="22.3.3 Registered Entries">
<link href="#rfc.section.22.4" rel="Chapter" title="22.4 RTSP Headers">
<link href="#rfc.section.22.4.1" rel="Chapter" title="22.4.1 Description">
<link href="#rfc.section.22.4.2" rel="Chapter" title="22.4.2 Registering New Headers with IANA">
<link href="#rfc.section.22.4.3" rel="Chapter" title="22.4.3 Registered entries">
<link href="#rfc.section.22.5" rel="Chapter" title="22.5 Accept-Credentials">
<link href="#rfc.section.22.5.1" rel="Chapter" title="22.5.1 Accept-Credentials policies">
<link href="#rfc.section.22.5.2" rel="Chapter" title="22.5.2 Accept-Credentials hash algorithms">
<link href="#rfc.section.22.6" rel="Chapter" title="22.6 Cache-Control Cache Directive Extensions">
<link href="#rfc.section.22.7" rel="Chapter" title="22.7 Media Properties">
<link href="#rfc.section.22.7.1" rel="Chapter" title="22.7.1 Description">
<link href="#rfc.section.22.7.2" rel="Chapter" title="22.7.2 Registration Rules">
<link href="#rfc.section.22.7.3" rel="Chapter" title="22.7.3 Registered Values">
<link href="#rfc.section.22.8" rel="Chapter" title="22.8 Notify-Reason header">
<link href="#rfc.section.22.8.1" rel="Chapter" title="22.8.1 Description">
<link href="#rfc.section.22.8.2" rel="Chapter" title="22.8.2 Registration Rules">
<link href="#rfc.section.22.8.3" rel="Chapter" title="22.8.3 Registered Values">
<link href="#rfc.section.22.9" rel="Chapter" title="22.9 Range header formats">
<link href="#rfc.section.22.9.1" rel="Chapter" title="22.9.1 Description">
<link href="#rfc.section.22.9.2" rel="Chapter" title="22.9.2 Registration Rules">
<link href="#rfc.section.22.9.3" rel="Chapter" title="22.9.3 Registered Values">
<link href="#rfc.section.22.10" rel="Chapter" title="22.10 Terminate-Reason Header">
<link href="#rfc.section.22.10.1" rel="Chapter" title="22.10.1 Redirect Reasons">
<link href="#rfc.section.22.10.2" rel="Chapter" title="22.10.2 Terminate-Reason Header Parameters">
<link href="#rfc.section.22.11" rel="Chapter" title="22.11 RTP-Info header parameters">
<link href="#rfc.section.22.11.1" rel="Chapter" title="22.11.1 Description">
<link href="#rfc.section.22.11.2" rel="Chapter" title="22.11.2 Registration Rules">
<link href="#rfc.section.22.11.3" rel="Chapter" title="22.11.3 Registered Values">
<link href="#rfc.section.22.12" rel="Chapter" title="22.12 Seek-Style Policies">
<link href="#rfc.section.22.12.1" rel="Chapter" title="22.12.1 Description">
<link href="#rfc.section.22.12.2" rel="Chapter" title="22.12.2 Registration Rules">
<link href="#rfc.section.22.12.3" rel="Chapter" title="22.12.3 Registered Values">
<link href="#rfc.section.22.13" rel="Chapter" title="22.13 Transport Header Registries">
<link href="#rfc.section.22.13.1" rel="Chapter" title="22.13.1 Transport Protocol Specification">
<link href="#rfc.section.22.13.2" rel="Chapter" title="22.13.2 Transport modes">
<link href="#rfc.section.22.13.3" rel="Chapter" title="22.13.3 Transport Parameters">
<link href="#rfc.section.22.14" rel="Chapter" title="22.14 URI Schemes">
<link href="#rfc.section.22.14.1" rel="Chapter" title="22.14.1 The rtsp URI Scheme">
<link href="#rfc.section.22.14.2" rel="Chapter" title="22.14.2 The rtsps URI Scheme">
<link href="#rfc.section.22.14.3" rel="Chapter" title="22.14.3 The rtspu URI Scheme">
<link href="#rfc.section.22.15" rel="Chapter" title="22.15 SDP attributes">
<link href="#rfc.section.22.16" rel="Chapter" title="22.16 Media Type Registration for text/parameters">
<link href="#rfc.references" rel="Chapter" title="23 References">
<link href="#rfc.references.1" rel="Chapter" title="23.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="23.2 Informative References">
<link href="#rfc.appendix.Appendix%20A" rel="Chapter" title="Appendix A Examples">
<link href="#rfc.appendix.Appendix%20A.1" rel="Chapter" title="Appendix A.1 Media on Demand (Unicast)">
<link href="#rfc.appendix.Appendix%20A.2" rel="Chapter" title="Appendix A.2 Media on Demand using Pipelining">
<link href="#rfc.appendix.Appendix%20A.3" rel="Chapter" title="Appendix A.3 Media on Demand (Unicast)">
<link href="#rfc.appendix.Appendix%20A.4" rel="Chapter" title="Appendix A.4 Single Stream Container Files">
<link href="#rfc.appendix.Appendix%20A.5" rel="Chapter" title="Appendix A.5 Live Media Presentation Using Multicast">
<link href="#rfc.appendix.Appendix%20A.6" rel="Chapter" title="Appendix A.6 Capability Negotiation">
<link href="#rfc.appendix.Appendix%20B" rel="Chapter" title="Appendix B RTSP Protocol State Machine">
<link href="#rfc.appendix.Appendix%20B.1" rel="Chapter" title="Appendix B.1 States">
<link href="#rfc.appendix.Appendix%20B.2" rel="Chapter" title="Appendix B.2 State variables">
<link href="#rfc.appendix.Appendix%20B.3" rel="Chapter" title="Appendix B.3 Abbreviations">
<link href="#rfc.appendix.Appendix%20B.4" rel="Chapter" title="Appendix B.4 State Tables">
<link href="#rfc.appendix.Appendix%20C" rel="Chapter" title="Appendix C Media Transport Alternatives">
<link href="#rfc.appendix.Appendix%20C.1" rel="Chapter" title="Appendix C.1 RTP">
<link href="#rfc.appendix.Appendix%20C.1.1" rel="Chapter" title="Appendix C.1.1 AVP">
<link href="#rfc.appendix.Appendix%20C.1.2" rel="Chapter" title="Appendix C.1.2 AVP/UDP">
<link href="#rfc.appendix.Appendix%20C.1.3" rel="Chapter" title="Appendix C.1.3 AVPF/UDP">
<link href="#rfc.appendix.Appendix%20C.1.4" rel="Chapter" title="Appendix C.1.4 SAVP/UDP">
<link href="#rfc.appendix.Appendix%20C.1.4.1" rel="Chapter" title="Appendix C.1.4.1 MIKEY Key Establishment">
<link href="#rfc.appendix.Appendix%20C.1.5" rel="Chapter" title="Appendix C.1.5 SAVPF/UDP">
<link href="#rfc.appendix.Appendix%20C.1.6" rel="Chapter" title="Appendix C.1.6 RTCP usage with RTSP">
<link href="#rfc.appendix.Appendix%20C.1.6.1" rel="Chapter" title="Appendix C.1.6.1 Media synchronization">
<link href="#rfc.appendix.Appendix%20C.1.6.2" rel="Chapter" title="Appendix C.1.6.2 RTSP Session keep-alive">
<link href="#rfc.appendix.Appendix%20C.1.6.3" rel="Chapter" title="Appendix C.1.6.3 Bit-rate adaption">
<link href="#rfc.appendix.Appendix%20C.1.6.4" rel="Chapter" title="Appendix C.1.6.4 RTP and RTCP Multiplexing">
<link href="#rfc.appendix.Appendix%20C.2" rel="Chapter" title="Appendix C.2 RTP over TCP">
<link href="#rfc.appendix.Appendix%20C.2.1" rel="Chapter" title="Appendix C.2.1 Interleaved RTP over TCP">
<link href="#rfc.appendix.Appendix%20C.2.2" rel="Chapter" title="Appendix C.2.2 RTP over independent TCP">
<link href="#rfc.appendix.Appendix%20C.3" rel="Chapter" title="Appendix C.3 Handling Media Clock Time Jumps in the RTP Media Layer">
<link href="#rfc.appendix.Appendix%20C.4" rel="Chapter" title="Appendix C.4 Handling RTP Timestamps after PAUSE">
<link href="#rfc.appendix.Appendix%20C.5" rel="Chapter" title="Appendix C.5 RTSP / RTP Integration">
<link href="#rfc.appendix.Appendix%20C.6" rel="Chapter" title="Appendix C.6 Scaling with RTP">
<link href="#rfc.appendix.Appendix%20C.7" rel="Chapter" title="Appendix C.7 Maintaining NPT synchronization with RTP timestamps">
<link href="#rfc.appendix.Appendix%20C.8" rel="Chapter" title="Appendix C.8 Continuous Audio">
<link href="#rfc.appendix.Appendix%20C.9" rel="Chapter" title="Appendix C.9 Multiple Sources in an RTP Session">
<link href="#rfc.appendix.Appendix%20C.10" rel="Chapter" title="Appendix C.10 Usage of SSRCs and the RTCP BYE Message During an RTSP Session">
<link href="#rfc.appendix.Appendix%20C.11" rel="Chapter" title="Appendix C.11 Future Additions">
<link href="#rfc.appendix.Appendix%20D" rel="Chapter" title="Appendix D Use of SDP for RTSP Session Descriptions">
<link href="#rfc.appendix.Appendix%20D.1" rel="Chapter" title="Appendix D.1 Definitions">
<link href="#rfc.appendix.Appendix%20D.1.1" rel="Chapter" title="Appendix D.1.1 Control URI">
<link href="#rfc.appendix.Appendix%20D.1.2" rel="Chapter" title="Appendix D.1.2 Media Streams">
<link href="#rfc.appendix.Appendix%20D.1.3" rel="Chapter" title="Appendix D.1.3 Payload Type(s)">
<link href="#rfc.appendix.Appendix%20D.1.4" rel="Chapter" title="Appendix D.1.4 Format-Specific Parameters">
<link href="#rfc.appendix.Appendix%20D.1.5" rel="Chapter" title="Appendix D.1.5 Directionality of media stream">
<link href="#rfc.appendix.Appendix%20D.1.6" rel="Chapter" title="Appendix D.1.6 Range of Presentation">
<link href="#rfc.appendix.Appendix%20D.1.7" rel="Chapter" title="Appendix D.1.7 Time of Availability">
<link href="#rfc.appendix.Appendix%20D.1.8" rel="Chapter" title="Appendix D.1.8 Connection Information">
<link href="#rfc.appendix.Appendix%20D.1.9" rel="Chapter" title="Appendix D.1.9 Message Body Tag">
<link href="#rfc.appendix.Appendix%20D.2" rel="Chapter" title="Appendix D.2 Aggregate Control Not Available">
<link href="#rfc.appendix.Appendix%20D.3" rel="Chapter" title="Appendix D.3 Aggregate Control Available">
<link href="#rfc.appendix.Appendix%20D.4" rel="Chapter" title="Appendix D.4 Grouping of Media Lines in SDP">
<link href="#rfc.appendix.Appendix%20D.5" rel="Chapter" title="Appendix D.5 RTSP external SDP delivery">
<link href="#rfc.appendix.Appendix%20E" rel="Chapter" title="Appendix E RTSP Use Cases">
<link href="#rfc.appendix.Appendix%20E.1" rel="Chapter" title="Appendix E.1 On-demand Playback of Stored Content">
<link href="#rfc.appendix.Appendix%20E.2" rel="Chapter" title="Appendix E.2 Unicast Distribution of Live Content">
<link href="#rfc.appendix.Appendix%20E.3" rel="Chapter" title="Appendix E.3 On-demand Playback using Multicast">
<link href="#rfc.appendix.Appendix%20E.4" rel="Chapter" title="Appendix E.4 Inviting an RTSP server into a conference">
<link href="#rfc.appendix.Appendix%20E.5" rel="Chapter" title="Appendix E.5 Live Content using Multicast">
<link href="#rfc.appendix.Appendix%20F" rel="Chapter" title="Appendix F Text format for Parameters">
<link href="#rfc.appendix.Appendix%20G" rel="Chapter" title="Appendix G Requirements for Unreliable Transport of RTSP">
<link href="#rfc.appendix.Appendix%20H" rel="Chapter" title="Appendix H Backwards Compatibility Considerations">
<link href="#rfc.appendix.Appendix%20H.1" rel="Chapter" title="Appendix H.1 Play Request in Play State">
<link href="#rfc.appendix.Appendix%20H.2" rel="Chapter" title="Appendix H.2 Using Persistent Connections">
<link href="#rfc.appendix.Appendix%20I" rel="Chapter" title="Appendix I Open Issues">
<link href="#rfc.appendix.Appendix%20J" rel="Chapter" title="Appendix J Changes">
<link href="#rfc.appendix.Appendix%20J.1" rel="Chapter" title="Appendix J.1 Brief Overview">
<link href="#rfc.appendix.Appendix%20J.2" rel="Chapter" title="Appendix J.2 Detailed List of Changes">
<link href="#rfc.appendix.Appendix%20K" rel="Chapter" title="Appendix K Acknowledgements">
<link href="#rfc.appendix.Appendix%20K.1" rel="Chapter" title="Appendix K.1 Contributors">
<link href="#rfc.appendix.Appendix%20L" rel="Chapter" title="Appendix L RFC Editor Consideration">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content=
  "http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.539, 2011-01-02 17:13:00, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />
  <meta name="dct.creator" content="Doe, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sample-input-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2010-12" />
  
  <meta name="dct.abstract" content="This memorandum defines RTSP version 2.0 which obsoletes RTSP version 1.0 which is defined in RFC 2326." />
  <meta name="description" content="This memorandum defines RTSP version 2.0 which obsoletes RTSP version 1.0 which is defined in RFC 2326." />
  <meta name="keywords" content="I-D, INTERNET-DRAFT, mmusic, RTSP, RTSP/2.0, real-time streaming protocol" />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">MMUSIC Working Group</td>
<td class="right">H.S. Schulzrinne</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Columbia University</td>
</tr>
<tr>
<td class="left">Obsoletes: 2326 (if approved)</td>
<td class="right">A.R. Rao</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left">Expires: September 10, 2011</td>
<td class="right">R.L. Lanphier</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M.W. Westerlund</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Ericsson AB</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Stiemerling (Ed.)</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">NEC</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 09, 2011</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Real Time Streaming Protocol 2.0 (RTSP)<br />
  <span class="filename">draft-ietf-mmusic-rfc2326bis-27</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This memorandum defines RTSP version 2.0 which obsoletes RTSP version 1.0 which is defined in RFC 2326.</p>
<p>The Real Time Streaming Protocol, or RTSP, is an application-level protocol for setup and control of the delivery of data with real-time properties. RTSP provides an extensible framework to enable controlled, on-demand delivery of real-time data, such as audio and video. Sources of data can include both live data feeds and stored clips. This protocol is intended to control multiple data delivery sessions, provide a means for choosing delivery channels such as UDP, multicast UDP and TCP, and provide a means for choosing delivery mechanisms based upon RTP (RFC 3550).</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of this Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet- Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 10, 2011.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2011 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Protocol Overview</a>
</li>
<li>2.1.   <a href="#rfc.section.2.1">Presentation Description</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Session Establishment</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Media Delivery Control</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Session Parameter Manipulations</a>
</li>
<li>2.5.   <a href="#rfc.section.2.5">Media Delivery</a>
</li>
<li>2.5.1.   <a href="#rfc.section.2.5.1">Media Delivery Manipulations</a>
</li>
<li>2.6.   <a href="#rfc.section.2.6">Session Maintenance and Termination</a>
</li>
<li>2.7.   <a href="#rfc.section.2.7">Extending RTSP</a>
</li>
<li>3.   <a href="#rfc.section.3">Document Conventions</a>
</li>
<li>3.1.   <a href="#rfc.section.3.1">Notational Conventions</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Terminology</a>
</li>
<li>4.   <a href="#rfc.section.4">Protocol Parameters</a>
</li>
<li>4.1.   <a href="#rfc.section.4.1">RTSP Version</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">RTSP IRI and URI</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Session Identifiers</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">SMPTE Relative Timestamps</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Normal Play Time</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Absolute Time</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Feature-Tags</a>
</li>
<li>4.8.   <a href="#rfc.section.4.8">Message Body Tags</a>
</li>
<li>4.9.   <a href="#rfc.section.4.9">Media Properties</a>
</li>
<li>4.9.1.   <a href="#rfc.section.4.9.1">Random Access and Seeking</a>
</li>
<li>4.9.2.   <a href="#rfc.section.4.9.2">Retention</a>
</li>
<li>4.9.3.   <a href="#rfc.section.4.9.3">Content Modifications</a>
</li>
<li>4.9.4.   <a href="#rfc.section.4.9.4">Supported Scale Factors</a>
</li>
<li>4.9.5.   <a href="#rfc.section.4.9.5">Mapping to the Attributes</a>
</li>
<li>5.   <a href="#rfc.section.5">RTSP Message</a>
</li>
<li>5.1.   <a href="#rfc.section.5.1">Message Types</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Message Headers</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Message Body</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Message Length</a>
</li>
<li>6.   <a href="#rfc.section.6">General Header Fields</a>
</li>
<li>7.   <a href="#rfc.section.7">Request</a>
</li>
<li>7.1.   <a href="#rfc.section.7.1">Request Line</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Request Header Fields</a>
</li>
<li>8.   <a href="#rfc.section.8">Response</a>
</li>
<li>8.1.   <a href="#rfc.section.8.1">Status-Line</a>
</li>
<li>8.1.1.   <a href="#rfc.section.8.1.1">Status Code and Reason Phrase</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Response Headers</a>
</li>
<li>9.   <a href="#rfc.section.9">Message Body</a>
</li>
<li>9.1.   <a href="#rfc.section.9.1">Message-Body Header Fields</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Message Body</a>
</li>
<li>10.   <a href="#rfc.section.10">Connections</a>
</li>
<li>10.1.   <a href="#rfc.section.10.1">Reliability and Acknowledgements</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Using Connections</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Closing Connections</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Timing Out Connections and RTSP Messages</a>
</li>
<li>10.5.   <a href="#rfc.section.10.5">Showing Liveness</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Use of IPv6</a>
</li>
<li>10.7.   <a href="#rfc.section.10.7">Overload Control</a>
</li>
<li>11.   <a href="#rfc.section.11">Capability Handling</a>
</li>
<li>12.   <a href="#rfc.section.12">Pipelining Support</a>
</li>
<li>13.   <a href="#rfc.section.13">Method Definitions</a>
</li>
<li>13.1.   <a href="#rfc.section.13.1">OPTIONS</a>
</li>
<li>13.2.   <a href="#rfc.section.13.2">DESCRIBE</a>
</li>
<li>13.3.   <a href="#rfc.section.13.3">SETUP</a>
</li>
<li>13.3.1.   <a href="#rfc.section.13.3.1">Changing Transport Parameters</a>
</li>
<li>13.4.   <a href="#rfc.section.13.4">PLAY</a>
</li>
<li>13.4.1.   <a href="#rfc.section.13.4.1">General Usage</a>
</li>
<li>13.4.2.   <a href="#rfc.section.13.4.2">Aggregated Sessions</a>
</li>
<li>13.4.3.   <a href="#rfc.section.13.4.3">Updating current PLAY Requests</a>
</li>
<li>13.4.4.   <a href="#rfc.section.13.4.4">Playing On-Demand Media</a>
</li>
<li>13.4.5.   <a href="#rfc.section.13.4.5">Playing Dynamic On-Demand Media</a>
</li>
<li>13.4.6.   <a href="#rfc.section.13.4.6">Playing Live Media</a>
</li>
<li>13.4.7.   <a href="#rfc.section.13.4.7">Playing Live with Recording</a>
</li>
<li>13.4.8.   <a href="#rfc.section.13.4.8">Playing Live with Time-Shift</a>
</li>
<li>13.5.   <a href="#rfc.section.13.5">PLAY_NOTIFY</a>
</li>
<li>13.5.1.   <a href="#rfc.section.13.5.1">End-of-Stream</a>
</li>
<li>13.5.2.   <a href="#rfc.section.13.5.2">Media-Properties-Update</a>
</li>
<li>13.5.3.   <a href="#rfc.section.13.5.3">Scale-Change</a>
</li>
<li>13.6.   <a href="#rfc.section.13.6">PAUSE</a>
</li>
<li>13.7.   <a href="#rfc.section.13.7">TEARDOWN</a>
</li>
<li>13.7.1.   <a href="#rfc.section.13.7.1">Client to Server</a>
</li>
<li>13.7.2.   <a href="#rfc.section.13.7.2">Server to Client</a>
</li>
<li>13.8.   <a href="#rfc.section.13.8">GET_PARAMETER</a>
</li>
<li>13.9.   <a href="#rfc.section.13.9">SET_PARAMETER</a>
</li>
<li>13.10.   <a href="#rfc.section.13.10">REDIRECT</a>
</li>
<li>14.   <a href="#rfc.section.14">Embedded (Interleaved) Binary Data</a>
</li>
<li>15.   <a href="#rfc.section.15">Status Code Definitions</a>
</li>
<li>15.1.   <a href="#rfc.section.15.1">Success 1xx</a>
</li>
<li>15.1.1.   <a href="#rfc.section.15.1.1">100 Continue</a>
</li>
<li>15.2.   <a href="#rfc.section.15.2">Success 2xx</a>
</li>
<li>15.2.1.   <a href="#rfc.section.15.2.1">200 OK</a>
</li>
<li>15.3.   <a href="#rfc.section.15.3">Redirection 3xx</a>
</li>
<li>15.3.1.   <a href="#rfc.section.15.3.1">301 Moved Permanently</a>
</li>
<li>15.3.2.   <a href="#rfc.section.15.3.2">302 Found</a>
</li>
<li>15.3.3.   <a href="#rfc.section.15.3.3">303 See Other</a>
</li>
<li>15.3.4.   <a href="#rfc.section.15.3.4">304 Not Modified</a>
</li>
<li>15.3.5.   <a href="#rfc.section.15.3.5">305 Use Proxy</a>
</li>
<li>15.4.   <a href="#rfc.section.15.4">Client Error 4xx</a>
</li>
<li>15.4.1.   <a href="#rfc.section.15.4.1">400 Bad Request</a>
</li>
<li>15.4.2.   <a href="#rfc.section.15.4.2">401 Unauthorized</a>
</li>
<li>15.4.3.   <a href="#rfc.section.15.4.3">402 Payment Required</a>
</li>
<li>15.4.4.   <a href="#rfc.section.15.4.4">403 Forbidden</a>
</li>
<li>15.4.5.   <a href="#rfc.section.15.4.5">404 Not Found</a>
</li>
<li>15.4.6.   <a href="#rfc.section.15.4.6">405 Method Not Allowed</a>
</li>
<li>15.4.7.   <a href="#rfc.section.15.4.7">406 Not Acceptable</a>
</li>
<li>15.4.8.   <a href="#rfc.section.15.4.8">407 Proxy Authentication Required</a>
</li>
<li>15.4.9.   <a href="#rfc.section.15.4.9">408 Request Timeout</a>
</li>
<li>15.4.10.   <a href="#rfc.section.15.4.10">410 Gone</a>
</li>
<li>15.4.11.   <a href="#rfc.section.15.4.11">411 Length Required</a>
</li>
<li>15.4.12.   <a href="#rfc.section.15.4.12">412 Precondition Failed</a>
</li>
<li>15.4.13.   <a href="#rfc.section.15.4.13">413 Request Message Body Too Large</a>
</li>
<li>15.4.14.   <a href="#rfc.section.15.4.14">414 Request-URI Too Long</a>
</li>
<li>15.4.15.   <a href="#rfc.section.15.4.15">415 Unsupported Media Type</a>
</li>
<li>15.4.16.   <a href="#rfc.section.15.4.16">451 Parameter Not Understood</a>
</li>
<li>15.4.17.   <a href="#rfc.section.15.4.17">452 reserved</a>
</li>
<li>15.4.18.   <a href="#rfc.section.15.4.18">453 Not Enough Bandwidth</a>
</li>
<li>15.4.19.   <a href="#rfc.section.15.4.19">454 Session Not Found</a>
</li>
<li>15.4.20.   <a href="#rfc.section.15.4.20">455 Method Not Valid in This State</a>
</li>
<li>15.4.21.   <a href="#rfc.section.15.4.21">456 Header Field Not Valid for Resource</a>
</li>
<li>15.4.22.   <a href="#rfc.section.15.4.22">457 Invalid Range</a>
</li>
<li>15.4.23.   <a href="#rfc.section.15.4.23">458 Parameter Is Read-Only</a>
</li>
<li>15.4.24.   <a href="#rfc.section.15.4.24">459 Aggregate Operation Not Allowed</a>
</li>
<li>15.4.25.   <a href="#rfc.section.15.4.25">460 Only Aggregate Operation Allowed</a>
</li>
<li>15.4.26.   <a href="#rfc.section.15.4.26">461 Unsupported Transport</a>
</li>
<li>15.4.27.   <a href="#rfc.section.15.4.27">462 Destination Unreachable</a>
</li>
<li>15.4.28.   <a href="#rfc.section.15.4.28">463 Destination Prohibited</a>
</li>
<li>15.4.29.   <a href="#rfc.section.15.4.29">464 Data Transport Not Ready Yet</a>
</li>
<li>15.4.30.   <a href="#rfc.section.15.4.30">465 Notification Reason Unknown</a>
</li>
<li>15.4.31.   <a href="#rfc.section.15.4.31">466 Key Management Error</a>
</li>
<li>15.4.32.   <a href="#rfc.section.15.4.32">470 Connection Authorization Required</a>
</li>
<li>15.4.33.   <a href="#rfc.section.15.4.33">471 Connection Credentials not accepted</a>
</li>
<li>15.4.34.   <a href="#rfc.section.15.4.34">472 Failure to establish secure connection</a>
</li>
<li>15.5.   <a href="#rfc.section.15.5">Server Error 5xx</a>
</li>
<li>15.5.1.   <a href="#rfc.section.15.5.1">500 Internal Server Error</a>
</li>
<li>15.5.2.   <a href="#rfc.section.15.5.2">501 Not Implemented</a>
</li>
<li>15.5.3.   <a href="#rfc.section.15.5.3">502 Bad Gateway</a>
</li>
<li>15.5.4.   <a href="#rfc.section.15.5.4">503 Service Unavailable</a>
</li>
<li>15.5.5.   <a href="#rfc.section.15.5.5">504 Gateway Timeout</a>
</li>
<li>15.5.6.   <a href="#rfc.section.15.5.6">505 RTSP Version Not Supported</a>
</li>
<li>15.5.7.   <a href="#rfc.section.15.5.7">551 Option not supported</a>
</li>
<li>16.   <a href="#rfc.section.16">Header Field Definitions</a>
</li>
<li>16.1.   <a href="#rfc.section.16.1">Accept</a>
</li>
<li>16.2.   <a href="#rfc.section.16.2">Accept-Credentials</a>
</li>
<li>16.3.   <a href="#rfc.section.16.3">Accept-Encoding</a>
</li>
<li>16.4.   <a href="#rfc.section.16.4">Accept-Language</a>
</li>
<li>16.5.   <a href="#rfc.section.16.5">Accept-Ranges</a>
</li>
<li>16.6.   <a href="#rfc.section.16.6">Allow</a>
</li>
<li>16.7.   <a href="#rfc.section.16.7">Authorization</a>
</li>
<li>16.8.   <a href="#rfc.section.16.8">Bandwidth</a>
</li>
<li>16.9.   <a href="#rfc.section.16.9">Blocksize</a>
</li>
<li>16.10.   <a href="#rfc.section.16.10">Cache-Control</a>
</li>
<li>16.11.   <a href="#rfc.section.16.11">Connection</a>
</li>
<li>16.12.   <a href="#rfc.section.16.12">Connection-Credentials</a>
</li>
<li>16.13.   <a href="#rfc.section.16.13">Content-Base</a>
</li>
<li>16.14.   <a href="#rfc.section.16.14">Content-Encoding</a>
</li>
<li>16.15.   <a href="#rfc.section.16.15">Content-Language</a>
</li>
<li>16.16.   <a href="#rfc.section.16.16">Content-Length</a>
</li>
<li>16.17.   <a href="#rfc.section.16.17">Content-Location</a>
</li>
<li>16.18.   <a href="#rfc.section.16.18">Content-Type</a>
</li>
<li>16.19.   <a href="#rfc.section.16.19">CSeq</a>
</li>
<li>16.20.   <a href="#rfc.section.16.20">Date</a>
</li>
<li>16.21.   <a href="#rfc.section.16.21">Expires</a>
</li>
<li>16.22.   <a href="#rfc.section.16.22">From</a>
</li>
<li>16.23.   <a href="#rfc.section.16.23">If-Match</a>
</li>
<li>16.24.   <a href="#rfc.section.16.24">If-Modified-Since</a>
</li>
<li>16.25.   <a href="#rfc.section.16.25">If-None-Match</a>
</li>
<li>16.26.   <a href="#rfc.section.16.26">Last-Modified</a>
</li>
<li>16.27.   <a href="#rfc.section.16.27">Location</a>
</li>
<li>16.28.   <a href="#rfc.section.16.28">Media-Properties</a>
</li>
<li>16.29.   <a href="#rfc.section.16.29">Media-Range</a>
</li>
<li>16.30.   <a href="#rfc.section.16.30">MTag</a>
</li>
<li>16.31.   <a href="#rfc.section.16.31">Notify-Reason</a>
</li>
<li>16.32.   <a href="#rfc.section.16.32">Pipelined-Requests</a>
</li>
<li>16.33.   <a href="#rfc.section.16.33">Proxy-Authenticate</a>
</li>
<li>16.34.   <a href="#rfc.section.16.34">Proxy-Authorization</a>
</li>
<li>16.35.   <a href="#rfc.section.16.35">Proxy-Require</a>
</li>
<li>16.36.   <a href="#rfc.section.16.36">Proxy-Supported</a>
</li>
<li>16.37.   <a href="#rfc.section.16.37">Public</a>
</li>
<li>16.38.   <a href="#rfc.section.16.38">Range</a>
</li>
<li>16.39.   <a href="#rfc.section.16.39">Referrer</a>
</li>
<li>16.40.   <a href="#rfc.section.16.40">Request-Status</a>
</li>
<li>16.41.   <a href="#rfc.section.16.41">Require</a>
</li>
<li>16.42.   <a href="#rfc.section.16.42">Retry-After</a>
</li>
<li>16.43.   <a href="#rfc.section.16.43">RTP-Info</a>
</li>
<li>16.44.   <a href="#rfc.section.16.44">Scale</a>
</li>
<li>16.45.   <a href="#rfc.section.16.45">Seek-Style</a>
</li>
<li>16.46.   <a href="#rfc.section.16.46">Server</a>
</li>
<li>16.47.   <a href="#rfc.section.16.47">Session</a>
</li>
<li>16.48.   <a href="#rfc.section.16.48">Speed</a>
</li>
<li>16.49.   <a href="#rfc.section.16.49">Supported</a>
</li>
<li>16.50.   <a href="#rfc.section.16.50">Terminate-Reason</a>
</li>
<li>16.51.   <a href="#rfc.section.16.51">Timestamp</a>
</li>
<li>16.52.   <a href="#rfc.section.16.52">Transport</a>
</li>
<li>16.53.   <a href="#rfc.section.16.53">Unsupported</a>
</li>
<li>16.54.   <a href="#rfc.section.16.54">User-Agent</a>
</li>
<li>16.55.   <a href="#rfc.section.16.55">Vary</a>
</li>
<li>16.56.   <a href="#rfc.section.16.56">Via</a>
</li>
<li>16.57.   <a href="#rfc.section.16.57">WWW-Authenticate</a>
</li>
<li>17.   <a href="#rfc.section.17">Proxies</a>
</li>
<li>17.1.   <a href="#rfc.section.17.1">Proxies and Protocol Extensions</a>
</li>
<li>17.2.   <a href="#rfc.section.17.2">Multiplexing and Demultiplexing of Messages</a>
</li>
<li>18.   <a href="#rfc.section.18">Caching</a>
</li>
<li>18.1.   <a href="#rfc.section.18.1"> Validation Model</a>
</li>
<li>18.1.1.   <a href="#rfc.section.18.1.1">Last-Modified Dates </a>
</li>
<li>18.1.2.   <a href="#rfc.section.18.1.2">Message Body Tag Cache Validators</a>
</li>
<li>18.1.3.   <a href="#rfc.section.18.1.3">Weak and Strong Validators</a>
</li>
<li>18.1.4.   <a href="#rfc.section.18.1.4">Rules for When to Use Message Body Tags and Last-Modified Dates</a>
</li>
<li>18.1.5.   <a href="#rfc.section.18.1.5">Non-validating Conditionals</a>
</li>
<li>18.2.   <a href="#rfc.section.18.2">Invalidation After Updates or Deletions</a>
</li>
<li>19.   <a href="#rfc.section.19">Security Framework</a>
</li>
<li>19.1.   <a href="#rfc.section.19.1">RTSP and HTTP Authentication</a>
</li>
<li>19.2.   <a href="#rfc.section.19.2">RTSP over TLS</a>
</li>
<li>19.3.   <a href="#rfc.section.19.3">Security and Proxies</a>
</li>
<li>19.3.1.   <a href="#rfc.section.19.3.1">Accept-Credentials</a>
</li>
<li>19.3.2.   <a href="#rfc.section.19.3.2">User approved TLS procedure</a>
</li>
<li>20.   <a href="#rfc.section.20">Syntax</a>
</li>
<li>20.1.   <a href="#rfc.section.20.1">Base Syntax</a>
</li>
<li>20.2.   <a href="#rfc.section.20.2">RTSP Protocol Definition</a>
</li>
<li>20.2.1.   <a href="#rfc.section.20.2.1">Generic Protocol elements</a>
</li>
<li>20.2.2.   <a href="#rfc.section.20.2.2">Message Syntax</a>
</li>
<li>20.2.3.   <a href="#rfc.section.20.2.3">Header Syntax</a>
</li>
<li>20.3.   <a href="#rfc.section.20.3">SDP extension Syntax</a>
</li>
<li>21.   <a href="#rfc.section.21">Security Considerations</a>
</li>
<li>21.1.   <a href="#rfc.section.21.1">Remote denial of Service Attack</a>
</li>
<li>22.   <a href="#rfc.section.22">IANA Considerations</a>
</li>
<li>22.1.   <a href="#rfc.section.22.1">Feature-tags</a>
</li>
<li>22.1.1.   <a href="#rfc.section.22.1.1">Description</a>
</li>
<li>22.1.2.   <a href="#rfc.section.22.1.2">Registering New Feature-tags with IANA</a>
</li>
<li>22.1.3.   <a href="#rfc.section.22.1.3">Registered entries</a>
</li>
<li>22.2.   <a href="#rfc.section.22.2">RTSP Methods</a>
</li>
<li>22.2.1.   <a href="#rfc.section.22.2.1">Description</a>
</li>
<li>22.2.2.   <a href="#rfc.section.22.2.2">Registering New Methods with IANA</a>
</li>
<li>22.2.3.   <a href="#rfc.section.22.2.3">Registered Entries</a>
</li>
<li>22.3.   <a href="#rfc.section.22.3">RTSP Status Codes</a>
</li>
<li>22.3.1.   <a href="#rfc.section.22.3.1">Description</a>
</li>
<li>22.3.2.   <a href="#rfc.section.22.3.2">Registering New Status Codes with IANA</a>
</li>
<li>22.3.3.   <a href="#rfc.section.22.3.3">Registered Entries</a>
</li>
<li>22.4.   <a href="#rfc.section.22.4">RTSP Headers</a>
</li>
<li>22.4.1.   <a href="#rfc.section.22.4.1">Description</a>
</li>
<li>22.4.2.   <a href="#rfc.section.22.4.2">Registering New Headers with IANA</a>
</li>
<li>22.4.3.   <a href="#rfc.section.22.4.3">Registered entries</a>
</li>
<li>22.5.   <a href="#rfc.section.22.5">Accept-Credentials</a>
</li>
<li>22.5.1.   <a href="#rfc.section.22.5.1">Accept-Credentials policies</a>
</li>
<li>22.5.2.   <a href="#rfc.section.22.5.2">Accept-Credentials hash algorithms</a>
</li>
<li>22.6.   <a href="#rfc.section.22.6">Cache-Control Cache Directive Extensions</a>
</li>
<li>22.7.   <a href="#rfc.section.22.7">Media Properties</a>
</li>
<li>22.7.1.   <a href="#rfc.section.22.7.1">Description</a>
</li>
<li>22.7.2.   <a href="#rfc.section.22.7.2">Registration Rules</a>
</li>
<li>22.7.3.   <a href="#rfc.section.22.7.3">Registered Values</a>
</li>
<li>22.8.   <a href="#rfc.section.22.8">Notify-Reason header</a>
</li>
<li>22.8.1.   <a href="#rfc.section.22.8.1">Description</a>
</li>
<li>22.8.2.   <a href="#rfc.section.22.8.2">Registration Rules</a>
</li>
<li>22.8.3.   <a href="#rfc.section.22.8.3">Registered Values</a>
</li>
<li>22.9.   <a href="#rfc.section.22.9">Range header formats</a>
</li>
<li>22.9.1.   <a href="#rfc.section.22.9.1">Description</a>
</li>
<li>22.9.2.   <a href="#rfc.section.22.9.2">Registration Rules</a>
</li>
<li>22.9.3.   <a href="#rfc.section.22.9.3">Registered Values</a>
</li>
<li>22.10.   <a href="#rfc.section.22.10">Terminate-Reason Header</a>
</li>
<li>22.10.1.   <a href="#rfc.section.22.10.1">Redirect Reasons</a>
</li>
<li>22.10.2.   <a href="#rfc.section.22.10.2">Terminate-Reason Header Parameters</a>
</li>
<li>22.11.   <a href="#rfc.section.22.11">RTP-Info header parameters</a>
</li>
<li>22.11.1.   <a href="#rfc.section.22.11.1">Description</a>
</li>
<li>22.11.2.   <a href="#rfc.section.22.11.2">Registration Rules</a>
</li>
<li>22.11.3.   <a href="#rfc.section.22.11.3">Registered Values</a>
</li>
<li>22.12.   <a href="#rfc.section.22.12">Seek-Style Policies</a>
</li>
<li>22.12.1.   <a href="#rfc.section.22.12.1">Description</a>
</li>
<li>22.12.2.   <a href="#rfc.section.22.12.2">Registration Rules</a>
</li>
<li>22.12.3.   <a href="#rfc.section.22.12.3">Registered Values</a>
</li>
<li>22.13.   <a href="#rfc.section.22.13">Transport Header Registries</a>
</li>
<li>22.13.1.   <a href="#rfc.section.22.13.1">Transport Protocol Specification</a>
</li>
<li>22.13.2.   <a href="#rfc.section.22.13.2">Transport modes</a>
</li>
<li>22.13.3.   <a href="#rfc.section.22.13.3">Transport Parameters</a>
</li>
<li>22.14.   <a href="#rfc.section.22.14">URI Schemes</a>
</li>
<li>22.14.1.   <a href="#rfc.section.22.14.1">The rtsp URI Scheme</a>
</li>
<li>22.14.2.   <a href="#rfc.section.22.14.2">The rtsps URI Scheme</a>
</li>
<li>22.14.3.   <a href="#rfc.section.22.14.3">The rtspu URI Scheme</a>
</li>
<li>22.15.   <a href="#rfc.section.22.15">SDP attributes</a>
</li>
<li>22.16.   <a href="#rfc.section.22.16">Media Type Registration for text/parameters</a>
</li>
<li>23.   <a href="#rfc.references">References</a>
</li>
<li>23.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>23.2.   <a href="#rfc.references.2">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.Appendix%20A">Examples</a>
</li>
<li>Appendix A.1.   <a href="#rfc.appendix.Appendix%20A.1">Media on Demand (Unicast)</a>
</li>
<li>Appendix A.2.   <a href="#rfc.appendix.Appendix%20A.2">Media on Demand using Pipelining</a>
</li>
<li>Appendix A.3.   <a href="#rfc.appendix.Appendix%20A.3">Media on Demand (Unicast)</a>
</li>
<li>Appendix A.4.   <a href="#rfc.appendix.Appendix%20A.4">Single Stream Container Files</a>
</li>
<li>Appendix A.5.   <a href="#rfc.appendix.Appendix%20A.5">Live Media Presentation Using Multicast</a>
</li>
<li>Appendix A.6.   <a href="#rfc.appendix.Appendix%20A.6">Capability Negotiation</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.Appendix%20B">RTSP Protocol State Machine</a>
</li>
<li>Appendix B.1.   <a href="#rfc.appendix.Appendix%20B.1">States</a>
</li>
<li>Appendix B.2.   <a href="#rfc.appendix.Appendix%20B.2">State variables</a>
</li>
<li>Appendix B.3.   <a href="#rfc.appendix.Appendix%20B.3">Abbreviations</a>
</li>
<li>Appendix B.4.   <a href="#rfc.appendix.Appendix%20B.4">State Tables</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.Appendix%20C">Media Transport Alternatives</a>
</li>
<li>Appendix C.1.   <a href="#rfc.appendix.Appendix%20C.1">RTP</a>
</li>
<li>Appendix C.1.1.   <a href="#rfc.appendix.Appendix%20C.1.1">AVP</a>
</li>
<li>Appendix C.1.2.   <a href="#rfc.appendix.Appendix%20C.1.2">AVP/UDP</a>
</li>
<li>Appendix C.1.3.   <a href="#rfc.appendix.Appendix%20C.1.3">AVPF/UDP</a>
</li>
<li>Appendix C.1.4.   <a href="#rfc.appendix.Appendix%20C.1.4">SAVP/UDP</a>
</li>
<li>Appendix C.1.4.1.   <a href="#rfc.appendix.Appendix%20C.1.4.1">MIKEY Key Establishment</a>
</li>
<li>Appendix C.1.5.   <a href="#rfc.appendix.Appendix%20C.1.5">SAVPF/UDP</a>
</li>
<li>Appendix C.1.6.   <a href="#rfc.appendix.Appendix%20C.1.6">RTCP usage with RTSP</a>
</li>
<li>Appendix C.1.6.1.   <a href="#rfc.appendix.Appendix%20C.1.6.1">Media synchronization</a>
</li>
<li>Appendix C.1.6.2.   <a href="#rfc.appendix.Appendix%20C.1.6.2">RTSP Session keep-alive</a>
</li>
<li>Appendix C.1.6.3.   <a href="#rfc.appendix.Appendix%20C.1.6.3">Bit-rate adaption</a>
</li>
<li>Appendix C.1.6.4.   <a href="#rfc.appendix.Appendix%20C.1.6.4">RTP and RTCP Multiplexing</a>
</li>
<li>Appendix C.2.   <a href="#rfc.appendix.Appendix%20C.2">RTP over TCP</a>
</li>
<li>Appendix C.2.1.   <a href="#rfc.appendix.Appendix%20C.2.1">Interleaved RTP over TCP</a>
</li>
<li>Appendix C.2.2.   <a href="#rfc.appendix.Appendix%20C.2.2">RTP over independent TCP</a>
</li>
<li>Appendix C.3.   <a href="#rfc.appendix.Appendix%20C.3">Handling Media Clock Time Jumps in the RTP Media Layer</a>
</li>
<li>Appendix C.4.   <a href="#rfc.appendix.Appendix%20C.4">Handling RTP Timestamps after PAUSE</a>
</li>
<li>Appendix C.5.   <a href="#rfc.appendix.Appendix%20C.5">RTSP / RTP Integration</a>
</li>
<li>Appendix C.6.   <a href="#rfc.appendix.Appendix%20C.6">Scaling with RTP</a>
</li>
<li>Appendix C.7.   <a href="#rfc.appendix.Appendix%20C.7">Maintaining NPT synchronization with RTP timestamps</a>
</li>
<li>Appendix C.8.   <a href="#rfc.appendix.Appendix%20C.8">Continuous Audio</a>
</li>
<li>Appendix C.9.   <a href="#rfc.appendix.Appendix%20C.9">Multiple Sources in an RTP Session</a>
</li>
<li>Appendix C.10.   <a href="#rfc.appendix.Appendix%20C.10">Usage of SSRCs and the RTCP BYE Message During an RTSP Session</a>
</li>
<li>Appendix C.11.   <a href="#rfc.appendix.Appendix%20C.11">Future Additions</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.Appendix%20D">Use of SDP for RTSP Session Descriptions</a>
</li>
<li>Appendix D.1.   <a href="#rfc.appendix.Appendix%20D.1">Definitions</a>
</li>
<li>Appendix D.1.1.   <a href="#rfc.appendix.Appendix%20D.1.1">Control URI</a>
</li>
<li>Appendix D.1.2.   <a href="#rfc.appendix.Appendix%20D.1.2">Media Streams</a>
</li>
<li>Appendix D.1.3.   <a href="#rfc.appendix.Appendix%20D.1.3">Payload Type(s)</a>
</li>
<li>Appendix D.1.4.   <a href="#rfc.appendix.Appendix%20D.1.4">Format-Specific Parameters</a>
</li>
<li>Appendix D.1.5.   <a href="#rfc.appendix.Appendix%20D.1.5">Directionality of media stream</a>
</li>
<li>Appendix D.1.6.   <a href="#rfc.appendix.Appendix%20D.1.6">Range of Presentation</a>
</li>
<li>Appendix D.1.7.   <a href="#rfc.appendix.Appendix%20D.1.7">Time of Availability</a>
</li>
<li>Appendix D.1.8.   <a href="#rfc.appendix.Appendix%20D.1.8">Connection Information</a>
</li>
<li>Appendix D.1.9.   <a href="#rfc.appendix.Appendix%20D.1.9">Message Body Tag</a>
</li>
<li>Appendix D.2.   <a href="#rfc.appendix.Appendix%20D.2">Aggregate Control Not Available</a>
</li>
<li>Appendix D.3.   <a href="#rfc.appendix.Appendix%20D.3">Aggregate Control Available</a>
</li>
<li>Appendix D.4.   <a href="#rfc.appendix.Appendix%20D.4">Grouping of Media Lines in SDP</a>
</li>
<li>Appendix D.5.   <a href="#rfc.appendix.Appendix%20D.5">RTSP external SDP delivery</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.Appendix%20E">RTSP Use Cases</a>
</li>
<li>Appendix E.1.   <a href="#rfc.appendix.Appendix%20E.1">On-demand Playback of Stored Content</a>
</li>
<li>Appendix E.2.   <a href="#rfc.appendix.Appendix%20E.2">Unicast Distribution of Live Content</a>
</li>
<li>Appendix E.3.   <a href="#rfc.appendix.Appendix%20E.3">On-demand Playback using Multicast</a>
</li>
<li>Appendix E.4.   <a href="#rfc.appendix.Appendix%20E.4">Inviting an RTSP server into a conference</a>
</li>
<li>Appendix E.5.   <a href="#rfc.appendix.Appendix%20E.5">Live Content using Multicast</a>
</li>
<li>Appendix F.   <a href="#rfc.appendix.Appendix%20F">Text format for Parameters</a>
</li>
<li>Appendix G.   <a href="#rfc.appendix.Appendix%20G">Requirements for Unreliable Transport of RTSP</a>
</li>
<li>Appendix H.   <a href="#rfc.appendix.Appendix%20H">Backwards Compatibility Considerations</a>
</li>
<li>Appendix H.1.   <a href="#rfc.appendix.Appendix%20H.1">Play Request in Play State</a>
</li>
<li>Appendix H.2.   <a href="#rfc.appendix.Appendix%20H.2">Using Persistent Connections</a>
</li>
<li>Appendix I.   <a href="#rfc.appendix.Appendix%20I">Open Issues</a>
</li>
<li>Appendix J.   <a href="#rfc.appendix.Appendix%20J">Changes</a>
</li>
<li>Appendix J.1.   <a href="#rfc.appendix.Appendix%20J.1">Brief Overview</a>
</li>
<li>Appendix J.2.   <a href="#rfc.appendix.Appendix%20J.2">Detailed List of Changes</a>
</li>
<li>Appendix K.   <a href="#rfc.appendix.Appendix%20K">Acknowledgements</a>
</li>
<li>Appendix K.1.   <a href="#rfc.appendix.Appendix%20K.1">Contributors</a>
</li>
<li>Appendix L.   <a href="#rfc.appendix.Appendix%20L">RFC Editor Consideration</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This memo defines version 2.0 of the Real Time Streaming Protocol (RTSP 2.0). RTSP 2.0 is an application-level protocol for setup and control over the delivery of data with real-time properties, typically streaming media. Streaming media is, for instance, video on demand or audio live streaming. Put simply, RTSP acts as a "network remote control" for multimedia servers, similar to the remote control for a DVD player.</p>
<p id="rfc.section.1.p.2">The protocol operates between RTSP 2.0 clients and servers, but also supports the usage of proxies placed between clients and servers.  Clients can request information about streaming media from servers by asking for a description of the media or use media description provided externally. The media delivery protocol is used to establish the media streams described by the media description. Clients can then request to play out the media, pause it, or stop it completely, as known from DVD players remote control or media players. The requested media can consist of multiple audio and video streams that are delivered as a time-synchronized streams from servers to clients.</p>
<p id="rfc.section.1.p.3">RTSP 2.0 is a replacement of <a href="#RFC2326">RTSP 1.0</a> <cite title="NONE">[RFC2326]</cite> that obsoletes that specification. This protocol is based on RTSP 1.0 but is not backwards compatible other than in the basic version negotiation mechanism. The changes are documented in <a href="#sec_changes">Appendix Appendix J</a>. There are many</p>
<p id="rfc.section.1.p.4">reasons why RTSP 2.0 can't be backwards compatible with RTSP 1.0 but some of the main ones are:</p>

<ul>
<li>Most headers that needed to be extensible did not define the allowed syntax, preventing safe deployment of extensions;</li>
<li>The changed behavior of the PLAY method when received in Play state;</li>
<li>Changed behavior of the extensibility model and its mechanism;</li>
<li>The change of syntax for some headers.</li>
</ul>
<p id="rfc.section.1.p.5">In summary, there are so many small details that changing version become necessary to enable clarification and consistent behavior.</p>
<p id="rfc.section.1.p.6">This document is structured as follows. It begins with an overview of the protocol operations and its functions in an informal way. Then a set of definitions of used terms and document conventions is introduced. It is followed by the actual protocol specification. In the appendix some functionality that isn't core RTSP, but still important to enable some usage, is defined. RTP usage is defined in <a href="#sec_mediatran">Appendix Appendix C</a> and SDP usage with RTSP <a href="#sec_sdpusage">Appendix Appendix D</a>, making these two appendixes mandatory.  This is followed by a number of informational parts discussing the changes, use cases, different considerations or motivations.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Protocol Overview</h1>
<p id="rfc.section.2.p.1">This section provides a informative overview of the different mechanisms in the RTSP 2.0 protocol, to give the reader a high level understanding before getting into all the different details. In case of conflict with this description and the later sections, the later sections take precedence. For more information about considered use cases for RTSP see <a href="#sec_usecases">Appendix Appendix E</a>.</p>
<p id="rfc.section.2.p.2">RTSP 2.0 is a bi-directional request and response protocol that first establishes a context including content resources (the media) and then controls the delivery of these content resources from the provider to the consumer. RTSP has three fundamental parts: Session Establishment, Media Delivery Control, and an extensibility model described below. The protocol is based on some assumptions about existing functionality to provide a complete solution for client controlled real-time media delivery.</p>
<p id="rfc.section.2.p.3">RTSP uses text-based messages, requests and responses, that may contain a binary message body. An RTSP request starts with a method line that identifies the method, the protocol and version and the resource to act on. Following the method line are a number of RTSP headers. This part is ended by two consecutive carriage return line feed (CRLF) character pairs. The message body if present follows the two CRLF and the body's length are described by a message header. RTSP responses are similar, but start with a response line with the protocol and version, followed by a status code and a reason phrase. RTSP messages are sent over a reliable transport protocol between the client and server. RTSP 2.0 requires clients and servers to implement TCP, and TLS over TCP, as mandatory transports for RTSP messages.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Presentation Description</h1>
<p id="rfc.section.2.1.p.1">RTSP exists to provide access to multi-media presentations and content, but tries to be agnostic about the media type or the actual media delivery protocol that is used. To enable a client to implement a complete system, an RTSP-external mechanism for describing the presentation and the delivery protocol(s) is used. RTSP assumes that this description is either delivered completely out of bands or as a data object in the response to a client's request using the <a href="#sec_DESCRIBE">DESCRIBE method</a> <cite title="NONE">[sec_DESCRIBE]</cite>.</p>
<p id="rfc.section.2.1.p.2">Parameters that commonly have to be included in the Content Description are the following:</p>

<ul>
<li>Number of media streams</li>
<li>The resource identifier for each media stream/resource that is to be controlled by RTSP</li>
<li>The protocol that each media stream is to be delivered over</li>
<li>Transport protocol parameters that are not negotiated or vary with each client</li>
<li>Media encoding information enabling a client to correctly decode it upon reception</li>
<li>An aggregate control resource identifier</li>
</ul>
<p id="rfc.section.2.1.p.3">RTSP uses its own URI schemes ("rtsp" and "rtsps") to reference media resources and aggregates under common control.</p>
<p id="rfc.section.2.1.p.4">This specification describes in <a href="#sec_sdpusage">Appendix Appendix D</a> how one uses <a href="#RFC4566">SDP</a> <cite title="NONE">[RFC4566]</cite> for Content Description</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Session Establishment</h1>
<p id="rfc.section.2.2.p.1">The RTSP client can request the establishment of an RTSP session after having used the presentation description to determine which media streams are available, and also which media delivery protocol is used and their particular resource identifiers. The RTSP session is a common context between the client and the server that consist of one or more media resources that are to be under common media delivery control.</p>
<p id="rfc.section.2.2.p.2">The client creates an RTSP session by sending a request using the <a href="#sec_SETUP">SETUP method</a> <cite title="NONE">[sec_SETUP]</cite> to the server. In the SETUP request the client also includes all the transport parameters necessary to enable the media delivery protocol to function in the <a href="#sec_Transport">"Transport" header</a> <cite title="NONE">[sec_Transport]</cite>. This includes parameters that are pre-established by the presentation description but necessary for any middlebox to correctly handle the media delivery protocols. The Transport header in a request may contain multiple alternatives for media delivery in a prioritized list, which the server can select from. These alternatives are typically based on information in the content description.</p>
<p id="rfc.section.2.2.p.3">The server determines if the media resource is available upon receiving a SETUP request and if any of the transport parameter specifications are acceptable. If that is successful, an RTSP session context is created and the relevant parameters and state is stored. An identifier is created for the RTSP session and included in the response in the <a href="#sec_Session">Session header</a> <cite title="NONE">[sec_Session]</cite>. The SETUP response includes a Transport header that specifies which of the alternatives has been selected and relevant parameters.</p>
<p id="rfc.section.2.2.p.4">A SETUP request that references an existing RTSP session but identifies a new media resource is a request to add that media resource under common control with the already present media resources in an aggregated session. A client can expect this to work for all media resources under RTSP control within a multi-media content.  However, aggregating resources from different content are likely to be refused by the server. The RTSP session as aggregate is referenced by the aggregate control URI, even if the RTSP session only contains a single media.</p>
<p id="rfc.section.2.2.p.5">To avoid an extra round trip in the session establishment of aggregated RTSP sessions, RTSP 2.0 supports pipelined requests; i.e., the client can send multiple requests back-to-back without waiting first for the completion of any of them. The client uses client-selected identifier in the Pipelined-Requests header to instruct the server to bind multiple requests together as if they included the session identifier.</p>
<p id="rfc.section.2.2.p.6">The SETUP response also provides additional information about the established sessions in a couple of different headers. The Media-Properties header includes a number of properties that apply for the aggregate that is valuable when doing media delivery control and configuring user interface. The Accept-Ranges header informs the client about which range formats that the server supports with these media resources. The Media-Range header inform the client about the time range of the media currently available.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> Media Delivery Control</h1>
<p id="rfc.section.2.3.p.1">After having established an RTSP session, the client can start controlling the media delivery. The basic operations are Start by using the <a href="#sec_PLAY">PLAY method</a> <cite title="NONE">[sec_PLAY]</cite> and Halt by using the <a href="#sec_PAUSE">PAUSE method</a> <cite title="NONE">[sec_PAUSE]</cite>. PLAY also allows for choosing the starting media position from which the server should deliver the media. The positioning is done using the <a href="#sec_Range">Range header</a> <cite title="NONE">[sec_Range]</cite> that supports several different time formats: <a href="#sec_npt">Normal Play Time</a> <cite title="NONE">[sec_npt]</cite>, <a href="#sec_smpte">SMPTE Timestamps</a> <cite title="NONE">[sec_smpte]</cite> and <a href="#sec_clock">absolute time</a> <cite title="NONE">[sec_clock]</cite>. The Range header does further allow the client to specify a position where delivery should end, thus allowing a specific interval to be delivered.</p>
<p id="rfc.section.2.3.p.2">The support for positioning/searching within a content depends on the content's media properties. Content exists in a number of different types, such as: on-demand, live, and live with simultaneous recording. Even within these categories there are differences in how the content is generated and distributed, which affect how it can be accessed for playback. The properties applicable for the RTSP session are provided by the server in the SETUP response using the <a href="#sec_Media-Properties">Media-Properties header</a> <cite title="NONE">[sec_Media-Properties]</cite>. These are expressed using one or several independent attributes. A first attribute is Random Access, which expresses if positioning can be done, and with what granularity. Another aspect is whether the content will change during the lifetime of the session. While on-demand content will provided in full from the beginning, a live stream being recorded results in the length of the accessible content growing as the session goes on. There also exist content that is dynamically built by another protocol than RTSP and thus also changes in steps during the session, but maybe not continuously. Furthermore, when content is recorded, there are cases where not the complete content is maintained, but, for example, only the last hour. All these properties result in the need for mechanisms that will be discussed below.</p>
<p id="rfc.section.2.3.p.3">When the client accesses on-demand content that allows random access in, the client can issue the PLAY request for any point in the content between the start and the end. The server will deliver media from the closest random access point prior to the requested point and indicate that in its PLAY response. If the client issues a PAUSE, the delivery will be halted and the point at which the server stopped will be reported back in the response. The client can later resume by a sending PLAY request without a range header. When the server is about to complete the PLAY request by delivering the end of the content or the requested range, the server will send a PLAY_NOTIFY request indicating this.</p>
<p id="rfc.section.2.3.p.4">When playing live content with no extra functions, such as recording, the client will receive the live media from the server after having sent a PLAY request. Seeking in such content is not possible as the server does not store it, but only forwards it from the source of the session. Thus delivery continues until the client sends a PAUSE request, tears down the session, or the content ends.</p>
<p id="rfc.section.2.3.p.5">For live sessions that are being recorded the client will need to keep track of how the recording progresses. Upon session establishment the client will learn the current duration of the recording from the Media-Range header. As the recording is ongoing the content grows in direct relation to the passed time. Therefore, each server's response to a PLAY request will contain the current Media-Range header. The server should also regularly send every 5 minutes the current media range in a PLAY_NOTIFY request. If the live transmission ends, the server must send a PLAY_NOTIFY request with the updated Media-Properties indicating that the content stopped being a recorded live session and instead become a on-demand content; the request also contains the final media range. While the live delivery continues the client can request to play the current live point by using the NPT timescale symbol "now", or it can request a specific point in the available content by an explicit range request for that point. If the requested point is outside of the available interval the server will adjust the position to the closest available point, i.e., either at the beginning or the end.</p>
<p id="rfc.section.2.3.p.6">A special case of recording is that where the recording is not retained longer than a specific time period, thus as the live delivery continues the client can access any media within a moving window that covers, for example, "now" to "now" minus 1 hour. A client that pauses on a specific point within the content may not be able to retrieve the content anymore. If the client waits too long before resuming the pause point, the content may no longer be available. In this case the pause point will be adjusted to the end of the available media.</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> Session Parameter Manipulations</h1>
<p id="rfc.section.2.4.p.1">A session may have additional state or functionality that effects how the server or client treats the session, content, how it functions, or feedback on how well the session works. Such extensions are not defined in this specification, but may be done in various extensions. RTSP has two methods for retrieving and setting parameter values on either the client or the server: <a href="#sec_GET_PARAMETER">GET_PARAMETER</a> <cite title="NONE">[sec_GET_PARAMETER]</cite> and <a href="#sec_SET_PARAMETER">SET_PARAMETER</a> <cite title="NONE">[sec_SET_PARAMETER]</cite>. These methods carry the parameters in a message body of the appropriate format. One can also use headers to query state with the GET_PARAMETER method. As an example, clients needing to know the current media-range for a time-progressing session can use the GET_PARAMETER method and include the media-range. Furthermore, synchronization information can be requested by using a combination of RTP-Info and Range.</p>
<p id="rfc.section.2.4.p.2">RTSP 2.0 does not have a strong mechanism for providing negotiation of which headers, or parameters and their formats, that can be used.  However, responses will indicate request headers or parameters that are not supported. A priori determination of what features are available needs to be done through out-of-band mechanisms, like the session description, or through the usage of <a href="#sec_feature_tags">feature tags</a> <cite title="NONE">[sec_feature_tags]</cite>.</p>
<h1 id="rfc.section.2.5">
<a href="#rfc.section.2.5">2.5.</a> Media Delivery</h1>
<p id="rfc.section.2.5.p.1">The delivery of media to the RTSP client is done with a protocol outside of RTSP and this protocol is determined during the session establishment. This document specifies how media is delivered with RTP over UDP, TCP or the RTSP control connection. Additional protocols may be specified in the future based on demand.</p>
<p id="rfc.section.2.5.p.2">The usage of RTP as media delivery protocol requires some additional information to function well. The PLAY response contains information to enable reliable and timely deliver of how a client should synchronize different sources in the different RTP sessions. It also provides a mapping between RTP timestamps and the content time scale. When the server want to notify the client about the completion of the media delivery, it sends a PLAY_NOTIFY request to the client.  The PLAY_NOTIFY request includes information about the stream end, including the last RTP sequence number for each stream, thus enabling the client to empty the buffer smoothly.</p>
<h1 id="rfc.section.2.5.1">
<a href="#rfc.section.2.5.1">2.5.1.</a> Media Delivery Manipulations</h1>
<p id="rfc.section.2.5.1.p.1">The basic playback functionality of RTSP enables delivery of a range of requested content to the client at the pace intended by the content's creator. However, RTSP can also manipulate the delivery to the client in two ways.</p>
<p></p>

<dl>
<dt>Scale:</dt>
<dd style="margin-left: 8">The ratio of media content time delivered per unit playback time.</dd>
<dt>Speed:</dt>
<dd style="margin-left: 8">The ratio of playback time delivered per unit of wallclock time.</dd>
</dl>

<p>Both affect the media delivery per time unit. However, they manipulate two independent time scales and the effects are possible to combine.</p>
<p id="rfc.section.2.5.1.p.3">Scale is used for fast forward or slow motion control as it changes the amount of content timescale that should be played back per time unit. Scale &gt; 1.0, means fast forward, e.g. Scale=2.0 results in that 2 seconds of content is played back every second of playback. Scale = 1.0 is the default value that is used if no Scale is specified, i.e., playback at the content's original rate. Scale values between 0 and 1.0 is providing for slow motion. Scale can be negative to allow for reverse playback in either regular pace (Scale = -1.0) or fast backwards (Scale &lt; -1.0) or slow motion backwards (-1.0 &lt; Scale &lt; 0). Scale = 0 is equal to pause and is not allowed.</p>
<p id="rfc.section.2.5.1.p.4">In most cases the realization of scale means server side manipulation of the media to ensure that the client can actually play it back. These media manipulation and when they are needed are highly media-type dependent. Lets exemplify with two common media types audio and video.</p>
<p id="rfc.section.2.5.1.p.5">It is very difficult to modify the playback rate of audio. A maximum of 10-30% is possible by changing the pitch-rate of speech.  Music goes out of tune if one tries to manipulate the playback rate by resampling it. This is a well known problem and audio is commonly muted or played back in short segments with skips to keep up with the current playback point.</p>
<p id="rfc.section.2.5.1.p.6">For video is possible to manipulate the frame rate, although the rendering capabilities are often limited to certain frame rates.  Also the allowed bitrates in decoding, the structured used in the encoding and the dependency between frames and other capabilities of the rendering device limits the possible manipulations. Therefore, the basic fast forward capabilities often are implemented by selecting certain subsets of frames.</p>
<p id="rfc.section.2.5.1.p.7">Due to the media restrictions, the possible scale values are commonly restricted to the set of realizable scale ratios. To enable the clients to select from the possible scale values, RTSP can signal the supported Scale ratios for the content. To support aggregated or dynamic content, where this may change during the ongoing session and dependent on the location within the content, a mechanism for updating the media properties and the currently used scale factor exist.</p>
<p id="rfc.section.2.5.1.p.8">Speed affects how much of the playback timeline is delivered in a given wallclock period. The default is Speed = 1 which means to deliver at the same rate the media is consumed. Speed &gt; 1 means that the receiver will get content faster than it regularly would consume it. Speed &lt; 1 means that delivery is slower than the regular media rate. Speed values of 0 or lower have no meaning and are not allowed. This mechanism enables two general functionalities.  One is client side scale operations, i.e. the client receives all the frames and makes the adjustment to the playback locally. The second is delivery control for buffering of media. By specifying a speed over 1.0 the client can build up the amount of playback time it has present in its buffers to a level that is sufficient for its needs.</p>
<p id="rfc.section.2.5.1.p.9">A naive implementation of Speed would only affect the transmission schedule of the media and has a clear impact on the needed bandwidth. This would result in the data rate being proportional to the speed factor. Speed = 1.5, i.e., 50% faster than normal delivery, would result in a 50% increase in the data transport rate. If that can be supported or not depends solely on the underlying network path. Scale may also have some impact on the required bandwidth due to the manipulation of the content in the new playback schedule. An example is fast forward where only the independently decodable intra frames are included in the media stream. This usage of solely intra frames increases the data rate significantly compared to a normal sequence with the same number of frames, where most frames are encoded using prediction.</p>
<p id="rfc.section.2.5.1.p.10">This potential increase of the data rate needs to be handled by the media sender. The client has requested that the media will be delivered in a specific way, which should be honored. However, the media sender cannot ignore if the network path between the sender and the receiver can't handle the resulting media stream. In that case the media stream needs to be adapted to fit the available resources of the path. This can result in a reduced media quality.</p>
<p id="rfc.section.2.5.1.p.11">The need for bitrate adaptation becomes especially problematic in connection with the Speed semantics. If the goal is to fill up the buffer, the client may not want to do that at the cost of reduced quality. If the client wants to make local playout changes then it may actually require that the requested speed be honored. To resolve this issue, Speed uses a range so that both cases can be supported.  The server is requested to use the highest possible speed value within the range which is compatible with the available bandwidth.  As long as the server can maintain a speed value within the range it shall not change the media quality, but instead modify the actual delivery rate in response to available bandwidth and reflect this in the Speed value in the response. However, if this is not possible, the server should instead modify the media quality to respect the lowest speed value and the available bandwidth.</p>
<p id="rfc.section.2.5.1.p.12">This functionality enables the local scaling implementation to use a tight range, or even a range where the lower bound equals the upper bound, to identify that it requires the server to deliver the requested amount of media time per delivery time independent of how much it needs to adapt the media quality to fit within the available path bandwidth. For buffer filling, it is suitable to use a range with a reasonable span and with a lower bound at the nominal media rate 1.0, such as 1.0 - 2.5. If the client wants to reduce the buffer, it can specify an upper bound that is below 1.0 to force the server to deliver slower than the nominal media rate.</p>
<h1 id="rfc.section.2.6">
<a href="#rfc.section.2.6">2.6.</a> Session Maintenance and Termination</h1>
<p id="rfc.section.2.6.p.1">The session context that has been established is kept alive by having the client show liveness. This is done in two main ways:</p>

<ul>
<li>Media transport protocol keep-alive. RTCP may be used when using RTP.</li>
<li>Any RTSP request referencing the session context.</li>
</ul>
<p><a href="#sec_liveness">Section 10.5</a> discusses the methods for showing liveness in more depth. If the client fails to show liveness for more than the established session timeout value (normally 60 seconds), the server may terminate the context. Other values may be selected by the server through the inclusion of the timeout parameter in the session header.</p>
<p id="rfc.section.2.6.p.3">The session context is normally terminated by the client sending a TEARDOWN request to the server referencing the aggregated control URI.  An individual media resource can be removed from a session context by a TEARDOWN request referencing that particular media resource. If all media resources are removed from a session context, the session context is terminated.</p>
<p id="rfc.section.2.6.p.4">A client may keep the session alive indefinitely if allowed by the server; however, it is recommended to release the session context when an extended period of time without media delivery activity has passed.  The client can re-establish the session context if required later.  What constitutes an extended period of time is dependent on the server and its usage. It is recommended that the client terminates the session before 10*times the session timeout value has passed. A server may terminate the session after one session timeout period without any client activity beyond keep-alive. When a server terminates the session context, it does that by sending a TEARDOWN request indicating the reason.</p>
<p id="rfc.section.2.6.p.5">A server can also request that the client tear down the session and re-establish it at an alternative server, as may be needed for maintenance. This is done by using the REDIRECT method. The Terminate-Reason header is used to indicate when and why. The Location header indicates where it should connect if there is an alternative server available. When the deadline expires, the server simply stops providing the service. To achieve a clean closure, the client needs to initiate session termination prior to the deadline. In case the server has no other server to redirect to, and wants to close the session for maintenance, it shall use the TEARDOWN method with a Terminate-Reason header.</p>
<h1 id="rfc.section.2.7">
<a href="#rfc.section.2.7">2.7.</a> <a href="#sec_extend-rtsp" id="sec_extend-rtsp">Extending RTSP</a>
</h1>
<p id="rfc.section.2.7.p.1">RTSP is quite a versatile protocol which supports extensions in many different directions. Even this core specification contains several blocks of functionality that are optional to implement. The use case and need for the protocol deployment should determine what parts are implemented. Allowing for extensions makes it possible for RTSP to reach out to additional use cases. However, extensions will affect the interoperability of the protocol and therefore it is important that they can be added in a structured way.</p>
<p id="rfc.section.2.7.p.2">The client can learn the capability of a server by using the <a href="#sec_OPTIONS">OPTIONS method</a> <cite title="NONE">[sec_OPTIONS]</cite> and the <a href="#sec_Supported">Supported header</a> <cite title="NONE">[sec_Supported]</cite>. It can also try and possibly fail using new methods, or require that particular features are supported using the Require or Proxy-Require header.</p>
<p id="rfc.section.2.7.p.3">The RTSP protocol in itself can be extended in three ways, listed here in order of the magnitude of changes supported: </p>

<ul>
<li>Existing methods can be extended with new parameters, for example, headers, as long as these parameters can be safely ignored by the recipient. If the client needs negative acknowledgment when a method extension is not supported, a tag corresponding to the extension may be added in the field of the Require or Proxy-Require headers (see <a href="#sec_Proxy-Require">Section 16.35</a>).</li>
<li>New methods can be added. If the recipient of the message does not understand the request, it must respond with error code 501 (Not Implemented) so that the sender can avoid using this method again. A client may also use the OPTIONS method to inquire about methods supported by the server. The server must list the methods it supports using the Public response header.</li>
<li>A new version of the protocol can be defined, allowing almost all aspects (except the position of the protocol version number) to change. A new version of the protocol must be registered through an IETF standard track document.</li>
</ul>
<p id="rfc.section.2.7.p.4">The basic capability discovery mechanism can be used to both discover support for a certain feature and to ensure that a feature is available when performing a request. For a detailed explanation of this see <a href="#sec_capability">Section 11</a>.</p>
<p id="rfc.section.2.7.p.5">New media delivery protocols may be added and negotiated at session establishment, in addition to extension to the core protocol. Certain types of protocol manipulations can be done through parameter formats using SET_PARAMETER and GET_PARAMETER.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Document Conventions</h1>
<p></p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#sec_notational_conventions" id="sec_notational_conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.3.1.p.1">Since a few of the definitions are identical to HTTP/1.1, this specification only points to the section where they are defined rather than copying it. For brevity, [HX.Y] is to be taken to refer to Section X.Y of the current HTTP/1.1 specification (<a href="#RFC2616">[RFC2616]</a>).</p>
<p id="rfc.section.3.1.p.2">All the mechanisms specified in this document are described in both prose and the Augmented Backus-Naur form (ABNF) described in detail in <a href="#RFC5234">[RFC5234]</a>.</p>
<p id="rfc.section.3.1.p.3">Indented and smaller-type paragraphs are used to provide informative background and motivation. This is intended to give readers who were not involved with the formulation of the specification an understanding of why things are the way they are in RTSP.</p>
<p id="rfc.section.3.1.p.4">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.3.1.p.5">The word, "unspecified" is used to indicate functionality or features that are not defined in this specification. Such functionality cannot be used in a standardized manner without further definition in an extension specification to RTSP.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#sec_Terminology" id="sec_Terminology">Terminology</a>
</h1>
<p></p>

<dl>
<dt>Aggregate control:</dt>
<dd style="margin-left: 8">The concept of controlling multiple streams using a single timeline, generally maintained by the server. A client, for example, uses aggregate control when it issues a single play or pause message to simultaneously control both the audio and video in a movie. A session which is under aggregate control is referred to as an aggregated session.</dd>
<dt>Aggregate control URI:</dt>
<dd style="margin-left: 8">The URI used in an RTSP request to refer to and control an aggregated session. It normally, but not always, corresponds to the presentation URI specified in the session description. See <a href="#sec_SETUP">Section 13.3</a> for more information.</dd>
<dt>Client:</dt>
<dd style="margin-left: 8">The client requests media service from the media server.</dd>
<dt>Connection:</dt>
<dd style="margin-left: 8">A transport layer virtual circuit established between two programs for the purpose of communication.</dd>
<dt>Container file:</dt>
<dd style="margin-left: 8">A file which may contain multiple media streams which often constitutes a presentation when played together. The concept of a container file is not embedded in the protocol. However, RTSP servers may offer aggregate control on the media streams within these files.</dd>
<dt>Continuous media:</dt>
<dd style="margin-left: 8">Data where there is a timing relationship between source and sink; that is, the sink needs to reproduce the timing relationship that existed at the source. The most common examples of continuous media are audio and motion video. Continuous media can be real-time (interactive or conversational), where there is a "tight" timing relationship between source and sink, or streaming where the relationship is less strict.</dd>
<dt>Feature-tag:</dt>
<dd style="margin-left: 8">A tag representing a certain set of functionality, i.e. a feature.</dd>
<dt>IRI:</dt>
<dd style="margin-left: 8">Internationalized Resource Identifier, is the same as an URI, with the exception that it allows characters from the whole Universal Character Set (Unicode/ISO 10646), rather than the US-ASCII only. See <a href="#RFC3987">[RFC3987]</a> for more information.</dd>
<dt>Live:</dt>
<dd style="margin-left: 8">Normally used to describe a presentation or session with media coming from an ongoing event. This generally results in the session having an unbound or only loosely defined duration, and sometimes no seek operations are possible.</dd>
<dt>Media initialization:</dt>
<dd style="margin-left: 8">Datatype/codec specific initialization. This includes such things as clock rates, color tables, etc. Any transport-independent information which is required by a client for playback of a media stream occurs in the media initialization phase of stream setup.</dd>
<dt>Media parameter:</dt>
<dd style="margin-left: 8">Parameter specific to a media type that may be changed before or during stream delivery.</dd>
<dt>Media server:</dt>
<dd style="margin-left: 8">The server providing media delivery services for one or more media streams. Different media streams within a presentation may originate from different media servers.  A media server may reside on the same host or on a different host from which the presentation is invoked.</dd>
<dt>(Media) stream:</dt>
<dd style="margin-left: 8">A single media instance, e.g., an audio stream or a video stream as well as a single whiteboard or shared application group. When using RTP, a stream consists of all RTP and RTCP packets created by a source within an RTP session.</dd>
<dt>Message:</dt>
<dd style="margin-left: 8">The basic unit of RTSP communication, consisting of a structured sequence of octets matching the syntax defined in <a href="#sec_syntax">Section 20</a> and transmitted over a connection or a connectionless transport. A message is either a Request or a Response.</dd>
<dt>Message Body:</dt>
<dd style="margin-left: 8">The information transferred as the payload of a message (Request and response). A message body consists of meta-information in the form of message-body headers and content in the form of a message-body, as described in <a href="#sec_entity">Section 9</a>.</dd>
<dt>Non-Aggregated Control:</dt>
<dd style="margin-left: 8">Control of a single media stream.</dd>
<dt>Presentation:</dt>
<dd style="margin-left: 8">A set of one or more streams presented to the client as a complete media feed and described by a presentation description as defined below. Presentations with more than one media stream are often handled in RTSP under aggregate control.</dd>
<dt>Presentation description:</dt>
<dd style="margin-left: 8">A presentation description contains information about one or more media streams within a presentation, such as the set of encodings, network addresses and information about the content. Other IETF protocols such as SDP (<a href="#RFC4566">[RFC4566]</a>) use the term "session" for a presentation. The presentation description may take several different formats, including but not limited to the session description protocol format, SDP.</dd>
<dt>Response:</dt>
<dd style="margin-left: 8">An RTSP response to a Request. One type of RTSP message. If an HTTP response is meant, it is indicated explicitly.</dd>
<dt>Request:</dt>
<dd style="margin-left: 8">An RTSP request. One type of RTSP message.  If an HTTP request is meant, it is indicated explicitly.</dd>
<dt>Request-URI:</dt>
<dd style="margin-left: 8">The URI used in a request to indicate the resource on which the request is to be performed.</dd>
<dt>RTSP agent:</dt>
<dd style="margin-left: 8">Refers to either an RTSP client, an RTSP server, or an RTSP proxy. In this specification, there are many capabilities that are common to these three entities such as the capability to send requests or receive responses. This term will be used when describing functionality that is applicable to all three of these entities.</dd>
<dt>RTSP session:</dt>
<dd style="margin-left: 8">A stateful abstraction upon which the main control methods of RTSP operate. An RTSP session is a common context; it is created, maintained and destroyed on client's request. It is established by an RTSP server upon the completion of a successful SETUP request (when a 200 OK response is sent) and is labeled with a session identifier at that time. The session exists until timed out by the server or explicitly removed by a TEARDOWN request. An RTSP session is a stateful entity; an RTSP server maintains an explicit session state machine (see <a href="#sec_machine">Appendix Appendix B</a>) where most state transitions are triggered by client requests. The existence of a session implies the existence of state about the session's media streams and their respective transport mechanisms. A given session can have one or more media streams associated with it. An RTSP server uses the session to aggregate control over multiple media streams.</dd>
<dt>Origin Server:</dt>
<dd style="margin-left: 8">The server on which a given resource resides.</dd>
<dt>Transport initialization:</dt>
<dd style="margin-left: 8">The negotiation of transport information (e.g., port numbers, transport protocols) between the client and the server.</dd>
<dt>URI:</dt>
<dd style="margin-left: 8">Universal Resource Identifier, see <a href="#RFC3986">[RFC3986]</a>. The URIs used in RTSP are generally URLs as they give a location for the resource. As URLs are a subset of URIs, they will be referred to as URIs to cover also the cases when an RTSP URI would not be an URL.</dd>
<dt>URL:</dt>
<dd style="margin-left: 8">Universal Resource Locator, is an URI which identifies the resource through its primary access mechanism, rather than identifying the resource by name or by some other attribute(s) of that resource.</dd>
</dl>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sec_parameters" id="sec_parameters">Protocol Parameters</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> RTSP Version</h1>
<p id="rfc.section.4.1.p.1">This specification defines version 2.0 of RTSP.</p>
<p id="rfc.section.4.1.p.2">RTSP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol. The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further RTSP communication, rather than the features obtained via that communication. No change is made to the version number for the addition of message components which do not affect communication behavior or which only add to extensible field values.</p>
<p id="rfc.section.4.1.p.3">The &lt;minor&gt; number is incremented when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may add to the message semantics and imply additional capabilities of the sender. The &lt;major&gt; number is incremented when the format of a message within the protocol is changed. The version of an RTSP message is indicated by an RTSP-Version field in the first line of the message. Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit. Thus, RTSP/2.4 is a lower version than RTSP/2.13, which in turn is lower than RTSP/12.3.  Leading zeros MUST be ignored by recipients and MUST NOT be sent.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#sec_url" id="sec_url">RTSP IRI and URI</a>
</h1>
<p id="rfc.section.4.2.p.1">RTSP 2.0 defines and registers three URI schemes "rtsp", "rtsps" and "rtspu". The usage of the last, "rtspu", is unspecified in RTSP 2.0, and is defined here to register and reserve the URI scheme that is defined in RTSP 1.0. The "rtspu" scheme indicates unspecified transport of the RTSP messages over unreliable transport (UDP in RTSP 1.0). A RTSP server MUST response with an error code indicating the "rtspu" scheme is not implemented (501) to a request that carries a "rtspu" URI scheme. The details of the syntax of "rtsp" and "rtsps" URIs has been changed from RTSP 1.0.</p>
<p id="rfc.section.4.2.p.2">This specification also defines the format of the RTSP IRI <a href="#RFC3987">[RFC3987]</a> that can be used as RTSP resource identifiers and locators, in web pages, user interfaces, on paper, etc. However, the RTSP request message format only allows usage of the absolute URI format. The RTSP IRI format MUST use the rules and transformation for IRIs defined in <a href="#RFC3987">[RFC3987]</a>. This way RTSP 2.0 URIs for request can be produced from an RTSP IRI.</p>
<p id="rfc.section.4.2.p.3">The RTSP IRI and URI are both syntax restricted compared to the generic syntax defined in <a href="#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a>: <a href="#RFC3986">[RFC3986]</a> and <a href="#RFC3987">[RFC3987]</a> defines as case-insensitive; for example, the scheme and host part.</p>

<ul>
<li>An absolute URI requires the authority part; i.e., a host identity must be provided.</li>
<li>Parameters in the path element are prefixed with the reserved separator ";".</li>
</ul>

<p> The RTSP URI and IRI is case sensitive, with the exception of those parts that </p>
<p id="rfc.section.4.2.p.4">The fragment identifier is used as defined in sections 3.5 and 4.3 of <a href="#RFC3986">[RFC3986]</a>, i.e. the fragment is to be stripped from the IRI by the requester and not included in the request URI. The user agent needs to interpret the value of the fragment based on the media type the request relates to; i.e., the media type indicated in Content-Type header in the response to DESCRIBE.</p>
<p id="rfc.section.4.2.p.5">The syntax of any URI query string is unspecified and responder (usually the server) specific. The query is, from the requester's perspective, an opaque string and needs to be handled as such. Please note that relative URI with queries are difficult to handle due to the RFC 3986 relative URI handling rules. Any change of the path element using a relative URI results in the stripping of the query, which means the relative part needs to contain the query.</p>
<p id="rfc.section.4.2.p.6">The URI scheme "rtsp" requires that commands are issued via a reliable protocol (within the Internet, TCP), while the scheme "rtsps" identifies a reliable transport using secure transport (TLS <a href="#RFC5246">[RFC5246]</a>, see (<a href="#sec_security-framework">Section 19</a>).</p>
<p id="rfc.section.4.2.p.7">For the scheme "rtsp", if no port number is provided in the authority part of the URI port number 554 MUST be used. For the scheme "rtsps", the TCP port 322 is registered and MUST be assumed.</p>
<p id="rfc.section.4.2.p.8">A presentation or a stream is identified by a textual media identifier, using the character set and escape conventions of URIs <a href="#RFC3986">[RFC3986]</a>. URIs may refer to a stream or an aggregate of streams; i.e., a presentation. Accordingly, requests described in (<a href="#sec_methods">Section 13</a>) can apply to either the whole presentation or an individual stream within the presentation. Note that some request methods can only be applied to streams, not presentations, and vice versa.</p>
<p id="rfc.section.4.2.p.9">For example, the RTSP URI: </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">rtsp://media.example.com:554/twister/audiotrack</dd>
</dl>

<p> may identify the audio stream within the presentation "twister", which can be controlled via RTSP requests issued over a TCP connection to port 554 of host media.example.com.</p>
<p id="rfc.section.4.2.p.10">Also, the RTSP URI: </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">rtsp://media.example.com:554/twister</dd>
</dl>

<p> identifies the presentation "twister", which may be composed of audio and video streams, but could also be something else like a random media redirector.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">This does not imply a standard way to reference streams in URIs. The presentation description defines the hierarchical relationships in the presentation and the URIs for the individual streams. A presentation description may name a stream "a.mov" and the whole presentation "b.mov".</dd>
</dl>
<p id="rfc.section.4.2.p.12">The path components of the RTSP URI are opaque to the client and do not imply any particular file system structure for the server.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">This decoupling also allows presentation descriptions to be used with non-RTSP media control protocols simply by replacing the scheme in the URI.</dd>
</dl>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#sec_session-id" id="sec_session-id">Session Identifiers</a>
</h1>
<p id="rfc.section.4.3.p.1">Session identifiers are strings of length 8-128 characters. A session identifier MUST be chosen cryptographically random (see <a href="#RFC4086">[RFC4086]</a>) . It is RECOMMENDED that it contains 128 bits of entropy, i.e. approximately 22 characters from a high quality generator. (see <a href="#sec_security">Section 21</a>.) However, note that the session identifier does not provide any security against session hijacking unless it is kept confidential by the client, server and trusted proxies.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#sec_smpte" id="sec_smpte">SMPTE Relative Timestamps</a>
</h1>
<p id="rfc.section.4.4.p.1">A SMPTE relative timestamp expresses time relative to the start of the clip. Relative timestamps are expressed as SMPTE time codes for frame-level access accuracy. The time code has the format </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">hours:minutes:seconds:frames.subframes,</dd>
</dl>

<p> with the origin at the start of the clip. The default SMPTE format is "SMPTE 30 drop" format, with frame rate is 29.97 frames per second. Other SMPTE codes MAY be supported (such as "SMPTE 25") through the use of "smpte-type". For SMPTE 30, the "frames" field in the time value can assume the values 0 through 29. The difference between 30 and 29.97 frames per second is handled by dropping the first two frame indices (values 00 and 01) of every minute, except every tenth minute. If the frame and the subframe values are zero, they may be omitted. Subframes are measured in one-hundredth of a frame.</p>
<div id="#rfc.figure.1"></div>
<pre>
  smpte=10:12:33:20-
  smpte=10:07:33-
  smpte=10:07:00-10:07:33:05.01
  smpte-25=10:07:00-10:07:33:05.01
</pre>
<p id="rfc.section.4.4.p.2">Examples: </p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#sec_npt" id="sec_npt">Normal Play Time</a>
</h1>
<p id="rfc.section.4.5.p.1">Normal play time (NPT) indicates the stream absolute position relative to the beginning of the presentation, not to be confused with the Network Time Protocol (NTP) <a href="#RFC5905">[RFC5905]</a>. The timestamp consists of two parts: the mandatory first part may be expressed in either seconds or hours, minutes, and seconds. The optional second part consists of a decimal point and decimal figures and indicates fractions of a second.</p>
<p id="rfc.section.4.5.p.2">The beginning of a presentation corresponds to 0.0 seconds.  Negative values are not defined.</p>
<p id="rfc.section.4.5.p.3">The special constant "now" is defined as the current instant of a live event. It MAY only be used for live events, and MUST NOT be used for on-demand (i.e., non-live) content.</p>
<p id="rfc.section.4.5.p.4">NPT is defined as in DSM-CC <a href="#ISO.13818-6.1995">[ISO.13818-6.1995]</a>: "Intuitively, NPT is the clock the viewer associates with a program. It is often digitally displayed on a VCR. NPT advances normally when in normal play mode (scale = 1), advances at a faster rate when in fast scan forward (high positive scale ratio), decrements when in scan reverse (negative scale ratio) and is fixed in pause mode. NPT is (logically) equivalent to SMPTE time codes."</p>
<div id="#rfc.figure.2"></div>
<pre>
  npt=123.45-125
  npt=12:05:35.3-
  npt=now-
</pre>
<p id="rfc.section.4.5.p.5">Examples: </p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The syntax conforms to ISO 8601 <a href="#ISO.8601.2000">[ISO.8601.2000]</a>. The npt-sec notation is optimized for automatic generation, the npt-hhmmss notation for consumption by human readers. The "now" constant allows clients to request to receive the live feed rather than the stored or time-delayed version. This is needed since neither absolute time nor zero time are appropriate for this case.</dd>
</dl>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#sec_clock" id="sec_clock">Absolute Time</a>
</h1>
<p id="rfc.section.4.6.p.1">Absolute time is expressed as ISO 8601 <a href="#ISO.8601.2000">[ISO.8601.2000]</a> timestamps, using UTC (GMT). Fractions of a second may be indicated.</p>
<div id="#rfc.figure.3"></div>
<pre>
  19961108T143720.25Z
</pre>
<p id="rfc.section.4.6.p.2">Example for November 8, 1996 at 14h 37 min and 20 and a quarter seconds UTC: </p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> <a href="#sec_feature_tags" id="sec_feature_tags">Feature-Tags</a>
</h1>
<p id="rfc.section.4.7.p.1">Feature-tags are unique identifiers used to designate features in RTSP. These tags are used in Require (<a href="#sec_Require">Section 16.41</a>), Proxy-Require (<a href="#sec_Proxy-Require">Section 16.35</a>), Proxy-Supported (<a href="#sec_Proxy-Supported">Section 16.36</a>), and Unsupported (<a href="#sec_Unsupported">Section 16.53</a>) header fields.</p>
<p id="rfc.section.4.7.p.2">A feature-tag definition MUST indicate which combination of clients, servers or proxies they applies to.</p>
<p id="rfc.section.4.7.p.3">The creator of a new RTSP feature-tag should either prefix the feature-tag with a reverse domain name (e.g., "com.example.mynewfeature" is an apt name for a feature whose inventor can be reached at "example.com"), or register the new feature-tag with the Internet Assigned Numbers Authority (IANA) (see IANA <a href="#sec_IANA">Section 22</a>).</p>
<p id="rfc.section.4.7.p.4">The usage of feature-tags is further described in <a href="#sec_capability">Section 11</a> that deals with capability handling.</p>
<h1 id="rfc.section.4.8">
<a href="#rfc.section.4.8">4.8.</a> <a href="#sec_message-tags" id="sec_message-tags">Message Body Tags</a>
</h1>
<p id="rfc.section.4.8.p.1">Message body tags are opaque strings that are used to compare two message bodies from the same resource, for example in caches or to optimize setup after a redirect. Message body tags can be carried in the MTag header (see <a href="#sec_MTag">Section 16.30</a>) or in SDP (see <a href="#sec_sdp-mtag">Appendix Appendix D.1.9</a>). MTag is similar to ETag in HTTP/1.1.</p>
<p id="rfc.section.4.8.p.2">A message body tag MUST be unique across all versions of all message bodies associated with a particular resource. A given message body tag value MAY be used for message bodies obtained by requests on different URIs. The use of the same message body tag value in conjunction with message bodies obtained by requests on different URIs does not imply the equivalence of those message bodies</p>
<p id="rfc.section.4.8.p.3">Message body tags are used in RTSP to make some methods conditional. The methods are made conditional through the inclusion of headers; see "<a href="#sec_If-Match">If-Match"</a> <cite title="NONE">[sec_If-Match]</cite> and "<a href="#sec_If-None-Match">If-None-Match"</a> <cite title="NONE">[sec_If-None-Match]</cite>. Note that RTSP message body tags apply to the complete presentation; i.e., both the presentation description and the individual media streams. Thus message body tags can be used to verify at setup time after a redirect that the same session description applies to the media at the new location using the If-Match header.</p>
<h1 id="rfc.section.4.9">
<a href="#rfc.section.4.9">4.9.</a> <a href="#sec_Media-Properties-Intro" id="sec_Media-Properties-Intro">Media Properties</a>
</h1>
<p id="rfc.section.4.9.p.1">When an RTSP server handles media, it is important to consider the different properties a media instance for delivery and playback can have. This specification considers the below listed media properties in its protocol operations. They are derived from the differences between a number of supported usages. </p>

<dl>
<dt>On-demand:</dt>
<dd style="margin-left: 8">Media that has a fixed (given) duration that doesn't change during the life time of the RTSP session and is known at the time of the creation of the session. It is expected that the content of the media will not change, even if the representation, i.e encoding, quality, etc, may change.  Generally one can seek, i.e. request any range, within the media.</dd>
<dt>Dynamic On-demand:</dt>
<dd style="margin-left: 8">This is a variation of the on-demand case where external methods are used to manipulate the actual content of the media setup for the RTSP session. The main example is a content defined by a playlist.</dd>
<dt>Live:</dt>
<dd style="margin-left: 8">Live media represents a progressing content stream (such as broadcast TV) where the duration may or may not be known. It is not seekable, only the content presently being delivered can be accessed.</dd>
<dt>Live with Recording:</dt>
<dd style="margin-left: 8">A Live stream that is combined with a server-side capability to store and retain the content of the live session, and allow for random access delivery within the part of the already recorded content. The actual behavior of the media stream is very much dependent on the retention policy for the media stream; either the server will be able to capture the complete media stream, or it will have a limitation in how much will be retained. The media range will dynamically change as the session progress. For servers with a limited amount of storage available for recording, there will typically be a sliding window that moves forwards while new data is made available and older data is discarded.</dd>
</dl>
<p id="rfc.section.4.9.p.2">To cover the above usages, the following media properties with appropriate values are specified:</p>
<h1 id="rfc.section.4.9.1">
<a href="#rfc.section.4.9.1">4.9.1.</a> <a href="#sec_random_access_seek" id="sec_random_access_seek">Random Access and Seeking</a>
</h1>
<p id="rfc.section.4.9.1.p.1">Random Access is the ability to specify and get media delivered from any point inside the content, an operation called seeking. This possibility is signaled using the Seek-Style header (see Section <a href="#sec_Seek-Style">Section 16.45</a>) which can take the following different values:</p>
<p></p>

<dl>
<dt>Random Access:</dt>
<dd style="margin-left: 8">The media are seekable to any out of a large number of points within the media. Due to media encoding limitations, a particular point may not be reachable, but seeking to a point close by is enabled. A floating point number of seconds may be provided to express the worst case distance between random access points.</dd>
<dt>Conditional Random Access:</dt>
<dd style="margin-left: 8">Based on the above Random Access but intended to handle a case where the distance in the media between random access points are large, and where small seek forward using Random Access would move the client further away then the current point.</dd>
<dt>Return To Start:</dt>
<dd style="margin-left: 8">Seeking is only possible to the beginning of the content.</dd>
<dt>No seeking:</dt>
<dd style="margin-left: 8">Seeking is not possible at all.</dd>
</dl>
<h1 id="rfc.section.4.9.2">
<a href="#rfc.section.4.9.2">4.9.2.</a> Retention</h1>
<p id="rfc.section.4.9.2.p.1">Media may have different retention policies in place that affect the operation on media. The following different media retention policies are envisioned and taken into consideration where applicable:</p>
<p></p>

<dl>
<dt>Unlimited:</dt>
<dd style="margin-left: 8">The media will not be removed as long as the RTSP session is in existence.</dd>
<dt>Time Limited:</dt>
<dd style="margin-left: 8">The media will not be removed before given wallclock time. After that time it may or may not be available any more.</dd>
<dt>Duration limited:</dt>
<dd style="margin-left: 8">Each individual unit of the media will be retained for the specified duration.</dd>
</dl>
<p></p>
<h1 id="rfc.section.4.9.3">
<a href="#rfc.section.4.9.3">4.9.3.</a> Content Modifications</h1>
<p id="rfc.section.4.9.3.p.1">There is also the question of how the content may change during time for a give media resource:</p>
<p></p>

<dl>
<dt>Immutable:</dt>
<dd style="margin-left: 8">The content of the media will not change, even if the representation, i.e., encoding, quality, etc., may change.</dd>
<dt>Dynamic:</dt>
<dd style="margin-left: 8">Between explicit updates the media content will not change, but the content may change due to external methods or triggers, such as playlists.</dd>
<dt>Time Progressing:</dt>
<dd style="margin-left: 8">As times progresses new content will become available. If the content also is retained it will become longer as everything between the start point and the point currently being made available can be accessed. If the media server uses a sliding window policy for retention, the start point will also change as time progresses.</dd>
</dl>
<p></p>
<h1 id="rfc.section.4.9.4">
<a href="#rfc.section.4.9.4">4.9.4.</a> Supported Scale Factors</h1>
<p id="rfc.section.4.9.4.p.1">Content often supports only a limited set or range of scales when delivering the media.. To enable the client to know what values or ranges of scale operations that the whole content or the current position supports, a media properties attribute for this is defined which contains a list with the values and/or ranges that are supported. The attribute is named "Scales". It may be updated at any point in the content due to content consisting of spliced pieces or content being dynamically updated by out-of-band mechanisms.</p>
<h1 id="rfc.section.4.9.5">
<a href="#rfc.section.4.9.5">4.9.5.</a> Mapping to the Attributes</h1>
<p id="rfc.section.4.9.5.p.1">This section shows examples of how one would map the above usages to the properties and their values.</p>
<p></p>

<dl>
<dt>On-demand:</dt>
<dd style="margin-left: 8">Random Access: Random Access=5s, Content Modifications: Immutable, Retention: unlimited or time limited.</dd>
<dt>Dynamic On-demand:</dt>
<dd style="margin-left: 8">Random Access: Random Access=3s, Content Modifications: Dynamic, Retention: unlimited or time limited.</dd>
<dt>Live:</dt>
<dd style="margin-left: 8">Random Access: No seeking, Content Modifications: Time Progressing, Retention: Duration limited=0.0s</dd>
<dt>Live with Recording:</dt>
<dd style="margin-left: 8">Random Access: Random Access=3s, Content Modifications: Time Progressing, Retention: Duration limited=2H</dd>
</dl>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sec_message" id="sec_message">RTSP Message</a>
</h1>
<p id="rfc.section.5.p.1">RTSP is a text-based protocol and uses the ISO 10646 character set in UTF-8 encoding RFC 3629 <a href="#RFC3629">[RFC3629]</a>. Lines MUST be terminated by CRLF.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Text-based protocols make it easier to add optional parameters in a self-describing manner. Since the number of parameters and the frequency of commands is low, processing efficiency is not a concern. Text-based protocols, if done carefully, also allow easy implementation of research prototypes in scripting languages such as TCL, Visual Basic and Perl.</dd>
</dl>
<p id="rfc.section.5.p.3">The ISO 10646 character set avoids tricky character set switching, but is invisible to the application as long as US-ASCII is being used.  This is also the encoding used for <a href="#RFC3550">RTCP</a> <cite title="NONE">[RFC3550]</cite>.</p>
<p id="rfc.section.5.p.4">Requests contain methods, the object the method is operating upon and parameters to further describe the method. Methods are idempotent unless otherwise noted. Methods are also designed to require little or no state maintenance at the media server.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec_message-types" id="sec_message-types">Message Types</a>
</h1>
<p id="rfc.section.5.1.p.1">RTSP messages consist of requests from client to server, or server to client, and responses in the reverse direction. Request <a href="#sec_request">Section 7</a> and Response <a href="#sec_response">Section 8</a> messages use a format based on the generic message format of RFC 2822 <a href="#RFC2822">[RFC2822]</a> for transferring bodies (the payload of the message). Both types of message consist of a start-line, zero or more header fields (also known as "headers"), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header, and possibly the data of the message-body.</p>
<div id="#rfc.figure.4"></div>
<pre>generic-message = start-line 
                *(message-header CRLF) 
                  CRLF 
                [ message-body-data ] 
start-line = Request-Line | Status-Line
 </pre>
<p></p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#sec_message-headers" id="sec_message-headers">Message Headers</a>
</h1>
<p id="rfc.section.5.2.p.1">RTSP header fields (see <a href="#sec_headers">Section 16</a>) include general-header, request-header, response-header, and Message-body header fields.</p>
<p id="rfc.section.5.2.p.2">The order in which header fields with differing field names are received is not significant. However, it is "good practice" to send general-header fields first, followed by request-header or response- header fields, and ending with the Message-body header fields.</p>
<p id="rfc.section.5.2.p.3">Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list. It MUST be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.</p>
<p id="rfc.section.5.2.p.4">Unknown message headers MUST be ignored (skipping over the header to the next protocol element, and not causing an error) by a RTSP server or client. An RTSP Proxy MUST forward unknown message headers.  Message headers defined outside of this specification that are required to be interpreted by the RTSP agent will need to use <a href="#sec_feature_tags">feature tags</a> <cite title="NONE">[sec_feature_tags]</cite> and include them in the appropriate <a href="#sec_Require">Require</a> <cite title="NONE">[sec_Require]</cite> or <a href="#sec_Proxy-Require">Proxy-Require</a> <cite title="NONE">[sec_Proxy-Require]</cite> header.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#sec_message-body" id="sec_message-body">Message Body</a>
</h1>
<p id="rfc.section.5.3.p.1">The message-body (if any) of an RTSP message is used to carry further information for a particular resource associated with the request or response. An example of a message body is the Session Description Protocol (SDP).</p>
<p id="rfc.section.5.3.p.2">The presence of a message-body in either a request or a response MUST be signaled by the inclusion of a Content-Length header (see <a href="#sec_Content-Length">Section 16.16</a>).</p>
<p id="rfc.section.5.3.p.3">The presence of a message-body in a request is signaled by the inclusion of a Content-Length header field in the RTSP message. A message-body MUST NOT be included in a request or response if the specification of the particular method (see <a href="#sec_methods">Method Definitions</a> <cite title="NONE">[sec_methods]</cite>) does not allow sending a message body.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> Message Length</h1>
<p id="rfc.section.5.4.p.1">When a message body is included with a message, the length of that body is determined by one of the following (in order of precedence): </p>

<ol>
<li>Any response message which MUST NOT include a message body (such as the 1xx, 204, and 304 responses) is always terminated by the first empty line after the header fields, regardless of the message-header fields present in the message. (Note: An empty line is a line with nothing preceding the CRLF.)</li>
<li>If a Content-Length header(<a href="#sec_Content-Length">Section 16.16</a>) is present, its value in bytes represents the length of the message-body. If this header field is not present, a value of zero is assumed.</li>
</ol>

<p> Unlike an HTTP message, an RTSP message MUST contain a Content-Length header whenever it contains a message body. Note that RTSP does not support the HTTP/1.1 "chunked" transfer coding (see [H3.6.1]).</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Given the moderate length of presentation descriptions returned, the server should always be able to determine its length, even if it is generated dynamically, making the chunked transfer encoding unnecessary.</dd>
</dl>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec_general-header" id="sec_general-header">General Header Fields</a>
</h1>
<p id="rfc.section.6.p.1">General headers are headers that may be used in both requests and responses. The general headers are listed in <a href="#tab_headers-general">Table 1</a>:</p>
<div id="#rfc.table.1"></div>
<div id="#tab_headers-general"></div>
<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>The general headers used in RTSP</caption>
<thead><tr>
<th class="left">Header Name</th>
<th class="left">Defined in Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Accept-Ranges</td>
<td class="left"><a href="#sec_Accept-Ranges">Section 16.5</a></td>
</tr>
<tr>
<td class="left">Cache-Control</td>
<td class="left"><a href="#sec_Cache-Control">Section 16.10</a></td>
</tr>
<tr>
<td class="left">Connection</td>
<td class="left"><a href="#sec_Connection">Section 16.11</a></td>
</tr>
<tr>
<td class="left">CSeq</td>
<td class="left"><a href="#sec_CSeq">Section 16.19</a></td>
</tr>
<tr>
<td class="left">Date</td>
<td class="left"><a href="#sec_Date">Section 16.20</a></td>
</tr>
<tr>
<td class="left">Media-Properties</td>
<td class="left"><a href="#sec_Media-Properties">Section 16.28</a></td>
</tr>
<tr>
<td class="left">Media-Range</td>
<td class="left"><a href="#sec_Media-Range">Section 16.29</a></td>
</tr>
<tr>
<td class="left">Pipelined-Requests</td>
<td class="left"><a href="#sec_Pipelined-Requests">Section 16.32</a></td>
</tr>
<tr>
<td class="left">Proxy-Supported</td>
<td class="left"><a href="#sec_Proxy-Supported">Section 16.36</a></td>
</tr>
<tr>
<td class="left">RTP-Info</td>
<td class="left"><a href="#sec_RTP-Info">Section 16.43</a></td>
</tr>
<tr>
<td class="left">Seek-Style</td>
<td class="left"><a href="#sec_Seek-Style">Section 16.45</a></td>
</tr>
<tr>
<td class="left">Supported</td>
<td class="left"><a href="#sec_Supported">Section 16.49</a></td>
</tr>
<tr>
<td class="left">Timestamp</td>
<td class="left"><a href="#sec_Timestamp">Section 16.51</a></td>
</tr>
<tr>
<td class="left">Via</td>
<td class="left"><a href="#sec_Via">Section 16.56</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sec_request" id="sec_request">Request</a>
</h1>
<p id="rfc.section.7.p.1">A request message uses the format outlined below regardless of the direction of a request, client to server or server to client: </p>

<ul>
<li>Request line, containing the method to be applied to the resource, the identifier of the resource, and the protocol version in use;</li>
<li>Zero or more Header lines, that can be of the following types: general (<a href="#sec_general-header">Section 6</a>), request (<a href="#sec_request-header">Section 7.2</a>), or message body(<a href="#sec_message-header">Section 9.1</a>);</li>
<li>One empty line (CRLF) to indicate the end of the header section;</li>
<li>Optionally a message-body, consisting of one or more lines. The length of the message body in bytes is indicated by the Content-Length message header.</li>
</ul>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#sec_request-line" id="sec_request-line">Request Line</a>
</h1>
<div id="#rfc.table.2"></div>
<div id="#tab_request-methods"></div>
<p id="rfc.section.7.1.p.1">The request line provides the key information about the request: what method, on what resources and using which RTSP version. The methods that are defined by this specification are listed in <a href="#tab_request-methods">Table 2</a>. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>The RTSP Methods</caption>
<thead><tr>
<th class="left">Method</th>
<th class="left">Defined in Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DESCRIBE</td>
<td class="left">
<a href="#sec_DESCRIBE">Section 13.2</a> </td>
</tr>
<tr>
<td class="left">GET_PARAMETER</td>
<td class="left">
<a href="#sec_GET_PARAMETER">Section 13.8</a> </td>
</tr>
<tr>
<td class="left">OPTIONS</td>
<td class="left">
<a href="#sec_OPTIONS">Section 13.1</a> </td>
</tr>
<tr>
<td class="left">PAUSE</td>
<td class="left">
<a href="#sec_PAUSE">Section 13.6</a> </td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">
<a href="#sec_PLAY">Section 13.4</a> </td>
</tr>
<tr>
<td class="left">PLAY_NOTIFY</td>
<td class="left">
<a href="#sec_PLAY_NOTIFY">Section 13.5</a> </td>
</tr>
<tr>
<td class="left">REDIRECT</td>
<td class="left">
<a href="#sec_REDIRECT">Section 13.10</a> </td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">
<a href="#sec_SETUP">Section 13.3</a> </td>
</tr>
<tr>
<td class="left">SET_PARAMETER</td>
<td class="left">
<a href="#sec_SET_PARAMETER">Section 13.9</a> </td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">
<a href="#sec_TEARDOWN">Section 13.7</a> </td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.1.p.2">The syntax of the RTSP request line is the following: </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">&lt;Method&gt; &lt;Request-URI&gt; &lt;RTSP-Version&gt; CRLF</dd>
</dl>

<p> Note: This syntax cannot be freely changed in future versions of RTSP. This line needs to remain parsable by older RTSP implementations since it indicates the RTSP version of the message.</p>
<p id="rfc.section.7.1.p.3">In contrast to HTTP/1.1 <a href="#RFC2616">[RFC2616]</a>, RTSP requests identify the resource through an absolute RTSP URI (including scheme, host, and port) (see <a href="#sec_url">Section 4.2</a>) rather than just the absolute path.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">HTTP/1.1 requires servers to understand the absolute URI, but clients are supposed to use the Host request header. This is purely needed for backward-compatibility with HTTP/1.0 servers, a consideration that does not apply to RTSP.</dd>
</dl>
<p id="rfc.section.7.1.p.5">An asterisk "*" can be used instead of an absolute URI in the Request-URI part to indicate that the request does not apply to a particular resource, but to the server or proxy itself, and is only allowed when the request method does not necessarily apply to a resource.</p>
<p id="rfc.section.7.1.p.6">For example: </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">OPTIONS * RTSP/2.0</dd>
</dl>
<p id="rfc.section.7.1.p.7">An OPTIONS in this form will determine the capabilities of the server or the proxy that first receives the request. If the capability of the specific server needs to be determined, without regard to the capability of an intervening proxy, the server should be addressed explicitly with an absolute URI that contains the server's address.</p>
<p id="rfc.section.7.1.p.8">For example: </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">OPTIONS rtsp://example.com RTSP/2.0</dd>
</dl>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#sec_request-header" id="sec_request-header">Request Header Fields</a>
</h1>
<div id="#rfc.table.3"></div>
<div id="#tab_request-header"></div>
<p id="rfc.section.7.2.p.1">The RTSP headers in <a href="#tab_request-header">Table 3</a> can be included in a request, as request headers, to modify the specifics of the request. Some of these headers may also be used in the response to a request, as response headers, to modify the specifics of a response (<a href="#sec_response-header">Section 8.2</a>). </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>The RTSP request headers</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Defined in Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Accept</td>
<td class="left">
<a href="#sec_Accept">Section 16.1</a> </td>
</tr>
<tr>
<td class="left">Accept-Credentials</td>
<td class="left">
<a href="#sec_Accept-Credentials">Section 16.2</a> </td>
</tr>
<tr>
<td class="left">Accept-Encoding</td>
<td class="left">
<a href="#sec_Accept-Encoding">Section 16.3</a> </td>
</tr>
<tr>
<td class="left">Accept-Language</td>
<td class="left">
<a href="#sec_Accept-Language">Section 16.4</a> </td>
</tr>
<tr>
<td class="left">Authorization</td>
<td class="left">
<a href="#sec_Authorization">Section 16.7</a> </td>
</tr>
<tr>
<td class="left">Bandwidth</td>
<td class="left">
<a href="#sec_Bandwidth">Section 16.8</a> </td>
</tr>
<tr>
<td class="left">Blocksize</td>
<td class="left">
<a href="#sec_Blocksize">Section 16.9</a> </td>
</tr>
<tr>
<td class="left">From</td>
<td class="left">
<a href="#sec_From">Section 16.22</a> </td>
</tr>
<tr>
<td class="left">If-Match</td>
<td class="left">
<a href="#sec_If-Match">Section 16.23</a> </td>
</tr>
<tr>
<td class="left">If-Modified-Since</td>
<td class="left">
<a href="#sec_If-Modified-Since">Section 16.24</a> </td>
</tr>
<tr>
<td class="left">If-None-Match</td>
<td class="left">
<a href="#sec_If-None-Match">Section 16.25</a> </td>
</tr>
<tr>
<td class="left">Notify-Reason</td>
<td class="left">
<a href="#sec_Notify-Reason">Section 16.31</a> </td>
</tr>
<tr>
<td class="left">Proxy-Require</td>
<td class="left">
<a href="#sec_Proxy-Require">Section 16.35</a> </td>
</tr>
<tr>
<td class="left">Range</td>
<td class="left">
<a href="#sec_Range">Section 16.38</a> </td>
</tr>
<tr>
<td class="left">Terminate-Reason</td>
<td class="left">
<a href="#sec_Terminate-Reason">Section 16.50</a> </td>
</tr>
<tr>
<td class="left">Referrer</td>
<td class="left">
<a href="#sec_Referrer">Section 16.39</a> </td>
</tr>
<tr>
<td class="left">Request-Status</td>
<td class="left">
<a href="#sec_Request-Status">Section 16.40</a> </td>
</tr>
<tr>
<td class="left">Require</td>
<td class="left">
<a href="#sec_Require">Section 16.41</a> </td>
</tr>
<tr>
<td class="left">Scale</td>
<td class="left">
<a href="#sec_Scale">Section 16.44</a> </td>
</tr>
<tr>
<td class="left">Session</td>
<td class="left">
<a href="#sec_Session">Section 16.47</a> </td>
</tr>
<tr>
<td class="left">Speed</td>
<td class="left">
<a href="#sec_Speed">Section 16.48</a> </td>
</tr>
<tr>
<td class="left">Supported</td>
<td class="left">
<a href="#sec_Supported">Section 16.49</a> </td>
</tr>
<tr>
<td class="left">Transport</td>
<td class="left">
<a href="#sec_Transport">Section 16.52</a> </td>
</tr>
<tr>
<td class="left">User-Agent</td>
<td class="left">
<a href="#sec_User-Agent">Section 16.54</a> </td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.2.p.2">New request headers may be defined. If the receiver of the request is required to understand the request header, the request MUST include a corresponding feature tag in a Require or Proxy-Require header to ensure the processing of the header.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#sec_response" id="sec_response">Response</a>
</h1>
<p id="rfc.section.8.p.1">After receiving and interpreting a request message, the recipient responds with an RTSP response message. Normally, there is only one, final, response. Only responses using the response code class 1xx, that it is allowed to send one or more 1xx response messages prior to the final response message.</p>
<p id="rfc.section.8.p.2">The valid response codes and the methods they can be used with are listed in <a href="#tab_status">Table 4</a>.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#sec_status-line" id="sec_status-line">Status-Line</a>
</h1>
<p id="rfc.section.8.1.p.1">The first line of a Response message is the Status-Line, consisting of the protocol version followed by a numeric status code and the textual phrase associated with the status code, with each element separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.</p>
<p id="rfc.section.8.1.p.2">&lt;RTSP-Version&gt; SP &lt;Status-Code&gt; SP &lt;Reason-Phrase&gt; CRLF</p>
<h1 id="rfc.section.8.1.1">
<a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#sec_status-code" id="sec_status-code">Status Code and Reason Phrase</a>
</h1>
<p id="rfc.section.8.1.1.p.1">The Status-Code element is a 3-digit integer result code of the attempt to understand and satisfy the request. These codes are fully defined in <a href="#sec_status">Section 15</a>. The Reason-Phrase is intended to give a short textual description of the Status-Code. The Status-Code is intended for use by automata and the Reason-Phrase is intended for the human user. The client is not required to examine or display the Reason-Phrase.</p>
<p id="rfc.section.8.1.1.p.2">The first digit of the Status-Code defines the class of response.  The last two digits do not have any categorization role. There are 5 values for the first digit: <a href="#tab_status">Table 4</a>. The reason phrases listed here are only recommended; they may be replaced by local equivalents without affecting the protocol. Note that RTSP adopts most HTTP/1.1 <a href="#RFC2616">[RFC2616]</a> status codes and adds RTSP-specific status codes starting at x50 to avoid conflicts with future HTTP status codes that are desirable to import into RTSP.</p>

<dl>
<dt>1xx:</dt>
<dd style="margin-left: 6">Informational - Request received, continuing process</dd>
<dt>2xx:</dt>
<dd style="margin-left: 6">Success - The action was successfully received, understood, and accepted</dd>
<dt>3rr:</dt>
<dd style="margin-left: 6">Redirection - Further action needs to be taken in order to complete the request</dd>
<dt>4xx:</dt>
<dd style="margin-left: 6">Client Error - The request contains bad syntax or cannot be fulfilled</dd>
<dt>5xx:</dt>
<dd style="margin-left: 6">Server Error - The server failed to fulfill an apparently valid request</dd>
</dl>

<p> The individual values of the numeric status codes defined for RTSP/2.0, and an example set of corresponding Reason-Phrases, are presented in </p>
<div id="#rfc.table.4"></div>
<div id="#tab_status"></div>
<p id="rfc.section.8.1.1.p.3">RTSP status codes are extensible. RTSP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response MUST NOT be cached. For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code. In such cases, user agents SHOULD present to the user the message body returned with the response, since that message body is likely to include human-readable information which will explain the unusual status. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Status codes and their usage with RTSP methods</caption>
<thead><tr>
<th class="left">Code</th>
<th class="left">Reason</th>
<th class="left">Method</th>
</tr></thead>
<tbody>
<tr>
<td class="left">100</td>
<td class="left">Continue</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
</tr>
<tr>
<td class="left">200</td>
<td class="left">OK</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
</tr>
<tr>
<td class="left">301</td>
<td class="left">Moved Permanently</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">302</td>
<td class="left">Found</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">304</td>
<td class="left">Not Modified</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">305</td>
<td class="left">Use Proxy</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
</tr>
<tr>
<td class="left">400</td>
<td class="left">Bad Request</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">401</td>
<td class="left">Unauthorized</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">402</td>
<td class="left">Payment Required</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">403</td>
<td class="left">Forbidden</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">404</td>
<td class="left">Not Found</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">405</td>
<td class="left">Method Not Allowed</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">406</td>
<td class="left">Not Acceptable</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">407</td>
<td class="left">Proxy Authentication Required</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">408</td>
<td class="left">Request Timeout</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">410</td>
<td class="left">Gone</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">411</td>
<td class="left">Length Required</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">412</td>
<td class="left">Precondition Failed</td>
<td class="left">DESCRIBE, SETUP</td>
</tr>
<tr>
<td class="left">413</td>
<td class="left">Request Message Body Too Large</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">414</td>
<td class="left">Request-URI Too Long</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">415</td>
<td class="left">Unsupported Media Type</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">451</td>
<td class="left">Parameter Not Understood</td>
<td class="left">SET_PARAMETER, GET_PARAMETER</td>
</tr>
<tr>
<td class="left">452</td>
<td class="left">reserved</td>
<td class="left">n/a</td>
</tr>
<tr>
<td class="left">453</td>
<td class="left">Not Enough Bandwidth</td>
<td class="left">SETUP</td>
</tr>
<tr>
<td class="left">454</td>
<td class="left">Session Not Found</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">455</td>
<td class="left">Method Not Valid In This State</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">456</td>
<td class="left">Header Field Not Valid</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">457</td>
<td class="left">Invalid Range</td>
<td class="left">PLAY, PAUSE</td>
</tr>
<tr>
<td class="left">458</td>
<td class="left">Parameter Is Read-Only</td>
<td class="left">SET_PARAMETER</td>
</tr>
<tr>
<td class="left">459</td>
<td class="left">Aggregate Operation Not Allowed</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">460</td>
<td class="left">Only Aggregate Operation Allowed</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">461</td>
<td class="left">Unsupported Transport</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">462</td>
<td class="left">Destination Unreachable</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">463</td>
<td class="left">Destination Prohibited</td>
<td class="left">SETUP</td>
</tr>
<tr>
<td class="left">464</td>
<td class="left">Data Transport Not Ready Yet</td>
<td class="left">PLAY</td>
</tr>
<tr>
<td class="left">465</td>
<td class="left">Notification Reason Unknown</td>
<td class="left">PLAY_NOTIFY</td>
</tr>
<tr>
<td class="left">470</td>
<td class="left">Connection Authorization Required</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">471</td>
<td class="left">Connection Credentials not accepted</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">472</td>
<td class="left">Failure to establish secure connection</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left"></td>
<td class="left"></td>
<td class="left"></td>
</tr>
<tr>
<td class="left">500</td>
<td class="left">Internal Server Error</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">501</td>
<td class="left">Not Implemented</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">502</td>
<td class="left">Bad Gateway</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">503</td>
<td class="left">Service Unavailable</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">504</td>
<td class="left">Gateway Timeout</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">505</td>
<td class="left">RTSP Version Not Supported</td>
<td class="left">all</td>
</tr>
<tr>
<td class="left">551</td>
<td class="left">Option Not Support</td>
<td class="left">all</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#sec_response-header" id="sec_response-header">Response Headers</a>
</h1>
<div id="#rfc.table.5"></div>
<div id="#tab_response-header"></div>
<p id="rfc.section.8.2.p.1">The response-header allows the request recipient to pass additional information about the response which cannot be placed in the Status-Line. This header give information about the server and about further access to the resource identified by the Request-URI. All headers currently classified as response headers are listed in <a href="#tab_response-header">Table 5</a>. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>The RTSP response headers</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Defined in Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Connection-Credentials</td>
<td class="left">
<a href="#sec_Connection-Credentials">Section 16.12</a> </td>
</tr>
<tr>
<td class="left">MTag</td>
<td class="left">
<a href="#sec_MTag">Section 16.30</a> </td>
</tr>
<tr>
<td class="left">Location</td>
<td class="left">
<a href="#sec_Location">Section 16.27</a> </td>
</tr>
<tr>
<td class="left">Proxy-Authenticate</td>
<td class="left">
<a href="#sec_Proxy-Authenticate">Section 16.33</a> </td>
</tr>
<tr>
<td class="left">Public</td>
<td class="left">
<a href="#sec_Public">Section 16.37</a> </td>
</tr>
<tr>
<td class="left">Range</td>
<td class="left">
<a href="#sec_Range">Section 16.38</a> </td>
</tr>
<tr>
<td class="left">Retry-After</td>
<td class="left">
<a href="#sec_Retry-After">Section 16.42</a> </td>
</tr>
<tr>
<td class="left">Scale</td>
<td class="left">
<a href="#sec_Scale">Section 16.44</a> </td>
</tr>
<tr>
<td class="left">Session</td>
<td class="left">
<a href="#sec_Session">Section 16.47</a> </td>
</tr>
<tr>
<td class="left">Server</td>
<td class="left">
<a href="#sec_Server">Section 16.46</a> </td>
</tr>
<tr>
<td class="left">Speed</td>
<td class="left">
<a href="#sec_Speed">Section 16.48</a> </td>
</tr>
<tr>
<td class="left">Transport</td>
<td class="left">
<a href="#sec_Transport">Section 16.52</a> </td>
</tr>
<tr>
<td class="left">Unsupported</td>
<td class="left">
<a href="#sec_Unsupported">Section 16.53</a> </td>
</tr>
<tr>
<td class="left">Vary</td>
<td class="left">
<a href="#sec_Vary">Section 16.55</a> </td>
</tr>
<tr>
<td class="left">WWW-Authenticate</td>
<td class="left">
<a href="#sec_WWW-Authenticate">Section 16.57</a> </td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#sec_entity" id="sec_entity">Message Body</a>
</h1>
<p id="rfc.section.9.p.1">Request and Response messages MAY transfer a message body, if not otherwise restricted by the request method or response status code. The message body consists of message-body header fields and the content data itself.</p>
<p id="rfc.section.9.p.2">The SET_PARAMETER and GET_PARAMETER request and response, and DESCRIBE response MAY have an message body. All 4xx and 5xx responses MAY also have an message body.</p>
<p id="rfc.section.9.p.3">In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives the message body.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#sec_message-header" id="sec_message-header">Message-Body Header Fields</a>
</h1>
<div id="#rfc.table.6"></div>
<div id="#tab_message-header-tab"></div>
<p id="rfc.section.9.1.p.1">Message-body header fields define meta-information about the content data in the message body. The message-body header fields are listed in <a href="#tab_message-header-tab">Table 6</a>. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>The RTSP message-body headers</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Defined in Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Allow</td>
<td class="left">
<a href="#sec_Allow">Section 16.6</a> </td>
</tr>
<tr>
<td class="left">Content-Base</td>
<td class="left">
<a href="#sec_Content-Base">Section 16.13</a> </td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">
<a href="#sec_Content-Encoding">Section 16.14</a> </td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">
<a href="#sec_Content-Language">Section 16.15</a> </td>
</tr>
<tr>
<td class="left">Content-Length</td>
<td class="left">
<a href="#sec_Content-Length">Section 16.16</a> </td>
</tr>
<tr>
<td class="left">Content-Location</td>
<td class="left">
<a href="#sec_Content-Location">Section 16.17</a> </td>
</tr>
<tr>
<td class="left">Content-Type</td>
<td class="left">
<a href="#sec_Content-Type">Section 16.18</a> </td>
</tr>
<tr>
<td class="left">Expires</td>
<td class="left">
<a href="#sec_Expires">Section 16.21</a> </td>
</tr>
<tr>
<td class="left">Last-Modified</td>
<td class="left">
<a href="#sec_Last-Modified">Section 16.26</a> </td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> Message Body</h1>
<p id="rfc.section.9.2.p.1">RTSP message with an message body MUST include the Content-Type and Content-Length headers. When a message body is included with a message, the data type of that content data is determined via the header fields Content-Type and Content-Encoding.</p>
<p id="rfc.section.9.2.p.2">Content-Type specifies the media type of the underlying data.  Content-Encoding may be used to indicate any additional content codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource. There is no default encoding.</p>
<p id="rfc.section.9.2.p.3">The Content-Length of a message is the length of the content, measured in bytes.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#sec_connections" id="sec_connections">Connections</a>
</h1>
<p id="rfc.section.10.p.1">RTSP requests can be transmitted using the two different connection scenarios listed below: </p>

<ul>
<li>persistent - a transport connection is used for several request/response transactions;</li>
<li>transient - a transport connection is used for a single request/response transaction.</li>
</ul>
<p id="rfc.section.10.p.2">RFC 2326 attempted to specify an optional mechanism for transmitting RTSP messages in connectionless mode over a transport protocol such as UDP. However, it was not specified in sufficient detail to allow for interoperable implementations. In an attempt to reduce complexity and scope, and due to lack of interest, RTSP 2.0 does not attempt to define a mechanism for supporting RTSP over UDP or other connectionless transport protocols. A side-effect of this is that RTSP requests MUST NOT be sent to multicast groups since no connection can be established with a specific receiver in multicast environments.</p>
<p id="rfc.section.10.p.3">Certain RTSP headers, such as the CSeq header (<a href="#sec_CSeq">Section 16.19</a>), which may appear to be relevant only to connectionless transport scenarios are still retained and must be implemented according to the specification. In the case of CSeq, it is quite useful for matching responses to requests if the requests are pipelined (see <a href="#Pipelining">Section 12</a>). It is also useful in proxies for keeping track of the different requests when aggregating several client requests on a single TCP connection.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> Reliability and Acknowledgements</h1>
<p id="rfc.section.10.1.p.1">Since RTSP messages are transmitted using reliable transport protocols, they MUST NOT be retransmitted at the RTSP protocol level.  Instead, the implementation must rely on the underlying transport to provide reliability. The RTSP implementation may use any indication of reception acknowledgment of the message from the underlying transport protocols to optimize the RTSP behavior.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">If both the underlying reliable transport such as TCP and the RTSP application retransmit requests, each packet loss or message loss may result in two retransmissions. The receiver typically cannot take advantage of the application-layer retransmission since the transport stack will not deliver the application-layer retransmission before the first attempt has reached the receiver.  If the packet loss is caused by congestion, multiple retransmissions at different layers will exacerbate the congestion.</dd>
</dl>
<p id="rfc.section.10.1.p.3">Lack of acknowledgment of an RTSP request should be handled within the constraints of the connection timeout considerations described below (<a href="#sec_connection-timeout">Section 10.4</a>).</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#sec_connections-usage" id="sec_connections-usage">Using Connections</a>
</h1>
<p id="rfc.section.10.2.p.1">A TCP transport can be used for both persistent connections (for several message exchanges) and transient connections (for a single message exchange). Implementations of this specification MUST support RTSP over TCP. The scheme of the RTSP URI (<a href="#sec_url">Section 4.2</a>) indicates the default port that the server will listen on if the port is not explicitly given.</p>
<p id="rfc.section.10.2.p.2">A server MUST handle both persistent and transient connections.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Transient connections facilitate mechanisms for fault tolerance. They also allow for application layer mobility. A server and client pair that support transient connections can survive the loss of a TCP connection; e.g., due to a NAT timeout.  When the client has discovered that the TCP connection has been lost, it can set up a new one when there is need to communicate again.</dd>
</dl>
<p id="rfc.section.10.2.p.4">A persistent connection is RECOMMENDED to be used for all transactions between the server and client, including messages for multiple RTSP sessions. However, a persistent connection MAY be closed after a few message exchanges. For example, a client may use a persistent connection for the initial SETUP and PLAY message exchanges in a session and then close the connection. Later, when the client wishes to send a new request, such as a PAUSE for the session, a new connection would be opened. This connection may either be transient or persistent.</p>
<p id="rfc.section.10.2.p.5">An RTSP agent SHOULD NOT have more than one connection to the server at any given point. If a client or proxy handles multiple RTSP sessions on the same server, it SHOULD use only one connection for managing those sessions.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">This saves connection resources on the server. It also reduces complexity by enabling the server to maintain less state about its sessions and connections.</dd>
</dl>
<p id="rfc.section.10.2.p.7">RTSP allows a server to send requests to a client. However, this can be supported only if a client establishes a persistent connection with the server. In cases where a persistent connection does not exist between a server and its client, due to the lack of a signaling channel the server may be forced to silently discard RTSP messages, and may even drop an RTSP session without notifying the client. An example of such a case is when the server desires to send a REDIRECT request for an RTSP session to the client but is not able to do so because it cannot reach the client. A server that attempts to send a request to a client that has no connection currently to the server SHOULD discard the request directly, but it MAY queue it for later delivery. However, if the server queues the request it should when adding additional requests to the queue ensure to remove older requests that are now redundant. </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Without a persistent connection between the client and the server, the media server has no reliable way of reaching the client. Because the likely failure of server to client established connections the server will not even attempt establishing any connection.</dd>
</dl>
<p id="rfc.section.10.2.p.8">The sending of client and server requests can be asynchronous events. To avoid deadlock situations both client and server MUST be able to send and receive requests simultaneously. As an RTSP response may be queued up for transmission, reception or processing behind the peer RTSP agent's own requests, all RTSP agents are required to have a certain capability of handling outstanding messages. A potential issue is that outstanding requests may timeout despite them being processed by the peer due to the response is caught in the queue behind a number of request that the RTSP agent is processing but that take some time to complete. To avoid this problem an RTSP agent is recommended to buffer incoming messages locally so that any response messages can be processed immediately upon reception. If responses are separated from requests and directly forwarded for processing, not only the result be used immediately, the state associated with that outstanding request can also be released. However, buffering a number of requests on the receiving RTSP agent consumes resources and enables a resource exhaustion attack on the agent. Therefore this buffer should be limited so that an unreasonable number of requests or total message size is not allowed to consume the receiving agent's resources. In most APIs having the receiving agent stop reading from the TCP socket will result in TCP's window being clamped. Thus forcing the buffering onto the sending agent when the load is larger than expected. However, as both RTSP message sizes and frequency may be changed in the future by protocol extensions, an agent should be careful against taking harsher measurements against a potential attack. When under attack an RTSP agent can close TCP connections and release state associated with that TCP connection.</p>
<p id="rfc.section.10.2.p.9">To provide some guidance on what is reasonable the following guidelines are given. An RTSP agent should not have more than 10 outstanding requests per RTSP session. An RTSP agent should not have more than 10 outstanding requests that aren't related to an RTSP session or that are requesting to create an RTSP session.</p>
<p id="rfc.section.10.2.p.10">In light of the above, it is RECOMMENDED that clients use persistent connections whenever possible. A client that supports persistent connections MAY "pipeline" its requests (see <a href="#Pipelining">Section 12</a>).</p>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> Closing Connections</h1>
<p id="rfc.section.10.3.p.1">The client MAY close a connection at any point when no outstanding request/response transactions exist for any RTSP session being managed through the connection. The server, however, SHOULD NOT close a connection until all RTSP sessions being managed through the connection have been timed out (<a href="#sec_Session">Section 16.47</a>). A server SHOULD NOT close a connection immediately after responding to a session-level TEARDOWN request for the last RTSP session being controlled through the connection. Instead, it should wait for a reasonable amount of time for the client to receive the TEARDOWN response, take appropriate action, and initiate the connection closing. The server SHOULD wait at least 10 seconds after sending the TEARDOWN response before closing the connection.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">This is to ensure that the client has time to issue a SETUP for a new session on the existing connection after having torn the last one down. 10 seconds should give the client ample opportunity to get its message to the server.</dd>
</dl>
<p id="rfc.section.10.3.p.3">A server SHOULD NOT close the connection directly as a result of responding to a request with an error code.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Certain error responses such as "460 Only Aggregate Operation Allowed" (<a href="#sec_error460">Section 15.4.25</a>) are used for negotiating capabilities of a server with respect to content or other factors. In such cases, it is inefficient for the server to close a connection on an error response. Also, such behavior would prevent implementation of advanced/special types of requests or result in extra overhead for the client when testing for new features. On the flip side, keeping connections open after sending an error response poses a Denial of Service security risk (<a href="#sec_security">Section 21</a>).</dd>
</dl>
<p id="rfc.section.10.3.p.5">The server MAY close a connection if he receives an incomplete message and if the message is not completed within a reasonable amount of time. It is RECOMMENDED that the server waits at least 10 second for the completion of a message or for the next part of the message to arrive (which is an indication that the transport and the client are still alive). Servers believing they are under attack or otherwise starved for resources during that event consider using a shorter timeout.</p>
<p id="rfc.section.10.3.p.6">If a server closes a connection while the client is attempting to send a new request, the client will have to close its current connection, establish a new connection and send its request over the new connection.</p>
<p id="rfc.section.10.3.p.7">An RTSP message should not be terminated by closing the connection.  Such a message MAY be considered to be incomplete by the receiver and discarded. An RTSP message is properly terminated as defined in <a href="#sec_message">Section 5</a>.</p>
<h1 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> <a href="#sec_connection-timeout" id="sec_connection-timeout">Timing Out Connections and RTSP Messages</a>
</h1>
<p id="rfc.section.10.4.p.1">Receivers of a request (responder) SHOULD respond to requests in a timely manner even when a reliable transport such as TCP is used.  Similarly, the sender of a request (requester) SHOULD wait for a sufficient time for a response before concluding that the responder will not be acting upon its request.</p>
<p id="rfc.section.10.4.p.2">A responder SHOULD respond to all requests within 5 seconds. If the responder recognizes that processing of a request will take longer than 5 seconds, it SHOULD send a 100 (Continue) response as soon as possible. It SHOULD continue sending a 100 response every 5 seconds thereafter until it is ready to send the final response to the requester. After sending a 100 response, the receiver MUST send a final response indicating the success or failure of the request.</p>
<p id="rfc.section.10.4.p.3">A requester SHOULD wait at least 10 seconds for a response before concluding that the responder will not be responding to its request.  After receiving a 100 response, the requester SHOULD continue waiting for further responses. If more than 10 seconds elapses without receiving any response, the requester MAY assume that the responder is unresponsive and abort the connection.</p>
<p id="rfc.section.10.4.p.4">A requester SHOULD wait longer than 10 seconds for a response if it is experiencing significant transport delays on its connection to the responder. The requester is capable of determining the RTT of the request/response cycle using the Timestamp header (<a href="#sec_Timestamp">Section 16.51</a>) in any RTSP request.</p>

<dl>
<dt></dt>
<dd style="margin-left: 8">10 seconds was chosen for the following reasons. It gives TCP time to perform a couple of retransmissions, even if operating on default values. It is short enough that users may not abandon the process themselves. However, it should be noted that 10 seconds can be aggressive on certain type of networks. The 5 seconds value for 1xx messages is half the timeout giving a reasonable change of successful delivery before timeout happens on the requester side.</dd>
</dl>
<h1 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> <a href="#sec_liveness" id="sec_liveness">Showing Liveness</a>
</h1>
<p id="rfc.section.10.5.p.1">The mechanisms for showing liveness of the client is, any RTSP request with a Session header, if RTP &amp; RTCP is used an RTCP message, or through any other used media protocol capable of indicating liveness of the RTSP client. It is RECOMMENDED that a client does not wait to the last second of the timeout before trying to send a liveness message. The RTSP message may be lost or when using reliable protocols, such as TCP, the message may take some time to arrive safely at the receiver. To show liveness between RTSP request issued to accomplish other things, the following mechanisms can be used, in descending order of preference: </p>

<dl>
<dt>RTCP:</dt>
<dd style="margin-left: 6">If RTP is used for media transport RTCP SHOULD be used. If RTCP is used to report transport statistics, it MUST also work as keep alive. The server can determine the client by network address and port together with the fact that the client is reporting on the servers SSRC(s). A downside of using RTCP is that it only gives statistical guarantees to reach the server. However, the probability of a false client timeout is so low that it can be ignored in most cases. For example, assume a session with 60 seconds timeout and enough bitrate assigned to RTCP messages to send a message from client to server on average every 5 seconds.  That client have, for a network with 5 % packet loss, the probability to fail showing liveness sign in that session within the timeout interval of 2.4*E-16. In sessions with shorter timeouts, or much higher packet loss, or small RTCP bandwidths SHOULD also use any of the mechanisms below.</dd>
<dt>SET_PARAMETER:</dt>
<dd style="margin-left: 6">When using SET_PARAMETER for keep alive, no body SHOULD be included. This method is the RECOMMENDED RTSP method to use for a request intended only to perform keep-alive.</dd>
<dt>GET_PARAMETER:</dt>
<dd style="margin-left: 6">When using GET_PARAMETER for keep alive, no body SHOULD be included.</dd>
<dt>OPTIONS:</dt>
<dd style="margin-left: 6">This method is also usable, but it causes the server to perform more unnecessary processing and result in bigger responses than necessary for the task. The reason is that the server needs to determine the capabilities associated with the media resource to correctly populate the Public and Allow headers.</dd>
</dl>
<p id="rfc.section.10.5.p.2">The timeout parameter MAY be included in a SETUP response, and MUST NOT be included in requests. The server uses it to indicate to the client how long the server is prepared to wait between RTSP commands or other signs of life before closing the session due to lack of activity (see <a href="#sec_machine">Appendix Appendix B</a>). The timeout is measured in seconds, with a default of 60 seconds. The length of the session timeout MUST NOT be changed in an established session.</p>
<h1 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> Use of IPv6</h1>
<p id="rfc.section.10.6.p.1">Explicit IPv6 support was not present in RTSP 1.0 (RFC 2326). RTSP 2.0 has been updated for explicit IPv6 support. Implementations of RTSP 2.0 MUST understand literal IPv6 addresses in URIs and headers.</p>
<h1 id="rfc.section.10.7">
<a href="#rfc.section.10.7">10.7.</a> Overload Control</h1>
<p id="rfc.section.10.7.p.1">Overload in RTSP can occur when server and proxies have insufficient resources to complete the processing of a request. An improper handling of such an overload situation at proxies and servers can impact the operation of the RTSP deployment, probably worsen the situation. RTSP defines the 503 (Service Unavailable) response (Section <a href="#sec_error_503">Section 15.5.4</a>) to let servers and proxies notify requesting proxies and RTSP clients about an overload situation. In conjunction with the Retry-After header (Section <a href="#sec_Retry-After">Section 16.42</a>) the server or proxy can indicate the time after the requesting entity can send another request to the proxy or server.</p>
<p id="rfc.section.10.7.p.2">Simply implementing and using the 503 (Service Unavailable) is not sufficient enough for properly handling overload situations. For instance, a simplistic approach would be to send the 503 response with a Retry-After header set to a fixed value. However, this can cause the situation where multiple RTSP clients again send requests to a proxy or server at roughly the same time which may again cause an overload situation, or if the "old" overload situation is not yet solved, i.e., the length indicated in the Retry-After header was too short.</p>
<p id="rfc.section.10.7.p.3">An RTSP server or proxy in an overload situation must select the value of the Retry-After header carefully and in dependency of its current load situation. It is RECOMMENDED to increase the length proportional with the current load of the server, i.e., an increasing workload should result in an increased length of the indicated unavailability. It is RECOMMENDED to not send the same value in the Retry-After header to all requesting proxies and clients, but to add a variation the mean value of the Retry-After header.</p>
<p id="rfc.section.10.7.p.4">Another issue are load balancing RTSP proxies, i.e., where an RTSP proxy is used to select amongst a set of RTSP servers to handled the requests, or when multiple server addresses are available for a given server name. The proxy or client may receive a 503 (Service Unavailable) from one of its RTSP servers or a TCP timeout (if the server is even unable to handled the request message). The proxy or client simply retries the other addresses, but may also receive a 503 (Service Unavailable) response or TCP timeouts from those addresses.  In such a situation, where none of the RTSP servers/addresses can handled the request, the RTSP agent has to wait before it can send any new requests to the RTSP server. Any additional request to a specific address MUST be delayed according to the Retry-After headers received.  For addresses where no response was received or TCP timeout occurred, an initial wait timer SHOULD be set to 5 seconds. That timer MUST be doubled for each additional failure to connect or receive response.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#sec_capability" id="sec_capability">Capability Handling</a>
</h1>
<p id="rfc.section.11.p.1">This section describes the available capability handling mechanism which allows RTSP to be extended. Extensions to this version of the protocol are basically done in two ways. First, new headers can be added. Secondly, new methods can be added. The capability handling mechanism is designed to handle both cases.</p>
<p id="rfc.section.11.p.2">When a method is added, the involved parties can use the OPTIONS method to discover whether it is supported. This is done by issuing a OPTIONS request to the other party. Depending on the URI it will either apply in regards to a certain media resource, the whole server in general, or simply the next hop. The OPTIONS response MUST contain a Public header which declares all methods supported for the indicated resource.</p>
<p id="rfc.section.11.p.3">It is not necessary to use OPTIONS to discover support of a method, as the client could simply try the method. If the receiver of the request does not support the method it will respond with an error code indicating the method is either not implemented (501) or does not apply for the resource (405). The choice between the two discovery methods depends on the requirements of the service.</p>
<p id="rfc.section.11.p.4">Feature-Tags are defined to handle functionality additions that are not new methods. Each feature-tag represents a certain block of functionality. The amount of functionality that a feature-tag represents can vary significantly. A feature-tag can for example represent the functionality a single RTSP header provides. Another feature-tag can represent much more functionality, such as the "play.basic" feature-tag which represents the minimal media delivery for playback implementation.</p>
<p id="rfc.section.11.p.5">Feature-tags are used to determine whether the client, server or proxy supports the functionality that is necessary to achieve the desired service. To determine support of a feature-tag, several different headers can be used, each explained below: </p>

<dl>
<dt>Supported:</dt>
<dd style="margin-left: 6">This header is used to determine the complete set of functionality that both client and server have. The intended usage is to determine before one needs to use a functionality that it is supported. It can be used in any method, but OPTIONS is the most suitable one as it at the same time determines all methods that are implemented. When sending a request the requester declares all its capabilities by including all supported feature-tags. This results in the receiver learns the requester's feature support. The receiver then includes its set of features in the response.</dd>
<dt>Proxy-Supported:</dt>
<dd style="margin-left: 6">This header is used similarly to the Supported header, but instead of giving the supported functionality of the client or server it provides both the requester and the responder a view of what functionality the proxy chain between the two supports. Proxies are required to add this header whenever the Supported header is present, but proxies may also add it independently of the requester.</dd>
<dt>Require:</dt>
<dd style="margin-left: 6">This header can be included in any request where the end-point, i.e. the client or server, is required to understand the feature to correctly perform the request. This can, for example, be a SETUP request where the server is required to understand a certain parameter to be able to set up the media delivery correctly. Ignoring this parameter would not have the desired effect and is not acceptable. Therefore the end-point receiving a request containing a Require MUST negatively acknowledge any feature that it does not understand and not perform the request.  The response in cases where features are not supported are 551 (Option Not Supported). Also the features that are not supported are given in the Unsupported header in the response.</dd>
<dt>Proxy-Require:</dt>
<dd style="margin-left: 6">This header has the same purpose and workings as Require except that it only applies to proxies and not the end-point. Features that need to be supported by both proxies and end-points need to be included in both the Require and Proxy-Require header.</dd>
<dt>Unsupported:</dt>
<dd style="margin-left: 6">This header is used in a 551 error response, to indicate which features were not supported. Such a response is only the result of the usage of the Require and/or Proxy-Require header where one or more feature where not supported.  This information allows the requester to make the best of situations as it knows which features are not supported.</dd>
</dl>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#Pipelining" id="Pipelining">Pipelining Support</a>
</h1>
<p id="rfc.section.12.p.1">Pipelining is a general method to improve performance of request response protocols by allowing the requesting agent to have more than one request outstanding and send them over the same persistent connection. For RTSP, where the relative order of requests will matter, it is important to maintain the order of the requests. Because of this, the responding agent MUST process the incoming requests in their sending order. The sending order can be determined by the CSeq header and its sequence number. For TCP the delivery order will be the same as the sending order. The processing of the request MUST also have been finished before processing the next request from the same agent. The responses MUST be sent in the order the requests were processed.</p>
<p id="rfc.section.12.p.2">RTSP 2.0 has extended support for pipelining compared to RTSP 1.0.  The major improvement is to allow all requests to setup and initiate media delivery to be pipelined after each other. This is accomplished by the utilization of the Pipelined-Requests header (see <a href="#sec_Pipelined-Requests">Section 16.32</a>). This header allows a client to request that two or more requests are processed in the same RTSP session context which the first request creates. In other words, a client can request that two or more media streams are set-up and then played without needing to wait for a single response. This speeds up the initial startup time for an RTSP session with at least one RTT.</p>
<p id="rfc.section.12.p.3">If a pipelined request builds on the successful completion of one or more prior requests the requester must verify that all requests were executed as expected. A common example will be two SETUP requests and a PLAY request. In case one of the SETUP fails unexpectedly, the PLAY request can still be successfully executed. However, the resulting presentation will not be as expected by the requesting client, as only a single media instead of two will be played. In this case the client can send a PAUSE request, correct the failing SETUP request and then request it to be played.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#sec_methods" id="sec_methods">Method Definitions</a>
</h1>
<div id="#rfc.table.7"></div>
<div id="#tab_methods"></div>
<p id="rfc.section.13.p.1">The method indicates what is to be performed on the resource identified by the Request-URI. The method name is case-sensitive. New methods may be defined in the future. Method names MUST NOT start with a $ character (decimal 36) and MUST be a token as defined by the ABNF <a href="#RFC5234">[RFC5234]</a> in the syntax chapter <a href="#sec_syntax">Section 20</a>. The methods are summarized in <a href="#tab_methods">Table 7</a>. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Overview of RTSP methods, their direction, and what objects (P: presentation, S: stream) they operate on.</caption>
<thead><tr>
<th class="left">method</th>
<th class="left">direction</th>
<th class="left">object</th>
<th class="left">Server req.</th>
<th class="left">Client req.</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DESCRIBE</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">recommended</td>
<td class="left">recommended</td>
</tr>
<tr>
<td class="left">GET_PARAMETER</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">optional</td>
<td class="left">optional</td>
</tr>
<tr>
<td class="left"></td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">optional</td>
<td class="left">optional</td>
</tr>
<tr>
<td class="left">OPTIONS</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left"></td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">optional</td>
<td class="left">optional</td>
</tr>
<tr>
<td class="left">PAUSE</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left">PLAY_NOTIFY</td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left">REDIRECT</td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">optional</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">C -&gt; S</td>
<td class="left">S</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left">SET_PARAMETER</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">required</td>
<td class="left">optional</td>
</tr>
<tr>
<td class="left"></td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">optional</td>
<td class="left">optional</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
<tr>
<td class="left"></td>
<td class="left">S -&gt; C</td>
<td class="left">P</td>
<td class="left">required</td>
<td class="left">required</td>
</tr>
</tbody>
</table>
<dl>
<dt></dt>
<dd style="margin-left: 8">Note on <a href="#tab_methods">Table 7</a>: GET_PARAMETER is recommended, but not required. For example, a fully functional server can be built to deliver media without any parameters.  SET_PARAMETER is required, however, due to its usage for keep-alive.  PAUSE is now required because it is the only way of leaving the Play state without terminating the whole session.</dd>
</dl>
<p id="rfc.section.13.p.2">If an RTSP agent does not support a particular method, it MUST return 501 (Not Implemented) and the requesting RTSP agent, in turn, SHOULD NOT try this method again for the given agent / resource combination. An RTSP proxy whose main function is to log or audit and not modify transport or media handling in any way MAY forward RTSP messages with unknown methods. Note that the proxy still needs to perform the minimal required processing, like adding the Via header.</p>
<h1 id="rfc.section.13.1">
<a href="#rfc.section.13.1">13.1.</a> <a href="#sec_OPTIONS" id="sec_OPTIONS">OPTIONS</a>
</h1>
<p id="rfc.section.13.1.p.1">The semantics of the RTSP OPTIONS method is similar to that of the HTTP OPTIONS method described in [H9.2]. In RTSP however, OPTIONS is bi-directional, in that a client can request it to a server and vice versa. A client MUST implement the capability to send an OPTIONS request and a server or a proxy MUST implement the capability to respond to an OPTIONS request. The client, server or proxy MAY also implement the converse of their required capability.</p>
<p id="rfc.section.13.1.p.2">An OPTIONS request may be issued at any time. Such a request does not modify the session state. However, it may prolong the session lifespan (see below). The URI in an OPTIONS request determines the scope of the request and the corresponding response. If the Request-URI refers to a specific media resource on a given host, the scope is limited to the set of methods supported for that media resource by the indicated RTSP agent. A Request-URI with only the host address limits the scope to the specified RTSP agent's general capabilities without regard to any specific media. If the Request-URI is an asterisk ("*"), the scope is limited to the general capabilities of the next hop (i.e. the RTSP agent in direct communication with the request sender).</p>
<p id="rfc.section.13.1.p.3">Regardless of scope of the request, the Public header MUST always be included in the OPTIONS response listing the methods that are supported by the responding RTSP agent. In addition, if the scope of the request is limited to a media resource, the Allow header MUST be included in the response to enumerate the set of methods that are allowed for that resource unless the set of methods completely matches the set in the Public header. If the given resource is not available, the RTSP agent SHOULD return an appropriate response code such as 3rr or 4xx. The Supported header MAY be included in the request to query the set of features that are supported by the responding RTSP agent.</p>
<p id="rfc.section.13.1.p.4">The OPTIONS method can be used to keep an RTSP session alive.  However, this is not the preferred way of session keep-alive signaling, see <a href="#sec_Session">Section 16.47</a>. An OPTIONS request intended for keeping alive an RTSP session MUST include the Session header with the associated session ID. Such a request SHOULD also use the media or the aggregated control URI as the Request-URI.</p>
<div id="#rfc.figure.5"></div>
<pre>
  C-&gt;S:  OPTIONS rtsp://server.example.com RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2
         Proxy-Require: gzipped-messages
         Supported: play.basic

  S-&gt;C:  RTSP/2.0 200 OK
         CSeq: 1
         Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, OPTIONS
         Supported: play.basic, setup.rtp.rtcp.mux, play.scale
         Server: PhonyServer/1.1

</pre>
<p id="rfc.section.13.1.p.5">Example: </p>
<p id="rfc.section.13.1.p.6">Note that some of the feature-tags in Supported and Proxy-Require are fictional features.</p>
<h1 id="rfc.section.13.2">
<a href="#rfc.section.13.2">13.2.</a> <a href="#sec_DESCRIBE" id="sec_DESCRIBE">DESCRIBE</a>
</h1>
<p id="rfc.section.13.2.p.1">The DESCRIBE method is used to retrieve the description of a presentation or media object from a server. The Request-URI of the DESCRIBE request identifies the media resource of interest. The client MAY include the Accept header in the request to list the description formats that it understands. The server MUST respond with a description of the requested resource and return the description in the message body of the response, if the DESCRIBE method request can be successfully fulfilled. The DESCRIBE reply-response pair constitutes the media initialization phase of RTSP.</p>
<p id="rfc.section.13.2.p.2">The DESCRIBE response SHOULD contain all media initialization information for the resource(s) that it describes. Servers SHOULD NOT use the DESCRIBE response as a means of media indirection by having the description point at another server; instead, using the 3rr responses is RECOMMENDED.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">By forcing a DESCRIBE response to contain all media initialization for the set of streams that it describes, and discouraging the use of DESCRIBE for media indirection, any looping problems can be avoided that might have resulted from other approaches.</dd>
</dl>
<div id="#rfc.figure.6"></div>
<pre>
  C-&gt;S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/2.0
        CSeq: 312
        User-Agent: PhonyClient/1.2
        Accept: application/sdp, application/example

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 312
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Server: PhonyServer/1.1
        Content-Base: rtsp://server.example.com/fizzle/foo/
        Content-Type: application/sdp
        Content-Length: 358

        v=0
        o=mhandley 2890844526 2890842807 IN IP4 192.0.2.46
        s=SDP Seminar
        i=A Seminar on the session description protocol
        u=http://www.example.com/lectures/sdp.ps
        e=seminar@example.com (Seminar Management)
        c=IN IP4 0.0.0.0
        a=control:*
        t=2873397496 2873404696
        m=audio 3456 RTP/AVP 0
        a=control:audio
        m=video 2232 RTP/AVP 31
        a=control:video
</pre>
<p id="rfc.section.13.2.p.4">Example: </p>
<p id="rfc.section.13.2.p.5">Media initialization is a requirement for any RTSP-based system, but the RTSP specification does not dictate that this is required to be done via the DESCRIBE method. There are three ways that an RTSP client may receive initialization information: </p>

<ul>
<li>via an RTSP DESCRIBE request</li>
<li>via some other protocol (HTTP, email attachment, etc.)</li>
<li>via some form of user interface</li>
</ul>
<p id="rfc.section.13.2.p.6">If a client obtains a valid description from an alternate source, the client MAY use this description for initialization purposes without issuing a DESCRIBE request for the same media. The client should use any MTag to either validate the presentation description or make the session establishment conditional on being valid.</p>
<p id="rfc.section.13.2.p.7">It is RECOMMENDED that minimal servers support the DESCRIBE method, and highly recommended that minimal clients support the ability to act as "helper applications" that accept a media initialization file from a user interface, and/or other means that are appropriate to the operating environment of the clients.</p>
<h1 id="rfc.section.13.3">
<a href="#rfc.section.13.3">13.3.</a> <a href="#sec_SETUP" id="sec_SETUP">SETUP</a>
</h1>
<p id="rfc.section.13.3.p.1">The SETUP request for an URI specifies the transport mechanism to be used for the streamed media. The SETUP method may be used in two different cases; Create an RTSP session and change the transport parameters of already set up media stream. SETUP can be used in all three states; Init, and Ready, for both purposes and in PLAY to change the transport parameters. There is also a third possible usage for the SETUP method which is not specified in this memo: adding a media to a session. Using SETUP to add media to an existing session, when the session is in Play state, is unspecified.</p>
<p id="rfc.section.13.3.p.2">The Transport header, see <a href="#sec_Transport">Section 16.52</a>, specifies the media transport parameters acceptable to the client for data transmission; the response will contain the transport parameters selected by the server. This allows the client to enumerate in descending order of preference the transport mechanisms and parameters acceptable to it, while the server can select the most appropriate. It is expected that the session description format used will enable the client to select a limited number possible configurations that are offered to the server to choose from. All transport related parameters shall be included in the Transport header; the use of other headers for this purpose is discouraged due to middleboxes, such as firewalls or NATs.</p>
<p id="rfc.section.13.3.p.3">For the benefit of any intervening firewalls, a client MUST indicate the known transport parameters, even if it has no influence over these parameters, for example, where the server advertises a fixed multicast address as destination.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Since SETUP includes all transport initialization information, firewalls and other intermediate network devices (which need this information) are spared the more arduous task of parsing the DESCRIBE response, which has been reserved for media initialization.</dd>
</dl>
<p id="rfc.section.13.3.p.5">The client MUST include the Accept-Ranges header in the request indicating all supported unit formats in the Range header. This allows the server to know which format it may use in future session related responses, such as a PLAY response without any range in the request.  If the client does not support a time format necessary for the presentation the server MUST respond using 456 (Header Field Not Valid for Resource) and include the Accept-Ranges header with the range unit formats supported for the resource.</p>
<p id="rfc.section.13.3.p.6">In a SETUP response the server MUST include the Accept-Ranges header (see <a href="#sec_Accept-Ranges">Section 16.5</a>) to indicate which time formats are acceptable to use for this media resource.</p>
<p id="rfc.section.13.3.p.7">The SETUP response 200 OK MUST include the Media-Properties header (see <a href="#sec_Media-Properties">Section 16.28</a> ). The combination of the parameters of the Media-Properties header indicate the nature of the content present in the session (see also <a href="#sec_Media-Properties-Intro">Section 4.9</a>). For example, a live stream with time shifting is indicated by</p>

<ul>
<li>Random Access set to Random-Access,</li>
<li>Content Modifications set to Time Progressing,</li>
<li>Retention set to Time-Duration (with specific recording window time value).</li>
</ul>
<p id="rfc.section.13.3.p.8">The SETUP response 200 OK MUST include the Media-Range header (see <a href="#sec_Media-Range">Section 16.29</a>) if the media is Time-Progressing.</p>
<div id="#rfc.figure.7"></div>
<pre>
  C-&gt;S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0
        CSeq: 302
        Transport: RTP/AVP;unicast;dest_addr=":4588"/":4589",
                   RTP/AVP/TCP;unicast;interleaved=0-1
        Accept-Ranges: NPT, UTC
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 302
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Server: PhonyServer/1.1
        Session: 47112344;timeout=60
        Transport: RTP/AVP;unicast;dest_addr="192.0.2.53:4588"/
                   "192.0.2.53:4589"; src_addr="198.51.100.241:6256"/
                   "198.51.100.241:6257"; ssrc=2A3F93ED
        Accept-Ranges: NPT
        Media-Properties: Random-Access=3.2, Time-Progressing, 
                          Time-Duration=3600.0
        Media-Range: npt=0-2893.23</pre>
<p id="rfc.section.13.3.p.9">A basic example for SETUP:</p>
<p id="rfc.section.13.3.p.10">In the above example the client wants to create an RTSP session containing the media resource "rtsp://example.com/foo/bar/baz.rm". The transport parameters acceptable to the client is either RTP/AVP/UDP (UDP per default) to be received on client port 4588 and 4589 at the address the RTSP setup connection comes from or RTP/AVP interleaved on the RTSP control channel. The server selects the RTP/AVP/UDP transport and adds the address and ports it will send and received RTP and RTCP from, and the RTP SSRC that will be used by the server.</p>
<p id="rfc.section.13.3.p.11">The server MUST generate a session identifier in response to a successful SETUP request, unless a SETUP request to a server includes a session identifier or an Pipelined-Requests header referencing an existing session context, in which case the server MUST bundle this setup request into the existing session (aggregated session) or return error 459 (Aggregate Operation Not Allowed) (see <a href="#sec_error459">Section 15.4.24</a>). An Aggregate control URI MUST be used to control an aggregated session. This URI MUST be different from the stream control URIs of the individual media streams included in the aggregate. The Aggregate control URI is to be specified by the session description if the server supports aggregated control and aggregated control is desired for the session. However, even if aggregated control is offered the client MAY chose to not set up the session in aggregated control. If an Aggregate control URI is not specified in the session description, it is normally an indication that non-aggregated control should be used. The SETUP of media streams in an aggregate which has not been given an aggregated control URI is unspecified.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">While the session ID sometimes carries enough information for aggregate control of a session, the Aggregate control URI is still important for some methods such as SET_PARAMETER where the control URI enables the resource in question to be easily identified. The Aggregate control URI is also useful for proxies, enabling them to route the request to the appropriate server, and for logging, where it is useful to note the actual resource that a request was operating on.</dd>
</dl>
<p id="rfc.section.13.3.p.13">A session will exist until it is either removed by a TEARDOWN request or is timed-out by the server. The server MAY remove a session that has not demonstrated liveness signs from the client(s) within a certain timeout period. The default timeout value is 60 seconds; the server MAY set this to a different value and indicate so in the timeout field of the Session header in the SETUP response. For further discussion see <a href="#sec_Session">Section 16.47</a>. Signs of liveness for an RTSP session are: </p>

<ul>
<li>Any RTSP request from a client which includes a Session header with that session's ID.</li>
<li>If RTP is used as a transport for the underlying media streams, an RTCP sender or receiver report from the client(s) for any of the media streams in that RTSP session. RTCP Sender Reports may for example be received in sessions where the server is invited into a conference session and is valid for keep-alive.</li>
</ul>
<p id="rfc.section.13.3.p.14">If a SETUP request on a session fails for any reason, the session state, as well as transport and other parameters for associated streams MUST remain unchanged from their values as if the SETUP request had never been received by the server.</p>
<h1 id="rfc.section.13.3.1">
<a href="#rfc.section.13.3.1">13.3.1.</a> Changing Transport Parameters</h1>
<p id="rfc.section.13.3.1.p.1">A client MAY issue a SETUP request for a stream that is already set up or playing in the session to change transport parameters, which a server MAY allow. If it does not allow changing of parameters, it MUST respond with error 455 (Method Not Valid In This State). The reasons to support changing transport parameters include allowing application layer mobility and flexibility to utilize the best available transport as it becomes available. If a client receives a 455 when trying to change transport parameters while the server is in Play state, it MAY try to put the server in ready state using PAUSE, before issuing the SETUP request again. If that also fails the changing of transport parameters will require that the client performs a TEARDOWN of the affected media and then to set it up again. In aggregated session avoiding tearing down all the media at the same time will avoid the creation of a new session.</p>
<p id="rfc.section.13.3.1.p.2">All transport parameters MAY be changed. However, the primary usage expected is to either change the transport protocol completely, like switching from Interleaved TCP mode to UDP or vice versa, or to change the delivery address.</p>
<p id="rfc.section.13.3.1.p.3">In a SETUP response for a request to change the transport parameters while in Play state, the server MUST include the Range to indicate at what point the new transport parameters will be used.  Further, if RTP is used for delivery, the server MUST also include the RTP-Info header to indicate at what timestamp and RTP sequence number the change will take place. If both RTP-Info and Range are included in the response the "rtp_time" parameter and start point in the Range header MUST be for the corresponding time, i.e. be used in the same way as for PLAY to ensure the correct synchronization information is available.</p>
<p id="rfc.section.13.3.1.p.4">If the transport parameters change while in Play state results in a change of synchronization related information, for example changing RTP SSRC, the server MUST provide in the SETUP response the necessary synchronization information. However, the server is RECOMMENDED to avoid changing the synchronization information if possible.</p>
<h1 id="rfc.section.13.4">
<a href="#rfc.section.13.4">13.4.</a> <a href="#sec_PLAY" id="sec_PLAY">PLAY</a>
</h1>
<p id="rfc.section.13.4.p.1">This section describes the usage of the PLAY method in general, for aggregated sessions, and in different usage scenarios.</p>
<p></p>
<h1 id="rfc.section.13.4.1">
<a href="#rfc.section.13.4.1">13.4.1.</a> <a href="#sec_PLAY_general" id="sec_PLAY_general">General Usage</a>
</h1>
<p id="rfc.section.13.4.1.p.1">The PLAY method tells the server to start sending data via the mechanism specified in SETUP and which part of the media should be played out. PLAY requests are valid when the session is in Ready or Play states. A PLAY request MUST include a Session header to indicate which session the request applies to.</p>
<p id="rfc.section.13.4.1.p.2">Upon receipt of the PLAY request, the server MUST position the normal play time to the beginning of the range specified in the received Range header and deliver stream data until the end of the range if given, until a new PLAY request is received, or until the end of the media is reached. If no Range header is present in the PLAY request the server SHALL play from current pause point until the end of media. The pause point defaults at session start to the beginning of the media. For media that is time-progressing and has no retention, the pause point will always be set equal to NPT "now", i.e., the current delivery point. The pause point may also be set to a particular point in the media by the PAUSE method, see <a href="#sec_PAUSE">Section 13.6</a>. The pause point for media that is currently playing is equal to the current media position. For time-progressing media with time-limited retention, if the pause point represents a position that is older than what is retained by the server, the pause point will be moved to the oldest retained.</p>
<p id="rfc.section.13.4.1.p.3">What range values are valid depends on the type of content. For content that isn't time progressing the range value is valid if the given range is part of any media within the aggregate. In other words the valid media range for the aggregate is the union of all of the media components in the aggregate. If a given range value points outside of the media, the response MUST be the 457 (Invalid Range) error code and include the <a href="#sec_Media-Range">Media-Range header</a> <cite title="NONE">[sec_Media-Range]</cite> with the valid range for the media. Except for time progressing content where the client requests a start point prior to what is retained, the start point is adjusted to the oldest retained content. For a start point that is beyond the media front edge, i.e. beyond the current value for "now", the server SHALL adjust the start value to the current front edge. The Range header's stop point value may point beyond the current media edge. In that case, the server SHALL deliver media from the requested (and possibly adjusted) start point until the provided stop point, or the end of the media is reached prior to the specified stop point.  Please note that if one simply wants to play from a particular start point until the end of media using an Range header with an implicit stop point is RECOMMENDED.</p>
<p id="rfc.section.13.4.1.p.4">If a client requests to start playing at the end of media, either explicitly with a Range header or implicitly with a pause point that is at the end of media, a 457 (Invalid Range) error MUST be sent and include the <a href="#sec_Media-Range">Media-Range header</a> <cite title="NONE">[sec_Media-Range]</cite>. Below is specified that the Range header also must be included, and will in the case of Ready State carry the pause point.  Note that this also applies if the pause point or requested start point is at the beginning of the media and a <a href="#sec_Scale">Scale header</a> <cite title="NONE">[sec_Scale]</cite> is included with a negative value (playing backwards).</p>
<p id="rfc.section.13.4.1.p.5">For media with random access properties a client may express its preference on which policy for start point selection the server shall use. This is done by including the <a href="#sec_Seek-Style">Seek-Style header</a> <cite title="NONE">[sec_Seek-Style]</cite> in the PLAY request. The Seek-Style applied will effect the content of the Range header as it will be adjusted to indicate from what point the media actually is delivered.</p>
<p id="rfc.section.13.4.1.p.6">A client desiring to play the media from the beginning MUST send a PLAY request with a Range header pointing at the beginning, e.g.  npt=0-. If a PLAY request is received without a Range header and media delivery has stopped at the end, the server SHOULD respond with a 457 "Invalid Range" error response. In that response, the current pause point MUST be included in a Range header.</p>
<p id="rfc.section.13.4.1.p.7">All range specifiers in this specification allow for ranges with an implicit start point (e.g. "npt=-30"). When used in a PLAY request, the server treats this as a request to start or resume delivery from the current pause point, ending at the end time specified in the Range header. If the pause point is located later than the given end value, a 457 (Invalid Range) response MUST be given.</p>
<div id="#rfc.figure.8"></div>
<pre>
  C-&gt;S: PLAY rtsp://audio.example.com/audio RTSP/2.0
        CSeq: 835
        Session: 12345678
        Range: npt=10-25
        Seek-Style: RAP
        User-Agent: PhonyClient/1.2</pre>
<p id="rfc.section.13.4.1.p.8">The example below will play seconds 10 through 25. It also requests the server to deliver media from the first Random Access Point prior to the indicated start point. </p>
<p id="rfc.section.13.4.1.p.9">Servers MUST include a "Range" header in any PLAY response, even if no Range header was present in the request. The response MUST use the same format as the request's range header contained. If no Range header was in the request, the format used in any previous PLAY request within the session SHOULD be used. If no format has been indicated in a previous request the server MAY use any time format supported by the media and indicated in the Accept-Ranges header in the SETUP request. It is RECOMMENDED that NPT is used if supported by the media.</p>
<p id="rfc.section.13.4.1.p.10">For any error response to a PLAY request, the server's response depends on the current session state. If the session is in Ready state, the current pause-point is returned using Range header with the pause point as the explicit start-point and an implicit stop-point. For time-progressing content where the pause-point moves with real-time due to limited retention, the current pause point is returned. For sessions in Play state, the current playout point and the remaining parts of the range request is returned. For any media with retention longer than 0 seconds the currently valid Media-Range header SHALL also be included in the response.</p>
<p id="rfc.section.13.4.1.p.11">A PLAY response MAY include a header carrying synchronization information. As the information necessary is dependent on the media transport format, further rules specifying the header and its usage are needed. For RTP the RTP-Info header is specified, see <a href="#sec_RTP-Info">Section 16.43</a>, and used in the following example.</p>
<p id="rfc.section.13.4.1.p.12">Here is a simple example for a single audio stream where the client requests the media starting from 3.52 seconds and to the end.  The server sends a 200 OK response with the actual play time which is 10 ms prior (3.51) and the RTP-Info header that contains the necessary parameters for the RTP stack.</p>
<div id="#rfc.figure.9"></div>
<pre>
C-&gt;S: PLAY rtsp://example.com/audio RTSP/2.0
      CSeq: 836
      Session: 12345678
      Range: npt=3.52-      
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 836
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Server: PhonyServer/1.0
      Range: npt=3.51-324.39
      Seek-Style: First-Prior
      RTP-Info:url="rtsp://example.com/audio"
         ssrc=0D12F123:seq=14783;rtptime=2345962545

S-&gt;C: RTP Packet TS=2345962545 =&gt; NPT=3.51
      Media duration=0.16 seconds</pre>
<p id="rfc.section.13.4.1.p.13">The server replies with the actual start point that will be delivered. This may differ from the requested range if alignment of the requested range to valid frame boundaries is required for the media source. Note that some media streams in an aggregate may need to be delivered from even earlier points. Also, some media formats have a very long duration per individual data unit, therefore it might be necessary for the client to parse the data unit, and select where to start. The server SHALL also indicate which policy it uses for selecting the actual start point by including a Seek-Style header.</p>
<div id="#rfc.figure.10"></div>
<pre>
C-&gt;S: PLAY rtsp://example.com/audio RTSP/2.0
      CSeq: 836
      Session: 12345678
      Range: npt=7.05-
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 836
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Server: PhonyServer/1.0
      Range: npt=3.52-
      Seek-Style: First-Prior
      RTP-Info:url="rtsp://example.com/audio"
         ssrc=0D12F123:seq=14783;rtptime=2345962545

S-&gt;C: RTP Packet TS=2345962545 =&gt; NPT=3.52
      Duration=4.15 seconds</pre>
<p id="rfc.section.13.4.1.p.14">In the following example the client receives the first media packet that stretches all the way up and past the requested playtime. Thus, it is the client's decision whether to render to the user the time between 3.52 and 7.05, or to skip it. In most cases it is probably most suitable not to render that time period.</p>
<p id="rfc.section.13.4.1.p.15">After playing the desired range, the presentation does NOT transition to the Ready state, media delivery simply stops. A PAUSE request MUST be issued before the stream enters the Ready state. A PLAY request while the stream is still in the Play state is legal, and can be issued without an intervening PAUSE request. Such a request MUST replace the current PLAY action with the new one requested, i.e. being handle the same as the request was received in Ready state. In the case the range in Range header has a implicit start time (-endtime), the server MUST continue to play from where it currently was until the specified end point. This is useful to change end at another point than in the previous request.</p>
<div id="#rfc.figure.11"></div>
<pre>
C-&gt;S: PLAY rtsp://audio.example.com/twister.en RTSP/2.0
      CSeq: 833
      Session: 12345678
      Range: smpte=0:10:20-
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 833
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Session: 12345678
      Server: PhonyServer/1.0
      Range: smpte=0:10:22-0:15:45
      Seek-Style: Next
      RTP-Info:url="rtsp://example.com/twister.en"
         ssrc=0D12F123:seq=14783;rtptime=2345962545</pre>
<p id="rfc.section.13.4.1.p.16">The following example plays the whole presentation starting at SMPTE time code 0:10:20 until the end of the clip. Note: The RTP-Info headers has been broken into several lines, where following lines start with whitespace as allowed by the syntax. </p>
<div id="#rfc.figure.12"></div>
<pre>
C-&gt;S: PLAY rtsp://audio.example.com/meeting.en RTSP/2.0
      CSeq: 835
      Session: 12345678
      Range: clock=19961108T142300Z-19961108T143520Z
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 835
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Session: 12345678
      Server: PhonyServer/1.0
      Range: clock=19961108T142300Z-19961108T143520Z
      Seek-Style: Next
      RTP-Info:url="rtsp://example.com/meeting.en"
         ssrc=0D12F123:seq=53745;rtptime=484589019</pre>
<p id="rfc.section.13.4.1.p.17">For playing back a recording of a live presentation, it may be desirable to use clock units: </p>
<h1 id="rfc.section.13.4.2">
<a href="#rfc.section.13.4.2">13.4.2.</a> Aggregated Sessions</h1>
<p id="rfc.section.13.4.2.p.1">PLAY requests can operate on sessions controlling a single media and on aggregated sessions controlling multiple media.</p>
<p id="rfc.section.13.4.2.p.2">In an aggregated session the PLAY request MUST contain an aggregated control URI. A server MUST respond with error 460 (Only Aggregate Operation Allowed) if the client PLAY Request-URI is for a single media. The media in an aggregate MUST be played in sync. If a client wants individual control of the media, it needs to use separate RTSP sessions for each media.</p>
<p id="rfc.section.13.4.2.p.3">For aggregated sessions where the initial SETUP request (creating a session) is followed by one or more additional SETUP requests, a PLAY request MAY be pipelined after those additional SETUP requests without awaiting their responses. This procedure can reduce the delay from start of session establishment until media play-out has started with one round trip time. However, a client needs to be aware that using this procedure will result in the playout of the server state established at the time of processing the PLAY, i.e., after the processing of all the requests prior to the PLAY request in the pipeline. This state may not be the intended one due to failure of any of the prior requests. A client can easily determine this based on the responses from those requests. In case of failure, the client can halt the media playout using PAUSE and try to establish the intended state again before issuing another PLAY request.</p>
<h1 id="rfc.section.13.4.3">
<a href="#rfc.section.13.4.3">13.4.3.</a> Updating current PLAY Requests</h1>
<p id="rfc.section.13.4.3.p.1">Clients can issue PLAY requests while the stream is in Play state and thus updating their request.</p>
<p id="rfc.section.13.4.3.p.2">The important difference compared to a PLAY request in Ready state is the handling of the current play point and how the Range header in request is constructed. The session is actively playing media and the play point will be moving, making the exact time a request will take action is hard to predict. Depending on how the PLAY header appears two different cases exist: total replacement or continuation. A total replacement is signaled by having the first range specification have an explicit start value, e.g. npt=45- or npt=45-60, in which case the server stops playout at the current playout point and then starts delivering media according to the Range header. This is equivalent to having the client first send a PAUSE and then a new play request that isn't based on the pause point. In the case of continuation the first range specifier has an implicit start point and a explicit stop value (Z), e.g. npt=-60, which indicate that it MUST convert the range specifier being played prior to this PLAY request (X to Y) into (X to Z) and continue as this was the request originally played. If the current delivery point is beyond the stop point, the server SHALL immediately pause delivery. As the request has been completed successfully it shall be responded with 200 OK. A PLAY_NOTIFY with end-of-stream is also sent to indicate the actual stop point. The pause point is set to the requested stop point.</p>
<p id="rfc.section.13.4.3.p.3">Following is an example of this behavior: The server has received requests to play ranges 10 to 15. If the new PLAY request arrives at the server 4 seconds after the previous one, it will take effect while the server still plays the first range (10-15). The server changes the current play to continue to 25 seconds, i.e. the equivalent single request would be PLAY with range: npt=10-25.</p>
<div id="#rfc.figure.13"></div>
<pre>  
  C-&gt;S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 834
        Session: 12345678
        Range: npt=10-15
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 834
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Session: 12345678
        Server: PhonyServer/1.0
        Range: npt=10-15
        Seek-Style: Next
        RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=5712;rtptime=934207921,
                url="rtsp://example.com/fizzle/videotrack"
                ssrc=789DAF12:seq=57654;rtptime=2792482193
        Session: 12345678

  C-&gt;S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 835
        Session: 12345678
        Range: npt=-25
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 835
        Date: Thu, 23 Jan 1997 15:35:09 GMT
        Session: 12345678
        Server: PhonyServer/1.0
        Range: npt=14-25
        Seek-Style: Next
        RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=5712;rtptime=934239921,
                url="rtsp://example.com/fizzle/videotrack"
                ssrc=789DAF12:seq=57654;rtptime=2792842193
        </pre>
<p></p>
<p id="rfc.section.13.4.3.p.5">A common use of a PLAY request while in Play state is changing the scale of the media, i.e., entering or leaving from fast forward or fast rewind. The client can issue an updating PLAY request that is either a continuation or a complete replacement, as discussed above this section. We give an example of a client that is requesting a fast forward without giving a stop point and the change from fast forward to regular playout (scale = 1).</p>
<div id="#rfc.figure.14"></div>
<pre>  
  C-&gt;S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 2034
        Session: 12345678
        Range: npt=now-
        Scale: 2.0
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 2034
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Session: 12345678
        Server: PhonyServer/1.0
        Range: npt=2:17:21.394-
        Seek-Style: Next
        RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=5712;rtptime=934207921,
                url="rtsp://example.com/fizzle/videotrack"
                ssrc=789DAF12:seq=57654;rtptime=2792482193
        Session: 12345678

[playing in fast forward and now returning to scale = 1]

  C-&gt;S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 2035
        Session: 12345678
        Range: npt=now-
        Scale: 1.0
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 2035
        Date: Thu, 23 Jan 1997 15:35:09 GMT
        Session: 12345678
        Server: PhonyServer/1.0
        Range: npt=2:19:32.144-
        Seek-Style: Next
        RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=5712;rtptime=934239921,
                url="rtsp://example.com/fizzle/videotrack"
                ssrc=789DAF12:seq=57654;rtptime=2792842193
        </pre>
<p></p>
<h1 id="rfc.section.13.4.4">
<a href="#rfc.section.13.4.4">13.4.4.</a> Playing On-Demand Media</h1>
<p id="rfc.section.13.4.4.p.1">On-demand media is indicated by the content of the Media-Properties header in the SETUP response by (see also <a href="#sec_Media-Properties">Section 16.28</a>):<a href="#sec_PLAY_general">Section 13.4.1</a>.</p>

<ul>
<li>Random-Access property is set to Random Access;</li>
<li>Content Modifications set to Immutable;</li>
<li>Retention set to Unlimited or Time-Limited.</li>
</ul>

<p>Playing on-demand media follows the general usage as described in </p>
<p></p>
<h1 id="rfc.section.13.4.5">
<a href="#rfc.section.13.4.5">13.4.5.</a> Playing Dynamic On-Demand Media</h1>
<p id="rfc.section.13.4.5.p.1">Dynamic on-demand media is indicated by the content of the Media-Properties header in the SETUP response by (see also <a href="#sec_Media-Properties">Section 16.28</a>):</p>

<ul>
<li>RandomAccess set to Random-Access;</li>
<li>Content Modifications set to Dynamic;</li>
<li>Retention set to Unlimited or Time-Limited.</li>
</ul>
<p id="rfc.section.13.4.5.p.2">Playing on-demand media follows the general usage as described in <a href="#sec_PLAY_general">Section 13.4.1</a> as long as the media has not been changed.</p>
<p id="rfc.section.13.4.5.p.3">There are two ways for the client to be informed about changes of media resources in Play state. The client will receive a PLAY_NOTIFY request with Notify-Reason header set to media-properties-update (see <a href="#sec_Media-Properties-Update-Reason">Section 13.5.2</a>. The client can use the value of the Media-Range to decide further actions, if the Media-Range header is present in the PLAY_NOTIFY request. The second way is that the client issues a GET_PARAMETER request without a body but including a Media-Range header. The 200 OK response MUST include the current Media-Range header (see <a href="#sec_Media-Range">Section 16.29</a>).</p>
<h1 id="rfc.section.13.4.6">
<a href="#rfc.section.13.4.6">13.4.6.</a> Playing Live Media</h1>
<p id="rfc.section.13.4.6.p.1">Live media is indicated by the content of the Media-Properties header in the SETUP response by (see also <a href="#sec_Media-Properties">Section 16.28</a>):</p>

<ul>
<li>Random-Access set to No-Seeking;</li>
<li>Content Modifications set to Time-Progressing;</li>
<li>Retention with Time-Duration set to 0.0.</li>
</ul>
<p id="rfc.section.13.4.6.p.2">For live media, the SETUP response 200 OK MUST include the Media-Range header (see <a href="#sec_Media-Range">Section 16.29</a>).</p>
<p id="rfc.section.13.4.6.p.3">A client MAY send PLAY requests without the Range header. If the request includes the Range header it MUST use a symbolic value representing "now". For NPT that range specification is "npt=now-".  The server MUST include the Range header in the response and it MUST indicate an explicit time value and not a symbolic value. In other words, "npt=now-" is not a valid to use in the response. Instead the time since session start is recommended expressed as an open interval, e.g. "npt=96.23-". An absolute time value (clock) for the corresponding time MAY be given, i.e. "clock=20030213T143205Z-". The UTC clock format can only be used if client has shown support for it using the Accept-Ranges header.</p>
<h1 id="rfc.section.13.4.7">
<a href="#rfc.section.13.4.7">13.4.7.</a> Playing Live with Recording</h1>
<p id="rfc.section.13.4.7.p.1">Certain media server may offer recording services of live sessions to their clients. This recording would normally be from the beginning of the media session. Clients can randomly access the media between now and the beginning of the media session. This live media with recording is indicated by the content of the Media-Properties header in the SETUP response by (see also <a href="#sec_Media-Properties">Section 16.28</a>):</p>

<ul>
<li>Random-Access set to Random-Access;</li>
<li>Content Modifications set to Time-Progressing;</li>
<li>Retention set to Time-limited or Unlimited</li>
</ul>
<p id="rfc.section.13.4.7.p.2">The SETUP response 200 OK MUST include the Media-Range header (see <a href="#sec_Media-Range">Section 16.29</a>) for this type of media.  For live media with recording, the Range header indicates the current delivery point in the media and the Media-Range header indicates the currently available media window around the current time. This window can cover recorded content in the past (seen from current time in the media) or recorded content in the future (seen from current time in the media). The server adjusts the delivery point to the requested border of the window, if the client requests a delivery point that is located outside the recording windows, e.g., if requested to far in the past, the server selects the oldest range in the recording. The considerations in <a href="#sec_ScaleChange">Section 13.5.3</a> apply, if a client requests delivery with <a href="#sec_Scale">Scale</a> <cite title="NONE">[sec_Scale]</cite> values other than 1.0 (Normal playback rate) while delivering live media with recording.</p>
<h1 id="rfc.section.13.4.8">
<a href="#rfc.section.13.4.8">13.4.8.</a> Playing Live with Time-Shift</h1>
<p id="rfc.section.13.4.8.p.1">Certain media server may offer time-shift services to their clients. This time shift records a fixed interval in the past, i.e., a sliding window recording mechanism, but not past this interval.  Clients can randomly access the media between now and the interval.  This live media with recording is indicated by the content of the Media-Properties header in the SETUP response by (see also <a href="#sec_Media-Properties">Section 16.28</a>):</p>

<ul>
<li>Random-Access set to Random-Access;</li>
<li>Content Modifications set to Time-Progressing;</li>
<li>Retention set to Time-Duration and a value indicating the recording interval (&gt;0).</li>
</ul>
<p id="rfc.section.13.4.8.p.2">The SETUP response 200 OK MUST include the Media-Range header (see <a href="#sec_Media-Range">Section 16.29</a>) for this type of media.  For live media with recording the Range header indicates the current time in the media and the Media Range indicates a window around the current time. This window can cover recorded content in the past (seen from current time in the media) or recorded content in the future (seen from current time in the media). The server adjusts the play point to the requested border of the window, if the client requests a play point that is located outside the recording windows, e.g., if requested too far in the past, the server selects the oldest range in the recording. The considerations in <a href="#sec_ScaleChange">Section 13.5.3</a> apply, if a client requests delivery using a <a href="#sec_Scale">Scale</a> <cite title="NONE">[sec_Scale]</cite> value other than 1.0 (Normal playback rate) while delivering live media with time-shift.</p>
<h1 id="rfc.section.13.5">
<a href="#rfc.section.13.5">13.5.</a> <a href="#sec_PLAY_NOTIFY" id="sec_PLAY_NOTIFY">PLAY_NOTIFY</a>
</h1>
<p id="rfc.section.13.5.p.1">The PLAY_NOTIFY method is issued by a server to inform a client about an asynchronous event for a session in Play state. The Session header MUST be presented in a PLAY_NOTIFY request and indicates the scope of the request. Sending of PLAY_NOTIFY requests requires a persistent connection between server and client, otherwise there is no way for the server to send this request method to the client.</p>
<p id="rfc.section.13.5.p.2">PLAY_NOTIFY requests have an end-to-end (i.e. server to client) scope, as they carry the Session header, and apply only to the given session. The client SHOULD immediately return a response to the server.</p>
<p id="rfc.section.13.5.p.3">PLAY_NOTIFY requests MAY be used with a message body, depending on the value of the Notify-Reason header. It is described in the particular section for each Notify-Reason if a message body is used.  However, currently there is no Notify-Reason that allows using a message body. In this case, there is a need to obey some limitations when adding new Notify-Reasons that intend to use a message body: the server can send any type of message body, but it is not ensured that the client can understand the received message body. This is related to DESCRIBE (see <a href="#sec_DESCRIBE">Section 13.2</a> ), but in this particular case the client can state its acceptable message bodies by using the Accept header. In the case of PLAY_NOTIFY, the server does not know which message bodies are understood by the client.</p>
<p id="rfc.section.13.5.p.4">The Notify-Reason header (see <a href="#sec_Notify-Reason">Section 16.31</a>) specifies the reason why the server sends the PLAY_NOTIFY request. This is extensible and new reasons MAY be added in the future. In case the client does not understand the reason for the notification it MUST respond with an <a href="#sec_error465">465 (Notification Reason Unknown)</a> <cite title="NONE">[sec_error465]</cite> error code. Servers can send PLAY_NOTIFY with these types:</p>
<p></p>

<ul>
<li>end-of-stream (see <a href="#sec_end_of_stream">Section 13.5.1</a>);</li>
<li>media-properties-update (see <a href="#sec_Media-Properties-Update-Reason">Section 13.5.2</a>);</li>
<li>scale-change (see <a href="#sec_ScaleChange">Section 13.5.3</a>).</li>
</ul>
<h1 id="rfc.section.13.5.1">
<a href="#rfc.section.13.5.1">13.5.1.</a> <a href="#sec_end_of_stream" id="sec_end_of_stream">End-of-Stream</a>
</h1>
<p id="rfc.section.13.5.1.p.1">A PLAY_NOTIFY request with Notify-Reason header set to end-of-stream indicates the completion or near completion of the PLAY request and the ending delivery of the media stream(s). The request MUST NOT be issued unless the server is in the Play state.  The end of the media stream delivery notification may be used to indicate either a successful completion of the PLAY request currently being served, or to indicate some error resulting in failure to complete the request. The <a href="#sec_Request-Status">Request-Status header</a> <cite title="NONE">[sec_Request-Status]</cite> MUST be included to indicate which request the notification is for and its completion status. The <a href="#sec_status-code">message response status codes</a> <cite title="NONE">[sec_status-code]</cite> are used to indicate how the PLAY request concluded. The sender of a PLAY_NOTIFY can issue an updated PLAY_NOTIFY, in the case of a PLAY_NOTIFY sent with wrong information. For instance, a PLAY_NOTIFY was issued before reaching the end-of-stream, but some error occurred resulting in that the previously sent PLAY_NOTIFY contained a wrong time when the stream will end. In this case a new PLAY_NOTIFY MUST be sent including the correct status for the completion and all additional information.</p>
<p id="rfc.section.13.5.1.p.2">PLAY_NOTIFY requests with Notify-Reason header set to end-of-stream MUST include a Range header and the Scale header if the scale value is not 1. The Range header indicates the point in the stream or streams where delivery is ending with the timescale that was used by the server in the PLAY response for the request being fulfilled. The server MUST NOT use the "now" constant in the Range header; it MUST use the actual numeric end position in the proper timescale. When end-of-stream notifications are issued prior to having sent the last media packets, this is evident as the end time in the Range header is beyond the current time in the media being received by the client, e.g., npt=-15, if npt is currently at 14.2 seconds. The Scale header is to be included so that it is evident if the media time scale is moving backwards and/or have a non-default pace. The end-of-stream notification does not prevent the client from sending a new PLAY request.</p>
<p id="rfc.section.13.5.1.p.3">If RTP is used as media transport, a RTP-Info header MUST be included, and the RTP-Info header MUST indicate the last sequence number in the seq parameter.</p>
<p id="rfc.section.13.5.1.p.4">A PLAY_NOTIFY request with Notify-Reason header set to end-of-stream MUST NOT carry a message body.</p>
<p id="rfc.section.13.5.1.p.5">This example request notifies the client about a future end-of-stream event:</p>
<div id="#rfc.figure.15"></div>
<pre>  S-&gt;C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 854
        Notify-Reason: end-of-stream
        Request-Status: cseq=853 status=200 reason="OK"
        Range: npt=-145
        RTP-Info:url="rtsp://example.com/audio"
           ssrc=0D12F123:seq=14783;rtptime=2345962545
        Session: uZ3ci0K+Ld-M
        Date: Mon, 08 Mar 2010 13:37:16 GMT

  C-&gt;S: RTSP/2.0 200 OK
        CSeq: 854
        User-Agent: PhonyClient/1.2
        Session: uZ3ci0K+Ld-M</pre>
<p></p>
<h1 id="rfc.section.13.5.2">
<a href="#rfc.section.13.5.2">13.5.2.</a> <a href="#sec_Media-Properties-Update-Reason" id="sec_Media-Properties-Update-Reason">Media-Properties-Update</a>
</h1>
<p id="rfc.section.13.5.2.p.1">A PLAY_NOTIFY request with Notify-Reason header set to media-properties-update indicates an update of the media properties for the given session (see <a href="#sec_Media-Properties">Section 16.28</a>) and/or the available media range that can be played as indicated by <a href="#sec_Media-Range">Media-Range</a> <cite title="NONE">[sec_Media-Range]</cite>. PLAY_NOTIFY requests with Notify-Reason header set to media-properties-update MUST include a Media-Properties and Date header and SHOULD include a Media-Range header.</p>
<p id="rfc.section.13.5.2.p.2">This notification MUST be sent for media that are time-progressing every time an event happens that changes the basis for making estimates on how the media range progress. In addition it is RECOMMENDED that the server sends these notifications every 5 minutes for time-progressing content to ensure the long-term stability of the client estimation and allowing for clock skew detection by the client. Requests for the just mentioned reasons MUST include Media-Range header to provide current Media duration and the Range header to indicate the current playing point and any remaining parts of the requested range.</p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The recommendation for sending updates every 5 minutes is due to any clock skew issues. In 5 minutes the clock skew should not become too significant as this is not used for media playback and synchronization, only for determining which content is available to the user.</dd>
</dl>
<p id="rfc.section.13.5.2.p.3">A PLAY_NOTIFY request with Notify-Reason header set to media-properties-update MUST NOT carry a message body.</p>
<div id="#rfc.figure.16"></div>
<pre>  S-&gt;C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0
        Date: Tue, 14 Apr 2008 15:48:06 GMT
        CSeq: 854
        Notify-Reason: media-properties-update
        Session: uZ3ci0K+Ld-M
        Media-Properties: Time-Progressing, 
              Time-Limited=20080415T153919.36Z, Random-Access=5.0
        Media-Range: npt=0-1:37:21.394
        Range: npt=1:15:49.873-

  C-&gt;S: RTSP/2.0 200 OK
        CSeq: 854
        User-Agent: PhonyClient/1.2
        Session: uZ3ci0K+Ld-M</pre>
<p></p>
<h1 id="rfc.section.13.5.3">
<a href="#rfc.section.13.5.3">13.5.3.</a> <a href="#sec_ScaleChange" id="sec_ScaleChange">Scale-Change</a>
</h1>
<p id="rfc.section.13.5.3.p.1">The server may be forced to change the rate, when a client request delivery using a <a href="#sec_Scale">Scale</a> <cite title="NONE">[sec_Scale]</cite> value other than 1.0 (normal playback rate). For time progressing media with some retention, i.e. the server stores already sent content, a client requesting to play with Scale values larger than 1 may catch up with the front end of the media. The server will then be unable to continue to provide with content at Scale larger than 1 as content is only made available by the server at Scale=1. Another case is when Scale &lt; 1 and the media retention is time-duration limited. In this case the delivery point can reach the oldest media unit available, and further playback at this scale becomes impossible as there will be no media available. To avoid having the client lose any media, the scale will need to be adjusted to the same rate at which the media is removed from the storage buffer, commonly Scale = 1.0.</p>
<p id="rfc.section.13.5.3.p.2">Another case is when the content itself consists of spliced pieces or is dynamically updated. In these cases the server may be required to change from one supported scale value (different than Scale=1.0) to another. In this case the server will pick the closest value and inform the client of what it has picked. In these case the media properties will also be sent updating the supported Scale values. This enables a client to adjust the used Scale value.</p>
<p id="rfc.section.13.5.3.p.3">To minimize impact on playback in any of the above cases the server MUST modify the playback properties and set Scale to a supportable value and continue delivery the media. When doing this modification it MUST send a PLAY_NOTIFY message with the Notify-Reason header set to "scale-change". The request MUST contain a Range header with the media time where the change took effect, a Scale header with the new value in use, Session header with the ID for the session it applies to and a Date header with the server wallclock time of the change. For time progressing content also the Media-Range and the Media-Properties at this point in time MUST be included. The Media-Properties header MUST be included if the scale change was due to the content changing what scale values that is supported.</p>
<p id="rfc.section.13.5.3.p.4">For media streams being delivered using RTP also a RTP-Info header MUST be included. It MUST contain the rtptime parameter with a value corresponding to the point of change in that media and optionally also the sequence number.</p>
<p id="rfc.section.13.5.3.p.5">A PLAY_NOTIFY request with Notify-Reason header set to "Scale-Change" MUST NOT carry a message body.</p>
<div id="#rfc.figure.17"></div>
<pre>  S-&gt;C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0
        Date: Tue, 14 Apr 2008 15:48:06 GMT
        CSeq: 854
        Notify-Reason: scale-change
        Session: uZ3ci0K+Ld-M
        Media-Properties: Time-Progressing, 
              Time-Limited=20080415T153919.36Z, Random-Access=5.0
        Media-Range: npt=0-1:37:21.394
        Range: npt=1:37:21.394-
        Scale: 1
        RTP-Info: url="rtsp://example.com/fizzle/foo/audio"
            ssrc=0D12F123:rtptime=2345962545

  C-&gt;S: RTSP/2.0 200 OK
        CSeq: 854
        User-Agent: PhonyClient/1.2
        Session: uZ3ci0K+Ld-M</pre>
<p></p>
<h1 id="rfc.section.13.6">
<a href="#rfc.section.13.6">13.6.</a> <a href="#sec_PAUSE" id="sec_PAUSE">PAUSE</a>
</h1>
<p id="rfc.section.13.6.p.1">The PAUSE request causes the stream delivery to immediately be interrupted (halted). A PAUSE request MUST be done either with the aggregated control URI for aggregated sessions, resulting in all media being halted, or the media URI for non-aggregated sessions. Any attempt to do muting of a single media with an PAUSE request in an aggregated session MUST be responded to with error 460 (Only Aggregate Operation Allowed). After resuming playback, synchronization of the tracks MUST be maintained. Any server resources are kept, though servers MAY close the session and free resources after being paused for the duration specified with the timeout parameter of the Session header in the SETUP message.</p>
<div id="#rfc.figure.18"></div>
<pre>
  C-&gt;S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 834
        Session: 12345678
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 834
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Range: npt=45.76-75.00</pre>
<p id="rfc.section.13.6.p.2">Example: </p>
<p id="rfc.section.13.6.p.3">The PAUSE request causes stream delivery to be interrupted immediately on receipt of the message and the pause point is set to the current point in the presentation. That pause point in the media stream needs to be maintained. A subsequent PLAY request without Range header resume from the pause point and play until media end.</p>
<div id="#rfc.figure.19"></div>
<pre>  C-&gt;S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 834
        Session: 12345678
        Range: npt=10-30
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 834
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Server: PhonyServer/1.0
        Range: npt=10-30
        Seek-Style: First-Prior
        RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=5712;rtptime=934207921,
                url="rtsp://example.com/fizzle/videotrack"
                ssrc=4FAD8726:seq=57654;rtptime=2792482193
        Session: 12345678

After 11 seconds, i.e. at 21 seconds into the presentation:
  C-&gt;S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 835
        Session: 12345678
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 835
        Date: 23 Jan 1997 15:35:09 GMT
        Server: PhonyServer/1.0
        Range: npt=21-30
        Session: 12345678</pre>
<p id="rfc.section.13.6.p.4">The pause point after any PAUSE request MUST be returned to the client by adding a Range header with what remains unplayed of the PLAY request's range. For media with random access properties, if one desires to resume playing a ranged request, one simply includes the Range header from the PAUSE response and include the Seek-Style header with the Next policy in the PLAY request. For media that is time-progressing and has retention duration=0 the follow-up PLAY request to start media delivery again, will need to use "npt=now-" and not the answer given in the response to PAUSE. </p>
<div id="#rfc.figure.20"></div>
<pre>
  C-&gt;S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 834
        Session: 12345678
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 834
        Session: 12345678
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Range: npt=45.76-98.36

  C-&gt;S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 835
        Session: 12345678
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 835
        Session: 12345678
        Date: 23 Jan 1997 15:35:07 GMT
        Range: npt=45.76-98.36</pre>
<p id="rfc.section.13.6.p.5">If a client issues a PAUSE request and the server acknowledges and enters the Ready state, the proper server response, if the player issues another PAUSE, is still 200 OK. The 200 OK response MUST include the Range header with the current pause point. See examples below: </p>
<h1 id="rfc.section.13.7">
<a href="#rfc.section.13.7">13.7.</a> <a href="#sec_TEARDOWN" id="sec_TEARDOWN">TEARDOWN</a>
</h1>
<p></p>
<h1 id="rfc.section.13.7.1">
<a href="#rfc.section.13.7.1">13.7.1.</a> Client to Server</h1>
<p id="rfc.section.13.7.1.p.1">The TEARDOWN client to server request stops the stream delivery for the given URI, freeing the resources associated with it. A TEARDOWN request MAY be performed on either an aggregated or a media control URI. However, some restrictions apply depending on the current state. The TEARDOWN request MUST contain a Session header indicating what session the request applies to.</p>
<p id="rfc.section.13.7.1.p.2">A TEARDOWN using the aggregated control URI or the media URI in a session under non-aggregated control (single media session) MAY be done in any state (Ready and Play). A successful request MUST result in that media delivery being immediately halted and the session state being destroyed. This MUST be indicated through the lack of a Session header in the response.</p>
<p id="rfc.section.13.7.1.p.3">A TEARDOWN using a media URI in an aggregated session MAY only be done in Ready state. Such a request only removes the indicated media stream and associated resources from the session. This may result in that a session returns to non-aggregated control, due to that it only contains a single media after the requests completion. A session that will exist after the processing of the TEARDOWN request MUST in the response to that TEARDOWN request contain a Session header. Thus the presence of the Session header indicates to the receiver of the response if the session is still existing or has been removed.</p>
<div id="#rfc.figure.21"></div>
<pre>
  C-&gt;S: TEARDOWN rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 892
        Session: 12345678
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 892
        Server: PhonyServer/1.0</pre>
<p id="rfc.section.13.7.1.p.4">Example: </p>
<p></p>
<h1 id="rfc.section.13.7.2">
<a href="#rfc.section.13.7.2">13.7.2.</a> Server to Client</h1>
<p id="rfc.section.13.7.2.p.1">The server can send TEARDOWN requests in the server to client direction to indicate that the server has been forced to terminate the ongoing session. This may happen for several reasons, such as server maintenance without available backup, or that the session has been inactive for extended periods of time. The reason is provided in the <a href="#sec_Terminate-Reason">Terminate-Reason header</a> <cite title="NONE">[sec_Terminate-Reason]</cite>.</p>
<p id="rfc.section.13.7.2.p.2">When a RTSP client has maintained a RTSP session that otherwise is inactive for an extended period of time the server may reclaim the resources. That is done by issuing a TEARDOWN request with the Terminate-Reason set to "Session-Timeout". This MAY be done when the client has been inactive in the RTSP session for more than one <a href="#sec_Session">Session Timeout period</a> <cite title="NONE">[sec_Session]</cite>. However, the server is RECOMMENDED to not perform this operation until an extended period of inactivity has passed. The time period is considered extended when it is 10 times the Session Timeout period.  Consideration of the application of the server and its content should be performed when configuring what is considered as extended periods of time.</p>
<p id="rfc.section.13.7.2.p.3">In case the server needs to stop providing service to the established sessions and their is no server to point at in a REDIRECT request TEARDOWN shall be used to terminate the session.  This method can also be used when non-recoverable internal errors have happened and the server has no other option then to terminate the sessions.</p>
<p id="rfc.section.13.7.2.p.4">The TEARDOWN request MUST be only done on the session aggregate control URI (i.e., it is not allowed to terminate individual media streams) and MUST include the following headers; Session and Terminate-Reason headers. The request only applies to the session identified in the Session header. The server may include a message to the client's user with the "user-msg" parameter.</p>
<p id="rfc.section.13.7.2.p.5">The TEARDOWN request may alternatively be done on the wild card URI * and without any session header. The scope of such a request is limited to the next-hop (i.e. the RTSP agent in direct communication with the server) and applies, as well, to the control connection between the next-hop RTSP agent and the server. This request indicates that all sessions and pending requests being managed via the control connection are terminated. Any intervening proxies SHOULD do all of the following in the order listed: </p>

<ol>
<li>respond to the TEARDOWN request</li>
<li>disconnect the control channel from the requesting server</li>
<li>pass the TEARDOWN request to each applicable client (typically those clients with an active session or an unanswered request)</li>
</ol>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: The proxy is responsible for accepting TEARDOWN responses from its clients; these responses MUST NOT be passed on to either the original server or the target server in the redirect.</dd>
</dl>
<p></p>
<h1 id="rfc.section.13.8">
<a href="#rfc.section.13.8">13.8.</a> <a href="#sec_GET_PARAMETER" id="sec_GET_PARAMETER">GET_PARAMETER</a>
</h1>
<p id="rfc.section.13.8.p.1">The GET_PARAMETER request retrieves the value of any specified parameter or parameters for a presentation or stream specified in the URI. If the Session header is present in a request, the value of a parameter MUST be retrieved in the specified session context. There are two ways of specifying the parameters to be retrieved. The first is by including headers which have been defined such that you can use them for this purpose. Headers for this purpose should allow empty, or stripped value parts to avoid having to specify bogus data when indicating the desire to retrieve a value. The successful completion of the request should also be evident from any filled out values in the response. The <a href="#sec_Media-Range">Media-Range header</a> <cite title="NONE">[sec_Media-Range]</cite> is one such header. The other way is to specify a message body that lists the parameter(s) that are desired to be retrieved. The <a href="#sec_Content-Type">Content-Type header</a> <cite title="NONE">[sec_Content-Type]</cite> is used to specify which format the message body has.</p>
<p id="rfc.section.13.8.p.2">The headers that MAY be used for retrieving their current value using GET_PARAMETER are:</p>

<ul>
<li>Accept-Ranges</li>
<li>Media-Range</li>
<li>Media-Properties</li>
<li>Range</li>
<li>RTP-Info</li>
</ul>

<p>The method MAY also be used without a message body or any header that request parameters for keep-alive purpose. Any request that is successful, i.e., a 200 OK response is received, then the keep-alive timer has been updated. Any non-required header present in such a request may or may not been processed. Normally the presence of filled out values in the header will be indication that the header has been processed. However, for cases when this is difficult to determine, it is recommended to use a feature-tag and the Require header. Due to this reason it is usually easier if any parameters to be retrieved are sent in the body, rather than using any header.</p>
<p id="rfc.section.13.8.p.3">Parameters specified within the body of the message must all be understood by the request receiving agent. If one or more parameters are not understood a 451 (Parameter Not Understood) MUST be sent including a body listing these parameters that weren't understood. If all parameters are understood their values are filled in and returned in the response message body.</p>
<div id="#rfc.figure.22"></div>
<pre>
  S-&gt;C: GET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 431
        User-Agent: PhonyClient/1.2
        Session: 12345678
        Content-Length: 26
        Content-Type: text/parameters
        
        packets_received
        jitter

  C-&gt;S: RTSP/2.0 200 OK
        CSeq: 431
        Session: 12345678
        Server: PhonyServer/1.1
        Date: Mon, 08 Mar 2010 13:43:23 GMT 
        Content-Length: 38
        Content-Type: text/parameters

        packets_received: 10
        jitter: 0.3838</pre>
<p id="rfc.section.13.8.p.4">Example: </p>
<p></p>
<h1 id="rfc.section.13.9">
<a href="#rfc.section.13.9">13.9.</a> <a href="#sec_SET_PARAMETER" id="sec_SET_PARAMETER">SET_PARAMETER</a>
</h1>
<p id="rfc.section.13.9.p.1">This method requests to set the value of a parameter or a set of parameters for a presentation or stream specified by the URI. The method MAY also be used without a message body. It is the RECOMMENDED method to be used in a request sent for the sole purpose of updating the keep-alive timer. If this request is successful, i.e. a 200 OK response is received, then the keep-alive timer has been updated. Any non-required header present in such a request may or may not been processed. To allow a client to determine if any such header has been processed, it is necessary to use a feature tag and the Require header. Due to this reason it is RECOMMENDED that any parameters are sent in the body, rather than using any header.</p>
<p id="rfc.section.13.9.p.2">A request is RECOMMENDED to only contain a single parameter to allow the client to determine why a particular request failed. If the request contains several parameters, the server MUST only act on the request if all of the parameters can be set successfully. A server MUST allow a parameter to be set repeatedly to the same value, but it MAY disallow changing parameter values. If the receiver of the request does not understand or cannot locate a parameter, error 451 (Parameter Not Understood) MUST be used. In the case a parameter is not allowed to change, the error code is 458 (Parameter Is Read-Only). The response body MUST contain only the parameters that have errors.  Otherwise no body MUST be returned.</p>
<p id="rfc.section.13.9.p.3">Note: transport parameters for the media stream MUST only be set with the SETUP command.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Restricting setting transport parameters to SETUP is for the benefit of firewalls.</dd>
</dl>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The parameters are split in a fine-grained fashion so that there can be more meaningful error indications. However, it may make sense to allow the setting of several parameters if an atomic setting is desirable. Imagine device control where the client does not want the camera to pan unless it can also tilt to the right angle at the same time.</dd>
</dl>
<div id="#rfc.figure.23"></div>
<pre>
  C-&gt;S: SET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 421
        User-Agent: PhonyClient/1.2
        Session: iixT43KLc
        Date: Mon, 08 Mar 2010 14:45:04 GMT
        Content-length: 20
        Content-type: text/parameters

        barparam: barstuff

  S-&gt;C: RTSP/2.0 451 Parameter Not Understood
        CSeq: 421
        Session: iixT43KLc
        Server: PhonyServer/1.0
        Date: Mon, 08 Mar 2010 14:44:56 GMT
        Content-length: 10
        Content-type: text/parameters

        barparam: barstuff</pre>
<p id="rfc.section.13.9.p.6">Example: </p>
<p></p>
<h1 id="rfc.section.13.10">
<a href="#rfc.section.13.10">13.10.</a> <a href="#sec_REDIRECT" id="sec_REDIRECT">REDIRECT</a>
</h1>
<p id="rfc.section.13.10.p.1">The REDIRECT method is issued by a server to inform a client that the service provided will be terminated and where a corresponding service can be provided instead. This may happen for different reasons. One is that the server is being administrated such that it must stop providing service. Thus the client is required to connect to another server location to access the resource indicated by the Request-URI.</p>
<p id="rfc.section.13.10.p.2">The REDIRECT request SHALL contain a <a href="#sec_Terminate-Reason">Terminate-Reason header</a> <cite title="NONE">[sec_Terminate-Reason]</cite> to inform the client of the reason for the request. Additional parameters related to the reason may also be included. The intention here is to allow a server administrator to do a controlled shutdown of the RTSP server. That requires sufficient time to inform all entities having associated state with the server and for them to perform a controlled migration from this server to a fall back server.</p>
<p id="rfc.section.13.10.p.3">A REDIRECT request with a Session header has end-to-end (i.e.  server to client) scope and applies only to the given session. Any intervening proxies SHOULD NOT disconnect the control channel while there are other remaining end-to-end sessions. The REQUIRED Location header MUST contain a complete absolute URI pointing to the resource to which the client SHOULD reconnect. Specifically, the Location MUST NOT contain just the host and port. A client may receive a REDIRECT request with a Session header, if and only if, an end-to-end session has been established.</p>
<p id="rfc.section.13.10.p.4">A client may receive a REDIRECT request without a Session header at any time when it has communication or a connection established with a server. The scope of such a request is limited to the next-hop (i.e.  the RTSP agent in direct communication with the server) and applies to all sessions controlled, as well as the control connection between the next-hop RTSP agent and the server. A REDIRECT request without a Session header indicates that all sessions and pending requests being managed via the control connection MUST be redirected. The REQUIRED Location header, if included in such a request, SHOULD contain an absolute URI with only the host address and the OPTIONAL port number of the server to which the RTSP agent SHOULD reconnect. Any intervening proxies SHOULD do all of the following in the order listed: </p>

<ol>
<li>respond to the REDIRECT request</li>
<li>disconnect the control channel from the requesting server</li>
<li>connect to the server at the given host address</li>
<li>pass the REDIRECT request to each applicable client (typically those clients with an active session or an unanswered request)</li>
</ol>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: The proxy is responsible for accepting REDIRECT responses from its clients; these responses MUST NOT be passed on to either the original server or the redirected server.</dd>
</dl>
<p id="rfc.section.13.10.p.6">When the server lacks any alternative server and needs to terminate a session or all sessions the TEARDOWN request SHALL be used instead.</p>
<p id="rfc.section.13.10.p.7">When no Terminate-Reason "time" parameter are included in a REDIRECT request, the client SHALL perform the redirection immediately and return a response to the server. The server shall consider the session as terminated and can free any associated state after it receives the successful (2xx) response. The server MAY close the signaling connection upon receiving the response and the client SHOULD close the signaling connection after sending the 2xx response. The exception to this is when the client has several sessions on the server being managed by the given signaling connection. In this case, the client SHOULD close the connection when it has received and responded to REDIRECT requests for all the sessions managed by the signaling connection.</p>
<p id="rfc.section.13.10.p.8">The Terminate-Reason header "time" parameter MAY be used to indicate the wallclock time by when the redirection MUST have take place. To allow a client to determine that redirect time without being time synchronized with the server, the server MUST include a Date header in the request. The client should have before the redirection time-line terminated the session and close the control connection. The server MAY simple cease to provide service when the deadline time has been reached, or it may issue TEARDOWN requests to the remaining sessions.</p>
<p id="rfc.section.13.10.p.9">If the REDIRECT request times out following the rules in <a href="#sec_connection-timeout">Section 10.4</a> the server MAY terminate the session or transport connection that would be redirected by the request. This is a safeguard against misbehaving clients that refuse to respond to a REDIRECT request. That should not provide any benefit.</p>
<p id="rfc.section.13.10.p.10">After a REDIRECT request has been processed, a client that wants to continue to send or receive media for the resource identified by the Request-URI will have to establish a new session with the designated host. If the URI given in the Location header is a valid resource URI, a client SHOULD issue a DESCRIBE request for the URI.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: The media resource indicated by the Location header can be identical, slightly different or totally different. This is the reason why a new DESCRIBE request SHOULD be issued.</dd>
</dl>
<p id="rfc.section.13.10.p.12">If the Location header contains only a host address, the client MAY assume that the media on the new server is identical to the media on the old server, i.e. all media configuration information from the old session is still valid except for the host address. However, the usage of conditional SETUP using MTag identifiers are RECOMMENDED to verify the assumption.</p>
<div id="#rfc.figure.24"></div>
<pre>
  S-&gt;C: REDIRECT rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 732
        Location: rtsp://s2.example.com:8001
        Terminate-Reason: Server-Admin ;time=19960213T143205Z
        Session: uZ3ci0K+Ld-M
        Date: Thu, 13 Feb 1996 14:30:43 GMT

  C-&gt;S: RTSP/2.0 200 OK
        CSeq: 732
        User-Agent: PhonyClient/1.2
        Session: uZ3ci0K+Ld-M</pre>
<p id="rfc.section.13.10.p.13">This example request redirects traffic for this session to the new server at the given absolute time: </p>
<p></p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#sec_binary" id="sec_binary">Embedded (Interleaved) Binary Data</a>
</h1>
<p id="rfc.section.14.p.1">In order to fulfill certain requirements on the network side, e.g. in conjunction with network address translators that block RTP traffic over UDP, it may be necessary to interleave RTSP messages and media stream data. This interleaving should generally be avoided unless necessary since it complicates client and server operation and imposes additional overhead. Also, head of line blocking may cause problems. Interleaved binary data SHOULD only be used if RTSP is carried over TCP. Interleaved data is not allowed inside RTSP messages.</p>
<div id="#rfc.figure.25"></div>
<pre>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | "$" = 36      | Channel ID    | Length in bytes               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   : Length number of bytes of binary data                         :
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre>
<p id="rfc.section.14.p.2">Stream data such as RTP packets is encapsulated by an ASCII dollar sign (36 decimal), followed by a one-byte channel identifier, followed by the length of the encapsulated binary data as a binary, two-byte integer in network byte order. The stream data follows immediately afterwards, without a CRLF, but including the upper-layer protocol headers. Each $ block MUST contain exactly one upper-layer protocol data unit, e.g., one RTP packet. </p>
<p id="rfc.section.14.p.3">The channel identifier is defined in the Transport header with the interleaved parameter (<a href="#sec_Transport">Section 16.52</a>).</p>
<p id="rfc.section.14.p.4">When the transport choice is RTP, RTCP messages are also interleaved by the server over the TCP connection. The usage of RTCP messages is indicated by including a interval containing a second channel in the interleaved parameter of the Transport header, see <a href="#sec_Transport">Section 16.52</a>. If RTCP is used, packets MUST be sent on the first available channel higher than the RTP channel. The channels are bi-directional, using the same ChannelD in both directions, and therefore RTCP traffic are sent on the second channel in both directions.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">RTCP is sometime needed for synchronization when two or more streams are interleaved in such a fashion. Also, this provides a convenient way to tunnel RTP/RTCP packets through the TCP control connection when required by the network configuration and transfer them onto UDP when possible.</dd>
</dl>
<div id="#rfc.figure.26"></div>
<pre>
  C-&gt;S: SETUP rtsp://example.com/bar.file RTSP/2.0
        CSeq: 2
        Transport: RTP/AVP/TCP;unicast;interleaved=0-1
        Accept-Ranges: NPT, SMPTE, UTC
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 2
        Date: Thu, 05 Jun 1997 18:57:18 GMT
        Transport: RTP/AVP/TCP;unicast;interleaved=5-6
        Session: 12345678
        Accept-Ranges: NPT
        Media-Properties: Random-Access=0.2, Immutable, Unlimited

  C-&gt;S: PLAY rtsp://example.com/bar.file RTSP/2.0
        CSeq: 3
        Session: 12345678
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 3
        Session: 12345678
        Date: Thu, 05 Jun 1997 18:57:19 GMT
        RTP-Info: url="rtsp://example.com/bar.file"
          ssrc=0D12F123:seq=232433;rtptime=972948234
        Range: npt=0-56.8
        Seek-Style: RAP

  S-&gt;C: $005{2 byte length}{"length" bytes data, w/RTP header}
  S-&gt;C: $005{2 byte length}{"length" bytes data, w/RTP header}
  S-&gt;C: $006{2 byte length}{"length" bytes  RTCP packet}</pre>
<p></p>
<h1 id="rfc.section.15">
<a href="#rfc.section.15">15.</a> <a href="#sec_status" id="sec_status">Status Code Definitions</a>
</h1>
<p id="rfc.section.15.p.1">Where applicable, HTTP status [H10] codes are reused. Status codes that have the same meaning are not repeated here. See <a href="#tab_status">Table 4</a> for a listing of which status codes may be returned by which requests. All error messages, 4xx and 5xx MAY return a body containing further information about the error.</p>
<h1 id="rfc.section.15.1">
<a href="#rfc.section.15.1">15.1.</a> Success 1xx</h1>
<h1 id="rfc.section.15.1.1">
<a href="#rfc.section.15.1.1">15.1.1.</a> 100 Continue</h1>
<p id="rfc.section.15.1.1.p.1">The client SHOULD continue with its request. This interim response is used to inform the client that the initial part of the request has been received and has not yet been rejected by the server. The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The server MUST send a final response after the request has been completed.</p>
<h1 id="rfc.section.15.2">
<a href="#rfc.section.15.2">15.2.</a> Success 2xx</h1>
<p id="rfc.section.15.2.p.1">This class of status code indicates that the client's request was successfully received, understood, and accepted.</p>
<h1 id="rfc.section.15.2.1">
<a href="#rfc.section.15.2.1">15.2.1.</a> 200 OK</h1>
<p id="rfc.section.15.2.1.p.1">The request has succeeded. The information returned with the response is dependent on the method used in the request.</p>
<h1 id="rfc.section.15.3">
<a href="#rfc.section.15.3">15.3.</a> <a href="#sec_status-redirect" id="sec_status-redirect">Redirection 3xx</a>
</h1>
<p id="rfc.section.15.3.p.1">The notation "3rr" indicates response codes from 300 to 399 inclusive which are meant for redirection. The response code 304 is excluded from this set, as it is not used for redirection.</p>
<p id="rfc.section.15.3.p.2">Within RTSP, redirection may be used for load balancing or redirecting stream requests to a server topologically closer to the client. Mechanisms to determine topological proximity are beyond the scope of this specification.</p>
<p id="rfc.section.15.3.p.3">A 3rr code MAY be used to respond to any request. It is RECOMMENDED that they are used if necessary before a session is established, i.e., in response to DESCRIBE or SETUP. However, in cases where a server is not able to send a REDIRECT request to the client, the server MAY need to resort to using 3rr responses to inform a client with an established session about the need for redirecting the session. If a 3rr response is received for a request in relation to an established session, the client SHOULD send a TEARDOWN request for the session, and MAY reestablish the session using the resource indicated by the Location.</p>
<p id="rfc.section.15.3.p.4">If the Location header is used in a response it MUST contain an absolute URI pointing out the media resource the client is redirected to, the URI MUST NOT only contain the host name.</p>
<h1 id="rfc.section.15.3.1">
<a href="#rfc.section.15.3.1">15.3.1.</a> 301 Moved Permanently</h1>
<p id="rfc.section.15.3.1.p.1">The request resource are moved permanently and resides now at the URI given by the location header. The user client SHOULD redirect automatically to the given URI. This response MUST NOT contain a message-body. The Location header MUST be included in the response.</p>
<h1 id="rfc.section.15.3.2">
<a href="#rfc.section.15.3.2">15.3.2.</a> 302 Found</h1>
<p id="rfc.section.15.3.2.p.1">The requested resource resides temporarily at the URI given by the Location header. The Location header MUST be included in the response. This response is intended to be used for many types of temporary redirects; e.g., load balancing. It is RECOMMENDED that the server set the reason phrase to something more meaningful than "Found" in these cases. The user client SHOULD redirect automatically to the given URI. This response MUST NOT contain a message-body.</p>
<div id="#rfc.figure.27"></div>
<pre>
  C-&gt;S: SETUP rtsp://example.com/fizzle/foo RTSP/2.0
        CSeq: 2
        Transport: RTP/AVP/TCP;unicast;interleaved=0-1
        Accept-Ranges: NPT, SMPTE, UTC
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 302 Try Other Server
        CSeq: 2
        Location: rtsp://s2.example.com:8001/fizzle/foo</pre>
<p id="rfc.section.15.3.2.p.2">This example shows a client being redirected to a different server: </p>
<h1 id="rfc.section.15.3.3">
<a href="#rfc.section.15.3.3">15.3.3.</a> 303 See Other</h1>
<p id="rfc.section.15.3.3.p.1">This status code MUST NOT be used in RTSP 2.0. However, it was allowed to use in RTSP 1.0 (RFC 2326).</p>
<h1 id="rfc.section.15.3.4">
<a href="#rfc.section.15.3.4">15.3.4.</a> 304 Not Modified</h1>
<p id="rfc.section.15.3.4.p.1">If the client has performed a conditional DESCRIBE or SETUP (see <a href="#sec_If-Modified-Since">Section 16.24</a>) and the requested resource has not been modified, the server SHOULD send a 304 response. This response MUST NOT contain a message-body.</p>
<p id="rfc.section.15.3.4.p.2">The response MUST include the following header fields: </p>

<ul>
<li>Date</li>
<li>MTag and/or Content-Location, if the header(s) would have been sent in a 200 response to the same request.</li>
<li>Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same variant.</li>
</ul>
<p id="rfc.section.15.3.4.p.3">This response is independent for the DESCRIBE and SETUP requests.  That is, a 304 response to DESCRIBE does NOT imply that the resource content is unchanged (only the session description) and a 304 response to SETUP does NOT imply that the resource description is unchanged. The MTag and If-Match headers may be used to link the DESCRIBE and SETUP in this manner.</p>
<h1 id="rfc.section.15.3.5">
<a href="#rfc.section.15.3.5">15.3.5.</a> 305 Use Proxy</h1>
<p id="rfc.section.15.3.5.p.1">The requested resource MUST be accessed through the proxy given by the Location field. The Location field gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 responses MUST only be generated by origin servers.</p>
<h1 id="rfc.section.15.4">
<a href="#rfc.section.15.4">15.4.</a> Client Error 4xx</h1>
<h1 id="rfc.section.15.4.1">
<a href="#rfc.section.15.4.1">15.4.1.</a> 400 Bad Request</h1>
<p id="rfc.section.15.4.1.p.1">The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications. If the request does not have a CSeq header, the server MUST NOT include a CSeq in the response.</p>
<h1 id="rfc.section.15.4.2">
<a href="#rfc.section.15.4.2">15.4.2.</a> <a href="#sec_error401" id="sec_error401">401 Unauthorized</a>
</h1>
<p id="rfc.section.15.4.2.p.1">The request requires user authentication. The response MUST include a <a href="#sec_WWW-Authenticate">WWW-Authenticate header</a> <cite title="NONE">[sec_WWW-Authenticate]</cite> field containing a challenge applicable to the requested resource. The client MAY repeat the request with a suitable Authorization header field. If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials. If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the message body that was given in the response, since that message body might include relevant diagnostic information. HTTP access authentication is explained in <a href="#RFC2617">[RFC2617]</a>.</p>
<h1 id="rfc.section.15.4.3">
<a href="#rfc.section.15.4.3">15.4.3.</a> 402 Payment Required</h1>
<p id="rfc.section.15.4.3.p.1">This code is reserved for future use.</p>
<h1 id="rfc.section.15.4.4">
<a href="#rfc.section.15.4.4">15.4.4.</a> 403 Forbidden</h1>
<p id="rfc.section.15.4.4.p.1">The server understood the request, but is refusing to fulfill it.  Authorization will not help and the request SHOULD NOT be repeated.  If the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the message body. If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used instead.</p>
<h1 id="rfc.section.15.4.5">
<a href="#rfc.section.15.4.5">15.4.5.</a> 404 Not Found</h1>
<p id="rfc.section.15.4.5.p.1">The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent. The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address.  This status code is commonly used when the server does not wish to reveal exactly why the request has been refused, or when no other response is applicable.</p>
<h1 id="rfc.section.15.4.6">
<a href="#rfc.section.15.4.6">15.4.6.</a> 405 Method Not Allowed</h1>
<p id="rfc.section.15.4.6.p.1">The method specified in the request is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource. This status code is also to be used if a request attempts to use a method not indicated during SETUP.</p>
<h1 id="rfc.section.15.4.7">
<a href="#rfc.section.15.4.7">15.4.7.</a> 406 Not Acceptable</h1>
<p id="rfc.section.15.4.7.p.1">The resource identified by the request is only capable of generating response message bodies which have content characteristics not acceptable according to the accept headers sent in the request.</p>
<p id="rfc.section.15.4.7.p.2">The response SHOULD include an message body containing a list of available message body characteristics and location(s) from which the user or user agent can choose the one most appropriate. The message body format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection.</p>
<p id="rfc.section.15.4.7.p.3">If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query the user for a decision on further actions.</p>
<h1 id="rfc.section.15.4.8">
<a href="#rfc.section.15.4.8">15.4.8.</a> 407 Proxy Authentication Required</h1>
<p id="rfc.section.15.4.8.p.1">This code is similar to <a href="#sec_error401">401 (Unauthorized)</a> <cite title="NONE">[sec_error401]</cite>, but indicates that the client must first authenticate itself with the proxy. The proxy MUST return a <a href="#sec_Proxy-Authenticate">Proxy-Authenticate header field</a> <cite title="NONE">[sec_Proxy-Authenticate]</cite> containing a challenge applicable to the proxy for the requested resource.</p>
<h1 id="rfc.section.15.4.9">
<a href="#rfc.section.15.4.9">15.4.9.</a> 408 Request Timeout</h1>
<p id="rfc.section.15.4.9.p.1">The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.</p>
<h1 id="rfc.section.15.4.10">
<a href="#rfc.section.15.4.10">15.4.10.</a> 410 Gone</h1>
<p id="rfc.section.15.4.10.p.1">The requested resource is no longer available at the server and the forwarding address is not known. This condition is expected to be considered permanent. If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead. This response is cacheable unless indicated otherwise.</p>
<p id="rfc.section.15.4.10.p.2">The 410 response is primarily intended to assist the task of repository maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server's site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time -- that is left to the discretion of the owner of the server.</p>
<h1 id="rfc.section.15.4.11">
<a href="#rfc.section.15.4.11">15.4.11.</a> 411 Length Required</h1>
<p id="rfc.section.15.4.11.p.1">The server refuses to accept the request without a defined Content- Length. The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request message.</p>
<h1 id="rfc.section.15.4.12">
<a href="#rfc.section.15.4.12">15.4.12.</a> 412 Precondition Failed</h1>
<p id="rfc.section.15.4.12.p.1">The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server. This response code allows the client to place preconditions on the current resource meta information (header field data) and thus prevent the requested method from being applied to a resource other than the one intended.</p>
<h1 id="rfc.section.15.4.13">
<a href="#rfc.section.15.4.13">15.4.13.</a> 413 Request Message Body Too Large</h1>
<p id="rfc.section.15.4.13.p.1">The server is refusing to process a request because the request message body is larger than the server is willing or able to process. The server MAY close the connection to prevent the client from continuing the request.</p>
<p id="rfc.section.15.4.13.p.2">If the condition is temporary, the server SHOULD include a Retry- After header field to indicate that it is temporary and after what time the client MAY try again.</p>
<h1 id="rfc.section.15.4.14">
<a href="#rfc.section.15.4.14">15.4.14.</a> 414 Request-URI Too Long</h1>
<p id="rfc.section.15.4.14.p.1">The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret. This rare condition is only likely to occur when a client has used a request with long query information, when the client has descended into a URI "black hole" of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some servers using fixed-length buffers for reading or manipulating the Request-URI.</p>
<h1 id="rfc.section.15.4.15">
<a href="#rfc.section.15.4.15">15.4.15.</a> 415 Unsupported Media Type</h1>
<p id="rfc.section.15.4.15.p.1">The server is refusing to service the request because the message body of the request is in a format not supported by the requested resource for the requested method.</p>
<h1 id="rfc.section.15.4.16">
<a href="#rfc.section.15.4.16">15.4.16.</a> 451 Parameter Not Understood</h1>
<p id="rfc.section.15.4.16.p.1">The recipient of the request does not support one or more parameters contained in the request. When returning this error message the sender SHOULD return a message body containing the offending parameter(s).</p>
<h1 id="rfc.section.15.4.17">
<a href="#rfc.section.15.4.17">15.4.17.</a> 452 reserved</h1>
<p id="rfc.section.15.4.17.p.1">This error code was removed from RFC 2326 <a href="#RFC2326">[RFC2326]</a> as it is obsolete. This error code MUST NOT be used anymore.</p>
<h1 id="rfc.section.15.4.18">
<a href="#rfc.section.15.4.18">15.4.18.</a> 453 Not Enough Bandwidth</h1>
<p id="rfc.section.15.4.18.p.1">The request was refused because there was insufficient bandwidth.  This may, for example, be the result of a resource reservation failure.</p>
<h1 id="rfc.section.15.4.19">
<a href="#rfc.section.15.4.19">15.4.19.</a> 454 Session Not Found</h1>
<p id="rfc.section.15.4.19.p.1">The RTSP session identifier in the Session header is missing, invalid, or has timed out.</p>
<h1 id="rfc.section.15.4.20">
<a href="#rfc.section.15.4.20">15.4.20.</a> 455 Method Not Valid in This State</h1>
<p id="rfc.section.15.4.20.p.1">The client or server cannot process this request in its current state. The response MUST contain an Allow header to make error recovery possible.</p>
<h1 id="rfc.section.15.4.21">
<a href="#rfc.section.15.4.21">15.4.21.</a> 456 Header Field Not Valid for Resource</h1>
<p id="rfc.section.15.4.21.p.1">The server could not act on a required request header. For example, if PLAY contains the Range header field but the stream does not allow seeking. This error message may also be used for specifying when the time format in Range is impossible for the resource. In that case the Accept-Ranges header MUST be returned to inform the client of which format(s) that are allowed.</p>
<h1 id="rfc.section.15.4.22">
<a href="#rfc.section.15.4.22">15.4.22.</a> 457 Invalid Range</h1>
<p id="rfc.section.15.4.22.p.1">The Range value given is out of bounds, e.g., beyond the end of the presentation.</p>
<h1 id="rfc.section.15.4.23">
<a href="#rfc.section.15.4.23">15.4.23.</a> 458 Parameter Is Read-Only</h1>
<p id="rfc.section.15.4.23.p.1">The parameter to be set by SET_PARAMETER can be read but not modified. When returning this error message the sender SHOULD return a message body containing the offending parameter(s).</p>
<h1 id="rfc.section.15.4.24">
<a href="#rfc.section.15.4.24">15.4.24.</a> <a href="#sec_error459" id="sec_error459">459 Aggregate Operation Not Allowed</a>
</h1>
<p id="rfc.section.15.4.24.p.1">The requested method may not be applied on the URI in question since it is an aggregate (presentation) URI. The method may be applied on a media URI.</p>
<h1 id="rfc.section.15.4.25">
<a href="#rfc.section.15.4.25">15.4.25.</a> <a href="#sec_error460" id="sec_error460">460 Only Aggregate Operation Allowed</a>
</h1>
<p id="rfc.section.15.4.25.p.1">The requested method may not be applied on the URI in question since it is not an aggregate control (presentation) URI. The method may be applied on the aggregate control URI.</p>
<h1 id="rfc.section.15.4.26">
<a href="#rfc.section.15.4.26">15.4.26.</a> <a href="#sec_error461" id="sec_error461">461 Unsupported Transport</a>
</h1>
<p id="rfc.section.15.4.26.p.1">The Transport field did not contain a supported transport specification.</p>
<h1 id="rfc.section.15.4.27">
<a href="#rfc.section.15.4.27">15.4.27.</a> 462 Destination Unreachable</h1>
<p id="rfc.section.15.4.27.p.1">The data transmission channel could not be established because the client address could not be reached. This error will most likely be the result of a client attempt to place an invalid dest_addr parameter in the Transport field.</p>
<h1 id="rfc.section.15.4.28">
<a href="#rfc.section.15.4.28">15.4.28.</a> 463 Destination Prohibited</h1>
<p id="rfc.section.15.4.28.p.1">The data transmission channel was not established because the server prohibited access to the client address. This error is most likely the result of a client attempt to redirect media traffic to another destination with a dest_addr parameter in the Transport header.</p>
<h1 id="rfc.section.15.4.29">
<a href="#rfc.section.15.4.29">15.4.29.</a> <a href="#sec_error464" id="sec_error464">464 Data Transport Not Ready Yet</a>
</h1>
<p id="rfc.section.15.4.29.p.1">The data transmission channel to the media destination is not yet ready for carrying data. However, the responding agent still expects that the data transmission channel will be established at some point in time. Note, however, that this may result in a permanent failure like 462 "Destination Unreachable".</p>
<p id="rfc.section.15.4.29.p.2">An example when this error may occur is in the case a client sends a PLAY request to a server prior to ensuring that the TCP connections negotiated for carrying media data was successful established (In violation of this specification). The server would use this error code to indicate that the requested action could not be performed due to the failure of completing the connection establishment.</p>
<h1 id="rfc.section.15.4.30">
<a href="#rfc.section.15.4.30">15.4.30.</a> <a href="#sec_error465" id="sec_error465">465 Notification Reason Unknown</a>
</h1>
<p id="rfc.section.15.4.30.p.1">This indicates that the client has received a <a href="#sec_PLAY_NOTIFY">PLAY_NOTIFY</a> <cite title="NONE">[sec_PLAY_NOTIFY]</cite> with a <a href="#sec_Notify-Reason">Notify-Reason header</a> <cite title="NONE">[sec_Notify-Reason]</cite> unknown to the client.</p>
<h1 id="rfc.section.15.4.31">
<a href="#rfc.section.15.4.31">15.4.31.</a> 466 Key Management Error</h1>
<p id="rfc.section.15.4.31.p.1">This indicates that there has been an error in a Key Management function used in conjunction with a request. For example usage of MIKEY according to <a href="#sec-mikey">Appendix Appendix C.1.4.1</a> may result in this error.</p>
<h1 id="rfc.section.15.4.32">
<a href="#rfc.section.15.4.32">15.4.32.</a> 470 Connection Authorization Required</h1>
<p id="rfc.section.15.4.32.p.1">The secured connection attempt needs user or client authorization before proceeding. The next hops certificate is included in this response in the Accept-Credentials header.</p>
<h1 id="rfc.section.15.4.33">
<a href="#rfc.section.15.4.33">15.4.33.</a> 471 Connection Credentials not accepted</h1>
<p id="rfc.section.15.4.33.p.1">When performing a secure connection over multiple connections, a intermediary has refused to connect to the next hop and carry out the request due to unacceptable credentials for the used policy.</p>
<h1 id="rfc.section.15.4.34">
<a href="#rfc.section.15.4.34">15.4.34.</a> 472 Failure to establish secure connection</h1>
<p id="rfc.section.15.4.34.p.1">A proxy fails to establish a secure connection to the next hop RTSP agent. This is primarily caused by a fatal failure at the TLS handshake, for example due to server not accepting any cipher suits.</p>
<h1 id="rfc.section.15.5">
<a href="#rfc.section.15.5">15.5.</a> Server Error 5xx</h1>
<p id="rfc.section.15.5.p.1">Response status codes beginning with the digit "5" indicate cases in which the server is aware that it has erred or is incapable of performing the request The server SHOULD include an message body containing an explanation of the error situation, and whether it is a temporary or permanent condition. User agents SHOULD display any included message body to the user. These response codes are applicable to any request method.</p>
<h1 id="rfc.section.15.5.1">
<a href="#rfc.section.15.5.1">15.5.1.</a> 500 Internal Server Error</h1>
<p id="rfc.section.15.5.1.p.1">The server encountered an unexpected condition which prevented it from fulfilling the request.</p>
<h1 id="rfc.section.15.5.2">
<a href="#rfc.section.15.5.2">15.5.2.</a> 501 Not Implemented</h1>
<p id="rfc.section.15.5.2.p.1">The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.</p>
<h1 id="rfc.section.15.5.3">
<a href="#rfc.section.15.5.3">15.5.3.</a> 502 Bad Gateway</h1>
<p id="rfc.section.15.5.3.p.1">The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.</p>
<h1 id="rfc.section.15.5.4">
<a href="#rfc.section.15.5.4">15.5.4.</a> <a href="#sec_error_503" id="sec_error_503">503 Service Unavailable</a>
</h1>
<p id="rfc.section.15.5.4.p.1">The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition which will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response. The client MUST honor the length, if given in the Retry-After header.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 6">Note: The existence of the 503 status code does not imply that a server must use it when becoming overloaded. Some servers may wish to simply refuse the connection.</dd>
</dl>
<h1 id="rfc.section.15.5.5">
<a href="#rfc.section.15.5.5">15.5.5.</a> 504 Gateway Timeout</h1>
<p id="rfc.section.15.5.5.p.1">The server, while acting as a proxy, did not receive a timely response from the upstream server specified by the URI or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request.</p>
<h1 id="rfc.section.15.5.6">
<a href="#rfc.section.15.5.6">15.5.6.</a> 505 RTSP Version Not Supported</h1>
<p id="rfc.section.15.5.6.p.1">The server does not support, or refuses to support, the RTSP protocol version that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client other than with this error message. The response SHOULD contain an message body describing why that version is not supported and what other protocols are supported by that server.</p>
<h1 id="rfc.section.15.5.7">
<a href="#rfc.section.15.5.7">15.5.7.</a> 551 Option not supported</h1>
<p id="rfc.section.15.5.7.p.1">A feature-tag given in the Require or the Proxy-Require fields was not supported. The Unsupported header MUST be returned stating the feature for which there is no support.</p>
<h1 id="rfc.section.16">
<a href="#rfc.section.16">16.</a> <a href="#sec_headers" id="sec_headers">Header Field Definitions</a>
</h1>
<div id="#rfc.table.8"></div>
<div id="#tab_methods2"></div>
<p></p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Overview of RTSP methods, their direction, and what objects (P: presentation, S: stream) they operate on. Body notes if a method is allowed to carry body and in which direction, R = Request, r=response. Note: It is allowed for all error messages 4xx and 5xx to have a body</caption>
<thead><tr>
<th class="left">method</th>
<th class="left">direction</th>
<th class="left">object</th>
<th class="left">acronym</th>
<th class="left">Body</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DESCRIBE</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">DES</td>
<td class="left">r</td>
</tr>
<tr>
<td class="left">GET_PARAMETER</td>
<td class="left">C -&gt; S, S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">GPR</td>
<td class="left">R,r</td>
</tr>
<tr>
<td class="left">OPTIONS</td>
<td class="left">C -&gt; S, S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">OPT</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">PAUSE</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">PSE</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">PLY</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">PLAY_NOTIFY</td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">PNY</td>
<td class="left">R</td>
</tr>
<tr>
<td class="left">REDIRECT</td>
<td class="left">S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">RDR</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">C -&gt; S</td>
<td class="left">S</td>
<td class="left">STP</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">SET_PARAMETER</td>
<td class="left">C -&gt; S, S -&gt; C</td>
<td class="left">P,S</td>
<td class="left">SPR</td>
<td class="left">R,r</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">C -&gt; S</td>
<td class="left">P,S</td>
<td class="left">TRD</td>
<td class="left"></td>
</tr>
<tr>
<td class="left"></td>
<td class="left">S -&gt; C</td>
<td class="left">P</td>
<td class="left">TRD</td>
<td class="left"></td>
</tr>
</tbody>
</table>
<p id="rfc.section.16.p.2">The general syntax for header fields is covered in <a href="#sec_message-headers">Section 5.2</a>. This section lists the full set of header fields along with notes on meaning, and usage. The syntax definition for header fields are present in <a href="#sec_syntax-prot-header">Section 20.2.3</a>. Throughout this section, we use [HX.Y] to informational refer to Section X.Y of the current HTTP/1.1 specification RFC 2616 <a href="#RFC2616">[RFC2616]</a>. Examples of each header field are given.</p>
<p id="rfc.section.16.p.3">Information about header fields in relation to methods and proxy processing is summarized in <a href="#tab_headers1a">Table 9</a>, <a href="#tab_headers1b">Table 10</a>, <a href="#tab_headers2a">Table 11</a>, and <a href="#tab_headers2b">Table 12</a>.</p>
<p id="rfc.section.16.p.4">The "where" column describes the request and response types in which the header field can be used. Values in this column are: </p>

<dl>
<dt>R:</dt>
<dd style="margin-left: 6">header field may only appear in requests;</dd>
<dt>r:</dt>
<dd style="margin-left: 6">header field may only appear in responses;</dd>
<dt>2xx, 4xx, etc.:</dt>
<dd style="margin-left: 6">A numerical value or range indicates response codes with which the header field can be used;</dd>
<dt>c:</dt>
<dd style="margin-left: 6">header field is copied from the request to the response.</dd>
</dl>
<p id="rfc.section.16.p.5">An empty entry in the "where" column indicates that the header field may be present in both requests and responses.</p>
<p id="rfc.section.16.p.6">The "proxy" column describes the operations a proxy may perform on a header field. An empty proxy column indicates that the proxy MUST NOT do any changes to that header, all allowed operations are explicitly stated: </p>

<dl>
<dt>a:</dt>
<dd style="margin-left: 6">A proxy can add or concatenate the header field if not present.</dd>
<dt>m:</dt>
<dd style="margin-left: 6">A proxy can modify an existing header field value.</dd>
<dt>d:</dt>
<dd style="margin-left: 6">A proxy can delete a header field value.</dd>
<dt>r:</dt>
<dd style="margin-left: 6">A proxy needs to be able to read the header field, and thus this header field cannot be encrypted.</dd>
</dl>
<p id="rfc.section.16.p.7">The rest of the columns relate to the presence of a header field in a method. The method names when abbreviated, are according to <a href="#tab_methods2">Table 8</a>: </p>

<dl>
<dt>c:</dt>
<dd style="margin-left: 6">Conditional; requirements on the header field depend on the context of the message.</dd>
<dt>m:</dt>
<dd style="margin-left: 6">The header field is mandatory.</dd>
<dt>m*:</dt>
<dd style="margin-left: 6">The header field SHOULD be sent, but clients/servers need to be prepared to receive messages without that header field.</dd>
<dt>o:</dt>
<dd style="margin-left: 6">The header field is optional.</dd>
<dt>*:</dt>
<dd style="margin-left: 6">The header field MUST be present if the message body is not empty. See <a href="#sec_Content-Length">Section 16.16</a>, <a href="#sec_Content-Type">Section 16.18</a> and <a href="#sec_message-body">Section 5.3</a> for details.</dd>
<dt>-:</dt>
<dd style="margin-left: 6">The header field is not applicable.</dd>
</dl>
<p id="rfc.section.16.p.8">"Optional" means that a Client/Server MAY include the header field in a request or response. The Client/Server behavior when receiving such headers varies, for some it may ignore the header field, in other case it is request to process the header. This is regulated by the method and header descriptions. Example of headers that require processing are the Require and Proxy-Require header fields discussed in <a href="#sec_Require">Section 16.41</a> and <a href="#sec_Proxy-Require">Section 16.35</a>. A "mandatory" header field MUST be present in a request, and MUST be understood by the Client/Server receiving the request. A mandatory response header field MUST be present in the response, and the header field MUST be understood by the Client/Server processing the response. "Not applicable" means that the header field MUST NOT be present in a request. If one is placed in a request by mistake, it MUST be ignored by the Client/Server receiving the request. Similarly, a header field labeled "not applicable" for a response means that the Client/Server MUST NOT place the header field in the response, and the Client/Server MUST ignore the header field in the response.</p>
<p id="rfc.section.16.p.9">An RTSP agent MUST ignore extension headers that are not understood.</p>
<p id="rfc.section.16.p.10">The From and Location header fields contain an URI. If the URI contains a comma, or semicolon, the URI MUST be enclosed in double quotes ("). Any URI parameters are contained within these quotes. If the URI is not enclosed in double quotas, any semicolon- delimited parameters are header-parameters, not URI parameters.</p>
<div id="#rfc.table.9"></div>
<div id="#tab_headers1a"></div>
<p></p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Overview of RTSP header fields (A-L) related to methods DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN.</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Where</th>
<th class="left">Proxy</th>
<th class="left">DES</th>
<th class="left">OPT</th>
<th class="left">STP</th>
<th class="left">PLY</th>
<th class="left">PSE</th>
<th class="left">TRD</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Accept</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Credentials</td>
<td class="left">R</td>
<td class="left">rm</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Accept-Encoding</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Language</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Ranges</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Ranges</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Ranges</td>
<td class="left">456</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Allow</td>
<td class="left">r</td>
<td class="left">am</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Allow</td>
<td class="left">405</td>
<td class="left">am</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Authorization</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Bandwidth</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Blocksize</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Cache-Control</td>
<td class="left"></td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Connection</td>
<td class="left"></td>
<td class="left">ad</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Connection-Credentials</td>
<td class="left">470,407</td>
<td class="left">ar</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Base</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Base</td>
<td class="left">4xx,5xx</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Length</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">*</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Length</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">Content-Location</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Location</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Type</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">*</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Type</td>
<td class="left">4xx,5xx</td>
<td class="left">ar</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">CSeq</td>
<td class="left">Rc</td>
<td class="left">rm</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Date</td>
<td class="left"></td>
<td class="left">am</td>
<td class="left">o/*</td>
<td class="left">o/*</td>
<td class="left">o/*</td>
<td class="left">o/*</td>
<td class="left">o/*</td>
<td class="left">o/*</td>
</tr>
<tr>
<td class="left">Expires</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">From</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">If-Match</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">If-Modified-Since</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">If-None-Match</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Last-Modified</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Location</td>
<td class="left">3rr</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
</tbody>
</table>
<div id="#rfc.table.10"></div>
<div id="#tab_headers1b"></div>
<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Overview of RTSP header fields (P-W) related to methods DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN.</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Where</th>
<th class="left">Proxy</th>
<th class="left">DES</th>
<th class="left">OPT</th>
<th class="left">STP</th>
<th class="left">PLY</th>
<th class="left">PSE</th>
<th class="left">TRD</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Media- Properties</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Media-Range</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">MTag</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Pipelined- Requests</td>
<td class="left"></td>
<td class="left">amdr</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Proxy- Authenticate</td>
<td class="left">407</td>
<td class="left">amr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Proxy- Authorization</td>
<td class="left">R</td>
<td class="left">rd</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Proxy- Require</td>
<td class="left">R</td>
<td class="left">ar</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Proxy- Require</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Proxy- Supported</td>
<td class="left">R</td>
<td class="left">amr</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Proxy- Supported</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Public</td>
<td class="left">r</td>
<td class="left">amr</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Public</td>
<td class="left">501</td>
<td class="left">amr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Range</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Range</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Terminate-Reason</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Referrer</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Request- Status</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Require</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Retry-After</td>
<td class="left">3rr,503</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Retry-After</td>
<td class="left">413</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">RTP-Info</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Scale</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Scale</td>
<td class="left">r</td>
<td class="left">amr</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Seek-Style</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Seek-Style</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Server</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Server</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Session</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Session</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">c</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Speed</td>
<td class="left">R</td>
<td class="left">admr</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Speed</td>
<td class="left">r</td>
<td class="left">admr</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Supported</td>
<td class="left">R</td>
<td class="left">amr</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Supported</td>
<td class="left">r</td>
<td class="left">amr</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Timestamp</td>
<td class="left">R</td>
<td class="left">admr</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Timestamp</td>
<td class="left">c</td>
<td class="left">admr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Transport</td>
<td class="left"></td>
<td class="left">mr</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Unsupported</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">User-Agent</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">m*</td>
</tr>
<tr>
<td class="left">Vary</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Via</td>
<td class="left">R</td>
<td class="left">amr</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Via</td>
<td class="left">c</td>
<td class="left">dr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">WWW- Authenticate</td>
<td class="left">401</td>
<td class="left"></td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
</tbody>
</table>
<div id="#rfc.table.11"></div>
<div id="#tab_headers2a"></div>
<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Overview of RTSP header fields (A-P) related to methods GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY.</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Where</th>
<th class="left">Proxy</th>
<th class="left">GPR</th>
<th class="left">SPR</th>
<th class="left">RDR</th>
<th class="left">PNY</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Accept</td>
<td class="left">R</td>
<td class="left">arm</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Credentials</td>
<td class="left">R</td>
<td class="left">rm</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Accept-Ranges</td>
<td class="left"></td>
<td class="left">rm</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Allow</td>
<td class="left">405</td>
<td class="left">amr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Authorization</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Bandwidth</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Blocksize</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Connection</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Cache-Control</td>
<td class="left"></td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Connection-Credentials</td>
<td class="left">470,407</td>
<td class="left">ar</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Base</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Base</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Base</td>
<td class="left">4xx,5xx</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Encoding</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Language</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Length</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Length</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Length</td>
<td class="left">4xx,5xx</td>
<td class="left">r</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">Content-Location</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Location</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Location</td>
<td class="left">4xx,5xx</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Content-Type</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Type</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Content-Type</td>
<td class="left">4xx,5xx</td>
<td class="left"></td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
<td class="left">*</td>
</tr>
<tr>
<td class="left">CSeq</td>
<td class="left">R,c</td>
<td class="left">mr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Date</td>
<td class="left">R</td>
<td class="left">a</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">m</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Date</td>
<td class="left">r</td>
<td class="left">am</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">If-Modified-Since</td>
<td class="left">R</td>
<td class="left">am</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">If-None-Match</td>
<td class="left">R</td>
<td class="left">am</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">From</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Last-Modified</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Last-Modified</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Location</td>
<td class="left">3rr</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Location</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Media-Properties</td>
<td class="left">R</td>
<td class="left">amr</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Media-Properties</td>
<td class="left">r</td>
<td class="left">mr</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Media-Range</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Media-Range</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Notify-Reason</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Pipelined-Requests</td>
<td class="left">R</td>
<td class="left">amdr</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Proxy-Authenticate</td>
<td class="left">407</td>
<td class="left">amr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Proxy-Authorization</td>
<td class="left">R</td>
<td class="left">rd</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Proxy-Require</td>
<td class="left">R</td>
<td class="left">ar</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Proxy-Require</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Proxy-Supported</td>
<td class="left">R</td>
<td class="left">amr</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Proxy-Supported</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Public</td>
<td class="left">501</td>
<td class="left">admr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
</tbody>
</table>
<div id="#rfc.table.12"></div>
<div id="#tab_headers2b"></div>
<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Overview of RTSP header fields (R-W) related to methods GET_PARAMETER, SET_PARAMETER,  REDIRECT, and PLAY_NOTIFY.</caption>
<thead><tr>
<th class="left">Header</th>
<th class="left">Where</th>
<th class="left">Proxy</th>
<th class="left">GPR</th>
<th class="left">SPR</th>
<th class="left">RDR</th>
<th class="left">PNY</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Range</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">o</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Referrer</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Request-Status</td>
<td class="left">R</td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Require</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Retry-After</td>
<td class="left">3rr,503</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Retry-After</td>
<td class="left">413</td>
<td class="left"></td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">RTP-Info</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">C</td>
</tr>
<tr>
<td class="left">RTP-Info</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Scale</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">c</td>
</tr>
<tr>
<td class="left">Seek-Style</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Session</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Session</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">o</td>
<td class="left">m</td>
</tr>
<tr>
<td class="left">Server</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
</tr>
<tr>
<td class="left">Server</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Speed</td>
<td class="left"></td>
<td class="left"></td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Supported</td>
<td class="left">R</td>
<td class="left">adrm</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Supported</td>
<td class="left">r</td>
<td class="left">adrm</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Terminate-Reason</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">-</td>
<td class="left">-</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Timestamp</td>
<td class="left">R</td>
<td class="left">adrm</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Timestamp</td>
<td class="left">c</td>
<td class="left">adrm</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Unsupported</td>
<td class="left">r</td>
<td class="left">arm</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">User-Agent</td>
<td class="left">R</td>
<td class="left">r</td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">User-Agent</td>
<td class="left">r</td>
<td class="left">r</td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">m*</td>
<td class="left">m*</td>
</tr>
<tr>
<td class="left">Vary</td>
<td class="left">r</td>
<td class="left"></td>
<td class="left">c</td>
<td class="left">c</td>
<td class="left">-</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Via</td>
<td class="left">R</td>
<td class="left">amr</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">o</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">Via</td>
<td class="left">c</td>
<td class="left">dr</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
<tr>
<td class="left">WWW-Authenticate</td>
<td class="left">401</td>
<td class="left"></td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">m</td>
<td class="left">-</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.16.1">
<a href="#rfc.section.16.1">16.1.</a> <a href="#sec_Accept" id="sec_Accept">Accept</a>
</h1>
<p id="rfc.section.16.1.p.1">The Accept request-header field can be used to specify certain presentation description and parameter <a href="#RFC4288">media types</a> <cite title="NONE">[RFC4288]</cite> which are acceptable for the response to DESCRIBE and GET_PARAMETER requests.</p>
<p id="rfc.section.16.1.p.2">See <a href="#sec_syntax-prot-header">Section 20.2.3</a> for the syntax.</p>
<div id="#rfc.figure.28"></div>
<pre>  Accept: application/example ;q=1.0, application/sdp
</pre>
<p id="rfc.section.16.1.p.3">Example of use: </p>
<h1 id="rfc.section.16.2">
<a href="#rfc.section.16.2">16.2.</a> <a href="#sec_Accept-Credentials" id="sec_Accept-Credentials">Accept-Credentials</a>
</h1>
<p id="rfc.section.16.2.p.1">The Accept-Credentials header is a request header used to indicate to any trusted intermediary how to handle further secured connections to proxies or servers. See <a href="#sec_security-framework">Section 19</a> for the usage of this header.  It MUST NOT be included in server to client requests.</p>
<p id="rfc.section.16.2.p.2">In a request the header MUST contain the method (User, Proxy, or Any) for approving credentials selected by the requester. The method MUST NOT be changed by any proxy, unless it is "proxy" when a proxy MAY change it to "user" to take the role of user approving each further hop. If the method is "User" the header contains zero or more of credentials that the client accepts. The header may contain zero credentials in the first RTSP request to a RTSP server when using the "User" method. This as the client has not yet received any credentials to accept. Each credential MUST consist of one URI identifying the proxy or server, the hash algorithm identifier, and the hash over that agent's DER encoded certificate <a href="#RFC5280">[RFC5280]</a> in <a href="#RFC4648">Base64</a> <cite title="NONE">[RFC4648]</cite>. All RTSP clients and proxies MUST implement the SHA-256<a href="#FIPS-pub-180-2">[FIPS-pub-180-2]</a> algorithm for computation of the hash of the DER encoded certificate.  The SHA-256 algorithm is identified by the token "sha-256".</p>
<p id="rfc.section.16.2.p.3">The intention with allowing for other hash algorithms is to enable the future retirement of algorithms that are not implemented somewhere else than here. Thus the definition of future algorithms for this purpose is intended to be extremely limited. A feature tag can be used to ensure that support for the replacement algorithm exist.</p>
<div id="#rfc.figure.29"></div>
<pre>  Accept-Credentials:User
    "rtsps://proxy2.example.com/";sha-256;exaIl9VMbQMOFGClx5rXnPJKVNI=,
    "rtsps://server.example.com/";sha-256;lurbjj5khhB0NhIuOXtt4bBRH1M=
</pre>
<p id="rfc.section.16.2.p.4">Example: </p>
<h1 id="rfc.section.16.3">
<a href="#rfc.section.16.3">16.3.</a> <a href="#sec_Accept-Encoding" id="sec_Accept-Encoding">Accept-Encoding</a>
</h1>
<p id="rfc.section.16.3.p.1">The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings, i.e. transformation codings of the message body like gzip compression, that are acceptable in the response.</p>
<p id="rfc.section.16.3.p.2">A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules:</p>
<p></p>

<ol>
<li>If the content-coding is one of the content-codings listed in the Accept-Encoding field, then it is acceptable, unless it is accompanied by a qvalue of 0. (As defined in section 3.9, a qvalue of 0 means "not acceptable.")</li>
<li>The special "*" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.</li>
<li>If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.</li>
<li>The "identity" content-coding is always acceptable, i.e. no transformation at all, unless specifically refused because the Accept-Encoding field includes "identity;q=0", or because the field includes "*;q=0" and does not explicitly include the "identity" content-coding. If the Accept-Encoding field-value is empty, then only the "identity" encoding is acceptable.</li>
</ol>

<p>If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code.</p>
<p id="rfc.section.16.3.p.4">If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding. In this case, if "identity" is one of the available content-codings, then the server SHOULD use the "identity" content-coding, unless it has additional information that a different content-coding is meaningful to the client.</p>
<h1 id="rfc.section.16.4">
<a href="#rfc.section.16.4">16.4.</a> <a href="#sec_Accept-Language" id="sec_Accept-Language">Accept-Language</a>
</h1>
<p id="rfc.section.16.4.p.1">The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Note that the language specified applies to the presentation description and any reason phrases, but not the media content.</p>
<p id="rfc.section.16.4.p.2">A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded. The syntax and registry of RTSP 2.0 language tags is the same as that defined by <a href="#RFC5646">[RFC5646]</a>.</p>
<p id="rfc.section.16.4.p.3">Each language-range MAY be given an associated quality value which represents an estimate of the user's preference for the languages specified by that range. The quality value defaults to "q=1". For example:</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Accept-Language: da, en-gb;q=0.8, en;q=0.7</dd>
</dl>
<p id="rfc.section.16.4.p.5">would mean: "I prefer Danish, but will accept British English and other types of English." A language-range matches a language-tag if it exactly equals the tag, or if it exactly equals a prefix of the tag such that the first tag character following the prefix is "-". The special range "*", if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always true that if a user understands a language with a certain tag, then this user will also understand all languages with tags for which this tag is a prefix. The prefix rule simply allows the use of prefix tags if this is the case.</dd>
</dl>

<p>The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language-range in the field that matches the language-tag. If no language-range in the field matches the tag, the language quality factor assigned is 0. If no Accept-Language header is present in the request, the server SHOULD assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages which are assigned a quality factor greater than 0 are acceptable.</p>
<h1 id="rfc.section.16.5">
<a href="#rfc.section.16.5">16.5.</a> <a href="#sec_Accept-Ranges" id="sec_Accept-Ranges">Accept-Ranges</a>
</h1>
<div id="#rfc.figure.30"></div>
<pre>
   Accept-Ranges: NPT, SMPTE</pre>
<p id="rfc.section.16.5.p.1">The Accept-Ranges general-header field allows indication of the format supported in the Range header. The client MUST include the header in SETUP requests to indicate which formats it support to receive in PLAY and PAUSE responses, and REDIRECT requests. The server MUST include the header in SETUP and 456 error responses to indicate the formats supported for the resource indicated by the request URI.  The header MAY be included in GET_PARAMETER request and response pairs. The GET_PARAMETER request MUST contain a Session header to identify the session context the request are related to. The requester and responder will indicate their capabilities regarding Range formats respectively. </p>
<p id="rfc.section.16.5.p.2">The syntax is defined in <a href="#sec_syntax-prot-header">Section 20.2.3</a>.</p>
<h1 id="rfc.section.16.6">
<a href="#rfc.section.16.6">16.6.</a> <a href="#sec_Allow" id="sec_Allow">Allow</a>
</h1>
<p id="rfc.section.16.6.p.1">The Allow message-header field lists the methods supported by the resource identified by the Request-URI. The purpose of this field is to strictly inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. The Allow header MUST also be present in all OPTIONS responses where the content of the header will not include exactly the same methods as listed in the Public header.</p>
<p id="rfc.section.16.6.p.2">The Allow MUST also be included in SETUP and DESCRIBE responses, if the methods allowed for the resource is different than the minimal implementation set.</p>
<div id="#rfc.figure.31"></div>
<pre>   Allow: SETUP, PLAY, SET_PARAMETER, DESCRIBE
</pre>
<p id="rfc.section.16.6.p.3">Example of use: </p>
<h1 id="rfc.section.16.7">
<a href="#rfc.section.16.7">16.7.</a> <a href="#sec_Authorization" id="sec_Authorization">Authorization</a>
</h1>
<p id="rfc.section.16.7.p.1">An RTSP client that wishes to authenticate itself with a server using <a href="#RFC2617">authentication mechanism from HTTP</a> <cite title="NONE">[RFC2617]</cite> , usually, but not necessarily, after receiving a 401 response, does so by including an Authorization request-header field with the request. The Authorization field value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.</p>
<p id="rfc.section.16.7.p.2">If a request is authenticated and a realm specified, the same credentials SHOULD be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).</p>
<p id="rfc.section.16.7.p.3">When a shared cache (see <a href="#sec_caching">Section 18</a>) receives a request containing an Authorization field, it MUST NOT return the corresponding response as a reply to any other request, unless one of the following specific exceptions holds:</p>
<p></p>

<ol>
<li>If the response includes the "max-age" cache-control directive, the cache MAY use that response in replying to a subsequent request. But (if the specified maximum age has passed) a proxy cache MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request. (This is the defined behavior for max-age.) If the response includes "max-age=0", the proxy MUST always revalidate it before re-using it.</li>
<li>If the response includes the "must-revalidate" cache-control directive, the cache MAY use that response in replying to a subsequent request. But if the response is stale, all caches MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request.</li>
<li>If the response includes the "public" cache-control directive, it MAY be returned in reply to any subsequent request.</li>
</ol>
<h1 id="rfc.section.16.8">
<a href="#rfc.section.16.8">16.8.</a> <a href="#sec_Bandwidth" id="sec_Bandwidth">Bandwidth</a>
</h1>
<p id="rfc.section.16.8.p.1">The Bandwidth request-header field describes the estimated bandwidth available to the client, expressed as a positive integer and measured in kilobits per second. The bandwidth available to the client may change during an RTSP session, e.g., due to mobility, congestion, etc.</p>
<p id="rfc.section.16.8.p.2">Clients may not be able to accurately determine the available bandwidth, for example due to that first hop is not a bottleneck. For example most local area networks (LAN) will not be a bottleneck if the server is not in the same LAN. Thus link speeds of WLAN or Ethernet networks are normally not a basis for estimating the available bandwidth. Cellular devices or other devices directly connected to an modem or connection enabling device may more accurately estimate the bottleneck bandwidth and what is reasonable share of it for RTSP controlled media. The client will also need to take into account other traffic sharing the bottleneck. For example by only assigning a certain fraction to RTSP and its media streams. It is RECOMMENDED that only clients that has accurate and explicit information about bandwidth bottlenecks uses this header.</p>
<p id="rfc.section.16.8.p.3">This header is not a substitute for proper congestion control. Only a method providing an initial estimate and coarsely determine if the selected content can be delivered at all.</p>
<div id="#rfc.figure.32"></div>
<pre>  Bandwidth: 62360</pre>
<p id="rfc.section.16.8.p.4">Example: </p>
<h1 id="rfc.section.16.9">
<a href="#rfc.section.16.9">16.9.</a> <a href="#sec_Blocksize" id="sec_Blocksize">Blocksize</a>
</h1>
<p id="rfc.section.16.9.p.1">The Blocksize request-header field is sent from the client to the media server asking the server for a particular media packet size.  This packet size does not include lower-layer headers such as IP, UDP, or RTP. The server is free to use a blocksize which is lower than the one requested. The server MAY truncate this packet size to the closest multiple of the minimum, media-specific block size, or override it with the media-specific size if necessary. The block size MUST be a positive decimal number, measured in octets. The server only returns an error (4xx) if the value is syntactically invalid.</p>
<h1 id="rfc.section.16.10">
<a href="#rfc.section.16.10">16.10.</a> <a href="#sec_Cache-Control" id="sec_Cache-Control">Cache-Control</a>
</h1>
<p id="rfc.section.16.10.p.1">The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.</p>
<p id="rfc.section.16.10.p.2">Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives may be applicable to all recipients along the request/response chain. It is not possible to specify a cache-directive for a specific cache.</p>
<p id="rfc.section.16.10.p.3">Cache-Control should only be specified in a DESCRIBE, GET_PARAMETER, SET_PARAMETER and SETUP request and its response. Note: Cache-Control does not govern only the caching of responses as for HTTP, instead it also applies to the media stream identified by the SETUP request. The RTSP requests are generally not cacheable, for further information see <a href="#sec_caching">Section 18</a>. Below is the description of the cache directives that can be included in the Cache-Control header.</p>
<p></p>

<dl>
<dt>no-cache:</dt>
<dd style="margin-left: 6">Indicates that the media stream MUST NOT be cached anywhere. This allows an origin server to prevent caching even by caches that have been configured to return stale responses to client requests. Note, there is no security function enforcing that the content can't be cached.</dd>
<dt>public:</dt>
<dd style="margin-left: 6">Indicates that the media stream is cacheable by any cache.</dd>
<dt>private:</dt>
<dd style="margin-left: 6">Indicates that the media stream is intended for a single user and MUST NOT be cached by a shared cache. A private (non-shared) cache may cache the media streams.</dd>
<dt>no-transform:</dt>
<dd style="margin-left: 6">An intermediate cache (proxy) may find it useful to convert the media type of a certain stream. A proxy might, for example, convert between video formats to save cache space or to reduce the amount of traffic on a slow link. Serious operational problems may occur, however, when these transformations have been applied to streams intended for certain kinds of applications. For example, applications for medical imaging, scientific data analysis and those using end-to-end authentication all depend on receiving a stream that is bit-for-bit identical to the original media stream. Therefore, if a response includes the no-transform directive, an intermediate cache or proxy MUST NOT change the encoding of the stream. Unlike HTTP, RTSP does not provide for partial transformation at this point, e.g., allowing translation into a different language.</dd>
<dt>only-if-cached:</dt>
<dd style="margin-left: 6">In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those media streams that it currently has stored, and not to receive these from the origin server. To do this, the client may include the only-if-cached directive in a request. If it receives this directive, a cache SHOULD either respond using a cached media stream that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status.  However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.</dd>
<dt>max-stale:</dt>
<dd style="margin-left: 6">Indicates that the client is willing to accept a media stream that has exceeded its expiration time. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.</dd>
<dt>min-fresh:</dt>
<dd style="margin-left: 6">Indicates that the client is willing to accept a media stream whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.</dd>
<dt>must-revalidate:</dt>
<dd style="margin-left: 6">When the must-revalidate directive is present in a SETUP response received by a cache, that cache MUST NOT use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. That is, the cache is required to do an end-to-end revalidation every time, if, based solely on the origin server's Expires, the cached response is stale.)</dd>
<dt>proxy-revalidate:</dt>
<dd style="margin-left: 6">The proxy-revalidate directive has the same meaning as the must-revalidate directive, except that it does not apply to non-shared user agent caches. It can be used on a response to an authenticated request to permit the user's cache to store and later return the response without needing to revalidate it (since it has already been authenticated once by that user), while still requiring proxies that service many users to revalidate each time (in order to make sure that each user has been authenticated). Note that such authenticated responses also need the public cache control directive in order to allow them to be cached at all.</dd>
<dt>max-age:</dt>
<dd style="margin-left: 6">When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with the cache entry. In this case, the cache MAY use either validator in making its own request without affecting semantic transparency.</dd>
</dl>

<p>However, the choice of validator might affect performance.  The best approach is for the intermediate cache to use its own validator when making its request. If the server replies with 304 (Not Modified), then the cache can return its now validated copy to the client with a 200 (OK) response. If the server replies with a new message body and cache validator, however, the intermediate cache can compare the returned validator with the one provided in the client's request, using the strong comparison function. If the client's validator is equal to the origin server's, then the intermediate cache simply returns 304 (Not Modified). Otherwise, it returns the new message body with a 200 (OK) response.</p>
<h1 id="rfc.section.16.11">
<a href="#rfc.section.16.11">16.11.</a> <a href="#sec_Connection" id="sec_Connection">Connection</a>
</h1>
<p id="rfc.section.16.11.p.1">The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.</p>
<p id="rfc.section.16.11.p.2">RTSP 2.0 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.</p>
<p id="rfc.section.16.11.p.3">Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control.</p>
<p id="rfc.section.16.11.p.4">RTSP 2.0 defines the "close" connection option for the sender to signal that the connection will be closed after completion of the response. For example, Connection: close in either the request or the response header fields indicates that the connection SHOULD NOT be considered <a href="#sec_connections-usage">`persistent'</a> <cite title="NONE">[sec_connections-usage]</cite> after the current request/response is complete.</p>
<p id="rfc.section.16.11.p.5">The use of the connection option "close" in RTSP messages SHOULD be limited to error messages when the server is unable to recover and therefore see it necessary to close the connection. The reason is that the client has the choice of continuing using a connection indefinitely, as long as it sends valid messages.</p>
<h1 id="rfc.section.16.12">
<a href="#rfc.section.16.12">16.12.</a> <a href="#sec_Connection-Credentials" id="sec_Connection-Credentials">Connection-Credentials</a>
</h1>
<p id="rfc.section.16.12.p.1">The Connection-Credentials response header is used to carry the chain of credentials of any next hop that need to be approved by the requester. It MUST only be used in server to client responses.</p>
<p id="rfc.section.16.12.p.2">The Connection-Credentials header in an RTSP response MUST, if included, contain the credential information (in form of a list of certificates providing the chain of certification) of the next hop that an intermediary needs to securely connect to. The header MUST include the URI of the next hop (proxy or server) and a base64 <a href="#RFC4648">[RFC4648]</a> encoded binary structure containing a sequence of DER encoded X.509v3 certificates<a href="#RFC5280">[RFC5280]</a> .</p>
<p id="rfc.section.16.12.p.3">The binary structure starts with the number of certificates (NR_CERTS) included as a 16 bit unsigned integer. This is followed by NR_CERTS number of 16 bit unsigned integers providing the size in octets of each DER encoded certificate. This is followed by NR_CERTS number of DER encoded X.509v3 certificates in a sequence (chain). The proxy or server's certificate must come first in the structure. Each following certificate must directly certify the one preceding it.  Because certificate validation requires that root keys be distributed independently, the self-signed certificate which specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.</p>
<div id="#rfc.figure.33"></div>
<pre>
Connection-Credentials:"rtsps://proxy2.example.com/";MIIDNTCC...

Where MIIDNTCC... is a BASE64 encoding of the following structure:

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Number of certificates       | Size of certificate #1        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Size of certificate #2        | Size of certificate #3        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    : DER Encoding of Certificate #1                                :
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    : DER Encoding of Certificate #2                                :
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    : DER Encoding of Certificate #3                                :
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre>
<p id="rfc.section.16.12.p.4">Example: </p>
<p></p>
<h1 id="rfc.section.16.13">
<a href="#rfc.section.16.13">16.13.</a> <a href="#sec_Content-Base" id="sec_Content-Base">Content-Base</a>
</h1>
<div id="#rfc.figure.34"></div>
<pre>
Content-Base: rtsp://media.example.com/movie/twister/
 </pre>
<p id="rfc.section.16.13.p.1">The Content-Base message-header field may be used to specify the base URI for resolving relative URIs within the message body. </p>
<h1 id="rfc.section.16.14">
<a href="#rfc.section.16.14">16.14.</a> <a href="#sec_Content-Encoding" id="sec_Content-Encoding">Content-Encoding</a>
</h1>
<p id="rfc.section.16.14.p.1">The Content-Encoding header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the message body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.</p>
<p id="rfc.section.16.14.p.2">The content-coding is a characteristic of the message body identified by the Request-URI. Typically, the message body is stored with this encoding and is only decoded before rendering or analogous usage. However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the "no-transform" cache-control directive is present in the message.</p>
<p id="rfc.section.16.14.p.3">If the content-coding of an message body is not "identity", then the response MUST include a Content-Encoding Message-body header that lists the non-identity content-coding(s) used.</p>
<p id="rfc.section.16.14.p.4">If the content-coding of an message body in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type).</p>
<p id="rfc.section.16.14.p.5">If multiple encodings have been applied to a message body, the content codings MUST be listed in the order in which they were applied, first to last from left to right. Additional information about the encoding parameters MAY be provided by other header fields not defined by this specification.</p>
<h1 id="rfc.section.16.15">
<a href="#rfc.section.16.15">16.15.</a> <a href="#sec_Content-Language" id="sec_Content-Language">Content-Language</a>
</h1>
<p id="rfc.section.16.15.p.1">The Content-Language header field describes the natural language(s) of the intended audience for the enclosed message body. Note that this might not be equivalent to all the languages used within the message body.</p>
<p id="rfc.section.16.15.p.2">Language tags are mentioned in <a href="#sec_Accept-Language">Section 16.4</a>. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user's own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Content-Language: da</dd>
</dl>

<p>If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.</p>
<p id="rfc.section.16.15.p.4">Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the "Treaty of Waitangi," presented simultaneously in the original Maori and English versions, would call for</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Content-Language: mi, en</dd>
</dl>

<p>However, just because multiple languages are present within an message body does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin," which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".</p>
<p id="rfc.section.16.15.p.6">Content-Language MAY be applied to any media type -- it is not limited to textual documents.</p>
<h1 id="rfc.section.16.16">
<a href="#rfc.section.16.16">16.16.</a> <a href="#sec_Content-Length" id="sec_Content-Length">Content-Length</a>
</h1>
<p id="rfc.section.16.16.p.1">The Content-Length general-header field contains the length of the message body of the RTSP message (i.e. after the double CRLF following the last header). Unlike HTTP, it MUST be included in all messages that carry a message body beyond the header portion of the RTSP message. If it is missing, a default value of zero is assumed. Any Content-Length greater than or equal to zero is a valid value.</p>
<h1 id="rfc.section.16.17">
<a href="#rfc.section.16.17">16.17.</a> <a href="#sec_Content-Location" id="sec_Content-Location">Content-Location</a>
</h1>
<p id="rfc.section.16.17.p.1">The Content-Location header field MAY be used to supply the resource location for the message body enclosed in the message when that body is accessible from a location separate from the requested resource's URI. A server SHOULD provide a Content-Location for the variant corresponding to the response message body; especially in the case where a resource has multiple variants associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant which is returned.</p>
<p id="rfc.section.16.17.p.2">The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular variant at the time of the request.  Future requests MAY specify the Content-Location URI as the request URI if the desire is to identify the source of that particular variant. This is useful if the RTSP agent desires verify if the resource variant is current through a conditional request.</p>
<p id="rfc.section.16.17.p.3">A cache cannot assume that an message body with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI. However, the Content- Location can be used to differentiate between multiple variants retrieved from a single requested resource.</p>
<p id="rfc.section.16.17.p.4">If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI.</p>
<p id="rfc.section.16.17.p.5">Note, that Content-Location can be used in some cases to derive the base-URI for relative URI present in session description formats. This needs to be taken into account when Content-Location is used. The easiest way to avoid needing to consider that issue is to include the Content-Base whenever the Content-Location is included.</p>
<p id="rfc.section.16.17.p.6">Note also, when using Media Tags in conjunction with Content-Location it is important that the different versions have different MTags, even if provided under different Content-Location URIs. This as they have still been provided under the same request URI.</p>
<p id="rfc.section.16.17.p.7">Note also, as in most cases as the URI used in the DESCRIBE and the SETUP requests are different the URI provided in a DESCRIBE Content-Location response can't directly be used in a SETUP request.  Instead the extra step of resolving URIs combined with the media descriptions indication, like with SDP's a=control attribute.</p>
<h1 id="rfc.section.16.18">
<a href="#rfc.section.16.18">16.18.</a> <a href="#sec_Content-Type" id="sec_Content-Type">Content-Type</a>
</h1>
<p id="rfc.section.16.18.p.1">The Content-Type header indicates the media type of the message body sent to the recipient. Note that the content types suitable for RTSP are likely to be restricted in practice to presentation descriptions and parameter-value types.</p>
<h1 id="rfc.section.16.19">
<a href="#rfc.section.16.19">16.19.</a> <a href="#sec_CSeq" id="sec_CSeq">CSeq</a>
</h1>
<p id="rfc.section.16.19.p.1">The CSeq general-header field specifies the sequence number for an RTSP request-response pair. This field MUST be present in all requests and responses. For every RTSP request containing the given sequence number, the corresponding response will have the same number. Any retransmitted request MUST contain the same sequence number as the original (i.e. the sequence number is not incremented for retransmissions of the same request). For each new RTSP request the CSeq value MUST be incremented by one. The initial sequence number MAY be any number, however, it is RECOMMENDED to start at 0. Each sequence number series is unique between each requester and responder, i.e. the client has one series for its request to a server and the server has another when sending request to the client. Each requester and responder is identified with its network address.</p>
<p id="rfc.section.16.19.p.2">Proxies that aggregate several sessions on the same transport will have to ensure that the requests sent towards a particular server have a joint sequence number space, i.e., they will regularly need to renumber the CSeq header field in requests (from proxy to server) and responses (from server to proxy) to fulfill the rules for the header.  The proxy MUST increase the CSeq by one for each request it transmits, without regard of different sessions.</p>
<div id="#rfc.figure.35"></div>
<pre>CSeq: 239</pre>
<p id="rfc.section.16.19.p.3">Example: </p>
<h1 id="rfc.section.16.20">
<a href="#rfc.section.16.20">16.20.</a> <a href="#sec_Date" id="sec_Date">Date</a>
</h1>
<p id="rfc.section.16.20.p.1">The Date header field represents the date and time at which the message was originated. The inclusion of the Date header in RTSP message follows these rules:</p>
<p></p>

<ul>
<li>An RTSP message, sent either by the client or the server, containing a body MUST include a Date header, if the sending host has a clock;</li>
<li>Clients and servers are RECOMMENDED to include a Date header in all other RTSP messages, if the sending host has a clock;</li>
<li>If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field. In this case, this rule MUST be followed: Some origin server implementations might not have a clock available. An origin server without a clock MUST NOT assign Expires or Last- Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock. It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows "pre-expiration" of responses without storing separate Expires values for each resource).</li>
</ul>
<p id="rfc.section.16.20.p.3">A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient . An RTSP implementation without a clock MUST NOT cache responses without revalidating them on every use. An RTSP cache, especially a shared cache, SHOULD use a mechanism, such as NTP, to synchronize its clock with a reliable external standard.</p>
<p id="rfc.section.16.20.p.4">The RTSP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the message body is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.</p>
<h1 id="rfc.section.16.21">
<a href="#rfc.section.16.21">16.21.</a> <a href="#sec_Expires" id="sec_Expires">Expires</a>
</h1>
<p id="rfc.section.16.21.p.1">The Expires message-header field gives a date and time after which the description or media-stream should be considered stale. The interpretation depends on the method: </p>

<dl>
<dt>DESCRIBE response:</dt>
<dd style="margin-left: 6">The Expires header indicates a date and time after which the presentation description (body) SHOULD be considered stale.</dd>
<dt>SETUP response:</dt>
<dd style="margin-left: 6">The Expires header indicate a date and time after which the media stream SHOULD be considered stale.</dd>
</dl>
<p id="rfc.section.16.21.p.2">A stale cache entry may not normally be returned by a cache (either a proxy cache or an user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the message body). See <a href="#sec_caching">Section 18</a> for further discussion of the expiration model.</p>
<p id="rfc.section.16.21.p.3">The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.</p>
<div id="#rfc.figure.36"></div>
<pre>  Expires: Thu, 01 Dec 1994 16:00:00 GMT</pre>
<p id="rfc.section.16.21.p.4">The format is an absolute date and time as defined by RTSP-date. An example of its use is </p>
<p id="rfc.section.16.21.p.5">RTSP/2.0 clients and caches MUST treat other invalid date formats, especially including the value "0", as having occurred in the past (i.e., already expired).</p>
<p id="rfc.section.16.21.p.6">To mark a response as "already expired," an origin server should use an Expires date that is equal to the Date header value. To mark a response as "never expires," an origin server SHOULD use an Expires date approximately one year from the time the response is sent.  RTSP/2.0 servers SHOULD NOT send Expires dates more than one year in the future.</p>
<h1 id="rfc.section.16.22">
<a href="#rfc.section.16.22">16.22.</a> <a href="#sec_From" id="sec_From">From</a>
</h1>
<p id="rfc.section.16.22.p.1">The From request-header field, if given, SHOULD contain an Internet e-mail address for the human user who controls the requesting user agent. The address SHOULD be machine-usable, as defined by "mailbox" in <a href="#RFC1123">[RFC1123]</a>.</p>
<p id="rfc.section.16.22.p.2">This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It SHOULD NOT be used as an insecure form of access protection. The interpretation of this field is that the request is being performed on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end.</p>
<p id="rfc.section.16.22.p.3">The Internet e-mail address in this field MAY be separate from the Internet host which issued the request. For example, when a request is passed through a proxy the original issuer's address SHOULD be used.</p>
<p id="rfc.section.16.22.p.4">The client SHOULD NOT send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request.</p>
<h1 id="rfc.section.16.23">
<a href="#rfc.section.16.23">16.23.</a> <a href="#sec_If-Match" id="sec_If-Match">If-Match</a>
</h1>
<p id="rfc.section.16.23.p.1">The If-Match request-header field is especially useful for ensuring the integrity of the presentation description, independent of how the presentation description was received. The presentation description can be fetched via means external to RTSP (such as HTTP) or via the DESCRIBE message. In the case of retrieving the presentation description via RTSP, the server implementation is guaranteeing the integrity of the description between the time of the DESCRIBE message and the SETUP message. By including the MTag given in or with the session description in a If-Match header part of the SETUP request, the client ensures that resources set up are matching the description.  A SETUP request with the If-Match header for which the MTag validation check fails, MUST response using 412 (Precondition Failed).</p>
<p id="rfc.section.16.23.p.2">This validation check is also very useful if a session has been redirected from one server to another.</p>
<h1 id="rfc.section.16.24">
<a href="#rfc.section.16.24">16.24.</a> <a href="#sec_If-Modified-Since" id="sec_If-Modified-Since">If-Modified-Since</a>
</h1>
<p id="rfc.section.16.24.p.1">The If-Modified-Since request-header field is used with the DESCRIBE and SETUP methods to make them conditional. If the requested variant has not been modified since the time specified in this field, a description will not be returned from the server (DESCRIBE) or a stream will not be set up (SETUP). Instead, a 304 (Not Modified) response MUST be returned without any message-body.</p>
<div id="#rfc.figure.37"></div>
<pre>  If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</pre>
<p id="rfc.section.16.24.p.2">An example of the field is: </p>
<h1 id="rfc.section.16.25">
<a href="#rfc.section.16.25">16.25.</a> <a href="#sec_If-None-Match" id="sec_If-None-Match">If-None-Match</a>
</h1>
<p id="rfc.section.16.25.p.1">This request header can be used with one or several message body tags to make DESCRIBE requests conditional. A client that has one or more message bodies previously obtained from the resource, can verify that none of those entities is current by including a list of their associated message body tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. As a special case, the value "*" matches any current entity of the resource.</p>
<p id="rfc.section.16.25.p.2">if any of the message body tags match the message body tag of the message body that would have been returned in the response to a similar DESCRIBE request (without the If-None-Match header) on that resource, or if "*" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request. Instead, if the request method was DESCRIBE, the server SHOULD respond with a 304 (Not Modified) response, including the cache-related header fields (particularly MTag) of one of the message bodies that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).</p>
<p id="rfc.section.16.25.p.3">See <a href="#sec.weak_strong_validators">Section 18.1.3</a> for rules on how to determine if two message body tags match.</p>
<p id="rfc.section.16.25.p.4">If none of the message body tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. That is, if no message body tags match, then the server MUST NOT return a 304 (Not Modified) response.</p>
<p id="rfc.section.16.25.p.5">If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. (See <a href="#sec.rule_entity_lastmod">Section 18.1.4</a> for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.)</p>
<p id="rfc.section.16.25.p.6">The result of a request having both an If-None-Match header field and an If-Match header field is unspecified and MUST be considered an illegal request.</p>
<h1 id="rfc.section.16.26">
<a href="#rfc.section.16.26">16.26.</a> <a href="#sec_Last-Modified" id="sec_Last-Modified">Last-Modified</a>
</h1>
<p id="rfc.section.16.26.p.1">The Last-Modified message-header field indicates the date and time at which the origin server believes the presentation description or media stream was last modified. For the method DESCRIBE, the header field indicates the last modification date and time of the description, for SETUP that of the media stream.</p>
<p id="rfc.section.16.26.p.2">An origin server MUST NOT send a Last-Modified date which is later than the server's time of message origination. In such cases, where the resource's last modification would indicate some time in the future, the server MUST replace that date with the message origination date.</p>
<p id="rfc.section.16.26.p.3">An origin server SHOULD obtain the Last-Modified value of the message body as close as possible to the time that it generates the Date value of its response. This allows a recipient to make an accurate assessment of the message body's modification time, especially if the message body changes near the time that the response is generated.</p>
<p id="rfc.section.16.26.p.4">RTSP servers SHOULD send Last-Modified whenever feasible.</p>
<h1 id="rfc.section.16.27">
<a href="#rfc.section.16.27">16.27.</a> <a href="#sec_Location" id="sec_Location">Location</a>
</h1>
<p id="rfc.section.16.27.p.1">The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. For 3xx responses, the location SHOULD indicate the server's preferred URI for automatic redirection to the resource. The field value consists of a single absolute URI.</p>
<p id="rfc.section.16.27.p.2">Note: The <a href="#sec_Content-Location">Content-Location header field</a> <cite title="NONE">[sec_Content-Location]</cite> differs from Location in that the Content-Location identifies the original location of the message body enclosed in the request. It is therefore possible for a response to contain header fields for both Location and Content-Location. Also, see <a href="#sec.chache_invalidation">Section 18.2</a> for cache requirements of some methods.</p>
<h1 id="rfc.section.16.28">
<a href="#rfc.section.16.28">16.28.</a> <a href="#sec_Media-Properties" id="sec_Media-Properties">Media-Properties</a>
</h1>
<p id="rfc.section.16.28.p.1">This general header is used in SETUP response or PLAY_NOTIFY requests to indicate the media's properties that currently are applicable to the RTSP session. PLAY_NOTIFY MAY be used to modify these properties at any point. However, the client SHOULD have received the update prior to that any action related to the new media properties take effect. For aggregated sessions, the Media-Properties header will be returned in each SETUP response. The header received in the latest response is the one that applies on the whole session from this point until any future update. The header MAY be included without value in GET_PARAMETER requests to the server with a Session header included to query the current Media-Properties for the session. The responder MUST include the current session's media properties.</p>
<p id="rfc.section.16.28.p.2">The media properties expressed by this header is the one applicable to all media in the RTSP session. For aggregated sessions, the header expressed the combined media-properties. As a result aggregation of media MAY result in a change of the media properties, and thus the content of the Media-Properties header contained in subsequent SETUP responses.</p>
<p id="rfc.section.16.28.p.3">The header contains a list of property values that are applicable to the currently setup media or aggregate of media as indicated by the RTSP URI in the request. No ordering are enforced within the header.  Property values should be grouped into a single group that handles a particular orthogonal property. Values or groups that express multiple properties SHOULD NOT be used. The list of properties that can be expressed MAY be extended at any time. Unknown property values MUST be ignored.</p>
<p id="rfc.section.16.28.p.4">This specification defines the following 4 groups and their property values:</p>
<p></p>

<dl>
<dt>Random Access:</dt>
<dd style="margin-left: 8"><dl>
<dt>Random-Access:</dt>
<dd style="margin-left: 8">Indicates that random access is possible. May optionally include a floating point value in seconds indicating the longest duration between any two random access points in the media.</dd>
<dt>Begining-Only:</dt>
<dd style="margin-left: 8">Seeking is limited to the beginning only.</dd>
<dt>No-Seeking:</dt>
<dd style="margin-left: 8">No seeking is possible.</dd>
</dl></dd>
<dt>Content Modifications:</dt>
<dd style="margin-left: 8"><dl>
<dt>Immutable:</dt>
<dd style="margin-left: 8">The content will not be changed during the life-time of the RTSP session.</dd>
<dt>Dynamic:</dt>
<dd style="margin-left: 8">The content may be changed based on external methods or triggers</dd>
<dt>Time-Progressing</dt>
<dd style="margin-left: 8">The media accessible progress as wallclock time progresses.</dd>
</dl></dd>
<dt>Retention:</dt>
<dd style="margin-left: 8"><dl>
<dt>Unlimited:</dt>
<dd style="margin-left: 8">Content will be retained for the duration of the life-time of the RTSP session.</dd>
<dt>Time-Limited:</dt>
<dd style="margin-left: 8">Content will be retained at least until the specified wallclock time. The time must be provided in the absolute time format specified in <a href="#sec_clock">Section 4.6</a>.</dd>
<dt>Time-Duration</dt>
<dd style="margin-left: 8">Each individual media unit is retained for at least the specified time duration. This definition allows for retaining data with a time based sliding window. The time duration is expressed as floating point number in seconds. 0.0 is a valid value as this indicates that no data is retained in a time-progressing session.</dd>
</dl></dd>
<dt>Supported Scale:</dt>
<dd style="margin-left: 8"><dl>
<dt>Scales:</dt>
<dd style="margin-left: 8">A quoted comma separated list of one or more decimal values or ranges of scale values supported by the content in arbitrary order. A range has a start and stop value separated by a colon. A range indicates that the content supports fine grained selection of scale values. Fine grained allows for steps at least as small as one tenth of a scale value. Negative values are supported. The value 0 have no meaning and must not be used.</dd>
</dl></dd>
</dl>
<p id="rfc.section.16.28.p.6">Examples of this header for on-demand content and a live stream without recording are:</p>
<div id="#rfc.figure.38"></div>
<pre>On-demand:
Media-Properties: Random-Access=2.5s, Unlimited, Immutable, 
     Scales="-20, -10, -4, 0.5:1.5, 4, 8, 10, 15, 20"

Live stream without recording/timeshifting:
Media-Properties: No-Seeking, Time-Progressing, Time-Duration=0.0
</pre>
<p></p>
<p></p>
<h1 id="rfc.section.16.29">
<a href="#rfc.section.16.29">16.29.</a> <a href="#sec_Media-Range" id="sec_Media-Range">Media-Range</a>
</h1>
<p id="rfc.section.16.29.p.1">The Media-Range general header is used to give the range of the media at the time of sending the RTSP message. This header MUST be included in SETUP response, and PLAY and PAUSE response for media that are Time-Progressing, and PLAY and PAUSE response after any change for media that are Dynamic, and in PLAY_NOTIFY request that are sent due to Media-Property-Update. Media-Range header without any range specifications MAY be included in GET_PARAMETER requests to the server to request the current range. The server MUST in this case include the current range at the time of sending the response.</p>
<p id="rfc.section.16.29.p.2">The header MUST include range specifications for all time formats supported for the media, as indicated in <a href="#sec_Accept-Ranges">Accept-Ranges header</a> <cite title="NONE">[sec_Accept-Ranges]</cite> when setting up the media. The server MAY include more than one range specification of any given time format to indicate media that has non-continuous range.</p>
<p id="rfc.section.16.29.p.3">For media that has the Time-Progressing property, the Media-Range values will only be valid for the particular point in time when it was issued. As wallclock progresses so will also the media range. However, it shall be assumed that media time progress in direct relationship to wallclock time (with the exception of clock skew) so that a reasonably accurate estimation of the media range can be calculated.</p>
<h1 id="rfc.section.16.30">
<a href="#rfc.section.16.30">16.30.</a> <a href="#sec_MTag" id="sec_MTag">MTag</a>
</h1>
<p id="rfc.section.16.30.p.1">The MTag response header MAY be included in DESCRIBE, GET_PARAMETER or SETUP responses. The message body tags (<a href="#sec_message-tags">Section 4.8</a>) returned in a DESCRIBE response, and the one in SETUP refers to the presentation, i.e. both the returned session description and the media stream. This allows for verification that one has the right session description to a media resource at the time of the SETUP request. However, it has the disadvantage that a change in any of the parts results in invalidation of all the parts.</p>
<p id="rfc.section.16.30.p.2">If the MTag is provided both inside the message body, e.g. within the "a=mtag" attribute in SDP, and in the response message, then both tags MUST be identical. It is RECOMMENDED that the MTag is primarily given in the RTSP response message, to ensure that caches can use the MTag without requiring content inspection. However, for session descriptions that are distributed outside of RTSP, for example using HTTP, etc. it will be necessary to include the message body tag in the session description as specified in <a href="#sec_sdp-mtag">Appendix Appendix D.1.9</a>.</p>
<p id="rfc.section.16.30.p.3">SETUP and DESCRIBE requests can be made conditional upon the MTag using the headers If-Match (<a href="#sec_If-Match">Section 16.23</a>) and If-None-Match ( <a href="#sec_If-None-Match">Section 16.25</a>).</p>
<h1 id="rfc.section.16.31">
<a href="#rfc.section.16.31">16.31.</a> <a href="#sec_Notify-Reason" id="sec_Notify-Reason">Notify-Reason</a>
</h1>
<p id="rfc.section.16.31.p.1">The Notify Reason header is solely used in the PLAY_NOTIFY method.  It indicates the reason why the server has sent the asynchronous PLAY_NOTIFY request (see <a href="#sec_PLAY_NOTIFY">Section 13.5</a>).</p>
<h1 id="rfc.section.16.32">
<a href="#rfc.section.16.32">16.32.</a> <a href="#sec_Pipelined-Requests" id="sec_Pipelined-Requests">Pipelined-Requests</a>
</h1>
<p id="rfc.section.16.32.p.1">The Pipelined-Requests general header is used to indicate that a request is to be executed in the context created by a previous request(s). The primary usage of this header is to allow pipelining of SETUP requests so that any additional SETUP request after the first one does not need to wait for the session ID to be sent back to the requesting agent. The header contains a unique identifier that is scoped by the persistent connection used to send the requests.</p>
<p id="rfc.section.16.32.p.2">Upon receiving a request with the Pipelined-Requests the responding agent MUST look up if there exists a binding between this Pipelined-Requests identifier for the current persistent connection and an RTSP session ID. If that exists then the received request is processed the same way as if it contained the Session header with the found session ID. If there does not exist a mapping and no Session header is included in the request, the responding agent MUST create a binding upon the successful completion of a session creating request, i.e. SETUP. A binding MUST NOT be created, if the request failed to create an RTSP session. In case the request contains both a Session header and the Pipelined-Requests header the Pipelined-Requests MUST be ignored.</p>
<p id="rfc.section.16.32.p.3">Note: Based on the above definition at least the first request containing a new unique Pipelined-Requests will be required to be a SETUP request (unless the protocol is extended with new methods of creating a session). After that first one, additional SETUP requests or request of any type using the RTSP session context may include the Pipelined-Requests header.</p>
<p id="rfc.section.16.32.p.4">When responding to any request that contained the Pipelined-Requests header the server MUST also include the Session header when a binding to a session context exist. A RTSP agent that knows the session ID SHOULD NOT use the Pipelined-Requests header in any request and only use the Session header. This as the Session identifier is persistent across transport contexts, like TCP connections, which the Pipelined-Requests identifier is not.</p>
<p id="rfc.section.16.32.p.5">The RTSP agent sending the request with a Pipelined-Requests header has the responsibility for using a unique and previously unused identifier within the transport context. Currently only a TCP connection is defined as such transport context. A server MUST delete the Pipelined-Requests identifier and its binding to a session upon the termination of that session. Despite the previous mandate, RTSP agents are RECOMMENDED to not reuse identifiers to allow for better error handling and logging.</p>
<p id="rfc.section.16.32.p.6">RTSP Proxies may need to translate Pipelined-Requests identifier values from incoming request to outgoing to allow for aggregation of requests onto a persistent connection.</p>
<h1 id="rfc.section.16.33">
<a href="#rfc.section.16.33">16.33.</a> <a href="#sec_Proxy-Authenticate" id="sec_Proxy-Authenticate">Proxy-Authenticate</a>
</h1>
<p id="rfc.section.16.33.p.1">The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response. The field value consists of a challenge that indicates the authentication scheme and parameters applicable to the proxy for this Request-URI.</p>
<p id="rfc.section.16.33.p.2">The HTTP access authentication process is described in <a href="#RFC2617">[RFC2617]</a>. Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream agents. However, an intermediate proxy might need to obtain its own credentials by requesting them from the downstream agent, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate header field.</p>
<h1 id="rfc.section.16.34">
<a href="#rfc.section.16.34">16.34.</a> Proxy-Authorization</h1>
<p id="rfc.section.16.34.p.1">The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires authentication. The Proxy-Authorization field value consists of credentials containing the authentication information of the user agent for the proxy and/or realm of the resource being requested.</p>
<p id="rfc.section.16.34.p.2">The HTTP access authentication process is described in <a href="#RFC2617">[RFC2617]</a>. Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication using the Proxy- Authenticate field. When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed by the first outbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.</p>
<h1 id="rfc.section.16.35">
<a href="#rfc.section.16.35">16.35.</a> <a href="#sec_Proxy-Require" id="sec_Proxy-Require">Proxy-Require</a>
</h1>
<p id="rfc.section.16.35.p.1">The Proxy-Require request-header field is used to indicate proxy-sensitive features that MUST be supported by the proxy. Any Proxy-Require header features that are not supported by the proxy MUST be negatively acknowledged by the proxy to the client using the Unsupported header. The proxy MUST use the 551 (Option Not Supported) status code in the response. Any feature-tag included in the Proxy-Require does not apply to the end-point (server or client). To ensure that a feature is supported by both proxies and servers the tag needs to be included in also a Require header.</p>
<p id="rfc.section.16.35.p.2">See <a href="#sec_Require">Section 16.41</a> for more details on the mechanics of this message and a usage example. See discussion in the <a href="#sec_proxies_ext">proxies section</a> <cite title="NONE">[sec_proxies_ext]</cite> about when to consider that a feature requires proxy support.</p>
<div id="#rfc.figure.39"></div>
<pre>   Proxy-Require: play.basic</pre>
<p id="rfc.section.16.35.p.3">Example of use: </p>
<h1 id="rfc.section.16.36">
<a href="#rfc.section.16.36">16.36.</a> <a href="#sec_Proxy-Supported" id="sec_Proxy-Supported">Proxy-Supported</a>
</h1>
<p id="rfc.section.16.36.p.1">The Proxy-Supported header field enumerates all the extensions supported by the proxy using feature-tags. The header carries the intersection of extensions supported by the forwarding proxies. The Proxy-Supported header MAY be included in any request by a proxy. It MUST be added by any proxy if the Supported header is present in a request. When present in a request, the receiver MUST in the response copy the received Proxy-Supported header.</p>
<p id="rfc.section.16.36.p.2">The Proxy-Supported header field contains a list of feature-tags applicable to proxies, as described in <a href="#sec_feature_tags">Section 4.7</a>. The list are the intersection of all feature-tags understood by the proxies. To achieve an intersection, the proxy adding the Proxy-Supported header includes all proxy feature-tags it understands. Any proxy receiving a request with the header, checks the list and removes any feature-tag it do not support. A Proxy-Supported header present in the response MUST NOT be touched by the proxies.</p>
<div id="#rfc.figure.40"></div>
<pre>  C-&gt;P1: OPTIONS rtsp://example.com/ RTSP/2.0
         Supported: foo, bar, blech
         User-Agent: PhonyClient/1.2

 P1-&gt;P2: OPTIONS rtsp://example.com/ RTSP/2.0
         Supported: foo, bar, blech
         Proxy-Supported: proxy-foo, proxy-bar, proxy-blech
         Via: 2.0 pro.example.com

 P2-&gt;S:  OPTIONS rtsp://example.com/ RTSP/2.0
         Supported: foo, bar, blech
         Proxy-Supported: proxy-foo, proxy-blech
         Via: 2.0 pro.example.com, 2.0 prox2.example.com

  S-&gt;C:  RTSP/2.0 200 OK
         Supported: foo, bar, baz
         Proxy-Supported: proxy-foo, proxy-blech
         Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN
         Via: 2.0 pro.example.com, 2.0 prox2.example.com</pre>
<p id="rfc.section.16.36.p.3">Example: </p>
<h1 id="rfc.section.16.37">
<a href="#rfc.section.16.37">16.37.</a> <a href="#sec_Public" id="sec_Public">Public</a>
</h1>
<p id="rfc.section.16.37.p.1">The Public response header field lists the set of methods supported by the response sender. This header applies to the general capabilities of the sender and its only purpose is to indicate the sender's capabilities to the recipient. The methods listed may or may not be applicable to the Request-URI; the <a href="#sec_Allow">Allow header field</a> <cite title="NONE">[sec_Allow]</cite> MAY be used to indicate methods allowed for a particular URI.</p>
<div id="#rfc.figure.41"></div>
<pre>   Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN</pre>
<p id="rfc.section.16.37.p.2">Example of use: </p>
<p id="rfc.section.16.37.p.3">In the event that there are proxies between the sender and the recipient of a response, each intervening proxy MUST modify the Public header field to remove any methods that are not supported via that proxy. The resulting Public header field will contain an intersection of the sender's methods and the methods allowed through by the intervening proxies.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">In general, proxies should allow all methods to transparently pass through from the sending RTSP agent to the receiving RTSP agent, but there may be cases where this is not desirable for a given proxy. Modification of the Public response header field by the intervening proxies ensures that the request sender gets an accurate response indicating the methods that can be used on the target agent via the proxy chain.</dd>
</dl>
<h1 id="rfc.section.16.38">
<a href="#rfc.section.16.38">16.38.</a> <a href="#sec_Range" id="sec_Range">Range</a>
</h1>
<p id="rfc.section.16.38.p.1">The Range header specifies a time range in PLAY (<a href="#sec_PLAY">Section 13.4</a>), PAUSE (<a href="#sec_PAUSE">Section 13.6</a>), SETUP (<a href="#sec_SETUP">Section 13.3</a>), REDIRECT (<a href="#sec_REDIRECT">Section 13.10</a>), and PLAY_NOTIFY (<a href="#sec_PLAY_NOTIFY">Section 13.5</a>) requests and responses. It MAY be included in GET_PARAMETER requests from the client to the server with only a Range format and no value to request the current media position, whether the session is in Play or Ready state in the included format. The server SHALL, if supporting the range format, respond with the current playing point or pause point as the start of the range. If an explicit stop point was used in the previous PLAY request, then that value shall be included as stop point. Note that if the server is currently under any type of media playback manipulation affecting the interpretation of Range, like Scale, that is also required to be included in any GET_PARAMETER response to provide complete information.</p>
<p id="rfc.section.16.38.p.2">The range can be specified in a number of units. This specification defines smpte (<a href="#sec_smpte">Section 4.4</a>), npt (<a href="#sec_npt">Section 4.5</a>), and clock (<a href="#sec_clock">Section 4.6</a>) range units. While byte ranges [H14.35.1] and other extended units MAY be used, their behavior is unspecified since they are not normally meaningful in RTSP. Servers supporting the Range header MUST understand the NPT range format and SHOULD understand the SMPTE range format. If the Range header is sent in a time format that is not understood, the recipient SHOULD return 456 (Header Field Not Valid for Resource) and include an Accept-Ranges header indicating the supported time formats for the given resource.</p>
<div id="#rfc.figure.42"></div>
<pre>  Range: clock=19960213T143205Z-</pre>
<p id="rfc.section.16.38.p.3">Example: </p>
<p id="rfc.section.16.38.p.4">The Range header contains a range of one single range format. A range is a half-open interval with a start and an end point, including the start point, but excluding the end point. A range may either be fully specified with explicit values for start point and end point, or have either start or end point be implicit. An implicit start point indicates the session's pause point, and if no pause point is set the start of the content. An implicit end point indicates the end of the content. The usage of both implicit start and end point is not allowed in the same range header, however, the exclusion of the range header has that meaning, i.e. from pause point (or start) until end of content.</p>
<p></p>

<ul class="empty">
<li>Regarding the half-open intervals; a range of A-B starts exactly at time A, but ends just before B. Only the start time of a media unit such as a video or audio frame is relevant. For example, assume that video frames are generated every 40 ms. A range of 10.0-10.1 would include a video frame starting at 10.0 or later time and would include a video frame starting at 10.08, even though it lasted beyond the interval. A range of 10.0-10.08, on the other hand, would exclude the frame at 10.08.</li>
<li>Please note the difference between NPT time scales' "now" and an implicit start value. Implicit value reference the current pause-point. While "now" is the currently ongoing time. In a time-progressing session with recording (retention for some or full time) the pause point may be 2 min into the session while now could be 1 hour into the session.</li>
</ul>
<p id="rfc.section.16.38.p.6">By default, range intervals increase, where the second point is larger than the first point.</p>
<div id="#rfc.figure.43"></div>
<pre>    Range: npt=10-15</pre>
<p id="rfc.section.16.38.p.7">Example: </p>
<p id="rfc.section.16.38.p.8">However, range intervals can also decrease if the Scale header (see <a href="#sec_Scale">Section 16.44</a>) indicates a negative scale value.  For example, this would be the case when a playback in reverse is desired.</p>
<div id="#rfc.figure.44"></div>
<pre>    Scale: -1
    Range: npt=15-10</pre>
<p id="rfc.section.16.38.p.9">Example: </p>
<p id="rfc.section.16.38.p.10">Decreasing ranges are still half open intervals as described above.  Thus, for range A-B, A is closed and B is open. In the above example, 15 is closed and 10 is open. An exception to this rule is the case when B=0 in a decreasing range. In this case, the range is closed on both ends, as otherwise there would be no way to reach 0 on a reverse playback for formats that have such a notion, like NPT and SMPTE.</p>
<div id="#rfc.figure.45"></div>
<pre>    Scale: -1
    Range: npt=15-0</pre>
<p id="rfc.section.16.38.p.11">Example: </p>
<p id="rfc.section.16.38.p.12">In this range both 15 and 0 are closed.</p>
<p id="rfc.section.16.38.p.13">A decreasing range interval without a corresponding negative Scale header is not valid.</p>
<h1 id="rfc.section.16.39">
<a href="#rfc.section.16.39">16.39.</a> <a href="#sec_Referrer" id="sec_Referrer">Referrer</a>
</h1>
<p id="rfc.section.16.39.p.1">The Referrer request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource from which the Request-URI was obtained. The URI refers to that of the presentation description, typically retrieved via HTTP. The Referrer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows obsolete or mistyped links to be traced for maintenance. The Referrer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.</p>
<p id="rfc.section.16.39.p.2">If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI. The URI MUST NOT include a fragment.</p>
<p id="rfc.section.16.39.p.3">Because the source of a link might be private information or might reveal an otherwise private information source, it is strongly recommended that the user be able to select whether or not the Referrer field is sent. For example, a streaming client could have a toggle switch for openly/anonymously, which would respectively enable/disable the sending of Referee and From information.</p>
<p id="rfc.section.16.39.p.4">Clients SHOULD NOT include a Referee header field in a (non-secure) RTSP request if the referring page was transferred with a secure protocol.</p>
<h1 id="rfc.section.16.40">
<a href="#rfc.section.16.40">16.40.</a> <a href="#sec_Request-Status" id="sec_Request-Status">Request-Status</a>
</h1>
<p id="rfc.section.16.40.p.1">This request header is used to indicate the end result for requests that takes time to complete, such a <a href="#sec_PLAY">PLAY</a> <cite title="NONE">[sec_PLAY]</cite>. It is sent in <a href="#sec_PLAY_NOTIFY">PLAY_NOTIFY</a> <cite title="NONE">[sec_PLAY_NOTIFY]</cite> with the end-of-stream reason to report how the PLAY request concluded, either in success or in failure. The header carries a reference to the request it reports on using the CSeq number for the session indicated by the Session header in the request. It provides both a numerical status code (according to <a href="#sec_status-code">Section 8.1.1</a>) and a human readable reason phrase.</p>
<div id="#rfc.figure.46"></div>
<pre>Example:
Request-Status: cseq=63 status=500 reason="Media data unavailable"</pre>
<p></p>
<p></p>
<h1 id="rfc.section.16.41">
<a href="#rfc.section.16.41">16.41.</a> <a href="#sec_Require" id="sec_Require">Require</a>
</h1>
<p id="rfc.section.16.41.p.1">The Require request-header field is used by clients or servers to ensure that the other end-point supports features that are required in respect to this request. It can also be used to query if the other end-point supports certain features, however, the use of the Supported (<a href="#sec_Supported">Section 16.49</a>) is much more effective in this purpose. The server MUST respond to this header by using the Unsupported header to negatively acknowledge those feature-tags which are NOT supported. The response MUST use the error code 551 (Option Not Supported). This header does not apply to proxies, for the same functionality in respect to proxies see Proxy-Require header (<a href="#sec_Proxy-Require">Section 16.35</a>) with the exception of media modifying proxies. Media modifying proxies due to their nature of handling media in a way that is very similar to what a server, do need to understand also the server features to correctly serve the client.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">This is to make sure that the client-server interaction will proceed without delay when all features are understood by both sides, and only slow down if features are not understood (as in the example below). For a well-matched client-server pair, the interaction proceeds quickly, saving a round-trip often required by negotiation mechanisms. In addition, it also removes state ambiguity when the client requires features that the server does not understand.</dd>
</dl>
<div id="#rfc.figure.47"></div>
<pre>C-&gt;S:   SETUP rtsp://server.com/foo/bar/baz.rm RTSP/2.0
        CSeq: 302
        Require: funky-feature
        Funky-Parameter: funkystuff

S-&gt;C:   RTSP/2.0 551 Option not supported
        CSeq: 302
        Unsupported: funky-feature</pre>
<p id="rfc.section.16.41.p.3">Example (Not complete): </p>
<p id="rfc.section.16.41.p.4">In this example, "funky-feature" is the feature-tag which indicates to the client that the fictional Funky-Parameter field is required.  The relationship between "funky-feature" and Funky-Parameter is not communicated via the RTSP exchange, since that relationship is an immutable property of "funky-feature" and thus should not be transmitted with every exchange.</p>
<p id="rfc.section.16.41.p.5">Proxies and other intermediary devices MUST ignore this header. If a particular extension requires that intermediate devices support it, the extension should be tagged in the Proxy-Require field instead (see <a href="#sec_Proxy-Require">Section 16.35</a>). See discussion in the <a href="#sec_proxies_ext">proxies section</a> <cite title="NONE">[sec_proxies_ext]</cite> about when to consider that a feature requires proxy support.</p>
<h1 id="rfc.section.16.42">
<a href="#rfc.section.16.42">16.42.</a> <a href="#sec_Retry-After" id="sec_Retry-After">Retry-After</a>
</h1>
<p id="rfc.section.16.42.p.1">The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request. The value of this field can be either an RTSP-date or an integer number of seconds (in decimal) after the time of the response.</p>
<div id="#rfc.figure.48"></div>
<pre>Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120</pre>
<p id="rfc.section.16.42.p.2">Example:</p>
<p id="rfc.section.16.42.p.3">In the latter example, the delay is 2 minutes.</p>
<h1 id="rfc.section.16.43">
<a href="#rfc.section.16.43">16.43.</a> <a href="#sec_RTP-Info" id="sec_RTP-Info">RTP-Info</a>
</h1>
<p id="rfc.section.16.43.p.1">The RTP-Info general field is used to set RTP-specific parameters in the PLAY and GET_PARAMETER responses or a PLAY_NOTIFY and GET_PARAMETER requests. For streams using RTP as transport protocol the RTP-Info header SHOULD be part of a 200 response to PLAY.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The exclusion of the RTP-Info in a PLAY response for RTP transported media will result in that a client needs to synchronize the media streams using RTCP. This may have negative impact as the RTCP can be lost, and does not need to be particularly timely in their arrival. Also functionality as informing the client from which packet a seek has occurred is affected.</dd>
</dl>
<p id="rfc.section.16.43.p.3">The RTP-Info MAY be included in SETUP responses to provide synchronization information when changing transport parameters, see <a href="#sec_SETUP">Section 13.3</a>. The RTP-Info header and the Range header MAY be included in a GET_PARAMETER request from client to server without any values to request the current playback point and corresponding. RTP synchronization information. When the RTP-Info header is included in a Request also the Range header MUST be included (Note, Range header only MAY be used). The server response SHALL include both the Range header and the RTP-Info header. If the session is in Play state, then the value of the Range header SHALL be filled in with the current playback point and with the corresponding RTP-Info values. If the server is another state, no values are included in the RTP-Info header. The header is included in PLAY_NOTIFY requests with the Notify-Reason of end-of-stream to provide RTP information about the end of the stream.</p>
<p id="rfc.section.16.43.p.4">The header can carry the following parameters: </p>

<dl>
<dt>url:</dt>
<dd style="margin-left: 6">Indicates the stream URI which for which the following RTP parameters correspond, this URI MUST be the same used in the SETUP request for this media stream. Any relative URI MUST use the Request-URI as base URI. This parameter MUST be present.</dd>
<dt>ssrc:</dt>
<dd style="margin-left: 6">The Synchronization source (SSRC) that the RTP timestamp and sequence number provide applies to. This parameter MUST be present.</dd>
<dt>seq:</dt>
<dd style="margin-left: 6">Indicates the sequence number of the first packet of the stream that is direct result of the request. This allows clients to gracefully deal with packets when seeking. The client uses this value to differentiate packets that originated before the seek from packets that originated after the seek. Note that a client may not receive the packet with the expressed sequence number, and instead packets with a higher sequence number, due to packet loss or reordering. This parameter is RECOMMENDED to be present.</dd>
<dt>rtptime:</dt>
<dd style="margin-left: 6">MUST indicate the RTP timestamp value corresponding to the start time value in the Range response header, or if not explicitly given the implied start point. The client uses this value to calculate the mapping of RTP time to NPT or other media timescale. This parameter SHOULD be present to ensure inter-media synchronization is achieved. There exist no requirement that any received RTP packet will have the same RTP timestamp value as the one in the parameter used to establish synchronization.</dd>
</dl>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">A mapping from RTP timestamps to NTP timestamps (wallclock) is available via RTCP. However, this information is not sufficient to generate a mapping from RTP timestamps to media clock time (NPT, etc.). Furthermore, in order to ensure that this information is available at the necessary time (immediately at startup or after a seek), and that it is delivered reliably, this mapping is placed in the RTSP control channel.</dd>
</dl>

<p> </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">In order to compensate for drift for long, uninterrupted presentations, RTSP clients should additionally map NPT to NTP, using initial RTCP sender reports to do the mapping, and later reports to check drift against the mapping.</dd>
</dl>
<div id="#rfc.figure.49"></div>
<pre>Range:npt=3.25-15
RTP-Info:url="rtsp://example.com/foo/audio" ssrc=0A13C760:seq=45102;
         rtptime=12345678,url="rtsp://example.com/foo/video"
         ssrc=9A9DE123:seq=30211;rtptime=29567112

Lets assume that Audio uses a 16kHz RTP timestamp clock and Video
a 90kHz RTP timestamp clock. Then the media synchronization is
depicted in the following way.

NPT    3.0---3.1---3.2-X-3.3---3.4---3.5---3.6
Audio               PA A
Video                  V    PV

X: NPT time value = 3.25, from Range header.
A: RTP timestamp value for Audio from RTP-Info header (12345678).
V: RTP timestamp value for Video from RTP-Info header (29567112).
PA: RTP audio packet carrying an RTP timestamp of 12344878. Which
    corresponds to NPT = (12344878 - A) / 16000 + 3.25 = 3.2
PV: RTP video packet carrying an RTP timestamp of 29573412. Which
    corresponds to NPT = (29573412 - V) / 90000 + 3.25 = 3.32</pre>
<p id="rfc.section.16.43.p.6">Example: </p>
<h1 id="rfc.section.16.44">
<a href="#rfc.section.16.44">16.44.</a> <a href="#sec_Scale" id="sec_Scale">Scale</a>
</h1>
<p id="rfc.section.16.44.p.1">A scale value of 1 indicates normal play at the normal forward viewing rate. If not 1, the value corresponds to the rate with respect to normal viewing rate. For example, a ratio of 2 indicates twice the normal viewing rate ("fast forward") and a ratio of 0.5 indicates half the normal viewing rate. In other words, a ratio of 2 has content time increase at twice the playback time. For every second of elapsed (wallclock) time, 2 seconds of content time will be delivered. A negative value indicates reverse direction. For certain media transports this may require certain considerations to work consistent, see <a href="#sec_rtp">Appendix Appendix C.1</a> for description on how RTP handles this.</p>
<p id="rfc.section.16.44.p.2">The transmitted data rate SHOULD NOT be changed by selection of a different scale value. The resulting bit-rate should be reasonably close to the nominal bit-rate of the content for Scale = 1. The server has to actively manipulate the data when needed to meet the bitrate constraints. Implementation of scale changes depends on the server and media type. For video, a server may, for example, deliver only key frames or selected frames. For audio, it may time-scale the audio while preserving pitch or, less desirably, deliver fragments of audio, or completely mute the audio.</p>
<p id="rfc.section.16.44.p.3">The server and content may restrict the range of scale values that it supports. The supported values are indicated by the <a href="#sec_Media-Properties">Media-Properties header</a> <cite title="NONE">[sec_Media-Properties]</cite>. The client SHOULD only indicate values indicated to be supported. However, as the values may change as the content progresses a requested value may no longer be valid when the request arrives. Thus, a non-supported value in a request does not generate an error, only forces the server to choose the closest value. The response MUST always contain the actual scale value chosen by the server.</p>
<p id="rfc.section.16.44.p.4">If the server does not implement the possibility to scale, it will not return a Scale header. A server supporting Scale operations for PLAY MUST indicate this with the use of the "play.scale" feature-tag.</p>
<p id="rfc.section.16.44.p.5">When indicating a negative scale for a reverse playback, the Range header MUST indicate a decreasing range as described in <a href="#sec_Range">Section 16.38</a>.</p>
<div id="#rfc.figure.50"></div>
<pre>  Scale: -3.5
  Range: npt=15-10</pre>
<p id="rfc.section.16.44.p.6">Example of playing in reverse at 3.5 times normal rate: </p>
<h1 id="rfc.section.16.45">
<a href="#rfc.section.16.45">16.45.</a> <a href="#sec_Seek-Style" id="sec_Seek-Style">Seek-Style</a>
</h1>
<p id="rfc.section.16.45.p.1">When a client sends a PLAY request with a Range header to perform a random access to the media, the client does not know if the server will pick the first media samples or the first random access point prior to the request range. Depending on use case, the client may have a strong preference. To express this preference and provide the client with information on how the server actually acted on that preference the Seek-Style header is defined.</p>
<p id="rfc.section.16.45.p.2">Seek-Style is a general header that MAY be included in any PLAY request to indicate the client's preference for any media stream that has random access properties. The server MUST always include the header in any PLAY response for media with random access properties to indicate what policy was applied. A server that receives a unknown Seek-Style policy MUST ignore it and select the server default policy.  A client receiving an unknown policy MUST ignore it and use the Range header and any media synchronization information as basis to determine what the server did.</p>
<p id="rfc.section.16.45.p.3">This specification defines the following seek policies that may be requested (see also Section <a href="#sec_random_access_seek">Section 4.9.1</a>):</p>
<p></p>

<dl>
<dt>RAP:</dt>
<dd style="margin-left: 8">Random Access Point (RAP) is the behavior of requesting the server to locate the closest previous random access point that exist in the media aggregate and deliver from that. By requesting a RAP, media quality will be the best possible as all media will be delivered from a point where full media state can be established in the media decoder.</dd>
<dt>CoRAP:</dt>
<dd style="margin-left: 8">Conditional Random Access Point (CoRAP) is a variant of the above RAP behavior. This policy is primarily intended for cases where there are larger distance between the random access points in the media. CoRAP is conditioned on that there is a Random Access Point closer to the requested start point than to the current pause point. This policy assumes that the media state existing prior to the pause is usable if delivery is continued. If the client or server knows that this is not the fact the RAP policy should be used. In other words: in most cases when the client requests a start point prior to the current pause point, a valid decoding dependency chain from the media delivered prior to the pause and to the requested media unit will not exist.  If the server searched to a random access point the server MUST return the CoRAP policy in the Seek-Style header and adjust the Range header to reflect the position of the picked RAP. In case the random access point is further away and the server selects to continue from the current pause point it MUST include the "Next" policy in the Seek-Style header and adjust the Range header start point to the current pause point.</dd>
<dt>First-Prior:</dt>
<dd style="margin-left: 8">The first-prior policy will start delivery with the media unit that has a playout time first prior to the requested time. For discrete media that would only include media units that would still be rendered at the request time. For continuous media that is media that will be render during the requested start time of the range.</dd>
<dt>Next:</dt>
<dd style="margin-left: 8">The next media units after the provided start time of the range. For continuous framed media that would mean the first next frame after the provided time. For discrete media the first unit that is to be rendered after the provided time. The main usage is for this case is when the client knows it has all media up to a certain point and would like to continue delivery so that a complete non-interrupted media playback can be achieved.  Example of such scenarios include switching from a broadcast/multicast delivery to a unicast based delivery. This policy MUST only be used on the client's explicit request.</dd>
</dl>

<p>Please note that these expressed preferences exist for optimizing the startup time or the media quality. The "Next" policy breaks the normal definition of the Range header to enable a client to request media with minimal overlap, although some may still occur for aggregated sessions. RAP and First-Prior both fulfill the requirement of providing media from the requested range and forward. However, unless RAP is used, the media quality for many media codecs using predictive methods can be severely degraded unless additional data is available as, for example, already buffered, or through other side channels.</p>
<h1 id="rfc.section.16.46">
<a href="#rfc.section.16.46">16.46.</a> <a href="#sec_Server" id="sec_Server">Server</a>
</h1>
<p id="rfc.section.16.46.p.1">The Server response-header field contains information about the software used by the origin server to handle the request. The field can contain multiple product tokens and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance for identifying the application.</p>
<p id="rfc.section.16.46.p.2">Example:</p>
<div id="#rfc.figure.51"></div>
<pre>Server: PhonyServer/1.0</pre>
<p id="rfc.section.16.46.p.3">If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header. Instead, it SHOULD include a <a href="#sec_Via">Via field</a> <cite title="NONE">[sec_Via]</cite>.</p>
<h1 id="rfc.section.16.47">
<a href="#rfc.section.16.47">16.47.</a> <a href="#sec_Session" id="sec_Session">Session</a>
</h1>
<p id="rfc.section.16.47.p.1">The Session request-header and response-header field identifies an RTSP session. An RTSP session is created by the server as a result of a successful SETUP request and in the response the session identifier is given to the client. The RTSP session exist until destroyed by a TEARDOWN, REDIRECT or timed out by the server.</p>
<p id="rfc.section.16.47.p.2">The session identifier is chosen by the server (see <a href="#sec_session-id">Section 4.3</a>) and MUST be returned in the SETUP response. Once a client receives a session identifier, it MUST be included in any request related to that session. This means that the Session header MUST be included in a request using the following methods: PLAY, PAUSE, and TEARDOWN, and MAY be included in SETUP, OPTIONS, SET_PARAMETER, GET_PARAMETER, and REDIRECT, and MUST NOT be included in DESCRIBE. In an RTSP response the session header MUST be included in methods, SETUP, PLAY, and PAUSE, and MAY be included in methods, TEARDOWN, and REDIRECT, and if included in the request of the following methods it MUST also be included in the response, OPTIONS, GET_PARAMETER, and SET_PARAMETER, and MUST NOT be included in DESCRIBE.</p>
<p id="rfc.section.16.47.p.3">Note that a session identifier identifies an RTSP session across transport sessions or connections. RTSP requests for a given session can use different URIs (Presentation and media URIs). Note, that there are restrictions depending on the session which URIs that are acceptable for a given method. However, multiple "user" sessions for the same URI from the same client will require use of different session identifiers.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The session identifier is needed to distinguish several delivery requests for the same URI coming from the same client.</dd>
</dl>
<p id="rfc.section.16.47.p.5">The response 454 (Session Not Found) MUST be returned if the session identifier is invalid.</p>
<p id="rfc.section.16.47.p.6">The header MAY include the session timeout period. If not explicitly provided this value is set to 60 seconds. As this affects how often session keep-alives are needed values smaller than 30 seconds are not recommended. However, larger than default values can be useful in applications of RTSP that have inactive but established sessions for longer time periods.</p>

<dl>
<dt></dt>
<dd style="margin-left: 8">60 seconds was chosen as session timeout value due to: Resulting in not to frequent keep-alive messages and having low sensitivity to variations in request response timing. If one reduces the timeout value to below 30 seconds the corresponding request response timeout becomes a significant part of the session timeout. 60 seconds also allows for reasonably rapid recovery of committed server resources in case of client failure.</dd>
</dl>
<h1 id="rfc.section.16.48">
<a href="#rfc.section.16.48">16.48.</a> <a href="#sec_Speed" id="sec_Speed">Speed</a>
</h1>
<p id="rfc.section.16.48.p.1">The Speed request-header field requests the server to deliver specific amounts of nominal media time per unit of delivery time, contingent on the server's ability and desire to serve the media stream at the given speed. The client requests the delivery speed to be within a given range with an lower and upper bound. The server SHALL deliver at the highest possible speed within the range, but not faster than the upper-bound, for which the underlying network path can support the resulting transport data rates. As long as any speed value within the given range can be provided the server SHALL NOT modify the media quality. Only if the server is unable to delivery media at the speed value provided by the lower bound shall it reduce the media quality.</p>
<p id="rfc.section.16.48.p.2">Implementation of the Speed functionality by the server is OPTIONAL. The server can indicate its support through a feature-tag, play.speed. The lack of a Speed header in the response is an indication of lack of support of this functionality.</p>
<p id="rfc.section.16.48.p.3">The speed parameter values are expressed as a positive decimal value, e.g., a value of 2.0 indicates that data is to be delivered twice as fast as normal. A speed value of zero is invalid. The range is specified in the form "lower bound - upper bound". The lower bound value may be smaller or equal to the upper bound. All speeds may not be possible to support. Therefore the server MAY modify the requested values to the closest supported. The actual supported speed MUST be included in the response. Note, however, that the use cases may vary and that Speed value ranges such as 0.7 - 0.8, 0.3-2.0, 1.0-2.5, 2.5-2.5 all have their usage.</p>
<div id="#rfc.figure.52"></div>
<pre>
  Speed: 1.0-2.5
 </pre>
<p id="rfc.section.16.48.p.4">Example: </p>
<h1 id="rfc.section.16.49">
<a href="#rfc.section.16.49">16.49.</a> <a href="#sec_Supported" id="sec_Supported">Supported</a>
</h1>
<p id="rfc.section.16.49.p.1">The Supported header enumerates all the extensions supported by the client or server using feature tags. The header carries the extensions supported by the message sending client or server. The Supported header MAY be included in any request. When present in a request, the receiver MUST respond with its corresponding Supported header. Note that the supported headers is also included in 4xx and 5xx responses.</p>
<p id="rfc.section.16.49.p.2">The Supported header contains a list of feature-tags, described in <a href="#sec_feature_tags">Section 4.7</a>, that are understood by the client or server.</p>
<div id="#rfc.figure.53"></div>
<pre>
  C-&gt;S:  OPTIONS rtsp://example.com/ RTSP/2.0
         Supported: foo, bar, blech
         User-Agent: PhonyClient/1.2

  S-&gt;C:  RTSP/2.0 200 OK
         Supported: bar, blech, baz</pre>
<p id="rfc.section.16.49.p.3">Example: </p>
<h1 id="rfc.section.16.50">
<a href="#rfc.section.16.50">16.50.</a> <a href="#sec_Terminate-Reason" id="sec_Terminate-Reason">Terminate-Reason</a>
</h1>
<p id="rfc.section.16.50.p.1">The Terminate-Reason request header allows the server when sending a REDIRECT or TEARDOWN request to provide a reason for the session termination and any additional information. This specification identifies three reasons for Redirections and may be extended in the future:</p>
<p></p>

<dl>
<dt>Server-Admin:</dt>
<dd style="margin-left: 8">The server needs to be shutdown for some administrative reason.</dd>
<dt>Session-Timeout:</dt>
<dd style="margin-left: 8">A client's session is kept alive for extended periods of time and the server has determined that it needs to reclaim the resources associated with this session.</dd>
<dt>Internal-Error</dt>
<dd style="margin-left: 8">An internal error that is impossible to recover from has occurred forcing the server to terminate the session.</dd>
</dl>

<p>The Server may provide additional parameters containing information around the redirect. This specification defines the following ones.</p>
<p></p>

<dl>
<dt>time:</dt>
<dd style="margin-left: 8">Provides a wallclock time when the server will stop provide any service.</dd>
<dt>user-msg:</dt>
<dd style="margin-left: 8">An UTF-8 text string with a message from the server to the user. This message SHOULD be displayed to the user.</dd>
</dl>
<p></p>
<h1 id="rfc.section.16.51">
<a href="#rfc.section.16.51">16.51.</a> <a href="#sec_Timestamp" id="sec_Timestamp">Timestamp</a>
</h1>
<p id="rfc.section.16.51.p.1">The Timestamp general-header describes when the agent sent the request. The value of the timestamp is of significance only to the agent and may use any timescale. The responding agent MUST echo the exact same value and MAY, if it has accurate information about this, add a floating point number indicating the number of seconds that has elapsed since it has received the request. The timestamp can be used by the agent to compute the round-trip time to the responding agent so that it can adjust the timeout value for retransmissions when running over a unreliable protocol. It also resolves retransmission ambiguities for unreliable transport of RTSP.</p>
<p id="rfc.section.16.51.p.2">Note that the present specification provides only for reliable transport of RTSP messages. The Timestamp general-header is specified in case the protocol is extended in the future to use unreliable transport.</p>
<h1 id="rfc.section.16.52">
<a href="#rfc.section.16.52">16.52.</a> <a href="#sec_Transport" id="sec_Transport">Transport</a>
</h1>
<p id="rfc.section.16.52.p.1">The Transport request and response header indicates which transport protocol is to be used and configures its parameters such as destination address, compression, multicast time-to-live and destination port for a single stream. It sets those values not already determined by a presentation description.</p>
<p id="rfc.section.16.52.p.2">A Transport request header MAY contain a list of transport options acceptable to the client, in the form of multiple transport specification entries. Transport specifications are comma separated, listed in decreasing order of preference. Parameters may be added to each transport specification, separated by a semicolon. The server MUST return a Transport response-header in the response to indicate the values actually chosen if any. If the transport specification is not supported, no transport header is returned and the request MUST be responded using the status code <a href="#sec_error461">461 (Unsupported Transport)</a> <cite title="NONE">[sec_error461]</cite>. In case more than one transport specification was present in the request, the server MUST return the single (transport-spec) which was actually chosen, if any. The number of transport-spec entries is expected to be limited as the client will get guidance on what configurations that are possible from the presentation description.</p>
<p id="rfc.section.16.52.p.3">The Transport header MAY also be used in subsequent SETUP requests to change transport parameters. A server MAY refuse to change parameters of an existing stream.</p>
<p id="rfc.section.16.52.p.4">A transport specification may only contain one of any given parameter within it. Parameters MAY be given in any order.  Additionally, it may only contain either of the unicast or the multicast transport type parameter. All parameters need to be understood in a transport specification, if not, the transport specification MUST be ignored. RTSP proxies of any type that uses or modifies the transport specification, e.g. access proxy or security proxy, MUST remove specifications with unknown parameters before forwarding the RTSP message. If that result in no remaining transport specification the proxy shall send a <a href="#sec_error461">461 (Unsupported Transport)</a> <cite title="NONE">[sec_error461]</cite> response without any Transport header.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The Transport header is restricted to describing a single media stream. (RTSP can also control multiple streams as a single entity.) Making it part of RTSP rather than relying on a multitude of session description formats greatly simplifies designs of firewalls.</dd>
</dl>
<div id="#rfc.figure.54"></div>
<pre>Value1/Value2/Value3...</pre>
<div id="#rfc.figure.55"></div>
<pre>RTP/profile/lower-transport.</pre>
<p id="rfc.section.16.52.p.6">The general syntax for the transport specifier is a list of slash separated tokens: </p>
<p id="rfc.section.16.52.p.7">The default value for the "lower-transport" parameters is specific to the profile. For RTP/AVP, the default is UDP.</p>
<p id="rfc.section.16.52.p.8">There are two different methods for how to specify where the media should be delivered for unicast transport: </p>

<dl>
<dt>dest_addr:</dt>
<dd style="margin-left: 6">The presence of this parameter and its values indicates the destination address or addresses (host address and port pairs for IP flows) necessary for the media transport.</dd>
<dt>No dest_addr:</dt>
<dd style="margin-left: 6">The lack of the dest_addr parameter indicates that the server MUST send media to same address for which the RTSP messages originates.</dd>
</dl>
<p id="rfc.section.16.52.p.9">The choice of method for indicating where the media is to be delivered depends on the use case. In some case the only allowed method will be to use no explicit address indication and have the server deliver media to the source of the RTSP messages.</p>
<p id="rfc.section.16.52.p.10">For Multicast there is several methods for specifying addresses but they are different in how they work compared with unicast:</p>
<p></p>

<dl>
<dt>dest_addr with client picked address:</dt>
<dd style="margin-left: 6">The address and relevant parameters like TTL (scope) for the actual multicast group to deliver the media to. There are <a href="#sec_security">security implications</a> <cite title="NONE">[sec_security]</cite> with this method that needs to be addressed if using this method because a RTSP server can be used as a DoS attacker on a existing multicast group.</dd>
<dt>dest_addr using Session Description Information:</dt>
<dd style="margin-left: 6">The information included in the transport header can all be coming from the session description, e.g. the SDP c= and m= line. This mitigates some of the security issues of the previous methods as it is the session provider that picks the multicast group and scope. The client MUST include the information if it is available in the session description.</dd>
<dt>No dest_addr:</dt>
<dd style="margin-left: 6">The behavior when no explicit multicast group is present in a request is not defined.</dd>
</dl>

<p>An RTSP proxy will need to take care. If the media is not desired to be routed through the proxy, the proxy will need to introduce the destination indication.</p>
<p id="rfc.section.16.52.p.12">Below are the configuration parameters associated with transport: <br><br> General parameters: </p>

<dl>
<dt>unicast / multicast:</dt>
<dd style="margin-left: 6">This parameter is a mutually exclusive indication of whether unicast or multicast delivery will be attempted. One of the two values MUST be specified. Clients that are capable of handling both unicast and multicast transmission needs to indicate such capability by including two full transport-specs with separate parameters for each.</dd>
<dt>layers:</dt>
<dd style="margin-left: 6">The number of multicast layers to be used for this media stream. The layers are sent to consecutive addresses starting at the dest_addr address. If the parameter is not included, it defaults to a single layer.</dd>
<dt>dest_addr:</dt>
<dd style="margin-left: 6">A general destination address parameter that can contain one or more address specifications. Each combination of protocol/profile/lower transport needs to have the format and interpretation of its address specification defined.  For RTP/AVP/UDP and RTP/AVP/TCP, the address specification is a tuple containing a host address and port. Note, only a single destination parameter per transport spec is intended. The usage of multiple destination to distribute a single media to multiple entities is unspecified. <br><br> The client originating the RTSP request MAY specify the destination address of the stream recipient with the host address part of the tuple.  When the destination address is specified, the recipient may be a different party than the originator of the request. To avoid becoming the unwitting perpetrator of a remote-controlled denial-of-service attack, a server MUST perform security checks (see <a href="#sec-dos">Section 21.1</a>) and SHOULD log such attempts before allowing the client to direct a media stream to a recipient address not chosen by the server. Implementations cannot rely on TCP as reliable means of client identification. If the server does not allow the host address part of the tuple to be set, it MUST return 463 (Destination Prohibited). <br><br> The host address part of the tuple MAY be empty, for example ":58044", in cases when only destination port is desired to be specified.  Responses to requests including the Transport header with a dest_addr parameter SHOULD include the full destination address that is actually used by the server. The server MUST NOT remove address information present already in the request when responding unless the protocol requires it.</dd>
<dt>src_addr:</dt>
<dd style="margin-left: 6">A general source address parameter that can contain one or more address specifications. Each combination of protocol/profile/lower transport needs to have the format and interpretation of its address specification defined. For RTP/AVP/UDP and RTP/AVP/TCP, the address specification is a tuple containing a host address and port. <br><br> This parameter MUST be specified by the server if it transmits media packets from another address than the one RTSP messages are sent to. This will allow the client to verify source address and give it a destination address for its RTCP feedback packets if RTP is used. The address or addresses indicated in the src_addr parameter SHOULD be used both for sending and receiving of the media streams data packets. The main reasons are threefold: First, indicating the port and source address(s) lets the receiver know where from the packets is expected to originate. Secondly, traversal of NATs are greatly simplified when traffic is flowing symmetrically over a NAT binding. Thirdly, certain NAT traversal mechanisms, needs to know to which address and port to send so called "binding packets" from the receiver to the sender, thus creating a address binding in the NAT that the sender to receiver packet flow can use.  <br><br> <dl>
<dt></dt>
<dd style="margin-left: 8">This information may also be available through SDP.  However, since this is more a feature of transport than media initialization, the authoritative source for this information should be in the SETUP response.</dd>
</dl>
</dd>
<dt>mode:</dt>
<dd style="margin-left: 6">The mode parameter indicates the methods to be supported for this session. Currently defined valid values are "PLAY". If not provided, the default is "PLAY". The "RECORD" value was defined in RFC 2326 and is in this specification unspecified but reserved. RECORD and other values may be specified in the future.</dd>
<dt>interleaved:</dt>
<dd style="margin-left: 6">The interleaved parameter implies mixing the media stream with the control stream in whatever protocol is being used by the control stream, using the mechanism defined in <a href="#sec_binary">Section 14</a>. The argument provides the channel number to be used in the $ statement and MUST be present. This parameter MAY be specified as a interval, e.g., interleaved=4-5 in cases where the transport choice for the media stream requires it, e.g. for RTP with RTCP. The channel number given in the request are only a guidance from the client to the server on what channel number(s) to use. The server MAY set any valid channel number in the response. The declared channel(s) are bi-directional, so both end-parties MAY send data on the given channel. One example of such usage is the second channel used for RTCP, where both server and client sends RTCP packets on the same channel. <br><br> <dl>
<dt></dt>
<dd style="margin-left: 8">This allows RTP/RTCP to be handled similarly to the way that it is done with UDP, i.e., one channel for RTP and the other for RTCP.</dd>
</dl>
</dd>
<dt>MIKEY:</dt>
<dd style="margin-left: 6">This parameter is used in conjunction with transport specifications that can utilize MIKEY for security context establishment. So far only the SRTP based RTP profiles SAVP and SAVPF can utilize MIKEY and this is defined in <a href="#sec-mikey">Appendix Appendix C.1.4.1</a>. This parameter can be included both in request and response messages. The binary MIKEY message SHALL be <a href="#RFC4648">BASE64</a> <cite title="NONE">[RFC4648]</cite> encoded before being included in the value part of the parameter.</dd>
</dl>
<p id="rfc.section.16.52.p.13">Multicast-specific: </p>

<dl>
<dt>ttl:</dt>
<dd style="margin-left: 6">multicast time-to-live for IPv4. When included in requests the value indicate the TTL value that the client request the server to use. In a response, the value actually being used by the server is returned. A server will need to consider what values that are reasonable and also the authority of the user to set this value. Corresponding functions are not needed for IPv6 as the scoping is part of the address.</dd>
</dl>
<p id="rfc.section.16.52.p.14">RTP-specific: <br><br> These parameters are MAY only be used if the media transport protocol is RTP. </p>

<dl>
<dt>ssrc:</dt>
<dd style="margin-left: 6">The ssrc parameter, if included in a SETUP response, indicates the RTP SSRC <a href="#RFC3550">[RFC3550]</a> value(s) that will be used by the media server for RTP packets within the stream. It is expressed as an eight digit hexadecimal value. <br><br> The ssrc parameter MUST NOT be specified in requests. The functionality of specifying the ssrc parameter in a SETUP request is deprecated as it is incompatible with the specification of RTP in RFC 3550<a href="#RFC3550">[RFC3550]</a>. If the parameter is included in the Transport header of a SETUP request, the server MAY ignore it, and choose appropriate SSRCs for the stream. The server MAY set the ssrc parameter in the Transport header of the response.</dd>
<dt>RTCP-mux:</dt>
<dd style="margin-left: 6">Use to negotiate the usage of <a href="#RFC5761">RTP and RTCP multiplexing</a> <cite title="NONE">[RFC5761]</cite> on a single underlying transport stream / flow. The presence of this parameter in a SETUP request indicates the clients support and requires the server to use RTP and RTCP multiplexing. The client SHALL only include one transport stream in the Transport header specification. To provide the server with a choice between using RTP/RTCP multiplexing or not, two different transport header specifications must be included.</dd>
</dl>
<p id="rfc.section.16.52.p.15">The parameters setup and connection defined below MAY only be used if the media transport protocol of the lower-level transport is connection-oriented (such as TCP). However, these parameters MUST NOT be used when interleaving data over the RTSP control connection.</p>

<dl>
<dt>setup:</dt>
<dd style="margin-left: 6">Clients use the setup parameter on the Transport line in a SETUP request, to indicate the roles it wishes to play in a TCP connection. This parameter is adapted from <a href="#RFC4145">[RFC4145]</a>. We discuss the use of this parameter in RTP/AVP/TCP non-interleaved transport in <a href="#sec_media-tcp-contrans">Appendix Appendix C.2.2</a>; the discussion below is limited to syntactic issues. Clients may specify the following values for the setup parameter: ["active":] The client will initiate an outgoing connection. ["passive":] The client will accept an incoming connection. ["actpass":] The client is willing to accept an incoming connection or to initiate an outgoing connection. <br><br> If a client does not specify a setup value, the "active" value is assumed. <br><br> In response to a client SETUP request where the setup parameter is set to "active", a server's 2xx reply MUST assign the setup parameter to "passive" on the Transport header line. <br><br> In response to a client SETUP request where the setup parameter is set to "passive", a server's 2xx reply MUST assign the setup parameter to "active" on the Transport header line. <br><br> In response to a client SETUP request where the setup parameter is set to "actpass", a server's 2xx reply MUST assign the setup parameter to "active" or "passive" on the Transport header line. <br><br> Note that the "holdconn" value for setup is not defined for RTSP use, and MUST NOT appear on a Transport line.</dd>
<dt>connection:</dt>
<dd style="margin-left: 6">Clients use the setup parameter on the Transport line in a SETUP request, to indicate the SETUP request prefers the reuse of an existing connection between client and server (in which case the client sets the "connection" parameter to "existing"), or that the client requires the creation of a new connection between client and server (in which cast the client sets the "connection" parameter to "new"). Typically, clients use the "new" value for the first SETUP request for a URL, and "existing" for subsequent SETUP requests for a URL. <br><br> If a client SETUP request assigns the "new" value to "connection", the server response MUST also assign the "new" value to "connection" on the Transport line. <br><br> If a client SETUP request assigns the "existing" value to "connection", the server response MUST assign a value of "existing" or "new" to "connection" on the Transport line, at its discretion. <br><br> The default value of "connection" is "existing", for all SETUP requests (initial and subsequent).</dd>
</dl>
<p id="rfc.section.16.52.p.16">The combination of transport protocol, profile and lower transport needs to be defined. A number of combinations are defined in the <a href="#sec_mediatran">Appendix Appendix C</a>.</p>
<div id="#rfc.figure.56"></div>
<pre>
  C-&gt;S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0
        CSeq: 302
        Transport: RTP/AVP;multicast;mode="PLAY",
            RTP/AVP;unicast;dest_addr="192.0.2.5:3456"/
            "192.0.2.5:3457";mode="PLAY"
        Accept-Ranges: NPT, SMPTE, UTC
        User-Agent: PhonyClient/1.2

  S-&gt;C: RTSP/2.0 200 OK
        CSeq: 302
        Date: Thu, 23 Jan 1997 15:35:06 GMT
        Session: 47112344
        Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:3456"/
           "192.0.2.5:3457";src_addr="192.0.2.224:6256"/
           "192.0.2.224:6257";mode="PLAY"
        Accept-Ranges: NPT
        Media-Properties: Random-Access=0.6, Dynamic, 
                          Time-Limited=20081128T165900
</pre>
<p id="rfc.section.16.52.p.17">Below is a usage example, showing a client advertising the capability to handle multicast or unicast, preferring multicast. Since this is a unicast-only stream, the server responds with the proper transport parameters for unicast. </p>
<h1 id="rfc.section.16.53">
<a href="#rfc.section.16.53">16.53.</a> <a href="#sec_Unsupported" id="sec_Unsupported">Unsupported</a>
</h1>
<p id="rfc.section.16.53.p.1">The Unsupported response-header lists the features not supported by the responding RTSP agent. In the case where the feature was specified via the Proxy-Require field (<a href="#sec_Proxy-Require">Section 16.35</a>), if there is a proxy on the path between the client and the server, the proxy MUST send a response message with a status code of 551 (Option Not Supported). The request MUST NOT be forwarded.</p>
<p id="rfc.section.16.53.p.2">See <a href="#sec_Require">Section 16.41</a> for a usage example.</p>
<h1 id="rfc.section.16.54">
<a href="#rfc.section.16.54">16.54.</a> <a href="#sec_User-Agent" id="sec_User-Agent">User-Agent</a>
</h1>
<p id="rfc.section.16.54.p.1">The User-Agent general-header field contains information about the user agent originating the request. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application.</p>
<p id="rfc.section.16.54.p.2">Example:</p>
<div id="#rfc.figure.57"></div>
<pre>User-Agent: PhonyClient/1.2</pre>
<h1 id="rfc.section.16.55">
<a href="#rfc.section.16.55">16.55.</a> <a href="#sec_Vary" id="sec_Vary">Vary</a>
</h1>
<p id="rfc.section.16.55.p.1">The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. For uncacheable or stale responses, the Vary field value advises the user agent about the criteria that were used to select the representation. A Vary field value of "*" implies that a cache cannot determine from the request headers of a subsequent request whether this response is the appropriate representation.</p>
<p id="rfc.section.16.55.p.2">An RTSP server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation. Doing so allows a cache to properly interpret future requests on that resource and informs the user agent about the presence of negotiation on that resource. A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response.</p>
<p id="rfc.section.16.55.p.3">A Vary field value consisting of a list of field-names signals that the representation selected for the response is based on a selection algorithm which considers ONLY the listed request-header field values in selecting the most appropriate representation. A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh.</p>
<p id="rfc.section.16.55.p.4">The field-names given are not limited to the set of standard request-header fields defined by this specification. Field names are case-insensitive.</p>
<p id="rfc.section.16.55.p.5">A Vary field value of "*" signals that unspecified parameters not limited to the request-headers (e.g., the network address of the client), play a role in the selection of the response representation.  The "*" value MUST NOT be generated by a proxy server; it may only be generated by an origin server.</p>
<h1 id="rfc.section.16.56">
<a href="#rfc.section.16.56">16.56.</a> <a href="#sec_Via" id="sec_Via">Via</a>
</h1>
<p id="rfc.section.16.56.p.1">The Via general-header field MUST be used by proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses. The field is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain.</p>
<p id="rfc.section.16.56.p.2">Multiple Via field values represents each proxy that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications.</p>
<p id="rfc.section.16.56.p.3">Proxies (e.g., Access Proxy or Translator Proxy) SHOULD NOT, by default, forward the names and ports of hosts within the private/protected region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the via-received of any host behind the firewall/NAT SHOULD be replaced by an appropriate pseudonym for that host.</p>
<p id="rfc.section.16.56.p.4">For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical sent-protocol values into a single such entry. Applications MUST NOT combine entries which have different received-protocol values.</p>
<h1 id="rfc.section.16.57">
<a href="#rfc.section.16.57">16.57.</a> <a href="#sec_WWW-Authenticate" id="sec_WWW-Authenticate">WWW-Authenticate</a>
</h1>
<p id="rfc.section.16.57.p.1">The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the Request-URI.</p>
<p id="rfc.section.16.57.p.2">The HTTP access authentication process is described in <a href="#RFC2617">[RFC2617]</a>. User agents are advised to take special care in parsing the WWW- Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters.</p>
<h1 id="rfc.section.17">
<a href="#rfc.section.17">17.</a> <a href="#sec_proxies" id="sec_proxies">Proxies</a>
</h1>
<p id="rfc.section.17.p.1">RTSP Proxies are RTSP agents that sit in between a client and a server. A proxy can take on both the role as a client and as server depending on what it tries to accomplish. Proxies are also introduced for several different reasons and the below are often combined. </p>

<dl>
<dt>Caching Proxy:</dt>
<dd style="margin-left: 6">This type of proxy is used to reduce the workload on servers and connections. By caching the description and media streams, i.e., the presentation, the proxy can serve a client with content, but without requesting it from the server once it has been cached and has not become stale. See the caching <a href="#sec_caching">Section 18</a>. This type of proxy is also expected to understand RTSP end-point functionality, i.e., functionality identified in the Require header in addition to what Proxy-Require demands.</dd>
<dt>Translator Proxy:</dt>
<dd style="margin-left: 6">This type of proxy is used to ensure that an RTSP client get access to servers and content on an external network or using content encodings not supported by the client. The proxy performs the necessary translation of addresses, protocols or encodings. This type of proxy is expected to also understand RTSP end-point functionality, i.e. functionality identified in the Require header in addition to what Proxy-Require demands.</dd>
<dt>Access Proxy:</dt>
<dd style="margin-left: 6">This type of proxy is used to ensure that a RTSP client get access to servers on an external network.  Thus this proxy is placed on the border between two domains, e.g. a private address space and the public Internet. The proxy performs the necessary translation, usually addresses. This type of proxies are required to redirect the media to themselves or a controlled gateway that perform the translation before the media can reach the client.</dd>
<dt>Security Proxy:</dt>
<dd style="margin-left: 6">This type of proxy is used to help facilitate security functions around RTSP. For example when having a firewalled network, the security proxy request that the necessary pinholes in the firewall is opened when a client in the protected network want to access media streams on the external side. This proxy can also limit the clients access to certain type of content.  This proxy can perform its function without redirecting the media between the server and client. However, in deployments with private address spaces this proxy is likely to be combined with the access proxy. Anyway, the functionality of this proxy is usually closely tied into understand all aspects of the media transport.</dd>
<dt>Auditing Proxy:</dt>
<dd style="margin-left: 6">RTSP proxies can also provide network owners with a logging and audit point for RTSP sessions, e.g. for corporations that tracks their employees usage of the network. This type of proxy can perform its function without inserting itself or any other node in the media transport. This proxy type can also accept unknown methods as it doesn't interfere with the clients' requests.</dd>
</dl>
<p id="rfc.section.17.p.2">All type of proxies can be used also when using secured communication with TLS as RTSP 2.0 allows the client to approve certificate chains used for connection establishment from a proxy, see <a href="#sec_security-tls-proxy">Section 19.3.2</a>. However, that trust model may not be suitable for all type of deployment. In those cases, the secured sessions do by-pass of the proxies.</p>
<p id="rfc.section.17.p.3">Access proxies SHOULD NOT be used in equipment like NATs and firewalls that aren't expected to be regularly maintained, like home or small office equipment. In these cases it is better to use the NAT traversal procedures defined for RTSP 2.0 <a href="#I-D.ietf-mmusic-rtsp-nat">[I-D.ietf-mmusic-rtsp-nat]</a>. The reason for these recommendations is that any extensions of RTSP resulting in new media transport protocols or profiles, new parameters etc may fail in a proxy that isn't maintained. This would impede RTSP's future development and usage.</p>
<h1 id="rfc.section.17.1">
<a href="#rfc.section.17.1">17.1.</a> <a href="#sec_proxies_ext" id="sec_proxies_ext">Proxies and Protocol Extensions</a>
</h1>
<p id="rfc.section.17.1.p.1">The existence of proxies must always be considered when developing new RTSP extensions. Most types of proxies will need to implement any new method to operate correctly in the presence of that extension. New headers can be introduced and will not be blocked by older proxies.  However, it is important to consider if this header and its function is required to be understood by the proxy or can be forwarded. If the header needs to be understood a feature-tag representing the functionality needs to be included in the Proxy-Require header. Below are guidelines for analysis if the header needs to be understood. The transport header and its parameters also shows that headers that are extensible and require correct interpretation in the proxy also require handling rules.</p>
<p id="rfc.section.17.1.p.2">Whether a proxy needs to understand a header is not easy to determine, as they serve a broad variety of functions. When evaluating if a header needs to be understood, one can divide the functionality into three main categories:</p>

<dl>
<dt>Media modifying:</dt>
<dd style="margin-left: 8">The caching and translator proxies are modifying the actual media and therefore needs to understand also request directed to the server that affects how the media is rendered. Thus, this type of proxies needs to also understand the server side functionality.</dd>
<dt>Transport modifying:</dt>
<dd style="margin-left: 8">The access and the security proxy both need to understand how the transport is performed, either for opening pinholes or to translate the outer headers, e.g. IP and UDP.</dd>
<dt>Non-modifying:</dt>
<dd style="margin-left: 8">The audit proxy is special in that it do not modify the messages in other ways than to insert the Via header. That makes it possible for this type to forward RTSP message that contains different type of unknown methods, headers or header parameters.</dd>
</dl>

<p>Based on the above classification, one should evaluate if the new functionality requires the Transport modifying type of proxies to understand it or not.</p>
<p></p>
<h1 id="rfc.section.17.2">
<a href="#rfc.section.17.2">17.2.</a> <a href="#sec_proxies_cseq" id="sec_proxies_cseq">Multiplexing and Demultiplexing of Messages</a>
</h1>
<p id="rfc.section.17.2.p.1">RTSP proxies may have to multiplex multiple RTSP sessions from their clients towards RTSP servers. This requires that RTSP requests from multiple clients are multiplexed onto a common connection for requests outgoing to a RTSP server and on the way back the responses are demultiplexed from the server to per client responses. On the protocol level this requires that request and response messages are handled in both ways, requiring that there is a mechanism to correlated what request/response pair exchanged between proxy and server is mapped to what client (or client request).</p>
<p id="rfc.section.17.2.p.2">This multiplexing of requests and demultiplexing of responses is done by using the CSeq header field (see <a href="#sec_CSeq">Section 16.19</a>). The proxy has to rewrite the CSeq in requests to the server and responses from the server and remember what CSeq is mapped to what client.</p>
<h1 id="rfc.section.18">
<a href="#rfc.section.18">18.</a> <a href="#sec_caching" id="sec_caching">Caching</a>
</h1>
<p id="rfc.section.18.p.1">In HTTP, response-request pairs are cached. RTSP differs significantly in that respect. Responses are not cacheable, with the exception of the presentation description returned by DESCRIBE. (Since the responses for anything but DESCRIBE and GET_PARAMETER do not return any data, caching is not really an issue for these requests.) However, it is desirable for the continuous media data, typically delivered out-of-band with respect to RTSP, to be cached, as well as the session description.</p>
<p id="rfc.section.18.p.2">On receiving a SETUP or PLAY request, a proxy ascertains whether it has an up-to-date copy of the continuous media content and its description. It can determine whether the copy is up-to-date by issuing a SETUP or DESCRIBE request, respectively, and comparing the Last-Modified header with that of the cached copy. If the copy is not up-to-date, it modifies the SETUP transport parameters as appropriate and forwards the request to the origin server. Subsequent control commands such as PLAY or PAUSE then pass the proxy unmodified. The proxy delivers the continuous media data to the client, while possibly making a local copy for later reuse. The exact allowed behavior of the cache is given by the cache-response directives described in <a href="#sec_Cache-Control">Section 16.10</a>. A cache MUST answer any DESCRIBE requests if it is currently serving the stream to the requester, as it is possible that low-level details of the stream description may have changed on the origin-server.</p>
<p id="rfc.section.18.p.3">Note that an RTSP cache, is of the "cut-through" variety. Rather than retrieving the whole resource from the origin server, the cache simply copies the streaming data as it passes by on its way to the client.  Thus, it does not introduce additional latency.</p>
<p id="rfc.section.18.p.4">To the client, an RTSP proxy cache appears like a regular media server, to the media origin server like a client. Just as an HTTP cache has to store the content type, content language, and so on for the objects it caches, a media cache has to store the presentation description. Typically, a cache eliminates all transport-references (that is, e.g. multicast information) from the presentation description, since these are independent of the data delivery from the cache to the client. Information on the encodings remains the same. If the cache is able to translate the cached media data, it would create a new presentation description with all the encoding possibilities it can offer.</p>
<h1 id="rfc.section.18.1">
<a href="#rfc.section.18.1">18.1.</a>  Validation Model</h1>
<p id="rfc.section.18.1.p.1">When a cache has a stale entry that it would like to use as a response to a client's request, it first has to check with the origin server (or possibly an intermediate cache with a fresh response) to see if its cached entry is still usable. We call this "validating" the cache entry. Since we do not want to have to pay the overhead of retransmitting the full response if the cached entry is good, and we do not want to pay the overhead of an extra round trip if the cached entry is invalid, the RTSP protocol supports the use of conditional methods.</p>
<p id="rfc.section.18.1.p.2">The key protocol features for supporting conditional methods are those concerned with "cache validators." When an origin server generates a full response, it attaches some sort of validator to it, which is kept with the cache entry. When a client (user agent or proxy cache) makes a conditional request for a resource for which it has a cache entry, it includes the associated validator in the request.</p>
<p id="rfc.section.18.1.p.3">The server then checks that validator against the current validator for the requested resource, and, if they match (see <a href="#sec.weak_strong_validators">Section 18.1.3</a>), it responds with a special status code (usually, 304 (Not Modified)) and no message body.  Otherwise, it returns a full response (including message body). Thus, we avoid transmitting the full response if the validator matches, and we avoid an extra round trip if it does not match.</p>
<p id="rfc.section.18.1.p.4">In RTSP, a conditional request looks exactly the same as a normal request for the same resource, except that it carries a special header (which includes the validator) that implicitly turns the method (usually DESCRIBE or SETUP) into a conditional.</p>
<p id="rfc.section.18.1.p.5">The protocol includes both positive and negative senses of cache-validating conditions. That is, it is possible to request either that a method be performed if and only if a validator matches or if and only if no validators match.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: a response that lacks a validator may still be cached, and served from cache until it expires, unless this is explicitly prohibited by a cache-control directive (see <a href="#sec_Cache-Control">Section 16.10</a>). However, a cache cannot do a conditional retrieval if it does not have a validator for the resource, which means it will not be refreshable after it expires.</dd>
</dl>

<p>Media streams that are being adapted based on the transport capacity between the server and the cache makes caching more difficult. A server needs to consider how it views caching of media streams that it adapts and potentially instruct any caches to not cache such streams.</p>
<h1 id="rfc.section.18.1.1">
<a href="#rfc.section.18.1.1">18.1.1.</a> Last-Modified Dates </h1>
<p id="rfc.section.18.1.1.p.1">The Last-Modified header (<a href="#sec_Last-Modified">Section 16.26</a>) value is often used as a cache validator. In simple terms, a cache entry is considered to be valid if the content has not been modified since the Last-Modified value.</p>
<h1 id="rfc.section.18.1.2">
<a href="#rfc.section.18.1.2">18.1.2.</a> Message Body Tag Cache Validators</h1>
<p id="rfc.section.18.1.2.p.1">The MTag response-header field value, an message body tag, provides for an "opaque" cache validator. This might allow more reliable validation in situations where it is inconvenient to store modification dates, where the one-second resolution of RTSP-date values is not sufficient, or where the origin server wishes to avoid certain paradoxes that might arise from the use of modification dates.</p>
<p id="rfc.section.18.1.2.p.2">Message body tags are described in <a href="#sec_message-body">Section 5.3</a></p>
<h1 id="rfc.section.18.1.3">
<a href="#rfc.section.18.1.3">18.1.3.</a> <a href="#sec.weak_strong_validators" id="sec.weak_strong_validators">Weak and Strong Validators</a>
</h1>
<p id="rfc.section.18.1.3.p.1">Since both origin servers and caches will compare two validators to decide if they represent the same or different entities, one normally would expect that if the message body (i.e., the presentation description) or any associated message body headers changes in any way, then the associated validator would change as well. If this is true, then we call this validator a "strong validator." We call message body (i.e., the presentation description) or any associated message body headers an entity for a better understanding.</p>
<p id="rfc.section.18.1.3.p.2">However, there might be cases when a server prefers to change the validator only on semantically significant changes, and not when insignificant aspects of the entity change. A validator that does not always change when the resource changes is a "weak validator."</p>
<p id="rfc.section.18.1.3.p.3">Message body tags are normally "strong validators," but the protocol provides a mechanism to tag an message body tag as "weak." One can think of a strong validator as one that changes whenever the bits of an entity changes, while a weak value changes whenever the meaning of an entity changes. Alternatively, one can think of a strong validator as part of an identifier for a specific entity, while a weak validator is part of an identifier for a set of semantically equivalent entities.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: One example of a strong validator is an integer that is incremented in stable storage every time an entity is changed.</dd>
<dt></dt>
<dd style="margin-left: 8">An entity's modification time, if represented with one-second resolution, could be a weak validator, since it is possible that the resource might be modified twice during a single second.</dd>
<dt></dt>
<dd style="margin-left: 8">Support for weak validators is optional. However, weak validators allow for more efficient caching of equivalent objects.</dd>
</dl>

<p>A "use" of a validator is either when a client generates a request and includes the validator in a validating header field, or when a server compares two validators.</p>
<p id="rfc.section.18.1.3.p.5">Strong validators are usable in any context. Weak validators are only usable in contexts that do not depend on exact equality of an entity. For example, either kind is usable for a conditional DESCRIBE of a full entity. However, only a strong validator is usable for a sub-range retrieval, since otherwise the client might end up with an internally inconsistent entity.</p>
<p id="rfc.section.18.1.3.p.6">Clients MAY issue DESCRIBE requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.</p>
<p id="rfc.section.18.1.3.p.7">The only function that the RTSP protocol defines on validators is comparison. There are two validator comparison functions, depending on whether the comparison context allows the use of weak validators or not: </p>

<ul>
<li>The strong comparison function: in order to be considered equal, both validators MUST be identical in every way, and both MUST NOT be weak.</li>
<li>The weak comparison function: in order to be considered equal, both validators MUST be identical in every way, but either or both of them MAY be tagged as "weak" without affecting the result.</li>
</ul>

<p>An message body tag is strong unless it is explicitly tagged as weak.</p>
<p id="rfc.section.18.1.3.p.8">A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules: </p>

<ul>
<li>The validator is being compared by an origin server to the actual current validator for the entity and,</li>
<li>That origin server reliably knows that the associated entity did not change twice during the second covered by the presented validator.</li>
</ul>

<p>OR</p>
<p></p>

<ul>
<li>The validator is about to be used by a client in an If-Modified-Since, because the client has a cache entry for the associated entity, and</li>
<li>That cache entry includes a Date value, which gives the time when the origin server sent the original response, and</li>
<li>The presented Last-Modified time is at least 60 seconds before the Date value.</li>
</ul>

<p>OR</p>
<p></p>

<ul>
<li>The validator is being compared by an intermediate cache to the validator stored in its cache entry for the entity, and</li>
<li>That cache entry includes a Date value, which gives the time when the origin server sent the original response, and</li>
<li>The presented Last-Modified time is at least 60 seconds before the Date value.</li>
</ul>

<p>This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time.  The arbitrary 60- second limit guards against the possibility that the Date and Last- Modified values are generated from different clocks, or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.</p>
<p id="rfc.section.18.1.3.p.11">If a client wishes to perform a sub-range retrieval on a value for which it has only a Last-Modified time and no opaque validator, it MAY do this only if the Last-Modified time is strong in the sense described here.</p>
<h1 id="rfc.section.18.1.4">
<a href="#rfc.section.18.1.4">18.1.4.</a> <a href="#sec.rule_entity_lastmod" id="sec.rule_entity_lastmod">Rules for When to Use Message Body Tags and Last-Modified Dates</a>
</h1>
<p id="rfc.section.18.1.4.p.1">We adopt a set of rules and recommendations for origin servers, clients, and caches regarding when various validator types ought to be used, and for what purposes.</p>
<p id="rfc.section.18.1.4.p.2">RTSP origin servers: </p>

<ul>
<li>SHOULD send an message body tag validator unless it is not feasible to generate one.</li>
<li>MAY send a weak message body tag instead of a strong message body tag, if performance considerations support the use of weak message body tags, or if it is unfeasible to send a strong message body tag.</li>
<li>SHOULD send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could result from using this date in an If-Modified-Since header would lead to serious problems.</li>
</ul>

<p>In other words, the preferred behavior for an RTSP origin server is to send both a strong message body tag and a Last-Modified value.</p>
<p id="rfc.section.18.1.4.p.3">In order to be legal, a strong message body tag MUST change whenever the associated entity value changes in any way. A weak message body tag SHOULD change whenever the associated entity changes in a semantically significant way.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: in order to provide semantically transparent caching, an origin server must avoid reusing a specific strong message body tag value for two different entities, or reusing a specific weak message body tag value for two semantically different entities. Cache entries might persist for arbitrarily long periods, regardless of expiration times, so it might be inappropriate to expect that a cache will never again attempt to validate an entry using a validator that it obtained at some point in the past.</dd>
</dl>
<p id="rfc.section.18.1.4.p.5">RTSP clients: </p>

<ul>
<li>If an message body tag has been provided by the origin server, MUST use that message body tag in any cache-conditional request (using If- Match or If-None-Match).</li>
<li>If only a Last-Modified value has been provided by the origin server, SHOULD use that value in non-subrange cache-conditional requests (using If-Modified-Since).</li>
<li>If both an message body tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests.</li>
</ul>

<p>An RTSP origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g., in an If-Modified-Since header) and one or more message body tags (e.g., in an If-Match, If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: The general principle behind these rules is that RTSP servers and clients should transmit as much non-redundant information as is available in their responses and requests.  RTSP systems receiving this information will make the most conservative assumptions about the validators they receive.</dd>
</dl>
<h1 id="rfc.section.18.1.5">
<a href="#rfc.section.18.1.5">18.1.5.</a> Non-validating Conditionals</h1>
<p id="rfc.section.18.1.5.p.1">The principle behind message body tags is that only the service author knows the semantics of a resource well enough to select an appropriate cache validation mechanism, and the specification of any validator comparison function more complex than byte-equality would open up a can of worms. Thus, comparisons of any other headers are never used for purposes of validating a cache entry.</p>
<h1 id="rfc.section.18.2">
<a href="#rfc.section.18.2">18.2.</a> <a href="#sec.chache_invalidation" id="sec.chache_invalidation">Invalidation After Updates or Deletions</a>
</h1>
<p id="rfc.section.18.2.p.1">The effect of certain methods performed on a resource at the origin server might cause one or more existing cache entries to become non- transparently invalid. That is, although they might continue to be "fresh," they do not accurately reflect what the origin server would return for a new request on that resource.</p>
<p id="rfc.section.18.2.p.2">There is no way for the RTSP protocol to guarantee that all such cache entries are marked invalid. For example, the request that caused the change at the origin server might not have gone through the proxy where a cache entry is stored. However, several rules help reduce the likelihood of erroneous behavior.</p>
<p id="rfc.section.18.2.p.3">In this section, the phrase "invalidate an entity" means that the cache will either remove all instances of that entity from its storage, or will mark these as "invalid" and in need of a mandatory revalidation before they can be returned in response to a subsequent request.</p>
<p id="rfc.section.18.2.p.4">Some RTSP methods MUST cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI, or by the Location or Content-Location headers (if present). These methods are: </p>

<ul>
<li>DESCRIBE</li>
<li>SETUP</li>
</ul>

<p>In order to prevent denial of service attacks, an invalidation based on the URI in a Location or Content-Location header MUST only be performed if the host part is the same as in the Request-URI.</p>
<p id="rfc.section.18.2.p.5">A cache that passes through requests for methods it does not understand SHOULD invalidate any entities referred to by the Request-URI.</p>
<h1 id="rfc.section.19">
<a href="#rfc.section.19">19.</a> <a href="#sec_security-framework" id="sec_security-framework">Security Framework</a>
</h1>
<p id="rfc.section.19.p.1">The RTSP security framework consists of two high level components: the pure authentication mechanisms based on HTTP authentication, and the message transport protection based on TLS, which is independent of RTSP.  Because of the similarity in syntax and usage between RTSP servers and HTTP servers, the security for HTTP is re-used to a large extent.</p>
<h1 id="rfc.section.19.1">
<a href="#rfc.section.19.1">19.1.</a> RTSP and HTTP Authentication</h1>
<p id="rfc.section.19.1.p.1">RTSP and HTTP share common authentication schemes, and thus follow the same usage guidelines as specified in<a href="#RFC2617">[RFC2617]</a> and also in [H15]. Servers SHOULD implement both basic and digest <a href="#RFC2617">[RFC2617]</a> authentication.  Client MUST implement both basic and digest authentication <a href="#RFC2617">[RFC2617]</a> so that Server who requires the client to authenticate can trust that the capability is present.</p>
<p id="rfc.section.19.1.p.2">It should be stressed that using the HTTP authentication alone does not provide full control message security. Therefore, in environments requiring tighter security for the control messages, TLS SHOULD be used, see <a href="#sec_sec-frame-TLS">Section 19.2</a>.</p>
<h1 id="rfc.section.19.2">
<a href="#rfc.section.19.2">19.2.</a> <a href="#sec_sec-frame-TLS" id="sec_sec-frame-TLS">RTSP over TLS</a>
</h1>
<p id="rfc.section.19.2.p.1">RTSP MUST follow the same guidelines with regards to TLS <a href="#RFC5246">[RFC5246]</a> usage as specified for HTTP, see <a href="#RFC2818">[RFC2818]</a>. RTSP over TLS is separated from unsecured RTSP both on URI level and port level. Instead of using the "rtsp" scheme identifier in the URI, the "rtsps" scheme identifier MUST be used to signal RTSP over TLS. If no port is given in a URI with the "rtsps" scheme, port 322 MUST be used for TLS over TCP/IP.</p>
<p id="rfc.section.19.2.p.2">When a client tries to setup an insecure channel to the server (using the "rtsp" URI), and the policy for the resource requires a secure channel, the server MUST redirect the client to the secure service by sending a 301 redirect response code together with the correct Location URI (using the "rtsps" scheme). A user or client MAY upgrade a non secured URI to a secured by changing the scheme from "rtsp" to "rtsps". A server implementing support for "rtsps" MUST allow this.</p>
<p id="rfc.section.19.2.p.3">It should be noted that TLS allows for mutual authentication (when using both server and client certificates). Still, one of the more common ways TLS is used is to only provide server side authentication (often to avoid client certificates). TLS is then used in addition to HTTP authentication, providing transport security and server authentication, while HTTP Authentication is used to authenticate the client.</p>
<p id="rfc.section.19.2.p.4">RTSP includes the possibility to keep a TCP session up between the client and server, throughout the RTSP session lifetime. It may be convenient to keep the TCP session, not only to save the extra setup time for TCP, but also the extra setup time for TLS (even if TLS uses the resume function, there will be almost two extra round trips).  Still, when TLS is used, such behavior introduces extra active state in the server, not only for TCP and RTSP, but also for TLS. This may increase the vulnerability to DoS attacks.</p>
<p id="rfc.section.19.2.p.5">In addition to these recommendations, <a href="#sec_sec-frame-proxy">Section 19.3</a> gives further recommendations of TLS usage with proxies.</p>
<h1 id="rfc.section.19.3">
<a href="#rfc.section.19.3">19.3.</a> <a href="#sec_sec-frame-proxy" id="sec_sec-frame-proxy">Security and Proxies</a>
</h1>
<p id="rfc.section.19.3.p.1">The nature of a proxy is often to act as a "man-in-the-middle", while security is often about preventing the existence of a "man-in-the-middle". This section provides clients with the possibility to use proxies even when applying secure transports (TLS) between the RTSP agents. The TLS proxy mechanism allows for server and proxy identification using certificates. However, the client can not be identified based on certificates. The client needs to select between using the procedure specified below or using a TLS connection directly (by-passing any proxies) to the server. The choice may be dependent on policies.</p>
<p id="rfc.section.19.3.p.2">There are basically two categories of proxies, the transparent proxies (of which the client is not aware) and the non-transparent proxies (of which the client is aware). An infrastructure based on proxies requires that the trust model is such that both client and servers can trust the proxies to handle the RTSP messages correctly.  To be able to trust a proxy, the client and server also needs to be aware of the proxy. Hence, transparent proxies cannot generally be seen as trusted and will not work well with security (unless they work only at transport layer). In the rest of this section any reference to proxy will be to a non-transparent proxy, which inspects or manipulate the RTSP messages.</p>
<p id="rfc.section.19.3.p.3">HTTP Authentication is built on the assumption of proxies and can provide user-proxy authentication and proxy-proxy/server authentication in addition to the client-server authentication.</p>
<p id="rfc.section.19.3.p.4">When TLS is applied and a proxy is used, the client will connect to the proxy's address when connecting to any RTSP server. This implies that for TLS, the client will authenticate the proxy server and not the end server. Note that when the client checks the server certificate in TLS, it MUST check the proxy's identity (URI or possibly other known identity) against the proxy's identity as presented in the proxy's Certificate message.</p>
<p id="rfc.section.19.3.p.5">The problem is that for a proxy accepted by the client, the proxy needs to be provided information on which grounds it should accept the next-hop certificate. Both the proxy and the user may have rules for this, and the user have the possibility to select the desired behavior. To handle this case, the Accept-Credentials header (See <a href="#sec_Accept-Credentials">Section 16.2</a>) is used, where the client can force the proxy/proxies to relay back the chain of certificates used to authenticate any intermediate proxies as well as the server. Given the assumption that the proxies are viewed as trusted, it gives the user a possibility to enforce policies to each trusted proxy of whether it should accept the next agent in the chain.</p>
<p id="rfc.section.19.3.p.6">A proxy MUST use TLS for the next hop if the RTSP request includes a "rtsps" URI. TLS MAY be applied on intermediate links (e.g. between client and proxy, or between proxy and proxy), even if the resource and the end server are not require to use it. The proxy MUST, when initiating the next hop TLS connection, use the incoming TLS connections cipher suite list, only modified by removing any cipher suits that the proxy does not support. In case a proxy fails to establish a TLS connection due to cipher suite mismatch between proxy and next hop proxy or server, this is indicated using error code 472 (Failure to establish secure connection).</p>
<h1 id="rfc.section.19.3.1">
<a href="#rfc.section.19.3.1">19.3.1.</a> <a href="#sec-frame-accept-cred" id="sec-frame-accept-cred">Accept-Credentials</a>
</h1>
<p id="rfc.section.19.3.1.p.1">The Accept-Credentials header can be used by the client to distribute simple authorization policies to intermediate proxies.  The client includes the Accept-Credentials header to dictate how the proxy treats the server/next proxy certificate. There are currently three methods defined: </p>

<dl>
<dt>Any,</dt>
<dd style="margin-left: 6">which means that the proxy (or proxies) MUST accept whatever certificate presented. This is of course not a recommended option to use, but may be useful in certain circumstances (such as testing).</dd>
<dt>Proxy,</dt>
<dd style="margin-left: 6">which means that the proxy (or proxies) MUST use its own policies to validate the certificate and decide whether to accept it or not. This is convenient in cases where the user has a strong trust relation with the proxy. Reason why a strong trust relation may exist are; personal/company proxy, proxy has a out-of-band policy configuration mechanism.</dd>
<dt>User,</dt>
<dd style="margin-left: 6">which means that the proxy (or proxies) MUST send credential information about the next hop to the client for authorization. The client can then decide whether the proxy should accept the certificate or not. See <a href="#sec_security-tls-proxy">Section 19.3.2</a> for further details.</dd>
</dl>
<p id="rfc.section.19.3.1.p.2">If the Accept-Credentials header is not included in the RTSP request from the client, then the "Proxy" method MUST be used as default. If another method than the "Proxy" is to be used, then the Accept-Credentials header MUST be included in all of the RTSP request from the client. This is because it cannot be assumed that the proxy always keeps the TLS state or the users previous preference between different RTSP messages (in particular if the time interval between the messages is long).</p>
<p id="rfc.section.19.3.1.p.3">With the "Any" and "Proxy" methods the proxy will apply the policy as defined for respectively method. If the policy does not accept the credentials of the next hop, the proxy MUST respond with a message using status code 471 (Connection Credentials not accepted).</p>
<p id="rfc.section.19.3.1.p.4">An RTSP request in the direction server to client MUST NOT include the Accept-Credential header. As for the non-secured communication, the possibility for these requests depends on the presence of a client established connection. However, if the server to client request is in relation to a session established over a TLS secured channel, it MUST be sent in a TLS secured connection. That secured connection MUST also be the one used by the last client to server request. If no such transport connection exist at the time when the server desires to send the request, the server discard the message.</p>
<p id="rfc.section.19.3.1.p.5">Further policies MAY be defined and registered, but should be done so with caution.</p>
<h1 id="rfc.section.19.3.2">
<a href="#rfc.section.19.3.2">19.3.2.</a> <a href="#sec_security-tls-proxy" id="sec_security-tls-proxy">User approved TLS procedure</a>
</h1>
<p id="rfc.section.19.3.2.p.1">For the "User" method, each proxy MUST perform the following procedure for each RTSP request: </p>

<ul>
<li>Setup the TLS session to the next hop if not already present (i.e. run the TLS handshake, but do not send the RTSP request).</li>
<li>Extract the peer certificate chain for the TLS session.</li>
<li>Check if a matching identity and hash of the peer certificate is present in the Accept-Credentials header. If present, send the message to the next hop, and conclude these procedures. If not, go to the next step.</li>
<li>The proxy responds to the RTSP request with a 470 or 407 response code. The 407 response code MAY be used when the proxy requires both user and connection authorization from user or client. In this message the proxy MUST include a Connection-Credentials header, see <a href="#sec_Connection-Credentials">Section 16.12</a> with the next hop's identity and certificate.</li>
</ul>
<p id="rfc.section.19.3.2.p.2">The client MUST upon receiving a 470 or 407 response with Connection-Credentials header take the decision on whether to accept the certificate or not (if it cannot do so, the user SHOULD be consulted). If the certificate is accepted, the client has to again send the RTSP request. In that request the client has to include the Accept-Credentials header including the hash over the DER encoded certificate for all trusted proxies in the chain.</p>
<div id="#rfc.figure.58"></div>
<pre>
C-&gt;P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0
      CSeq: 2
      Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:4588"/
                 "192.0.2.5:4589"
      Accept-Ranges: NPT, SMPTE, UTC
      Accept-Credentials: User

P-&gt;C: RTSP/2.0 470 Connection Authorization Required
      CSeq: 2
      Connection-Credentials: "rtsps://test.example.org";
      MIIDNTCCAp...

C-&gt;P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0
      CSeq: 3
      Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:4588"/
                 "192.0.2.5:4589"
      Accept-Credentials: User "rtsps://test.example.org";sha-256;
      dPYD7txpoGTbAqZZQJ+vaeOkyH4=
      Accept-Ranges: NPT, SMPTE, UTC

P-&gt;S: SETUP rtsps://test.example.org/secret/audio RTSP/2.0
      CSeq: 3
      Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:4588"/
                 "192.0.2.5:4589"
      Via: RTSP/2.0 proxy.example.org
      Accept-Credentials: User "rtsps://test.example.org";sha-256;
      dPYD7txpoGTbAqZZQJ+vaeOkyH4=
      Accept-Ranges: NPT, SMPTE, UTC
      </pre>
<p id="rfc.section.19.3.2.p.3">Example: </p>
<p id="rfc.section.19.3.2.p.4">One implication of this process is that the connection for secured RTSP messages may take significantly more round-trip times for the first message. A complete extra message exchange between the proxy connecting to the next hop and the client results because of the process for approval for each hop. However, if each message contains the chain of proxies that the requester accepts, the remaining message exchange should not be delayed. The procedure of including the credentials in each request rather than building state in each proxy, avoids the need for revocation procedures.</p>
<h1 id="rfc.section.20">
<a href="#rfc.section.20">20.</a> <a href="#sec_syntax" id="sec_syntax">Syntax</a>
</h1>
<p id="rfc.section.20.p.1">The RTSP syntax is described in an Augmented Backus-Naur Form (ABNF) as defined in RFC 5234 <a href="#RFC5234">[RFC5234]</a>. It uses the basic definitions present in RFC 5234.</p>
<p id="rfc.section.20.p.2">Please note that ABNF strings, e.g. "Accept", are case insensitive as specified in section 2.3 of RFC 5234.</p>
<h1 id="rfc.section.20.1">
<a href="#rfc.section.20.1">20.1.</a> Base Syntax</h1>
<p id="rfc.section.20.1.p.1">RTSP header values can be folded onto multiple lines if the continuation line begins with a space or horizontal tab. All linear white space, including folding, has the same semantics as SP. A recipient MAY replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream.  This is intended to behave exactly as HTTP/1.1 as described in RFC 2616 <a href="#RFC2616">[RFC2616]</a>. The SWS construct is used when linear white space is optional, generally between tokens and separators.</p>
<div id="#rfc.figure.59"></div>
<pre>
OCTET           =  %x00-FF ; any 8-bit sequence of data
CHAR            =  %x01-7F ; any US-ASCII character (octets 1 - 127)
UPALPHA         =  %x41-5A ; any US-ASCII uppercase letter "A".."Z"
LOALPHA         =  %x61-7A ;any US-ASCII lowercase letter "a".."z"
ALPHA           =  UPALPHA / LOALPHA
DIGIT           =  %x30-39 ; any US-ASCII digit "0".."9"
CTL             =  %x00-1F / %x7F  ; any US-ASCII control character
                   ; (octets 0 - 31) and DEL (127)
CR              =  %x0D ; US-ASCII CR, carriage return (13)
LF              =  %x0A  ; US-ASCII LF, linefeed (10)
SP              =  %x20  ; US-ASCII SP, space (32)
HT              =  %x09  ; US-ASCII HT, horizontal-tab (9)
DQ              =  %x22  ; US-ASCII double-quote mark (34)
BACKSLASH       =  %x5C  ; US-ASCII backslash (92)
CRLF            =  CR LF</pre>
<div id="#rfc.figure.60"></div>
<pre>
LWS             =  [CRLF] 1*( SP / HT ) ; Line-breaking White Space
SWS             =  [LWS] ; Separating White Space
HCOLON          =  *( SP / HT ) ":" SWS
TEXT            =  %x20-7E / %x80-FF  ; any OCTET except CTLs
tspecials       =  "(" / ")" / "&lt;" / "&gt;" / "@"
                /  "," / ";" / ":" / BACKSLASH / DQ
                /  "/" / "[" / "]" / "?" / "="
                /  "{" / "}" / SP / HT
token           =  1*(%x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39
                /  %x41-5A / %x5E-7A / %x7C / %x7E)
                   ; 1*&lt;any CHAR except CTLs or tspecials&gt;
quoted-string   =  ( DQ *qdtext DQ )
qdtext          =  %x20-21 / %x23-7E / %x80-FF / UTF8-NONASCII
                   ; any UTF-8 TEXT except &lt;"&gt;
quoted-pair     =  BACKSLASH CHAR
ctext           =  %x20-27 / %x2A-7E
                /  %x80-FF  ; any OCTET except CTLs, "(" and ")"
generic-param   =  token [ EQUAL gen-value ]
gen-value       =  token / host / quoted-string</pre>
<div id="#rfc.figure.61"></div>
<pre>
safe            =  "$" / "-" / "_" / "." / "+"
extra           =  "!" / "*" / "'" / "(" / ")" / ","
rtsp-extra      =  "!" / "*" / "'" / "(" / ")" 

HEX             =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F" 
                /  "a" / "b" / "c" / "d" / "e" / "f"
LHEX            =  DIGIT /  "a" / "b" / "c" / "d" / "e" / "f" 
                   ; lowercase "a-f" Hex
reserved        =  ";" / "/" / "?" / ":" / "@" / "&amp;" / "="

unreserved      =  ALPHA / DIGIT / safe / extra
rtsp-unreserved  =  ALPHA / DIGIT / safe / rtsp-extra

base64          =  *base64-unit [base64-pad]
base64-unit     =  4base64-char
base64-pad      =  (2base64-char "==") / (3base64-char "=")
base64-char     =  ALPHA / DIGIT / "+" / "/"</pre>
<div id="#rfc.figure.62"></div>
<pre>
SLASH    =  SWS "/" SWS ; slash
EQUAL    =  SWS "=" SWS ; equal
LPAREN   =  SWS "(" SWS ; left parenthesis
RPAREN   =  SWS ")" SWS ; right parenthesis
COMMA    =  SWS "," SWS ; comma
SEMI     =  SWS ";" SWS ; semicolon
COLON    =  SWS ":" SWS ; colon
MINUS    =  SWS "-" SWS ; minus/dash
LDQUOT   =  SWS DQ ; open double quotation mark
RDQUOT   =  DQ SWS ; close double quotation mark
RAQUOT   =  "&gt;" SWS ; right angle quote
LAQUOT   =  SWS "&lt;" ; left angle quote

TEXT-UTF8char    =  %x21-7E / UTF8-NONASCII
UTF8-NONASCII    =  %xC0-DF 1UTF8-CONT
                 /  %xE0-EF 2UTF8-CONT
                 /  %xF0-F7 3UTF8-CONT
                 /  %xF8-FB 4UTF8-CONT
                 /  %xFC-FD 5UTF8-CONT
UTF8-CONT        =  %x80-BF

POS-FLOAT        = 1*12DIGIT ["." 1*9DIGIT]
FLOAT            = ["-"] POS-FLOAT</pre>
<p id="rfc.section.20.1.p.2">To separate the header name from the rest of value, a colon is used, which, by the above rule, allows whitespace before, but no line break, and whitespace after, including a line break. The HCOLON defines this construct. </p>
<h1 id="rfc.section.20.2">
<a href="#rfc.section.20.2">20.2.</a> <a href="#sec_syntax-prot" id="sec_syntax-prot">RTSP Protocol Definition</a>
</h1>
<h1 id="rfc.section.20.2.1">
<a href="#rfc.section.20.2.1">20.2.1.</a> <a href="#sec_syntax-prot-generic" id="sec_syntax-prot-generic">Generic Protocol elements</a>
</h1>
<div id="#rfc.figure.63"></div>
<pre>
RTSP-IRI       =  schemes ":" IRI-rest
IRI-rest       =  ihier-part [ "?" iquery ] [ "#" ifragment ]
ihier-part     =  "//" iauthority ipath-abempty
RTSP-IRI-ref   =  RTSP-IRI / irelative-ref
irelative-ref  =  irelative-part [ "?" iquery ] [ "#" ifragment ]
irelative-part =  "//" iauthority ipath-abempty
                  / ipath-absolute
                  / ipath-noscheme
                  / ipath-empty

iauthority     =  &lt; As defined in RFC 3987&gt;
ipath          =  ipath-abempty   ; begins with "/" or is empty
                  / ipath-absolute  ; begins with "/" but not "//"
                  / ipath-noscheme  ; begins with a non-colon segment
                  / ipath-rootless  ; begins with a segment
                  / ipath-empty     ; zero characters

ipath-abempty   =  *( "/" isegment )
ipath-absolute  =  "/" [ isegment-nz *( "/" isegment ) ]
ipath-noscheme  =  isegment-nz-nc *( "/" isegment )
ipath-rootless  =  isegment-nz *( "/" isegment )
ipath-empty     =  0&lt;ipchar&gt;

isegment        =  *ipchar [";" *ipchar]
isegment-nz     =  1*ipchar [";" *ipchar]
                   / ";" *ipchar
isegment-nz-nc  =  (1*ipchar-nc [";" *ipchar-nc])
                   / ";" *ipchar-nc
                   ; non-zero-length segment without any colon ":"

ipchar         =  iunreserved / pct-encoded / sub-delims / ":" / "@"
ipchar-nc      =  iunreserved / pct-encoded / sub-delims / "@"

iquery         =  &lt; As defined in RFC 3987&gt;
ifragment      =  &lt; As defined in RFC 3987&gt;
iunreserved    =  &lt; As defined in RFC 3987&gt;
pct-encoded    =  &lt; As defined in RFC 3987&gt;</pre>
<p></p>
<div id="#rfc.figure.64"></div>
<pre>
RTSP-URI       =  schemes ":" URI-rest
RTSP-REQ-URI   =  schemes ":" URI-req-rest
RTSP-URI-Ref   =  RTSP-URI / RTSP-Relative
RTSP-REQ-Ref   =  RTSP-REQ-URI / RTSP-REQ-Rel
schemes        =  "rtsp" / "rtsps" / scheme
scheme         =  &lt; As defined in RFC 3986&gt;
URI-rest       =  hier-part [ "?" query ] [ "#" fragment ]
URI-req-rest   =  hier-part [ "?" query ]
                  ; Note fragment part not allowed in requests
hier-part      =  "//" authority path-abempty

RTSP-Relative  =  relative-part [ "?" query ] [ "#" fragment ]
RTSP-REQ-Rel   =  relative-part [ "?" query ]
relative-part  =  "//" authority path-abempty
                  / path-absolute
                  / path-noscheme
                  / path-empty

authority      =  &lt; As defined in RFC 3986&gt;
query          =  &lt; As defined in RFC 3986&gt;
fragment       =  &lt; As defined in RFC 3986&gt;

path           =  path-abempty    ; begins with "/" or is empty
                  / path-absolute ; begins with "/" but not "//"
                  / path-noscheme ; begins with a non-colon segment
                  / path-rootless ; begins with a segment
                  / path-empty    ; zero characters

path-abempty   =  *( "/" segment )
path-absolute  =  "/" [ segment-nz *( "/" segment ) ]
path-noscheme  =  segment-nz-nc *( "/" segment )
path-rootless  =  segment-nz *( "/" segment )
path-empty     =  0&lt;pchar&gt;

segment        =  *pchar [";" *pchar]
segment-nz     =  ( 1*pchar [";" *pchar]) / (";" *pchar)
segment-nz-nc  =  ( 1*pchar-nc [";" *pchar-nc]) / (";" *pchar-nc)
                  ; non-zero-length segment without any colon ":"

pchar          =  unreserved / pct-encoded / sub-delims / ":" / "@"
pchar-nc       =  unreserved / pct-encoded / sub-delims / "@"

sub-delims     =  "!" / "$" / "&amp;" / "'" / "(" / ")"
                  / "*" / "+" / "," / "="
</pre>
<div id="#rfc.figure.65"></div>
<pre>
smpte-range        =  smpte-type ["=" smpte-range-spec]
                      ; See section 3.4
smpte-range-spec   =  ( smpte-time "-" [ smpte-time ] )
                   /  ( "-" smpte-time )
smpte-type         =  "smpte" / "smpte-30-drop" 
                   /  "smpte-25" / smpte-type-extension
                   ; other timecodes may be added
smpte-type-extension  =  "smpte" token
smpte-time         =  1*2DIGIT ":" 1*2DIGIT ":" 1*2DIGIT 
                      [ ":" 1*2DIGIT [ "." 1*2DIGIT ] ]
</pre>
<div id="#rfc.figure.66"></div>
<pre>
npt-range        =  "npt" ["=" npt-range-spec]
npt-range-spec   =  ( npt-time "-" [ npt-time ] ) / ( "-" npt-time )
npt-time         =  "now" / npt-sec / npt-hhmmss
npt-sec          =  1*19DIGIT [ "." 1*9DIGIT ]
npt-hhmmss       =  npt-hh ":" npt-mm ":" npt-ss [ "." 1*9DIGIT ]
npt-hh           =  1*19DIGIT   ; any positive number
npt-mm           =  1*2DIGIT  ; 0-59
npt-ss           =  1*2DIGIT  ; 0-59
</pre>
<div id="#rfc.figure.67"></div>
<pre>
utc-range        =  "clock" ["=" utc-range-spec]
utc-range-spec   =  ( utc-time "-" [ utc-time ] ) / ( "-" utc-time )
utc-time         =  utc-date "T" utc-clock "Z" 
utc-date         =  8DIGIT                 
utc-clock        =  6DIGIT [ "." 1*9DIGIT ]
</pre>
<div id="#rfc.figure.68"></div>
<pre>
feature-tag       =  token

session-id        =  1*256( ALPHA / DIGIT / safe )

extension-header  =  header-name HCOLON header-value
header-name       =  token
header-value      =  *(TEXT-UTF8char / UTF8-CONT / LWS)
</pre>
<p></p>
<h1 id="rfc.section.20.2.2">
<a href="#rfc.section.20.2.2">20.2.2.</a> <a href="#sec_syntax-prot-message" id="sec_syntax-prot-message">Message Syntax</a>
</h1>
<div id="#rfc.figure.69"></div>
<pre>
RTSP-message  = Request / Response  ; RTSP/2.0 messages

Request       = Request-Line  
                *((general-header 
                /  request-header  
                /  message-header) CRLF)   
                CRLF
                [ message-body-data ]      

Response     = Status-Line  
               *((general-header     
               /  response-header   
               /  message-header) CRLF)      
               CRLF
               [ message-body-data ]       </pre>
<div id="#rfc.figure.70"></div>
<pre>
Request-Line = Method SP Request-URI SP RTSP-Version CRLF

Status-Line  = RTSP-Version SP Status-Code SP Reason-Phrase CRLF</pre>
<div id="#rfc.figure.71"></div>
<pre>Method  =  "DESCRIBE" 
        /  "GET_PARAMETER"
        /  "OPTIONS" 
        /  "PAUSE"
        /  "PLAY"
        /  "PLAY_NOTIFY"
        /  "REDIRECT"
        /  "SETUP" 
        /  "SET_PARAMETER"
        /  "TEARDOWN" 
        /  extension-method

extension-method  =  token</pre>
<div id="#rfc.figure.72"></div>
<pre>
Request-URI  =  "*" / RTSP-REQ-URI
RTSP-Version =  "RTSP/" 1*DIGIT "." 1*DIGIT

message-body-data = 1*OCTET</pre>
<div id="#rfc.figure.73"></div>
<pre>
Status-Code  =  "100"  ; Continue
             /  "200"  ; OK
             /  "301"  ; Moved Permanently
             /  "302"  ; Found
             /  "303"  ; See Other
             /  "304"  ; Not Modified
             /  "305"  ; Use Proxy
             /  "400"  ; Bad Request
             /  "401"  ; Unauthorized
             /  "402"  ; Payment Required
             /  "403"  ; Forbidden
             /  "404"  ; Not Found
             /  "405"  ; Method Not Allowed
             /  "406"  ; Not Acceptable
             /  "407"  ; Proxy Authentication Required
             /  "408"  ; Request Time-out
             /  "410"  ; Gone
             /  "411"  ; Length Required
             /  "412"  ; Precondition Failed
             /  "413"  ; Request Message Body Too Large
             /  "414"  ; Request-URI Too Large
             /  "415"  ; Unsupported Media Type
             /  "451"  ; Parameter Not Understood
             /  "452"  ; reserved
             /  "453"  ; Not Enough Bandwidth
             /  "454"  ; Session Not Found
             /  "455"  ; Method Not Valid in This State
             /  "456"  ; Header Field Not Valid for Resource
             /  "457"  ; Invalid Range
             /  "458"  ; Parameter Is Read-Only
             /  "459"  ; Aggregate operation not allowed
             /  "460"  ; Only aggregate operation allowed
             /  "461"  ; Unsupported Transport
             /  "462"  ; Destination Unreachable
             /  "463"  ; Destination Prohibited
             /  "464"  ; Data Transport Not Ready Yet
             /  "465"  ; Notification Reason Unknown
             /  "466"  ; Key Management Error
             /  "470"  ; Connection Authorization Required
             /  "471"  ; Connection Credentials not accepted
             /  "472"  ; Failure to establish secure connection
             /  "500"  ; Internal Server Error
             /  "501"  ; Not Implemented
             /  "502"  ; Bad Gateway
             /  "503"  ; Service Unavailable
             /  "504"  ; Gateway Time-out
             /  "505"  ; RTSP Version not supported
             /  "551"  ; Option not supported
             /  extension-code
            
extension-code  =  3DIGIT

Reason-Phrase   =  1*(TEXT-UTF8char / HT / SP)
</pre>
<div id="#rfc.figure.74"></div>
<pre>
general-header  =  Cache-Control       
                /  Connection          
                /  CSeq                
                /  Date
                /  Media-Properties
                /  Media-Range
                /  Pipelined-Requests
                /  Proxy-Supported 
                /  Seek-Style 
                /  Server   
                /  Supported           
                /  Timestamp 
                /  User-Agent            
                /  Via                 
                /  extension-header</pre>
<div id="#rfc.figure.75"></div>
<pre>
request-header  =  Accept               
                /  Accept-Credentials   
                /  Accept-Encoding      
                /  Accept-Language      
                /  Authorization        
                /  Bandwidth            
                /  Blocksize            
                /  From                 
                /  If-Match             
                /  If-Modified-Since    
                /  If-None-Match
                /  Notify-Reason
                /  Proxy-Require        
                /  Range                
                /  Referrer              
                /  Request-Status
                /  Require              
                /  Scale                
                /  Session              
                /  Speed                
                /  Supported            
                /  Terminate-Reason
                /  Transport                     
                /  extension-header</pre>
<div id="#rfc.figure.76"></div>
<pre>
response-header  =  Accept-Credentials  
                 /  Accept-Ranges           
                 /  Connection-Credentials  
                 /  MTag                    
                 /  Location                
                 /  Proxy-Authenticate      
                 /  Public                  
                 /  Range                   
                 /  Retry-After             
                 /  RTP-Info                
                 /  Scale                   
                 /  Session                                   
                 /  Speed                   
                 /  Transport               
                 /  Unsupported             
                 /  Vary                    
                 /  WWW-Authenticate        
                 /  extension-header</pre>
<div id="#rfc.figure.77"></div>
<pre>
message-header    =  Allow                
                 /  Content-Base         
                 /  Content-Encoding     
                 /  Content-Language     
                 /  Content-Length       
                 /  Content-Location     
                 /  Content-Type         
                 /  Expires              
                 /  Last-Modified        
                 /  extension-header</pre>
<p></p>
<h1 id="rfc.section.20.2.3">
<a href="#rfc.section.20.2.3">20.2.3.</a> <a href="#sec_syntax-prot-header" id="sec_syntax-prot-header">Header Syntax</a>
</h1>
<div id="#rfc.figure.78"></div>
<pre>
Accept            =  "Accept" HCOLON
                     [ accept-range *(COMMA accept-range) ]
accept-range      =  media-type-range [SEMI accept-params]
media-type-range  =  ( "*/*"
                     / ( m-type SLASH "*" )
                     / ( m-type SLASH m-subtype )
                    ) *( SEMI m-parameter )
accept-params     =  "q" EQUAL qvalue *(SEMI generic-param )
qvalue            =  ( "0" [ "." *3DIGIT ] )
                  /  ( "1" [ "." *3("0") ] )
Accept-Credentials =  "Accept-Credentials" HCOLON cred-decision
cred-decision     =  ("User" [LWS cred-info]) 
                  /  "Proxy"
                  /  "Any"
                  /  (token [LWS 1*header-value])
				  ; For future extensions
cred-info         =  cred-info-data *(COMMA cred-info-data)

cred-info-data    =  DQ RTSP-REQ-URI DQ SEMI hash-alg SEMI base64
hash-alg          =  "sha-256" / extension-alg
extension-alg     =  token
Accept-Encoding   =  "Accept-Encoding" HCOLON
                     [ encoding *(COMMA encoding) ]
encoding          =  codings [SEMI accept-params]
codings           =  content-coding / "*"
content-coding    =  token
Accept-Language   =  "Accept-Language" HCOLON
                     language *(COMMA language)
language          =  language-range [SEMI accept-params]
language-range    =  language-tag / "*" 
language-tag      =  primary-tag *( "-" subtag )
primary-tag       =  1*8ALPHA
subtag            =  1*8ALPHA
Accept-Ranges     =  "Accept-Ranges" HCOLON acceptable-ranges 
acceptable-ranges =  (range-unit *(COMMA range-unit)) 
range-unit        =  "NPT" / "SMPTE" / "UTC" / extension-format
extension-format  =  token
Allow             =  "Allow" HCOLON Method *(COMMA Method)
Authorization     =  "Authorization" HCOLON credentials
credentials       =  ("Digest" LWS digest-response)
                  /  other-response
digest-response   =  dig-resp *(COMMA dig-resp)
dig-resp          =  username / realm / nonce / digest-uri
                  /  dresponse / algorithm / cnonce
                  /  opaque / message-qop
                  /  nonce-count / auth-param
username          =  "username" EQUAL username-value
username-value    =  quoted-string
digest-uri        =  "uri" EQUAL LDQUOT digest-uri-value RDQUOT
digest-uri-value  =  RTSP-REQ-URI
message-qop       =  "qop" EQUAL qop-value
cnonce            =  "cnonce" EQUAL cnonce-value
cnonce-value      =  nonce-value
nonce-count       =  "nc" EQUAL nc-value
nc-value          =  8LHEX
dresponse         =  "response" EQUAL request-digest
request-digest    =  LDQUOT 32LHEX RDQUOT
auth-param        =  auth-param-name EQUAL
                     ( token / quoted-string )
auth-param-name   =  token
other-response    =  auth-scheme LWS auth-param
                     *(COMMA auth-param)
auth-scheme       =  token

Bandwidth         =  "Bandwidth" HCOLON 1*19DIGIT 

Blocksize         =  "Blocksize" HCOLON 1*9DIGIT </pre>
<div id="#rfc.figure.79"></div>
<pre>
Cache-Control     =  "Cache-Control" HCOLON cache-directive 
                     *(COMMA cache-directive)
cache-directive   =  cache-rqst-directive
                  /  cache-rspns-directive

cache-rqst-directive =  "no-cache"
                     /  "max-stale" [EQUAL delta-seconds]
                     /  "min-fresh" EQUAL delta-seconds
                     /  "only-if-cached"
                     /  cache-extension

cache-rspns-directive =  "public"
                         /  "private"
                         /  "no-cache"
                         /  "no-transform"
                         /  "must-revalidate"
                         /  "proxy-revalidate"
                         /  "max-age" EQUAL delta-seconds
                         /  cache-extension

cache-extension   =  token [EQUAL (token / quoted-string)]
delta-seconds     =  1*19DIGIT</pre>
<div id="#rfc.figure.80"></div>
<pre>
Connection         =  "Connection" HCOLON connection-token
                      *(COMMA connection-token) 
connection-token   =  "close" / token

Connection-Credentials = "Connection-Credentials" HCOLON cred-chain 
cred-chain         =  DQ RTSP-REQ-URI DQ SEMI base64

Content-Base       =  "Content-Base" HCOLON RTSP-URI 
Content-Encoding   =  "Content-Encoding" HCOLON
                      content-coding *(COMMA content-coding)
Content-Language   =  "Content-Language" HCOLON
                      language-tag *(COMMA language-tag)
Content-Length     =  "Content-Length" HCOLON 1*19DIGIT
Content-Location   =  "Content-Location" HCOLON RTSP-REQ-Ref
Content-Type       =  "Content-Type" HCOLON media-type
media-type         =  m-type SLASH m-subtype *(SEMI m-parameter)
m-type             =  discrete-type / composite-type
discrete-type      =  "text" / "image" / "audio" / "video"
                   /  "application" / extension-token
composite-type   =  "message" / "multipart" / extension-token
extension-token  =  ietf-token / x-token
ietf-token       =  token
x-token          =  "x-" token
m-subtype        =  extension-token / iana-token
iana-token       =  token
m-parameter      =  m-attribute EQUAL m-value
m-attribute      =  token
m-value          =  token / quoted-string

CSeq           =  "CSeq" HCOLON cseq-nr 
cseq-nr        =  1*9DIGIT
Date           =  "Date" HCOLON RTSP-date
RTSP-date      =  rfc1123-date ; HTTP-date
rfc1123-date   =  wkday "," SP date1 SP time SP "GMT"
date1          =  2DIGIT SP month SP 4DIGIT
                  ; day month year (e.g., 02 Jun 1982)
time           =  2DIGIT ":" 2DIGIT ":" 2DIGIT
                  ; 00:00:00 - 23:59:59
wkday          =  "Mon" / "Tue" / "Wed"
               /  "Thu" / "Fri" / "Sat" / "Sun"
month          =  "Jan" / "Feb" / "Mar" / "Apr"
               /  "May" / "Jun" / "Jul" / "Aug"
               /  "Sep" / "Oct" / "Nov" / "Dec"

Expires        =  "Expires" HCOLON RTSP-date
From           =  "From" HCOLON from-spec
from-spec      =  ( name-addr / addr-spec ) *( SEMI from-param )
name-addr      =  [ display-name ] LAQUOT addr-spec RAQUOT
addr-spec      =  RTSP-REQ-URI / absolute-URI
absolute-URI   =  &lt; As defined in RFC 3986&gt;
display-name   =  *(token LWS) / quoted-string
from-param     =  tag-param / generic-param
tag-param      =  "tag" EQUAL token
If-Match       =  "If-Match" HCOLON ("*" / message-tag-list)
message-tag-list =  message-tag *(COMMA message-tag)
message-tag      =  [ weak ] opaque-tag
weak             =  "W/"
opaque-tag       =  quoted-string
If-Modified-Since  =  "If-Modified-Since" HCOLON RTSP-date
If-None-Match    =  "If-None-Match" HCOLON ("*" / message-tag-list)
Last-Modified    =  "Last-Modified" HCOLON RTSP-date
Location         =  "Location" HCOLON RTSP-REQ-URI
Media-Properties = "Media-Properties" HCOLON [media-prop-list]
media-prop-list  = media-prop-value *(COMMA media-prop-value)
media-prop-value = ("Random-Access" [EQUAL POS-FLOAT])
                 / "Begining-Only"
                 / "No-Seeking"
                 / "Immutable"
                 / "Dynamic"
                 / "Time-Progressing"
                 / "Unlimited"
                 / ("Time-Limited" EQUAL utc-time)
                 / ("Time-Duration" EQUAL POS-FLOAT)
                 / ("Scales" EQUAL scale-value-list)
                 / media-prop-ext
media-prop-ext   = token [EQUAL (1*rtsp-unreserved / quoted-string)]
scale-value-list = DQ scale-entry *(COMMA scale-entry) DQ
scale-entry      = scale-value / (scale-value COLON scale-value)
scale-value      = FLOAT
Media-Range      = "Media-Range" HCOLON [ranges-list]
ranges-list      =  ranges-spec *(COMMA ranges-spec)
MTag             =  "MTag" HCOLON message-tag
Notify-Reason    = "Notify-Reason" HCOLON Notify-Reas-val
Notify-Reas-val  = "end-of-stream" 
                 / "media-properties-update"
                 / "scale-change"
                 / Notify-Reason-extension
Notify-Reason-extension  = token
Pipelined-Requests = "Pipelined-Requests" HCOLON startup-id
startup-id  = 1*8DIGIT</pre>
<p></p>
<div id="#rfc.figure.81"></div>
<pre>Proxy-Authenticate   =  "Proxy-Authenticate" HCOLON challenge-list
challenge-list       =  challenge *(COMMA challenge)
challenge            =  ("Digest" LWS digest-cln *(COMMA digest-cln))
                     /  other-challenge
other-challenge      =  auth-scheme LWS auth-param
                        *(COMMA auth-param)
digest-cln           =  realm / domain / nonce
                     /  opaque / stale / algorithm
                     /  qop-options / auth-param
realm                =  "realm" EQUAL realm-value
realm-value          =  quoted-string
domain               =  "domain" EQUAL LDQUOT RTSP-REQ-Ref
                        *(1*SP RTSP-REQ-Ref ) RDQUOT
nonce                =  "nonce" EQUAL nonce-value
nonce-value          =  quoted-string
opaque               =  "opaque" EQUAL quoted-string
stale                =  "stale" EQUAL ( "true" / "false" )
algorithm            =  "algorithm" EQUAL ("MD5" / "MD5-sess" / token)
qop-options          =  "qop" EQUAL LDQUOT qop-value
                        *("," qop-value) RDQUOT
qop-value            =  "auth" / "auth-int" / token
Proxy-Require        =  "Proxy-Require" HCOLON feature-tag-list
feature-tag-list     =  feature-tag *(COMMA feature-tag)  
Proxy-Supported      =  "Proxy-Supported" HCOLON [feature-tag-list]

Public               =  "Public" HCOLON Method *(COMMA Method) 

Range                =  "Range" HCOLON ranges-spec 

ranges-spec          =  npt-range / utc-range / smpte-range
                     /  range-ext
range-ext            =  extension-format ["=" range-value]
range-value          =  1*(rtsp-unreserved / quoted-string / ":" )

Referrer             =  "Referrer" HCOLON (absolute-URI / RTSP-URI-Ref) 
Request-Status       =  "Request-Status" HCOLON req-status-info
req-status-info      =  cseq-info LWS status-info LWS reason-info
cseq-info            =  "cseq" EQUAL cseq-nr
status-info          =  "status" EQUAL Status-Code
reason-info          =  "reason" EQUAL DQ Reason-Phrase DQ 
Require              =  "Require" HCOLON feature-tag-list 
</pre>
<div id="#rfc.figure.82"></div>
<pre>RTP-Info         =  "RTP-Info" HCOLON [rtsp-info-spec
                    *(COMMA rtsp-info-spec)] 
rtsp-info-spec   =  stream-url 1*ssrc-parameter 
stream-url       =  "url" EQUAL DQ RTSP-REQ-Ref DQ 
ssrc-parameter   =  LWS "ssrc" EQUAL ssrc HCOLON
                    ri-parameter *(SEMI ri-parameter)
ri-parameter     =  ("seq" EQUAL 1*5DIGIT)
                 /  ("rtptime" EQUAL 1*10DIGIT)
                 /  generic-param

Retry-After      =  "Retry-After" HCOLON ( RTSP-date / delta-seconds )
Scale            =  "Scale" HCOLON scale-value 
Seek-Style       =  "Seek-Style" HCOLON Seek-S-values
Seek-S-values    =  "RAP"
                 /  "CoRAP"
                 /  "First-Prior"
                 /  "Next"
                 /  Seek-S-value-ext
Seek-S-value-ext =  token

Server           =  "Server" HCOLON ( product / comment )
                    *(LWS (product / comment)) 
product          =  token [SLASH product-version]
product-version  =  token
comment          =  LPAREN *( ctext / quoted-pair) RPAREN

Session          =  "Session" HCOLON session-id 
                    [ SEMI "timeout" EQUAL delta-seconds ] 

Speed            =  "Speed" HCOLON lower-bound MINUS upper-bound
lower-bound      =  POS-FLOAT
upper-bound      =  POS-FLOAT

Supported        =  "Supported" HCOLON [feature-tag-list] 
</pre>
<div id="#rfc.figure.83"></div>
<pre>Terminate-Reason      =  "Terminate-Reason" HCOLON TR-Info
TR-Info              =  TR-Reason *(SEMI TR-Parameter)
TR-Reason            =  "Session-Timeout" 
                     /  "Server-Admin"
                     /  "Internal-Error"
                     /  token
TR-Parameter         =  TR-time / TR-user-msg / generic-param
TR-time              =  "time" EQUAL utc-time
TR-user-msg          =  "user-msg" EQUAL quoted-string

Timestamp        =  "Timestamp" HCOLON timestamp-value [LWS delay]
timestamp-value  =  *19DIGIT [ "." *9DIGIT ]
delay            =  *9DIGIT [ "." *9DIGIT ]

Transport        =  "Transport" HCOLON transport-spec 
                    *(COMMA transport-spec) 
transport-spec   =  transport-id *trns-parameter
transport-id     =  trans-id-rtp / other-trans
trans-id-rtp     =  "RTP/" profile ["/" lower-transport]
                    ; no LWS is allowed inside transport-id 
other-trans      =  token *("/" token)</pre>
<div id="#rfc.figure.84"></div>
<pre>
profile             = "AVP" / "SAVP" / "AVPF" / token
lower-transport     = "TCP" / "UDP" / token
trns-parameter      = (SEMI ( "unicast" / "multicast" ))
                    / (SEMI "interleaved" EQUAL channel [ "-" channel ])
                    / (SEMI "ttl" EQUAL ttl)
                    / (SEMI "layers" EQUAL 1*DIGIT)
                    / (SEMI "ssrc" EQUAL ssrc *(SLASH ssrc))
                    / (SEMI "mode" EQUAL mode-spec)
                    / (SEMI "dest_addr" EQUAL addr-list)
                    / (SEMI "src_addr" EQUAL addr-list)
                    / (SEMI "setup" EQUAL contrans-setup)
                    / (SEMI "connection" EQUAL contrans-con)
                    / (SEMI "RTCP-mux")
                    / (SEMI "MIKEY" EQUAL MIKEY-Value)
                    / (SEMI trn-param-ext)
contrans-setup      = "active" / "passive" / "actpass"
contrans-con        = "new" / "existing"
trn-param-ext       = par-name [EQUAL trn-par-value]
par-name            = token
trn-par-value       = *(rtsp-unreserved / quoted-string)
ttl                 = 1*3DIGIT ; 0 to 255
ssrc                = 8HEX
channel             = 1*3DIGIT ; 0 to 255
MIKEY-Value         = base64
mode-spec           = ( DQ mode *(COMMA mode) DQ )
mode                = "PLAY" / token
addr-list           = quoted-addr *(SLASH quoted-addr)
quoted-addr         = DQ (host-port / extension-addr) DQ
host-port           = ( host [":" port] )
                    / ( ":" port )
extension-addr      = 1*qdtext
host                = &lt; As defined in RFC 3986&gt;
port                = &lt; As defined in RFC 3986&gt;
</pre>
<div id="#rfc.figure.85"></div>
<pre>
Unsupported     = "Unsupported" HCOLON feature-tag-list 

User-Agent      = "User-Agent" HCOLON ( product / comment ) 
                  *(LWS (product / comment)) 

Vary            = "Vary" HCOLON ( "*" / field-name-list)
field-name-list = field-name *(COMMA field-name)
field-name      = token
Via             = "Via" HCOLON via-parm *(COMMA via-parm)
via-parm        = sent-protocol LWS sent-by *( SEMI via-params )
via-params      = via-ttl / via-maddr
                / via-received / via-extension
via-ttl         = "ttl" EQUAL ttl
via-maddr       = "maddr" EQUAL host
via-received    = "received" EQUAL (IPv4address / IPv6address)
IPv4address     = &lt; As defined in RFC 3986&gt;
IPv6address     = &lt; As defined in RFC 3986&gt;
via-extension   = generic-param
sent-protocol   = protocol-name SLASH protocol-version
                  SLASH transport-prot
protocol-name   = "RTSP" / token
protocol-version = token
transport-prot  = "UDP" / "TCP" / "TLS" / other-transport
other-transport = token
sent-by         = host [ COLON port ]

WWW-Authenticate = "WWW-Authenticate" HCOLON challenge-list
</pre>
<p></p>
<h1 id="rfc.section.20.3">
<a href="#rfc.section.20.3">20.3.</a> <a href="#sec_sdp-syntax" id="sec_sdp-syntax">SDP extension Syntax</a>
</h1>
<div id="#rfc.figure.86"></div>
<pre>
control-attribute   =  "a=control:" *SP RTSP-REQ-Ref CRLF

a-range-def         =  "a=range:" ranges-spec CRLF

a-mtag-def          =  "a=mtag:" message-tag CRLF
</pre>
<p id="rfc.section.20.3.p.1">This section defines in ABNF the SDP extensions defined for RTSP.  See <a href="#sec_sdpusage">Appendix Appendix D</a> for the definition of the extensions in text. </p>
<h1 id="rfc.section.21">
<a href="#rfc.section.21">21.</a> <a href="#sec_security" id="sec_security">Security Considerations</a>
</h1>
<p id="rfc.section.21.p.1">Because of the similarity in syntax and usage between RTSP servers and HTTP servers, the security considerations outlined in [H15] apply also.</p>
<p id="rfc.section.21.p.2">Specifically, please note the following: </p>

<dl>
<dt>Abuse of Server Log Information:</dt>
<dd style="margin-left: 6">RTSP and HTTP servers will presumably have similar logging mechanisms, and thus should be equally guarded in protecting the contents of those logs, thus protecting the privacy of the users of the servers. See [H15.1.1] for HTTP server recommendations regarding server logs.</dd>
<dt>Transfer of Sensitive Information:</dt>
<dd style="margin-left: 6">There is no reason to believe that information transferred or controlled via RTSP may be any less sensitive than that normally transmitted via HTTP.  Therefore, all of the precautions regarding the protection of data privacy and user privacy apply to implementors of RTSP clients, servers, and proxies. See [H15.1.2] for further details.</dd>
<dt>Attacks Based On File and Path Names:</dt>
<dd style="margin-left: 6">Though RTSP URIs are opaque handles that do not necessarily have file system semantics, it is anticipated that many implementations will translate portions of the Request-URIs directly to file system calls. In such cases, file systems SHOULD follow the precautions outlined in [H15.5], such as checking for ".." in path components.</dd>
<dt>Personal Information:</dt>
<dd style="margin-left: 6">RTSP clients are often privy to the same information that HTTP clients are (user name, location, etc.) and thus should be equally sensitive. See [H15.1] for further recommendations.</dd>
<dt>Privacy Issues Connected to Accept Headers:</dt>
<dd style="margin-left: 6">Since may of the same "Accept" headers exist in RTSP as in HTTP, the same caveats outlined in [H15.1.4] with regards to their use should be followed.</dd>
<dt>DNS Spoofing:</dt>
<dd style="margin-left: 6">Presumably, given the longer connection times typically associated to RTSP sessions relative to HTTP sessions, RTSP client DNS optimizations should be less prevalent.  Nonetheless, the recommendations provided in [H15.3] are still relevant to any implementation which attempts to rely on a DNS-to-IP mapping to hold beyond a single use of the mapping.</dd>
<dt>Location Headers and Spoofing:</dt>
<dd style="margin-left: 6">If a single server supports multiple organizations that do not trust each another, then it needs to check the values of Location and Content-Location header fields in responses that are generated under control of said organizations to make sure that they do not attempt to invalidate resources over which they have no authority. ([H15.4])</dd>
</dl>
<p id="rfc.section.21.p.3">In addition to the recommendations in the current HTTP specification (RFC 2616 <a href="#RFC2616">[RFC2616]</a>, as of this writing) and also of the previous RFC 2068 <a href="#RFC2068">[RFC2068]</a>, future HTTP specifications may provide additional guidance on security issues.</p>
<p id="rfc.section.21.p.4">The following are added considerations for RTSP implementations.  </p>

<dl>
<dt>Concentrated denial-of-service attack:</dt>
<dd style="margin-left: 6">The protocol offers the opportunity for a remote-controlled denial-of-service attack. See <a href="#sec-dos">Section 21.1</a>.</dd>
<dt>Session hijacking:</dt>
<dd style="margin-left: 6">Since there is no or little relation between a transport layer connection and an RTSP session, it is possible for a malicious client to issue requests with random session identifiers which would affect unsuspecting clients. The server SHOULD use a large, random and non-sequential session identifier to minimize the possibility of this kind of attack.  However, unless the RTSP signaling always are confidentiality protected, e.g. using TLS, an on-path attacker will be able to hijack a session. For real session security, client authentication needs to be performed.</dd>
<dt>Authentication:</dt>
<dd style="margin-left: 6">Servers SHOULD implement both basic and digest <a href="#RFC2617">[RFC2617]</a> authentication. In environments requiring tighter security for the control messages, the transport layer mechanism <a href="#RFC5246">TLS</a> <cite title="NONE">[RFC5246]</cite> SHOULD be used.</dd>
<dt>Stream issues:</dt>
<dd style="margin-left: 6">RTSP only provides for stream control.  Stream delivery issues are not covered in this section, nor in the rest of this draft. RTSP implementations will most likely rely on other protocols such as RTP, IP multicast, RSVP and IGMP, and should address security considerations brought up in those and other applicable specifications.</dd>
<dt>Persistently suspicious behavior:</dt>
<dd style="margin-left: 6">RTSP servers SHOULD return error code 403 (Forbidden) upon receiving a single instance of behavior which is deemed a security risk. RTSP servers SHOULD also be aware of attempts to probe the server for weaknesses and entry points and MAY arbitrarily disconnect and ignore further requests clients which are deemed to be in violation of local security policy.</dd>
<dt>Scope of Multicast:</dt>
<dd style="margin-left: 6">If RTSP is used to control the transmission of media onto a multicast network it is need to consider the scope that delivery has. RTSP supports the TTL Transport header parameter to indicate this scope. However, such scope control is risk as it may be set to large and distribute media beyond the intended scope.</dd>
<dt>TLS through proxies:</dt>
<dd style="margin-left: 6">If one uses the possibility to connect TLS in multiple legs (<a href="#sec_sec-frame-proxy">Section 19.3</a> one really needs to be aware of the trust model. That procedure requires full faith and trust in all proxies that one allows to connect through. They are man in the middle and has access to all that goes on over the TLS connection.  Thus it is important to consider if that trust model is acceptable in the actual application.</dd>
<dt>Resource Exhaustion:</dt>
<dd style="margin-left: 6">As RTSP is a stateful protocol and establish resource usages on the server there is a clear possibility to attack the server by trying to overbook these resources to perform an denial of service attack. This attack can be both against ongoing sessions and to prevent others from establishing sessions. RTSP agents will need to have mechanism to prevent single peers from consuming extensive amounts of resources.</dd>
</dl>
<h1 id="rfc.section.21.1">
<a href="#rfc.section.21.1">21.1.</a> <a href="#sec-dos" id="sec-dos">Remote denial of Service Attack</a>
</h1>
<p id="rfc.section.21.1.p.1">The attacker may initiate traffic flows to one or more IP addresses by specifying them as the destination in SETUP requests. While the attacker's IP address may be known in this case, this is not always useful in prevention of more attacks or ascertaining the attackers identity. Thus, an RTSP server MUST only allow client-specified destinations for RTSP-initiated traffic flows if the server has ensured that the specified destination address accepts receiving media through different security mechanisms. Security mechanisms that are acceptable in an increased generality are: </p>

<ul>
<li>Verification of the client's identity, either against a database of known users using RTSP authentication mechanisms (preferably digest authentication or stronger)</li>
<li>A list of addresses that accept to be media destinations, especially considering user identity</li>
<li>Media path based verification</li>
</ul>
<p id="rfc.section.21.1.p.2">The server SHOULD NOT allow the destination field to be set unless a mechanism exists in the system to authorize the request originator to direct streams to the recipient. It is preferred that this authorization be performed by the media recipient (destination) itself and the credentials passed along to the server. However, in certain cases, such as when recipient address is a multicast group, or when the recipient is unable to communicate with the server in an out-of-band manner, this may not be possible. In these cases the server may chose another method such as a server-resident authorization list to ensure that the request originator has the proper credentials to request stream delivery to the recipient.</p>
<p id="rfc.section.21.1.p.3">One solution that performs the necessary verification of acceptance of media suitable for unicast based delivery is the ICE based NAT traversal method described in <a href="#I-D.ietf-mmusic-rtsp-nat">[I-D.ietf-mmusic-rtsp-nat]</a>. By using random passwords and username the probability of unintended indication as a valid media destination is very low. If the server include in its STUN requests a cookie (consisting of random material) that is the destination echo back the solution is also safe against having a off-path attacker being able to spoof the STUN checks. Leaving this solution vulnerable only to on-path attackers that can see the STUN requests go to the target of attack.</p>
<p id="rfc.section.21.1.p.4">For delivery to multicast addresses there is need for another solution which is not specified here.</p>
<h1 id="rfc.section.22">
<a href="#rfc.section.22">22.</a> <a href="#sec_IANA" id="sec_IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.22.p.1">This section sets up a number of registries for RTSP 2.0 that should be maintained by IANA. These registries are separate from any registries existing for RTSP 1.0. For each registry there is a description on what it is required to contain, what specification is needed when adding a entry with IANA, and finally the entries that this document needs to register. See also the <a href="#sec_extend-rtsp">Section 2.7</a> "Extending RTSP". There is also an IANA registration of two SDP attributes.</p>
<p id="rfc.section.22.p.2">The sections describing how to register an item uses some of the requirements level described in <a href="#RFC5226">RFC 5226</a> <cite title="NONE">[RFC5226]</cite>, namely "First Come, First Served", "Expert Review, "Specification Required", and "Standards Action".</p>
<p id="rfc.section.22.p.3">In case a registry requires a contact person, the authors are the contact person for any entries created by this document.</p>
<p id="rfc.section.22.p.4">A registration request to IANA MUST contain the following information: </p>

<ul>
<li>A name of the item to register according to the rules specified by the intended registry.</li>
<li>Indication of who has change control over the feature (for example, IETF, ISO, ITU-T, other international standardization bodies, a consortium, a particular company or group of companies, or an individual);</li>
<li>A reference to a further description, if available, for example (in decreasing order of preference) an RFC, a published standard, a published paper, a patent filing, a technical report, documented source code or a computer manual;</li>
<li>For proprietary features, contact information (postal and email address);</li>
</ul>
<h1 id="rfc.section.22.1">
<a href="#rfc.section.22.1">22.1.</a> Feature-tags</h1>
<h1 id="rfc.section.22.1.1">
<a href="#rfc.section.22.1.1">22.1.1.</a> Description</h1>
<p id="rfc.section.22.1.1.p.1">When a client and server try to determine what part and functionality of the RTSP specification and any future extensions that its counter part implements there is need for a namespace. This registry contains named entries representing certain functionality.</p>
<p id="rfc.section.22.1.1.p.2">The usage of feature-tags is explained in <a href="#sec_capability">Section 11</a> and <a href="#sec_OPTIONS">Section 13.1</a>.</p>
<h1 id="rfc.section.22.1.2">
<a href="#rfc.section.22.1.2">22.1.2.</a> Registering New Feature-tags with IANA</h1>
<p id="rfc.section.22.1.2.p.1">The registering of feature-tags is done on a first come, first served basis.</p>
<p id="rfc.section.22.1.2.p.2">The name of the feature MUST follow these rules: The name may be of any length, but SHOULD be no more than twenty characters long.  The name MUST NOT contain any spaces, or control characters. The registration MUST indicate if the feature-tag applies to clients, servers, or proxies only or any combinations of these. Any proprietary feature MUST have as the first part of the name a vendor tag, which identifies the organization. The registry entries consists of the tag, a one paragraph description of what it represents, its applicability (server, client, proxy, any combination) and a reference to its specification where applicable.</p>
<h1 id="rfc.section.22.1.3">
<a href="#rfc.section.22.1.3">22.1.3.</a> Registered entries</h1>
<p id="rfc.section.22.1.3.p.1">The following feature-tags are in this specification defined and hereby registered. The change control belongs to the IETF. </p>

<dl>
<dt>play.basic:</dt>
<dd style="margin-left: 6">The minimal implementation for delivery and playback operations according to this specification. Applies for both clients, servers and proxies.</dd>
<dt>play.scale:</dt>
<dd style="margin-left: 6">Support of scale operations for media playback. Applies only for servers.</dd>
<dt>play.speed:</dt>
<dd style="margin-left: 6">Support of the speed functionality for media delivery. Applies only for servers.</dd>
<dt>setup.rtp.rtcp.mux</dt>
<dd style="margin-left: 6">Support of the RTP and RTCP multiplexing as discussed in <a href="#sec-rtp-rtcp-mux">Appendix Appendix C.1.6.4</a>. Applies for both client and servers and any media caching proxy.</dd>
</dl>

<p>This should be represented by IANA as table with the feature tags, contact person and their references.</p>
<h1 id="rfc.section.22.2">
<a href="#rfc.section.22.2">22.2.</a> RTSP Methods</h1>
<h1 id="rfc.section.22.2.1">
<a href="#rfc.section.22.2.1">22.2.1.</a> Description</h1>
<p id="rfc.section.22.2.1.p.1">What a method is, is described in section <a href="#sec_methods">Section 13</a>. Extending the protocol with new methods allow for totally new functionality.</p>
<h1 id="rfc.section.22.2.2">
<a href="#rfc.section.22.2.2">22.2.2.</a> Registering New Methods with IANA</h1>
<p id="rfc.section.22.2.2.p.1">A new method MUST be registered through an IETF Standards Action.  The reason is that new methods may radically change the protocol's behavior and purpose.</p>
<p id="rfc.section.22.2.2.p.2">A specification for a new RTSP method MUST consist of the following items: </p>

<ul>
<li>A method name which follows the ABNF rules for methods.</li>
<li>A clear specification what a request using the method does and what responses are expected. Which directions the method is used, C-&gt;S or S-&gt;C or both. How the use of headers, if any, modifies the behavior and effect of the method.</li>
<li>A list or table specifying which of the registered headers that are allowed to use with the method in request or/and response.</li>
<li>Describe how the method relates to network proxies.</li>
</ul>
<h1 id="rfc.section.22.2.3">
<a href="#rfc.section.22.2.3">22.2.3.</a> Registered Entries</h1>
<p id="rfc.section.22.2.3.p.1">This specification, RFCXXXX, registers 10 methods: DESCRIBE, GET_PARAMETER, OPTIONS, PAUSE, PLAY, PLAY_NOTIFY REDIRECT, SETUP, SET_PARAMETER, and TEARDOWN. The initial table of the registry is below provided.</p>
<div id="#rfc.figure.87"></div>
<pre>Method         Directionality           Reference
-----------------------------------------------------
DESCRIBE       C-&gt;S                     [RFCXXXX]
GET_PARAMETER  C-&gt;S, S-&gt;C               [RFCXXXX]
OPTIONS        C-&gt;S, S-&gt;C               [RFCXXXX]
PAUSE          C-&gt;S                     [RFCXXXX]
PLAY           C-&gt;S                     [RFCXXXX]
PLAY_NOTIFY    S-&gt;C                     [RFCXXXX]
REDIRECT       S-&gt;C                     [RFCXXXX]
SETUP          C-&gt;S                     [RFCXXXX]
SET_PARAMETER  C-&gt;S, S-&gt;C               [RFCXXXX]
TEARDOWN       C-&gt;S, S-&gt;C               [RFCXXXX] </pre>
<p></p>
<h1 id="rfc.section.22.3">
<a href="#rfc.section.22.3">22.3.</a> RTSP Status Codes</h1>
<h1 id="rfc.section.22.3.1">
<a href="#rfc.section.22.3.1">22.3.1.</a> Description</h1>
<p id="rfc.section.22.3.1.p.1">A status code is the three digit numbers used to convey information in RTSP response messages, see<a href="#sec_response">Section 8</a>. The number space is limited and care should be taken not to fill the space.</p>
<h1 id="rfc.section.22.3.2">
<a href="#rfc.section.22.3.2">22.3.2.</a> Registering New Status Codes with IANA</h1>
<p id="rfc.section.22.3.2.p.1">A new status code registrations follows the policy of IETF Review. A specification for a new status code MUST specify the following: </p>

<ul>
<li>The requested number.</li>
<li>A description what the status code means and the expected behavior of the sender and receiver of the code.</li>
</ul>
<h1 id="rfc.section.22.3.3">
<a href="#rfc.section.22.3.3">22.3.3.</a> Registered Entries</h1>
<p id="rfc.section.22.3.3.p.1">RFCXXXX, registers the numbered status code defined in the ABNF entry "Status-Code" except "extension-code" (that defines the syntax allowed for future extensions) in <a href="#sec_syntax-prot-message">Section 20.2.2</a>.</p>
<h1 id="rfc.section.22.4">
<a href="#rfc.section.22.4">22.4.</a> RTSP Headers</h1>
<h1 id="rfc.section.22.4.1">
<a href="#rfc.section.22.4.1">22.4.1.</a> Description</h1>
<p id="rfc.section.22.4.1.p.1">By specifying new headers a method(s) can be enhanced in many different ways. An unknown header will be ignored by the receiving agent. If the new header is vital for a certain functionality, a feature-tag for the functionality can be created and demanded to be used by the counter-part with the inclusion of a Require header carrying the feature-tag.</p>
<h1 id="rfc.section.22.4.2">
<a href="#rfc.section.22.4.2">22.4.2.</a> Registering New Headers with IANA</h1>
<p id="rfc.section.22.4.2.p.1">Registrations in the registry can be done following the Expert Review policy. A specification SHOULD be provided, preferable an IETF RFC or other Standards Developing Organization specification.  The minimal information in a registration request is the header name and the contact information.</p>
<p id="rfc.section.22.4.2.p.2">The specification SHOULD contain the following information: </p>

<ul>
<li>The name of the header.</li>
<li>An ABNF specification of the header syntax.</li>
<li>A list or table specifying when the header may be used, encompassing all methods, their request or response, the direction (C-&gt;S or S-&gt;C).</li>
<li>How the header is to be handled by proxies.</li>
<li>A description of the purpose of the header.</li>
</ul>
<h1 id="rfc.section.22.4.3">
<a href="#rfc.section.22.4.3">22.4.3.</a> Registered entries</h1>
<p id="rfc.section.22.4.3.p.1">All headers specified in <a href="#sec_headers">Section 16</a> in RFCXXXX are to be registered. The Registry is to include header name, description, and reference.</p>
<p id="rfc.section.22.4.3.p.2">Furthermore the following RTSP headers defined in other specifications are registered: </p>

<ul>
<li>x-wap-profile defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>x-wap-profile-diff defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>x-wap-profile-warning defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>x-predecbufsize defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>x-initpredecbufperiod defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>x-initpostdecbufperiod defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>3gpp-videopostdecbufsize defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>3GPP-Link-Char defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>3GPP-Adaptation defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>3GPP-QoE-Metrics defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
<li>3GPP-QoE-Feedback defined in <a href="#3gpp-26234">[3gpp-26234]</a>.</li>
</ul>
<p id="rfc.section.22.4.3.p.3">The use of "x-" is NOT RECOMMENDED but the above headers in the register list was defined prior to the clarification.</p>
<h1 id="rfc.section.22.5">
<a href="#rfc.section.22.5">22.5.</a> Accept-Credentials</h1>
<p id="rfc.section.22.5.p.1">The security framework's TLS connection mechanism has two registrable entities.</p>
<h1 id="rfc.section.22.5.1">
<a href="#rfc.section.22.5.1">22.5.1.</a> Accept-Credentials policies</h1>
<p id="rfc.section.22.5.1.p.1">In <a href="#sec-frame-accept-cred">Section 19.3.1</a> three policies for how to handle certificates are specified. Further policies may be defined and MUST be registered with IANA using the following rules: </p>

<ul>
<li>Registering requires an IETF Standards Action</li>
<li>A registration is required to name a contact person.</li>
<li>Name of the policy.</li>
<li>A describing text that explains how the policy works for handling the certificates.</li>
</ul>
<p id="rfc.section.22.5.1.p.2">This specification registers the following values: </p>

<dl>
<dt>Any</dt>
<dd style="margin-left: 6"></dd>
<dt>Proxy</dt>
<dd style="margin-left: 6"></dd>
<dt>User</dt>
<dd style="margin-left: 6"></dd>
</dl>
<h1 id="rfc.section.22.5.2">
<a href="#rfc.section.22.5.2">22.5.2.</a> Accept-Credentials hash algorithms</h1>
<p id="rfc.section.22.5.2.p.1">The Accept-Credentials header (See <a href="#sec_Accept-Credentials">Section 16.2</a>) allows for the usage of other algorithms for hashing the DER records of accepted entities.  The registration of any future algorithm is expected to be extremely rare and could also cause interoperability problems. Therefore the bar for registering new algorithms is intentionally placed high.</p>
<p id="rfc.section.22.5.2.p.2">Any registration of a new hash algorithm MUST fulfill the following requirement: </p>

<ul>
<li>Follow the IETF Standards Action policy.</li>
<li>A definition of the algorithm and its identifier meeting the "token" ABNF requirement.</li>
</ul>

<p>The registered value is:</p>
<div id="#rfc.figure.88"></div>
<pre>Hash Alg. Id   Reference
------------------------
sha-256        [RFCXXXX]</pre>
<p></p>
<h1 id="rfc.section.22.6">
<a href="#rfc.section.22.6">22.6.</a> Cache-Control Cache Directive Extensions</h1>
<p id="rfc.section.22.6.p.1">There exist a number of cache directives which can be sent in the Cache-Control header. A registry for these cache directives MUST be defined with the following rules: </p>

<ul>
<li>Registering requires an IETF Standards Action or IESG Approval.</li>
<li>A registration is required to contain a contact person.</li>
<li>Name of the directive and a definition of the value, if any.</li>
<li>Specification if it is an request or response directive.</li>
<li>A describing text that explains how the cache directive is used for RTSP controlled media streams.</li>
</ul>
<p id="rfc.section.22.6.p.2">This specification registers the following values: </p>

<dl>
<dt>no-cache:</dt>
<dd style="margin-left: 6"></dd>
<dt>public:</dt>
<dd style="margin-left: 6"></dd>
<dt>private:</dt>
<dd style="margin-left: 6"></dd>
<dt>no-transform:</dt>
<dd style="margin-left: 6"></dd>
<dt>only-if-cached:</dt>
<dd style="margin-left: 6"></dd>
<dt>max-stale:</dt>
<dd style="margin-left: 6"></dd>
<dt>min-fresh:</dt>
<dd style="margin-left: 6"></dd>
<dt>must-revalidate:</dt>
<dd style="margin-left: 6"></dd>
<dt>proxy-revalidate:</dt>
<dd style="margin-left: 6"></dd>
<dt>max-age:</dt>
<dd style="margin-left: 6"></dd>
</dl>

<p>The registry should be represented as: Name of the directive, contact person and reference.</p>
<h1 id="rfc.section.22.7">
<a href="#rfc.section.22.7">22.7.</a> Media Properties</h1>
<p></p>
<h1 id="rfc.section.22.7.1">
<a href="#rfc.section.22.7.1">22.7.1.</a> Description</h1>
<p id="rfc.section.22.7.1.p.1">The media streams being controlled by RTSP can have many different properties. The media properties required to cover the use cases that was in mind when writing the specification are defined.  However, it can be expected that further innovation will result in new use cases or media streams with properties not covered by the ones specified here. Thus new media properties can be specified. As new media properties may need a substantial amount of new definitions to correctly specify behavior for this property the bar is intended to be high.</p>
<h1 id="rfc.section.22.7.2">
<a href="#rfc.section.22.7.2">22.7.2.</a> Registration Rules</h1>
<p id="rfc.section.22.7.2.p.1">Registering new media property MUST fulfill the following requirements</p>
<p></p>

<ul>
<li>Follow the Specification Required policy and get the approval of the designated Expert.</li>
<li>Have an ABNF definition of the media property value name that meets "media-prop-ext" definition</li>
<li>A Contact Person for the Registration</li>
<li>Description of all changes to the behavior of the RTSP protocol as result of these changes.</li>
</ul>
<h1 id="rfc.section.22.7.3">
<a href="#rfc.section.22.7.3">22.7.3.</a> Registered Values</h1>
<p id="rfc.section.22.7.3.p.1">This specification registers the 9 values listed in <a href="#sec_Media-Properties">Section 16.28</a>. The registry should be represented as: Name of the media property, contact person and reference.</p>
<h1 id="rfc.section.22.8">
<a href="#rfc.section.22.8">22.8.</a> Notify-Reason header</h1>
<p></p>
<h1 id="rfc.section.22.8.1">
<a href="#rfc.section.22.8.1">22.8.1.</a> Description</h1>
<p id="rfc.section.22.8.1.p.1">Notify-Reason values are used for indicating the reason the notification was sent. Each reason has its associated rules on what headers and information that may or must be included in the notification. New notification behaviors need to be specified to enable interoperable usage, thus a specification of each new value is required.</p>
<h1 id="rfc.section.22.8.2">
<a href="#rfc.section.22.8.2">22.8.2.</a> Registration Rules</h1>
<p id="rfc.section.22.8.2.p.1">Registrations for new Notify-Reason value MUST fulfill the following requirements</p>
<p></p>

<ul>
<li>Follow the Specification Required policy and get the approval of the designated Expert.</li>
<li>Have a ABNF definition of the Notify reason value name that meets "Notify-Reason-extension" definition</li>
<li>A Contact Person for the Registration</li>
<li>Description of which headers shall be included in the request and response, when it should be sent, and any effect it has on the server client state.</li>
</ul>
<h1 id="rfc.section.22.8.3">
<a href="#rfc.section.22.8.3">22.8.3.</a> Registered Values</h1>
<p id="rfc.section.22.8.3.p.1">This specification registers 3 values defined in the Notify-Reas-val ABNF<a href="#sec_syntax-prot-header">Section 20.2.3</a>:</p>
<p></p>

<ul>
<li>end-of-stream</li>
<li>media-properties-update</li>
<li>scale-change</li>
</ul>

<p>The registry entries should be represented in the registry as: Name, short description, contact and reference.</p>
<h1 id="rfc.section.22.9">
<a href="#rfc.section.22.9">22.9.</a> Range header formats</h1>
<p></p>
<h1 id="rfc.section.22.9.1">
<a href="#rfc.section.22.9.1">22.9.1.</a> Description</h1>
<p id="rfc.section.22.9.1.p.1">The <a href="#sec_Range">Range header</a> <cite title="NONE">[sec_Range]</cite> allows for different range formats. New ones may be registered, but moderation should be applied as it makes interoperability more difficult.</p>
<h1 id="rfc.section.22.9.2">
<a href="#rfc.section.22.9.2">22.9.2.</a> Registration Rules</h1>
<p id="rfc.section.22.9.2.p.1">A registration MUST fulfill the following requirements: </p>

<ul>
<li>Follow the Specification Required policy.</li>
<li>An ABNF definition of the range format that fulfills the "range-ext" definition.</li>
<li>A Contact person for the registration.</li>
<li>Rules for how one handles the range when using a negative Scale.</li>
</ul>
<h1 id="rfc.section.22.9.3">
<a href="#rfc.section.22.9.3">22.9.3.</a> Registered Values</h1>
<p id="rfc.section.22.9.3.p.1">The registry should be represented as: Name of the range format, contact person and reference. This specification registers the following values.</p>
<p></p>

<dl>
<dt>npt:</dt>
<dd style="margin-left: 8">Normal Play Time</dd>
<dt>clock:</dt>
<dd style="margin-left: 8">UTC Clock format</dd>
<dt>smpte:</dt>
<dd style="margin-left: 8">SMPTE Timestamps</dd>
</dl>
<h1 id="rfc.section.22.10">
<a href="#rfc.section.22.10">22.10.</a> Terminate-Reason Header</h1>
<p id="rfc.section.22.10.p.1">The <a href="#sec_Terminate-Reason">Terminate-Reason header</a> <cite title="NONE">[sec_Terminate-Reason]</cite> has two registries for extensions.</p>
<h1 id="rfc.section.22.10.1">
<a href="#rfc.section.22.10.1">22.10.1.</a> Redirect Reasons</h1>
<p id="rfc.section.22.10.1.p.1">Registrations are done under the policy of Expert Review. The registered value needs to follow syntax, i.e. be a token. The specification needs to provide definition of what the procedures that is to be followed when a client receives this redirect reason.  This specification registers two values:</p>
<p></p>

<ul>
<li>Session-Timeout</li>
<li>Server-Admin</li>
</ul>

<p>The registry should be represented as: Name of the Redirect Reason, contact person and reference.</p>
<h1 id="rfc.section.22.10.2">
<a href="#rfc.section.22.10.2">22.10.2.</a> Terminate-Reason Header Parameters</h1>
<p id="rfc.section.22.10.2.p.1">Registrations are done under the policy of Specification Required. The registrations must define a syntax for the parameter that also follows the allowed by the RTSP 2.0 specification. A contact person is also required. This specification registers:</p>
<p></p>

<ul>
<li>time</li>
<li>user-msg</li>
</ul>

<p>The registry should be represented as: Name of the Terminate Reason, contact person and reference.</p>
<h1 id="rfc.section.22.11">
<a href="#rfc.section.22.11">22.11.</a> RTP-Info header parameters</h1>
<p></p>
<h1 id="rfc.section.22.11.1">
<a href="#rfc.section.22.11.1">22.11.1.</a> Description</h1>
<p id="rfc.section.22.11.1.p.1">The <a href="#sec_RTP-Info">RTP-Info header</a> <cite title="NONE">[sec_RTP-Info]</cite> carries one or more parameter value pairs with information about a particular point in the RTP stream. RTP extensions or new usages may need new types of information. As RTP information that could be needed is likely to be generic enough and to maximize the interoperability registration requires specification required.</p>
<h1 id="rfc.section.22.11.2">
<a href="#rfc.section.22.11.2">22.11.2.</a> Registration Rules</h1>
<p id="rfc.section.22.11.2.p.1">Registrations for new Notify-Reason value MUST fulfill the following requirements</p>
<p></p>

<ul>
<li>Follow the Specification Required policy and get the approval of the designated Expert.</li>
<li>Have a ABNF definition that meets the "generic-param" definition</li>
<li>A Contact Person for the Registration</li>
</ul>
<h1 id="rfc.section.22.11.3">
<a href="#rfc.section.22.11.3">22.11.3.</a> Registered Values</h1>
<p id="rfc.section.22.11.3.p.1">This specification registers 2 parameter value pairs:</p>
<p></p>

<ul>
<li>seq</li>
<li>rtptime</li>
</ul>

<p>The registry should be represented as: Name of the parameter, contact person and reference.</p>
<h1 id="rfc.section.22.12">
<a href="#rfc.section.22.12">22.12.</a> Seek-Style Policies</h1>
<p></p>
<h1 id="rfc.section.22.12.1">
<a href="#rfc.section.22.12.1">22.12.1.</a> Description</h1>
<p id="rfc.section.22.12.1.p.1">New seek policies may be registered, however, a large number of these will complicate implementation substantially. The impact of unknown policies is that the server will not honor the unknown and use the server default policy instead.</p>
<h1 id="rfc.section.22.12.2">
<a href="#rfc.section.22.12.2">22.12.2.</a> Registration Rules</h1>
<p id="rfc.section.22.12.2.p.1">Registrations of new Seek-Style polices MUST fulfill the following requirements</p>
<p></p>

<ul>
<li>Follow the Specification Required policy.</li>
<li>Have a ABNF definition of the Seek-Style policy name that meets "Seek-S-value-ext" definition</li>
<li>A Contact Person for the Registration</li>
<li>Description of which headers shall be included in the request and response, when it should be sent, and any affect it has on the server client state.</li>
</ul>
<h1 id="rfc.section.22.12.3">
<a href="#rfc.section.22.12.3">22.12.3.</a> Registered Values</h1>
<p id="rfc.section.22.12.3.p.1">This specification registers 4 values:</p>
<p></p>

<ul>
<li>RAP</li>
<li>CoRAP</li>
<li>First-Prior</li>
<li>Next</li>
</ul>

<p>The registry should be represented as: Name of the Seek-Style Policy, short description, contact person and reference.</p>
<h1 id="rfc.section.22.13">
<a href="#rfc.section.22.13">22.13.</a> <a href="#sec_IANA-trn" id="sec_IANA-trn">Transport Header Registries</a>
</h1>
<p id="rfc.section.22.13.p.1">The transport header contains a number of parameters which have possibilities for future extensions. Therefore registries for these needs to be defined.</p>
<h1 id="rfc.section.22.13.1">
<a href="#rfc.section.22.13.1">22.13.1.</a> Transport Protocol Specification</h1>
<p id="rfc.section.22.13.1.p.1">A registry for the parameter transport-protocol specification MUST be defined with the following rules: </p>

<ul>
<li>Registering uses the policy of Specification Required.</li>
<li>A contact person or organization with address and email.</li>
<li>A value definition that are following the ABNF syntax definition of "transport-id" <a href="#sec_syntax-prot-header">Section 20.2.3</a>.</li>
<li>A describing text that explains how the registered value are used in RTSP.</li>
</ul>

<p>The registry should be represented as: The protocol ID string, contact person and reference.</p>
<p id="rfc.section.22.13.1.p.2">This specification registers the following values: </p>

<dl>
<dt>RTP/AVP:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the <a href="#RFC3551">"RTP profile for audio and video conferences with minimal control"</a> <cite title="NONE">[RFC3551]</cite> over UDP. The usage is explained in RFC XXXX, <a href="#sec_rtp">Appendix Appendix C.1</a>.</dd>
<dt>RTP/AVP/UDP:</dt>
<dd style="margin-left: 6">the same as RTP/AVP.</dd>
<dt>RTP/AVPF:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the <a href="#RFC4585">"Extended RTP Profile for RTCP-based Feedback (RTP/AVPF)"</a> <cite title="NONE">[RFC4585]</cite> over UDP. The usage is explained in RFC XXXX, <a href="#sec_rtp">Appendix Appendix C.1</a>.</dd>
<dt>RTP/AVPF/UDP:</dt>
<dd style="margin-left: 6">the same as RTP/AVPF.</dd>
<dt>RTP/SAVP:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the <a href="#RFC3711">"The Secure Real-time Transport Protocol (SRTP)"</a> <cite title="NONE">[RFC3711]</cite> over UDP. The usage is explained in RFC XXXX, <a href="#sec_rtp">Appendix Appendix C.1</a>.</dd>
<dt>RTP/SAVP/UDP:</dt>
<dd style="margin-left: 6">the same as RTP/SAVP.</dd>
<dt>RTP/SAVPF:</dt>
<dd style="margin-left: 6">Use of the RTP<a href="#RFC3550">[RFC3550]</a> protocol for media transport in combination with the <a href="#RFC5124">Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)</a> <cite title="NONE">[RFC5124]</cite> over UDP. The usage is explained in RFC XXXX, <a href="#sec_rtp">Appendix Appendix C.1</a>.</dd>
<dt>RTP/SAVPF/UDP:</dt>
<dd style="margin-left: 6">the same as RTP/SAVPF.</dd>
<dt>RTP/AVP/TCP:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the <a href="#RFC3551">"RTP profile for audio and video conferences with minimal control"</a> <cite title="NONE">[RFC3551]</cite> over TCP. The usage is explained in RFC XXXX, <a href="#sec_media-tcp-contrans">Appendix Appendix C.2.2</a>.</dd>
<dt>RTP/AVPF/TCP:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the <a href="#RFC4585">"Extended RTP Profile for RTCP-based Feedback (RTP/AVPF)"</a> <cite title="NONE">[RFC4585]</cite> over TCP. The usage is explained in RFC XXXX, <a href="#sec_media-tcp-contrans">Appendix Appendix C.2.2</a>.</dd>
<dt>RTP/SAVP/TCP:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the <a href="#RFC3711">"The Secure Real-time Transport Protocol (SRTP)"</a> <cite title="NONE">[RFC3711]</cite> over TCP. The usage is explained in RFC XXXX, <a href="#sec_media-tcp-contrans">Appendix Appendix C.2.2</a>.</dd>
<dt>RTP/SAVPF/TCP:</dt>
<dd style="margin-left: 6">Use of the <a href="#RFC3550">RTP</a> <cite title="NONE">[RFC3550]</cite> protocol for media transport in combination with the "<a href="#RFC5124">Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)"</a> <cite title="NONE">[RFC5124]</cite> over TCP. The usage is explained in RFC XXXX, <a href="#sec_media-tcp-contrans">Appendix Appendix C.2.2</a>.</dd>
</dl>
<h1 id="rfc.section.22.13.2">
<a href="#rfc.section.22.13.2">22.13.2.</a> Transport modes</h1>
<p id="rfc.section.22.13.2.p.1">A registry for the transport parameter mode MUST be defined with the following rules: </p>

<ul>
<li>Registering requires an IETF Standards Action.</li>
<li>A contact person or organization with address and email.</li>
<li>A value definition that are following the ABNF "token" definition <a href="#sec_syntax-prot-header">Section 20.2.3</a>.</li>
<li>A describing text that explains how the registered value are used in RTSP.</li>
</ul>
<p id="rfc.section.22.13.2.p.2">This specification registers 1 value: </p>

<dl>
<dt>PLAY:</dt>
<dd style="margin-left: 6">See RFC XXXX.</dd>
</dl>
<h1 id="rfc.section.22.13.3">
<a href="#rfc.section.22.13.3">22.13.3.</a> Transport Parameters</h1>
<p id="rfc.section.22.13.3.p.1">A registry for parameters that may be included in the Transport header MUST be defined with the following rules: <a href="#sec_Transport">Section 16.52</a>.</p>

<ul>
<li>Registering uses the Specification Required policy.</li>
<li>A value definition that are following the ABNF "token" definition <a href="#sec_syntax-prot-header">Section 20.2.3</a>.</li>
<li>A describing text that explains how the registered value are used in RTSP.</li>
</ul>

<p> This specification registers all the transport parameters defined in </p>
<h1 id="rfc.section.22.14">
<a href="#rfc.section.22.14">22.14.</a> <a href="#sec_iana-uri-schemes" id="sec_iana-uri-schemes">URI Schemes</a>
</h1>
<p id="rfc.section.22.14.p.1">This specification defines two URI schemes ("rtsp" and "rtsps") and reserves a third one ("rtspu"). Registrations are following RFC 4395<a href="#RFC4395">[RFC4395]</a>.</p>
<h1 id="rfc.section.22.14.1">
<a href="#rfc.section.22.14.1">22.14.1.</a> The rtsp URI Scheme</h1>
<p></p>

<dl>
<dt>URI scheme name:</dt>
<dd style="margin-left: 6">rtsp</dd>
<dt>Status:</dt>
<dd style="margin-left: 6">Permanent</dd>
<dt>URI scheme syntax:</dt>
<dd style="margin-left: 6">See <a href="#sec_syntax-prot-generic">Section 20.2.1</a> of RFC XXXX.</dd>
<dt>URI scheme semantics:</dt>
<dd style="margin-left: 6">The rtsp scheme is used to indicate resources accessible through the usage of the Real-time Streaming Protocol (RTSP). RTSP allows different operations on the resource identified by the URI, but the primary purpose is the streaming delivery of the resource to a client. However, the operations that are currently defined are: Describing the resource for the purpose of configuring the receiving agent (DESCRIBE), configuring the delivery method and its addressing (SETUP), controlling the delivery (PLAY and PAUSE), reading or setting of resource related parameters (SET_PARAMETER and GET_PARAMETER, and termination of the session context created (TEARDOWN).</dd>
<dt>Encoding considerations:</dt>
<dd style="margin-left: 6">IRIs in this scheme are defined and needs to be encoded as RTSP URIs when used within the RTSP protocol. That encoding is done according to RFC 3987.</dd>
<dt>Applications/protocols that use this URI scheme name:</dt>
<dd style="margin-left: 6">RTSP 1.0 (RFC 2326), RTSP 2.0 (RFC XXXX)</dd>
<dt>Interoperability considerations:</dt>
<dd style="margin-left: 6">The change in URI syntax performed between RTSP 1.0 and 2.0 can create interoperability issues.</dd>
<dt>Security considerations:</dt>
<dd style="margin-left: 6">All the security threats identified in Section 7 of RFC 3986 applies also to this scheme.  They need to be reviewed and considered in any implementation utilizing this scheme.</dd>
<dt>Contact:</dt>
<dd style="margin-left: 6">Magnus Westerlund, magnus.westerlund@ericsson.com</dd>
<dt>Author/Change controller:</dt>
<dd style="margin-left: 6">IETF</dd>
<dt>References:</dt>
<dd style="margin-left: 6">RFC 2326, RFC 3986, RFC 3987, RFC XXXX</dd>
</dl>
<h1 id="rfc.section.22.14.2">
<a href="#rfc.section.22.14.2">22.14.2.</a> The rtsps URI Scheme</h1>
<p></p>

<dl>
<dt>URI scheme name:</dt>
<dd style="margin-left: 6">rtsps</dd>
<dt>Status:</dt>
<dd style="margin-left: 6">Permanent</dd>
<dt>URI scheme syntax:</dt>
<dd style="margin-left: 6">See <a href="#sec_syntax-prot-generic">Section 20.2.1</a> of RFC XXXX.</dd>
<dt>URI scheme semantics:</dt>
<dd style="margin-left: 6">The rtsps scheme is used to indicate resources accessible through the usage of the Real-time Streaming Protocol (RTSP) over TLS. RTSP allows different operations on the resource identified by the URI, but the primary purpose is the streaming delivery of the resource to a client. However, the operations that are currently defined are: Describing the resource for the purpose of configuring the receiving agent (DESCRIBE), configuring the delivery method and its addressing (SETUP), controlling the delivery (PLAY and PAUSE), reading or setting of resource related parameters (SET_PARAMETER and GET_PARAMETER, and termination of the session context created (TEARDOWN).</dd>
<dt>Encoding considerations:</dt>
<dd style="margin-left: 6">IRIs in this scheme are defined and needs to be encoded as RTSP URIs when used within the RTSP protocol. That encoding is done according to RFC 3987.</dd>
<dt>Applications/protocols that use this URI scheme name:</dt>
<dd style="margin-left: 6">RTSP 1.0 (RFC 2326), RTSP 2.0 (RFC XXXX)</dd>
<dt>Interoperability considerations:</dt>
<dd style="margin-left: 6">The change in URI syntax performed between RTSP 1.0 and 2.0 can create interoperability issues.</dd>
<dt>Security considerations:</dt>
<dd style="margin-left: 6">All the security threats identified in Section 7 of RFC 3986 applies also to this scheme.  They need to be reviewed and considered in any implementation utilizing this scheme.</dd>
<dt>Contact:</dt>
<dd style="margin-left: 6">Magnus Westerlund, magnus.westerlund@ericsson.com</dd>
<dt>Author/Change controller:</dt>
<dd style="margin-left: 6">IETF</dd>
<dt>References:</dt>
<dd style="margin-left: 6">RFC 2326, RFC 3986, RFC 3987, RFC XXXX</dd>
</dl>
<h1 id="rfc.section.22.14.3">
<a href="#rfc.section.22.14.3">22.14.3.</a> The rtspu URI Scheme</h1>
<p></p>

<dl>
<dt>URI scheme name:</dt>
<dd style="margin-left: 6">rtspu</dd>
<dt>Status:</dt>
<dd style="margin-left: 6">Permanent</dd>
<dt>URI scheme syntax:</dt>
<dd style="margin-left: 6">See Section 3.2 of RFC 2326.</dd>
<dt>URI scheme semantics:</dt>
<dd style="margin-left: 6">The rtspu scheme is used to indicate resources accessible through the usage of the Real-time Streaming Protocol (RTSP) over unreliable datagram transport.  RTSP allows different operations on the resource identified by the URI, but the primary purpose is the streaming delivery of the resource to a client. However, the operations that are currently defined are: Describing the resource for the purpose of configuring the receiving agent (DESCRIBE), configuring the delivery method and its addressing (SETUP), controlling the delivery (PLAY and PAUSE), reading or setting of resource related parameters (SET_PARAMETER and GET_PARAMETER, and termination of the session context created (TEARDOWN).</dd>
<dt>Encoding considerations:</dt>
<dd style="margin-left: 6">IRIs in this scheme are not defined.</dd>
<dt>Applications/protocols that use this URI scheme name:</dt>
<dd style="margin-left: 6">RTSP 1.0 (RFC 2326)</dd>
<dt>Interoperability considerations:</dt>
<dd style="margin-left: 6">The definition of the transport mechanism of RTSP over UDP has interoperability issues. That makes the usage of this scheme problematic.</dd>
<dt>Security considerations:</dt>
<dd style="margin-left: 6">All the security threats identified in Section 7 of RFC 3986 applies also to this scheme.  They needs to be reviewed and considered in any implementation utilizing this scheme.</dd>
<dt>Contact:</dt>
<dd style="margin-left: 6">Magnus Westerlund, magnus.westerlund@ericsson.com</dd>
<dt>Author/Change controller:</dt>
<dd style="margin-left: 6">IETF</dd>
<dt>References:</dt>
<dd style="margin-left: 6">RFC 2326</dd>
</dl>
<h1 id="rfc.section.22.15">
<a href="#rfc.section.22.15">22.15.</a> SDP attributes</h1>
<div id="#rfc.figure.89"></div>
<pre>
SDP Attribute ("att-field"):

     Attribute name:     range
     Long form:          Media Range Attribute
     Type of name:       att-field
     Type of attribute:  Media and session level
     Subject to charset: No
     Purpose:            RFC XXXX
     Reference:          RFC XXXX, RFC 2326
     Values:             See ABNF definition.

     Attribute name:     control
     Long form:          RTSP control URI
     Type of name:       att-field
     Type of attribute:  Media and session level
     Subject to charset: No
     Purpose:            RFC XXXX
     Reference:          RFC XXXX, RFC 2326
     Values:             Absolute or Relative URIs.

     Attribute name:     mtag
     Long form:          Message Tag
     Type of name:       att-field
     Type of attribute:  Media and session level
     Subject to charset: No
     Purpose:            RFC XXXX
     Reference:          RFC XXXX
     Values:             See ABNF definition

</pre>
<p id="rfc.section.22.15.p.1">This specification defines three SDP <a href="#RFC4566">[RFC4566]</a> attributes that it is requested that IANA register. </p>
<h1 id="rfc.section.22.16">
<a href="#rfc.section.22.16">22.16.</a> <a href="#sec_iana_textpar" id="sec_iana_textpar">Media Type Registration for text/parameters</a>
</h1>
<p></p>
<p></p>

<dl>
<dt>Type name:</dt>
<dd style="margin-left: 8">text</dd>
<dt>Subtype name:</dt>
<dd style="margin-left: 8">parameters</dd>
<dt>Required parameters:</dt>
<dd style="margin-left: 8"></dd>
<dt>Optional parameters:</dt>
<dd style="margin-left: 8"></dd>
<dt>Encoding considerations:</dt>
<dd style="margin-left: 8"></dd>
<dt>Security considerations:</dt>
<dd style="margin-left: 8">This format may carry any type of parameters. Some can clear have security requirements, like privacy, confidentiality or integrity requirements. The format has no built in security protection. For the usage it was defined the transport can be protected between server and client using TLS. However, care must be take to consider if also the proxies are trusted with the parameters in case hop-by-hop security is used. If stored as file in file system the necessary precautions needs to be taken in relation to the parameters requirements including object security such as S/MIME <a href="#RFC5751">[RFC5751]</a>.</dd>
<dt>Interoperability considerations:</dt>
<dd style="margin-left: 8">This media type was mentioned as a fictional example in RFC 2326 but was not formally specified. This have resulted in usage of this media type which may not match its formal definition.</dd>
<dt>Published specification:</dt>
<dd style="margin-left: 8">RFC XXXX, <a href="#sec_text-parameters">Appendix Appendix F</a>.</dd>
<dt>Applications that use this media type:</dt>
<dd style="margin-left: 8">Applications that use RTSP and have additional parameters they like to read and set using the RTSP GET_PARAMETER and SET_PARAMETER methods.</dd>
<dt>Additional information:</dt>
<dd style="margin-left: 8"></dd>
<dt>Magic number(s):</dt>
<dd style="margin-left: 8"></dd>
<dt>File extension(s):</dt>
<dd style="margin-left: 8"></dd>
<dt>Macintosh file type code(s): </dt>
<dd style="margin-left: 8"></dd>
<dt>Person &amp; email address to contact for further information:</dt>
<dd style="margin-left: 8">Magnus Westerlund (magnus.westerlund@ericsson.com)</dd>
<dt>Intended usage: </dt>
<dd style="margin-left: 8">Common</dd>
<dt>Restrictions on usage: </dt>
<dd style="margin-left: 8">None</dd>
<dt>Author:</dt>
<dd style="margin-left: 8">Magnus Westerlund (magnus.westerlund@ericsson.com)</dd>
<dt>Change controller:</dt>
<dd style="margin-left: 8">IETF</dd>
<dt>Addition Notes:</dt>
<dd style="margin-left: 8"></dd>
</dl>
<p></p>
<h1 id="rfc.references">
<a href="#rfc.references">23.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">23.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC5646">[RFC5646]</b></td>
<td class="top">
<a>Phillips, A.</a> and <a>M. Davis</a>, "<a href="http://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a>", BCP 47, RFC 5646, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4566">[RFC4566]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3551">[RFC3551]</b></td>
<td class="top">
<a>Schulzrinne, H.</a> and <a>S. Casner</a>, "<a href="http://tools.ietf.org/html/rfc3551">RTP Profile for Audio and Video Conferences with Minimal Control</a>", STD 65, RFC 3551, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2616">[RFC2616]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a> and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5124">[RFC5124]</b></td>
<td class="top">
<a>Ott, J.</a> and <a>E. Carrara</a>, "<a href="http://tools.ietf.org/html/rfc5124">Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)</a>", RFC 5124, February 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3987">[RFC3987]</b></td>
<td class="top">
<a>Duerst, M.</a> and <a>M. Suignard</a>, "<a href="http://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>", RFC 3987, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2617">[RFC2617]</b></td>
<td class="top">
<a href="mailto:john@math.nwu.edu" title="Northwestern University, Department of Mathematics">Franks, J.</a>, <a href="mailto:pbaker@verisign.com" title="Verisign Inc.">Hallam-Baker, P.M.</a>, <a href="mailto:jeff@AbiSource.com" title="AbiSource, Inc.">Hostetler, J.L.</a>, <a href="mailto:lawrence@agranat.com" title="Agranat Systems, Inc.">Lawrence, S.D.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.J.</a>, <a title="Netscape Communications Corporation">Luotonen, A.</a> and <a href="mailto:stewart@OpenMarket.com" title="Open Market, Inc.">L. Stewart</a>, "<a href="http://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>", RFC 2617, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0768">[RFC0768]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc768">User Datagram Protocol</a>", STD 6, RFC 768, August 1980.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a title="University of Southern California (USC)/Information Sciences Institute">Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4395">[RFC4395]</b></td>
<td class="top">
<a>Hansen, T.</a>, <a>Hardie, T.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc4395">Guidelines and Registration Procedures for New URI Schemes</a>", BCP 35, RFC 4395, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="3gpp-26234">[3gpp-26234]</b></td>
<td class="top">
<a title="Third Generation Partnership Project (3GPP)">, </a>, "<a>Transparent end-to-end Packet-switched Streaming Service (PSS); Protocols and codecs; Technical Specification 26.234</a>", December 2002.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS-pub-180-2">[FIPS-pub-180-2]</b></td>
<td class="top">
<a title="National Institute of Standards and Technology (NIST)">, </a>, "<a>Federal Information Processing Standards Publications (FIPS PUBS) 180-2: Secure Hash Standard</a>", August 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3550">[RFC3550]</b></td>
<td class="top">
<a>Schulzrinne, H.</a>, <a>Casner, S.</a>, <a>Frederick, R.</a> and <a>V. Jacobson</a>, "<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>", STD 64, RFC 3550, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2818">[RFC2818]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4585">[RFC4585]</b></td>
<td class="top">
<a>Ott, J.</a>, <a>Wenger, S.</a>, <a>Sato, N.</a>, <a>Burmeister, C.</a> and <a>J. Rey</a>, "<a href="http://tools.ietf.org/html/rfc4585">Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)</a>", RFC 4585, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3711">[RFC3711]</b></td>
<td class="top">
<a>Baugher, M.</a>, <a>McGrew, D.</a>, <a>Naslund, M.</a>, <a>Carrara, E.</a> and <a>K. Norrman</a>, "<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>", RFC 3711, March 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4567">[RFC4567]</b></td>
<td class="top">
<a>Arkko, J.</a>, <a>Lindholm, F.</a>, <a>Naslund, M.</a>, <a>Norrman, K.</a> and <a>E. Carrara</a>, "<a href="http://tools.ietf.org/html/rfc4567">Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)</a>", RFC 4567, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3830">[RFC3830]</b></td>
<td class="top">
<a>Arkko, J.</a>, <a>Carrara, E.</a>, <a>Lindholm, F.</a>, <a>Naslund, M.</a> and <a>K. Norrman</a>, "<a href="http://tools.ietf.org/html/rfc3830">MIKEY: Multimedia Internet KEYing</a>", RFC 3830, August 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4571">[RFC4571]</b></td>
<td class="top">
<a>Lazzaro, J.</a>, "<a href="http://tools.ietf.org/html/rfc4571">Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection-Oriented Transport</a>", RFC 4571, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4288">[RFC4288]</b></td>
<td class="top">
<a>Freed, N.</a> and <a>J. Klensin</a>, "<a href="http://tools.ietf.org/html/rfc4288">Media Type Specifications and Registration Procedures</a>", BCP 13, RFC 4288, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4291">[RFC4291]</b></td>
<td class="top">
<a>Hinden, R.</a> and <a>S. Deering</a>, "<a href="http://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>", RFC 4291, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5751">[RFC5751]</b></td>
<td class="top">
<a>Ramsdell, B.</a> and <a>S. Turner</a>, "<a href="http://tools.ietf.org/html/rfc5751">Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification</a>", RFC 5751, January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5761">[RFC5761]</b></td>
<td class="top">
<a>Perkins, C.</a> and <a>M. Westerlund</a>, "<a href="http://tools.ietf.org/html/rfc5761">Multiplexing RTP Data and Control Packets on a Single Port</a>", RFC 5761, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4738">[RFC4738]</b></td>
<td class="top">
<a>Ignjatic, D.</a>, <a>Dondeti, L.</a>, <a>Audet, F.</a> and <a>P. Lin</a>, "<a href="http://tools.ietf.org/html/rfc4738">MIKEY-RSA-R: An Additional Mode of Key Distribution in Multimedia Internet KEYing (MIKEY)</a>", RFC 4738, November 2006.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">23.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2068">[RFC2068]</b></td>
<td class="top">
<a href="mailto:fielding@ics.uci.edu" title="University of California, Irvine, Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="MIT Laboratory for Computer Science">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Digital Equipment Corporation, Western Research Laboratory">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="MIT Laboratory for Computer Science">Nielsen, H.</a> and <a href="mailto:timbl@w3.org" title="MIT Laboratory for Computer Science">T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2068">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2068, January 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2326">[RFC2326]</b></td>
<td class="top">
<a href="mailto:schulzrinne@cs.columbia.edu" title="Columbia University, Dept. of Computer Science">Schulzrinne, H.</a>, <a href="mailto:anup@netscape.com" title="Netscape Communications Corp.">Rao, A.</a> and <a href="mailto:robla@real.com" title="RealNetworks">R. Lanphier</a>, "<a href="http://tools.ietf.org/html/rfc2326">Real Time Streaming Protocol (RTSP)</a>", RFC 2326, April 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5888">[RFC5888]</b></td>
<td class="top">
<a>Camarillo, G.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc5888">The Session Description Protocol (SDP) Grouping Framework</a>", RFC 5888, June 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1123">[RFC1123]</b></td>
<td class="top">
<a href="mailto:Braden@ISI.EDU" title="University of Southern California (USC), Information Sciences Institute">Braden, R.</a>, "<a href="http://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and Support</a>", STD 3, RFC 1123, October 1989.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1644">[RFC1644]</b></td>
<td class="top">
<a href="mailto:Braden@ISI.EDU" title="University of Southern California,  Information Sciences Institute">Braden, B.</a>, "<a href="http://tools.ietf.org/html/rfc1644">T/TCP -- TCP Extensions for Transactions Functional Specification</a>", RFC 1644, July 1994.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4145">[RFC4145]</b></td>
<td class="top">
<a>Yon, D.</a> and <a>G. Camarillo</a>, "<a href="http://tools.ietf.org/html/rfc4145">TCP-Based Media Transport in the Session Description Protocol (SDP)</a>", RFC 4145, September 2005.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-rtsp-nat">[I-D.ietf-mmusic-rtsp-nat]</b></td>
<td class="top">
<a>Goldberg, J</a>, <a>Westerlund, M</a> and <a>T Zeng</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-rtsp-nat-11">A Network Address Translator (NAT) Traversal mechanism for media controlled by Real-Time Streaming Protocol (RTSP)</a>", Internet-Draft draft-ietf-mmusic-rtsp-nat-11, October 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2974">[RFC2974]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Perkins, C.</a> and <a>E. Whelan</a>, "<a href="http://tools.ietf.org/html/rfc2974">Session Announcement Protocol</a>", RFC 2974, October 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2663">[RFC2663]</b></td>
<td class="top">
<a href="mailto:srisuresh@lucent.com" title="Lucent Technologies">Srisuresh, P.</a> and <a href="mailto:holdrege@lucent.com" title="Lucent Technologiesv">M. Holdrege</a>, "<a href="http://tools.ietf.org/html/rfc2663">IP Network Address Translator (NAT) Terminology and Considerations</a>", RFC 2663, August 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2822">[RFC2822]</b></td>
<td class="top">
<a>Resnick, P.</a>, "<a href="http://tools.ietf.org/html/rfc2822">Internet Message Format</a>", RFC 2822, April 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3261">[RFC3261]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5905">[RFC5905]</b></td>
<td class="top">
<a>Mills, D.</a>, <a>Martin, J.</a>, <a>Burbank, J.</a> and <a>W. Kasch</a>, "<a href="http://tools.ietf.org/html/rfc5905">Network Time Protocol Version 4: Protocol and Algorithms Specification</a>", RFC 5905, June 2010.</td>
</tr>
<tr>
<td class="reference"><b id="ISO.13818-6.1995">[ISO.13818-6.1995]</b></td>
<td class="top">
<a>International Organization for Standardization</a>, "<a>Information technology - Generic coding of moving pictures and associated audio information - part 6: Extension for digital storage media and control</a>", ISO Draft Standard 13818-6, November 1995.</td>
</tr>
<tr>
<td class="reference"><b id="ISO.8601.2000">[ISO.8601.2000]</b></td>
<td class="top">
<a>International Organization for Standardization</a>, "<a>Data elements and interchange formats - Information interchange - Representation of dates and times</a>", ISO/IEC Standard 8601, December 2000.</td>
</tr>
<tr>
<td class="reference"><b id="Stevens98">[Stevens98]</b></td>
<td class="top">
<a>Stevens, W. R.</a>, "<a>Unix Networking Programming - Volume 1, second edition</a>", 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5583">[RFC5583]</b></td>
<td class="top">
<a>Schierl, T.</a> and <a>S. Wenger</a>, "<a href="http://tools.ietf.org/html/rfc5583">Signaling Media Decoding Dependency in the Session Description Protocol (SDP)</a>", RFC 5583, July 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.Appendix A">
<a href="#rfc.appendix.Appendix%20A">Appendix A.</a> <a href="#sec_examples" id="sec_examples">Examples</a>
</h1>
<p id="rfc.section.Appendix A.p.1">This section contains several different examples trying to illustrate possible ways of using RTSP. The examples can also help with the understanding of how functions of RTSP work. However, remember that these are examples and the normative and syntax description in the other sections takes precedence. Please also note that many of the example contain syntax illegal line breaks to accommodate the formatting restriction that the RFC series impose.</p>
<h1 id="rfc.appendix.Appendix A.1">
<a href="#rfc.appendix.Appendix%20A.1">Appendix A.1.</a> <a href="#sec-examples-mod-unicast" id="sec-examples-mod-unicast">Media on Demand (Unicast)</a>
</h1>
<p id="rfc.section.Appendix A.1.p.1">This is an example of media on demand streaming of a media stored in a container file. For purposes of this example, a container file is a storage entity in which multiple continuous media types pertaining to the same end-user presentation are present. In effect, the container file represents an RTSP presentation, with each of its components being RTSP controlled media streams. Container files are a widely used means to store such presentations. While the components are transported as independent streams, it is desirable to maintain a common context for those streams at the server end.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">This enables the server to keep a single storage handle open easily. It also allows treating all the streams equally in case of any priorization of streams by the server.</dd>
</dl>
<p id="rfc.section.Appendix A.1.p.3">It is also possible that the presentation author may wish to prevent selective retrieval of the streams by the client in order to preserve the artistic effect of the combined media presentation.  Similarly, in such a tightly bound presentation, it is desirable to be able to control all the streams via a single control message using an aggregate URI.</p>
<p id="rfc.section.Appendix A.1.p.4">The following is an example of using a single RTSP session to control multiple streams. It also illustrates the use of aggregate URIs. In a container file it is also desirable to not write any URI parts which is not kept, when the container is distributed, like the host and most of the path element. Therefore this example also uses the "*" and relative URI in the delivered SDP.</p>
<p id="rfc.section.Appendix A.1.p.5">Also this presentation description (SDP) is not cachable, as the Expires header is set to an equal value with date indicating immediate expiration of its valididty.</p>
<div id="#rfc.figure.90"></div>
<pre>
C-&gt;M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
      CSeq: 1
      User-Agent: PhonyClient/1.2

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Server: PhonyServer/1.0
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Content-Type: application/sdp
      Content-Length: 271
      Content-Base: rtsp://example.com/twister.3gp/
      Expires: 24 Jan 1997 15:35:06 GMT

      v=0
      o=- 2890844256 2890842807 IN IP4 198.51.100.5
      s=RTSP Session
      i=An Example of RTSP Session Usage
      e=adm@example.com
      c=IN IP4 0.0.0.0
      a=control: *
      a=range: npt=0-0:10:34.10
      t=0 0
      m=audio 0 RTP/AVP 0
      a=control: trackID=1
      m=video 0 RTP/AVP 26
      a=control: trackID=4</pre>
<div id="#rfc.figure.91"></div>
<pre>C-&gt;M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0
      CSeq: 2
      User-Agent: PhonyClient/1.2
      Require: play.basic
      Transport: RTP/AVP;unicast;dest_addr=":8000"/":8001"
      Accept-Ranges: NPT, SMPTE, UTC

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 2
      Server: PhonyServer/1.0
      Transport: RTP/AVP;unicast; ssrc=93CB001E;
                 dest_addr="192.0.2.53:8000"/"192.0.2.53:8001"; 
                 src_addr="198.51.100.5:9000"/"198.51.100.5:9001"
      Session: 12345678
      Expires: 24 Jan 1997 15:35:12 GMT
      Date: 23 Jan 1997 15:35:12 GMT
      Accept-Ranges: NPT
      Media-Properties: Random-Access=0.02, Immutable, Unlimited

C-&gt;M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Require: play.basic
      Transport: RTP/AVP;unicast;dest_addr=":8002"/":8003"
      Session: 12345678
      Accept-Ranges: NPT, SMPTE, UTC


M-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Server: PhonyServer/1.0
      Transport: RTP/AVP;unicast; ssrc=A813FC13;
                 dest_addr="192.0.2.53:8002"/"192.0.2.53:8003";
                 src_addr="198.51.100.5:9002"/"198.51.100.5:9003";
                 
      Session: 12345678
      Expires: 24 Jan 1997 15:35:13 GMT
      Date: 23 Jan 1997 15:35:13 GMT
      Accept-Range: NPT
      Media-Properties: Random-Access=0.8, Immutable, Unlimited
</pre>
<div id="#rfc.figure.92"></div>
<pre>C-&gt;M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
      CSeq: 4
      User-Agent: PhonyClient/1.2
      Range: npt=30-
      Seek-Style: RAP
      Session: 12345678

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 4
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:35:14 GMT
      Session: 12345678
      Range: npt=30-623.10
      Seek-Style: RAP
      RTP-Info: url="rtsp://example.com/twister.3gp/trackID=4"
         ssrc=0D12F123:seq=12345;rtptime=3450012,
        url="rtsp://example.com/twister.3gp/trackID=1"
         ssrc=4F312DD8:seq=54321;rtptime=2876889

C-&gt;M: PAUSE rtsp://example.com/twister.3gp/ RTSP/2.0
      CSeq: 5
      User-Agent: PhonyClient/1.2
      Session: 12345678

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 5
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:36:01 GMT
      Session: 12345678
      Range: npt=34.57-623.10

C-&gt;M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
      CSeq: 6
      User-Agent: PhonyClient/1.2
      Range: npt=34.57-623.10
      Seek-Style: Next
      Session: 12345678

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 6
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:36:01 GMT
      Session: 12345678
      Range: npt=34.57-623.10
      Seek-Style: Next
      RTP-Info: url="rtsp://example.com/twister.3gp/trackID=4"
         ssrc=0D12F123:seq=12555;rtptime=6330012,
        url="rtsp://example.com/twister.3gp/trackID=1"
         ssrc=4F312DD8:seq=55021;rtptime=3132889


C-&gt;M: TEARDOWN rtsp://example.com/twister.3gp/ RTSP/2.0
      CSeq: 7
      User-Agent: PhonyClient/1.2
      Session: 12345678

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 7
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:49:34 GMT
     </pre>
<p id="rfc.section.Appendix A.1.p.6">Client C requests a presentation from media server M. The movie is stored in a container file. The client has obtained an RTSP URI to the container file. </p>
<h1 id="rfc.appendix.Appendix A.2">
<a href="#rfc.appendix.Appendix%20A.2">Appendix A.2.</a> <a href="#sec-examples-mod-unicast-pipelining" id="sec-examples-mod-unicast-pipelining">Media on Demand using Pipelining</a>
</h1>
<p id="rfc.section.Appendix A.2.p.1">This example is basically the example above (<a href="#sec-examples-mod-unicast">Appendix Appendix A.1</a>), but now utilizing pipelining to speed up the setup. It requires only two round trip times until the media starts flowing. First of all, the session description is retrieved to determine what media resources need to be setup. In the second step, one sends the necessary SETUP requests and the PLAY request to initiate media delivery.</p>
<div id="#rfc.figure.93"></div>
<pre>
C-&gt;M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
      CSeq: 1
      User-Agent: PhonyClient/1.2

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Server: PhonyServer/1.0
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Content-Type: application/sdp
      Content-Length: 271
      Content-Base: rtsp://example.com/twister.3gp/
      Expires: 24 Jan 1997 15:35:06 GMT

      v=0
      o=- 2890844256 2890842807 IN IP4 192.0.2.5
      s=RTSP Session
      i=An Example of RTSP Session Usage
      e=adm@example.com
      c=IN IP4 0.0.0.0
      a=control: *
      a=range: npt=0-0:10:34.10
      t=0 0
      m=audio 0 RTP/AVP 0
      a=control: trackID=1
      m=video 0 RTP/AVP 26
      a=control: trackID=4

C-&gt;M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0
      CSeq: 2
      User-Agent: PhonyClient/1.2
      Require: play.basic
      Transport: RTP/AVP;unicast;dest_addr=":8000"/":8001"
      Accept-Ranges: NPT, SMPTE, UTC
      Pipelined-Requests: 7654

C-&gt;M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Require: play.basic
      Transport: RTP/AVP;unicast;dest_addr=":8002"/":8003"
      Accept-Ranges: NPT, SMPTE, UTC
      Pipelined-Requests: 7654

C-&gt;M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
      CSeq: 4
      User-Agent: PhonyClient/1.2
      Range: npt=0-
      Seek-Style: RAP
      Session: 12345678
      Pipelined-Requests: 7654

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 2
      Server: PhonyServer/1.0
      Transport: RTP/AVP;unicast;
                 dest_addr="192.0.2.53:8000"/"192.0.2.53:8001";
                 src_addr="198.51.100.5:9000"/"198.51.100.5:9001";
                 ssrc=93CB001E
      Session: 12345678
      Expires: 24 Jan 1997 15:35:12 GMT
      Date: 23 Jan 1997 15:35:12 GMT
      Accept-Ranges: NPT
      Pipelined-Requests: 7654
      Media-Properties: Random-Access=0.2, Immutable, Unlimited

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Server: PhonyServer/1.0
      Transport: RTP/AVP;unicast;
                 dest_addr="192.0.2.53:8002"/"192.0.2.53:8003;
                 src_addr="198.51.100.5:9002"/"198.51.100.5:9003";
                 ssrc=A813FC13
      Session: 12345678
      Expires: 24 Jan 1997 15:35:13 GMT
      Date: 23 Jan 1997 15:35:13 GMT
      Accept-Range: NPT
      Pipelined-Requests: 7654
      Media-Properties: Random-Access=0.8, Immutable, Unlimited

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 4
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:35:14 GMT
      Session: 12345678
      Range: npt=0-623.10
      Seek-Style: RAP
      RTP-Info: url="rtsp://example.com/twister.3gp/trackID=4"
         ssrc=0D12F123:seq=12345;rtptime=3450012,
        url="rtsp://example.com/twister.3gp/trackID=1"
         ssrc=4F312DD8:seq=54321;rtptime=2876889
      Pipelined-Requests: 7654</pre>
<p id="rfc.section.Appendix A.2.p.2">Client C requests a presentation from media server M. The movie is stored in a container file. The client has obtained an RTSP URI to the container file. </p>
<h1 id="rfc.appendix.Appendix A.3">
<a href="#rfc.appendix.Appendix%20A.3">Appendix A.3.</a> Media on Demand (Unicast)</h1>
<p id="rfc.section.Appendix A.3.p.1">An alternative example of media on demand with a bit more tweaks is the following. Client C requests a movie distributed from two different media servers A (audio.example.com) and V ( video.example.com). The media description is stored on a web server W.  The media description contains descriptions of the presentation and all its streams, including the codecs that are available, dynamic RTP payload types, the protocol stack, and content information such as language or copyright restrictions. It may also give an indication about the timeline of the movie.</p>
<div id="#rfc.figure.94"></div>
<pre>
C-&gt;W: GET /twister.sdp HTTP/1.1
      Host: www.example.com
      Accept: application/sdp

W-&gt;C: HTTP/1.0 200 OK
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Content-Type: application/sdp
      Content-Length: 278
      Expires: 23 Jan 1998 15:35:06 GMT

      v=0
      o=- 2890844526 2890842807 IN IP4 198.51.100.5
      s=RTSP Session
      e=adm@example.com
      c=IN IP4 0.0.0.0
      a=range:npt=0-1:49:34
      t=0 0
      m=audio 0 RTP/AVP 0
      a=control:rtsp://audio.example.com/twister/audio.en
      m=video 0 RTP/AVP 31
      a=control:rtsp://video.example.com/twister/video

C-&gt;A: SETUP rtsp://audio.example.com/twister/audio.en RTSP/2.0
      CSeq: 1
      User-Agent: PhonyClient/1.2
      Transport: RTP/AVP/UDP;unicast;dest_addr=":3056"/":3057",
                 RTP/AVP/TCP;unicast;interleaved=0-1
      Accept-Ranges: NPT, SMPTE, UTC

A-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Session: 12345678
      Transport: RTP/AVP/UDP;unicast;
                 dest_addr="192.0.2.53:3056"/"192.0.2.53:3057";
                 src_addr="198.51.100.5:5000"/"198.51.100.5:5001"
      Date: 23 Jan 1997 15:35:12 GMT
      Server: PhonyServer/1.0
      Expires: 24 Jan 1997 15:35:12 GMT
      Cache-Control: public
      Accept-Ranges: NPT, SMPTE
      Media-Properties: Random-Access=0.02, Immutable, Unlimited
</pre>
<div id="#rfc.figure.95"></div>
<pre>C-&gt;V: SETUP rtsp://video.example.com/twister/video RTSP/2.0
      CSeq: 1
      User-Agent: PhonyClient/1.2
      Transport: RTP/AVP/UDP;unicast;
                 dest_addr="192.0.2.53:3058"/"192.0.2.53:3059",
                 RTP/AVP/TCP;unicast;interleaved=0-1
      Accept-Ranges: NPT, SMPTE, UTC

V-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Session: 23456789
      Transport: RTP/AVP/UDP;unicast;
         dest_addr="192.0.2.53:3058"/"192.0.2.53:3059";
         src_addr="198.51.100.5:5002"/"198.51.100.5:5003"
      Date: 23 Jan 1997 15:35:12 GMT
      Server: PhonyServer/1.0
      Cache-Control: public
      Expires: 24 Jan 1997 15:35:12 GMT
      Accept-Ranges: NPT, SMPTE
      Media-Properties: Random-Access=1.2, Immutable, Unlimited

C-&gt;V: PLAY rtsp://video.example.com/twister/video RTSP/2.0
      CSeq: 2
      User-Agent: PhonyClient/1.2
      Session: 23456789
      Range: smpte=0:10:00-

V-&gt;C: RTSP/2.0 200 OK
      CSeq: 2
      Session: 23456789
      Range: smpte=0:10:00-1:49:23
      Seek-Style: First-Prior
      RTP-Info: url="rtsp://video.example.com/twister/video"
                ssrc=A17E189D:seq=12312232;rtptime=78712811
      Server: PhonyServer/2.0
      Date: 23 Jan 1997 15:35:13 GMT</pre>
<div id="#rfc.figure.96"></div>
<pre>C-&gt;A: PLAY rtsp://audio.example.com/twister/audio.en RTSP/2.0
      CSeq: 2
      User-Agent: PhonyClient/1.2
      Session: 12345678
      Range: smpte=0:10:00-

A-&gt;C: RTSP/2.0 200 OK
      CSeq: 2
      Session: 12345678
      Range: smpte=0:10:00-1:49:23
      Seek-Style: First-Prior
      RTP-Info: url="rtsp://audio.example.com/twister/audio.en"
                ssrc=3D124F01:seq=876655;rtptime=1032181
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:35:13 GMT



C-&gt;A: TEARDOWN rtsp://audio.example.com/twister/audio.en RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Session: 12345678

A-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:36:52 GMT

C-&gt;V: TEARDOWN rtsp://video.example.com/twister/video RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Session: 23456789

V-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Server: PhonyServer/2.0
      Date: 23 Jan 1997 15:36:52 GMT

</pre>
<p id="rfc.section.Appendix A.3.p.2">In this example, the client is only interested in the last part of the movie. </p>
<p id="rfc.section.Appendix A.3.p.3">Even though the audio and video track are on two different servers that may start at slightly different times and may drift with respect to each other over time, the client can perform initial synchronization of the two media using RTP-Info and Range received in the PLAY responses. If the two servers are time synchronized the RTCP packets can also be used to maintain synchronization.</p>
<h1 id="rfc.appendix.Appendix A.4">
<a href="#rfc.appendix.Appendix%20A.4">Appendix A.4.</a> Single Stream Container Files</h1>
<div id="#rfc.figure.97"></div>
<pre>
C-&gt;S: DESCRIBE rtsp://foo.example.com/test.wav RTSP/2.0
      Accept: application/x-rtsp-mh, application/sdp
      CSeq: 1
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Content-base: rtsp://foo.example.com/test.wav/
      Content-type: application/sdp
      Content-length: 163
      Server: PhonyServer/1.0
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Expires: 23 Jan 1997 17:00:00 GMT

      v=0
      o=- 872653257 872653257 IN IP4 192.0.2.5
      s=mu-law wave file
      i=audio test
      c=IN IP4 0.0.0.0
      t=0 0
      a=control: *
      m=audio 0 RTP/AVP 0
      a=control:streamid=0

</pre>
<div id="#rfc.figure.98"></div>
<pre>C-&gt;S: SETUP rtsp://foo.example.com/test.wav/streamid=0 RTSP/2.0
      Transport: RTP/AVP/UDP;unicast;
         dest_addr=":6970"/":6971";mode="PLAY"
      CSeq: 2
      User-Agent: PhonyClient/1.2
      Accept-Ranges: NPT, SMPTE, UTC

S-&gt;C: RTSP/2.0 200 OK
      Transport: RTP/AVP/UDP;unicast;
          dest_addr="192.0.2.53:6970"/"192.0.2.53:6971";
          src_addr="198.51.100.5:6970"/"198.51.100.5:6971";
          mode="PLAY";ssrc=EAB98712
      CSeq: 2
      Session: 2034820394
      Expires: 23 Jan 1997 16:00:00 GMT
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:35:07 GMT
      Accept-Ranges: NPT
      Media-Properties: Random-Acces=0.5, Immutable, Unlimited</pre>
<div id="#rfc.figure.99"></div>
<pre>

C-&gt;S: PLAY rtsp://foo.example.com/test.wav/ RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Session: 2034820394

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:35:08 GMT
      Session: 2034820394
      Range: npt=0-600
      Seek-Style: RAP
      RTP-Info: url="rtsp://foo.example.com/test.wav/streamid=0"
         ssrc=0D12F123:seq=981888;rtptime=3781123</pre>
<p id="rfc.section.Appendix A.4.p.1">Some RTSP servers may treat all files as though they are "container files", yet other servers may not support such a concept. Because of this, clients needs to use the rules set forth in the session description for Request-URIs, rather than assuming that a consistent URI may always be used throughout. Below are an example of how a multi-stream server might expect a single-stream file to be served: </p>
<p id="rfc.section.Appendix A.4.p.2">Note the different URI in the SETUP command, and then the switch back to the aggregate URI in the PLAY command. This makes complete sense when there are multiple streams with aggregate control, but is less than intuitive in the special case where the number of streams is one. However, the server has declared that the aggregated control URI in the SDP and therefore this is legal.</p>
<div id="#rfc.figure.100"></div>
<pre>
C-&gt;S: PLAY rtsp://example.com/test.wav/streamid=0 RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Session: 2034820394
</pre>
<p id="rfc.section.Appendix A.4.p.3">In this case, it is also required that servers accept implementations that use the non-aggregated interpretation and use the individual media URI, like this: </p>
<h1 id="rfc.appendix.Appendix A.5">
<a href="#rfc.appendix.Appendix%20A.5">Appendix A.5.</a> <a href="#sec_example-live-multicast" id="sec_example-live-multicast">Live Media Presentation Using Multicast</a>
</h1>
<div id="#rfc.figure.101"></div>
<pre>
C-&gt;W: GET /sessions.html HTTP/1.1
      Host: www.example.com

W-&gt;C: HTTP/1.1 200 OK
      Content-Type: text/html

      &lt;html&gt;
        ...
        &lt;a href "rtsp://live.example.com/concert/audio"&gt; 
           Streamed Live Music performance &lt;/a&gt;           
        ...
      &lt;/html&gt;

</pre>
<div id="#rfc.figure.102"></div>
<pre>C-&gt;M: DESCRIBE rtsp://live.example.com/concert/audio RTSP/2.0
      CSeq: 1
      Supported: play.basic, play.scale
      User-Agent: PhonyClient/1.2

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Content-Type: application/sdp
      Content-Length: 183
      Server: PhonyServer/1.0
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Supported: play.basic

      v=0
      o=- 2890844526 2890842807 IN IP4 192.0.2.5
      s=RTSP Session
      t=0 0
      m=audio 3456 RTP/AVP 0
      c=IN IP4 233.252.0.54/16
      a=control: rtsp://live.example.com/concert/audio
      a=range:npt=0-</pre>
<div id="#rfc.figure.103"></div>
<pre>C-&gt;M: SETUP rtsp://live.example.com/concert/audio RTSP/2.0
      CSeq: 2
      Transport: RTP/AVP;multicast;
           dest_addr="233.252.0.54:3456"/"233.252.0.54:3457";ttl=16
      Accept-Ranges: NPT, SMPTE, UTC
      User-Agent: PhonyClient/1.2

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 2
      Server: PhonyServer/1.0
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Transport: RTP/AVP;multicast;
           dest_addr="233.252.0.54:3456"/"233.252.0.54:3457";ttl=16
           ;ssrc=4D12AB92/0DF876A3
      Session: 0456804596
      Accept-Ranges: NPT, UTC
      Media-Properties: No-Seeking, Time-Progressing, Time-Duration=0

</pre>
<div id="#rfc.figure.104"></div>
<pre>C-&gt;M: PLAY rtsp://live.example.com/concert/audio RTSP/2.0
      CSeq: 3
      Session: 0456804596
      User-Agent: PhonyClient/1.2

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Server: PhonyServer/1.0
      Date: 23 Jan 1997 15:35:07 GMT
      Session: 0456804596
      Seek-Style: Next
      Range:npt=1256-
      RTP-Info: url="rtsp://live.example.com/concert/audio"
                ssrc=0D12F123:seq=1473; rtptime=80000
</pre>
<p id="rfc.section.Appendix A.5.p.1">The media server M chooses the multicast address and port. Here, it is assumed that the web server only contains a pointer to the full description, while the media server M maintains the full description.  </p>
<h1 id="rfc.appendix.Appendix A.6">
<a href="#rfc.appendix.Appendix%20A.6">Appendix A.6.</a> <a href="#sec_capability-example" id="sec_capability-example">Capability Negotiation</a>
</h1>
<div id="#rfc.figure.105"></div>
<pre>
C-&gt;S: OPTIONS rtsp://media.example.com/movie/twister.3gp RTSP/2.0
      CSeq: 1
      Supported: play.basic, play.scale
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Public: OPTIONS,SETUP,PLAY,PAUSE,TEARDOWN,DESCRIBE,GET_PARAMETER
      Allow: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN, DESCRIBE
      Server: PhonyServer/2.0
      Supported: play.basic, play.scale, com.example.flight
</pre>
<p id="rfc.section.Appendix A.6.p.1">This examples illustrate how the client and server determines their capability to support a special feature, in this case "play.scale".  The server, through the clients request and the included Supported header, learns the client supports RTSP 2.0, and also supports the playback time scaling feature of RTSP. The server's response contains the following feature related information to the client; it supports the basic media delivery functions (play.basic), the extended functionality of time scaling of content (play.scale), and one "example.com" proprietary feature (com.example.flight). The client also learns the methods supported (Public header) by the server for the indicated resource. </p>
<div id="#rfc.figure.106"></div>
<pre>
C-&gt;S: SETUP rtsp://media.example.com/twister.3gp/trackID=1 RTSP/2.0
      CSeq: 3
      User-Agent: PhonyClient/1.2
      Transport: RTP/AVP/UDP;unicast;
                 dest_addr="192.0.2.53:3056"/"192.0.2.53:3057",
                 RTP/AVP/TCP;unicast;interleaved=0-1
      Require: play.scale
      Accept-Ranges: NPT, SMPTE, UTC
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 3
      Session: 12345678
      Transport: RTP/AVP/UDP;unicast;
         dest_addr="192.0.2.53:3056"/"192.0.2.53:3057";
         src_addr="198.51.100.5:5000"/"198.51.100.5:5001"
      Server: PhonyServer/2.0
      Accept-Ranges: NPT, SMPTE
      Media-Properties: Random-Access=0.8, Immutable, Unlimited
</pre>
<p id="rfc.section.Appendix A.6.p.2">When the client sends its SETUP request it tells the server that it requires support of the play.scale feature for this session by including the Require header. </p>
<h1 id="rfc.appendix.Appendix B">
<a href="#rfc.appendix.Appendix%20B">Appendix B.</a> <a href="#sec_machine" id="sec_machine">RTSP Protocol State Machine</a>
</h1>
<p id="rfc.section.Appendix B.p.1">The RTSP session state machine describes the behavior of the protocol from RTSP session initialization through RTSP session termination.</p>
<p id="rfc.section.Appendix B.p.2">The State machine is defined on a per session basis which is uniquely identified by the RTSP session identifier. The session may contain one or more media streams depending on state. If a single media stream is part of the session it is in non-aggregated control. If two or more is part of the session it is in aggregated control.</p>
<p id="rfc.section.Appendix B.p.3">The below state machine is a informative description of the protocols behavior. In case of ambiguity with the earlier parts of this specification, the description in the earlier parts take precedence.</p>
<h1 id="rfc.appendix.Appendix B.1">
<a href="#rfc.appendix.Appendix%20B.1">Appendix B.1.</a> States</h1>
<p id="rfc.section.Appendix B.1.p.1">The state machine contains three states, described below. For each state there exist a table which shows which requests and events are allowed and whether they will result in a state change. </p>

<dl>
<dt>Init:</dt>
<dd style="margin-left: 6">Initial state no session exists.</dd>
<dt>Ready:</dt>
<dd style="margin-left: 6">Session is ready to start playing.</dd>
<dt>Play:</dt>
<dd style="margin-left: 6">Session is playing, i.e. sending media stream data in the direction S-&gt;C.</dd>
</dl>
<h1 id="rfc.appendix.Appendix B.2">
<a href="#rfc.appendix.Appendix%20B.2">Appendix B.2.</a> State variables</h1>
<p id="rfc.section.Appendix B.2.p.1">This representation of the state machine needs more than its state to work. A small number of variables are also needed and is explained below. </p>

<dl>
<dt>NRM:</dt>
<dd style="margin-left: 6">The number of media streams part of this session.</dd>
<dt>RP:</dt>
<dd style="margin-left: 6">Resume point, the point in the presentation time line at which a request to continue playing will resume from. A time format for the variable is not mandated.</dd>
</dl>
<h1 id="rfc.appendix.Appendix B.3">
<a href="#rfc.appendix.Appendix%20B.3">Appendix B.3.</a> Abbreviations</h1>
<p id="rfc.section.Appendix B.3.p.1">To make the state tables more compact a number of abbreviations are used, which are explained below. </p>

<dl>
<dt>IFI:</dt>
<dd style="margin-left: 6">IF Implemented.</dd>
<dt>md:</dt>
<dd style="margin-left: 6">Media</dd>
<dt>PP:</dt>
<dd style="margin-left: 6">Pause Point, the point in the presentation time line at which the presentation was paused.</dd>
<dt>Prs:</dt>
<dd style="margin-left: 6">Presentation, the complete multimedia presentation.</dd>
<dt>RedP:</dt>
<dd style="margin-left: 6">Redirect Point, the point in the presentation time line at which a REDIRECT was specified to occur.</dd>
<dt>SES:</dt>
<dd style="margin-left: 6">Session.</dd>
</dl>
<h1 id="rfc.appendix.Appendix B.4">
<a href="#rfc.appendix.Appendix%20B.4">Appendix B.4.</a> State Tables</h1>
<p id="rfc.section.Appendix B.4.p.1">This section contains a table for each state. The table contains all the requests and events that this state is allowed to act on. The events which is method names are, unless noted, requests with the given method in the direction client to server (C-&gt;S). In some cases there exist one or more requisite. The response column tells what type of response actions should be performed. Possible actions that is requested for an event includes: response codes, e.g. 200, headers that needs to be included in the response, setting of state variables, or setting of other session related parameters. The new state column tells which state the state machine changes to.</p>
<p id="rfc.section.Appendix B.4.p.2">The response to a valid request meeting the requisites is normally a 2xx (SUCCESS) unless other noted in the response column. The exceptions need to be given a response according to the response column. If the request does not meet the requisite, is erroneous or some other type of error occur, the appropriate response code is to be sent. If the response code is a 4xx the session state is unchanged. A response code of 3rr will result in that the session is ended and its state is changed to Init. A response code of 304 results in no state change. However, there exist restrictions to when a 3rr response may be used. A 5xx response does not result in any change of the session state, except if the error is not possible to recover from. A unrecoverable error results in the ending of the session. As it in the general case can't be determined if it was a unrecoverable error or not the client will be required to test. In the case that the next request after a 5xx is responded with 454 (Session Not Found) the client knows that the session has ended. For any request message that cannot be responded to within the time defined in <a href="#sec_connection-timeout">Section 10.4</a>, a 100 response must be sent.</p>
<p id="rfc.section.Appendix B.4.p.3">The server will timeout the session after the period of time specified in the SETUP response, if no activity from the client is detected. Therefore there exist a timeout event for all states except Init.</p>
<div id="#rfc.table.13"></div>
<div id="#tab_state-nochange"></div>
<p id="rfc.section.Appendix B.4.p.4">In the case that NRM = 1 the presentation URI is equal to the media URI or a specified presentation URI. For NRM &gt; 1 the presentation URI needs to be other than any of the medias that are part of the session. This applies to all states. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>None state-machine changing events</caption>
<thead><tr>
<th class="left">Event</th>
<th class="left">Prerequisite</th>
<th class="left">Response</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DESCRIBE</td>
<td class="left">Needs REDIRECT</td>
<td class="left">3rr, Redirect</td>
</tr>
<tr>
<td class="left">DESCRIBE</td>
<td class="left"></td>
<td class="left">200, Session description</td>
</tr>
<tr>
<td class="left">OPTIONS</td>
<td class="left">Session ID</td>
<td class="left">200, Reset session timeout timer</td>
</tr>
<tr>
<td class="left">OPTIONS</td>
<td class="left"></td>
<td class="left">200</td>
</tr>
<tr>
<td class="left">SET_PARAMETER</td>
<td class="left">Valid parameter</td>
<td class="left">200, change value of parameter</td>
</tr>
<tr>
<td class="left">GET_PARAMETER</td>
<td class="left">Valid parameter</td>
<td class="left">200, return value of parameter</td>
</tr>
</tbody>
</table>
<div id="#rfc.table.14"></div>
<div id="#tab_state-init"></div>
<p id="rfc.section.Appendix B.4.p.5">The methods in <a href="#tab_state-nochange">Table 13</a> do not have any effect on the state machine or the state variables. However, some methods do change other session related parameters, for example SET_PARAMETER which will set the parameter(s) specified in its body.  Also all of these methods that allows Session header will also update the keep-alive timer for the session. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>State: Init</caption>
<thead><tr>
<th class="left">Action</th>
<th class="left">Requisite</th>
<th class="left">New State</th>
<th class="left">Response</th>
</tr></thead>
<tbody>
<tr>
<td class="left">SETUP</td>
<td class="left"></td>
<td class="left">Ready</td>
<td class="left">NRM=1, RP=0.0</td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">Needs Redirect</td>
<td class="left">Init</td>
<td class="left">3rr Redirect</td>
</tr>
<tr>
<td class="left">S -&gt; C: REDIRECT</td>
<td class="left">No Session hdr</td>
<td class="left">Init</td>
<td class="left">Terminate all SES</td>
</tr>
</tbody>
</table>
<div id="#rfc.table.15"></div>
<div id="#tab_state-ready"></div>
<p id="rfc.section.Appendix B.4.p.6">The initial state of the state machine, see <a href="#tab_state-init">Table 14</a> can only be left by processing a correct SETUP request. As seen in the table the two state variables are also set by a correct request. This table also shows that a correct SETUP can in some cases be redirected to another URI and/or server by a 3rr response. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>State: Ready</caption>
<thead><tr>
<th class="left">Action</th>
<th class="left">Requisite</th>
<th class="left">New State</th>
<th class="left">Response</th>
</tr></thead>
<tbody>
<tr>
<td class="left">SETUP</td>
<td class="left">New URI</td>
<td class="left">Ready</td>
<td class="left">NRM +=1</td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">URI Setup prior</td>
<td class="left">Ready</td>
<td class="left">Change transport param</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">Prs URI,</td>
<td class="left">Init</td>
<td class="left">No session hdr, NRM = 0</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">md URI,NRM=1</td>
<td class="left">Init</td>
<td class="left">No Session hdr, NRM = 0</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">md URI,NRM&gt;1</td>
<td class="left">Ready</td>
<td class="left">Session hdr, NRM -= 1</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">Prs URI, No range</td>
<td class="left">Play</td>
<td class="left">Play from RP</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">Prs URI, Range</td>
<td class="left">Play</td>
<td class="left">According to range</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">md URI, NRM=1, Range</td>
<td class="left">Play</td>
<td class="left">According to range</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">md URI, NRM=1</td>
<td class="left">Play</td>
<td class="left">Play from RP</td>
</tr>
<tr>
<td class="left">PAUSE</td>
<td class="left">Prs URI</td>
<td class="left">Ready</td>
<td class="left">Return PP</td>
</tr>
<tr>
<td class="left">SC:REDIRECT</td>
<td class="left">Terminate-Reason</td>
<td class="left">Ready</td>
<td class="left">Set RedP</td>
</tr>
<tr>
<td class="left">SC:REDIRECT</td>
<td class="left">No Terminate-Reason time parameter</td>
<td class="left">Init</td>
<td class="left">Session is removed</td>
</tr>
<tr>
<td class="left">Timeout</td>
<td class="left"></td>
<td class="left">Init</td>
<td class="left"></td>
</tr>
<tr>
<td class="left">RedP reached</td>
<td class="left"></td>
<td class="left">Init</td>
<td class="left">TEARDOWN of session</td>
</tr>
</tbody>
</table>
<div id="#rfc.table.16"></div>
<div id="#tab_state-play"></div>
<p id="rfc.section.Appendix B.4.p.7">In the Ready state, see <a href="#tab_state-ready">Table 15</a>, some of the actions are depending on the number of media streams (NRM) in the session, i.e., aggregated or non-aggregated control. A SETUP request in the Ready state can either add one more media stream to the session or, if the media stream (same URI) already is part of the session, change the transport parameters. TEARDOWN is depending on both the Request-URI and the number of media stream within the session. If the Request-URI is the presentations URI the whole session is torn down.  If a media URI is used in the TEARDOWN request and more than one media exist in the session, the session will remain and a session header is returned in the response. If only a single media stream remains in the session when performing a TEARDOWN with a media URI the session is removed. The number of media streams remaining after tearing down a media stream determines the new state. </p>

<p></p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>State: Play</caption>
<thead><tr>
<th class="left">Action</th>
<th class="left">Requisite</th>
<th class="left">New State</th>
<th class="left">Response</th>
</tr></thead>
<tbody>
<tr>
<td class="left">PAUSE</td>
<td class="left">Prs URI</td>
<td class="left">Ready</td>
<td class="left">Set RP to present point</td>
</tr>
<tr>
<td class="left">End of media</td>
<td class="left">All media</td>
<td class="left">Play</td>
<td class="left">Set RP = End of media</td>
</tr>
<tr>
<td class="left">End of range</td>
<td class="left"></td>
<td class="left">Play</td>
<td class="left">Set RP = End of range</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">Prs URI, No range</td>
<td class="left">Play</td>
<td class="left">Play from present point</td>
</tr>
<tr>
<td class="left">PLAY</td>
<td class="left">Prs URI, Range</td>
<td class="left">Play</td>
<td class="left">According to range</td>
</tr>
<tr>
<td class="left">SC:PLAY_NOTIFY</td>
<td class="left"></td>
<td class="left">Play</td>
<td class="left">200</td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">New URI</td>
<td class="left">Play</td>
<td class="left">455</td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">Setuped URI</td>
<td class="left">Play</td>
<td class="left">455</td>
</tr>
<tr>
<td class="left">SETUP</td>
<td class="left">Setuped URI, IFI</td>
<td class="left">Play</td>
<td class="left">Change transport param.</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">Prs URI</td>
<td class="left">Init</td>
<td class="left">No session hdr</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">md URI,NRM=1</td>
<td class="left">Init</td>
<td class="left">No Session hdr, NRM=0</td>
</tr>
<tr>
<td class="left">TEARDOWN</td>
<td class="left">md URI</td>
<td class="left">Play</td>
<td class="left">455</td>
</tr>
<tr>
<td class="left">SC:REDIRECT</td>
<td class="left">Terminate Reason with Time parameter</td>
<td class="left">Play</td>
<td class="left">Set RedP</td>
</tr>
<tr>
<td class="left">SC:REDIRECT</td>
<td class="left"></td>
<td class="left">Init</td>
<td class="left">Session is removed</td>
</tr>
<tr>
<td class="left">RedP reached</td>
<td class="left"></td>
<td class="left">Init</td>
<td class="left">TEARDOWN of session</td>
</tr>
<tr>
<td class="left">Timeout</td>
<td class="left"></td>
<td class="left">Init</td>
<td class="left">Stop Media playout</td>
</tr>
</tbody>
</table>
<p id="rfc.section.Appendix B.4.p.8">The Play state table, see <a href="#tab_state-play">Table 16</a>, contains a number of requests that needs a presentation URI (labeled as Prs URI) to work on (i.e., the presentation URI has to be used as the Request-URI). This is due to the exclusion of non-aggregated stream control in sessions with more than one media stream.</p>
<p id="rfc.section.Appendix B.4.p.9">To avoid inconsistencies between the client and server, automatic state transitions are avoided. This can be seen at for example "End of media" event when all media has finished playing, the session still remain in Play state. An explicit PAUSE request needs to be sent to change the state to Ready. It may appear that there exist automatic transitions in "RedP reached" and "PP reached". However, they are requested and acknowledged before they take place. The time at which the transition will happen is known by looking at the range header. If the client sends a request close in time to these transitions it needs to be prepared for receiving error message, as the state may or may not have changed.</p>
<h1 id="rfc.appendix.Appendix C">
<a href="#rfc.appendix.Appendix%20C">Appendix C.</a> <a href="#sec_mediatran" id="sec_mediatran">Media Transport Alternatives</a>
</h1>
<p id="rfc.section.Appendix C.p.1">This section defines how certain combinations of protocols, profiles and lower transports are used. This includes the usage of the Transport header's source and destination address parameters "src_addr" and "dest_addr".</p>
<h1 id="rfc.appendix.Appendix C.1">
<a href="#rfc.appendix.Appendix%20C.1">Appendix C.1.</a> <a href="#sec_rtp" id="sec_rtp">RTP</a>
</h1>
<p id="rfc.section.Appendix C.1.p.1">This section defines the interaction of RTSP with respect to the RTP protocol <a href="#RFC3550">[RFC3550]</a>. It also defines any necessary media transport signalling with regards to RTP.</p>
<p id="rfc.section.Appendix C.1.p.2">The available RTP profiles and lower layer transports are described below along with rules on signalling the available combinations.</p>
<h1 id="rfc.appendix.Appendix C.1.1">
<a href="#rfc.appendix.Appendix%20C.1.1">Appendix C.1.1.</a> <a href="#sec_mediatran-rtp-avp" id="sec_mediatran-rtp-avp">AVP</a>
</h1>
<p id="rfc.section.Appendix C.1.1.p.1">The usage of the "RTP Profile for Audio and Video Conferences with Minimal Control" <a href="#RFC3551">[RFC3551]</a> when using RTP for media transport over different lower layer transport protocols is defined below in regards to RTSP.</p>
<p id="rfc.section.Appendix C.1.1.p.2">One such case is defined within this document, the use of embedded (interleaved) binary data as defined in <a href="#sec_binary">Section 14</a>. The usage of this method is indicated by include the "interleaved" parameter.</p>
<p id="rfc.section.Appendix C.1.1.p.3">When using embedded binary data the "src_addr" and "dest_addr" MUST NOT be used. This addressing and multiplexing is used as defined with use of channel numbers and the interleaved parameter.</p>
<h1 id="rfc.appendix.Appendix C.1.2">
<a href="#rfc.appendix.Appendix%20C.1.2">Appendix C.1.2.</a> AVP/UDP</h1>
<p id="rfc.section.Appendix C.1.2.p.1">This part describes sending of RTP <a href="#RFC3550">[RFC3550]</a> over lower transport layer UDP <a href="#RFC0768">[RFC0768]</a> according to the profile "RTP Profile for Audio and Video Conferences with Minimal Control" defined in RFC 3551 <a href="#RFC3551">[RFC3551]</a>. This profile requires one or two uni- or bi-directional UDP flows per media stream. The first UDP flow is for RTP and the second is for RTCP. Embedding of RTP data with the RTSP messages, in accordance with <a href="#sec_binary">Section 14</a>, SHOULD NOT be performed when RTSP messages are transported over unreliable transport protocols, like UDP <a href="#RFC0768">[RFC0768]</a>.</p>
<p id="rfc.section.Appendix C.1.2.p.2">The RTP/UDP and RTCP/UDP flows can be established using the Transport header's "src_addr", and "dest_addr" parameters.</p>
<p id="rfc.section.Appendix C.1.2.p.3">In RTSP PLAY mode, the transmission of RTP packets from client to server is unspecified. The behavior in regards to such RTP packets MAY be defined in future.</p>
<p id="rfc.section.Appendix C.1.2.p.4">The "src_addr" and "dest_addr" parameters are used in the following way for media delivery and playback mode, i.e. Mode=PLAY: </p>

<ul>
<li>The "src_addr" and "dest_addr" parameters MUST contain either 1 or 2 address specifications.</li>
<li>Each address specification for RTP/AVP/UDP or RTP/AVP/TCP MUST contain either: <ul>
<li>both an address and a port number, or</li>
<li>a port number without an address.</li>
</ul>
</li>
<li>The first address and port pair given in either of the parameters applies to the RTP stream. The second address and port pair if present applies to the RTCP stream.</li>
<li>The RTP/UDP packets from the server to the client MUST be sent to the address and port given by first address and port pair of the "dest_addr" parameter.</li>
<li>The RTCP/UDP packets from the server to the client MUST be sent to the address and port given by the second address and port pair of the "dest_addr" parameter. If no second pair is specified RTCP MUST NOT be sent.</li>
<li>The RTCP/UDP packets from the client to the server MUST be sent to the address and port given by the second address and port pair of the "src_addr" parameter. If no second pair is given RTCP MUST NOT be sent.</li>
<li>The RTP/UDP packets from the client to the server MUST be sent to the address and port given by the first address and port pair of the "src_addr" parameter.</li>
<li>RTP and RTCP Packets SHOULD be sent from the corresponding receiver port, i.e. RTCP packets from server should be sent from the "src_addr" parameters second address port pair.</li>
</ul>
<h1 id="rfc.appendix.Appendix C.1.3">
<a href="#rfc.appendix.Appendix%20C.1.3">Appendix C.1.3.</a> AVPF/UDP</h1>
<p id="rfc.section.Appendix C.1.3.p.1">The RTP profile <a href="#RFC4585">"Extended RTP Profile for RTCP-based Feedback (RTP/AVPF)"</a> <cite title="NONE">[RFC4585]</cite> MAY be used as RTP profiles in session using RTP. All that is defined for AVP MUST also apply for AVPF.</p>
<p id="rfc.section.Appendix C.1.3.p.2">The usage of AVPF is indicated by the media initialization protocol used. In the case of SDP it is indicated by media lines (m=) containing the profile RTP/AVPF. That SDP MAY also contain further AVPF related SDP attributes configuring the AVPF session regarding reporting interval and feedback messages to be used. This configuration MUST be followed.</p>
<h1 id="rfc.appendix.Appendix C.1.4">
<a href="#rfc.appendix.Appendix%20C.1.4">Appendix C.1.4.</a> SAVP/UDP</h1>
<p id="rfc.section.Appendix C.1.4.p.1">The RTP profile "The Secure Real-time Transport Protocol (SRTP)" <a href="#RFC3711">[RFC3711]</a> is an RTP profile (SAVP) that MAY be used in RTSP sessions using RTP. All that is defined for AVP MUST also apply for SAVP.</p>
<p id="rfc.section.Appendix C.1.4.p.2">The usage of SRTP requires that a security context is established. The default key-management unless otherwise signalled shall be MIKEY in RSA-R mode as defined in <a href="#sec-mikey">Appendix Appendix C.1.4.1</a>, and not according to the procedure defined in <a href="#RFC4567">"Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)"</a> <cite title="NONE">[RFC4567]</cite>. The reason is that RFC 4567 sends the initial MIKEY message in SDP, thus both requiring the usage of the DESCRIBE method and forcing the server to keep state for client performing DESCRIBE in anticipation that they might require key management.</p>
<p id="rfc.section.Appendix C.1.4.p.3">MIKEY is selected as default method for establishing SRTP cryptographic context within an RTSP session as it can be embedded in the RTSP messages, while still ensuring confidentiality of content of the keying material, even when using hop-by-hop TLS security for the RTSP messages. This method does also support pipelining of the RTSP messages.</p>
<h1 id="rfc.appendix.Appendix C.1.4.1">
<a href="#rfc.appendix.Appendix%20C.1.4.1">Appendix C.1.4.1.</a> <a href="#sec-mikey" id="sec-mikey">MIKEY Key Establishment</a>
</h1>
<p id="rfc.section.Appendix C.1.4.1.p.1">This method for using MIKEY to establish the SRTP cryptographic context is initiated in the client's SETUP request, and the servers response to the SETUP carries the MIKEY response. Thus ensuring that the crypto context establishment happens simultaneously with the establishment of the media stream being protected. By using MIKEY's <a href="#RFC4738">RSA-R mode</a> <cite title="NONE">[RFC4738]</cite> the client can be initiator and still allow the server to set the parameters in accordance with the actual media stream.</p>
<p id="rfc.section.Appendix C.1.4.1.p.2">The SRTP cryptographic context establishment is done according to the following process:</p>
<p></p>

<ol>
<li>The client determines that SAVP or SAVPF shall be used from media description format, e.g. SDP. If no other key management method is explicitly signalled, then MIKEY SHALL be used as defined here in. This specification does not specify an explicit method for indicating this SRTP cryptographic context establishment method, but future specifications may.</li>
<li>The client SHALL establish a TLS connection for RTSP messages, directly or hop by hop with the server. If hop-by-hop TLS security is used, the User method SHALL be indicated in the Accept-Credentials header. We do note that using hop-by-hop does allow the proxy to insert itself as a man in the middle also in the MIKEY exchange by providing one of its certificates, rather than the server's in the Connection-Credentials header. The client shall therefore validate the server certificate.</li>
<li>The client retrieves the servers certificate from a direct TLS connection, or if hop by hop from Connection-Credentials header. The client then checks that the server certificate is valid and belongs to server.</li>
<li>The client forms the MIKEY Initiator message using RSA-R mode in unicast mode as specified in <a href="#RFC4738">[RFC4738]</a>. The client SHOULD use the same certificate for TLS and in MIKEY to enable server to bind the two together. The client's certificate SHALL be included in the MIKEY message. The client SHALL indicate its SRTP capabilities in the message.</li>
<li>The MIKEY message from the previous step is <a href="#RFC4648">base64</a> <cite title="NONE">[RFC4648]</cite> encoded and becomes the value of the MIKEY parameter that are included in the transport specification(s) that specifies a SRTP based profile (SAVP, SAVPF) in the SETUP request.</li>
<li>Any proxy encountering the MIKEY parameter SHALL forward it without modification. A proxy requiring to understand transport specification which doesn't support SAVP/SAVPF with MIKEY will discard the whole transport specification. Most types of proxy can easily support SAVP and SAVPF with MIKEY.  If possible bypassing the proxy should be tried.</li>
<li>The server upon receiving the SETUP request, will need to decide upon the transport specification to use, if multiple are included by the client. In the determination of which transport specifications that are supported and preferred, the server should decode the MIKEY message to take the embedded SRTP parameters into account. If all transport specs require SRTP but no MIKEY parameter or other supported keying method is included, the server shall respond with 403.</li>
<li>Upon generating a response the following outcomes can occur:<ul>
<li>A transport spec not using SRTP and MIKEY is selected.  Thus the answer will not contain any MIKEY parameter.</li>
<li>A transport spec using SRTP and MIKEY is selected but an error is encountered in the MIKEY processing. In that case an RTSP error response code of 466 "Key Management Error" SHALL be used. A MIKEY message describing the error MAY be included.</li>
<li>A transport spec using SRTP and MIKEY is selected and a MIKEY response message can be created. The server SHOULD use the same certificate for TLS and in MIKEY to enable client to bind the two together. If a different certificate is used it SHALL be included in the MIKEY message. It is RECOMMENDED that the envelope key cache type is set to &#8216;Cache&#8217; and that a single envelope key is reused for all MIKEY messages to the client. That message is included in the MIKEY parameter part of the single selected transport specification in the SETUP response. The server will set the SRTP parameters as preferred for this media stream within the supported range by the client.</li>
</ul>
</li>
<li>The server transmits the SETUP response back to the client.</li>
<li>The client receives the SETUP response and if the response code indicates a successful request it decodes the MIKEY message and establish the SRTP cryptographic context from the parameters in the MIKEY response.</li>
</ol>

<p>In the above method the client's certificate may be self-signed in cases where the client's identify is not necessary to establish and the security goal is only to ensure that the RTSP signalling client is the same as the one receiving the SRTP security context.</p>
<h1 id="rfc.appendix.Appendix C.1.5">
<a href="#rfc.appendix.Appendix%20C.1.5">Appendix C.1.5.</a> SAVPF/UDP</h1>
<p id="rfc.section.Appendix C.1.5.p.1">The RTP profile "Extended Secure RTP Profile for RTCP-based Feedback (RTP/SAVPF)" <a href="#RFC5124">[RFC5124]</a> is an RTP profile (SAVPF) that MAY be used in RTSP sessions using RTP. All that is defined for AVP MUST also apply for SAVPF.</p>
<p id="rfc.section.Appendix C.1.5.p.2">The usage of SRTP requires that a cryptographic context is established. The default mechanism for establishing that security association is to use MIKEY<a href="#RFC3830">[RFC3830]</a> with RTSP as defined <a href="#sec-mikey">Appendix Appendix C.1.4.1</a>.</p>
<h1 id="rfc.appendix.Appendix C.1.6">
<a href="#rfc.appendix.Appendix%20C.1.6">Appendix C.1.6.</a> RTCP usage with RTSP</h1>
<p id="rfc.section.Appendix C.1.6.p.1">RTCP has several usages when RTP is used for media transport as explained below. Due to that RTCP MUST be supported if an RTSP agent handles RTP.</p>
<h1 id="rfc.appendix.Appendix C.1.6.1">
<a href="#rfc.appendix.Appendix%20C.1.6.1">Appendix C.1.6.1.</a> Media synchronization</h1>
<p id="rfc.section.Appendix C.1.6.1.p.1">RTCP provides media synchronization and clock drift compensation. The initial media synchronization is available from RTP-Info header. However, to be able to handle any clock drift between the media streams, RTCP is needed.</p>
<h1 id="rfc.appendix.Appendix C.1.6.2">
<a href="#rfc.appendix.Appendix%20C.1.6.2">Appendix C.1.6.2.</a> RTSP Session keep-alive</h1>
<p id="rfc.section.Appendix C.1.6.2.p.1">RTCP traffic from the RTSP client to the RTSP server MUST function as keep-alive. Which requires an RTSP server supporting RTP to use the received RTCP packets as indications that the client desires the related RTSP session to be kept alive.</p>
<h1 id="rfc.appendix.Appendix C.1.6.3">
<a href="#rfc.appendix.Appendix%20C.1.6.3">Appendix C.1.6.3.</a> Bit-rate adaption</h1>
<p id="rfc.section.Appendix C.1.6.3.p.1">RTCP Receiver reports and any additional feedback from the client MUST be used adapt the bit-rate used over the transport for all cases when RTP is sent over UDP. An RTP sender without reserved resources MUST NOT use more than its fair share of the available resources. This can be determined by comparing on short to medium term (some seconds) the used bit-rate and adapt it so that the RTP sender sends at a bit-rate comparable to what a TCP sender would achieve on average over the same path.</p>
<h1 id="rfc.appendix.Appendix C.1.6.4">
<a href="#rfc.appendix.Appendix%20C.1.6.4">Appendix C.1.6.4.</a> <a href="#sec-rtp-rtcp-mux" id="sec-rtp-rtcp-mux">RTP and RTCP Multiplexing</a>
</h1>
<p id="rfc.section.Appendix C.1.6.4.p.1">RTSP can be used to negotiate the usage of RTP and RTCP multiplexing as described in <a href="#RFC5761">[RFC5761]</a>. This allows servers and client to reduce the amount of resources required for the session by only requiring one underlying transport stream per media stream instead of two when using RTP and RTCP. This lessens the server port consumption and also the necessary state and keep-alive work when operating across <a href="#RFC2663">Network and Address Translators</a> <cite title="NONE">[RFC2663]</cite>.</p>
<p id="rfc.section.Appendix C.1.6.4.p.2">Content must be prepared with some consideration for RTP and RTCP multiplexing, mainly ensuring that the RTP payload types used does not collide with the ones used for RTCP packet types this option likely needs explicit support from the content unless the RTP payload types can be remapped by the server and that is correctly reflected in the session description. Beyond that support of this feature should come at little cost and much gain.</p>
<p id="rfc.section.Appendix C.1.6.4.p.3">It is recommended that if the content and server supports RTP and RTCP multiplexing that this is indicated in the session description, for example using the SDP attribute "a=rtcp-mux". If the SDP message contains the a=rtcp-mux attribute for a media stream, the server MUST support RTP and RTCP multiplexing. If indicated or otherwise desired by the client it can include the Transport parameter "RTCP-mux" in any transport specification where it desires to use RTCP-mux. The server will indicate if it supports RTCP-mux. Server and Client SHOULD support RTP and RTCP multiplexing.</p>
<p id="rfc.section.Appendix C.1.6.4.p.4">For capability exchange, an RTSP feature tag for RTP and RTCP multiplexing is defined: "setup.rtp.rtcp.mux".</p>
<h1 id="rfc.appendix.Appendix C.2">
<a href="#rfc.appendix.Appendix%20C.2">Appendix C.2.</a> RTP over TCP</h1>
<p id="rfc.section.Appendix C.2.p.1">Transport of RTP over TCP can be done in two ways, over independent TCP connections using RFC 4571 <a href="#RFC4571">[RFC4571]</a> or interleaved in the RTSP control connection. In both cases the protocol MUST be "rtp" and the lower layer MUST be TCP. The profile may be any of the above specified ones; AVP, AVPF, SAVP or SAVPF.</p>
<h1 id="rfc.appendix.Appendix C.2.1">
<a href="#rfc.appendix.Appendix%20C.2.1">Appendix C.2.1.</a> Interleaved RTP over TCP</h1>
<p id="rfc.section.Appendix C.2.1.p.1">The use of embedded (interleaved) binary data transported on the RTSP connection is possible as specified in <a href="#sec_binary">Section 14</a>. When using this declared combination of interleaved binary data the RTSP messages MUST be transported over TCP. TLS may or may not be used.</p>
<p id="rfc.section.Appendix C.2.1.p.2">One should, however, consider that this will result that all media streams go through any proxy. Using independent TCP connections can avoid that issue.</p>
<h1 id="rfc.appendix.Appendix C.2.2">
<a href="#rfc.appendix.Appendix%20C.2.2">Appendix C.2.2.</a> <a href="#sec_media-tcp-contrans" id="sec_media-tcp-contrans">RTP over independent TCP</a>
</h1>
<p id="rfc.section.Appendix C.2.2.p.1">In this Appendix, we describe the sending of RTP <a href="#RFC3550">[RFC3550]</a> over lower transport layer TCP <a href="#RFC0793">[RFC0793]</a> according to "Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection-Oriented Transport" <a href="#RFC4571">[RFC4571]</a>. This Appendix adapts the guidelines for using RTP over TCP within SIP/SDP <a href="#RFC4145">[RFC4145]</a> to work with RTSP.</p>
<p id="rfc.section.Appendix C.2.2.p.2">A client codes the support of RTP over independent TCP by specifying an RTP/AVP/TCP transport option without an interleaved parameter in the Transport line of a SETUP request. This transport option MUST include the "unicast" parameter.</p>
<p id="rfc.section.Appendix C.2.2.p.3">If the client wishes to use RTP with RTCP, two ports (or two address/port pairs) are specified by the dest_addr parameter. If the client wishes to use RTP without RTCP, one port (or one address/port pair) is specified by the dest_addr parameter. Ordering rules of dest_addr ports follow the rules for RTP/AVP/UDP.</p>
<p id="rfc.section.Appendix C.2.2.p.4">If the client wishes to play the active role in initiating the TCP connection, it MAY set the "setup" parameter (See <a href="#sec_Transport">Section 16.52</a>) on the Transport line to be "active", or it MAY omit the setup parameter, as active is the default. If the client signals the active role, the ports for all dest_addr values MUST be set to 9 (the discard port).</p>
<p id="rfc.section.Appendix C.2.2.p.5">If the client wishes to play the passive role in TCP connection initiation, it MUST set the "setup" parameter on the Transport line to be "passive". If the client is able to assume the active or the passive role, it MUST set the "setup" parameter on the Transport line to be "actpass". In either case, the dest_addr port value for RTP MUST be set to the TCP port number on which the client is expecting to receive the RTP stream connection, and the dest_addr port value for RTCP MUST be set to the TCP port number on which the client is expecting to receive the RTCP stream connection.</p>
<p id="rfc.section.Appendix C.2.2.p.6">If upon receipt of a non-interleaved RTP/AVP/TCP SETUP request, a server decides to accept this requested option, the 2xx reply MUST contain a Transport option that specifies RTP/AVP/TCP (without using the interleaved parameter, and with using the unicast parameter).  The dest_addr parameter value MUST be echoed from the parameter value in the client request unless the destination address (only port) was not provided in which can the server MAY include the source address of the RTSP TCP connection with the port number unchanged.</p>
<p id="rfc.section.Appendix C.2.2.p.7">In addition, the server reply MUST set the setup parameter on the Transport line, to indicate the role the server will play in the connection setup. Permissible values are "active" (if a client set "setup" to "passive" or "actpass") and "passive" (if a client set "setup" to "active" or "actpass").</p>
<p id="rfc.section.Appendix C.2.2.p.8">If a server sets "setup" to "passive", the "src_addr" in the reply MUST indicate the ports the server is willing to receive an RTP connection and (if the client requested an RTCP connection by specifying two dest_addr ports or address/port pairs) and RTCP connection. If a server sets "setup" to "active", the ports specified in "src_addr" MUST be set to 9. The server MAY use the "ssrc" parameter, following the guidance in <a href="#sec_Transport">Section 16.52</a>. Port ordering for src_addr follows the rules for RTP/AVP/UDP.</p>
<p id="rfc.section.Appendix C.2.2.p.9">Servers MUST support taking the passive role and MAY support taking the active role. Servers with a public IP address takes the passive role, thus enabling clients behind NATs and Firewalls to better chance of succesful connect to the server by actively connecting outwards. Therefore the clients are RECOMMENDED to take the active role.</p>
<p id="rfc.section.Appendix C.2.2.p.10">After sending (receiving) a 2xx reply for a SETUP method for a non-interleaved RTP/AVP/TCP media stream, the active party SHOULD initiate the TCP connection as soon as possible. The client MUST NOT send a PLAY request prior to the establishment of all the TCP connections negotiated using SETUP for the session. In case the server receives a PLAY request in a session that has not yet established all the TCP connections, it MUST respond using the 464 "Data Transport Not Ready Yet" (<a href="#sec_error464">Section 15.4.29</a>) error code.</p>
<p id="rfc.section.Appendix C.2.2.p.11">Once the PLAY request for a media resource transported over non-interleaved RTP/AVP/TCP occurs, media begins to flow from server to client over the RTP TCP connection, and RTCP packets flow bidirectionally over the RTCP TCP connection. As in the RTP/UDP case, client to server traffic on the TCP port is unspecified by this memo. The packets that travel on these connections MUST be framed using the protocol defined in <a href="#RFC4571">[RFC4571]</a>, not by the framing defined for interleaving RTP over the RTSP control connection defined in <a href="#sec_binary">Section 14</a>.</p>
<p id="rfc.section.Appendix C.2.2.p.12">A successful PAUSE request for a media being transported over RTP/AVP/TCP pauses the flow of packets over the connections, without closing the connections. A successful TEARDOWN request signals that the TCP connections for RTP and RTCP are to be closed as soon as possible.</p>
<p id="rfc.section.Appendix C.2.2.p.13">Subsequent SETUP requests on an already-SETUP RTP/AVP/TCP URI may be ambiguous in the following way: does the client wish to open up new TCP RTP and RTCP connections for the URI, or does the client wish to continue using the existing TCP RTP and RTCP connections? The client SHOULD use the "connection" parameter (defined in <a href="#sec_Transport">Section 16.52</a>) on the Transport line to make its intention clear in the regard (by setting "connection" to "new" if new connections are needed, and by setting "connection" to "existing" if the existing connections are to be used). After a 2xx reply for a SETUP request for a new connection, parties should close the pre-existing connections, after waiting a suitable period for any stray RTP or RTCP packets to arrive.</p>
<p id="rfc.section.Appendix C.2.2.p.14">The usage of SRTP, i.e. either SAVP or SAVPF profiles requires that a security association is established. The default mechanism for establishing that security association is to use MIKEY<a href="#RFC3830">[RFC3830]</a> with RTSP as defined <a href="#sec-mikey">Appendix Appendix C.1.4.1</a>.</p>
<div id="#rfc.figure.107"></div>
<pre>
   C-&gt;M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2

   M-&gt;C: RTSP/2.0 200 OK
         CSeq: 1
         Server: PhonyServer/1.0
         Date: Thu, 23 Jan 1997 15:35:06 GMT
         Content-Type: application/sdp
         Content-Length: 227
         Content-Base: rtsp://example.com/twister.3gp/
         Expires: 24 Jan 1997 15:35:06 GMT

         v=0
         o=- 2890844256 2890842807 IN IP4 198.51.100.34
         s=RTSP Session
         i=An Example of RTSP Session Usage
         e=adm@example.com
         c=IN IP4 0.0.0.0
         a=control: *
         a=range: npt=0-0:10:34.10
         t=0 0
         m=audio 0 RTP/AVP 0
         a=control: trackID=1

   C-&gt;M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0
         CSeq: 2
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/AVP/TCP;unicast;dest_addr=":9"/":9";
                    setup=active;connection=new
         Accept-Ranges: NPT, SMPTE, UTC</pre>
<div id="#rfc.figure.108"></div>
<pre>
   M-&gt;C: RTSP/2.0 200 OK
         CSeq: 2
         Server: PhonyServer/1.0
         Transport: RTP/AVP/TCP;unicast;
                    dest_addr=":9"/":9";
                    src_addr="198.51.100.5:53478"/"198.51.100:54091";
                    setup=passive;connection=new;ssrc=93CB001E
         Session: 12345678
         Expires: 24 Jan 1997 15:35:12 GMT
         Date: 23 Jan 1997 15:35:12 GMT
         Accept-Ranges: NPT
         Media-Properties: Random-Access=0.8, Immutable, Unlimited

   C-&gt;M: TCP Connection Establishment x2

   C-&gt;M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
         CSeq: 4
         User-Agent: PhonyClient/1.2
         Range: npt=30-
         Session: 12345678

   M-&gt;C: RTSP/2.0 200 OK
         CSeq: 4
         Server: PhonyServer/1.0
         Date: 23 Jan 1997 15:35:14 GMT
         Session: 12345678
         Range: npt=30-623.10
         Seek-Style: First-Prior
         RTP-Info:  url="rtsp://example.com/twister.3gp/trackID=1"
            ssrc=4F312DD8:seq=54321;rtptime=2876889
</pre>
<p id="rfc.section.Appendix C.2.2.p.15">Below, we rewrite part of the example media on demand example shown in <a href="#sec-examples-mod-unicast">Appendix Appendix A.1</a> to use RTP/AVP/TCP non-interleaved: </p>
<h1 id="rfc.appendix.Appendix C.3">
<a href="#rfc.appendix.Appendix%20C.3">Appendix C.3.</a> Handling Media Clock Time Jumps in the RTP Media Layer</h1>
<p id="rfc.section.Appendix C.3.p.1">RTSP allows media clients to control selected, non-contiguous sections of media presentations, rendering those streams with an <a href="#RFC3550">RTP media layer</a> <cite title="NONE">[RFC3550]</cite>. Two cases occur, the first is when a new PLAY request replaces an old ongoing request and the new request results in a jump in the media. This should produce in the RTP layer a continuous media stream. A client may also directly following a completed PLAY request perform a new PLAY request. This will result in some gap in the media layer. The below text will look into both cases.</p>
<p id="rfc.section.Appendix C.3.p.2">A PLAY request that replaces a ongoing request allows the media layer rendering the RTP stream without being affected by jumps in media clock time. The RTP timestamps for the new media range is set so that they become continuous with the previous media range in the previous request. The RTP sequence number for the first packet in the new range will be the next following the last packet in the previous range, i.e. monotonically increasing. The goal is to allow the media rendering layer to work without interruption or reconfiguration across the jumps in media clock. This should be possible in all cases of replaced PLAY requests for media that has random-access properties. In this case care is needed to align frames or similar media dependent structures.</p>
<p id="rfc.section.Appendix C.3.p.3">In cases where jumps in media clock time are a result of RTSP signalling operations arriving after a completed PLAY operation, the request timing will result in that media becomes non-continuous. The server becomes unable to send the media so that it arrive timely and still carry timestamps to make the media stream continuous. In these cases the server will produce RTP streams where there are gaps in the RTP timeline for the media. In such cases, if the media has frame structure, aligning the timestamp for the next frame with the previous structure reduces the burden to render this media. The gap should represent the time the server hasn't been serving media, e.g. the time between the end of the media stream or a PAUSE request and the new PLAY request. In these cases the RTP sequence number would normally be monotonically increasing across the gap.</p>
<p id="rfc.section.Appendix C.3.p.4">For RTSP sessions with media that lacks random access properties, like live streams, any media clock jump is commonly result of correspondingly long pause of delivery. The RTP timestamp will have increased in direct proportion to the duration of the paused delivery.  Note also that in this case the RTP sequence number should be the next packet number. If not, the RTCP packet loss reporting will indicate as loss all packets not received between the point of pausing and later resuming. This may trigger congestion avoidance mechanisms. An allowed exception from the above recommendation on monotonically increasing RTP sequence number is live media streams, likely being relayed. In this case, when the client resumes delivery, it will get the media that is currently being delivered to the server itself. For this type of basic delivery of live streams to multiple users over unicast, individual rewriting of RTP sequence numbers becomes quite a burden.  For solutions that anyway caches media, timeshifts, etc, the rewriting should be a minor issue.</p>
<p id="rfc.section.Appendix C.3.p.5">The goal when handling jumps in media clock time is that the provided stream is continuous without gaps in RTP timestamp or sequence number. However, when delivery has been halted for some reason the RTP timestamp when resuming MUST represent the duration the delivery was halted. RTP sequence number MUST generally be the next number, i.e. monotonically increasing modulo 65536. For media resources with the properties Time-Progressing and Time-Duration=0.0 the server MAY create RTP media streams with RTP sequence number jumps in them due to client first halting delivery and later resuming it (PAUSE and then later PLAY). However, servers utilizing this exception must take into consideration the resulting RTCP receiver reports that likely contains loss report for all the packets part of the discontinuity. A client can not rely on that a server will align when resuming playing even if it is RECOMMENDED. The RTP-Info header will provide information on how the server acts in each case.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">We cannot assume that the RTSP client can communicate with the RTP media agent, as the two may be independent processes. If the RTP timestamp shows the same gap as the NPT, the media agent will assume that there is a pause in the presentation. If the jump in NPT is large enough, the RTP timestamp may roll over and the media agent may believe later packets to be duplicates of packets just played out. Having the RTP timestamp jump will also affect the RTCP measurements based on this.</dd>
</dl>
<div id="#rfc.figure.109"></div>
<pre>
   C-&gt;S: PLAY rtsp://example.com/fizzle RTSP/2.0
     CSeq: 4
     Session: abcdefgh
     Range: npt=10-15
     User-Agent: PhonyClient/1.2

   S-&gt;C: RTSP/2.0 200 OK
     CSeq: 4
     Session: abcdefgh
     Range: npt=10-15
     RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
               ssrc=0D12F123:seq=0;rtptime=0
</pre>
<p id="rfc.section.Appendix C.3.p.7">As an example, assume a RTP timestamp frequency of 8000 Hz, a packetization interval of 100 ms and an initial sequence number and timestamp of zero. </p>
<div id="#rfc.figure.110"></div>
<pre>

   S -&gt; C: RTP packet - seq = 0,  rtptime = 0,     NPT time = 10s
   S -&gt; C: RTP packet - seq = 1,  rtptime = 800,   NPT time = 10.1s
    . . .
   S -&gt; C: RTP packet - seq = 49, rtptime = 39200, NPT time = 14.9s

</pre>
<p id="rfc.section.Appendix C.3.p.8">The ensuing RTP data stream is depicted below: </p>
<p id="rfc.section.Appendix C.3.p.9">Upon the completion of the requested delivery the server sends a PLAY_NOTIFY</p>
<div id="#rfc.figure.111"></div>
<pre>     S-&gt;C: PLAY_NOTIFY rtsp://example.com/fizzle RTSP/2.0
           CSeq: 5
           Notify-Reason: end-of-stream
           Request-Status: cseq=4 status=200 reason="OK"
           Range: npt=-15
           RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
              ssrc=0D12F123:seq=49;rtptime=39200
           Session: abcdefgh

     C-&gt;S: RTSP/2.0 200 OK
           CSeq: 5
           User-Agent: PhonyClient/1.2
</pre>
<div id="#rfc.figure.112"></div>
<pre>
C-&gt;S: PLAY rtsp://example.com/fizzle RTSP/2.0
      CSeq: 6
      Session: abcdefg
      Range: npt=18-20
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 6
      Session: abcdefg
      Range: npt=18-20
      RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=50;rtptime=40100</pre>
<p></p>
<div id="#rfc.figure.113"></div>
<pre>
   S-&gt;C: RTP packet - seq = 50, rtptime = 40100, NPT time = 18s
   S-&gt;C: RTP packet - seq = 51, rtptime = 40900, NPT time = 18.1s
    . . .
   S-&gt;C: RTP packet - seq = 69, rtptime = 55300, NPT time = 19.9s
</pre>
<p id="rfc.section.Appendix C.3.p.11">The ensuing RTP data stream is depicted below: </p>
<p id="rfc.section.Appendix C.3.p.12">In this example, first, NPT 10 through 15 is played, then the client request the server to skip ahead and play NPT 18 through 20.  The first segment is presented as RTP packets with sequence numbers 0 through 49 and timestamp 0 through 39,200. The second segment consists of RTP packets with sequence number 50 through 69, with timestamps 40,100 through 55,200. While there is a gap in the NPT, there is no gap in the sequence number space of the RTP data stream.</p>
<p id="rfc.section.Appendix C.3.p.13">The RTP timestamp gap is present in the above example due to the time it takes to perform the second play request, in this case 12.5 ms (100/8000).</p>
<h1 id="rfc.appendix.Appendix C.4">
<a href="#rfc.appendix.Appendix%20C.4">Appendix C.4.</a> Handling RTP Timestamps after PAUSE</h1>
<p id="rfc.section.Appendix C.4.p.1">During a PAUSE / PLAY interaction in an RTSP session, the duration of time for which the RTP transmission was halted MUST be reflected in the RTP timestamp of each RTP stream. The duration can be calculated for each RTP stream as the time elapsed from when the last RTP packet was sent before the PAUSE request was received and when the first RTP packet was sent after the subsequent PLAY request was received. The duration includes all latency incurred and processing time required to complete the request.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The RTP RFC <a href="#RFC3550">[RFC3550]</a> states that: The RTP timestamp for each unit [packet] would be related to the wallclock time at which the unit becomes current on the virtual presentation timeline.</dd>
<dt></dt>
<dd style="margin-left: 8">In order to satisfy the requirements of <a href="#RFC3550">[RFC3550]</a>, the RTP timestamp space needs to increase continuously with real time. While this is not optimal for stored media, it is required for RTP and RTCP to function as intended. Using a continuous RTP timestamp space allows the same timestamp model for both stored and live media and allows better opportunity to integrate both types of media under a single control.</dd>
</dl>
<div id="#rfc.figure.114"></div>
<pre>
C-&gt;S: PLAY rtsp://example.com/fizzle RTSP/2.0
      CSeq: 4
      Session: abcdefg
      Range: npt=10-15</pre>
<div id="#rfc.figure.115"></div>
<pre>      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 4
      Session: abcdefg
      Range: npt=10-15
      RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=0;rtptime=0
</pre>
<p id="rfc.section.Appendix C.4.p.3">As an example, assume a clock frequency of 8000 Hz, a packetization interval of 100 ms and an initial sequence number and timestamp of zero. </p>
<div id="#rfc.figure.116"></div>
<pre>
   S -&gt; C: RTP packet - seq = 0, rtptime = 0,    NPT time = 10s
   S -&gt; C: RTP packet - seq = 1, rtptime = 800,  NPT time = 10.1s
   S -&gt; C: RTP packet - seq = 2, rtptime = 1600, NPT time = 10.2s
   S -&gt; C: RTP packet - seq = 3, rtptime = 2400, NPT time = 10.3s
</pre>
<p id="rfc.section.Appendix C.4.p.4">The ensuing RTP data stream is depicted below: </p>
<div id="#rfc.figure.117"></div>
<pre>
C-&gt;S: PAUSE rtsp://example.com/fizzle RTSP/2.0
      CSeq: 5
      Session: abcdefg
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 5
      Session: abcdefg
      Range: npt=10.4-15</pre>
<p id="rfc.section.Appendix C.4.p.5">The client then sends a PAUSE request: </p>
<div id="#rfc.figure.118"></div>
<pre>
C-&gt;S: PLAY rtsp://example.com/fizzle RTSP/2.0
      CSeq: 6
      Session: abcdefg
      User-Agent: PhonyClient/1.2

S-&gt;C: RTSP/2.0 200 OK
      CSeq: 6
      Session: abcdefg
      Range: npt=10.4-15
      RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                ssrc=0D12F123:seq=4;rtptime=164400</pre>
<p id="rfc.section.Appendix C.4.p.6">20 seconds elapse and then the client sends a PLAY request. In addition the server requires 15 ms to process the request: </p>
<div id="#rfc.figure.119"></div>
<pre>
   S -&gt; C: RTP packet - seq = 4, rtptime = 164400, NPT time = 10.4s
   S -&gt; C: RTP packet - seq = 5, rtptime = 165200, NPT time = 10.5s
   S -&gt; C: RTP packet - seq = 6, rtptime = 166000, NPT time = 10.6s</pre>
<p id="rfc.section.Appendix C.4.p.7">The ensuing RTP data stream is depicted below: </p>
<p id="rfc.section.Appendix C.4.p.8">First, NPT 10 through 10.3 is played, then a PAUSE is received by the server. After 20 seconds a PLAY is received by the server which take 15ms to process. The duration of time for which the session was paused is reflected in the RTP timestamp of the RTP packets sent after this PLAY request.</p>
<p id="rfc.section.Appendix C.4.p.9">A client can use the RTSP range header and RTP-Info header to map NPT time of a presentation with the RTP timestamp.</p>
<p id="rfc.section.Appendix C.4.p.10">Note: In RFC 2326 <a href="#RFC2326">[RFC2326]</a>, this matter was not clearly defined and was misunderstood commonly. However, for RTSP 2.0 it is expected that this will be handled correctly and no exception handling will be required.</p>
<p id="rfc.section.Appendix C.4.p.11">Note Further: To ensure correct media decoding and usually jitter-buffer handling reseting some of the state when issuing a PLAY request is needed.</p>
<h1 id="rfc.appendix.Appendix C.5">
<a href="#rfc.appendix.Appendix%20C.5">Appendix C.5.</a> RTSP / RTP Integration</h1>
<p id="rfc.section.Appendix C.5.p.1">For certain datatypes, tight integration between the RTSP layer and the RTP layer will be necessary. This by no means precludes the above restrictions. Combined RTSP/RTP media clients should use the RTP-Info field to determine whether incoming RTP packets were sent before or after a seek or before or after a PAUSE.</p>
<h1 id="rfc.appendix.Appendix C.6">
<a href="#rfc.appendix.Appendix%20C.6">Appendix C.6.</a> Scaling with RTP</h1>
<p id="rfc.section.Appendix C.6.p.1">For scaling (see <a href="#sec_Scale">Section 16.44</a>), RTP timestamps should correspond to the rendering timing. For example, when playing video recorded at 30 frames/second at a scale of two and speed (<a href="#sec_Speed">Section 16.48</a>) of one, the server would drop every second frame to maintain and deliver video packets with the normal timestamp spacing of 3,000 per frame, but NPT would increase by 1/15 second for each video frame.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: The above scaling puts requirements on the media codec or a media stream to support it. For example motion JPEG or other non-predictive video coding can easier handle the above example.</dd>
</dl>
<h1 id="rfc.appendix.Appendix C.7">
<a href="#rfc.appendix.Appendix%20C.7">Appendix C.7.</a> Maintaining NPT synchronization with RTP timestamps</h1>
<p id="rfc.section.Appendix C.7.p.1">The client can maintain a correct display of NPT (Normal Play Time) by noting the RTP timestamp value of the first packet arriving after repositioning. The sequence parameter of the RTP-Info (<a href="#sec_RTP-Info">Section 16.43</a>) header provides the first sequence number of the next segment.</p>
<h1 id="rfc.appendix.Appendix C.8">
<a href="#rfc.appendix.Appendix%20C.8">Appendix C.8.</a> Continuous Audio</h1>
<p id="rfc.section.Appendix C.8.p.1">For continuous audio, the server SHOULD set the RTP marker bit at the beginning of serving a new PLAY request or at jumps in timeline.  This allows the client to perform playout delay adaptation.</p>
<h1 id="rfc.appendix.Appendix C.9">
<a href="#rfc.appendix.Appendix%20C.9">Appendix C.9.</a> Multiple Sources in an RTP Session</h1>
<p id="rfc.section.Appendix C.9.p.1">Note that more than one SSRC MAY be sent in the media stream. If it happens all sources are expected to be rendered simultaneously.</p>
<h1 id="rfc.appendix.Appendix C.10">
<a href="#rfc.appendix.Appendix%20C.10">Appendix C.10.</a> Usage of SSRCs and the RTCP BYE Message During an RTSP Session</h1>
<p id="rfc.section.Appendix C.10.p.1">The RTCP BYE message indicates the end of use of a given SSRC. If all sources leave an RTP session, it can, in most cases, be assumed to have ended. Therefore, a client or server MUST NOT send a RTCP BYE message until it has finished using a SSRC. A server SHOULD keep using a SSRC until the RTP session is terminated. Prolonging the use of a SSRC allows the established synchronization context associated with that SSRC to be used to synchronize subsequent PLAY requests even if the PLAY response is late.</p>
<p id="rfc.section.Appendix C.10.p.2">An SSRC collision with the SSRC that transmits media does also have consequences, as it will normally force the media sender to change its SSRC in accordance with the RTP specification<a href="#RFC3550">[RFC3550]</a>. However, a RTSP server may wait and see if the client changes and thus resolve the conflict to minimize the impact. As media sender SSRC change will result in a loss of synchronization context, and require any receiver to wait for RTCP sender reports for all media requiring synchronization before being able to play out synchronized. Due to these reasons a client joining a session should take care to not select the same SSRC(s) as the server indicates in the ssrc Transport header parameter. Any SSRC signalled in the Transport header MUST be avoided. A client detecting a collision prior to sending any RTP or RTCP messages SHALL also select a new SSRC.</p>
<h1 id="rfc.appendix.Appendix C.11">
<a href="#rfc.appendix.Appendix%20C.11">Appendix C.11.</a> Future Additions</h1>
<p id="rfc.section.Appendix C.11.p.1">It is the intention that any future protocol or profile regarding both for media delivery and lower transport should be easy to add to RTSP. This section provides the necessary steps that needs to be meet.</p>
<p id="rfc.section.Appendix C.11.p.2">The following things needs to be considered when adding a new protocol or profile for use with RTSP: </p>

<ul>
<li>The protocol or profile needs to define a name tag representing it. This tag is required to be a ABNF "token" to be possible to use in the Transport header specification.</li>
<li>The useful combinations of protocol, profiles and lower layer transport for this extension needs to be defined. For each combination declare the necessary parameters to use in the Transport header.</li>
<li>For new media protocols the interaction with RTSP needs to be addressed. One important factor will be the media synchronization.  May need new headers similar to RTP info to carry information.</li>
<li>Discuss congestion control for media, especially if transport without built in congestion control is used.</li>
</ul>
<p id="rfc.section.Appendix C.11.p.3">See the IANA section (<a href="#sec_IANA">Section 22</a>) for information how to register new attributes.</p>
<h1 id="rfc.appendix.Appendix D">
<a href="#rfc.appendix.Appendix%20D">Appendix D.</a> <a href="#sec_sdpusage" id="sec_sdpusage">Use of SDP for RTSP Session Descriptions</a>
</h1>
<p id="rfc.section.Appendix D.p.1">The Session Description Protocol (SDP, <a href="#RFC4566">[RFC4566]</a>) may be used to describe streams or presentations in RTSP. This description is typically returned in reply to a DESCRIBE request on an URI from a server to a client, or received via HTTP from a server to a client.</p>
<p id="rfc.section.Appendix D.p.2">This appendix describes how an SDP file determines the operation of an RTSP session. SDP as is provides no mechanism by which a client can distinguish, without human guidance, between several media streams to be rendered simultaneously and a set of alternatives (e.g., two audio streams spoken in different languages). The SDP extension "Grouping of Media Lines in the Session Description Protocol (SDP)" <a href="#RFC5888">[RFC5888]</a> provides such functionality to some degree.  <a href="#sec_sdp_m_grouping">Appendix Appendix D.4</a> describes the usage of SDP media line grouping for RTSP.</p>
<h1 id="rfc.appendix.Appendix D.1">
<a href="#rfc.appendix.Appendix%20D.1">Appendix D.1.</a> Definitions</h1>
<p id="rfc.section.Appendix D.1.p.1">The terms "session-level", "media-level" and other key/attribute names and values used in this appendix are to be used as defined in SDP<a href="#RFC4566">[RFC4566]</a>:</p>
<h1 id="rfc.appendix.Appendix D.1.1">
<a href="#rfc.appendix.Appendix%20D.1.1">Appendix D.1.1.</a> <a href="#sec_sdp-control-url" id="sec_sdp-control-url">Control URI</a>
</h1>
<p id="rfc.section.Appendix D.1.1.p.1">The "a=control:" attribute is used to convey the control URI.  This attribute is used both for the session and media descriptions.  If used for individual media, it indicates the URI to be used for controlling that particular media stream. If found at the session level, the attribute indicates the URI for aggregate control (presentation URI). The session level URI MUST be different from any media level URI. The presence of a session level control attribute MUST be interpreted as support for aggregated control. The control attribute MUST be present on media level unless the presentation only contains a single media stream, in which case the attribute MAY only be present on the session level and then also apply to that single media level.</p>
<p id="rfc.section.Appendix D.1.1.p.2">ABNF for the attribute is defined in <a href="#sec_sdp-syntax">Section 20.3</a>.</p>
<div id="#rfc.figure.120"></div>
<pre>  a=control:rtsp://example.com/foo</pre>
<p id="rfc.section.Appendix D.1.1.p.3">Example: </p>
<p id="rfc.section.Appendix D.1.1.p.4">This attribute MAY contain either relative or absolute URIs, following the rules and conventions set out in RFC 3986 <a href="#RFC3986">[RFC3986]</a>. Implementations MUST look for a base URI in the following order: </p>

<ol>
<li>the RTSP Content-Base field;</li>
<li>the RTSP Content-Location field;</li>
<li>the RTSP Request-URI.</li>
</ol>

<p>If this attribute contains only an asterisk (*), then the URI MUST be treated as if it were an empty embedded URI, and thus inherit the entire base URI.</p>
<p><a href="#RFC3986">[RFC3986]</a> to the above given media URI is: "container.mp4/trackID=2". It is usually not desirable to need to include in or modify the SDP stored within the container file with the server local name of the container file. To avoid this, one can modify the base URI used to include a trailing slash, e.g.  "rtsp://example.com/container.mp4/". In this case the relative URI for the media will only need to be: "trackID=2". However, this will also mean that using "*" in the SDP will result in control URI including the trailing slash, i.e.  "rtsp://example.com/container.mp4/".</p>

<ul class="empty"><li>Note, RFC 2326 was very unclear on the processing of relative URI and several RTSP 1.0 implementations at the point of publishing this document did not perform RFC 3986 processing to determine the resulting URI, instead simple concatenation is common. To avoid this issue completely it is recommended to use absolute URI in the SDP.</li></ul>

<p>The URI handling for SDPs from container files need special consideration. For example lets assume that a container file has the URI: "rtsp://example.com/container.mp4". Lets further assume this URI is the base URI, and that there is a absolute media level URI: "rtsp://example.com/container.mp4/trackID=2". A relative media level URI that resolves in accordance with RFC 3986 </p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Note: The usage of TrackID in the above is not an standardized form, but one example out of several similar strings such as TrackID, Track_ID, StreamID that is used by different server vendors to indicate a particular piece of media inside a container file.</dd>
</dl>
<h1 id="rfc.appendix.Appendix D.1.2">
<a href="#rfc.appendix.Appendix%20D.1.2">Appendix D.1.2.</a> Media Streams</h1>
<p id="rfc.section.Appendix D.1.2.p.1">The "m=" field is used to enumerate the streams. It is expected that all the specified streams will be rendered with appropriate synchronization. If the session is over multicast, the port number indicated SHOULD be used for reception. The client MAY try to override the destination port, through the Transport header. The servers MAY allow this, the response will indicate if allowed or not. If the session is unicast, the port numbers are the ones RECOMMENDED by the server to the client, about which receiver ports to use; the client MUST still include its receiver ports in its SETUP request. The client MAY ignore this recommendation. If the server has no preference, it SHOULD set the port number value to zero.</p>
<p id="rfc.section.Appendix D.1.2.p.2">The "m=" lines contain information about which transport protocol, profile, and possibly lower-layer is to be used for the media stream. The combination of transport, profile and lower layer, like RTP/AVP/UDP needs to be defined for how to be used with RTSP.  The currently defined combinations are defined in <a href="#sec_mediatran">Appendix Appendix C</a>, further combinations MAY be specified.</p>
<div id="#rfc.figure.121"></div>
<pre>  m=audio 0 RTP/AVP 31
</pre>
<p id="rfc.section.Appendix D.1.2.p.3">Example: </p>
<h1 id="rfc.appendix.Appendix D.1.3">
<a href="#rfc.appendix.Appendix%20D.1.3">Appendix D.1.3.</a> Payload Type(s)</h1>
<p id="rfc.section.Appendix D.1.3.p.1">The payload type(s) are specified in the "m=" line. In case the payload type is a static payload type from RFC 3551 <a href="#RFC3551">[RFC3551]</a>, no other information may be required. In case it is a dynamic payload type, the media attribute "rtpmap" is used to specify what the media is. The "encoding name" within the "rtpmap" attribute may be one of those specified in RFC 3551 (Sections 5 and 6), or an MIME type registered with IANA, or an experimental encoding as specified in SDP (RFC 4566 <a href="#RFC4566">[RFC4566]</a>). Codec-specific parameters are not specified in this field, but rather in the "fmtp" attribute described below.</p>
<p id="rfc.section.Appendix D.1.3.p.2">The selection of the RTP payload type numbers used may be required to consider <a href="#RFC5761">RTP and RTCP Multiplexing</a> <cite title="NONE">[RFC5761]</cite> if that is to be supported by the server.</p>
<h1 id="rfc.appendix.Appendix D.1.4">
<a href="#rfc.appendix.Appendix%20D.1.4">Appendix D.1.4.</a> Format-Specific Parameters</h1>
<p id="rfc.section.Appendix D.1.4.p.1">Format-specific parameters are conveyed using the "fmtp" media attribute. The syntax of the "fmtp" attribute is specific to the encoding(s) that the attribute refers to. Note that some of the format specific parameters may be specified outside of the fmtp parameters, like for example the "ptime" attribute for most audio encodings.</p>
<h1 id="rfc.appendix.Appendix D.1.5">
<a href="#rfc.appendix.Appendix%20D.1.5">Appendix D.1.5.</a> <a href="#sec_sdp-direction" id="sec_sdp-direction">Directionality of media stream</a>
</h1>
<p id="rfc.section.Appendix D.1.5.p.1">The SDP attributes "a=sendrecv", "a=recvonly" and "a=sendonly" provides instructions on which direction the media streams flow within a session. When using RTSP the SDP can be delivered to a client using either RTSP DESCRIBE or a number of RTSP external methods, like HTTP, FTP, and email. Based on this the SDP applies to how the RTSP client will see the complete session. Thus for media streams delivered from the RTSP server to the client would be given the "a=recvonly" attribute.</p>
<p id="rfc.section.Appendix D.1.5.p.2">The direction attributes are not commonly used in SDPs for RTSP, but may occur. "a=recvonly" in a SDP provided to the RTSP client MUST indicate that media delivery will only occur in the direction from the RTSP server to the client. In SDP provided to the RTSP client that lacks any of the directionality attributes (a=recvonly, a=sendonly, a=sendrecv) MUST behave as if the "a=recvonly" attribute was received. Note that this overrules the normal default rule defined in SDP<a href="#RFC4566">[RFC4566]</a>. The usage of "a=sendonly" or "a=sendrecv" is not defined, nor is the interpretation of SDP by other entities than the RTSP client.</p>
<h1 id="rfc.appendix.Appendix D.1.6">
<a href="#rfc.appendix.Appendix%20D.1.6">Appendix D.1.6.</a> <a href="#sec_sdp-range" id="sec_sdp-range">Range of Presentation</a>
</h1>
<p id="rfc.section.Appendix D.1.6.p.1">The "a=range" attribute defines the total time range of the stored session or an individual media. Non-seekable live sessions can be indicated as specified below, while the length of live sessions can be deduced from the "t" and "r" SDP parameters.</p>
<p id="rfc.section.Appendix D.1.6.p.2">The attribute is both a session and a media level attribute. For presentations that contains media streams of the same durations, the range attribute SHOULD only be used at session-level. In case of different length the range attribute MUST be given at media level for all media, and SHOULD NOT be given at session level. If the attribute is present at both media level and session level the media level values MUST be used.</p>
<p id="rfc.section.Appendix D.1.6.p.3">Note: Usually one will specify the same length for all media, even if there isn't media available for the full duration on all media. However, that requires that the server accepts PLAY requests within that range.</p>
<p id="rfc.section.Appendix D.1.6.p.4">Servers MUST take care to provide RTSP Range (see <a href="#sec_Range">Section 16.38</a>) values that are consistent with what is presented in the SDP for the content. There is no reason for non dynamic content, like media clips provided on demand to have inconsistent values. Inconsistent values between the SDP and the actual values for the content handled by the server is likely to generate some failure, like 457 "Invalid Range", in case the client uses PLAY requests with a Range header. In case the content is dynamic in length and it is infeasible to provide a correct value in the SDP the server is recommended to describe this as non-seekable content (see below). The server MAY override that property in the response to a PLAY request using the correct values in the Range header.</p>
<p id="rfc.section.Appendix D.1.6.p.5">The unit is specified first, followed by the value range. The units and their values are as defined in <a href="#sec_smpte">Section 4.4</a>, <a href="#sec_npt">Section 4.5</a> and <a href="#sec_clock">Section 4.6</a> and MAY be extended with further formats.  Any open ended range (start-), i.e. without stop range, is of unspecified duration and MUST be considered as non-seekable content unless this property is overridden. Multiple instances carrying different clock formats MAY be included at either session or media level.</p>
<p id="rfc.section.Appendix D.1.6.p.6">ABNF for the attribute is defined in <a href="#sec_sdp-syntax">Section 20.3</a>.</p>
<div id="#rfc.figure.122"></div>
<pre>  a=range:npt=0-34.4368
  a=range:clock=19971113T211503Z-19971113T220300Z
  Non seekable stream of unknown duration:
  a=range:npt=0-
</pre>
<p id="rfc.section.Appendix D.1.6.p.7">Examples: </p>
<h1 id="rfc.appendix.Appendix D.1.7">
<a href="#rfc.appendix.Appendix%20D.1.7">Appendix D.1.7.</a> Time of Availability</h1>
<p id="rfc.section.Appendix D.1.7.p.1">The "t=" field defines when the SDP is valid. For on-demand content the server SHOULD indicate a stop time value for which it guarantees the description to be valid, and a start time that is equal to or before the time at which the DESCRIBE request was received. It MAY also indicate start and stop times of 0, meaning that the session is always available.</p>
<p id="rfc.section.Appendix D.1.7.p.2">For sessions that are of live type, i.e. specific start time, unknown stop time, likely unseekable, the "t=" and "r=" field SHOULD be used to indicate the start time of the event. The stop time SHOULD be given so that the live event will have ended at that time, while still not be unnecessary long into the future.</p>
<h1 id="rfc.appendix.Appendix D.1.8">
<a href="#rfc.appendix.Appendix%20D.1.8">Appendix D.1.8.</a> Connection Information</h1>
<p id="rfc.section.Appendix D.1.8.p.1">In SDP, the "c=" field contains the destination address for the media stream. If a multicast address is specified the client SHOULD use this address in any SETUP request as destination address, including any additional parameters, such as TTL. For on-demand unicast streams and some multicast streams, the destination address MAY be specified by the client via the SETUP request, thus overriding any specified address. To identify streams without a fixed destination address, where the client is required to specify a destination address, the "c=" field SHOULD be set to a null value.  For addresses of type "IP4", this value MUST be "0.0.0.0", and for type "IP6", this value MUST be "0:0:0:0:0:0:0:0" (can also be written as "::"), i.e. the unspecified address according to RFC 4291 <a href="#RFC4291">[RFC4291]</a>.</p>
<h1 id="rfc.appendix.Appendix D.1.9">
<a href="#rfc.appendix.Appendix%20D.1.9">Appendix D.1.9.</a> <a href="#sec_sdp-mtag" id="sec_sdp-mtag">Message Body Tag</a>
</h1>
<p id="rfc.section.Appendix D.1.9.p.1">The optional "a=mtag" attribute identifies a version of the session description. It is opaque to the client. SETUP requests may include this identifier in the If-Match field (see <a href="#sec_If-Match">Section 16.23</a>) to only allow session establishment if this attribute value still corresponds to that of the current description. The attribute value is opaque and may contain any character allowed within SDP attribute values.</p>
<p id="rfc.section.Appendix D.1.9.p.2">ABNF for the attribute is defined in <a href="#sec_sdp-syntax">Section 20.3</a>.</p>
<div id="#rfc.figure.123"></div>
<pre>  a=mtag:"158bb3e7c7fd62ce67f12b533f06b83a"</pre>
<p id="rfc.section.Appendix D.1.9.p.3">Example: </p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">One could argue that the "o=" field provides identical functionality. However, it does so in a manner that would put constraints on servers that need to support multiple session description types other than SDP for the same piece of media content.</dd>
</dl>
<h1 id="rfc.appendix.Appendix D.2">
<a href="#rfc.appendix.Appendix%20D.2">Appendix D.2.</a> <a href="#sdp_no_aggr_control" id="sdp_no_aggr_control">Aggregate Control Not Available</a>
</h1>
<p id="rfc.section.Appendix D.2.p.1">If a presentation does not support aggregate control no session level "a=control:" attribute is specified. For a SDP with multiple media sections specified, each section will have its own control URI specified via the "a=control:" attribute.</p>
<div id="#rfc.figure.124"></div>
<pre>v=0
o=- 2890844256 2890842807 IN IP4 192.0.2.56
s=I came from a web page
e=adm@example.com
c=IN IP4 0.0.0.0
t=0 0
m=video 8002 RTP/AVP 31
a=control:rtsp://audio.example.com/movie.aud
m=audio 8004 RTP/AVP 3
a=control:rtsp://video.example.com/movie.vid</pre>
<p id="rfc.section.Appendix D.2.p.2">Example: </p>
<p id="rfc.section.Appendix D.2.p.3">Note that the position of the control URI in the description implies that the client establishes separate RTSP control sessions to the servers audio.example.com and video.example.com.</p>
<p id="rfc.section.Appendix D.2.p.4">It is recommended that an SDP file contains the complete media initialization information even if it is delivered to the media client through non-RTSP means. This is necessary as there is no mechanism to indicate that the client should request more detailed media stream information via DESCRIBE.</p>
<h1 id="rfc.appendix.Appendix D.3">
<a href="#rfc.appendix.Appendix%20D.3">Appendix D.3.</a> <a href="#sdp_aggr_control" id="sdp_aggr_control">Aggregate Control Available</a>
</h1>
<p id="rfc.section.Appendix D.3.p.1">In this scenario, the server has multiple streams that can be controlled as a whole. In this case, there are both a media-level "a=control:" attributes, which are used to specify the stream URIs, and a session-level "a=control:" attribute which is used as the Request-URI for aggregate control. If the media-level URI is relative, it is resolved to absolute URIs according to <a href="#sec_sdp-control-url">Appendix Appendix D.1.1</a> above.</p>
<div id="#rfc.figure.125"></div>
<pre>C-&gt;M: DESCRIBE rtsp://example.com/movie RTSP/2.0
      CSeq: 1
      User-Agent: PhonyClient/1.2

M-&gt;C: RTSP/2.0 200 OK
      CSeq: 1
      Date: Thu, 23 Jan 1997 15:35:06 GMT
      Expires: Thu, 23 Jan 1997 16:35:06 GMT
      Content-Type: application/sdp
      Content-Base: rtsp://example.com/movie/
      Content-Length: 227

      v=0
      o=- 2890844256 2890842807 IN IP4 192.0.2.211
      s=I contain
      i=&lt;more info&gt;
      e=adm@example.com
      c=IN IP4 0.0.0.0
      a=control:*
      t=0 0
      m=video 8002 RTP/AVP 31
      a=control:trackID=1
      m=audio 8004 RTP/AVP 3
      a=control:trackID=2
</pre>
<p id="rfc.section.Appendix D.3.p.2">Example: </p>
<p id="rfc.section.Appendix D.3.p.3">In this example, the client is recommended to establish a single RTSP session to the server, and uses the URIs rtsp://example.com/movie/trackID=1 and rtsp://example.com/movie/trackID=2 to set up the video and audio streams, respectively. The URI rtsp://example.com/movie/, which is resolved from the "*", controls the whole presentation (movie).</p>
<p id="rfc.section.Appendix D.3.p.4">A client is not required to issues SETUP requests for all streams within an aggregate object. Servers should allow the client to ask for only a subset of the streams.</p>
<h1 id="rfc.appendix.Appendix D.4">
<a href="#rfc.appendix.Appendix%20D.4">Appendix D.4.</a> <a href="#sec_sdp_m_grouping" id="sec_sdp_m_grouping">Grouping of Media Lines in SDP</a>
</h1>
<p id="rfc.section.Appendix D.4.p.1">For some types media it is desirable to express a relationship between various media components, for instance, for lip synchronization or Scalable Video Codec (SVC) <a href="#RFC5583">[RFC5583]</a>. This relationship is expressed on the SDP level by grouping of media lines, as described in <a href="#RFC5888">[RFC5888]</a> and can be exposed to RTSP.</p>
<p id="rfc.section.Appendix D.4.p.2">For RTSP it is mainly important to know how to handle grouped medias received by means of SDP, i.e., if the media are under aggregate control (see <a href="#sdp_aggr_control">Appendix Appendix D.3</a>) or if aggregate control is not available (see <a href="#sdp_no_aggr_control">Appendix Appendix D.2</a>).</p>
<p id="rfc.section.Appendix D.4.p.3">It is RECOMMENDED that grouped medias are handled by aggregate control, to give the client the ability to control either the whole presentation or single medias.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">Editor's note: how should the dependencies in <a href="#RFC5583">[RFC5583]</a> be handled in RTSP?</dd>
</dl>
<h1 id="rfc.appendix.Appendix D.5">
<a href="#rfc.appendix.Appendix%20D.5">Appendix D.5.</a> RTSP external SDP delivery</h1>
<p id="rfc.section.Appendix D.5.p.1">There are some considerations that need to be made when the session description is delivered to the client outside of RTSP, for example via HTTP or email.</p>
<p id="rfc.section.Appendix D.5.p.2">First of all, the SDP needs to contain absolute URIs, since relative will in most cases not work as the delivery will not correctly forward the base URI.</p>
<p id="rfc.section.Appendix D.5.p.3">The writing of the SDP session availability information, i.e. "t=" and "r=", needs to be carefully considered. When the SDP is fetched by the DESCRIBE method, the probability that it is valid is very high.  However, the same are much less certain for SDPs distributed using other methods. Therefore the publisher of the SDP should take care to follow the recommendations about availability in the SDP specification <a href="#RFC4566">[RFC4566]</a>.</p>
<h1 id="rfc.appendix.Appendix E">
<a href="#rfc.appendix.Appendix%20E">Appendix E.</a> <a href="#sec_usecases" id="sec_usecases">RTSP Use Cases</a>
</h1>
<p id="rfc.section.Appendix E.p.1">This Appendix describes the most important and considered use cases for RTSP. They are listed in descending order of importance in regards to ensuring that all necessary functionality is present. This specification only fully supports usage of the two first. Also in these first two cases, there are special cases or exceptions that are not supported without extensions, e.g. the redirection of media delivery to another address than the controlling agent's (client's).</p>
<h1 id="rfc.appendix.Appendix E.1">
<a href="#rfc.appendix.Appendix%20E.1">Appendix E.1.</a> <a href="#sec_usecases-on-demand" id="sec_usecases-on-demand">On-demand Playback of Stored Content</a>
</h1>
<p id="rfc.section.Appendix E.1.p.1">An RTSP capable server stores content suitable for being streamed to a client. A client desiring playback of any of the stored content uses RTSP to set up the media transport required to deliver the desired content. RTSP is then used to initiate, halt and manipulate the actual transmission (playout) of the content. RTSP is also required to provide necessary description and synchronization information for the content.</p>
<p id="rfc.section.Appendix E.1.p.2">The above high level description can be broken down into a number of functions that RTSP needs to be capable of. </p>

<dl>
<dt>Presentation Description:</dt>
<dd style="margin-left: 6">Provide initialization information about the presentation (content); for example, which media codecs are needed for the content. Other information that is important includes the number of media stream the presentation contains, the transport protocols used for the media streams, and identifiers for these media streams. This information is required before setup of the content is possible and to determine if the client is even capable of using the content. <br><br> This information need not be sent using RTSP; other external protocols can be used to transmit the transport presentation descriptions. Two good examples are the use of HTTP <a href="#RFC2616">[RFC2616]</a> or email to fetch or receive presentation descriptions like SDP <a href="#RFC4566">[RFC4566]</a>
</dd>
<dt>Setup:</dt>
<dd style="margin-left: 6">Set up some or all of the media streams in a presentation. The setup itself consist of selecting the protocol for media transport and the necessary parameters for the protocol, like addresses and ports.</dd>
<dt>Control of Transmission:</dt>
<dd style="margin-left: 6">After the necessary media streams have been established the client can request the server to start transmitting the content. The client must be allowed to start or stop the transmission of the content at arbitrary times.  The client must also be able to start the transmission at any point in the timeline of the presentation.</dd>
<dt>Synchronization:</dt>
<dd style="margin-left: 6">For media transport protocols like RTP <a href="#RFC3550">[RFC3550]</a> it might be beneficial to carry synchronization information within RTSP. This may be due to either the lack of inter-media synchronization within the protocol itself, or the potential delay before the synchronization is established (which is the case for RTP when using RTCP).</dd>
<dt>Termination:</dt>
<dd style="margin-left: 6">Terminate the established contexts.</dd>
</dl>

<p> For this use case there are a number of assumptions about how it works. These are: </p>

<dl>
<dt>On-Demand content:</dt>
<dd style="margin-left: 6">The content is stored at the server and can be accessed at any time during a time period when it is intended to be available.</dd>
<dt>Independent sessions:</dt>
<dd style="margin-left: 6">A server is capable of serving a number of clients simultaneously, including from the same piece of content at different points in that presentations time-line.</dd>
<dt>Unicast Transport:</dt>
<dd style="margin-left: 6">Content for each individual client is transmitted to them using unicast traffic.</dd>
</dl>

<p> It is also possible to redirect the media traffic to a different destination than that of the agent controlling the traffic.  However, allowing this without appropriate mechanisms for checking that the destination approves of this allows for distributed denial of service attacks (DDoS).</p>
<h1 id="rfc.appendix.Appendix E.2">
<a href="#rfc.appendix.Appendix%20E.2">Appendix E.2.</a> Unicast Distribution of Live Content</h1>
<p id="rfc.section.Appendix E.2.p.1">This use case is similar to the above on-demand content case (see <a href="#sec_usecases-on-demand">Appendix Appendix E.1</a>) the difference is the nature of the content itself. Live content is continuously distributed as it becomes available from a source; i.e., the main difference from on-demand is that one starts distributing content before the end of it has become available to the server.</p>
<p id="rfc.section.Appendix E.2.p.2">In many cases the consumer of live content is only interested in consuming what is actually happens "now"; i.e., very similar to broadcast TV. However, in this case it is assumed that there exist no broadcast or multicast channel to the users, and instead the server functions as a distribution node, sending the same content to multiple receivers, using unicast traffic between server and client. This unicast traffic and the transport parameters are individually negotiated for each receiving client.</p>
<p id="rfc.section.Appendix E.2.p.3">Another aspect of live content is that it often has a very limited time of availability, as it is only is available for the duration of the event the content covers. An example of such a live content could be a music concert which lasts 2 hour and starts at a predetermined time. Thus there is need to announce when and for how long the live content is available.</p>
<p id="rfc.section.Appendix E.2.p.4">In some cases, the server providing live content may be saving some or all of the content to allow clients to pause the stream and resume it from the paused point, or to "rewind" and play continuously from a point earlier than the live point. Hence, this use case does not necessarily exclude playing from other than the live point of the stream, playing with scales other than 1.0, etc.</p>
<h1 id="rfc.appendix.Appendix E.3">
<a href="#rfc.appendix.Appendix%20E.3">Appendix E.3.</a> On-demand Playback using Multicast</h1>
<p id="rfc.section.Appendix E.3.p.1">It is possible to use RTSP to request that media be delivered to a multicast group. The entity setting up the session (the controller) will then control when and what media is delivered to the group. This use case has some potential for denial of service attacks by flooding a multicast group. Therefore, a mechanism is needed to indicate that the group actually accepts the traffic from the RTSP server.</p>
<p id="rfc.section.Appendix E.3.p.2">An open issue in this use case is how one ensures that all receivers listening to the multicast or broadcast receives the session presentation configuring the receivers. This specification has to rely on a external solution to solve this issue.</p>
<h1 id="rfc.appendix.Appendix E.4">
<a href="#rfc.appendix.Appendix%20E.4">Appendix E.4.</a> Inviting an RTSP server into a conference</h1>
<p id="rfc.section.Appendix E.4.p.1">If one has an established conference or group session, it is possible to have an RTSP server distribute media to the whole group.  Transmission to the group is simplest when controlled by a single participant or leader of the conference. Shared control might be possible, but would require further investigation and possibly extensions.</p>
<p id="rfc.section.Appendix E.4.p.2">This use case assumes that there exists either multicast or a conference focus that redistribute media to all participants.</p>
<p id="rfc.section.Appendix E.4.p.3">This use case is intended to be able to handle the following scenario: A conference leader or participant (hereafter called the controller) has some pre-stored content on an RTSP server that he wants to share with the group. The controller sets up an RTSP session at the streaming server for this content and retrieves the session description for the content. The destination for the media content is set to the shared multicast group or conference focus. When desired by the controller, he/she can start and stop the transmission of the media to the conference group.</p>
<p id="rfc.section.Appendix E.4.p.4">There are several issues with this use case that are not solved by this core specification for RTSP: </p>

<dl>
<dt>Denial of service:</dt>
<dd style="margin-left: 6">To avoid an RTSP server from being an unknowing participant in a denial of service attack the server needs to be able to verify the destination's acceptance of the media. Such a mechanism to verify the approval of received media does not yet exist; instead, only policies can be used, which can be made to work in controlled environments.</dd>
<dt>Distributing the presentation description to all participants in the group:</dt>
<dd style="margin-left: 6">To enable a media receiver to correctly decode the content the media configuration information needs to be distributed reliably to all participants. This will most likely require support from an external protocol.</dd>
<dt>Passing control of the session:</dt>
<dd style="margin-left: 6">If it is desired to pass control of the RTSP session between the participants, some support will be required by an external protocol to exchange state information and possibly floor control of who is controlling the RTSP session.</dd>
</dl>

<p> If there interest in this use case, further work is required on the necessary extensions.</p>
<h1 id="rfc.appendix.Appendix E.5">
<a href="#rfc.appendix.Appendix%20E.5">Appendix E.5.</a> Live Content using Multicast</h1>
<p id="rfc.section.Appendix E.5.p.1">This use case in its simplest form does not require any use of RTSP at all; this is what multicast conferences being announced with <a href="#RFC2974">SAP</a> <cite title="NONE">[RFC2974]</cite> and SDP are intended to handle. However, in use cases where more advanced features like access control to the multicast session are desired, RTSP could be used for session establishment.</p>
<p id="rfc.section.Appendix E.5.p.2">A client desiring to join a live multicasted media session with cryptographic (encryption) access control could use RTSP in the following way. The source of the session announces the session and gives all interested an RTSP URI. The client connects to the server and requests the presentation description, allowing configuration for reception of the media. In this step it is possible for the client to use secured transport and any desired level of authentication; for example, for billing or access control. An RTSP link also allows for load balancing between multiple servers.</p>
<p id="rfc.section.Appendix E.5.p.3">If these were the only goals, they could be achieved by simply using HTTP. However, for cases where the sender likes to keep track of each individual receiver of a session, and possibly use the session as a side channel for distributing key-updates or other information on a per-receiver basis, and the full set of receivers is not know prior to the session start, the state establishment that RTSP provides can be beneficial. In this case a client would establish an RTSP session for this multicast group with the RTSP server. The RTSP server will not transmit any media, but instead will point to the multicast group. The client and server will be able to keep the session alive for as long as the receiver participates in the session thus enabling, for example, the server to push updates to the client.</p>
<p id="rfc.section.Appendix E.5.p.4">This use case will most likely not be able to be implemented without some extensions to the server-to-client push mechanism. Here the PLAY_NOTIFY method (see <a href="#sec_PLAY_NOTIFY">Section 13.5</a>) with a suitable extension could provide clear benefits.</p>
<h1 id="rfc.appendix.Appendix F">
<a href="#rfc.appendix.Appendix%20F">Appendix F.</a> <a href="#sec_text-parameters" id="sec_text-parameters">Text format for Parameters</a>
</h1>
<p id="rfc.section.Appendix F.p.1">A resource of type "text/parameters" consists of either 1) a list of parameters (for a query) or 2) a list of parameters and associated values (for an response or setting of the parameter). Each entry of the list is a single line of text. Parameters are separated from values by a colon. The parameter name MUST only use US-ASCII visible characters while the values are UTF-8 text strings. The media type registration form is in <a href="#sec_iana_textpar">Section 22.16</a>.</p>
<p id="rfc.section.Appendix F.p.2">There exist a potential interoperability issue for this format. It was named in RFC 2326 but never defined, even if used in examples that hint at the syntax. This format matches the purpose and its syntax supports the examples provided. However, it goes further by allowing UTF-8 in the value part, thus usage of UTF-8 strings may not be supported. However, as individual parameters are not defined, the using application anyway needs to have out-of-band agreement or using feature-tag to determine if the end-point supports the parameters.</p>
<p id="rfc.section.Appendix F.p.3">The <a href="#RFC5234">ABNF</a> <cite title="NONE">[RFC5234]</cite> grammar for "text/parameters" content is:</p>
<div id="#rfc.figure.126"></div>
<pre>file             = *((parameter / parameter-value) CRLF)
parameter        = 1*visible-except-colon 
parameter-value  = parameter *WSP ":" value 
visible-except-colon = %x21-39 / %x3B-7E    ; VCHAR - ":" 
value            = *(TEXT-UTF8char / WSP)
TEXT-UTF8char    =  %x21-7E / UTF8-NONASCII
UTF8-NONASCII    =  %xC0-DF 1UTF8-CONT
                 /  %xE0-EF 2UTF8-CONT
                 /  %xF0-F7 3UTF8-CONT
                 /  %xF8-FB 4UTF8-CONT
                 /  %xFC-FD 5UTF8-CONT
UTF8-CONT        =  %x80-BF
WSP              = &lt;See RFC 5234&gt; ; Space or HTAB
VCHAR            = &lt;See RFC 5234&gt;
CRLF             = &lt;See RFC 5234&gt;</pre>
<p></p>
<p></p>
<h1 id="rfc.appendix.Appendix G">
<a href="#rfc.appendix.Appendix%20G">Appendix G.</a> <a href="#sec_unreliable" id="sec_unreliable">Requirements for Unreliable Transport of RTSP</a>
</h1>
<p id="rfc.section.Appendix G.p.1">This section provides anyone intending to define how to transport of RTSP messages over a unreliable transport protocol with some information learned by the attempt in RFC 2326 <a href="#RFC2326">[RFC2326]</a>. RFC 2326 define both an URI scheme and some basic functionality for transport of RTSP messages over UDP, however, it was not sufficient for reliable usage and successful interoperability.</p>
<p id="rfc.section.Appendix G.p.2">The RTSP scheme defined for unreliable transport of RTSP messages was "rtspu". It has been reserved by this specification as at least one commercial implementation exist, thus avoiding any collisions in the name space.</p>
<p id="rfc.section.Appendix G.p.3">The following considerations should exist for operation of RTSP over an unreliable transport protocol: </p>

<ul>
<li>Request shall be acknowledged by the receiver. If there is no acknowledgement, the sender may resend the same message after a timeout of one round-trip time (RTT). Any retransmissions due to lack of acknowledgement must carry the same sequence number as the original request.</li>
<li>The round-trip time can be estimated as in TCP (RFC 1123) <a href="#RFC1123">[RFC1123]</a>, with an initial round-trip value of 500 ms. An implementation may cache the last RTT measurement as the initial value for future connections.</li>
<li>If RTSP is used over a small-RTT LAN, standard procedures for optimizing initial TCP round trip estimates, such as those used in T/TCP (RFC 1644) <a href="#RFC1644">[RFC1644]</a>, can be beneficial.</li>
<li>The Timestamp header (<a href="#sec_Timestamp">Section 16.51</a>) is used to avoid <a href="#Stevens98">the retransmission ambiguity problem</a> <cite title="NONE">[Stevens98]</cite>.</li>
<li>The registered default port for RTSP over UDP for the server is 554.</li>
<li>RTSP messages can be carried over any lower-layer transport protocol that is 8-bit clean.</li>
<li>RTSP messages are vulnerable to bit errors and should not be subjected to them.</li>
<li>Source authentication, or at least validation that RTSP messages comes from the same entity becomes extremely important, as session hijacking may be substantially easier for RTSP message transport using an unreliable protocol like UDP than for TCP.</li>
</ul>
<p id="rfc.section.Appendix G.p.4">There exist two RTSP headers thats primarily are intended for being used by the unreliable handling of RTSP messages and which will be maintained: </p>

<ul>
<li>CSeq: See <a href="#sec_CSeq">Section 16.19</a>
</li>
<li>Timestamp: See <a href="#sec_Timestamp">Section 16.51</a>
</li>
</ul>
<h1 id="rfc.appendix.Appendix H">
<a href="#rfc.appendix.Appendix%20H">Appendix H.</a> <a href="#sec_backwards" id="sec_backwards">Backwards Compatibility Considerations</a>
</h1>
<p id="rfc.section.Appendix H.p.1">This section contains notes on issues about backwards compatibility with clients or servers being implemented according to RFC 2326 <a href="#RFC2326">[RFC2326]</a>. Note that there exists no requirement to implement RTSP 1.0, in fact we recommend against it as it is difficult to do in an interoperable way.</p>
<p id="rfc.section.Appendix H.p.2">A server implementing RTSP/2.0 MUST include a RTSP-Version of RTSP/2.0 in all responses to requests containing RTSP-Version RTSP/2.0.  If a server receives a RTSP/1.0 request, it MAY respond with a RTSP/1.0 response if it chooses to support RFC 2326. If the server chooses not to support RFC 2326, it MUST respond with a 505 (RTSP Version not supported) status code. A server MUST NOT respond to a RTSP-Version RTSP/1.0 request with a RTSP-Version RTSP/2.0 response.</p>
<p id="rfc.section.Appendix H.p.3">Clients implementing RTSP/2.0 MAY use an OPTIONS request with a RTSP-Version of 2.0 to determine whether a server supports RTSP/2.0. If the server responds with either a RTSP-Version of 1.0 or a status code of 505 (RTSP Version not supported), the client will have to use RTSP/1.0 requests if it chooses to support RFC 2326.</p>
<h1 id="rfc.appendix.Appendix H.1">
<a href="#rfc.appendix.Appendix%20H.1">Appendix H.1.</a> <a href="#sec_back-play" id="sec_back-play">Play Request in Play State</a>
</h1>
<p id="rfc.section.Appendix H.1.p.1">The behavior in the server when a Play is received in Play state has changed (<a href="#sec_PLAY">Section 13.4</a>). In RFC 2326, the new PLAY request would be queued until the current Play completed. Any new PLAY request now take effect immediately replacing the previous request.</p>
<h1 id="rfc.appendix.Appendix H.2">
<a href="#rfc.appendix.Appendix%20H.2">Appendix H.2.</a> <a href="#sec_back-persistent-connection" id="sec_back-persistent-connection">Using Persistent Connections</a>
</h1>
<p id="rfc.section.Appendix H.2.p.1">Some server implementations of RFC 2326 maintain a one-to-one relationship between a connection and an RTSP session. Such implementations require clients to use a persistent connection to communicate with the server and when a client closes its connection, the server may remove the RTSP session. This is worth noting if a RTSP 2.0 client also supporting 1.0 connects to a 1.0 server.</p>
<h1 id="rfc.appendix.Appendix I">
<a href="#rfc.appendix.Appendix%20I">Appendix I.</a> <a href="#sec_open" id="sec_open">Open Issues</a>
</h1>
<p id="rfc.section.Appendix I.p.1">Open issues are filed and tracked in the bug and feature trackers at http://rtspspec.sourceforge.net. Open issues are discussed on MMUSIC list (mmusic@ietf.org).</p>
<p id="rfc.section.Appendix I.p.2">Note to RFC-editor: Please remove this section before publication of this document as an RFC.</p>
<h1 id="rfc.appendix.Appendix J">
<a href="#rfc.appendix.Appendix%20J">Appendix J.</a> <a href="#sec_changes" id="sec_changes">Changes</a>
</h1>
<p id="rfc.section.Appendix J.p.1">This appendix briefly lists the differences between <a href="#RFC2326">RTSP 1.0</a> <cite title="NONE">[RFC2326]</cite> and RTSP 2.0 for an informational purpose. For implementers of RTSP 2.0 it is recommended to read carefully through this memo and not to rely on the list of changes below to adapt from RTSP 1.0 to RTSP 2.0, as RTSP 2.0 is not intended to be backwards compatible with <a href="#RFC2326">RTSP 1.0</a> <cite title="NONE">[RFC2326]</cite> other than the version negotiation mechanism.</p>
<h1 id="rfc.appendix.Appendix J.1">
<a href="#rfc.appendix.Appendix%20J.1">Appendix J.1.</a> Brief Overview</h1>
<p id="rfc.section.Appendix J.1.p.1">The following protocol elements were removed in RTSP 2.0 compared to RTSP 1.0:</p>

<ul>
<li>there is no section on minimal implementation anymore, but more the definition of RTSP 2.0 core;</li>
<li>the RECORD and ANNOUNCE methods and all related functionality (including 201 (Created) and 250 (Low On Storage Space) status codes);</li>
<li>the use of UDP for RTSP message transport was removed due to missing interest and to broken specification;</li>
<li>the use of PLAY method for keep-alive in Play state.</li>
</ul>
<p id="rfc.section.Appendix J.1.p.2">The following protocol elements were added or changed in RTSP 2.0 compared to RTSP 1.0:</p>

<ul>
<li>RTSP session TEARDOWN from the server to the client;</li>
<li>IPv6 support;</li>
<li>extended IANA registries (e.g., transport headers parameters, transport-protocol, profile, lower-transport, and mode);</li>
<li>request pipelining for quick session start-up;</li>
<li>fully reworked state-machine;</li>
<li>RTSP messages now uses URIs rather then URLs;</li>
<li>incorporated much of related HTTP text (<a href="#RFC2616">[RFC2616]</a>) in this memo, compared to just referencing the sections in HTTP, to avoid ambiguities;</li>
<li>the REDIRECT method was expanded and diversified for different situations;</li>
<li>Includes a new section about how to setup different media transport alternatives and their profiles, and lower layer protocols. This resulted that the appendix on RTP interaction was moved there instead in the part describing RTP. The section also includes guidelines what to consider when writing usage guidelines for new protocols and profiles;</li>
<li>added an asynchronous notification method PLAY_NOTIFY. This method is used by the RTSP server to asynchronously notify clients about session changes while in Play state. To a limited extend this is comparable with some implementations of ANNOUNCE in RTSP 1.0 not intended for Recording.</li>
</ul>
<h1 id="rfc.appendix.Appendix J.2">
<a href="#rfc.appendix.Appendix%20J.2">Appendix J.2.</a> Detailed List of Changes</h1>
<p id="rfc.section.Appendix J.2.p.1">Compared to RTSP 1.0 (RFC 2326), the below changes has been made when defining RTSP 2.0. Note that this list does not reflect minor changes in wording or correction of typographical errors. </p>

<ul>
<li>The section on minimal implementation was deleted without substitution.</li>
<li>The Transport header has been changed in the following way: <ul>
<li>The ABNF has been changed to define that extensions are possible, and that unknown parameters results in that servers ignore the transport specification.</li>
<li>To prevent backwards compatibility issues, any extension or new parameter requires the usage of a feature-tag combined with the Require header.</li>
<li>Syntax unclarities with the Mode parameter has been resolved.</li>
<li>Syntax error with ";" for multicast and unicast has been resolved.</li>
<li>Two new addressing parameters has been defined, src_addr and dest_addr. These replaces the parameters "port", "client_port", "server_port", "destination", "source".</li>
<li>Support for IPv6 explicit addresses in all address fields has been included.</li>
<li>To handle URI definitions that contain ";" or "," a quoted URI format has been introduced and is required.</li>
<li>Defined IANA registries for the transport headers parameters, transport-protocol, profile, lower-transport, and mode.</li>
<li>The transport headers interleaved parameter's text was made more strict and use formal requirements levels. It was also clarified that the interleaved channels are symmetric and that it is the server that sets the channel numbers.</li>
<li>It has been clarified that the client can't request of the server to use a certain RTP SSRC, using a request with the transport parameter SSRC.</li>
<li>Syntax definition for SSRC has been clarified to require 8HEX. It has also been extended to allow multiple values for clients supporting this version.</li>
<li>Clarified the text on the transport headers "dest_addr" parameters regarding what security precautions the server is required to perform.</li>
</ul>
</li>
<li>The Range formats has been changed in the following way: <ul>
<li>The NPT format has been given a initial NPT identifier that must now be used.</li>
<li>All formats now support initial open ended formats of type "npt=-10" and also format only "Range: smpte" ranges for usage with GET_PARAMETER requests.</li>
</ul>
</li>
<li>RTSP message handling has been changed in the following way: <ul>
<li>RTSP messages now uses URIs rather then URLs.</li>
<li>It has been clarified that a 4xx message due to missing CSeq header shall be returned without a CSeq header.</li>
<li>The 300 (Multiple Choices) response code has been removed.</li>
<li>Rules for how to handle timing out RTSP messages has been added.</li>
<li>Extended Pipelining rules allowing for quick session startup.</li>
</ul>
</li>
<li>The HTTP references has been updated to RFC 2616 and RFC 2617.  Most of text has been copied and then altered to fit RTSP into this specification. Public, and the Content-Base header has also been imported from RFC 2068 so that they are defined in the RTSP specification. Known effects on RTSP due to HTTP clarifications: <ul><li>Content-Encoding header can include encoding of type "identity".</li></ul>
</li>
<li>The state machine section has completely been rewritten. It includes now more details and are also more clear about the model used.</li>
<li>A IANA section has been included with contains a number of registries and their rules. This will allow us to use IANA to keep track of RTSP extensions.</li>
<li>The transport of RTSP messages has seen the following changes: <ul>
<li>The use of UDP for RTSP message transport has been deprecated due to missing interest and to broken specification.</li>
<li>The rules for how TCP connections is to be handled has been clarified. Now it is made clear that servers should not close the TCP connection unless they have been unused for significant time.</li>
<li>Strong recommendations why server and clients should use persistent connections has also been added.</li>
<li>There is now a requirement on the servers to handle non-persistent connections as this provides fault tolerance.</li>
<li>Added wording on the usage of Connection:Close for RTSP.</li>
<li>specified usage of TLS for RTSP messages, including a scheme to approve a proxies TLS connection to the next hop.</li>
</ul>
</li>
<li>The following header related changes have been made: <ul>
<li>Accept-Ranges response header is added. This header clarifies which range formats that can be used for a resource.</li>
<li>Fixed the missing definitions for the Cache-Control header.  Also added to the syntax definition the missing delta-seconds for max-stale and min-fresh parameters.</li>
<li>Put requirement on CSeq header that the value is increased by one for each new RTSP request. A Recommendation to start at 0 has also been added.</li>
<li>Added requirement that the Date header must be used for all messages with message body and the Server should always include it.</li>
<li>Removed possibility of using Range header with Scale header to indicate when it is to be activated, since it can't work as defined. Also added rule that lack of Scale header in response indicates lack of support for the header. Feature-tags for scaled playback has been defined.</li>
<li>The Speed header must now be responded to indicate support and the actual speed going to be used. A feature-tag is defined. Notes on congestion control was also added.</li>
<li>The Supported header was borrowed from <a href="#RFC3261">SIP</a> <cite title="NONE">[RFC3261]</cite> to help with the feature negotiation in RTSP.</li>
<li>Clarified that the Timestamp header can be used to resolve retransmission ambiguities.</li>
<li>The Session header text has been expanded with a explanation on keep alive and which methods to use.  SET_PARAMETER is now recommended to use if only keep-alive within RTSP is desired.</li>
<li>It has been clarified how the Range header formats is used to indicate pause points in the PAUSE response.</li>
<li>Clarified that RTP-Info URIs that are relative, use the Request-URI as base URI. Also clarified that the used URI must be the one that was used in the SETUP request. The URIs are now also required to be quoted. The header also expresses the SSRC for the provided RTP timestamp and sequence number values.</li>
<li>Added text that requires the Range to always be present in PLAY responses. Clarified what should be sent in case of live streams.</li>
<li>The headers table has been updated using a structured borrowed from SIP. Those tables carries much more information and should provide a good overview of the available headers.</li>
<li>It has been clarified that any message with a message body is required to have a Content-Length header. This was the case in RFC 2326, but could be misinterpreted.</li>
<li>ETag has changed name to MTag.</li>
<li>To resolve functionality around MTag. The MTag and If-None-Match header has been added from HTTP with necessary clarification in regards to RTSP operation.</li>
<li>Imported the Public header from HTTP RFC 2068 <a href="#RFC2068">[RFC2068]</a> since it has been removed from HTTP due to lack of use. Public is used quite frequently in RTSP.</li>
<li>Clarified rules for populating the Public header so that it is an intersection of the capabilities of all the RTSP agents in a chain.</li>
<li>Added the Media-Range header for listing the current availability of the media range.</li>
<li>Added the Notify-Reason header for giving the reason when sending PLAY_NOTIFY requests.</li>
<li>A new header Seek-Style has been defined to direct and inform how any seek operation should/have been performed.</li>
</ul>
</li>
<li>The Protocol Syntax has been changed in the following way: <ul>
<li>All ABNF definitions are updated according to the rules defined in RFC 5234 <a href="#RFC5234">[RFC5234]</a> and has been gathered in a separate <a href="#sec_syntax">Section 20</a>.</li>
<li>The ABNF for the User-Agent and Server headers has been corrected.</li>
<li>Some definitions in the introduction regarding the RTSP session has been changed.</li>
<li>The protocol has been made fully IPv6 capable.</li>
<li>Added a fragment part to the RTSP URI. This seem to be indicated by the note below the definition, however, it was not part of the ABNF.</li>
<li>The CHAR rule has been changed to exclude NULL.</li>
</ul>
</li>
<li>The Status codes have been changed in the following way: <ul>
<li>The use of status code 303 "See Other" has been deprecated as it does not make sense to use in RTSP.</li>
<li>When sending response 451 and 458 the response body should contain the offending parameters.</li>
<li>Clarification on when a 3rr redirect status code can be received has been added. This includes receiving 3rr as a result of request within a established session. This provides clarification to a previous unspecified behavior.</li>
<li>Removed the 201 (Created) and 250 (Low On Storage Space) status codes as they are only relevant to recording, which is deprecated.</li>
<li>Several new Status codes has been defined: 464 "Data Transport Not Ready Yet", 465 "Notification Reason Unknown", 470 "Connection Authorization Required", 471 "Connection Credentials not accepted", 472 "Failure to establish secure connection".</li>
</ul>
</li>
<li>The following functionality has been deprecated from the protocol: <ul>
<li>The use of Queued Play.</li>
<li>The use of PLAY method for keep-alive in Play state.</li>
<li>The RECORD and ANNOUNCE methods and all related functionality. Some of the syntax has been removed.</li>
<li>The possibility to use timed execution of methods with the time parameter in the Range header.</li>
<li>The description on how rtspu works is not part of the core specification and will require external description. Only that it exist is defined here and some requirements for the transport is provided.</li>
</ul>
</li>
<li>The following changes has been made in relation to methods: <ul>
<li>The OPTIONS method has been clarified with regards to the use of the Public and Allow headers.</li>
<li>Added text clarifying the usage of SET_PARAMETER for keep-alive and usage without any body.</li>
<li>PLAY method is now allowed to be pipelined with the pipelining of one or more SETUP requests following the initial that generates the session for aggregated control.</li>
<li>REDIRECT has been expanded and diversified for different situations.</li>
<li>Added a new method PLAY_NOTIFY. This method is used by the RTSP server to asynchronously notify clients about session changes.</li>
</ul>
</li>
<li>Wrote a new section about how to setup different media transport alternatives and their profiles, and lower layer protocols. This resulted that the appendix on RTP interaction was moved there instead in the part describing RTP. The section also includes guidelines what to consider when writing usage guidelines for new protocols and profiles.</li>
<li>Setup and usage of independent TCP connections for transport of RTP has been specified.</li>
<li>Added a new section describing the available mechanisms to determine if functionality is supported, called "Capability Handling". Renamed option-tags to feature-tags.</li>
<li>Added a contributors section with people who have contributed actual text to the specification.</li>
<li>Added a section Use Cases that describes the major use cases for RTSP.</li>
<li>Clarified the usage of a=range and how to indicate live content that are not seekable with this header.</li>
<li>Text specifying the special behavior of PLAY for live content.</li>
</ul>
<h1 id="rfc.appendix.Appendix K">
<a href="#rfc.appendix.Appendix%20K">Appendix K.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.Appendix K.p.1">This memorandum defines RTSP version 2.0 which is a revision of the Proposed Standard RTSP version 1.0 which is defined in <a href="#RFC2326">[RFC2326]</a>. The authors of RFC 2326 are Henning Schulzrinne, Anup Rao, and Robert Lanphier.</p>
<p id="rfc.section.Appendix K.p.2">Both RTSP version 1.0 and RTSP version 2.0 borrow format and descriptions from HTTP/1.1.</p>
<p id="rfc.section.Appendix K.p.3">This document has benefited greatly from the comments of all those participating in the MMUSIC-WG. In addition to those already mentioned, the following individuals have contributed to this specification:</p>
<p id="rfc.section.Appendix K.p.4">Rahul Agarwal, Jeff Ayars, Milko Boic, Torsten Braun, Brent Browning, Bruce Butterfield, Steve Casner, Francisco Cortes, Kelly Djahandari, Martin Dunsmuir, Eric Fleischman, Jay Geagan, Andy Grignon, V.  Guruprasad, Peter Haight, Mark Handley, Brad Hefta-Gaub, Volker Hilt, John K. Ho, Go Hori, Philipp Hoschka, Anne Jones, Ingemar Johansson, Anders Klemets, Ruth Lang, Stephanie Leif, Jonathan Lennox, Eduardo F.  Llach, Thomas Marshall, Rob McCool, David Oran, Joerg Ott, Maria Papadopouli, Sujal Patel, Ema Patki, Alagu Periyannan, Colin Perkins, Igor Plotnikov, Jonathan Sergent, Pinaki Shah, David Singer, Lior Sion, Jeff Smith, Alexander Sokolsky, Dale Stammen, John Francis Stracke, Maureen Chesire, David Walker, Geetha Srikantan, Stephan Wenger, Pekka Pessi, Jae-Hwan Kim, Holger Schmidt, Stephen Farrell, Xavier Marjou, Joe Pallas, Martti Mela, Byungjo Yoon and Patrick Hoffman, Jinhang Choi.</p>
<h1 id="rfc.appendix.Appendix K.1">
<a href="#rfc.appendix.Appendix%20K.1">Appendix K.1.</a> <a href="#sec_contributors" id="sec_contributors">Contributors</a>
</h1>
<p id="rfc.section.Appendix K.1.p.1">The following people have made written contributions that were included in the specification: </p>

<ul>
<li>Tom Marshall contributed text on the usage of 3rr status codes.</li>
<li>Thomas Zheng contributed text on the usage of the Range in PLAY responses and proposed an earlier version of the PLAY_NOTIFY method.</li>
<li>Sean Sheedy contributed text on the timeout behavior of RTSP messages and connections, the 463 status code, and proposed an earlier version of the PLAY_NOTIFY method.</li>
<li>Greg Sherwood proposed an earlier version of the PLAY_NOTIFY method.</li>
<li>Fredrik Lindholm contributed text about the RTSP security framework.</li>
<li>John Lazzaro contributed the text for RTP over Independent TCP.</li>
<li>Aravind Narasimhan contributed by rewriting <a href="#sec_mediatran">Media Transport Alternatives</a> <cite title="NONE">[sec_mediatran]</cite> and editorial improvements on a number of places in the specification.</li>
<li>Torbjorn Einarsson has done some editorial approvements of the text.</li>
</ul>
<h1 id="rfc.appendix.Appendix L">
<a href="#rfc.appendix.Appendix%20L">Appendix L.</a> <a href="#RFCEditorConsideration" id="RFCEditorConsideration">RFC Editor Consideration</a>
</h1>
<p id="rfc.section.Appendix L.p.1">Please replace RFC XXXX with the RFC number this specification receives.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henning Schulzrinne</span> 
	  <span class="n hidden">
		<span class="family-name">Schulzrinne</span>
	  </span>
	</span>
	<span class="org vcardline">Columbia University</span>
	<span class="adr">
	  <span>1214 Amsterdam Avenue</span>

	  <span class="vcardline">
		<span class="locality">New York</span>,  
		<span class="region">NY</span> 
		<span class="code">10027</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:schulzrinne@cs.columbia.edu">schulzrinne@cs.columbia.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Anup Rao</span> 
	  <span class="n hidden">
		<span class="family-name">Rao</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:anrao@cisco.com">anrao@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Rob Lanphier</span> 
	  <span class="n hidden">
		<span class="family-name">Lanphier</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Seattle</span>,  
		<span class="region">WA</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:robla@robla.net">robla@robla.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Magnus Westerlund</span> 
	  <span class="n hidden">
		<span class="family-name">Westerlund</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  <span>F&#228;r&#246;gatan 6</span>

	  <span class="vcardline">
		<span class="locality">STOCKHOLM</span>,  
		<span class="region"></span>
		<span class="code">SE-164 80</span>
	  </span>
	  <span class="country-name vcardline">SWEDEN</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:magnus.westerlund@ericsson.com">magnus.westerlund@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Stiemerling</span> 
	  <span class="n hidden">
		<span class="family-name">Stiemerling (Ed.)</span>
	  </span>
	</span>
	<span class="org vcardline">NEC Laboratories Europe, NEC Europe Ltd.</span>
	<span class="adr">
	  <span>Kurfuersten-Anlage 36</span>

	  <span class="vcardline">
		<span class="locality">Heidelberg</span>,  
		<span class="region"></span>
		<span class="code">69115</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49 (0) 6221 4342 113</span>

<span class="vcardline">EMail: <a href="mailto:martin.stiemerling@neclab.eu">martin.stiemerling@neclab.eu</a></span>

<span class="vcardline">URI: <a href="http://ietf.stiemerling.org">http://ietf.stiemerling.org</a></span>

  </address>
</div>

</body>
</html>