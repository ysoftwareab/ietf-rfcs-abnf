schema = {
     form,
     ? definitions: { * tstr => schema },
     ? additionalProperties: bool,
     * non-keyword => *
non-keyword =
     (((((((((tstr .ne "definitions")
       .ne "additionalProperties")
       .ne "ref")
       .ne "type")
       .ne "enum")
       .ne "elements")
       .ne "properties")
       .ne "optionalProperties")
       .ne "values")
       .ne "discriminator"

                   Figure 1: CDDL Definition of a Schema

form = empty /
     ref /
     type /
     enum /
     elements /
     properties /
     values /
     discriminator

               Figure 2: CDDL Definition of the Schema Forms

empty = {}

                Figure 3: CDDL Definition of the Empty Form

ref = { ref: tstr }

                 Figure 4: CDDL Definition of the Ref Form

type = { type: "boolean" / num-type / "string" / "timestamp" }
num-type = "float32" / "float64" /
     "int8" / "uint8" / "int16" / "uint16" / "int32" / "uint32"

                Figure 5: CDDL Definition of the Type Form

enum = { enum: [+ tstr] }

                Figure 6: CDDL Definition of the Enum Form

elements = { elements: schema }

              Figure 7: CDDL Definition of the Elements Form

properties = with-properties / with-optional-properties

with-properties = {
     properties: * tstr => schema,
     ? optionalProperties * tstr => schema
with-optional-properties = {
     ? properties: * tstr => schema,
     optionalProperties: * tstr => schema
values = { values: * tstr => schema }

               Figure 9: CDDL Definition of the Values Form

discriminator = { tag: tstr, mapping: * tstr => properties }

           Figure 10: CDDL Definition of the Discriminator Form

root = any

root = [* a]

a = [* b]
b = number

root = "PENDING" / "DONE" / "CANCELED"

root = bool

root = number

root = tstr

root = tdate

root = [* number]

root = { a: bool, b: number, ? c: tstr, ? d: tdate }
root = { * tstr => number }

root = { a: "foo", b: number } / { a: "bar", b: tstr }

