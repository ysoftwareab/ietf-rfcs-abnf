<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std"
     consensus="true" docName="draft-ietf-6man-segment-routing-header-26"
     number="8754" ipr="trust200902" obsoletes="" updates=""
     submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="3"
     symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 2.35.0 -->
  <front>
    <title abbrev="IPv6 Segment Routing Header (SRH)">IPv6 Segment Routing Header (SRH)</title>
    <seriesInfo name="RFC" value="8754" />
    <author fullname="Clarence Filsfils" initials="C." role="editor" surname="Filsfils">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Brussels</city>
          <region/>
          <code/>
          <country>Belgium</country>
        </postal>
        <email>cfilsfil@cisco.com</email>
      </address>
    </author>
    <author fullname="Darren Dukes" initials="D." role="editor" surname="Dukes">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street/>
          <city>Ottawa</city>
          <region/>
          <code/>
          <country>Canada</country>
        </postal>
        <email>ddukes@cisco.com</email>
      </address>
    </author>
    <author fullname="Stefano Previdi" initials="S." surname="Previdi">
      <organization>Huawei</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <code/>
          <country>Italy</country>
        </postal>
        <email>stefano@previdi.net</email>
      </address>
    </author>
    <author fullname="John Leddy" initials="J." surname="Leddy">
      <organization>Individual</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <region/>
          <code/>
          <country>United States of America</country>
        </postal>
        <email>john@leddy.net</email>
      </address>
    </author>
    <author fullname="Satoru Matsushima" initials="S." surname="Matsushima">
      <organization>SoftBank</organization>
      <address>
        <email>satoru.matsushima@g.softbank.co.jp</email>
      </address>
    </author>
    <author fullname="Daniel Voyer" initials="D." surname="Voyer">
      <organization>Bell Canada</organization>
      <address>
        <email>daniel.voyer@bell.ca</email>
      </address>
    </author>
    <date year="2020" month="March"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>

<keyword>SRv6</keyword>
<keyword>source-routing</keyword>
<keyword>network-programming</keyword>


    <abstract>
      <t>Segment Routing can be applied to the IPv6 data plane using a new
      type of Routing Extension Header called the Segment Routing Header (SRH). This
      document describes the SRH and how it is used by nodes that are
      Segment Routing (SR) capable.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="INTRO" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Segment Routing (SR) can be applied to the IPv6 data plane using a new
      type of routing header called the Segment Routing Header (SRH). This document
      describes the SRH and how it is used by nodes that are SR capable.</t>
      <t>"Segment Routing Architecture" <xref target="RFC8402" format="default"/> describes
      Segment Routing and its instantiation in two data planes: MPLS and
      IPv6.</t>
      <t>The encoding of IPv6 segments in the SRH is
      defined in this document.</t>
          <section anchor="TERMS" numbered="true" toc="default">
      <name>Terminology</name>
      <t>This document uses the terms Segment Routing (SR), SR domain, SR over
      IPv6 (SRv6), Segment Identifier (SID), SRv6 SID, Active Segment, and SR Policy as defined in
      <xref target="RFC8402" format="default"/>.</t></section>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>

      </section>
    </section>
    <section anchor="SRH" numbered="true" toc="default">
      <name>Segment Routing Header</name>
      <t>Routing headers are defined in <xref target="RFC8200" format="default"/>. The Segment
      Routing Header (SRH) has a new Routing Type (4).</t>
      <t>The SRH is defined as follows:</t>
      <artwork name="" type="" align="left" alt=""><![CDATA[
  0                   1                   2                   3 
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1    
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Next Header   |  Hdr Ext Len  | Routing Type  | Segments Left |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Last Entry   |     Flags     |              Tag              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |            Segment List[0] (128-bit IPv6 address)             |
 |                                                               |
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                                                               |
                               ...
 |                                                               |
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |            Segment List[n] (128-bit IPv6 address)             |
 |                                                               |
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 //                                                             //
 //         Optional Type Length Value objects (variable)       //
 //                                                             //
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
<t>where:</t>
      <dl spacing="normal">
        <dt>Next Header:</dt><dd>Defined in <xref target="RFC8200"
	sectionFormat="comma" section="4.4"/>.</dd>
        <dt>Hdr Ext Len:</dt><dd>Defined in <xref target="RFC8200" sectionFormat="comma" section="4.4"/>.</dd>
        <dt>Routing Type:</dt><dd>4.</dd>
        <dt>Segments Left:</dt><dd>Defined in <xref target="RFC8200"
	sectionFormat="comma" section="4.4"/>.</dd>
        <dt>Last Entry:</dt><dd>contains the index (zero based), in the Segment List,
          of the last element of the Segment List.</dd>
      
          <dt>Flags:</dt><dd>8 bits of flags. <xref target="SRHFLAGSREG" format="default"/> creates an
          IANA registry for new flags to be defined. The following flags are
          defined:</dd></dl>
          <artwork align="left" name="" type="" alt=""><![CDATA[
       0 1 2 3 4 5 6 7  
      +-+-+-+-+-+-+-+-+
      |U U U U U U U U|
      +-+-+-+-+-+-+-+-+
 ]]></artwork>
          <dl newline="false" spacing="normal">
            <dt/>
            <dd>U: Unused and for future use. <bcp14>MUST</bcp14> be 0 on transmission and
              ignored on receipt.</dd>
          </dl>
        <dl spacing="normal">
        <dt>Tag:</dt><dd>Tag a packet as part of a class or group of packets -- e.g.,
          packets sharing the same set of properties. When Tag is not used at the
          source, it <bcp14>MUST</bcp14> be set to zero on transmission. When
	  Tag is not used during SRH processing, it <bcp14>SHOULD</bcp14> be
	  ignored. Tag is not used when
          processing the SID defined in <xref target="pktENDSID" format="default"/>. It may be
          used when processing other SIDs that are not defined in this
          document. The allocation and use of tag is outside the scope of this
          document.</dd>

	  
        <dt>Segment List[0..n]:</dt><dd>128-bit IPv6 addresses representing the nth
          segment in the Segment List. The Segment List is encoded starting
          from the last segment of the SR Policy. That is, the first element of
          the Segment List (Segment List[0]) contains the last segment of the
          SR Policy, the second element contains the penultimate segment of
          the SR Policy, and so on.</dd>
        <dt>TLV:</dt><dd>Type Length Value (TLV) is described in <xref target="TLVS"
	format="default"/>.</dd>
      </dl>
      <t>In the SRH, the Next Header, Hdr Ext Len, Routing Type, and Segments
      Left fields are defined in <xref target="RFC8200"
      sectionFormat="of" section="4.4"/>.
      Based on the constraints in that section, Next Header, Header Ext Len,
      and Routing Type are not mutable while Segments Left is mutable.</t>
      <t>The mutability of the TLV value is defined by the most significant
      bit in the type, as specified in <xref target="TLVS" format="default"/>.</t>
      <t><xref target="ENDSID" format="default"/> defines the mutability of the remaining
      fields in the SRH (Flags, Tag, Segment List) in the context of the SID
      defined in this document.</t>
      <t>New SIDs defined in the future <bcp14>MUST</bcp14> specify the mutability properties
      of the Flags, Tag, and Segment List and indicate how the Hashed Message
      Authentication Code (HMAC) TLV (<xref target="HMACTLV"
      format="default"/>) verification works. Note that, in effect, these
      fields are mutable.</t>
      <t>Consistent with the SR model, the source of the SRH
      always knows how to set the Segment List, Flags, Tag, and TLVs of the SRH
      for use within the SR domain. How it achieves this is outside the scope
      of this document but may be based on topology, available SIDs and their
      mutability properties, the SRH mutability requirements of the
      destination, or any other information.</t>
      <section anchor="TLVS" numbered="true" toc="default">
        <name>SRH TLVs</name>
        <t>This section defines TLVs of the Segment Routing Header.</t>

          
        <t>A TLV provides metadata for segment processing. The only TLVs
        defined in this document are the HMAC (<xref target="HMACTLV" format="default"/>) and
        padding TLVs (<xref target="PADDINGTLV" format="default"/>). While processing the SID
        defined in <xref target="pktENDSID" format="default"/>, all TLVs are ignored unless
        local configuration indicates otherwise (<xref target="TLVPROCESS" format="default"/>).
        Thus, TLV and HMAC support is optional for any implementation;
        however, an implementation adding or parsing TLVs <bcp14>MUST</bcp14> support PAD
        TLVs. Other documents may define additional TLVs and processing rules
        for them.</t>
        <t>TLVs are present when the Hdr Ext Len is greater than (Last
        Entry+1)*2.</t>
        <t>While processing TLVs at a segment endpoint, TLVs <bcp14>MUST</bcp14> be fully
        contained within the SRH as determined by the Hdr Ext
	Len.&nbsp; Detection
        of TLVs exceeding the boundary of the SRH Hdr Ext Len results in an
        ICMP Parameter Problem, Code 0, message to the Source Address,
        pointing to the Hdr Ext Len field of the SRH, and the packet being
        discarded.</t>
        <t>An implementation <bcp14>MAY</bcp14> limit the number and/or length of TLVs it
        processes based on local configuration. It <bcp14>MAY</bcp14> limit:</t>
        <ul spacing="normal">
          <li>the number of consecutive Pad1 (<xref target="PAD1" format="default"/>)
            options to 1. If padding of more than one byte is required, then
            PadN (<xref target="PADN" format="default"/>) should be used.</li>
          <li>The length in PadN to 5.</li>
          <li>The maximum number of non-Pad TLVs to be processed.</li>
          <li>The maximum length of all TLVs to be processed.</li>
        </ul>
        <t> The implementation <bcp14>MAY</bcp14> stop processing additional TLVs in
        the SRH when these configured limits are exceeded.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1 
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-----------------------
|     Type      |    Length     | Variable-length data  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-----------------------
]]></artwork><dl spacing="normal">
        <dt>Type:</dt><dd>An 8-bit codepoint from the &quot;Segment Routing Header TLVs&quot; <xref target="IANA-SRHTLV" format="default"/>.


          
	Unrecognized Types <bcp14>MUST</bcp14> be ignored on receipt.</dd>
        <dt>Length:</dt><dd>The length of the variable-length data field in bytes.</dd>

        <dt>Variable-length data:</dt><dd>data that is specific to the
        Type.</dd></dl>
        <t>Type Length Value (TLV) entries contain <bcp14>OPTIONAL</bcp14> information that
        may be used by the node identified in the Destination Address (DA) of
        the packet.</t>
        <t>Each TLV has its own length, format, and semantic. The codepoint
        allocated (by IANA) to each TLV Type defines both the format and the
        semantic of the information carried in the TLV. Multiple TLVs may be
        encoded in the same SRH.</t>
        <t>The highest-order bit of the TLV type (bit 0) specifies whether or
        not the TLV data of that type can change en route to the packet's
        final destination: </t>
        <ul empty="true" spacing="normal">
          <li>0: TLV data does not change en route</li>
          <li>1: TLV data does change en route</li>
        </ul>
        <t>All TLVs specify their alignment requirements using an xn+y format.
        The xn+y format is defined as per <xref target="RFC8200" format="default"/>. The SR
        source nodes use the xn+y alignment requirements of TLVs and Padding
        TLVs when constructing an SRH.</t>
        <t>The Length field of the TLV is used to skip the TLV while
        inspecting the SRH in case the node doesn't support or recognize the
        Type. The Length defines the TLV length in octets, not including the
        Type and Length fields.</t>
        <t>The following TLVs are defined in this document:</t>
        <ul empty="true" spacing="normal">
          <li>Padding TLVs</li>
          <li>HMAC TLV</li>
        </ul>
        <t>Additional TLVs may be defined in the future.</t>
        <section anchor="PADDINGTLV" numbered="true" toc="default">
          <name>Padding TLVs</name>
          <t>There are two types of Padding TLVs, Pad1 and PadN, and the following
          applies to both:</t>
          <ul empty="true" spacing="normal">
            <li>Padding TLVs are used for meeting the alignment requirement
              of the subsequent TLVs.</li>
            <li>Padding TLVs are used to pad the SRH to a multiple of 8
              octets.</li>
            <li>Padding TLVs are ignored by a node processing the SRH
              TLV.</li>
            <li>Multiple Padding TLVs <bcp14>MAY</bcp14> be used in one SRH.</li>
          </ul>
          <section anchor="PAD1" numbered="true" toc="default">
            <name>Pad1</name>
            <t>Alignment requirement: none</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+ 
  |     Type      |
  +-+-+-+-+-+-+-+-+]]></artwork>
            <dl spacing="normal">
              <dt>Type:</dt><dd>0</dd>
            </dl>
            <t>A single Pad1 TLV <bcp14>MUST</bcp14> be used when a single byte of padding is
            required. A Pad1 TLV <bcp14>MUST NOT</bcp14> be used if more than one consecutive
            byte of padding is required.</t>
          </section>
          <section anchor="PADN" numbered="true" toc="default">
            <name>PadN</name>
            <t>Alignment requirement: none</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
|     Type      |    Length     |      Padding (variable)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//                    Padding (variable)                       //
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            <dl spacing="normal">
              <dt>Type:</dt><dd>4</dd>
              <dt>Length:</dt><dd>0 to 5. The length of the Padding field in bytes.</dd>

              <dt>Padding:</dt><dd>Padding bits have no
                semantic. They <bcp14>MUST</bcp14> be set to 0 on transmission and ignored on
                receipt.</dd>
            </dl>
            <t>The PadN TLV <bcp14>MUST</bcp14> be used when more than one byte of padding is
            required.</t>
          </section>
        </section>
        <section anchor="HMACTLV" numbered="true" toc="default">
          <name>HMAC TLV</name>
          <t>Alignment requirement: 8n</t>
          <t>The keyed Hashed Message Authentication Code (HMAC) TLV is
          <bcp14>OPTIONAL</bcp14> and has the following format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[ 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
|      Type     |     Length    |D|        RESERVED             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      HMAC Key ID (4 octets)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                              //
|                      HMAC (variable)                         //
|                                                              //
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 

where:]]></artwork>
          <dl spacing="normal">
            <dt>Type:</dt><dd>5.</dd>
            <dt>Length:</dt><dd>The length of the variable-length data in bytes.</dd>
            <dt>D:</dt><dd>1 bit. 1 indicates that the Destination Address verification is
              disabled due to use of a reduced Segment List (see <xref
	      target="REDUCED" format="default"/>).</dd>
            <dt>RESERVED:</dt><dd>15 bits. <bcp14>MUST</bcp14> be 0 on transmission.</dd>
            <dt>HMAC Key ID:</dt><dd>A 4-octet opaque number that uniquely
              identifies the pre-shared key and algorithm used to generate the
              HMAC.</dd>
            <dt>HMAC:</dt><dd>Keyed HMAC, in multiples of 8 octets, at most 32
              octets.</dd>
          </dl>
          <t>The HMAC TLV is used to verify that the SRH applied to a packet
          was selected by an authorized party and to ensure that the segment
          list is not modified after generation. This also allows for
          verification that the current segment (by virtue of being in the
          authorized Segment List) is authorized for use. The SR domain
          ensures that the source node is permitted to use the source address in
          the packet via ingress filtering mechanisms as defined in BCP 84
          <xref target="RFC3704" format="default"/> or other strategies as appropriate.</t>
          <section numbered="true" toc="default">
            <name>HMAC Generation and Verification</name>
            <t>Local configuration determines when to check for an HMAC. This
            local configuration is outside the scope of this document. It may
            be based on the active segment at an SR Segment endpoint node, the
            result of an Access Control List (ACL) that considers incoming interface, HMAC Key ID,
            or other packet fields.</t>
            <t>An implementation that supports the generation and verification
            of the HMAC supports the following default behavior, as
            defined in the remainder of this section.</t>
            <t>The HMAC verification begins by checking that the current segment is
            equal to the destination address of the IPv6 header. The check is
            successful when either:</t>
            <ul spacing="normal">
              <li>HMAC D bit is 1 and Segments Left is greater than Last
                Entry, or</li>
              <li>HMAC Segments Left is less than or equal to Last Entry, and the
                destination address is equal to Segment List[Segments
                Left].</li>
            </ul>
            <t>The HMAC field is the output of the HMAC computation as defined
            in <xref target="RFC2104" format="default"/>, using:</t>
            <ul spacing="normal">
              <li>key: The pre-shared key identified by HMAC Key ID</li>
              <li>HMAC algorithm: Identified by the HMAC Key ID</li>
              <li>
                <t>Text: A concatenation of the following fields from the IPv6
                header and the SRH, as it would be received at the node
                verifying the HMAC:</t>
                <ul spacing="normal">
                  <li>IPv6 header: Source address (16 octets)</li>
                  <li>SRH: Last Entry (1 octet)</li>
                  <li>SRH: Flags (1 octet)</li>
                  <li>SRH: HMAC 16 bits following Length</li>
                  <li>SRH: HMAC Key ID (4 octets)</li>
                  <li>SRH: All addresses in the Segment List (variable
                    octets)</li>
                </ul>
              </li>
            </ul>
            <t>The HMAC digest is truncated to 32 octets and placed in the
            HMAC field of the HMAC TLV.</t>
            <t>For HMAC algorithms producing digests less than 32 octets long, the
            digest is placed in the lowest-order octets of the HMAC field.
            Subsequent octets <bcp14>MUST</bcp14> be set to zero such that the HMAC length is
            a multiple of 8 octets.</t>
            <t>If HMAC verification is successful, processing proceeds as
            normal.</t>


            <t>If HMAC verification fails, an ICMP error message (parameter
            problem, error code 0, pointing to the HMAC TLV) <bcp14>SHOULD</bcp14> be
            generated (but rate limited) and logged, and the packet
	    <bcp14>SHOULD</bcp14> be discarded.</t>
          </section>
          <section numbered="true" toc="default">
            <name>HMAC Pre-shared Key Algorithm</name>
            <t>The HMAC Key ID field allows for the simultaneous existence of
            several hash algorithms (SHA-256, SHA3-256 ... or future ones) as
            well as pre-shared keys.</t>
            <t>The HMAC Key ID field is opaque -- i.e., it has neither syntax
            nor semantic except as an identifier of the right combination of
            pre-shared key and hash algorithm.</t>
            <t>At the HMAC TLV generating and verification nodes, the Key ID
            uniquely identifies the pre-shared key and HMAC algorithm.</t>
            <t>At the HMAC TLV generating node, the Text for the HMAC
            computation is set to the IPv6 header fields and SRH fields as
            they would appear at the verification node(s), not necessarily the
            same as the source node sending a packet with the HMAC TLV.</t>
            <t>Pre-Shared key rollover is supported by having two key IDs in
            use while the HMAC TLV generating node and verifying node converge
            to a new key.</t>
            <t>The HMAC TLV generating node may need to revoke an SRH for
            which it previously generated an HMAC. Revocation is achieved by
            allocating a new key and key ID, then rolling over the key ID
            associated with the SRH to be revoked. The HMAC TLV verifying node
            drops packets with the revoked SRH.</t>
            <t>An implementation supporting HMAC can support multiple hash
            functions. An implementation supporting HMAC <bcp14>MUST</bcp14> implement SHA-2
            <xref target="FIPS180-4" format="default"/> in its SHA-256 variant.</t>

              
            <t>The selection of pre-shared key and algorithm and their
            distribution is outside the scope of this document. Some options
            may include: </t>
            <ul spacing="normal">

              <li>setting these items in the configuration of the HMAC generating or verifying
                nodes, either by static configuration or any
		SDN-oriented
                approach</li>
              <li>dynamically using a trusted key distribution protocol such
                as <xref target="RFC6407" format="default"/></li>
            </ul>
            <t>While key management is outside the scope of this document, the
            recommendations of BCP 107 <xref target="RFC4107" format="default"/> should be
            considered when choosing the key management system.</t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="SRNODES" numbered="true" toc="default">
      <name>SR Nodes</name>
      <t>There are different types of nodes that may be involved in segment
      routing networks: SR source nodes that originate packets with a segment in
      the destination address of the IPv6 header, transit nodes that forward
      packets destined to a remote segment, and SR segment endpoint nodes that
      process a local segment in the destination address of an IPv6
      header.</t>
      <section anchor="SOURCE" numbered="true" toc="default">
        <name>SR Source Node</name>
        <t>A SR source node is any node that originates an IPv6 packet with a
        segment (i.e., SRv6 SID) in the destination address of the IPv6 header.
        The packet leaving the SR source node may or may not contain an SRH.
        This includes either: </t>
        <ul spacing="normal">
          <li>A host originating an IPv6 packet, or</li>
          <li>An SR domain ingress router encapsulating a received packet in
            an outer IPv6 header, followed by an optional SRH.</li>
        </ul>
        <t>It is out of the scope of this document to describe the mechanism
	through which a segment in the destination address of
        the IPv6 header and the Segment List in the SRH are derived.</t>
      </section>
      <section anchor="TRANSIT" numbered="true" toc="default">
        <name>Transit Node</name>
        <t>A transit node is any node forwarding an IPv6 packet where the
        destination address of that packet is not locally configured as a
        segment or a local interface. A transit node is not required to be
        capable of processing a segment or SRH.</t>
      </section>
      <section numbered="true" toc="default">
        <name>SR Segment Endpoint Node</name>
        <t>An SR segment endpoint node is any node receiving an IPv6 packet
        where the destination address of that packet is locally configured as
        a segment or local interface.</t>
      </section>
    </section>
    <section anchor="PacketProcessing" numbered="true" toc="default">
      <name>Packet Processing</name>
      <t>This section describes SRv6 packet processing at the SR source,
      Transit, and SR segment endpoint nodes.</t>
      <section anchor="pktSourceNode" numbered="true" toc="default">
        <name>SR Source Node</name>
        <t>A source node steers a packet into an SR Policy. If the SR Policy
        results in a Segment List containing a single segment, and there is no
        need to add information to the SRH flag or add TLV; the DA is set
        to the single Segment List entry, and the SRH <bcp14>MAY</bcp14> be omitted.</t>
        <t>When needed, the SRH is created as follows:</t>
        <dl newline="false" spacing="normal">
          <dt/>
          <dd>The Next Header and Hdr Ext Len fields are set as specified in
            <xref target="RFC8200" format="default"/>.</dd>
          <dt/>
          <dd>The Routing Type field is set to 4.</dd>
          <dt/>
          <dd>The DA of the packet is set with the value of the first
            segment.</dd>
          <dt/>
          <dd>The first element of the SRH Segment List is the ultimate
            segment. The second element is the penultimate segment, and so
            on.</dd>
          <dt/>
          <dd>The Segments Left field is set to n-1, where n is the number of
            elements in the SR Policy.</dd>
          <dt/>
          <dd>The Last Entry field is set to n-1, where n is the number of
            elements in the SR Policy.</dd>
          <dt/>
          <dd>TLVs (including HMAC) may be set according to their
            specification.</dd>
          <dt/>
          <dd>The packet is forwarded toward the packet's Destination Address
            (the first segment).</dd>
        </dl>
        <section anchor="REDUCED" numbered="true" toc="default">
          <name>Reduced SRH</name>
          <t>When a source does not require the entire SID list to be
          preserved in the SRH, a reduced SRH may be used.</t>
          <t>A reduced SRH does not contain the first segment of the related
          SR Policy (the first segment is the one already in the DA of the
          IPv6 header), and the Last Entry field is set to n-2, where n is the
          number of elements in the SR Policy.</t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Transit Node</name>
        <t>As specified in <xref target="RFC8200" format="default"/>, the only node allowed to
        inspect the Routing Extension Header (and therefore the SRH) is the
        node corresponding to the DA of the packet. Any other transit node
        <bcp14>MUST NOT</bcp14> inspect the underneath routing header and <bcp14>MUST</bcp14> forward the
        packet toward the DA according to its IPv6 routing table.</t>
        <t>When a SID is in the destination address of an IPv6 header of a
        packet, it's routed through an IPv6 network as an IPv6 address. SIDs,
        or the prefix(es) covering SIDs, and their reachability may be
        distributed by means outside the scope of this document. For example,
        <xref target="RFC5308" format="default"/> or <xref target="RFC5340" format="default"/> may be used to
        advertise a prefix covering the SIDs on a node.</t>
      </section>
      <section anchor="ENDSID" numbered="true" toc="default">
        <name>SR Segment Endpoint Node</name>
        <t>Without constraining the details of an implementation, the SR
        segment endpoint node creates Forwarding Information Base (FIB)
        entries for its local SIDs.</t>
        <t>When an SRv6-capable node receives an IPv6 packet, it performs a
        longest-prefix-match lookup on the packet's destination address. This
        lookup can return any of the following:</t>
<ul>
    <li>A FIB entry that represents a locally instantiated SRv6 SID</li>
    <li>A FIB entry that represents a local interface, not locally
    instantiated as an SRv6 SID</li>
    <li>A FIB entry that represents a nonlocal route</li>
    <li>No Match</li>
      </ul>
        <section anchor="pktENDSID" numbered="true" toc="default">
          <name>FIB Entry Is a Locally Instantiated SRv6 SID</name>
          <t>This document and section define a single SRv6 SID. Future
          documents may define additional SRv6 SIDs. In such a case, the entire
          content of this section will be defined in that document.</t>
          <t>If the FIB entry represents a locally instantiated SRv6 SID,
          process the next header chain of the IPv6 header as defined in
          <xref target="RFC8200" sectionFormat="of" section="4"/>. <xref
	  target="SRHPROC" format="default"/>
          describes how to process an SRH; <xref target="UPPERHEADER" format="default"/>
          describes how to process an upper-layer header or the absence of a Next
          Header.</t>
          <t>Processing this SID modifies the Segments Left and, if configured
          to process TLVs, it may modify the "variable-length data" of TLV
          types that change en route. Therefore, Segments Left is mutable, and
          TLVs that change en route are mutable. The remainder of the SRH
          (Flags, Tag, Segment List, and TLVs that do not change en route) are
          immutable while processing this SID.</t>
          <section anchor="SRHPROC" numbered="true" toc="default">
            <name>SRH Processing</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
S01. When an SRH is processed {
S02.   If Segments Left is equal to zero {
S03.     Proceed to process the next header in the packet, 
         whose type is identified by the Next Header field in
         the routing header.
S04.   }
S05.   Else {
S06.     If local configuration requires TLV processing {
S07.       Perform TLV processing (see TLV Processing)
S08.     }
S09.     max_last_entry  =  ( Hdr Ext Len /  2 ) - 1
S10.     If  ((Last Entry > max_last_entry) or 
S11.          (Segments Left is greater than (Last Entry+1)) {
S12.       Send an ICMP Parameter Problem, Code 0, message to
           the Source Address, pointing to the Segments Left 
           field, and discard the packet.
S13.     }
S14.     Else {
S15.       Decrement Segments Left by 1.
S16.       Copy Segment List[Segments Left] from the SRH to the
           destination address of the IPv6 header.
S17.       If the IPv6 Hop Limit is less than or equal to 1 {
S18.         Send an ICMP Time Exceeded -- Hop Limit Exceeded in
             Transit message to the Source Address and discard
             the packet.
S19.       }
S20.       Else {
S21.         Decrement the Hop Limit by 1
S22.         Resubmit the packet to the IPv6 module for transmission
             to the new destination.
S23.       }
S24.     }
S25.   }
S26. }
]]></artwork>
 
           <section anchor="TLVPROCESS" numbered="true" toc="default">
             <name>TLV Processing</name>
             <t>Local configuration determines how TLVs are to be processed
             when the Active Segment is a local SID defined in this document.
             The definition of local configuration is outside the scope of
             this document.</t>
             <t>For illustration purposes only, two example local
             configurations that may be associated with a SID are provided
             below.</t>

              <artwork name="" type="" align="left" alt=""><![CDATA[
Example 1:
For any packet received from interface I2
  Skip TLV processing

Example 2:
For any packet received from interface I1
  If first TLV is HMAC {
    Process the HMAC TLV
  }
  Else {
    Discard the packet
  }]]></artwork>
            </section>
          </section>
          <section anchor="UPPERHEADER" numbered="true" toc="default">

            <name>Upper-Layer Header or No Next Header</name>
            <t>When processing the upper-layer header of a packet matching a
            FIB entry locally instantiated as an SRv6 SID defined in this
            document:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
IF (Upper-layer Header is IPv4 or IPv6) and 
    local configuration permits {
  Perform IPv6 decapsulation 
  Resubmit the decapsulated packet to the IPv4 or IPv6 module
}
ELSE {   
  Send an ICMP parameter problem message to the Source Address and
  discard the packet.  Error code (4) "SR Upper-layer 
  Header Error", pointer set to the offset of the upper-layer 
  header.
}
]]></artwork>
            <t>A unique error code allows an SR source node to recognize an
            error in SID processing at an endpoint.</t>
          </section>
        </section>
        <section numbered="true" toc="default">
          <name>FIB Entry Is a Local Interface</name>

            
          <t>If the FIB entry represents a local interface and is not locally
          instantiated as an SRv6 SID, the SRH is processed as follows:</t>
          <ul empty="true" spacing="normal">
            <li>If Segments Left is zero, the node must ignore the routing
              header and proceed to process the next header in the packet,
              whose type is identified by the Next Header field in the routing
              header.</li>
            <li>If Segments Left is non-zero, the node must discard the
              packet and send an ICMP Parameter Problem, Code 0, message to
              the packet's Source Address, pointing to the unrecognized
              Routing Type.</li>
          </ul>
        </section>
        <section numbered="true" toc="default">
          <name>FIB Entry Is a Nonlocal Route</name>
          <t>Processing is not changed by this document.</t>
        </section>
        <section numbered="true" toc="default">
          <name>FIB Entry Is a No Match</name>
          <t>Processing is not changed by this document.</t>
        </section>
      </section>
    </section>
    <section anchor="DEP" numbered="true" toc="default">
      <name>Intra-SR-Domain Deployment Model</name>
      <t>The use of the SIDs exclusively within the SR domain and solely for
      packets of the SR domain is an important deployment model.</t>
      <t>This enables the SR domain to act as a single routing system.</t>
      <t>This section covers:</t>
      <ul spacing="normal">
        <li>securing the SR domain from external attempts to use its SIDs</li>
        <li>using the SR domain as a single system with delegation between
          components</li>
        <li>handling packets of the SR domain</li>
      </ul>
      <section anchor="SECSRDOMAIN" numbered="true" toc="default">
        <name>Securing the SR Domain</name>
        <t>Nodes outside the SR domain are not trusted: they cannot directly
        use the SIDs of the domain. This is enforced by two levels of access
        control lists: </t>
        <ol spacing="normal" type="1">
          <li>
            <t>Any packet entering the SR domain and destined to a SID within
            the SR domain is dropped. This may be realized with the following
            logic. Other methods with equivalent outcome are considered
            compliant: </t>
            <ul spacing="normal">
              <li>Allocate all the SIDs from a block S/s</li>
              <li>Configure each external interface of each edge node of the
                domain with an inbound infrastructure access list (IACL) that
                drops any incoming packet with a destination address in
                S/s</li>
              <li>Failure to implement this method of ingress filtering
                exposes the SR domain to source-routing attacks, as described
                and referenced in <xref target="RFC5095" format="default"/></li>
            </ul>
          </li>
          <li>
            <t>The distributed protection in #1 is complemented with per-node
            protection, dropping packets to SIDs from source addresses outside
            the SR domain. This may be realized with the following logic.
            Other methods with equivalent outcome are considered compliant:
            </t>
            <ul spacing="normal">
              <li>Assign all interface addresses from prefix A/a</li>
              <li>At node k, all SIDs local to k are assigned from prefix
                Sk/sk</li>
              <li>Configure each internal interface of each SR node k in the
                SR domain with an inbound IACL that drops any incoming packet
                with a destination address in Sk/sk if the source address is
                not in A/a.</li>
            </ul>
          </li>
        </ol>
      </section>
      <section anchor="SINGLESYS" numbered="true" toc="default">
        <name>SR Domain as a Single System with Delegation among Components</name>
        <t>All intra-SR-domain packets are of the SR domain. The IPv6 header
        is originated by a node of the SR domain and is destined to a node of
        the SR domain.</t>
        <t>All interdomain packets are encapsulated for the part of the
        packet journey that is within the SR domain. The outer IPv6 header is
        originated by a node of the SR domain and is destined to a node of
        the SR domain.</t>
        <t>As a consequence, any packet within the SR domain is of the SR
        domain.</t>
        <t>The SR domain is a system in which the operator may want to
        distribute or delegate different operations of the outermost header
        to different nodes within the system.</t>
        <t>An operator of an SR domain may choose to delegate SRH addition to
        a host node within the SR domain and delegate validation of the contents of
        any SRH to a more trusted router or switch attached to the host.
        Consider a top-of-rack switch T connected to host H via interface
        I. H receives an SRH (SRH1) with a computed HMAC via some SDN method
        outside the scope of this document. H classifies traffic it sources
        and adds SRH1 to traffic requiring a specific Service Level
	Agreement (SLA). T is configured
        with an IACL on I requiring verification of the SRH for any packet
        destined to the SID block of the SR domain (S/s). T checks and
        verifies that SRH1 is valid and contains an HMAC TLV; T then verifies the
        HMAC.</t>
        <t>An operator of the SR domain may choose to have all segments in the
        SR domain verify the HMAC. This mechanism would verify that the SRH
        Segment List is not modified while traversing the SR domain.</t>
      </section>
      <section anchor="MTU" numbered="true" toc="default">
        <name>MTU Considerations</name>
        <t>An SR domain ingress edge node encapsulates packets traversing the
        SR domain and needs to consider the MTU of the SR domain. Within the
        SR domain, well-known mitigation techniques are <bcp14>RECOMMENDED</bcp14>, such as
        deploying a greater MTU value within the SR domain than at the ingress
        edges.</t>
        <t>Encapsulation with an outer IPv6 header and SRH shares the same MTU
        and fragmentation considerations as IPv6 tunnels described in <xref target="RFC2473" format="default"/>. Further investigation on the limitation of various
        tunneling methods (including IPv6 tunnels) is discussed in <xref
	target="I-D.ietf-intarea-tunnels" format="default"/> and
	<bcp14>SHOULD</bcp14> be considered by
        operators when considering MTU within the SR domain.</t>
      </section>
      <section anchor="ICMP" numbered="true" toc="default">
        <name>ICMP Error Processing</name>
        <t>ICMP error packets generated within the SR domain are sent to
        source nodes within the SR domain. The invoking packet in the ICMP
        error message may contain an SRH. Since the destination address of a
        packet with an SRH changes as each segment is processed, it may not be
        the destination used by the socket or application that generated the
        invoking packet.</t>
        <t>For the source of an invoking packet to process the ICMP error
        message, the ultimate destination address of the IPv6 header may be
        required. The following logic is used to determine the destination
        address for use by protocol-error handlers.</t>
        <ul spacing="normal">
          <li>
            <t>Walk all extension headers of the invoking IPv6 packet to the
            routing extension header preceding the upper-layer header.</t>
            <ul spacing="normal">
              <li>
                <t>If routing header is type 4 Segment Routing Header (SRH)</t>
                <ul spacing="normal">
                  <li>The SID at Segment List[0] may be used as the
                    destination address of the invoking packet.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <t>ICMP errors are then processed by upper-layer transports as defined
        in <xref target="RFC4443" format="default"/>.</t>
        <t>For IP packets encapsulated in an outer IPv6 header, ICMP error
        handling is as defined in <xref target="RFC2473" format="default"/>.</t>
      </section>
      <section anchor="LBECMP" numbered="true" toc="default">
        <name>Load Balancing and ECMP</name>
        <t>For any interdomain packet, the SR source node <bcp14>MUST</bcp14> impose a flow
        label computed based on the inner packet. The computation of the flow
        label is as recommended in <xref target="RFC6438" format="default"/> for the sending
        Tunnel End Point.</t>
        <t>For any intradomain packet, the SR source node <bcp14>SHOULD</bcp14> impose a
        flow label computed as described in <xref target="RFC6437" format="default"/> to assist
        ECMP load balancing at transit nodes incapable of computing a 5-tuple
        beyond the SRH.</t>
        <t>At any transit node within an SR domain, the flow label <bcp14>MUST</bcp14> be
        used as defined in <xref target="RFC6438" format="default"/> to calculate the ECMP hash
        toward the destination address. If a flow label is not used, the transit
        node would likely hash all packets between a pair of SR Edge nodes to
        the same link.</t>
        <t>At an SR segment endpoint node, the flow label <bcp14>MUST</bcp14> be used as
        defined in <xref target="RFC6438" format="default"/> to calculate any ECMP hash used to
        forward the processed packet to the next segment.</t>
      </section>
      <section anchor="other" numbered="true" toc="default">
        <name>Other Deployments</name>
        <t>Other deployment models and their implications on security, MTU,
        HMAC, ICMP error processing, and interaction with other extension
        headers are outside the scope of this document.</t>
      </section>
    </section>
    <section anchor="ILL" numbered="true" toc="default">
      <name>Illustrations</name>
      <t>This section provides illustrations of SRv6 packet processing at SR
      source, transit, and SR segment endpoint nodes.</t>
      <section numbered="true" toc="default">
        <name>Abstract Representation of an SRH</name>
        <t>For a node k, its IPv6 address is represented as Ak, and its SRv6 SID
        is represented as Sk.</t>

        <t>IPv6 headers are represented as the tuple of (source,destination).
        For example, a packet with source address A1 and destination address
        A2 is represented as (A1,A2). The payload of the packet is
        omitted.</t>
        <t>An SR Policy is a list of segments. A list of segments is
        represented as &lt;S1,S2,S3&gt; where S1 is the first SID to visit, S2
        is the second SID to visit, and S3 is the last SID to visit.</t>
        <t>(SA,DA) (S3,S2,S1; SL) represents an IPv6 packet with:</t>
        <ul spacing="normal">
          <li>Source Address SA, Destination Addresses DA, and
            next header SRH.</li>
          <li>SRH with SID list &lt;S1,S2,S3&gt; with SegmentsLeft =
            SL.</li>
          <li>Note the difference between the &lt;&gt; and () symbols.
            &lt;S1,S2,S3&gt; represents a SID list where the leftmost
            segment is the first segment. In contrast, (S3,S2,S1; SL) represents
            the same SID list but encoded in the SRH Segment List format where
            the leftmost segment is the last segment. When referring to an SR
            Policy in a high-level use case, it is simpler to use the &lt;S1,S2,S3&gt; notation. When referring to an illustration of detailed
            behavior, the (S3,S2,S1; SL) notation is more convenient.</li>
        </ul>
        <t>At its SR Policy headend, the Segment List &lt;S1,S2,S3&gt; results
        in SRH (S3,S2,S1; SL=2) represented fully as: </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    Segments Left=2
    Last Entry=2
    Flags=0
    Tag=0
    Segment List[0]=S3
    Segment List[1]=S2
    Segment List[2]=S1]]></artwork>
      </section>
      <section numbered="true" toc="default">
        <name>Example Topology</name>
        <t>The following topology is used in examples below: </t>
        <figure anchor="TOPO1">
          <artwork name="" type="" align="left" alt=""><![CDATA[
        + * * * * * * * * * * * * * * * * * * * * +

        *         [8]                [9]          *
                   |                  |
        *          |                  |           *
[1]----[3]--------[5]----------------[6]---------[4]---[2]
        *          |                  |           *
                   |                  |
        *          |                  |           *
                   +--------[7]-------+
        *                                         *

        + * * * * * * *  SR domain  * * * * * * * +]]></artwork>
        </figure>
        <ul spacing="normal">
          <li>3 and 4 are SR domain edge routers</li>
          <li>5, 6, and 7 are all SR domain routers</li>
          <li>8 and 9 are hosts within the SR domain</li>
          <li>1 and 2 are hosts outside the SR domain</li>
          <li>The SR domain implements ingress filtering as per <xref
	  target="SECSRDOMAIN" format="default"/> and no external packet can
	  enter the domain
            with a destination address equal to a segment of the domain.</li>
        </ul>
      </section>
      <section numbered="true" toc="default">
        <name>SR Source Node</name>
        <section numbered="true" toc="default">
          <name>Intra-SR-Domain Packet</name>
          <t>When host 8 sends a packet to host 9 via an SR Policy
          &lt;S7,A9&gt; the packet is</t>
          <t>P1: (A8,S7)(A9,S7; SL=1)</t>
          <section numbered="true" toc="default">
            <name>Reduced Variant</name>
            <t>When host 8 sends a packet to host 9 via an SR Policy
            &lt;S7,A9&gt; and it wants to use a reduced SRH, the packet is</t>
            <t>P2: (A8,S7)(A9; SL=1)</t>
          </section>
        </section>
        <section numbered="true" toc="default">
          <name>Inter-SR-Domain Packet -- Transit</name>
          <t>When host 1 sends a packet to host 2, the packet is</t>
          <t>P3: (A1,A2)</t>
          <t>The SR domain ingress router 3 receives P3 and steers it to SR
          domain egress router 4 via an SR Policy &lt;S7,S4&gt;. Router 3
          encapsulates the received packet P3 in an outer header with an SRH.
          The packet is</t>
          <t>P4: (A3,S7)(S4,S7; SL=1)(A1,A2)</t>
          <t>If the SR Policy contains only one segment (the egress router 4),
          the ingress router 3 encapsulates P3 into an outer header (A3,S4)
          without SRH. The packet is</t>
          <t>P5: (A3,S4)(A1,A2)</t>
          <section numbered="true" toc="default">
            <name>Reduced Variant</name>
            <t>The SR domain ingress router 3 receives P3 and steers it to SR
            domain egress router 4 via an SR Policy &lt;S7,S4&gt;. If router
            3 wants to use a reduced SRH, it encapsulates the received
            packet P3 in an outer header with a reduced SRH. The packet is</t>
            <t>P6: (A3,S7)(S4; SL=1)(A1,A2)</t>
          </section>
        </section>
        <section numbered="true" toc="default">
          <name>Inter-SR-Domain Packet -- Internal to External</name>
          <t>When host 8 sends a packet to host 1, the packet is encapsulated
          for the portion of its journey within the SR domain. From 8 to 3 the
          packet is</t>
          <t>P7: (A8,S3)(A8,A1)</t>
          <t>In the opposite direction, the packet generated from 1 to 8
          is</t>
          <t>P8: (A1,A8)</t>
          <t>At node 3, P8 is encapsulated for the portion of its journey
          within the SR domain, with the outer header destined to segment S8.
          This results in</t>
          <t>P9: (A3,S8)(A1,A8)</t>
          <t>At node 8, the outer IPv6 header is removed by S8 processing, then
          processed again when received by A8.</t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Transit Node</name>
        <t>Node 5 acts as transit node for packet P1 and sends packet</t>
        <t>P1: (A8,S7)(A9,S7;SL=1)</t>
        <t>on the interface toward node 7.</t>
      </section>
      <section numbered="true" toc="default">
        <name>SR Segment Endpoint Node</name>
        <t>Node 7 receives packet P1 and, using the logic in <xref target="pktENDSID" format="default"/>, sends packet</t>
        <t>P7: (A8,A9)(A9,S7; SL=0)</t>
        <t>on the interface toward router 6.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Delegation of Function with HMAC Verification</name>
        <t>This section describes how a function may be delegated within the
        SR domain. In the following sections, consider a host 8 connected to a
        top of rack 5.</t>
        <section numbered="true" toc="default">
          <name>SID List Verification</name>
          <t>An operator may prefer to apply the SRH at source 8, while 5
          verifies that the SID list is valid.</t>
          <t>For illustration purposes, an SDN controller provides 8 an SRH
          terminating at node 9, with Segment List &lt;S5,S7,S6,A9&gt;, and
          HMAC TLV computed for the SRH. The HMAC key ID and key associated
          with the HMAC TLV is shared with 5. Node 8 does not know the key.
          Node 5 is configured with an IACL applied to the interface connected
          to 8, requiring HMAC verification for any packet destined to
          S/s.</t>
          <t>Node 8 originates packets with the received SRH, including HMAC
          TLV.</t>
          <t>P15: (A8,S5)(A9,S6,S7,S5;SL=3;HMAC)</t>
          <t>Node 5 receives and verifies the HMAC for the SRH, then forwards
          the packet to the next segment</t>
          <t>P16: (A8,S7)(A9,S6,S7,S5;SL=2;HMAC)</t>
          <t>Node 6 receives</t>
          <t>P17: (A8,S6)(A9,S6,S7,S5;SL=1;HMAC)</t>
          <t>Node 9 receives</t>
          <t>P18: (A8,A9)(A9,S6,S7,S5;SL=0;HMAC)</t>
          <t>This use of an HMAC is particularly valuable within an
	  enterprise-based SR domain <xref target="SRN"
	  format="default"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This section reviews security considerations related to the SRH,
      given the SRH processing and deployment models discussed in this
      document.</t>
      <t>As described in <xref target="DEP" format="default"/>, it is necessary to filter
      packets' ingress to the SR domain, destined to SIDs within the SR domain
      (i.e., bearing a SID in the destination address). This ingress filtering
      is via an IACL at SR domain ingress border nodes. Additional protection
      is applied via an IACL at each SR Segment Endpoint node, filtering
      packets not from within the SR domain, destined to SIDs in the SR domain. ACLs are easily supported for small numbers of seldom changing prefixes, making
      summarization important.</t>
      <t>Additionally, ingress filtering of IPv6 source addresses as
      recommended in BCP 38 <xref target="RFC2827" format="default"/> <bcp14>SHOULD</bcp14> be used.</t>
      <section numbered="true" toc="default">
        <name>SR Attacks</name>
        <t>An SR domain implements distributed and per-node protection as
        described in <xref target="SECSRDOMAIN"/>. Additionally, domains deny traffic with
        spoofed addresses by implementing the recommendations in BCP 84 <xref target="RFC3704" format="default"/>.</t>
        <t>Full implementation of the recommended protection blocks the
        attacks documented in <xref target="RFC5095" format="default"/> from outside the SR
        domain, including bypassing filtering devices, reaching
	otherwise-unreachable Internet systems, network topology discovery,
	bandwidth
        exhaustion, and defeating anycast.</t>
        <t>Failure to implement distributed and per-node protection allows
        attackers to bypass filtering devices and exposes the SR domain to
        these attacks.</t>
        <t>Compromised nodes within the SR domain may mount the attacks listed
        above along with other known attacks on IP networks (e.g., DoS/DDoS,
        topology discovery, man-in-the-middle, traffic
        interception/siphoning).</t>
      </section>
      <section numbered="true" toc="default">
        <name>Service Theft</name>
        <t>Service theft is defined as the use of a service offered by the SR
        domain by a node not authorized to use the service.</t>
        <t>Service theft is not a concern within the SR domain, as all SR
        source nodes and SR segment endpoint nodes within the domain are able
        to utilize the services of the domain. If a node outside the SR domain
        learns of segments or a topological service within the SR domain, IACL
        filtering denies access to those segments.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Topology Disclosure</name>
        <t>The SRH is unencrypted and may contain SIDs of some intermediate
        SR nodes in the path towards the destination within the SR domain. If
        packets can be snooped within the SR domain, the SRH may reveal
        topology, traffic flows, and service usage.</t>
        <t>This is applicable within an SR domain, but the disclosure is less
        relevant as an attacker has other means of learning topology, flows,
        and service usage.</t>
      </section>
      <section numbered="true" toc="default">
        <name>ICMP Generation</name>
        <t>The generation of ICMPv6 error messages may be used to attempt
        denial-of-service attacks by sending an error-causing destination
        address or SRH in back-to-back packets. An implementation that
        correctly follows <xref target="RFC4443"
	sectionFormat="of" section="2.4"/> would be
        protected by the ICMPv6 rate-limiting mechanism.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Applicability of AH</name>

        <t>The SR domain is a trusted domain, as defined in <xref
	target="RFC8402" format="default"/>, Sections <xref target="RFC8402" section="2"
	sectionFormat="bare" /> and <xref target="RFC8402" section="8.2"
	sectionFormat="bare" />. The SR	source is trusted
        to add an SRH (optionally verified as having been generated by a
        trusted source via the HMAC TLV in this document), and segments
        advertised within the domain are trusted to be accurate and advertised
        by trusted sources via a secure control plane. As such, the SR domain
        does not rely on the Authentication Header (AH) as defined in <xref target="RFC4302" format="default"/> to secure the SRH.</t>
        <t>The use of SRH with AH by an SR source node and its processing at an SR
        segment endpoint node are not defined in this document. Future
        documents may define use of SRH with AH and its processing.</t>
      </section>
    </section>
    <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document makes the following registrations in the &quot;Internet
      Protocol Version 6 (IPv6) Parameters&quot; &quot;Routing Types&quot; subregistry maintained
      by IANA:</t>


<table anchor="SRH-REG">  
  <name>SRH Registration</name>    
  <thead>
    <tr>
      <th>Value</th>    
      <th>Description</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>          
    <tr>
      <td>4</td>
      <td>Segment Routing Header (SRH)</td>
      <td>This document</td>
    </tr>
  </tbody>
</table>

      <t>This document makes the following registrations in the "Type 4 -
      Parameter Problem" message of the "Internet Control Message Protocol
      version 6 (ICMPv6) Parameters" registry maintained by IANA:</t>

<table anchor="UPPER-LAYER">  
  <name>SR Upper-layer Header Error Registration</name>    
  <thead>
    <tr>
      <th>Code</th>    
      <th>Name</th>
    </tr>
  </thead>
  <tbody>          
    <tr>
      <td>4</td>
      <td>SR Upper-layer Header Error</td>
    </tr>
  </tbody>
</table>


      <section anchor="SRHFLAGSREG" numbered="true" toc="default">
        <name>Segment Routing Header Flags Registry</name>
        <t>This document describes a new IANA-managed registry
        to identify SRH Flags Bits. The registration procedure is "IETF
        Review" <xref target="RFC8126" format="default"/>. The registry name is "Segment Routing Header Flags".
        Flags are 8 bits.</t>
      </section>
      <section anchor="SRHTLVREG" numbered="true" toc="default">
        <name>Segment Routing Header TLVs Registry</name>
        <t>This document describes a new IANA-managed registry
        to identify SRH TLVs. The registration procedure is "IETF Review".
        The registry name is "Segment Routing Header TLVs". A TLV is
        identified through an unsigned 8-bit codepoint value, with assigned
        values 0-127 for TLVs that do not change en route and 128-255 for
        TLVs that may change en route. The following codepoints are defined in
        this document: </t>

<table anchor="TLV-REG">  
  <name>Segment Routing Header TLVs Registry</name>    
  <thead>
    <tr>
      <th>Value</th>   
      <th>Description</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>          
    <tr>
      <td>0</td>
      <td>Pad1 TLV</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Reserved</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Reserved</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Reserved</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>4</td>
      <td>PadN TLV</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>5</td>
      <td>HMAC TLV</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Reserved</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>124-126</td>
      <td>Experimentation and Test</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>127</td>
      <td>Reserved</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>252-254</td>
      <td>Experimentation and Test</td>
      <td>This document</td>
    </tr>
    <tr>
      <td>255</td>
      <td>Reserved</td>
      <td>This document</td>
    </tr>

  </tbody>
</table>

        <t>Values 1, 2, 3, and 6 were defined in draft versions of this specification
        and are Reserved for backwards compatibility with early
        implementations and should not be reassigned. Values 127 and 255 are
        Reserved to allow for expansion of the Type field in future
        specifications, if needed.</t>
      </section>
    </section>

  </middle>
  <back>   

<displayreference target="I-D.ietf-intarea-tunnels" to="INTAREA-TUNNELS"/>



 <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5095.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6407.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8402.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2473.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4302.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2827.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6438.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6437.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4107.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3704.xml"/>



        <reference anchor="FIPS180-4" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
          <front>
            <title>Secure Hash Standard (SHS)</title>
            <author>
              <organization>National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
            <refcontent>FIPS PUB 180-4</refcontent>
            <refcontent>DOI 10.6028/NIST.FIPS.180-4</refcontent>
        </reference>
          <reference anchor="IANA-SRHTLV" target="https://www.iana.org/assignments/ipv6-parameters/">
              <front>
                  <title>Segment Routing Header TLVs</title>
                  <author>
                  <organization>IANA</organization>
                  </author>
              </front>
          </reference>
      </references>

      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>


<!-- I-D.draft-ietf-intarea-tunnels-10; IESG state I-D Exists -->
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-intarea-tunnels-10.xml"/>


        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5340.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5308.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml"/>


        <reference anchor="SRN" target="https://inl.info.ucl.ac.be/system/files/sosr18-final15-embedfonts.pdf">
          <front>
            <title>Software Resolved Networks: Rethinking Enterprise Networks with IPv6 Segment Routing</title>
            <author fullname="David Lebrun"/>
            <author fullname="Mathieu Jadin"/>
            <author fullname="Francois Clad"/>
            <author fullname="Clarence Filsfils"/>
            <author fullname="Olivier Bonaventure"/>
            <date year="2018"/>
          </front>
        </reference>
      </references>
    </references>

    <section anchor="Acknowledgements" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>The authors would like to thank <contact fullname="Ole Troan"/>, <contact fullname="Bob Hinden"/>, <contact fullname="Ron Bonica"/>,
      <contact fullname="Fred Baker"/>, <contact fullname="Brian Carpenter"/>, <contact fullname="Alexandru Petrescu"/>, <contact fullname="Punit Kumar Jaiswal"/>,
      <contact fullname="David Lebrun"/>, <contact fullname="Benjamin Kaduk"/>, <contact fullname="Frank Xialiang"/>, <contact fullname="Mirja Kühlewind"/>, <contact fullname="Roman
      Danyliw"/>, <contact fullname="Joe Touch"/>, and <contact fullname="Magnus Westerlund"/> for their comments to this
      document.</t>
    </section>
    <section anchor="Contributors" numbered="false" toc="default">
      <name>Contributors</name>
      <t><contact fullname="Kamran Raza"/>, <contact fullname="Zafar Ali"/>, <contact fullname="Brian Field"/>, <contact fullname="Daniel Bernier"/>, <contact fullname="Ida Leung"/>, <contact fullname="Jen
      Linkova"/>, <contact fullname="Ebben Aries"/>, <contact fullname="Tomoya Kosugi"/>, <contact fullname="Éric Vyncke"/>, <contact fullname="David Lebrun"/>, <contact fullname="Dirk
      Steinberg"/>, <contact fullname="Robert Raszuk"/>, <contact fullname="Dave Barach"/>, <contact fullname="John Brzozowski"/>, <contact fullname="Pierre Francois"/>,
      <contact fullname="Nagendra Kumar"/>, <contact fullname="Mark Townsley"/>, <contact fullname="Christian Martin"/>, <contact fullname="Roberta Maglione"/>, <contact fullname="James
      Connolly"/>, and <contact fullname="Aloys Augustin"/> contributed to the content of this
      document.</t>
    </section>

    
  </back>
</rfc>
