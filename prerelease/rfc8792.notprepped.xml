<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info"
     ipr="trust200902" docName="draft-ietf-netmod-artwork-folding-12"
     number="8792" obsoletes="" updates="" submissionType="IETF"
     consensus="true" xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 2.40.1 -->

    <front>
    <title abbrev="Handling Long Lines in Content">Handling Long Lines in
    Content of Internet-Drafts and RFCs</title>

    <seriesInfo name="RFC" value="8792"/>
    <author initials="K." surname="Watsen" fullname="Kent Watsen">
      <organization>Watsen Networks</organization>
      <address>
        <email>kent+ietf@watsen.net</email>
      </address>
    </author>
    <author initials="E." surname="Auerswald" fullname="Erik Auerswald">
      <organization>Individual Contributor</organization>
      <address>
        <email>auerswal@unix-ag.uni-kl.de</email>
      </address>
    </author>
    <author initials="A." surname="Farrel" fullname="Adrian Farrel">
      <organization>Old Dog Consulting</organization>
      <address>
        <email>adrian@olddog.co.uk</email>
      </address>
    </author>
    <author initials="Q." surname="Wu" fullname="Qin Wu">
      <organization>Huawei Technologies</organization>
      <address>
        <email>bill.wu@huawei.com</email>
      </address>
    </author>
    <date month="June" year="2020"/>
    <keyword>sourcecode</keyword>
    <keyword>artwork</keyword>
    <abstract>
      <t>This document defines two strategies for handling long lines in width-bounded
          text content.  One strategy, called the "single backslash" strategy, is based on the historical use of a single backslash
          ('\') character to indicate where line-folding has occurred, with the continuation
          occurring with the first character that is not a space character ('&nbsp;') on the next line.  The second
          strategy, called the "double backslash" strategy, extends the first strategy by adding a second backslash character to
          identify where the continuation begins and is thereby able to handle cases not
          supported by the first strategy.  Both strategies use a self-describing header
          enabling automated reconstitution of the original content.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t><xref target="RFC7994" format="default"/> sets out the requirements for
        plain-text RFCs and states that each line of an RFC (and hence of
        an Internet-Draft) must be limited to 72 characters followed by
        the character sequence that denotes an end-of-line (EOL).</t>
      <t>Internet-Drafts and RFCs often include example text or code
        fragments.  Many times, the example text or code exceeds the 72-character line-length limit.  The 'xml2rfc' utility <xref target="xml2rfc" format="default"/>, at the time of this document's publication, does not
        attempt to wrap the content of such inclusions, simply issuing
        a warning whenever lines exceed 69 characters.  Historically,
        there has been no convention recommended by the  RFC Editor in place
        for how to handle long lines in such inclusions, other than advising
        authors to clearly indicate what manipulation has occurred.</t>
      <t>This document defines two strategies for handling long lines in width-bounded
        text content.  One strategy, called the "single backslash" strategy, is based on the historical use of a single backslash
        ('\') character to indicate where line-folding has occurred, with the continuation
        occurring with the first character that is not a space character ('&nbsp;') on the next line.  The second
        strategy, called the "double backslash" strategy, extends the first strategy by adding a second backslash character to
        identify where the continuation begins and is thereby able to handle cases not
        supported by the first strategy.  Both strategies use a self-describing header
        enabling automated reconstitution of the original content.</t>
      <t>The strategies defined in this document work on any text content but are
        primarily intended for a structured sequence of lines, such as would be
        referenced by the &lt;sourcecode&gt; element defined in <xref target="RFC7991" sectionFormat="of" section="2.48"/>, rather than for two-dimensional imagery, such
        as would be referenced by the &lt;artwork&gt; element defined in <xref target="RFC7991" sectionFormat="of" section="2.5"/>.</t>
      <t>Note that text files are represented as lines having their first
        character in column 1, and a line length of N where the last
        character is in the Nth column and is immediately followed by an
        end-of-line character sequence.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Applicability Statement</name>
      <t>The formats and algorithms defined in this document may be used
          in any context, whether for IETF documents or in other situations
          where structured folding is desired.</t>
      <t>Within the IETF, this work primarily targets the xml2rfc v3
          &lt;sourcecode&gt; element (<xref target="RFC7991" sectionFormat="of" section="2.48"/>)
          and the xml2rfc&nbsp;v2 &lt;artwork&gt; element (<xref
          target="RFC7749" sectionFormat="of" section="2.5"/>), which, for
          lack of a better option, is used in xml2rfc v2 for both source code and artwork. This work may
          also be used for the xml2rfc v3 &lt;artwork&gt; element
          (<xref target="RFC7991" sectionFormat="of" section="2.5"/>), but as described in
          <xref target="not-for-art" format="default"/>, it is generally not recommended.</t>
    </section>
    <section anchor="requirements-language" numbered="true" toc="default">
      <name>Requirements Language</name>
       <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
       "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
       "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
       "<bcp14>SHOULD NOT</bcp14>",
       "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
       "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
       are to be interpreted as described in BCP&nbsp;14
       <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
       when, they appear in all capitals, as shown here.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Goals</name>
      <section numbered="true" toc="default">
        <name>Automated Folding of Long Lines in Text Content</name>
        <t>Automated folding of long lines is needed in order to support
            documents that are dynamically compiled to include content with
            potentially unconstrained line lengths.  For instance, the
            build process may wish to include content from other local
            files or content that is dynamically generated by some external process.
            Both of these cases are discussed next.</t>
        <t>Many documents need to include the content from local files (e.g.,
            XML, JSON, ABNF, ASN.1).  Prior to including a file's content,
            the build process <bcp14>SHOULD</bcp14> first validate these source files
            using format-specific validators.  In order for such tooling
            to be able to process the files, the files must be in their
            original/natural state, which may entail them having some long
            lines.  Thus, these source files need to be folded before
            inclusion into the XML document, in order to satisfy 'xml2rfc'
            line-length limits.</t>
        <t>Similarly, documents sometimes contain dynamically generated
            output, typically from an external process operating on the
            same source files discussed in the previous paragraph.  For
            instance, such processes may translate the input format to
            another format, or they may render a report on, or a view of, the input
            file.  In some cases, the dynamically generated output may
            contain lines exceeding the 'xml2rfc' line-length limits.</t>
        <t>In both cases, folding is required and <bcp14>SHOULD</bcp14> be automated 
            to reduce effort and errors resulting from manual processing.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Automated Reconstitution of the Original Text Content</name>
        <t>Automated reconstitution of the exact original text content is needed to
            support validation of text-based content extracted from documents.</t>
        <t>For instance, YANG modules <xref target="RFC7950"
        format="default"/> are already
            extracted from Internet-Drafts and validated as part of the
            submission process.  Additionally, the desire to validate
            instance examples (i.e., XML/JSON documents) contained within
            Internet-Drafts has been discussed <xref
            target="yang-doctors-thread" format="default"/>.
</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Limitations</name>
      <section anchor="not-for-art" numbered="true" toc="default">
        <name>Not Recommended for Graphical Artwork</name>
        <t>While the solution presented in this document works on any
          kind of text-based content, it is most useful on content that
          represents source code (XML, JSON, etc.) or, more generally, on
          content that has not been laid out in two dimensions (e.g., diagrams).</t>
        <t>Fundamentally, the issue is whether the text content remains readable
          once folded.  Text content that is unpredictable is especially susceptible
          to looking bad when folded; falling into this category are most
          Unified Modeling Language (UML) diagrams, YANG tree diagrams, and ASCII art in general.</t>
        <t>It is <bcp14>NOT RECOMMENDED</bcp14> to use the solution presented in
          this document on graphical artwork.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Doesn't Work as Well as Format-Specific Options</name>
        <t>The solution presented in this document works generically
          for all text-based content, as it only views content as plain
          text.  However, various formats sometimes have built-in mechanisms
          that are better suited to prevent long lines.</t>
        <t>For instance, both the 'pyang' and 'yanglint' utilities <xref target="pyang"
          format="default"/> <xref target="yanglint" format="default"/>
          have the command-line option "tree-line-length", which can
          be used to indicate a desired maximum line length when
          generating YANG tree diagrams <xref target="RFC8340" format="default"/>.
</t>
        <t>In another example, some source formats (e.g., YANG
          <xref target="RFC7950" format="default"/>) allow any quoted string to be
          broken up into substrings separated by a concatenation
          character (e.g., '+'), any of which can be on a different
          line.</t>
        <t>It is <bcp14>RECOMMENDED</bcp14> that authors do as much as possible
          within the selected format to avoid long lines.</t>
      </section>
    </section>
    <section anchor="two-strategies" numbered="true" toc="default">
      <name>Two Folding Strategies</name>
      <t>This document defines two nearly identical strategies for folding
          text-based content.
      </t>
      <dl newline="true" spacing="normal">
        <dt>The Single Backslash Strategy ('\'):</dt>
        <dd>Uses a backslash
              ('\') character at the end of the line where folding occurs,
              and assumes that the continuation begins at the first character that is not
              a space character ('&nbsp;') on the following line.</dd>
        <dt>The Double Backslash Strategy ('\\'):</dt>
        <dd>Uses a backslash
              ('\') character at the end of the line where folding occurs,
              and assumes that the continuation begins after a second backslash ('\')
              character on the following line.</dd>
      </dl>
      <section numbered="true" toc="default">
        <name>Comparison</name>
        <t>The first strategy produces output that is more readable. However, (1)&nbsp;it is
            significantly more likely to encounter unfoldable input (e.g.,
            a long line containing only space characters), and (2)&nbsp;for long lines
            that can be folded, automation implementations may encounter
            scenarios that, without special care, will produce errors.</t>
        <t>The second strategy produces output that is less readable, but it is
            unlikely to encounter unfoldable input, there are no long lines
            that cannot be folded, and no special care is required when
            folding a long line.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Recommendation</name>
        <t>It is <bcp14>RECOMMENDED</bcp14> that implementations first attempt to fold
            content using the single backslash strategy and, only in the
            unlikely event that it cannot fold the input or the folding
            logic is unable to cope with a contingency occurring on the
            desired folding column, then fall back to the double backslash
            strategy.</t>
      </section>
    </section>
    <section anchor="single-slash" numbered="true" toc="default">
      <name>The Single Backslash Strategy ('\')</name>
      <section numbered="true" toc="default">
        <name>Folded Structure</name>
        <t>Text content that has been folded as specified by this strategy
           <bcp14>MUST</bcp14> adhere to the following structure.</t>
        <section anchor="single-header" numbered="true" toc="default">
          <name>Header</name>
          <t>The header is two lines long.</t>
          <t>The first line is the following 36-character string; this string 
            <bcp14>MAY</bcp14> be surrounded by any number of printable characters.
            This first line cannot itself be folded.
          </t>
         <artwork name="header1_line1.txt"><![CDATA[
NOTE: '\' line wrapping per RFC 8792]]></artwork>
          <t>The second line is an empty line, containing only the end-of-line
              character sequence.  This line provides visual separation for
              readability.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Body</name>
          <t>The character encoding is the same as the encoding described in <xref target="RFC7994" sectionFormat="of" section="2"/>, except that, per <xref target="RFC7991" format="default"/>,
            tab characters are prohibited.</t>
          <t>Lines that have a backslash ('\') occurring as the last character in
            a line are considered "folded".</t>
          <t>Exceptionally long lines MAY be folded multiple times.</t>
        </section>
      </section>
      <section anchor="single-algorithm" numbered="true" toc="default">
        <name>Algorithm</name>
        <t>This section describes a process for folding and unfolding long
            lines when they are encountered in text content.</t>
        <t>The steps are complete, but implementations <bcp14>MAY</bcp14> achieve the same
            result in other ways.</t>
        <t>When a larger document contains multiple instances of text content
            that may need to be folded or unfolded, another process must
            insert&wj;/extract the individual text content instances to/from the
            larger document prior to utilizing the algorithms described in this
            section.  For example, the 'xiax' utility <xref target="xiax" format="default"/> does this.</t>
        <section anchor="single-folding" numbered="true" toc="default">
          <name>Folding</name>
          <t>Determine the desired maximum line length from input to the
            line-wrapping process, such as from a command-line
            parameter.  If no value is explicitly specified, the value "69"
            <bcp14>SHOULD</bcp14> be used.</t>
          <t>Ensure that the desired maximum line length is not less than
            the minimum header, which is 36 characters.  If the desired
            maximum line length is less than this minimum, exit (this text-based
            content cannot be folded).</t>
          <t>Scan the text content for horizontal tab characters.  If any
            horizontal tab characters appear, either resolve them to space
            characters or exit, forcing the input provider to convert them
            to space characters themselves first.</t>
          <t>Scan the text content to ensure that at least one line exceeds the
            desired maximum.  If no line exceeds the desired maximum, exit
            (this text content does not
            need to be folded).</t>
          <t>Scan the text content to ensure that no existing lines already end with a
            backslash ('\') character, as this could lead to an ambiguous result.
            If such a line is found, and its width is less than the desired maximum,
            then it <bcp14>SHOULD</bcp14> be flagged for "forced" folding (folding even though
            unnecessary). If the folding implementation doesn't support forced
            foldings, it <bcp14>MUST</bcp14> exit.</t>
          <t>If this text content needs to, and can, be folded, insert the header
            described in <xref target="single-header" format="default"/>, ensuring that any additional
            printable characters surrounding the header do not result in a
            line exceeding the desired maximum.</t>
          <t>For each line in the text content, from top to bottom, if the line
              exceeds the desired maximum or requires a forced folding, then fold
              the line by performing the following steps:
          </t>
          <ol spacing="normal" type="1">
            <li>Determine where the fold will occur.  This location <bcp14>MUST</bcp14> be before
                  or at the desired maximum column and <bcp14>MUST NOT</bcp14> be chosen such that
                  the character immediately after the fold is a space ('&nbsp;') character.
                  For forced foldings, the location is between the '\' and the end-of-line sequence.  If no such location can be found, then exit (this
                  text content cannot be folded).</li>
            <li>At the location where the fold is to occur, insert a backslash
                  ('\') character followed by the end-of-line character sequence.</li>
            <li>On the following line, insert any number of space ('&nbsp;') characters,
                  provided that the resulting line does not
exceed the desired maximum.
</li>
          </ol>
          <t>The result of the previous operation is that the next line starts
            with an arbitrary number of space ('&nbsp;') characters, followed by the
            character that was previously occupying the position where the fold
            occurred.</t>
          <t>Continue in this manner until reaching the end of the text content.  Note
            that this algorithm naturally addresses the case where the remainder
            of a folded line is still longer than the desired maximum and, hence,
            needs to be folded again, ad infinitum.</t>
          <t>The process described in this section is illustrated by the "fold_it_1()"
            function in <xref target="script" format="default"/>.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Unfolding</name>
          <t>Scan the beginning of the text content for the header described in
              <xref target="single-header" format="default"/>.  If the header is not present, exit
              (this text content does not need to be unfolded).</t>
          <t>Remove the two-line header from the text content.</t>
          <t>For each line in the text content, from top to bottom, if the line has
            a backslash ('\') character immediately followed by the end-of-line
            character sequence, then the line can be unfolded.
            Remove the backslash ('\') character, the end-of-line character
            sequence, and any leading space ('&nbsp;') characters, which will bring up
            the next line.  Then continue to scan each line in the text content
            starting with the current line (in case it was multiply folded).</t>
          <t>Continue in this manner until reaching the end of the text content.</t>
          <t>The process described in this section is illustrated by the "unfold_it_1()"
            function in <xref target="script" format="default"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="double-slash" numbered="true" toc="default">
      <name>The Double Backslash Strategy ('\\')</name>
      <section numbered="true" toc="default">
        <name>Folded Structure</name>
        <t>Text content that has been folded as specified by this strategy
           <bcp14>MUST</bcp14> adhere to the following structure.</t>
        <section anchor="double-header" numbered="true" toc="default">
          <name>Header</name>
          <t>The header is two lines long.</t>
          <t>The first line is the following 37-character string; this string 
            <bcp14>MAY</bcp14> be surrounded by any number of printable characters.
            This first line cannot itself be folded.
          </t>
        <artwork name="header2_line1.txt"><![CDATA[
NOTE: '\\' line wrapping per RFC 8792]]></artwork>
          <t>The second line is an empty line, containing only the end-of-line
              character sequence.  This line provides visual separation for
              readability.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Body</name>
          <t>The character encoding is the same as the encoding described in <xref target="RFC7994" sectionFormat="of" section="2"/>, except that, per <xref target="RFC7991" format="default"/>,
            tab characters are prohibited.</t>
          <t>Lines that have a backslash ('\') occurring as the last character in
            a line immediately followed by the end-of-line character sequence, when
            the subsequent line starts with a backslash ('\') as the first
            character that is not a space character ('&nbsp;'), are considered "folded".</t>
          <t>Exceptionally long lines MAY be folded multiple times.</t>
        </section>
      </section>
      <section anchor="double-algorithm" numbered="true" toc="default">
        <name>Algorithm</name>
        <t>This section describes a process for folding and unfolding long
            lines when they are encountered in text content.</t>
        <t>The steps are complete, but implementations <bcp14>MAY</bcp14> achieve the same
            result in other ways.</t>
        <t>When a larger document contains multiple instances of text content
            that may need to be folded or unfolded, another process must
            insert&wj;/extract the individual text content instances to/from the
            larger document prior to utilizing the algorithms described in this
            section.  For example, the 'xiax' utility <xref target="xiax" format="default"/> does this.</t>
        <section anchor="double-folding" numbered="true" toc="default">
          <name>Folding</name>
          <t>Determine the desired maximum line length from input to the
            line-wrapping process, such as from a command-line
            parameter.  If no value is explicitly specified, the value "69"
            <bcp14>SHOULD</bcp14> be used.</t>
          <t>Ensure that the desired maximum line length is not less than
            the minimum header, which is 37 characters.  If the desired
            maximum line length is less than this minimum, exit (this text-based
            content cannot be folded).</t>
          <t>Scan the text content for horizontal tab characters.  If any
            horizontal tab characters appear, either resolve them to space
            characters or exit, forcing the input provider to convert them
            to space characters themselves first.</t>
          <t>Scan the text content to see if any line exceeds the desired maximum.
            If no line exceeds the desired maximum, exit (this text content does not
            need to be folded).</t>
          <t>Scan the text content to ensure that no existing lines already end with a
            backslash ('\') character while the subsequent line starts with a
            backslash ('\') character as the first character that is not a
            space character ('&nbsp;'),
            as this could lead to an ambiguous result.  If such a line is found
            and its width is less than the desired maximum, then it <bcp14>SHOULD</bcp14> be
            flagged for forced folding (folding even though unnecessary).  If
            the folding implementation doesn't support forced foldings, it <bcp14>MUST</bcp14>
            exit.</t>
          <t>If this text content needs to, and can, be folded, insert the header
            described in <xref target="double-header" format="default"/>, ensuring that any additional
            printable characters surrounding the header do not result in a
            line exceeding the desired maximum.</t>
          <t>For each line in the text content, from top to bottom, if the line
              exceeds the desired maximum or requires a forced folding, then
              fold the line by performing the following steps:
          </t>
          <ol spacing="normal" type="1">
            <li>Determine where the fold will occur.  This location <bcp14>MUST</bcp14> be before
                  or at the desired maximum column.  For forced foldings, the location
                  is between the '\' and the end-of-line sequence on the first line.</li>
            <li>At the location where the fold is to occur, insert a first
                  backslash ('\') character followed by the end-of-line character
                  sequence.</li>
            <li>On the following line, insert any number of space ('&nbsp;') characters,
                  provided that the resulting line does not
exceed the desired maximum,
                  followed by a second backslash ('\') character.</li>
          </ol>
          <t>The result of the previous operation is that the next line starts
            with an arbitrary number of space ('&nbsp;') characters, followed by a
            backslash ('\') character, immediately followed by the character that
            was previously occupying the position where the fold occurred.</t>
          <t>Continue in this manner until reaching the end of the text content.  Note
            that this algorithm naturally addresses the case where the remainder
            of a folded line is still longer than the desired maximum and, hence,
            needs to be folded again, ad infinitum.</t>
          <t>The process described in this section is illustrated by the "fold_it_2()"
            function in <xref target="script" format="default"/>.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Unfolding</name>
          <t>Scan the beginning of the text content for the header described in
              <xref target="double-header" format="default"/>.  If the header is not present, exit
              (this text content does not need to be unfolded).</t>
          <t>Remove the two-line header from the text content.</t>
          <t>For each line in the text content, from top to bottom, if the line has
            a backslash ('\') character immediately followed by the end-of-line
            character sequence and if the next line has a backslash ('\') character
            as the first character that is not a space character ('&nbsp;'), then the lines can be unfolded.
            Remove the first backslash ('\') character, the end-of-line character
            sequence, any leading space ('&nbsp;') characters, and the second backslash
            ('\') character, which will bring up the next line.  Then, continue to
            scan each line in the text content starting with the current line (in case
            it was multiply folded).</t>
          <t>Continue in this manner until reaching the end of the text content.</t>
          <t>The process described in this section is illustrated by the "unfold_it_2()"
            function in <xref target="script" format="default"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="example" numbered="true" toc="default">
      <name>Examples</name>
      <t>The following self-documenting examples illustrate folded
        text-based content.</t>
      <t>The source text content cannot be presented here, as it would
        again be folded. Alas, only the results can be provided.</t>
      <section numbered="true" toc="default">
        <name>Example Showing Boundary Conditions</name>
        <t>This example illustrates boundary conditions.  The input contains
            seven lines, each line one character longer than the previous line.
            Numbers are used for counting purposes.  The default desired maximum column
            value "69" is used.</t>
        <section numbered="true" toc="default">
          <name>Using '\'</name>
          <artwork name="example-1.1.txt.folded" type="" align="left" alt=""><![CDATA[
========== NOTE: '\' line wrapping per RFC 8792 ===========

123456789012345678901234567890123456789012345678901234567890123456
1234567890123456789012345678901234567890123456789012345678901234567
12345678901234567890123456789012345678901234567890123456789012345678
123456789012345678901234567890123456789012345678901234567890123456789
12345678901234567890123456789012345678901234567890123456789012345678\
90
12345678901234567890123456789012345678901234567890123456789012345678\
901
12345678901234567890123456789012345678901234567890123456789012345678\
9012]]></artwork>
        </section>
        <section numbered="true" toc="default">
          <name>Using '\\'</name>
          <artwork name="example-1.2.txt.folded" type="" align="left" alt=""><![CDATA[
========== NOTE: '\\' line wrapping per RFC 8792 ==========

123456789012345678901234567890123456789012345678901234567890123456
1234567890123456789012345678901234567890123456789012345678901234567
12345678901234567890123456789012345678901234567890123456789012345678
123456789012345678901234567890123456789012345678901234567890123456789
12345678901234567890123456789012345678901234567890123456789012345678\
\90
12345678901234567890123456789012345678901234567890123456789012345678\
\901
12345678901234567890123456789012345678901234567890123456789012345678\
\9012]]></artwork>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Example Showing Multiple Wraps of a Single Line</name>
        <t>This example illustrates what happens when a very long line needs to
            be folded multiple times.  The input contains one line containing
            280 characters.  Numbers are used for counting purposes.  The default
            desired maximum column value "69" is used.</t>
        <section numbered="true" toc="default">
          <name>Using '\'</name>
          <artwork name="example-2.1.txt.folded" type="" align="left" alt=""><![CDATA[
========== NOTE: '\' line wrapping per RFC 8792 ===========

12345678901234567890123456789012345678901234567890123456789012345678\
90123456789012345678901234567890123456789012345678901234567890123456\
78901234567890123456789012345678901234567890123456789012345678901234\
56789012345678901234567890123456789012345678901234567890123456789012\
34567890]]></artwork>
        </section>
        <section numbered="true" toc="default">
          <name>Using '\\'</name>
          <artwork name="example-2.2.txt.folded" type="" align="left" alt=""><![CDATA[
========== NOTE: '\\' line wrapping per RFC 8792 ==========

12345678901234567890123456789012345678901234567890123456789012345678\
\9012345678901234567890123456789012345678901234567890123456789012345\
\6789012345678901234567890123456789012345678901234567890123456789012\
\3456789012345678901234567890123456789012345678901234567890123456789\
\01234567890]]></artwork>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Example Showing "Smart" Folding</name>
        <t>This example illustrates how readability can be improved via "smart"
            folding, whereby folding occurs at format-specific locations and
            format-specific indentations are used.</t>
        <t>The text content was manually folded, since the script in <xref target="script"/>
            does not implement smart folding.</t>
        <t>Note that the headers are surrounded by different printable characters
            than those shown in the script-generated examples.</t>
        <section numbered="true" toc="default">
          <name>Using '\'</name>
<artwork name="example-3.1.txt.folded.smart"><![CDATA[
[NOTE: '\' line wrapping per RFC 8792]

<yang-library
    xmlns="urn:ietf:params:xml:ns:yang:ietf-yang-library"
    xmlns:ds="urn:ietf:params:xml:ns:yang:ietf-datastores">

  <module-set>
    <name>config-modules</name>
    <module>
      <name>ietf-interfaces</name>
      <revision>2018-02-20</revision>
      <namespace>\
        urn:ietf:params:xml:ns:yang:ietf-interfaces\
      </namespace>
    </module>
    ...
  </module-set>
  ...
</yang-library>]]></artwork>
          <t>Below is the equivalent of the above, but it was folded using the
              script in <xref target="script"/>.</t>
          <artwork name="example-3.1.txt.folded.rfcfold"><![CDATA[
========== NOTE: '\' line wrapping per RFC 8792 ===========

<yang-library
    xmlns="urn:ietf:params:xml:ns:yang:ietf-yang-library"
    xmlns:ds="urn:ietf:params:xml:ns:yang:ietf-datastores">

  <module-set>
    <name>config-modules</name>
    <module>
      <name>ietf-interfaces</name>
      <revision>2018-02-20</revision>
      <namespace>urn:ietf:params:xml:ns:yang:ietf-interfaces</namesp\
ace>
    </module>
    ...
  </module-set>
  ...
</yang-library>]]></artwork>
        </section>
        <section numbered="true" toc="default">
          <name>Using '\\'</name>
          <artwork name="example-3.2.txt.folded.smart"><![CDATA[
[NOTE: '\\' line wrapping per RFC 8792]

<yang-library
    xmlns="urn:ietf:params:xml:ns:yang:ietf-yang-library"
    xmlns:ds="urn:ietf:params:xml:ns:yang:ietf-datastores">

  <module-set>
    <name>config-modules</name>
    <module>
      <name>ietf-interfaces</name>
      <revision>2018-02-20</revision>
      <namespace>\
        \urn:ietf:params:xml:ns:yang:ietf-interfaces\
      \</namespace>
    </module>
    ...
  </module-set>
  ...
</yang-library>]]></artwork>
          <t>Below is the equivalent of the above, but it was folded using the
              script in <xref target="script"/>.</t>
          <artwork name="example-3.2.txt.folded.rfcfold"><![CDATA[
========== NOTE: '\\' line wrapping per RFC 8792 ==========

<yang-library
    xmlns="urn:ietf:params:xml:ns:yang:ietf-yang-library"
    xmlns:ds="urn:ietf:params:xml:ns:yang:ietf-datastores">

  <module-set>
    <name>config-modules</name>
    <module>
      <name>ietf-interfaces</name>
      <revision>2018-02-20</revision>
      <namespace>urn:ietf:params:xml:ns:yang:ietf-interfaces</namesp\
\ace>
    </module>
    ...
  </module-set>
  ...
</yang-library>]]></artwork>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Example Showing "Forced" Folding</name>
        <t>This example illustrates how invalid sequences in lines that do not
            have to be folded can be handled via forced folding, whereby the folding
            occurs even though unnecessary.</t>

        <artwork name="example-4.txt" type="" align="left" alt=""><![CDATA[
The following line exceeds a 68-char max and, thus, demands folding:
123456789012345678901234567890123456789012345678901234567890123456789

This line ends with a backslash \

This line ends with a backslash \
\ This line begins with a backslash

The following is an indented 3x3 block of backslashes:
   \\\
   \\\
   \\\]]></artwork>
        <t>The samples below were manually folded, since the script in the appendix
            does not implement forced folding.</t>
        <t>Note that the headers are prefixed by a pound ('#') character, rather 
            than surrounded by 'equals' ('=') characters as shown in the script-generated
            examples.</t>
        <section numbered="true" toc="default">
          <name>Using '\'</name>
          <artwork name="example-4.1.txt.folded.forced" type="" align="left" alt=""><![CDATA[
# NOTE: '\' line wrapping per RFC 8792

The following line exceeds a 68-char max and, thus, demands folding:
1234567890123456789012345678901234567890123456789012345678901234567\
89

This line ends with a backslash \\


This line ends with a backslash \\

\ This line begins with a backslash

The following is an indented 3x3 block of backslashes:
   \\\\

   \\\\

   \\\]]></artwork>
        </section>
        <section numbered="true" toc="default">
          <name>Using '\\'</name>
          <artwork name="example-4.2.txt.folded.forced" type="" align="left" alt=""><![CDATA[
# NOTE: '\\' line wrapping per RFC 8792

The following line exceeds a 68-char max and, thus, demands folding:
1234567890123456789012345678901234567890123456789012345678901234567\
\89

This line ends with a backslash \

This line ends with a backslash \\
\
\ This line begins with a backslash

The following is an indented 3x3 block of backslashes:
   \\\\
   \
   \\\\
   \
   \\\]]></artwork>
        </section>
      </section>
    </section>
    <section anchor="sec-cons" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>This document has no security considerations.</t>
    </section>
    <section anchor="iana-cons" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7991.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      </references>
      <references>
        <name>Informative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7950.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7749.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7994.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8340.xml"/>
        <reference anchor="yang-doctors-thread" target="https://mailarchive.ietf.org/arch/msg/yang-doctors/DCfBqgfZPAD7afzeDFlQ1Xm2X3g">
          <front>
            <title>[yang-doctors] automating yang doctor reviews</title>
            <author initials="K" surname="Watsen" />
            <date day="18" month="April" year="2018" />
          </front>
          <refcontent>message to the yang-doctors mailing list</refcontent>
        </reference>
        <reference anchor="bash" target="https://www.gnu.org/software/bash/manual">
          <front>
            <title>GNU Bash Manual</title>
            <author/>
          </front>
        </reference>
        <reference anchor="xiax" target="https://pypi.org/project/xiax/">
          <front>
            <title>The 'xiax' Python Package</title>
            <author/>
          </front>
        </reference>
        <reference anchor="pyang" target="https://pypi.org/project/pyang/">
          <front>
            <title>pyang</title>
            <author/>
          </front>
        </reference>
        <reference anchor="xml2rfc" target="https://pypi.org/project/xml2rfc/">
          <front>
            <title>xml2rfc</title>
            <author/>
          </front>
        </reference>
        <reference anchor="yanglint" target="https://github.com/CESNET/libyang#yanglint">
          <front>
            <title>yanglint</title>
            <seriesInfo name="commit" value="1b7d73d"/>
            <author/>
            <date month="February" year="2020"/>
          </front>
        </reference>
      </references>
    </references>
      <section anchor="script" numbered="true" toc="default">
      <name>Bash Shell Script: rfcfold</name>
      <t>This non-normative appendix includes a Bash shell script <xref target="bash" format="default"/> 
          that can both fold and unfold text content using both the
          single and double backslash strategies described in Sections&nbsp;<xref target="single-slash" format="counter"/> and <xref target="double-slash" format="counter"/>,
          respectively.  This shell script, called 'rfcfold', is maintained at
      <eref brackets="angle" target="https://github.com/ietf-tools/rfcfold"/>.</t>
      <t>This script is intended to be applied to a single text content
          instance.  If it is desired to fold or unfold text content instances
          within a larger document (e.g., an Internet-Draft or RFC), then
          another tool must be used to extract the content from the larger
          document before utilizing this script.</t>
      <t>For readability purposes, this script forces the minimum
          supported line length to be eight characters longer than the
          raw header text defined in Sections&nbsp;<xref target="single-header" format="counter"/> and
          <xref target="double-header" format="counter"/> so as to ensure that the header
          can be wrapped by a space ('&nbsp;') character and three 'equals' ('=')
          characters on each side of the raw header text.
</t>
      <t>When a tab character is detected in the input file, this script 
          exits with the following error message:</t>
    <ul empty="true">
    <li>Error: infile contains a tab character, which is not allowed.</li>
    </ul>
      <t>This script tests for the availability of GNU awk (gawk), in
          order to test for ASCII-based control characters and non-ASCII
          characters in the input file (see below).  Note that testing
          revealed flaws in the default version of 'awk' on some platforms.
          As this script uses 'gawk' only to issue warning messages,
          if 'gawk' is not found, this script issues the following debug
          message:
      </t>
    <ul empty="true">
    <li>Debug: no GNU awk; skipping checks for special characters.</li>
    </ul>
      <t>When 'gawk' is available (see above) and ASCII-based control
          characters are detected in the input file, this script issues
          the following warning message:</t>
    <ul empty="true">
    <li>Warning: infile contains ASCII control characters (unsupported).</li>
    </ul>
      <t>When 'gawk' is available (see above) and non-ASCII characters
          are detected in the input file, this script issues the following warning
          message:</t>
    <ul empty="true">
    <li>Warning: infile contains non-ASCII characters (unsupported).</li>
    </ul>
      <t>This script does not implement the whitespace-avoidance logic
          described in <xref target="single-folding" format="default"/>.  In
          such a case,
          the script will exit with the following error message:</t>

    <ul empty="true">
    <li>Error: infile has a space character occurring on the
    folding column. This file cannot be folded using the
    '\' strategy.</li>
    </ul>
      <t>While this script can unfold input that contains forced foldings,
          it is unable to fold files that would require forced foldings.  Forced
          folding is described in Sections&nbsp;<xref target="single-folding" format="counter"/> and
          <xref target="double-folding" format="counter"/>.  When being asked to fold a file
          that would require forced folding, the script will instead exit
          with one of the following error messages:</t>
      <t>For '\':</t>
    <ul empty="true">
    <li>Error: infile has a line ending with a '\' character.
    This file cannot be folded using the '\' strategy without
    there being false positives produced in the unfolding
    (i.e., this script does not force-fold such lines, as
    described in RFC 8792).</li>
    </ul>
      <t>For '\\':</t>
    <ul empty="true">
    <li>Error: infile has a line ending with a '\' character
    followed by a '\' character as the first non-space
    character on the next line.  This script cannot fold
    this file using the '\\' strategy without there being
    false positives produced in the unfolding (i.e., this
    script does not force-fold such lines, as described
    in RFC 8792).
</li>
    </ul>
      <t>Shell-level end-of-line backslash ('\') characters have been
          purposely added to the script so as to ensure that the script is
          itself not folded in this document, thus simplifying the ability to
          copy/paste the script for local use.  As should be evident by the
          lack of the mandatory header described in <xref target="single-header" format="default"/>,
          these backslashes do not designate a folded line (e.g., as described
          in <xref target="single-slash" format="default"/>).</t>
      <sourcecode name="rfcfold" type="bash" markers="true"><![CDATA[
#!/bin/bash --posix

# This script may need some adjustments to work on a given system.
# For instance, the utility 'gsed' may need to be installed.
# Also, please be advised that 'bash' (not 'sh') must be used.

# Copyright (c) 2020 IETF Trust, Kent Watsen, and Erik Auerswald.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#
#   * Redistributions in binary form must reproduce the above
#     copyright notice, this list of conditions and the following
#     disclaimer in the documentation and/or other materials
#     provided with the distribution.
#
#   * Neither the name of Internet Society, IETF or IETF Trust, nor
#     the names of specific contributors, may be used to endorse or
#     promote products derived from this software without specific
#     prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

print_usage() {
  printf "\n"
  printf "Folds or unfolds the input text file according to"
  printf " RFC 8792.\n"
  printf "\n"
  printf "Usage: rfcfold [-h] [-d] [-q] [-s <strategy>] [-c <col>]"
  printf " [-r] -i <infile> -o <outfile>\n"
  printf "\n"
  printf "  -s: strategy to use, '1' or '2' (default: try 1,"
  printf " else 2)\n"
  printf "  -c: column to fold on (default: 69)\n"
  printf "  -r: reverses the operation\n"
  printf "  -i: the input filename\n"
  printf "  -o: the output filename\n"
  printf "  -d: show debug messages (unless -q is given)\n"
  printf "  -q: quiet (suppress error and debug messages)\n"
  printf "  -h: show this message\n"
  printf "\n"
  printf "Exit status code: 1 on error, 0 on success, 255 on no-op."
  printf "\n\n"
}

# global vars, do not edit
strategy=0 # auto
debug=0
quiet=0
reversed=0
infile=""
outfile=""
maxcol=69  # default, may be overridden by param
col_gvn=0  # maxcol overridden?
hdr_txt_1="NOTE: '\\' line wrapping per RFC 8792"
hdr_txt_2="NOTE: '\\\\' line wrapping per RFC 8792"
equal_chars="======================================================="
space_chars="                                                       "
temp_dir=""
prog_name='rfcfold'

# functions for diagnostic messages
prog_msg() {
  if [[ "$quiet" -eq 0 ]]; then
    format_string="${prog_name}: $1: %s\n"
    shift
    printf -- "$format_string" "$*" >&2
  fi
}

err() {
  prog_msg 'Error' "$@"
}

warn() {
  prog_msg 'Warning' "$@"
}

dbg() {
  if [[ "$debug" -eq 1 ]]; then
    prog_msg 'Debug' "$@"
  fi
}

# determine name of [g]sed binary
type gsed > /dev/null 2>&1 && SED=gsed || SED=sed

# warn if a non-GNU sed utility is used
"$SED" --version < /dev/null 2> /dev/null | grep -q GNU || \
warn 'not using GNU `sed` (likely cause if an error occurs).'

cleanup() {
  rm -rf "$temp_dir"
}
trap 'cleanup' EXIT

fold_it_1() {
  # ensure input file doesn't contain the fold-sequence already
  if [[ -n "$("$SED" -n '/\\$/p' "$infile")" ]]; then
    err "infile '$infile' has a line ending with a '\\' character."\
        "This script cannot fold this file using the '\\' strategy"\
        "without there being false positives produced in the"\
        "unfolding."
    return 1
  fi

  # where to fold
  foldcol=$(expr "$maxcol" - 1) # for the inserted '\' char

  # ensure input file doesn't contain whitespace on the fold column
  grep -q "^\(.\{$foldcol\}\)\{1,\} " "$infile"
  if [[ $? -eq 0 ]]; then
    err "infile '$infile' has a space character occurring on the"\
        "folding column.  This file cannot be folded using the"\
        "'\\' strategy."
    return 1
  fi

  # center header text
  length=$(expr ${#hdr_txt_1} + 2)
  left_sp=$(expr \( "$maxcol" - "$length" \) / 2)
  right_sp=$(expr "$maxcol" - "$length" - "$left_sp")
  header=$(printf "%.*s %s %.*s" "$left_sp" "$equal_chars"\
                   "$hdr_txt_1" "$right_sp" "$equal_chars")

  # generate outfile
  echo "$header" > "$outfile"
  echo "" >> "$outfile"
  "$SED" 's/\(.\{'"$foldcol"'\}\)\(..\)/\1\\\n\2/;t M;b;:M;P;D;'\
    < "$infile" >> "$outfile" 2> /dev/null
  if [[ $? -ne 0 ]]; then
    return 1
  fi
  return 0
}

fold_it_2() {
  # where to fold
  foldcol=$(expr "$maxcol" - 1) # for the inserted '\' char

  # ensure input file doesn't contain the fold-sequence already
  if [[ -n "$("$SED" -n '/\\$/{N;s/\\\n[ ]*\\/&/p;D}' "$infile")" ]]
  then
    err "infile '$infile' has a line ending with a '\\' character"\
        "followed by a '\\' character as the first non-space"\
        "character on the next line.  This script cannot fold"\
        "this file using the '\\\\' strategy without there being"\
        "false positives produced in the unfolding."
    return 1
  fi

  # center header text
  length=$(expr ${#hdr_txt_2} + 2)
  left_sp=$(expr \( "$maxcol" - "$length" \) / 2)
  right_sp=$(expr "$maxcol" - "$length" - "$left_sp")
  header=$(printf "%.*s %s %.*s" "$left_sp" "$equal_chars"\
                   "$hdr_txt_2" "$right_sp" "$equal_chars")

  # generate outfile
  echo "$header" > "$outfile"
  echo "" >> "$outfile"
  "$SED" 's/\(.\{'"$foldcol"'\}\)\(..\)/\1\\\n\\\2/;t M;b;:M;P;D;'\
    < "$infile" >> "$outfile" 2> /dev/null
  if [[ $? -ne 0 ]]; then
    return 1
  fi
  return 0
}

fold_it() {
  # ensure input file doesn't contain a tab
  grep -q $'\t' "$infile"
  if [[ $? -eq 0 ]]; then
    err "infile '$infile' contains a tab character, which is not"\
        "allowed."
    return 1
  fi

  # folding of input containing ASCII control or non-ASCII characters
  # may result in a wrong folding column and is not supported
  if type gawk > /dev/null 2>&1; then
    env LC_ALL=C gawk '/[\000-\014\016-\037\177]/{exit 1}' "$infile"\
    || warn "infile '$infile' contains ASCII control characters"\
            "(unsupported)."
    env LC_ALL=C gawk '/[^\000-\177]/{exit 1}' "$infile"\
    || warn "infile '$infile' contains non-ASCII characters"\
            "(unsupported)."
  else
    dbg "no GNU awk; skipping checks for special characters."
  fi

  # check if file needs folding
  testcol=$(expr "$maxcol" + 1)
  grep -q ".\{$testcol\}" "$infile"
  if [[ $? -ne 0 ]]; then
    dbg "nothing to do; copying infile to outfile."
    cp "$infile" "$outfile"
    return 255
  fi

  if [[ "$strategy" -eq 1 ]]; then
    fold_it_1
    return $?
  fi
  if [[ "$strategy" -eq 2 ]]; then
    fold_it_2
    return $?
  fi
  quiet_sav="$quiet"
  quiet=1
  fold_it_1
  result=$?
  quiet="$quiet_sav"
  if [[ "$result" -ne 0 ]]; then
    dbg "Folding strategy '1' didn't succeed; trying strategy '2'..."
    fold_it_2
    return $?
  fi
  return 0
}

unfold_it_1() {
  temp_dir=$(mktemp -d)

  # output all but the first two lines (the header) to wip file
  awk "NR>2" "$infile" > "$temp_dir/wip"

  # unfold wip file
  "$SED" '{H;$!d};x;s/^\n//;s/\\\n *//g' "$temp_dir/wip" > "$outfile"

  return 0
}

unfold_it_2() {
  temp_dir=$(mktemp -d)

  # output all but the first two lines (the header) to wip file
  awk "NR>2" "$infile" > "$temp_dir/wip"

  # unfold wip file
  "$SED" '{H;$!d};x;s/^\n//;s/\\\n *\\//g' "$temp_dir/wip"\
    > "$outfile"

  return 0
}

unfold_it() {
  # check if file needs unfolding
  line=$(head -n 1 "$infile")
  line2=$("$SED" -n '2p' "$infile")
  result=$(echo "$line" | fgrep "$hdr_txt_1")
  if [[ $? -eq 0 ]]; then
    if [[ -n "$line2" ]]; then
      err "the second line in '$infile' is not empty."
      return 1
    fi
    unfold_it_1
    return $?
  fi
  result=$(echo "$line" | fgrep "$hdr_txt_2")
  if [[ $? -eq 0 ]]; then
    if [[ -n "$line2" ]]; then
      err "the second line in '$infile' is not empty."
      return 1
    fi
    unfold_it_2
    return $?
  fi
  dbg "nothing to do; copying infile to outfile."
  cp "$infile" "$outfile"
  return 255
}

process_input() {
  while [[ "$1" != "" ]]; do
    if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
      print_usage
      exit 0
    elif [[ "$1" == "-d" ]]; then
      debug=1
    elif [[ "$1" == "-q" ]]; then
      quiet=1
    elif [[ "$1" == "-s" ]]; then
      if [[ "$#" -eq "1" ]]; then
        err "option '-s' needs an argument (use -h for help)."
        exit 1
      fi
      strategy="$2"
      shift
    elif [[ "$1" == "-c" ]]; then
      if [[ "$#" -eq "1" ]]; then
        err "option '-c' needs an argument (use -h for help)."
        exit 1
      fi
      col_gvn=1
      maxcol="$2"
      shift
    elif [[ "$1" == "-r" ]]; then
      reversed=1
    elif [[ "$1" == "-i" ]]; then
      if [[ "$#" -eq "1" ]]; then
        err "option '-i' needs an argument (use -h for help)."
        exit 1
      fi
      infile="$2"
      shift
    elif [[ "$1" == "-o" ]]; then
      if [[ "$#" -eq "1" ]]; then
        err "option '-o' needs an argument (use -h for help)."
        exit 1
      fi
      outfile="$2"
      shift
    else
      warn "ignoring unknown option '$1'."
    fi
    shift
  done

  if [[ -z "$infile" ]]; then
    err "infile parameter missing (use -h for help)."
    exit 1
  fi

  if [[ -z "$outfile" ]]; then
    err "outfile parameter missing (use -h for help)."
    exit 1
  fi

  if [[ ! -f "$infile" ]]; then
    err "specified file '$infile' does not exist."
    exit 1
  fi

  if [[ "$col_gvn" -eq 1 ]] && [[ "$reversed" -eq 1 ]]; then
    warn "'-c' option ignored when unfolding (option '-r')."
  fi

  if [[ "$strategy" -eq 0 ]] || [[ "$strategy" -eq 2 ]]; then
    min_supported=$(expr ${#hdr_txt_2} + 8)
  else
    min_supported=$(expr ${#hdr_txt_1} + 8)
  fi
  if [[ "$maxcol" -lt "$min_supported" ]]; then
    err "the folding column cannot be less than $min_supported."
    exit 1
  fi

  # this is only because the code otherwise runs out of equal_chars
  max_supported=$(expr ${#equal_chars} + 1 + ${#hdr_txt_1} + 1\
       + ${#equal_chars})
  if [[ "$maxcol" -gt "$max_supported" ]]; then
    err "the folding column cannot be more than $max_supported."
    exit 1
  fi
}

main() {
  if [[ "$#" -eq "0" ]]; then
     print_usage
     exit 1
  fi

  process_input "$@"

  if [[ "$reversed" -eq 0 ]]; then
    fold_it
    code=$?
  else
    unfold_it
    code=$?
  fi
  exit "$code"
}

main "$@"]]></sourcecode>

    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>The authors thank the RFC Editor for confirming that there was
          previously no set convention, at the time of this document's publication,
          for handling long lines in source code inclusions, thus instigating this
          work.</t>
      <t>The authors thank the following folks for their various
          contributions while producing this document (sorted by first name):
          <contact fullname="Ben Kaduk"/>,
          <contact fullname="Benoit Claise"/>,
          <contact fullname="Gianmarco Bruno"/>,
          <contact fullname="Italo Busi"/>,
          <contact fullname="Joel Jaeggli"/>,
          <contact fullname="Jonathan Hansford"/>,
          <contact fullname="Lou Berger"/>,
          <contact fullname="Martin Bjorklund"/>,
          and <contact fullname="Rob Wilton"/>.</t>
    </section>
  </back>
</rfc>
