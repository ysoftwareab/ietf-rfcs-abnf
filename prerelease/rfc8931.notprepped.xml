<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">


<rfc  xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF" category="std" consensus="true" ipr='trust200902' tocInclude="true" sortRefs="true" symRefs="true" obsoletes="" updates="4944" xml:lang="en" version="3" docName="draft-ietf-6lo-fragment-recovery-21" number="8931" >

<front>



   <title abbrev='Selective RFRAG'>IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery</title>
   <seriesInfo name="RFC" value="8931"/>
   <author fullname='Pascal Thubert' initials='P.' role='editor' surname='Thubert'>
      <organization abbrev='Cisco Systems'>Cisco Systems, Inc.</organization>
      <address>
         <postal>
            <extaddr>Building D</extaddr>
            <street>45 Allee des Ormes - BP1200 </street>
            <city>MOUGINS - Sophia Antipolis</city>
            <code>06254</code>
            <country>France</country>
         </postal>
         <phone>+33 497 23 26 34</phone>
         <email>pthubert@cisco.com</email>
      </address>
   </author>

   <date year="2020" month="November" />

	<area>Internet</area>

	<workgroup>6lo</workgroup>

        <abstract>
	  <t>
        This document updates RFC 4944 with a protocol that forwards individual fragments
        across a route-over mesh and recovers them end to end, with
	congestion control
        capabilities to protect the network.
	  </t>
	</abstract>
    </front>

    <middle>

	<section anchor='introduction'><name>Introduction</name>


	  <t>

        In most Low-Power and Lossy Network (LLN) applications, the bulk of
        the traffic consists of small chunks of data (on the order of a few bytes
        to a few tens of bytes) at a time. Given that an
        <xref target='IEEE.802.15.4'>IEEE Std 802.15.4</xref>
        frame can carry a payload of 74 bytes or more, fragmentation is
        usually not required. However, and though this happens only
        occasionally, a number of mission-critical applications do require
        the capability to transfer larger chunks of data, for instance, to
        support the firmware upgrade of the LLN nodes or the extraction of logs
        from LLN nodes.
	  </t>
	  <t>
        In the former case, the large chunk of data is
        transferred to the LLN node, whereas in the latter case, the large chunk
        flows away from the LLN node.
        In both cases, the size can be on the
        order of 10 KB or more, and an end-to-end reliable transport
        is required.
	  </t>
	  <t>
	    <xref target='RFC4944'>"Transmission of IPv6 Packets over IEEE 802.15.4
        Networks"</xref> defines the original IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) datagram fragmentation
        mechanism for LLNs. One critical issue with this original design is that
        routing an IPv6 <xref target='RFC8200'/> packet across a route-over mesh
        requires the reassembly of the packet at each hop. <xref target='I-D.ietf-6tisch-architecture'>"An
        Architecture for IPv6 over the TSCH mode of IEEE 802.15.4"</xref>
        indicates that this may cause latency along a path and impact critical
        resources such as memory and battery; to alleviate those
        undesirable effects, it recommends using a 6LoWPAN Fragment Forwarding
        (6LFF) technique.
	    </t>
	    <t>

        <xref target='RFC8930'>
        "On Forwarding 6LoWPAN Fragments over a Multihop IPv6 Network"</xref> specifies the generic behavior
        that all 6LFF techniques including this specification follow, and it presents
        the associated caveats. In particular, the routing information is fully
        indicated in the first fragment, which is always forwarded first.
        With this specification, the first fragment is identified by a Sequence
        of 0 as opposed to a dispatch type in <xref target='RFC4944'/>.
        A state is formed and used to forward all the next fragments along the
        same path. The Datagram_Tag is locally significant to the Layer 2 source
        of the packet and is swapped at each hop; see <xref target='ffc'/>.
        This specification encodes the Datagram_Tag in 1 byte, which will
        saturate if more than 256 datagrams transit in fragmented
        form over a single hop at the same time.
        This is not realistic at the time of this writing.
        Should this happen in a new 6LoWPAN technology, a node will need to use
        several link-layer addresses to increase its indexing capacity.
	  </t>
	  <t>
        <xref target='I-D.ietf-lwig-6lowpan-virtual-reassembly'>
        "Virtual reassembly buffers in 6LoWPAN"</xref> proposes a 6LFF
        technique that is compatible with <xref target='RFC4944'/> without the
        need to define a new protocol.
        However, adding that capability alone to the local implementation of the
        original 6LoWPAN fragmentation would not address the inherent fragility
        of fragmentation (see <xref target='RFC8900'/>), in
        particular, the issues of resources locked on the reassembling endpoint and the wasted
        transmissions due to the loss of a single fragment in a whole datagram.
        <xref target='Kent'/> compares the unreliable delivery of fragments with
        a mechanism it calls "selective acknowledgments" that recovers the loss
        of a fragment individually. The paper illustrates the benefits that can
        be derived from such a method; see Figures 1, 2, and 3 in Section 2.3 of <xref target='Kent'/>.
        <xref target='RFC4944'/> has no selective recovery, and the whole datagram
        fails when one fragment is not delivered to the reassembling  endpoint.
        Constrained memory resources are blocked on the reassembling endpoint until
        it times out, possibly causing the loss of subsequent packets
        that cannot be received for the lack of buffers.
	  </t>
	  <t>
        That problem is exacerbated when forwarding fragments over multiple hops
        since a loss at an intermediate hop will not be discovered by either the
        fragmenting or the reassembling endpoints. Should this happen, the source will keep on sending
        fragments, wasting even more resources in the network since the datagram
        cannot arrive in its entirety, which possibly contributes to the
        condition that caused the loss.
        <xref target='RFC4944'/> is lacking a congestion control to avoid
        participating in a saturation that may have caused the loss of the
        fragment.
        It has no signaling to abort a multi-fragment transmission at any
        time and from either end, and if the
        capability to forward fragments is implemented, clean up the related
        state in the network.

	  </t>
	  <t>
        This specification provides a method to forward fragments over, typically,
        a few hops in a route-over 6LoWPAN mesh and a selective acknowledgment
        to recover individual fragments between 6LoWPAN endpoints. The method
        can help limit the congestion loss in the network and addresses the
        requirements in <xref target='req'/>. Flow control is out of scope since
        the endpoints are expected to be able to store the full datagram.
        Deployments are expected to be managed and homogeneous, and an
        incremental transition requires a flag day.
	  </t>
    </section>


<section><name>Terminology</name>
<section anchor='bcp'><name>Requirements Language</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/>
    when, and only when, they appear in all capitals, as shown here.
        </t>
</section>

 <section anchor='lo'><name>Background</name>
    <t>
	This document uses 6LoWPAN terms and concepts
	that are presented in  <xref target='RFC4919'>"IPv6 over Low-Power
	Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions,
	    Problem Statement, and Goals"</xref>; <xref target='RFC4944'>
	    "Transmission of IPv6 Packets over IEEE 802.15.4 Networks"</xref>; and
        <xref target='RFC6606'> "Problem Statement and Requirements for
		IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN)
		Routing" </xref>.
           </t>
	 <t><xref target='RFC8930'></xref> discusses the generic concept
        of a  Virtual Reassembly Buffer (VRB) and specifies behaviors
        and caveats that are common to a large family of 6LFF techniques
        including the mechanism specified by this document,
        which is fully inherited from that specification.
        It also defines terms used in this document:  Compressed Form,
        Datagram_Tag, Datagram_Size, Fragment_Offset, and
        6LoWPAN Fragment Forwarding endpoint (commonly abbreviated as only
        "endpoint").
    </t>


  <t>
		Past experience with fragmentation has shown that misassociated or lost
        fragments can lead to poor network behavior and, occasionally, trouble
        at the application layer. The reader is encouraged to read
		<xref target='RFC4963'>"IPv4 Reassembly Errors at High Data Rates"</xref>
        and follow the references for more information.
		That experience led to the definition of the <xref target='RFC8201'>"Path
        MTU Discovery for IP version 6"</xref> protocol that limits fragmentation over the
        Internet.
		Specifically, in the case of UDP, valuable additional information can be
        found in <xref target='RFC8085'>"UDP Usage Guidelines"</xref>.
	  </t>

	 <t><xref target='RFC8087'>
        "The Benefits of Using Explicit Congestion Notification (ECN)"</xref>
        provides useful information on the potential benefits and pitfalls of
        using ECN.
           </t>

	 <t>Quoting <xref target='RFC3031'>
        "Multiprotocol Label Switching Architecture"</xref>:
         </t>

        <blockquote>With MPLS, "packets are "labeled" before they are forwarded [along a Label Switched
        Path (LSP)]. At subsequent hops, there is no further analysis of the packet's
        network layer header. Rather, the label is used as an index into a
        table which specifies the next hop, and a new label".</blockquote>


        <t>
        <xref target='RFC8930'/> leverages
        MPLS to forward fragments that actually
        do not have a network-layer header, since the fragmentation occurs below
        IP, and this specification makes it reversible so the reverse path can
        be followed as well.
           </t>

  </section>

 <section anchor='new'><name>Other Terms</name>

	<t>
    This specification uses the following terms:
      </t><dl>

       <dt>RFRAG:</dt><dd>Recoverable Fragment
	    </dd>
       <dt>RFRAG-ACK:</dt><dd>Recoverable Fragment Acknowledgment
	    </dd>
       <dt>RFRAG Acknowledgment Request:</dt><dd>An RFRAG with the
       Acknowledgment Request flag ("X" flag) set.
	    </dd>
       <dt>NULL bitmap:</dt><dd>Refers to a bitmap with all bits set to zero.
	    </dd>
       <dt>FULL bitmap:</dt><dd>Refers to a bitmap with all bits set to one.
	    </dd>
       <dt>Reassembling endpoint:</dt><dd>The receiving endpoint.
	    </dd>
       <dt>Fragmenting endpoint:</dt><dd>The sending endpoint.
	    </dd>
       <dt>Forward direction:</dt><dd>The direction of a path, which is followed by the RFRAG.
	    </dd>
       <dt>Reverse direction:</dt><dd>The reverse direction of a path, which is taken by the
       RFRAG-ACK.
	    </dd>
	  </dl><t>
    </t>
</section>
</section>
    <section><name>Updating RFC 4944</name>

    <t>This specification updates the fragmentation mechanism that is
    specified in <xref target='RFC4944'/> for use in route-over
    LLNs by providing a model where fragments can be forwarded
    end to end across a 6LoWPAN LLN and where fragments that are lost on
    the way can be recovered individually.
    A new format for fragments is introduced, and new dispatch types are defined
    in <xref target='dispatch'/>.
    </t>

    <t>
    <xref target='RFC8138'/> allows modifying the size of a packet en route by
    removing the consumed hops in a compressed Routing Header.
    This requires that
    Fragment_Offset and Datagram_Size (defined in <xref target='RF2'/>) also be
    modified en route, which is difficult to do in the uncompressed form.
    This specification expresses those fields in the compressed form and
    allows modifying them en route easily (more in <xref target='mod'/>).
    </t>

    <t>
    To be consistent with <xref target='RFC6282' sectionFormat="of" section="2"/>, for the
    fragmentation mechanism described in <xref target='RFC4944' sectionFormat="of" section="5.3"/>,
    any header that cannot fit within the first fragment <bcp14>MUST NOT</bcp14> be compressed
    when using the fragmentation mechanism described in this specification.
    </t>

    </section>

    <section><name>Extending RFC 8930</name>

    <t>This specification implements the generic 6LFF technique defined in
    <xref target='RFC8930'></xref> and provides end-to-end fragment
    recovery and congestion control mechanisms.
    </t>


    <section><name>Slack in the First Fragment</name>

    <t>
    <xref target='RFC8930'/> allows for a refragmentation operation
    in intermediate nodes, whereby the trailing bytes from a given fragment may be
    left in the VRB to be added as the heading bytes in the next fragment.
    This solves the case when the outgoing fragment needs more space than the incoming fragment; that case may arise when
    the 6LoWPAN header compression is not as efficient on the outgoing link or
    if the Link MTU is reduced.
    </t>
    <t>
    This specification cannot allow that refragmentation operation since
    the fragments are recovered end to end based on a sequence number. The
    Fragment_Size <bcp14>MUST</bcp14> be tailored to fit the minimal MTU along the path, and
    the first fragment that contains a 6LoWPAN compressed header <bcp14>MUST</bcp14> have enough
    slack to enable a less-efficient compression in the next hops to still
    fit within the Link MTU.
    </t>
    <t>
    For instance, if the fragmenting endpoint is also the 6LoWPAN compression endpoint, it will
    elide the Interface ID (IID) of the source IPv6 address when it matches the link-layer address
    <xref target='RFC6282'/>. In that case, it <bcp14>MUST</bcp14> leave slack in the first fragment as the if MTU on the first hop was 8 bytes less, so the next hop can expand the IID within the same fragment within MTU.
      </t>

    </section>


    <section anchor='gap'><name>Gap between Frames</name>
    <t><xref target='RFC8930'/> requires that a
    configurable interval of time be inserted between transmissions to the same
    next hop and, in particular, between fragments of a same datagram.
    In the case of half duplex interfaces, this inter-frame gap ensures that the
    next hop is done forwarding the previous frame and is capable of receiving
    the next one.
    </t><t>
    In the case of a mesh operating at a single frequency with omnidirectional
    antennas, a larger inter-frame gap is required to protect the frame against
    hidden terminal collisions with the previous frame of the same flow that is
    still progressing along a common path.
    </t><t>
    The inter-frame gap is useful even for unfragmented datagrams, but it
    becomes a necessity for fragments that are typically generated in a fast
    sequence and are all sent over the exact same path.
    </t>
    </section>


    <section><name>Congestion Control</name>
    <t>
    The inter-frame gap is the only protection that
    <xref target='RFC8930'/> imposes by default. This
    document enables grouping fragments in windows and requesting intermediate
    acknowledgments, so the number of in-flight fragments can be bounded.
    This document also adds an
    ECN mechanism that can be used to protect the network by adapting the
    size of the window, the size of the fragments, and/or the inter-frame gap.
    </t><t>
    This specification enables the fragmenting endpoint to apply a congestion control
    mechanism to tune those parameters, but the mechanism itself is out of scope.
    In most cases, the expectation is that most datagrams will require only a
    few fragments, and that only the last fragment will be acknowledged. A
    basic implementation of the fragmenting endpoint is NOT <bcp14>REQUIRED</bcp14> to vary
    the size of the window, the duration of the inter-frame gap, or the size of a
    fragment in the middle of the transmission of a datagram, and it <bcp14>MAY</bcp14> ignore
    the ECN signal or simply reset the window to 1 (see <xref target='onECN'/>)
    until the end of this datagram upon detecting a congestion.
    </t><t>
    An intermediate node that experiences a congestion <bcp14>MAY</bcp14> set the ECN bit in a
    fragment, and the reassembling endpoint echoes the ECN bit at most once at
    the next opportunity to acknowledge back.
    </t><t>
    The size of the fragments is typically computed from the
    Link MTU to maximize the size of the resulting  frames.
    The size of the window and the duration of the inter-frame
    gap <bcp14>SHOULD</bcp14> be configurable, to reduce the chances of congestion and to
    follow the general recommendations
    in <xref target='RFC8930'/>, respectively.
    </t>
    </section>

    <section anchor='mod'><name>Modifying the First Fragment</name>

    <t>
    The compression of the hop limit, of the source and destination addresses
    in the IPv6 header, and of the Routing Header, which are all in the first fragment, may change en route in a
    route-over mesh LLN.
    If the size of the first fragment is modified, then the intermediate node
    <bcp14>MUST</bcp14> adapt the Datagram_Size, encoded in the Fragment_Size field,
    to reflect that difference.
    </t>

    <t>
    The intermediate node <bcp14>MUST</bcp14> also save the difference of Datagram_Size of the
    first fragment in the VRB and add it to the Fragment_Offset of all the
    subsequent fragments that it forwards for that datagram. In the case of a Source Routing 
    Header 6LoWPAN Routing Header (SRH-6LoRH)
    <xref target='RFC8138'/> being consumed and thus reduced, that
    difference is negative, meaning that the Fragment_Offset is decremented by
    the number of bytes that were consumed.
    </t>
    </section>


    </section>

<section anchor='dispatch'><name>New Dispatch Types and Headers</name>

    <t> This document specifies an alternative to the 6LoWPAN fragmentation
    sub-layer <xref target='RFC4944'/> to emulate a Link MTU up to 2048 bytes
    for the upper layer, which can be the 6LoWPAN header compression sub-layer
    that is defined in <xref target='RFC6282'>"Compression Format for IPv6
    Datagrams over IEEE 802.15.4-Based Networks"</xref>. This specification also provides a reliable
    transmission of the fragments over a multi-hop 6LoWPAN route-over mesh
    network and a minimal congestion control to reduce the chances of congestion loss.
    </t>
	<t>
     A 6LoWPAN Fragment Forwarding <xref target='RFC8930'/>
     technique derived from MPLS enables the forwarding of individual fragments
     across a 6LoWPAN route-over mesh without reassembly at each hop.
     The Datagram_Tag is used as a label; it is locally unique to the
     node that owns the source link-layer address of the fragment, so together
     the link-layer address and the label can identify the fragment globally
     within the lifetime of the datagram.
     A node may build the Datagram_Tag in its own locally significant way,
     as long as the chosen Datagram_Tag stays unique to the particular datagram
     for its lifetime.
     The result is that the label does not need to be globally unique, but
     it must be swapped at each hop as the source link-layer address changes.
    </t>


	<t>
	In the following sections, a Datagram_Tag extends the semantics defined in
    "Fragmentation Type and Header" (see <xref target='RFC4944' sectionFormat="of" section="5.3"/>).
    The Datagram_Tag is a locally unique identifier for the datagram from the
    perspective of the sender. This means that the Datagram_Tag identifies a
    datagram uniquely in the network when associated with the source of the
    datagram. As the datagram gets forwarded, the source changes, and the
    Datagram_Tag must be swapped as detailed in
    <xref target='RFC8930'/>.
	</t>

    	<t>This specification extends <xref target='RFC4944'></xref>
	with two new dispatch types for RFRAG and the RFRAG-ACK that is received back.

    The new 6LoWPAN dispatch types are taken from
    <xref target='RFC8025'/>, as indicated in <xref target='difig'/>
    of <xref target='ianacon'/>.</t>

	<section anchor='RF2'><name>Recoverable Fragment Dispatch Type and Header </name>

	<t>
	In this specification, if the packet is compressed, the size and offset
    of the fragments are expressed with respect to the compressed form of the
    packet, as opposed to the uncompressed (native) form.
    </t>	<t>
	The format of the fragment header is shown in <xref target='RFfigalt'/>.
    It is the same for all fragments even though the Fragment_Offset is overloaded.
    The format has a length and an offset, as
    well as a Sequence field. This would be redundant if the offset was computed
    as the product of the Sequence by the length, but this is not the case.
    The position of a fragment in the
    reassembly buffer is correlated with neither the value of the Sequence
    field nor the order in which the fragments are received.
    This enables splitting fragments to cope with an MTU deduction; see the example of
    fragment Sequence 5 that is retried end to end as smaller fragment Sequences 13
    and 14 in <xref target='ura'/>.
    </t>    <t>
    The first fragment is recognized by a Sequence of 0; it carries its
    Fragment_Size and the Datagram_Size of the compressed packet before it is
    fragmented, whereas the other fragments carry their Fragment_Size and
    Fragment_Offset. The last fragment
    for a datagram is recognized when its Fragment_Offset and its Fragment_Size
    add up to the stored Datagram_Size of the packet identified by the
    sender link-layer address and the Datagram_Tag.
    </t>

<figure anchor='RFfigalt'><name>RFRAG Dispatch Type and Header</name>
<artwork align='center'>
                           1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                    |1 1 1 0 1 0 0|E|  Datagram_Tag |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |X| Sequence|   Fragment_Size   |       Fragment_Offset         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                             X set == Ack-Request
</artwork>
</figure>

	  <dl>

	   <dt>X:</dt><dd>1 bit; Ack-Request. When set, the fragmenting endpoint requires an
       RFRAG Acknowledgment from the reassembling endpoint.
	    </dd>
        <dt>E:</dt><dd>1 bit; Explicit Congestion Notification. The "E"
       flag is cleared by the source of the fragment and set by intermediate
       routers to signal that this fragment experienced congestion along
       its path.
	    </dd>
	   <dt>Fragment_Size:</dt><dd>10-bit unsigned integer. The size of this
       fragment in a unit that depends on link-layer technology. Unless
       overridden by a more specific specification, that unit is the byte,
       which allows fragments up to 1023 bytes.

	    </dd>

	   <dt>Datagram_Tag:</dt><dd>8 bits. An identifier of the datagram that
       is locally unique to the link-layer sender.
	    </dd>
	   <dt>Sequence:</dt><dd>5-bit unsigned integer.
       The sequence number of the fragment in the acknowledgment bitmap.
       Fragments are numbered as [0..N], where N is in [0..31].
       A Sequence of 0 indicates the first fragment in a datagram, but non-zero
       values are not indicative of the position in the reassembly buffer.
	    </dd>
	   <dt>Fragment_Offset:</dt>
       <dd>
       <t>16-bit unsigned integer.</t>
       <t>
       When the Fragment_Offset is set to a non-zero value, its semantics depend
       on the value of the Sequence field as follows:
       </t>
       <ul spacing='normal'>
       <li>
       For a first fragment (i.e., with a Sequence of 0), this field indicates
       the Datagram_Size of the compressed datagram, to help the reassembling endpoint
       allocate an adapted buffer for the reception and reassembly operations.
       The fragment may be stored for local reassembly. Alternatively, it may be
       routed based on the destination IPv6 address. In that case, a VRB state
       must be installed as described in <xref target='ff'/>.
       </li>
       <li>
       When the Sequence is not 0, this field indicates the offset of the
       fragment in the compressed form of the datagram. The fragment may be
       added to a local reassembly buffer or forwarded based on an existing
       VRB as described in <xref target='nf'/>.
       </li>
	    </ul>
        <t>
       A Fragment_Offset that is set to a value of 0 indicates
       an abort condition, and all states regarding the datagram should be
       cleaned up once the processing of the fragment is complete;
       the processing of the fragment depends on whether there is a VRB already
       established for this datagram and if the next hop is still reachable:
       </t>
       <ul spacing='normal'>
       <li>
       if a VRB already exists and the next hop is still reachable, the fragment
       is to be
       forwarded along the associated LSP
       as described in <xref target='nf'/>, without checking the value
       of the Sequence field.
       </li><li>
       else, if the Sequence is 0, then the fragment is to be routed as
       described in <xref target='ff'/>, but no state is conserved afterwards.
       In that case, the session, if it exists, is aborted, and the packet is
       also forwarded in an attempt to clean up the next hops along the
       path indicated by the IPv6 header (possibly including a Routing Header).
       </li><li>
       else (the Sequence is non-zero and either no VRB exists or the next hop
       is unavailable), the fragment cannot be forwarded or routed; the fragment
       is discarded and an abort RFRAG-ACK
       is sent back to the source as described in <xref target='nf'/>.
       </li>
	    </ul>
        <t>
       </t>
	    </dd>
	    </dl>
    <t>
	Recoverable Fragments are sequenced, and a bitmap is used in the RFRAG
    Acknowledgment to indicate the received fragments by setting the individual
    bits that correspond to their sequence.
	</t>
    <t>
    There is no requirement on the reassembling endpoint to check that the
    received fragments are consecutive and non-overlapping.

    This may be useful, in particular, in the case where the MTU changes and a
    fragment Sequence is retried with a smaller Fragment_Size, with the remainder of
    the original fragment being retried with new Sequence values.

    The fragmenting endpoint knows that the datagram is fully received
    when the acknowledged fragments cover the whole datagram, which is implied
    by a FULL bitmap.
    </t>

    </section>

	<section anchor='ackfrag'><name>RFRAG Acknowledgment Dispatch Type and Header</name>
	<t>This specification also defines a 4-byte RFRAG Acknowledgment Bitmap
       that is used by the reassembling endpoint
       to selectively confirm the reception of individual fragments.
       A given offset in the bitmap maps one to one with a given sequence number
       and indicates which fragment is acknowledged as follows:
    </t>
	<figure anchor='dCack3'><name>RFRAG Acknowledgment Bitmap Encoding</name>
<artwork align='center'>
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           RFRAG Acknowledgment Bitmap                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ^                 ^
     |                 |    bitmap indicating whether:
     |                 +----- Fragment with Sequence 9 was received
     +----------------------- Fragment with Sequence 0 was received
</artwork>
</figure>
<t>    <xref target='dCack2'/> shows an example RFRAG Acknowledgment Bitmap that
       indicates that all fragments from Sequence 0 to 20 were received, except
       for fragments 1, 2, and 16, which were lost and must be retried.
</t>
<figure anchor='dCack2'><name>Example RFRAG Acknowledgment Bitmap</name>
<artwork align='center'>
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|0|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1|1|1|1|0|0|0|0|0|0|0|0|0|0|0|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
	<t>The RFRAG Acknowledgment Bitmap is included in
	an RFRAG Acknowledgment header, as follows:
	</t>
	<figure anchor='ackfig'><name>RFRAG Acknowledgment Dispatch Type and Header</name>
<artwork align='center'>

                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                    |1 1 1 0 1 0 1|E|  Datagram_Tag |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          RFRAG Acknowledgment Bitmap (32 bits)                |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 </artwork>
</figure>
  <dl>


	   <dt>E:</dt><dd>1 bit; Explicit Congestion Notification Echo.</dd>

	    <dt></dt><dd>When set, the fragmenting endpoint indicates that at least one of the acknowledged fragments
		was received with an Explicit Congestion Notification, indicating that the
		path followed by the fragments is subject to congestion. See more details in
        <xref target='onECN'/>.
	    </dd>

	   <dt>Datagram_Tag:</dt><dd>8 bits; an identifier of the datagram that
       is locally unique to the link-layer recipient.
	    </dd>
	   <dt>RFRAG Acknowledgment Bitmap:</dt>
       <dd>An RFRAG Acknowledgment Bitmap, whereby setting the bit at offset x
        indicates that fragment x was received, as shown in <xref target='dCack3'/>.
        A NULL bitmap indicates that the fragmentation process is aborted.
        A FULL bitmap indicates that the fragmentation process is complete;
        all fragments were received at the reassembly endpoint.
	    </dd>
	    </dl>
    </section>

    </section>


    <section anchor='ffc'><name>Fragment Recovery</name>

	<t>
	The RFRAG header is used to transport
    a fragment and optionally request an RFRAG-ACK that
    confirms the reception of one or more fragments.
    An RFRAG-ACK is carried as a standalone fragment header (i.e.,
    with no 6LoWPAN payload) in a message that is propagated back to the
    fragmenting endpoint.

    To achieve this, each hop that performed an MPLS-like operation on fragments
    reverses that operation for the RFRAG-ACK by sending a frame from the next
    hop to the previous hop as known by its link-layer address in the VRB.
    The Datagram_Tag in the RFRAG-ACK is unique to the reassembling endpoint and is enough
    information for an intermediate hop to locate the VRB that contains the
    Datagram_Tag used by the previous hop and the Layer 2 information associated with it (interface and link-layer address).
	</t>

	<t>	The fragmenting endpoint (i.e., the node that fragments the packets at the 6LoWPAN level)
     also controls the number of acknowledgments by setting the Ack-Request flag in the RFRAG packets.
        </t>
	<t>
    The fragmenting endpoint may set the Ack-Request flag on any fragment to perform
    congestion control by limiting the number of outstanding fragments, which
    are the fragments that have been sent but for which reception or loss
    was not positively confirmed by the reassembling endpoint. The maximum
    number of outstanding fragments is controlled by the Window-Size. It is configurable and
    may vary in case of ECN notification. When the endpoint that
    reassembles the packets at the 6LoWPAN level receives a fragment with the Ack-Request flag set, it <bcp14>MUST</bcp14> send an
    RFRAG-ACK back to the originator to confirm reception of all the
    fragments it has received so far.
	</t>
	<t>
    The Ack-Request ("X") set in an RFRAG marks the end of a window. This flag
    <bcp14>MUST</bcp14> be set on the last fragment if the fragmenting endpoint wishes to perform
    an automatic repeat request (ARQ) process for the datagram,
    and it <bcp14>MAY</bcp14> be set in any intermediate fragment for the purpose of congestion control.
	</t>
	<t>
    This ARQ process <bcp14>MUST</bcp14> be protected by a Retransmission Timeout (RTO) timer,
    and the fragment that carries the "X"
    flag <bcp14>MAY</bcp14> be retried upon a timeout for a configurable number of times (see
    <xref target='protp'/>) with an exponential backoff.
    Upon exhaustion of the retries, the fragmenting endpoint may either abort the
    transmission of the datagram or resend the first fragment with an "X" flag
    set in order to establish a new path for the datagram and obtain the list of
    fragments that were received over the old path in the acknowledgment bitmap.
	When the fragmenting endpoint knows that an underlying link-layer
    mechanism protects the fragments, it may refrain from using the RFRAG
    Acknowledgment mechanism and never set the Ack-Request bit.
    </t>

	<t>The reassembling endpoint <bcp14>MAY</bcp14> issue unsolicited acknowledgments.
    An unsolicited acknowledgment signals to the fragmenting endpoint that it
    can resume sending in case it has reached its maximum number
	of outstanding fragments. Another use is to inform the fragmenting endpoint
    that the reassembling endpoint aborted the processing of an individual
    datagram.
	</t>
	<t>
    The RFRAG Acknowledgment carries an ECN indication for congestion
    control (see <xref target='onECN'/>).
    The reassembling endpoint of a fragment with the "E" (ECN) flag set <bcp14>MUST</bcp14>
    echo that information at most once by setting the "E" (ECN) flag
    in the next RFRAG-ACK.
	</t>
	<t>
	In order to protect the datagram, the fragmenting endpoint transfers a controlled number
    of fragments and flags to the last
	fragment of a window with an RFRAG Acknowledgment Request. The reassembling endpoint <bcp14>MUST</bcp14>
    acknowledge a fragment with the acknowledgment request bit set.
    If any fragment immediately preceding
	an acknowledgment request is still missing, the reassembling endpoint <bcp14>MAY</bcp14> intentionally
	delay its acknowledgment to allow in-transit fragments to arrive.
    Because it might defeat the round-trip time computation, delaying the
    acknowledgment should be configurable and not enabled by default.

	</t>
    <t>
    When enough fragments are received to cover the whole datagram, the reassembling endpoint reconstructs
    the packet, passes it to the upper layer, sends an RFRAG-ACK on
    the reverse path with a FULL bitmap, and arms a short timer, e.g.,
    on the order of an average round-trip time in the network. The FULL bitmap
    is used as opposed to a bitmap that acknowledges only the received fragments
    to let the intermediate nodes know that the datagram is fully received.
    As the timer runs, the reassembling endpoint absorbs the fragments that were
    still in flight for that datagram without creating a new state, acknowledging
    the ones that bear an Ack-Request with an FRAG Acknowledgment and the
    FULL bitmap.
    The reassembling endpoint aborts the communication if fragments with a
    matching source and Datagram-Tag continue to be received
    after the timer expires.</t>

	<t>
    Note that acknowledgments might consume precious resources, so the use of
    unsolicited acknowledgments <bcp14>SHOULD</bcp14> be configurable and not enabled by
    default.
	</t>
	<t>
    An observation is that streamlining the forwarding of fragments generally
    reduces the latency over the LLN mesh, providing room for retries within
    existing upper-layer reliability mechanisms.
	The fragmenting endpoint protects the transmission over the LLN mesh with a retry timer
    that is configured for a use case and may be adapted dynamically, e.g.,
    according to the method detailed in <xref target='RFC6298'/>.
    It is expected that the upper-layer retry mechanism obeys the recommendations in
    <xref target='RFC8085'/>, in which case a single
    round of fragment recovery should fit within the upper-layer recovery timers.
	</t>
	<t>
    Fragments <bcp14>MUST</bcp14> be sent in a round-robin fashion: the sender <bcp14>MUST</bcp14> send all
    the fragments for a first time before it retries any lost fragment; lost
    fragments <bcp14>MUST</bcp14> be retried in sequence, oldest first. This mechanism
    enables the receiver to acknowledge fragments that were delayed in
    the network before they are retried.

	</t>

	<t>
    When a single radio frequency is used by contiguous hops, the fragmenting endpoint <bcp14>SHOULD</bcp14> insert a delay between the frames (e.g., carrying fragments) that are sent to the same next hop. The delay <bcp14>SHOULD</bcp14> cover multiple transmissions so as to let a frame progress a few hops and avoid hidden terminal issues.
    This precaution is not required on channel hopping technologies such as Time-Slotted Channel Hopping (TSCH)
    <xref target='RFC6554'/>, where nodes that communicate at Layer 2 are scheduled to send
    and receive, respectively, and different hops operate on different channels.
    </t>


<section anchor='ffg'><name>Forwarding Fragments</name>
    <t>
    This specification inherits from <xref target='RFC8930'/>
    and proposes a Virtual Reassembly Buffer technique to forward fragments with no intermediate reconstruction of the entire datagram.

    </t><t>
    The IPv6 header <bcp14>MUST</bcp14> be placed in the first fragment in full to enable the routing decision. The first fragment is routed and creates an LSP from the fragmenting endpoint to the reassembling endpoint. The next fragments are label switched along that LSP.
    As a consequence, the next fragments can only follow the path that was set
    up by the first fragment; they cannot follow an alternate route.
      The Datagram_Tag is used to carry the label, which is swapped in each hop.
    </t><t>
    If the first fragment is too large for the path MTU, it will repeatedly fail
    and never establish an LSP. In that case,
    the fragmenting endpoint <bcp14>MAY</bcp14> retry the same datagram with a smaller
    Fragment_Size, in which case it <bcp14>MUST</bcp14> abort the original attempt and use a
    new Datagram_Tag for the new attempt.
	</t>

<section anchor='ff'><name>Receiving the First Fragment</name>
	<t>
	In route-over mode, the source and destination link-layer addresses in a frame
    change at each hop. The label that is formed and placed in the
    Datagram_Tag by the sender is associated with the source link-layer address and only valid (and temporarily unique) for that source link-layer address.
    </t>
    <t>
    Upon receiving the first fragment (i.e., with a Sequence of 0), an intermediate router
    creates a VRB and the associated
    LSP state indexed by the incoming interface, the previous-hop link-layer address,
    and the Datagram_Tag and forwards the fragment along the IPv6 route that matches
    the destination IPv6 address in the IPv6 header until it reaches the
    reassembling endpoint, as prescribed by
    <xref target='RFC8930'/>.
    The LSP state enables matching the next incoming fragments of a datagram to
    the abstract forwarding information of the next interface, source and next-hop
    link-layer addresses, and the swapped Datagram_Tag.
    </t>
    <t>
    In addition, the router also forms a reverse LSP state indexed by the interface to the next hop, the link-layer address the router uses as source for that datagram, and the swapped Datagram_Tag. This reverse LSP state
    enables matching the tuple (interface, destination link-layer address, Datagram_Tag) found in an RFRAG-ACK to the abstract forwarding information (previous interface, previous link-layer address, Datagram_Tag) used to forward the RFRAG-ACK back to the fragmenting endpoint.
	</t>


	</section>

<section anchor='nf'><name>Receiving the Next Fragments</name>
	<t>Upon receiving the next fragment (i.e., with a non-zero Sequence),
    an intermediate router looks up
    an LSP indexed by the tuple (incoming interface, previous-hop link-layer address, Datagram_Tag) found in the fragment.
    If it is found, the router forwards the fragment using the associated VRB as
    prescribed by <xref target='RFC8930'/>.
	</t>
	<t>If the VRB for the tuple is not found, the router builds an RFRAG-ACK
    to abort the transmission of the packet. The resulting message has the
	following information:
	</t><ul spacing='normal'>
		<li>The source and destination link-layer addresses are swapped from those found
        in the fragment, and the same interface is used</li>
		<li>The Datagram_Tag is set to the Datagram_Tag found in the fragment</li>
		<li>A NULL bitmap is used to signal the abort condition</li>
	</ul><t>
	At this point, the router is all set and can send the RFRAG-ACK back to
    the previous router. The RFRAG-ACK should normally be forwarded all the way
    to the source using the reverse LSP state in the VRBs in the intermediate
    routers as described in the next section.
	</t>
	<t>
    <xref target='RFC8930'/> indicates that the
    reassembling endpoint stores
    "the actual packet data from the fragments received so far, in a form that
    makes it possible to detect when the whole packet has been received and can
    be processed or forwarded".
    How this is computed is implementation specific,
    but it relies on receiving all the bytes up to the Datagram_Size indicated in
    the first fragment.
    An implementation may receive overlapping fragments as the result of retries
    after an MTU change.
	</t>
	</section>
</section>
<section anchor='ura'><name>Receiving RFRAG Acknowledgments</name>

	<t>Upon receipt of an RFRAG-ACK, the router looks up a reverse LSP indexed by the interface and destination link-layer address of the received frame and the received Datagram_Tag in the RFRAG-ACK.
    If it is found, the router forwards the fragment using the associated VRB as
    prescribed by <xref target='RFC8930'/>, but it uses
    the reverse LSP so that the RFRAG-ACK flows back to the fragmenting endpoint.
    </t>

	<t>If the reverse LSP is not found, the router <bcp14>MUST</bcp14> silently drop the RFRAG-ACK message.</t>

	<t>Either way, if the RFRAG-ACK indicates that the fragment was entirely received (FULL bitmap), it arms a short timer, and upon timeout, the VRB and all the associated states are destroyed. Until the timer elapses, fragments of that datagram may still be received, e.g., if the RFRAG-ACK was lost on the path back, and the source retried the last fragment. In that
    case, the router generates an RFRAG-ACK with a FULL bitmap back to the fragmenting endpoint if an acknowledgment was requested; else, it silently drops the fragment. </t>

    <t>
    This specification does not provide a method to discover the number of hops
    or the minimal value of MTU along those hops. In a typical case, the MTU is
    constant and is the same across the network. But should the minimal MTU along
    the path decrease, it is possible to retry a long fragment (say a Sequence of 5) with
    several shorter fragments with a Sequence that was not used before (e.g.,
    13 and 14). Fragment 5 is marked as abandoned and will not be retried
    anymore. Note that when this mechanism is in place, it is hard to predict
    the total number of fragments that will be needed or the final shape of the
    bitmap that would cover the whole packet. This is why the FULL bitmap is used
    when the reassembling endpoint gets the whole datagram regardless of which
    fragments were actually used to do so. Intermediate nodes will know unambiguously
    that the process is complete. Note that Path MTU Discovery is out of scope for this document.
    </t>

    </section>

    <section><name>Aborting the Transmission of a Fragmented Packet</name>
	<t>
	A reset is signaled on the forward path with a pseudo fragment that has the Fragment_Offset set to 0. The sender of a reset <bcp14>SHOULD</bcp14> also set the Sequence and Fragment_Size field to 0.
	</t>
	<t>
    When the fragmenting endpoint or a router on the path decides that a packet should be dropped and the fragmentation process aborted, it generates a reset pseudo fragment and forwards it down the fragment path.
	</t>
	<t>Each router along the path forwards the pseudo fragment in
	turn based on the VRB state. If an acknowledgment is not requested, the VRB and all associated states are destroyed.
	</t>
	<t>
	Upon reception of the pseudo fragment, the reassembling endpoint cleans up all resources for the packet
	associated with the Datagram_Tag. If an acknowledgment is requested, the reassembling endpoint responds with a NULL bitmap.
	</t>
	<t>On the other hand, the reassembling endpoint might need to abort the processing of a fragmented packet for internal reasons, for instance, if it is out of reassembly buffers, already uses all 256 possible values of the Datagram_Tag, or keeps receiving fragments beyond a reasonable time while it considers that this packet is already fully reassembled and was passed to the upper layer. In that case, the reassembling endpoint <bcp14>SHOULD</bcp14> indicate so to the fragmenting endpoint with a NULL bitmap in an RFRAG-ACK.
	</t>
	<t>
    The RFRAG-ACK is forwarded all the way back to the source of the packet and cleans up all resources on the path.
	Upon an acknowledgment with a NULL bitmap, the fragmenting endpoint <bcp14>MUST</bcp14> abort the transmission of the fragmented datagram with one exception: in the particular case of the first fragment, it <bcp14>MAY</bcp14> decide to retry via an alternate next hop instead.
	</t>
    </section>

    <section><name>Applying Recoverable Fragmentation along a Diverse Path</name>
    <t>
    The text above can be read with the assumption of a serial path between a
    source and a destination. The IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH) architecture (see
    <xref target='I-D.ietf-6tisch-architecture' sectionFormat="of" section="4.5.3"/>)
    defines the concept of a Track that can be a complex path between a source
    and a destination with Packet ARQ, Replication,
    Elimination, and Overhearing (PAREO) along the Track. This specification
    can be used along any subset of
    the complex Track where the first fragment is flooded. The last RFRAG
    Acknowledgment is flooded on that same subset in the reverse direction.
    Intermediate RFRAG Acknowledgments can be flooded on any sub-subset of that
    reverse subset that reaches back to the source.
    </t>
    </section>
    </section>

    <section><name>Management Considerations</name>
    <t>

    This specification extends  <xref target='RFC8930'/> and requires the same parameters in the reassembling endpoint and on intermediate nodes. There is no new parameter as echoing ECN is always on. These parameters typically include the reassembly timeout at the reassembling endpoint, an inactivity cleanup timer on the intermediate nodes, and the number of messages that can be processed in parallel in all nodes.
    </t>
    <t>

    The configuration settings introduced by this specification only apply to the fragmenting endpoint, which is in full control of the transmission.
    LLNs vary a lot in size (there can be thousands of nodes in a mesh), in
    speed (from 10 Kbps to several Mbps at the PHY layer), in traffic density, and in optimizations that are desired (e.g., the selection of a Routing Protocol for LLNs (RPL) <xref target='RFC6550'/> Objective Function <xref target='RFC6552'/> impacts the shape of the routing graph).

    </t>
    <t>
    For that reason, only very generic guidance can be given on the settings of the fragmenting endpoint and on whether complex algorithms are needed to perform congestion control or to estimate the round-trip time. To cover the most complex use cases, this specification enables the fragmenting endpoint to vary the fragment size, the window size, and the inter-frame gap based on the number of losses, the observed variations of the round-trip time, and the setting of the ECN bit.
    </t>

    <section anchor='protp'><name>Protocol Parameters</name>
    <t>
    The management system <bcp14>SHOULD</bcp14> be capable of providing the parameters listed in this section, and an
    implementation <bcp14>MUST</bcp14> abide by those parameters and, in particular, never exceed the minimum and maximum configured boundaries.
    </t>
    <t>
    An implementation should consider the generic recommendations from the IETF in the matter of congestion control and rate management for IP datagrams in
    <xref target='RFC8085'/>.
    An implementation may perform congestion control by using a dynamic value of the window size (Window_Size), adapting the fragment size (Fragment_Size), and potentially
    reducing the load by inserting an inter-frame gap that is longer than necessary. In a large network where nodes contend for the bandwidth, a larger Fragment_Size consumes less bandwidth but also reduces fluidity and incurs higher chances of loss in transmission. </t>
    <t>
    This is controlled by the following parameters:
    </t>
    <dl>
       <dt>inter-frame gap:</dt><dd>
       The inter-frame gap indicates the minimum amount of time between transmissions.
       The inter-frame gap controls the rate at which fragments are sent, the ratio of air time, and the amount of memory in intermediate nodes that a particular datagram will use. It can be used as a flow control, a congestion control, and/or a collision
       control measure.
       It <bcp14>MUST</bcp14> be set at a minimum to a value that protects the propagation of one transmission against collision with next <xref target='RFC8930'/>. In a wireless network that uses the same frequency along a path, this may represent the time for a frame to progress over multiple hops (see more in <xref target='gap'/>).
       It <bcp14>SHOULD</bcp14> be augmented beyond this as necessary to protect the network against congestion.
       </dd>
       <dt>MinFragmentSize:</dt><dd>
       The MinFragmentSize is the minimum value for the Fragment_Size. It <bcp14>MUST</bcp14> be lower than the minimum value of smallest 1-hop MTU that can be encountered along the path.
       </dd>
       <dt>OptFragmentSize:</dt><dd>
       The OptFragmentSize is the value for the Fragment_Size that the fragmenting endpoint
       should use to start with. It is greater than or equal to MinFragmentSize. It is less than or equal to MaxFragmentSize. For the
       first fragment, it must account for the expansion of the IPv6 addresses and of the Hop Limit field within MTU. For all fragments, it is a balance between the expected fluidity and the overhead of link-layer and 6LoWPAN headers. For a small MTU, the idea is to keep it close to the maximum, whereas for larger MTUs, it might make sense to keep it short enough so that the duty cycle of the transmitter is bounded, e.g., to transmit at least 10 frames per second.
       </dd>
       <dt>MaxFragmentSize:</dt><dd>
       The MaxFragmentSize is the maximum value for the Fragment_Size.
       It <bcp14>MUST</bcp14> be lower than the maximum value of the smallest 1-hop MTU that can be encountered along the path. A large
       value augments the chances of buffer bloat and transmission loss.
       The value <bcp14>MUST</bcp14> be less than 512 if the unit that is defined
       for the PHY layer is the byte.
       </dd>
       <dt>Window_Size:</dt><dd>
       <t>
       The Window_Size <bcp14>MUST</bcp14> be at least 1 and less than 33.
       </t>

       <ul>
       <li>
       If the round-trip time is known, the Window_Size <bcp14>SHOULD</bcp14> be set to the round-trip time divided by the time per fragment; that is, the time to transmit a fragment plus the inter-frame gap.
       </li>
       </ul>

       <t>
       Otherwise:
       </t>

       <ul>
       <li>
       A window_size of 32 indicates that only the last fragment is to be acknowledged in each round. This is the <bcp14>RECOMMENDED</bcp14> value in a half-duplex LLN
       where the fragment acknowledgment consumes roughly the same bandwidth on the
       same links as the fragments themselves.
       </li><li>
       If it is set to a smaller value, more acks are generated.
       In a full-duplex network, the load on the forward path will be lower, and
       a small value of 3 <bcp14>SHOULD</bcp14> be configured.
       </li>
       </ul>

       </dd>

    </dl>
    <t>
    An implementation may perform its estimate of the RTO or use a configured one. The ARQ process is controlled by the following parameters:
    </t>
    <dl>
       <dt>MinARQTimeOut:</dt><dd>
       The minimum amount of time a node should wait for an RFRAG Acknowledgment before it takes the next action.
       It <bcp14>MUST</bcp14> be more than the maximum expected round-trip time in the respective network.
       </dd>
       <dt>OptARQTimeOut:</dt><dd>
       The initial value of the RTO, which is the amount of time that a fragmenting endpoint should wait for an RFRAG Acknowledgment before it takes the next action. It is greater than or equal to MinARQTimeOut. It is less than or equal to MaxARQTimeOut. See <xref target='onECN'/> for recommendations on computing the round-trip time. By default, a value of 3 times the maximum expected round-trip time in the respective network is <bcp14>RECOMMENDED</bcp14>.


       </dd>
       <dt>MaxARQTimeOut:</dt><dd>
       The maximum amount of time a node should wait for the RFRAG Acknowledgment before it takes the next action. It must cover the longest expected round-trip time and be several times less than the timeout that covers the recomposition buffer at the reassembling endpoint, which is typically on the order of the minute.
       An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped
       before an upper layer decides to retry it.
       </dd>
       <dt>MaxFragRetries:</dt><dd>
       The maximum number of retries for a particular fragment. A default value of 3 is <bcp14>RECOMMENDED</bcp14>.
       An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped
       before an upper layer decides to retry it.
       </dd>
       <dt>MaxDatagramRetries:</dt><dd>
       The maximum number of retries from scratch for a particular datagram.
       A default value of 1 is <bcp14>RECOMMENDED</bcp14>.
       An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped
       before an upper layer decides to retry it.
       </dd>
    </dl>
    <t>
    An implementation may be capable of performing congestion control based on ECN; see <xref target='onECN'/>. This is controlled by the following parameter:
    </t>
    <dl>
       <dt>UseECN:</dt><dd>
       Indicates whether the fragmenting endpoint should react to ECN.
       The fragmenting endpoint may react to ECN by varying the Window_Size between
       MinWindowSize and MaxWindowSize, varying the Fragment_Size between MinFragmentSize and MaxFragmentSize, and/or increasing or reducing the inter-frame gap.
       With this specification, if UseECN is set and a fragmenting
       endpoint detects a congestion, it may apply a congestion control method until the end of the datagram, whereas if UseECN is reset, the endpoint does not react to congestion.
       Future specifications may provide additional parameters and capabilities.
       </dd>
    </dl>
    </section>


    <section><name>Observing the Network</name>

    <t>The management system should monitor the number of retries
    and ECN settings that can be observed from the perspective of
    the fragmenting endpoint with respect to the reassembling endpoint and reciprocally.

    It may then tune the optimum size of
    Fragment_Size and of Window_Size, OptFragmentSize, and OptWindowSize,
    respectively, at the fragmenting endpoint towards a particular reassembling endpoint, which is applicable to the
    next datagrams.
    It will preferably tune the inter-frame gap to
    increase the spacing between fragments of the same datagram and reduce the
    buffer bloat in the intermediate node that holds one or more fragments of that
    datagram.
	</t>

    </section>
    </section>

    <section><name>Security Considerations</name>

        <t>
    This document specifies an instantiation of a 6LFF technique and inherits
    from the generic description in <xref target='RFC8930'/>.
    The considerations in the Security Considerations section of <xref target='RFC8930'/>  equally apply to this document.
    </t>
    <t>
    In addition to the threats detailed therein, an attacker that is on path can
    prematurely end the transmission of a datagram by sending a RFRAG Acknowledgment
    to the fragmenting endpoint. It can also cause extra transmissions of
    fragments by resetting bits in the RFRAG Acknowledgment Bitmap and of
    RFRAG Acknowledgments by forcing the  Ack-Request bit in fragments that it
    forwards.
    </t>
    <t>
    As indicated in <xref target='RFC8930'/>, secure joining and link-layer security are <bcp14>REQUIRED</bcp14> to protect against those attacks, as the fragmentation protocol does not include any native
    security mechanisms.
    </t>
    <t>
    This specification does not recommend a particular algorithm for the
    estimation of the duration of the RTO that covers the detection of the
    loss of a fragment with the "X" flag set; regardless, an attacker on the
    path may slow down or discard packets, which in turn can affect the
    throughput of fragmented packets.
    </t>
	<t>Compared to
	<xref target='RFC4944'/>, this specification reduces the Datagram_Tag to 8 bits, and
    the tag wraps faster than with <xref target='RFC4944'/>.
    But for a constrained network where a node is expected to be able to hold
    only one or a few large packets in memory, 256 is still a large number.
    Also, the acknowledgment mechanism allows cleaning up the state rapidly
    once the packet is fully transmitted or aborted.

	</t>
    <t>
    The abstract Virtual Recovery Buffer from
    <xref target='RFC8930'/> may be used to perform a
    Denial-of-Service (DoS) attack against the intermediate routers since the
    routers need to maintain a state per flow. The particular VRB implementation
    technique described in
    <xref target='I-D.ietf-lwig-6lowpan-virtual-reassembly'/> allows realigning
    which data goes in which fragment; this causes the intermediate node to
    store a portion of the data, which adds an attack vector that is not present
    with this specification. With this specification, the data that is
    transported in each fragment is conserved, and the state to keep does not
    include any data that would not fit in the previous fragment.
	</t>
        </section>
        <section anchor='ianacon'><name>IANA Considerations</name>
        <t>

    This document allocates two patterns for a total of four dispatch values for Recoverable Fragments from the
   "Dispatch Type Field" registry that was created by <xref target='RFC4944'/> and
     reformatted by <xref target='RFC8025'>"IPv6 over Low-Power Wireless Personal Area
                   Network (6LoWPAN) Paging Dispatch"</xref>.
     </t>


   <table anchor="difig"><name>Additional Dispatch Value Bit Patterns</name>
   <thead>
      <tr><td>Bit Pattern</td><td>Page</td><td align='left'>Header Type</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>11  10100x</td><td>0</td><td>RFRAG - Recoverable
      Fragment</td>    <td>RFC 8931</td></tr>
      <tr><td>11  10100x</td><td>1-14</td><td>Unassigned</td>    <td></td></tr>
      <tr><td>11  10100x</td><td>15</td><td>Reserved for Experimental Use</td>    <td>RFC 8025</td></tr>

      <tr><td>11  10101x</td><td>0</td><td>RFRAG-ACK - RFRAG
      Acknowledgment</td><td>RFC 8931</td></tr>
      <tr><td>11  10101x</td><td>1-14</td><td>Unassigned</td>    <td></td></tr>
      <tr><td>11  10101x</td><td>15</td><td>Reserved for Experimental Use</td>    <td>RFC 8025</td></tr>
   </tbody>
   </table>
        </section>



    </middle>

    <back>

   <displayreference   target="I-D.ietf-lwig-6lowpan-virtual-reassembly" to="LWIG-FRAG"/>
   <displayreference   target="I-D.ietf-6tisch-architecture" to="6TiSCH"/>

<references><name>References</name>
    <references><name>Normative References</name>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6298.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4919.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6282.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6606.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8025.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8138.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml'/>

<!--draft-ietf-6lo-minimal-fragment-15; C310 companion document -->
<reference anchor='RFC8930' target='https://www.rfc-editor.org/info/rfc8930'>
<front>
<title>On Forwarding 6LoWPAN (IPv6 over Low-Power Wireless Personal Area
Network) Fragments over a Multi-Hop IPv6 Network</title>

<author initials='T' surname='Watteyne' fullname='Thomas Watteyne' role='editor'>
    <organization />
</author>

<author initials='P' surname='Thubert' fullname='Pascal Thubert' role='editor'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='November' year='2020' />

</front>
<seriesInfo name="RFC" value="8930"/>
<seriesInfo name="DOI" value="10.17487/RFC8930"/>

</reference>


    </references>

    <references><name>Informative References</name>

	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7567.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3031.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5681.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2914.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4963.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5033.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6550.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6552.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6554.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7554.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8087.xml'/>

<!--draft-ietf-lwig-6lowpan-virtual-reassembly-02; Expired-->
<xi:include href='https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-lwig-6lowpan-virtual-reassembly.xml'/>

<!--draft-ietf-intarea-frag-fragile-17; pub'd as RFC 8900 -->
 <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8900.xml'/>

<!--draft-ietf-6tisch-architecture-29; in MISSREF state as of 11/12/20 -->
<xi:include href='https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-6tisch-architecture.xml'/>

<!--[IEEE.802.15.4] DOI https://doi.org/10.1109/IEEESTD.2016.7460875 URL below is correct -->
      <reference anchor='IEEE.802.15.4' target='http://ieeexplore.ieee.org/document/7460875/'>
        <front>
            <title>IEEE Standard for Low-Rate Wireless Networks</title>
            <author>
              <organization>IEEE</organization>
            </author>
            <date month="April" year="2016"/>
        </front>
        <seriesInfo name='IEEE' value='Standard 802.15.4-2015'/>
	    <seriesInfo name='DOI' value=' 10.1109/IEEESTD.2016.7460875'/>
      </reference>


      <reference anchor='Kent' target='http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf'><front>
          <title>Fragmentation Considered Harmful

          </title>
          <author fullname='Kent' initials='C. ' surname='Kent'>
                  <organization/>
          </author>
          <author fullname='Mogul' initials='J.' surname='Mogul'>
                  <organization/>
          </author>
          <date month='August' year='1987'/>
          </front>
        <seriesInfo name='DOI' value='10.1145/55483.55524'/>
<refcontent>SIGCOMM '87: Proceedings of the ACM workshop on Frontiers in computer communications technology, pp. 390-401</refcontent>
      </reference>
    </references>
  </references>


	<section anchor='rationale'><name>Rationale</name>
	  <t>

	  There are a number of uses for large packets in Wireless Sensor Networks. Such usages
	  may not be the most typical or represent the largest amount of traffic over the LLN;
	  however, the associated functionality can be critical enough to justify extra care for
	  ensuring effective transport of large packets across the LLN.
	  </t>

	  <t>
	  The list of those usages includes:
          </t>

          <t>Towards the LLN node:</t>

         <ul empty="true"><li><dl>
		  <dt>Firmware update:</dt><dd>
	       For example, a new version of the LLN node software is downloaded from a system
		   manager over unicast or multicast services.
		   Such a reflashing operation typically involves updating a large number of similar
		   LLN nodes over a relatively short period of time.
		 </dd>
	      <dt>Packages of commands:</dt><dd>
	       A number of commands or a full configuration can be packaged as a single message
	       to ensure consistency and enable atomic execution or complete rollback.
		   Until such commands are fully received and interpreted, the intended operation will not take effect.
	     </dd>

	 </dl></li></ul>

            <t>From the LLN node:</t>

           <ul empty="true"><li><dl>

	     <dt>Waveform captures:</dt><dd>
	       A number of consecutive samples are measured at a high rate for a short time and then are transferred
		   from a sensor to a gateway or an edge server as a single large report.
	     </dd>
	     <dt>Data logs:</dt><dd>
	       LLN nodes may generate large logs of sampled data
	       for later extraction. LLN nodes may also generate
	       system logs to assist in diagnosing problems on the
	       node or network.
	     </dd>
	     <dt>Large data packets:</dt><dd>
	       Rich data types might require more than one fragment.
	     </dd>
		</dl></li></ul>
	  <t>
		   Uncontrolled firmware download or waveform upload can easily result in a massive
		   increase of the traffic and saturate the network.
		</t>
		<t>
		   When a fragment is lost in transmission, the lack of recovery in
           the original fragmentation system of RFC 4944 implies that all
           fragments would need to be resent, further contributing
	       to the congestion that caused the initial loss
           and potentially leading to congestion collapse.

	  </t>
	  <t>
		   This saturation may lead to excessive radio interference or random early discard
		   (leaky bucket) in relaying nodes. Additional queuing and memory congestion may
		   result while waiting for a low-power next hop to emerge from its sleep state.
	  </t>

	  <t>
	    Considering that RFC 4944
		defines an MTU as 1280 bytes, and that in most incarnations
		(except 802.15.4g) an IEEE Std 802.15.4 frame can limit the link-layer payload
		to as few as 74 bytes, a packet might be fragmented into at
	    least 18 fragments at the 6LoWPAN shim layer. Taking into
	    account the worst-case header overhead for 6LoWPAN
	    Fragmentation and Mesh Addressing headers will increase
	    the number of required fragments to around 32. This level
	    of fragmentation is much higher than that traditionally
	    experienced over the Internet with IPv4 fragments. At the
	    same time, the use of radios increases the probability of
	    transmission loss, and mesh-under techniques compound that
	    risk over multiple hops.

	  </t>


    	  <t>
	    Mechanisms such as TCP or application-layer segmentation
	    could be used to support end-to-end reliable transport. One
	    option to support bulk data transfer over a frame-size-constrained
		LLN is to set the Maximum Segment Size to fit within the link
	    maximum frame size. However, doing so can add significant header
	    overhead to each 802.15.4 frame and cause extraneous acknowledgments
        across the LLN compared to the method in this specification.
</t>

	</section>
    	<section anchor='req'><name>Requirements</name>
	  <t>
		For one-hop communications, a number of LLN
        link layers propose a local acknowledgment mechanism that is enough to
		detect and recover the loss of fragments. In a multi-hop environment, an
        end-to-end fragment recovery mechanism might be a good complement to a
		hop-by-hop Medium Access Control (MAC) recovery.
	    This document introduces a simple protocol to recover individual fragments
        between 6LFF endpoints that may be multiple hops away.

	  </t><t>
        The method addresses the following requirements of an LLN:

	   </t><dl>
	   <dt>Number of fragments:</dt><dd>The recovery mechanism must support highly fragmented packets, with a maximum of 32 fragments per packet.
	   </dd>
	   <dt>Minimum acknowledgment overhead:</dt><dd> Because the radio is half duplex, and because of silent time spent in the
	   various medium access mechanisms, an acknowledgment consumes roughly as many resources as a data fragment.
	    </dd><dt></dt><dd>The new end-to-end fragment recovery mechanism should be able to acknowledge multiple fragments in a single message and
		not require an acknowledgment at all if fragments are already protected at a lower layer.
		</dd>

	   <dt>Controlled latency:</dt><dd>The recovery mechanism must succeed or give up within the time boundary imposed by the recovery process
	   of the upper-layer protocols.
	   </dd>
	   <dt>Optional congestion control:</dt><dd> The aggregation of multiple concurrent flows may lead to the saturation of the radio network and congestion collapse.
		</dd>
		<dt></dt><dd>The recovery mechanism should provide means for controlling the number of fragments in transit over the LLN.
	    </dd>

	    </dl>
	</section>

	<section anchor='onECN'><name>Considerations on Congestion Control</name>

	<t>Considering that a multi-hop LLN can be a very sensitive environment
	due to the limited queuing capabilities of a
	large population of its nodes, this document recommends a simple and
	conservative approach to congestion control, based on TCP congestion avoidance.
	</t>
	<t>Congestion on the forward path is assumed in case of packet loss, and
    packet loss is assumed upon timeout. This document allows controlling the number
    of outstanding fragments that have been transmitted, but for which an
   acknowledgment was not yet received, and that are still covered by the ARQ timer.

	</t>
	<t>Congestion on the forward path can also be indicated by an ECN mechanism.
	Though whether and how ECN <xref target='RFC3168'/> is carried out over the
    LoWPAN is out of scope, this document provides a way for the destination
    endpoint to echo an ECN indication back to the fragmenting endpoint in an
    acknowledgment message as represented in
	<xref target='ackfig'/> in <xref target='ackfrag'/>.
    	</t>
	<t>
    While the support of echoing the ECN at the reassembling endpoint is mandatory, this
    specification only provides a minimalistic behavior on the fragmenting endpoint.
    If an "E" flag is received, the window <bcp14>SHOULD</bcp14> be reduced at least by 1 and at max to 1. Halving the window for each "E" flag received could be a good compromise, but it needs further experimentation. A very simple implementation may just reset the window to 1, so the fragments are sent and acknowledged one by one.
    </t>
	<t>
    Note that any action that has been performed upon detection of congestion
    only applies for the transmission of one datagram, and the next datagram
    starts with the configured Window_Size again.
	</t>
	<t>
    The exact use of the Acknowledgment Request flag and of the window are left to implementation. An optimistic implementation could send all the fragments up to Window_Size, setting the Acknowledgment Request "X" flag only on the last fragment; wait for the bitmap, which means a gap of half a round-trip time; and resend the losses.
    A pessimistic implementation could set the "X" flag on the first fragment to check that the path works and open the window only upon receiving the RFRAG-ACK. It could then set an "X" flag again on the second fragment and use the window as a credit to send up to Window_Size before it is blocked. In that case, if the RFRAG-ACK comes back before the window starves, the gating factor is the inter-frame gap. If the RFRAG-ACK does not arrive in time, the Window_Size is the gating factor, and the
    transmission of the datagram is delayed.
	</t>
	<t>
   It must be noted that even though the inter-frame gap can be used as a flow
   control or a congestion control measure, it also plays a critical role in
   wireless collision avoidance.
   In particular, when a mesh operates on the same channel over multiple hops,
   the forwarding of a fragment over a certain hop may collide with the
   forwarding of the next fragment that is following over a previous hop but that is in the same interference domain. To prevent this, the fragmenting endpoint is required to pace individual fragments within a transmit window with an inter-frame gap. This is needed to ensure that a given fragment is sent only when the previous fragment has had a chance to progress beyond the interference domain of this hop.

   In the case of
   6TiSCH <xref target='I-D.ietf-6tisch-architecture'></xref>, which operates
   over the
   Time-Slotted Channel Hopping (TSCH) mode
   of operation of IEEE 802.15.4 <xref target='RFC7554'></xref>, a fragment is forwarded over a different
   channel at a different time, and it makes full sense to transmit the next fragment as
   soon as the previous fragment has had its chance to be forwarded at the next
   hop.

	</t>
	<t>
    Depending on the setting of the Window_Size and the inter-frame gap,
    how the window is used, and the number of hops, the Window_Size may or
    may not become the gating factor that blocks the transmission.
    If the sender uses the Window_Size as a credit:
    </t>
    <ul>
    <li>
    a conservative Window_Size of, say, 3 will be the gating factor that limits the transmission rate of the sender -- and causes transmission gaps longer than the inter-frame gap -- as soon as the
    number of hops exceeds 3 in a TSCH network and 5-9 in a single frequency mesh.
    The more hops the more the starving window will add to latency of the transmission.
    </li><li>
    The recommendation to align the Window-Size to the round-trip time divided by
    the time per fragment aligns the Window-Size to the time it takes to get the
    RFAG_ACK before the window starves. A Window-Size that is higher than that increases
    the chances of a congestion but does not improve the forward throughput. Considering that the RFRAG-ACK takes the same path as the fragment with the assumption that it travels at roughly the same speed, an inter-frame gap that separates fragments by 2
    hops leads to a Window_Size that is roughly the number of hops.

    </li><li>
    Setting the Window-Size to 32 minimizes the cost of the acknowledgment
    in a constrained network and frees bandwidth for the fragments in a half-duplex
    network. Using it increases the risk of congestion if a bottleneck forms, but it
    optimizes the use of resources under normal conditions. When it is used, the
    only protection for the network is the inter-frame gap, which must be chosen
    wisely to prevent the formation of a bottleneck.

    </li>
    </ul>
	<t>
    From the standpoint of a source 6LoWPAN endpoint, an outstanding
    fragment is a fragment that was
	sent but for which no explicit acknowledgment was yet received.
	This means that the fragment might be on the path or received but not yet
    acknowledged, or the acknowledgment might be on the path back. It is also
    possible that either the fragment or the acknowledgment was lost on the
    way.
	</t>


	<t>From the fragmenting endpoint standpoint,
	all outstanding fragments might still be in the network and contribute to its congestion.
	There is an assumption, though, that after a certain amount of time, a frame is either received
    or lost, so it is not causing congestion anymore. This amount of time can be estimated based on the round-trip
	time between the 6LoWPAN endpoints. For the lack of a more adapted technique, the method detailed in <xref target='RFC6298'>"Computing TCP's Retransmission Timer"</xref> may be used for that computation.
	</t>
	<t>
    This specification provides the necessary tools for the fragmenting endpoint
    to take congestion control actions and protect the network, but it leaves the
    implementation free to select the action to be taken. The intention is to
    use it to build experience and specify more precisely the congestion control actions
    in one or more future specifications. <xref target='RFC2914'>"Congestion Control Principles"</xref> and <xref target='RFC5033'>"Specifying New Congestion Control Algorithms"</xref> provide indications and wisdom that should help through this process.
	</t>
	<t>
    <xref target='RFC7567'/> and <xref target='RFC5681'/> provide deeper information on why congestion control is needed and how TCP handles it. Basically, the goal here is to
	manage the number of fragments present in the network; this is achieved by reducing the number of outstanding fragments over a congested path by throttling the sources.
	</t>
</section>
<section numbered="false" toc="default"><name>Acknowledgments</name>

<t>The author wishes to thank <contact fullname="Michel Veillette"/>, <contact fullname="Dario Tedeschi"/>, <contact fullname="Laurent Toutain"/>,
<contact fullname="Carles Gomez Montenegro"/>, <contact fullname="Thomas Watteyne"/>, and <contact fullname="Michael Richardson"/> for their in-depth
reviews and comments.
Also, many thanks to <contact fullname="Roman Danyliw"/>, <contact fullname="Peter Yee"/>, <contact fullname="Colin Perkins"/>, <contact fullname="Tirumaleswar Reddy.K"/>, <contact fullname="Éric Vyncke"/>, <contact fullname="Warren Kumari"/>, <contact fullname="Magnus Westerlund"/>, <contact fullname="Erik Nordmark"/>, and especially <contact fullname="Benjamin Kaduk"/> and <contact fullname="Mirja Kühlewind"/> for
their careful reviews and help during the IETF Last Call and IESG review process.
Thanks to <contact fullname="Jonathan Hui"/>, <contact fullname="Jay Werb"/>, <contact fullname="Christos Polyzois"/>, <contact fullname="Soumitri Kolavennu"/>,
<contact fullname="Pat Kinney"/>, <contact fullname="Margaret Wasserman"/>, <contact fullname="Richard Kelsey"/>, <contact fullname="Carsten Bormann"/>, and
<contact fullname="Harry Courtice"/> for their various contributions in the long process that lead to this document.</t>
</section>

    </back>

</rfc>
