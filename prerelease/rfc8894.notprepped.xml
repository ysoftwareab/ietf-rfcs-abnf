<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF"
     category="info" consensus="true" ipr="pre5378Trust200902"
     docName="draft-gutmann-scep-16" number="8894" obsoletes="" updates=""
     xml:lang="en" tocInclude="true" tocDepth="5" symRefs="true"
     sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 2.42.0 -->

  <front>
    <title abbrev="SCEP">Simple Certificate Enrolment Protocol</title>
    <seriesInfo name="RFC" value="8894" /> 
    <author initials="P." surname="Gutmann" fullname="Peter Gutmann">
      <organization abbrev="University of Auckland">University of Auckland</organization>
      <address>
        <postal>
          <street>Department of Computer Science</street>
          <city>Auckland</city>
          <country>New Zealand</country>
        </postal>
        <email>pgut001@cs.auckland.ac.nz</email>
      </address>
    </author>
    <date month="September" year="2020" />
    <area>Security Area</area>

    <abstract>
      <t>

This document specifies the Simple Certificate Enrolment Protocol (SCEP), a
PKI protocol that leverages existing technology by using Cryptographic Message
Syntax (CMS, formerly known as PKCS #7) and PKCS #10 over HTTP.  SCEP is the
evolution of the enrolment
protocol sponsored by Cisco Systems, which enjoys wide support in both client
and server implementations, as well as being relied upon by numerous other
industry standards that work with certificates.

      </t>
    </abstract>


  </front>

  <middle>

    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>

X.509 certificates serve as the basis for several standardised security
protocols such as <xref target="RFC8446" format="default">TLS</xref>, <xref
target="RFC8551" format="default">S/MIME</xref>, and <xref target="RFC7296"
format="default">IKE/IPsec</xref>.  When an X.509
certificate is issued, there typically is a need for a certificate management
protocol to enable a PKI client to request or renew a certificate from a
Certificate Authority (CA).  This specification defines a protocol, the Simple
Certificate Enrolment Protocol (SCEP), for certificate management and
certificate and CRL queries.

      </t>
      <t>

The SCEP protocol supports the following general operations:

      </t>
      <ul spacing="compact">
        <li>CA public key distribution</li>
        <li>Certificate enrolment and issue</li>
        <li>Certificate renewal</li>
        <li>Certificate query</li>
        <li>CRL query</li>
      </ul>
      <t>

SCEP makes extensive use of <xref target="RFC5652" format="default">CMS</xref>
and <xref target="RFC2986" format="default">PKCS #10</xref>.
      </t>

      <section anchor="mustshouldmay" numbered="true" toc="default">
        <name>Conventions Used in This Document</name>
        <t>
	  The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
	  "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
	  NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
	  "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
	  "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
	  are to be interpreted as
	  described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
	  when, and only when, they appear in all capitals, as shown here.
        </t>

        <t>This document uses the Augmented Backus-Naur Form (ABNF) notation
        as specified in <xref target="RFC5234" format="default"/> for defining formal syntax of
	commands.  Non-terminals not defined in <xref target="RFC5234" format="default"/> are
	defined in <xref target="HTTP-GET-POST" format="default"/>.</t>
      </section>
    </section>

    <section anchor="overview" numbered="true" toc="default">
      <name>SCEP Overview</name>
      <t>

This section provides an overview of the functionality of SCEP.

      </t>
      <section anchor="overview-entities" numbered="true" toc="default">
        <name>SCEP Entities</name>
        <t>

The entity types defined in SCEP are a client requesting a certificate and a
Certificate Authority (CA) that issues the certificate.  These are described
in the following sections.

        </t>
        <section anchor="overview-client" numbered="true" toc="default">
          <name>Client</name>
          <t>

A client <bcp14>MUST</bcp14> have the following information locally configured:

          </t>
          <ol type="1">
            <li>The CA's fully qualified domain name or IP address.</li>
            <li>Any identification and/or authorisation information required by
			the CA before a certificate will be issued, as described in
			<xref target="PKCSReq" format="default"/>.</li>
            <li>The identifying information that is used for authentication of
			the CA in <xref target="GetCACert-resp" format="default"/>, typically a certificate
			fingerprint.</li>
          </ol>
        </section>
        <section anchor="overview-ca" numbered="true" toc="default">
          <name>Certificate Authority</name>
          <t>
A SCEP CA is the entity that signs client certificates.  A CA may enforce
policies and apply them to certificate requests, and it may reject a request for
any reason.
          </t>

          <t>
Since the client is expected to perform signature verification and optionally
encryption using the CA certificate, the keyUsage extension in the CA
certificate <bcp14>MUST</bcp14> indicate that it is valid for digitalSignature and
keyEncipherment (if the key is to be used for en/decryption) alongside the
usual CA usages of keyCertSign and/or cRLSign.
          </t>
        </section>
      </section>
      <section anchor="overview-cert-dist" numbered="true" toc="default">
        <name>CA Certificate Distribution</name>
        <t>
If the CA certificate(s) have not previously been acquired by the client
through some other means, the client <bcp14>MUST</bcp14> retrieve them before any PKI
operation (<xref target="message-obj" format="default"/>) can be started.  Since no public key
has yet been exchanged between the client and the CA, the messages cannot be
secured using CMS, and the CA certificate request and response data is instead
transferred in the clear.
        </t>
        <t>
If an intermediate CA is in use, a certificates-only CMS SignedData message
with a certificate chain consisting of all CA certificates is returned.
Otherwise, the CA certificate itself is returned.
        </t>
        <t>
The CA certificate <bcp14>MAY</bcp14> be provided out of band to the client.  Alternatively,
the CA certificate fingerprint <bcp14>MAY</bcp14> be used to authenticate a CA certificate
distributed by the GetCACert response (<xref target="GetCACert" format="default"/>) or via
<xref target="RFC4387" format="default">HTTP certificate-store access</xref>.  The
fingerprint is created by calculating a SHA-256 hash over the whole CA
certificate. (For legacy reasons, a SHA-1 hash may be used by some
implementations.)

        </t>
        <t>

After the client gets the CA certificate, it <bcp14>SHOULD</bcp14> authenticate it in some
manner unless this is deemed unnecessary, for example, because the device is
being provisioned inside a trusted environment.  For example, the client could compare
the certificate's fingerprint with locally configured, out-of-band distributed, identifying
information, or by some equivalent means such as a direct comparison with a
locally stored copy of the certificate.

        </t>
        <t>

Intermediate CA certificates, if any, are signed by a higher-level CA, so there
is no need to authenticate them against the out-of-band data.  Since
intermediate CA certificates are rolled over more frequently than long-lived
top-level CA certificates, clients <bcp14>MUST</bcp14> verify intermediate-level CA
certificates before use during protocol exchanges in case the intermediate CA
certificate has expired or otherwise been invalidated.

        </t>
        <t>

When a CA certificate expires, certificates that have been signed by it may no
longer be regarded as valid.  CA key rollover provides a mechanism by which
the CA can distribute a new CA certificate that will be valid in the future once
the current certificate has expired.  This is done via the GetNextCACert
message (<xref target="get-next-CA" format="default"/>).

        </t>
      </section>
      <section anchor="overview-req-auth" numbered="true" toc="default">
        <name>Client Authentication</name>
        <t>

As with every protocol that uses public-key cryptography, the association
between the public keys used in the protocol and the identities with which
they are associated must be authenticated in a cryptographically secure
manner.  Communications between the client and the CA are secured using SCEP
Secure Message Objects as explained in <xref target="message-obj" format="default"/>, which
specifies how CMS is used to encrypt and sign the data.  In order to perform
the signing operation, the client uses an appropriate local certificate:

        </t>
        <ol type="1">
          <li>If the client does not have an appropriate existing certificate,
		  then a locally generated self-signed certificate <bcp14>MUST</bcp14> be used.  The
		  keyUsage extension in the certificate <bcp14>MUST</bcp14> indicate that it is valid
		  for digitalSignature and keyEncipherment (if available).  The
		  self-signed certificate <bcp14>SHOULD</bcp14> use the same subject name and key as
		  in the PKCS #10 request.  In this case, the messageType is PKCSReq
		  (see <xref target="messageType" format="default"/>).</li>
          <li>If the client already has a certificate issued by the SCEP CA, and
		  the CA supports renewal (see <xref target="overview-cert-enrol" format="default"/>),
		  that certificate <bcp14>SHOULD</bcp14> be used. In this case, the messageType is
		  RenewalReq (see <xref target="messageType" format="default"/>).</li>
          <li>Alternatively, if the client has no certificate issued by the
		  SCEP CA but has credentials from an alternate CA, then the
		  certificate issued by the alternate CA <bcp14>MAY</bcp14> be used in a renewal
		  request as described above.  The SCEP CA's policy will determine
		  whether the request can be accepted or not.</li>
        </ol>
        <t>
Note that although the above text describes several different types of
operations, for historical reasons, most implementations always apply the first
one, even if an existing certificate already exists.  For this reason, support
for the first case is mandatory while support for the latter ones are optional
(see <xref target="MTI" format="default"/>).
        </t>
        <t>
During the certificate-enrolment process, the client <bcp14>MUST</bcp14> use
the selected certificate's key when signing the CMS envelope (see <xref
target="message-obj" format="default"/>).  This certificate will be either the
self-signed one matching the PKCS #10 request or the CA-issued one used to
authorise a renewal, and it <bcp14>MUST</bcp14> be included in the signedData
certificates field (possibly as part of a full certificate chain).  If the key
being certified allows encryption, then the CA's CertResp will use the same
certificate's public key when encrypting the response.
        </t>
        <t>
Note that, in the case of renewal operations, this means that the request will
be signed and authenticated with the key in the previously issued certificate
rather than the key in the PKCS #10 request, and the response may similarly be
returned encrypted with the key in the previously issued certificate.  This
has security implications; see <xref target="security-no-pop" format="default"/>.
        </t>
      </section>

      <section anchor="overview-enrol-auth" numbered="true" toc="default">
        <name>Enrolment Authorisation</name>
        <t>

<xref target="RFC2986" format="default">PKCS #10</xref> specifies a <xref target="RFC2985" format="default">PKCS
#9</xref> challengePassword attribute to be sent as part of the enrolment
request.  When utilising the challengePassword, the CA distributes a shared
secret to the client, which will be used to authenticate the request from the
client.  It is <bcp14>RECOMMENDED</bcp14> that the challengePassword be a
one-time
authenticator value to limit the ability of an attacker who can capture the
authenticator from the client or CA and reuse it to request further
certificates.

        </t>
        <t>

Inclusion of the challengePassword by the SCEP client is
<bcp14>RECOMMENDED</bcp14>; however,
its omission allows for unauthenticated authorisation of enrolment requests
(which may, however, require manual approval of each certificate issue if
other security measures to control issue aren't in place; see below).
Inclusion is <bcp14>OPTIONAL</bcp14> for renewal requests that are authenticated by being
signed with an existing certificate.  The CMS envelope protects the privacy of
the challengePassword.

        </t>
        <t>

A client that is performing certificate renewal as per <xref target="overview-cert-enrol" format="default"/> <bcp14>SHOULD</bcp14> omit the challengePassword but <bcp14>MAY</bcp14> send
the originally distributed shared secret in the challengePassword attribute.
The SCEP CA <bcp14>MAY</bcp14> authenticate the request using the
challengePassword in addition to the previously issued certificate that signs
the request. The SCEP CA <bcp14>MUST NOT</bcp14> attempt to authenticate a
client based on a self-signed certificate unless it has been verified through
out-of-band means such as a certificate fingerprint.
        </t>
        <t>

To perform the authorisation in manual mode, the client's request is placed in
the PENDING state until the CA operator authorises or rejects it.  Manual
authorisation is used when the client has only a self-signed certificate that
hasn't been previously authenticated by the CA and/or a challengePassword is
not available.  The SCEP CA <bcp14>MAY</bcp14> either reject unauthorised requests or mark
them for manual authorisation according to CA policy.

        </t>
      </section>
      <section anchor="overview-cert-enrol" numbered="true" toc="default">
        <name>Certificate Enrolment/Renewal</name>
        <t>
A client starts an enrolment transaction (<xref target="PKCSReq" format="default"/>) by creating a
certificate request using PKCS #10 and sends the request to the CA enveloped
using CMS (<xref target="message-obj" format="default"/>).
        </t>
        <t>

If the CA supports certificate renewal and the CA policy permits, then a new
certificate with new validity dates can be issued, even though the old one is
still valid.  To renew an existing certificate, the client uses the RenewalReq
message (see <xref target="pkiMessage-types" format="default"/>) and signs it with the existing
client certificate.  The client <bcp14>SHOULD</bcp14> use a new keypair when requesting a new
certificate but <bcp14>MAY</bcp14> request a new certificate using the old keypair.

        </t>
        <t>

If the CA returns a CertRep message (<xref target="CertRep" format="default"/>) with status set
to PENDING, the client enters into polling mode by periodically sending a
CertPoll message (<xref target="CertPoll" format="default"/>) to the CA until the CA operator
completes the manual authentication (approving or denying the request). The
frequency of the polling operation is a CA/client configuration issue and may
range from seconds or minutes when the issue process is automatic but not
instantaneous, through to hours or days if the certificate-issue operation
requires manual approval.

        </t>
        <t>

If polling mode is being used, then the client will send a single
PKCSReq/RenewalReq message (<xref target="PKCSReq" format="default"/>), followed by 0 or more
CertPoll messages (<xref target="CertPoll" format="default"/>).  The CA will, in return, send 0
or more CertRep messages (<xref target="CertRep" format="default"/>) with status set to PENDING
in response to CertPolls, followed by a single CertRep message (<xref
target="CertRep" format="default"/>) with status set to either SUCCESS or
FAILURE.

        </t>
        <section anchor="overview-client-state" numbered="true" toc="default">
          <name>Client State Transitions</name>
          <t>

The client state transitions during the SCEP process are indicated in <xref target="state-diagram" format="default"/>.

          </t>
          <figure anchor="state-diagram">
            <name>State Transition Diagram</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
                                CertPoll
                              +-----<----+
                              |          |
                              |          | CertRep(PENDING)
                              |          |
[CERT-NONEXISTENT] ------> [CERT-REQ-PENDING] --------> [CERT-ISSUED]
      ^            PKCSReq    |           CertRep(SUCCESS)
      |          RenewalReq   |
      |                       |
      +-----------------------+
      CertRep(FAILURE) or
      Max-time/max-polls exceeded
			]]></artwork>
          </figure>
          <t>

The certificate-issue process starts at state CERT-NONEXISTENT.  Sending a
PKCSReq/RenewalReq message changes the state to CERT-REQ-PENDING.

          </t>
          <t>

If the CA returns a CertRep message with pkiStatus set to SUCCESS, then the
state changes to CERT-ISSUED.

          </t>
          <t>

If the CA returns a CertRep message with pkiStatus set to FAILURE or there is
no response, then the state reverts back to CERT-NONEXISTENT.

          </t>
          <t>

If the CA returns a CertRep message with pkiStatus set to PENDING, then the
client will keep polling by sending a CertPoll message until either a CertRep
message with status set to SUCCESS or FAILURE is received, a timeout occurs,
or the maximum number of polls has been exceeded.

          </t>
          <t><xref target="automatic" /> shows a successful transaction in
	  automatic mode</t>
<figure anchor="automatic">
<name>Automatic Mode</name>
          <artwork type="" align="left" alt=""><![CDATA[
    CLIENT                              CA SERVER

PKCSReq: PKI cert. enrolment message
--------------------------------> CertRep: pkiStatus = SUCCESS
                                  Certificate attached
                                  <------------------------------
Receive issued certificate.
			]]></artwork>
</figure>

          <t><xref target="manual"/> shows a successful transaction in manual
	  mode:</t>
<figure anchor="manual">
<name>Manual Mode</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    CLIENT                              CA SERVER

PKCSReq: PKI cert. enrolment message
--------------------------------> CertRep: pkiStatus = PENDING
                                  <------------------------------
CertPoll: Polling message
--------------------------------> CertRep: pkiStatus = PENDING
                                  <------------------------------
................ <Manual identity authentication> ...............

CertPoll: Polling message
--------------------------------> CertRep: pkiStatus = SUCCESS
                                  Certificate attached
                                  <------------------------------
Receive issued certificate.
			]]></artwork>
</figure>
        </section>
      </section>
      <section anchor="overview-cert-access" numbered="true" toc="default">
        <name>Certificate Access</name>
        <t>

A certificate query message is defined for clients to retrieve a copy of their
own certificate from the CA.  It allows clients that do not store their
certificates locally to obtain a copy when needed.  This functionality is not
intended to provide a general-purpose certificate-access service, which may be
achieved instead via <xref target="RFC4387" format="default">HTTP certificate-store
access</xref> or Lightweight Directory Access Protocol (LDAP).

        </t>
        <t>

To retrieve a certificate from the CA, a client sends a request consisting of
the certificate's issuer name and serial number.  This assumes that the client
has saved the issuer name and the serial number of the issued certificate from
the previous enrolment transaction.  The transaction to retrieve a certificate
consists of one GetCert (<xref target="GetCertCRL" format="default"/>) message and one CertRep
(<xref target="CertRep" format="default"/>) message, as shown in <xref target="retrieve"/>.

        </t>
<figure anchor="retrieve">
<name>Retrieving a Certificate</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
   CLIENT                               CA SERVER

GetCert: PKI certificate query message
-------------------------------> CertRep: pkiStatus = SUCCESS
                                 Certificate attached
                                 <-----------------------------
Receive the certificate.
		  ]]></artwork>
</figure>
      </section>
      <section anchor="overview-CRL-access" numbered="true" toc="default">
        <name>CRL Access</name>
        <t>

SCEP clients <bcp14>MAY</bcp14> request a CRL via one of three methods:

        </t>
        <ol type="1">
          <li>If the CA supports the <xref target="RFC5280" format="default">CRL Distribution
		  Points (CRLDPs) extension</xref> in issued certificates, then the
		  CRL <bcp14>MAY</bcp14> be retrieved via the mechanism specified in the CRLDP.</li>
          <li>If the CA supports <xref target="RFC4387" format="default">HTTP
		  certificate-store access</xref>, then the CRL <bcp14>MAY</bcp14> be retrieved via
		  the <xref target="RFC5280" format="default">AuthorityInfoAcces</xref> location specified
		  in the certificate.</li>
          <li>Only if the CA does not support CRLDPs or HTTP access should a
		  CRL query be composed by creating a GetCRL message consisting of the
		  issuer name and serial number from the certificate whose revocation
		  status is being queried.</li>
        </ol>
        <t>

The message is sent to the SCEP CA in the same way as the other SCEP requests.
The transaction to retrieve a CRL consists of one GetCRL PKI message and one
CertRep PKI message, which contains only the CRL (no certificates) in a
degenerate certificates-only CMS SignedData message
(<xref target="certs-only" format="default"/>), as shown in <xref target="retrieve-CRL"/>. 

        </t>
<figure anchor="retrieve-CRL">
<name>Retrieving a CRL</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
       CLIENT                           CA SERVER

   GetCRL: PKI CRL query message
---------------------------------->
                                  CertRep: CRL attached
                                  <-----------------------------
Receive the CRL
		  ]]></artwork>
</figure>
      </section>
      <section anchor="overview-cert-rev" numbered="true" toc="default">
        <name>Certificate Revocation</name>
        <t>

SCEP does not specify a method to request certificate revocation.  In order to
revoke a certificate, the client must contact the CA using a non-SCEP-defined mechanism.
        </t>
      </section>
      <section anchor="MTI" numbered="true" toc="default">
        <name>Mandatory-to-Implement Functionality</name>
        <t>

At a minimum, all SCEP implementations compliant with this specification <bcp14>MUST</bcp14>
support <xref target="CA-caps-HTTP" format="default">GetCACaps</xref>,
<xref target="GetCACert" format="default">GetCACert</xref>,
<xref target="PKCSReq" format="default">PKCSReq</xref> (and its associated response messages),
communication of binary data via <xref target="HTTP-GET-POST" format="default">HTTP
POST</xref>, and the <xref target="AES" format="default">AES128-CBC</xref> and
<xref target="SHA2" format="default">SHA-256</xref> algorithms to secure
<xref target="pkiMessage" format="default">pkiMessages</xref>.

        </t>
        <t>

For historical reasons, implementations <bcp14>MAY</bcp14> support communications of binary
data via <xref target="HTTP-GET-POST" format="default">HTTP GET</xref>, and the triple DES-CBC
and SHA-1 algorithms to secure <xref target="pkiMessage" format="default">pkiMessages</xref>.
Implementations <bcp14>MUST NOT</bcp14> support the obsolete and/or insecure single DES and
MD5 algorithms used in earlier versions of this specification, since the
unsecured nature of GetCACaps means that an in-path attacker can trivially
roll back the encryption used to these insecure algorithms; see <xref
target="security-getcacaps" format="default"/>.

        </t>
      </section>
    </section>

    <section anchor="message-obj" numbered="true" toc="default">
      <name>SCEP Secure Message Objects</name>
      <t>

CMS is a general enveloping mechanism that enables both signed and encrypted
transmission of arbitrary data.  SCEP messages that require confidentiality
use two layers of CMS, as shown using ASN.1-like pseudocode in
<xref target="cms-layering" format="default"/>.  By applying both enveloping and signing
transformations, the SCEP message is protected both for the integrity of its
end-to-end transaction information and the confidentiality of its information
portion.

      </t>
      <figure anchor="cms-layering">
        <name>CMS Layering</name>
<sourcecode type="pseudocode">
pkiMessage {
  contentType = signedData { pkcs-7 2 },
  content {
    digestAlgorithms,
    encapsulatedContentInfo {
      eContentType = data { pkcs-7 1 },
      eContent {           -- pkcsPKIEnvelope, optional
        contentType = envelopedData { pkcs-7 3 },
        content {
          recipientInfo,
          encryptedContentInfo {
            contentType = data { pkcs-7 1 },
            contentEncrAlgorithm,
            encryptedContent {
              messageData  -- Typically PKCS #10 request
              }
            }
          }
        }
      },
    certificates,          -- Optional
    crls,                  -- Optional
    signerInfo {
      signedAttrs {
        transactionID,
        messageType,
        pkiStatus,
        failInfo,          -- Optional
        senderNonce / recipientNonce,
        },
      signature
      }
    }
  }
</sourcecode>
      </figure>
      <t>

When a particular SCEP message carries data, this data is carried in the
messageData.  CertRep messages will lack any signed content and consist only
of a pkcsPKIEnvelope (<xref target="pkcsPKIEnvelope" format="default"/>).

      </t>
      <t>

The remainder of this document will refer only to "messageData", but it is
understood to always be encapsulated in the pkcsPKIEnvelope (<xref target="pkcsPKIEnvelope" format="default"/>).  The format of the data in the messageData is
defined by the messageType attribute (see <xref target="pkiMessage" format="default"/>) of the
SignedData.  If there is no messageData to be transmitted, the entire
pkcsPKIEnvelope <bcp14>MUST</bcp14> be omitted.

      </t>
      <t>

Samples of SCEP messages are available through the
<xref target="JSCEP" format="default">JSCEP project</xref> in the src/samples directory.

      </t>
      <section anchor="message-processing" numbered="true" toc="default">
        <name>SCEP Message Object Processing</name>
        <t>

Creating a SCEP message consists of several stages.  The content to be
conveyed (in other words, the messageData) is first encrypted, and the
encrypted content is then signed.

        </t>
        <t>

The form of encryption to be applied depends on the capabilities of the
recipient's public key.  If the key is encryption capable (for example, RSA),
then the messageData is encrypted using the recipient's public key with the
CMS KeyTransRecipientInfo mechanism.  If the key is not encryption capable
(for example, DSA or ECDSA), then
the messageData is encrypted using the
challengePassword with the CMS PasswordRecipientInfo mechanism.

        </t>
        <t>

Once the messageData has been encrypted, it is signed with the sender's public
key.  This completes the SCEP message, which is then sent to the recipient.

        </t>
        <t>

Note that some early implementations of this specification dealt with keys
that were not encryption capable by omitting the encryption stage, based on the
text in <xref target="message-obj" format="default"/> that indicated that "the EnvelopedData is
omitted".  This alternative processing mechanism <bcp14>SHOULD NOT</bcp14> be used since it
exposes in cleartext the challengePassword used to authorise the certificate
issue.

        </t>
        <t>

        </t>
      </section>
      <section anchor="pkiMessage" numbered="true" toc="default">
        <name>SCEP pkiMessage</name>
        <t>

The basic building block of all secured SCEP messages is the SCEP pkiMessage.
It consists of a CMS SignedData content type.  The following restrictions
apply:

        </t>
        <ul spacing="compact">
          <li>The eContentType in encapsulatedContentInfo <bcp14>MUST</bcp14> be data ({pkcs-7
		     1}).</li>
          <li>The signed content, if present (FAILURE and PENDING CertRep
			 messages will lack any signed content),
			 <bcp14>MUST</bcp14> be a pkcsPKIEnvelope
			 (<xref target="pkcsPKIEnvelope" format="default"/>)
			 and <bcp14>MUST</bcp14> match the
			 messageType attribute.</li>
          <li>The SignerInfo <bcp14>MUST</bcp14> contain a set of authenticatedAttributes
			 (<xref target="signed-attrs" format="default"/>).</li>
        </ul>
        <section anchor="signed-attrs" numbered="true" toc="default">
          <name>Signed Transaction Attributes</name>
          <t>

At a minimum, all messages <bcp14>MUST</bcp14> contain the following authenticatedAttributes:

          </t>
          <ul spacing="compact">
            <li>A transactionID attribute (see <xref target="transactionID" format="default"/>).</li>
            <li>A messageType attribute (see <xref target="messageType" format="default"/>).</li>
            <li>A fresh senderNonce attribute (see <xref target="nonces"
	    format="default"/>).  However, note the comment about
	    senderNonces and polling in <xref target="CertRep" format="default"/> </li>
            <li>Any attributes required by CMS.</li>
          </ul>
          <t>

If the message is a CertRep, it <bcp14>MUST</bcp14> also include the following
authenticatedAttributes:

          </t>
          <ul spacing="compact">
            <li>A pkiStatus attribute (see <xref target="pkiStatus" format="default"/>).</li>
            <li>failInfo and optional failInfoText attributes (see <xref
	    target="failInfo" format="default"/>) if pkiStatus = FAILURE.</li>
            <li>A recipientNonce attribute (see <xref target="nonces" format="default"/>) copied
	    from the senderNonce in the request that this is a response
	    to.</li>
          </ul>
          <t>

The following transaction attributes are encoded as authenticated attributes
and carried in the SignerInfo for this SignedData.

          </t>
          <table align="left">
	    <name>SCEP Attributes</name>
            <thead>
              <tr>
                <th align="left">Attribute</th>
                <th align="left">Encoding</th>
                <th align="left">Comment</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">transactionID</td>
                <td align="left">PrintableString</td>
                <td align="left">Unique ID for this
			transaction as a text string</td>
              </tr>
              <tr>
                <td align="left">messageType</td>
                <td align="left">PrintableString</td>
                <td align="left">Decimal value as a
			numeric text string</td>
              </tr>
              <tr>
                <td align="left">pkiStatus</td>
                <td align="left">PrintableString</td>
                <td align="left">Decimal value as a
			numeric text string</td>
              </tr>
              <tr>
                <td align="left">failInfo</td>
                <td align="left">PrintableString</td>
                <td align="left">Decimal value as a
			numeric text string</td>
              </tr>
              <tr>
                <td align="left">failInfoText</td>
                <td align="left">UTF8String</td>
                <td align="left">Descriptive text for the
			failInfo value</td>
              </tr>
              <tr>
                <td align="left">senderNonce</td>
                <td align="left">OCTET STRING</td>
                <td align="left">Random nonce as a 16-byte
			binary data string</td>
              </tr>
              <tr>
                <td align="left">recipientNonce</td>
                <td align="left">OCTET STRING</td>
                <td align="left">Random nonce as a
			16-byte binary data string</td>
              </tr>
            </tbody>
          </table>
          <t>The OIDs used for these attributes are as
			          follows:</t>

          <table align="left">
	    <name>SCEP Attribute OIDs</name>
            <thead>
              <tr>
                <th align="left">Name</th>
                <th align="left">ASN.1 Definition</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">id-VeriSign</td>
                <td align="left">OBJECT_IDENTIFIER ::= {2 16 US(840) 1
			   VeriSign(113733)}</td>
              </tr>
              <tr>
                <td align="left">id-pki</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-VeriSign pki(1)}</td>
              </tr>
              <tr>
                <td align="left">id-attributes</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-pki
			   attributes(9)}</td>
              </tr>
              <tr>
                <td align="left">id-transactionID</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-attributes
			   transactionID(7)}</td>
              </tr>
              <tr>
                <td align="left">id-messageType</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-attributes
			   messageType(2)}</td>
              </tr>
              <tr>
                <td align="left">id-pkiStatus</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-attributes
			   pkiStatus(3)}</td>
              </tr>
              <tr>
                <td align="left">id-failInfo</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-attributes
			   failInfo(4)}</td>
              </tr>
              <tr>
                <td align="left">id-senderNonce</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-attributes
			   senderNonce(5)}</td>
              </tr>
              <tr>
                <td align="left">id-recipientNonce</td>
                <td align="left">OBJECT_IDENTIFIER ::= {id-attributes
				recipientNonce(6)}</td>
              </tr>
              <tr>
                <td align="left">id-scep</td>
                <td align="left">OBJECT IDENTIFIER ::= {id-pkix 24}</td>
              </tr>
              <tr>
                <td align="left">id-scep-failInfoText</td>
                <td align="left">OBJECT IDENTIFIER ::= {id-scep 1}</td>
              </tr>
            </tbody>
          </table>
          <t>

The attributes are detailed in the following sections.

          </t>
          <section anchor="transactionID" numbered="true" toc="default">
            <name>transactionID</name>
            <t>

A PKI operation is a transaction consisting of the messages exchanged between
a client and the CA.  The transactionID is a text string provided by the
client when starting a transaction.  The client <bcp14>MUST</bcp14> use a unique string as
the transaction identifier, encoded as a PrintableString, which <bcp14>MUST</bcp14> be used
for all PKI messages exchanged for a given operation, such as a certificate
issue.

            </t>
            <t>

Note that the transactionID must be unique, but not necessarily randomly
generated.  For example, it may be a value assigned by the CA to allow the
client to be identified by their transactionID, using a value such as the
client device's Extended Unique Identifier (EUI), Remote Terminal Unit (RTU) ID, or a similar unique
identifier.  This can be
useful when the client doesn't have a preassigned Distinguished Name through
which the CA can identify their request -- for example, when enrolling
Supervisory Control and Data Acquisition (SCADA) devices.

            </t>
          </section>
          <section anchor="messageType" numbered="true" toc="default">
            <name>messageType</name>
            <t>
The messageType attribute specifies the type of operation performed by the
transaction.  This attribute <bcp14>MUST</bcp14> be included in all PKI messages.  The
following message types are defined:
            </t>

<table anchor="scep-message-types"> 
  <name>SCEP Message Types</name>   
  <thead>
    <tr>
      <th>Value</th>   
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>         

    <tr>
      <td>0</td>
      <td>Reserved</td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>CertRep</td>
      <td>Response to certificate or CRL request.</td>
    </tr>
    <tr>
      <td>17</td>
      <td>RenewalReq</td>
      <td>PKCS #10 certificate request authenticated with an existing certificate.</td>
    </tr>
    <tr>
      <td>19</td>
      <td>PKCSReq</td>
      <td>PKCS #10 certificate request authenticated with a shared secret.</td>
    </tr>
    <tr>
      <td>20</td>
      <td>CertPoll</td>
      <td>Certificate polling in manual enrolment.</td>
    </tr>
    <tr>
      <td>21</td>
      <td>GetCert</td>
      <td>Retrieve a certificate.</td>
    </tr>
    <tr>
      <td>22</td>
      <td>GetCRL</td>
      <td>Retrieve a CRL.</td>
    </tr>
  </tbody>
</table>

<t>
Message types not defined above <bcp14>MUST</bcp14> be treated as errors unless their use
has been negotiated through <xref target="CA-caps-HTTP" format="default">GetCACaps</xref>.

            </t>
          </section>
          <section anchor="pkiStatus" numbered="true" toc="default">
            <name>pkiStatus</name>
            <t>

All response messages <bcp14>MUST</bcp14> include transaction status information, which is
defined as a pkiStatus attribute:
            </t>

<table anchor="tab-pkiStatus"> 
  <name>pkiStatus Attributes</name>   
  <thead>
    <tr>
      <th>Value</th>   
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>         
    <tr>
      <td>0</td>
      <td>SUCCESS</td>
      <td>Request granted.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>FAILURE</td>
      <td>Request rejected.  In this case, the failInfo attribute, as defined
      in <xref target="failInfo" format="default"/>, <bcp14>MUST</bcp14> also
      be present.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>PENDING</td>
      <td>Request pending for manual approval.</td>
    </tr>
  </tbody>
</table>

<t>
PKI status values not defined above <bcp14>MUST</bcp14> be treated as errors unless their
use has been negotiated through <xref target="CA-caps-HTTP" format="default">GetCACaps</xref>.
            </t>
          </section>
          <section anchor="failInfo" numbered="true" toc="default">
            <name>failInfo and failInfoText</name>
            <t>
The failInfo attribute <bcp14>MUST</bcp14> contain one of the following failure reasons:
            </t>

<table anchor="tab-failInfo">
  <name>failInfo Attributes</name>  
  <thead>
    <tr>
      <th>Value</th>  
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>        
    <tr>
      <td>0</td>
      <td>badAlg</td>
      <td>Unrecognised or unsupported algorithm.</td>
    </tr>
    <tr>
      <td>1</td>
      <td>badMessageCheck</td>
      <td>Integrity check (meaning signature verification of the CMS message) failed.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>badRequest</td>
      <td>Transaction not permitted or supported.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>badTime</td>
      <td>The signingTime attribute from the CMS authenticatedAttributes was
      not sufficiently close to the system time.  This condition may occur if
      the CA is concerned about replays of old messages.</td>
    </tr>
    <tr>
      <td>4</td>
      <td>badCertId</td>
      <td>No certificate could be identified matching the provided criteria.</td>
    </tr>
  </tbody>
</table>

            <t>
Failure reasons not defined above <bcp14>MUST</bcp14> be treated as errors unless their use
has been negotiated through <xref target="CA-caps-HTTP" format="default">GetCACaps</xref>.
            </t>
            <t>
The failInfoText is a free-form UTF-8 text string that provides further
information in the case of pkiStatus = FAILURE.  In particular, it may be used
to provide details on why a certificate request was not granted that go beyond
what's provided by the near-universal failInfo = badRequest status.  Since
this is a free-form text string intended for interpretation by humans,
implementations <bcp14>SHOULD NOT</bcp14> assume that it has any type of machine-processable
content.
            </t>
          </section>
          <section anchor="nonces" numbered="true" toc="default">
            <name>senderNonce and recipientNonce</name>
            <t>
The senderNonce and recipientNonce attributes are each a 16-byte random number
generated for each transaction.  These are intended to prevent replay attacks.
            </t>
            <t>
When a sender sends a PKI message to a recipient, a fresh senderNonce <bcp14>MUST</bcp14> be
included in the message.  The recipient <bcp14>MUST</bcp14> copy the senderNonce into the
recipientNonce of the reply as a proof of liveliness.  The original sender
<bcp14>MUST</bcp14> verify that the recipientNonce of the reply matches the senderNonce it
sent in the request.  If the nonce does not match, then the message <bcp14>MUST</bcp14> be
rejected.
            </t>
            <t>
Note that since SCEP exchanges consist of a single request followed by a
single response, the use of distinct sender and recipient nonces is redundant,
since the client sends a nonce in its request and the CA responds with the
same nonce in its reply.  In effect, there's just a single nonce, identified as
senderNonce in the client's request and recipientNonce in the CA's reply.
            </t>
          </section>
        </section>
        <section anchor="pkcsPKIEnvelope" numbered="true" toc="default">
          <name>SCEP pkcsPKIEnvelope</name>
          <t>

The information portion of a SCEP message is carried inside an EnvelopedData
content type, as defined in CMS, with the following restrictions:

          </t>
          <ul spacing="compact">
            <li>contentType in encryptedContentInfo <bcp14>MUST</bcp14> be data ({pkcs-7
			   1}).</li>

            <li>encryptedContent <bcp14>MUST</bcp14> be the SCEP message being transported
			   (see <xref target="SCEP-trans" format="default"/>)
			   and <bcp14>MUST</bcp14> match the
			   messageType authenticated Attribute in the pkiMessage.</li>
          </ul>
        </section>
      </section>
      <section anchor="pkiMessage-types" numbered="true" toc="default">
        <name>SCEP pkiMessage types</name>
        <t>

All of the messages in this section are pkiMessages (<xref target="pkiMessage" format="default"/>), where the type of the message <bcp14>MUST</bcp14> be specified in the
"messageType" authenticated Attribute.  Each section defines a valid message
type, the corresponding messageData formats, and mandatory authenticated
attributes for that type.

        </t>
        <section anchor="PKCSReq" numbered="true" toc="default">
          <name>PKCSReq/RenewalReq</name>
          <t>

The messageData for this type consists of a PKCS #10 Certificate Request.  The
certificate request <bcp14>MUST</bcp14> contain at least the following items:

          </t>
          <ul spacing="compact">
            <li>The subject Distinguished Name.</li>
            <li>The subject public key.</li>
            <li>For a PKCSReq, if authorisation based on a shared secret is
	    being used, a challengePassword attribute.</li>
          </ul>
          <t>

In addition, the message must contain the authenticatedAttributes specified in
<xref target="signed-attrs" format="default"/>.

          </t>
        </section>
        <section anchor="CertRep" numbered="true" toc="default">
          <name>CertRep</name>
          <t>

The messageData for this type consists of a degenerate certificates-only CMS
SignedData message (<xref target="certs-only" format="default"/>).  The exact content required
for the reply depends on the type of request that this message is a response
to.  The request types are detailed in Sections <xref target="CertRep-success"
format="counter"/> and <xref target="SCEP-trans" format="counter"/>.  In
addition, the message must contain the
authenticatedAttributes specified in <xref target="signed-attrs" format="default"/>.

          </t>
          <t>
Earlier draft versions of this specification required that this message include a
senderNonce alongside the recipientNonce, which was to be used to chain to
subsequent polling operations.  However, if a single message was lost during
the potentially extended interval over which polling could take place (see
<xref target="state-trans" format="default"/> for an example of this), then if the
implementation were to enforce this requirement, the overall transaction would
fail, even though nothing had actually gone wrong.  Because of this issue,
implementations mostly ignored the requirement to either carry this nonce over to
subsequent polling messages or verify its presence.  More recent versions
of the specification no longer require the chaining of nonces across polling
operations.

          </t>
          <section anchor="CertRep-success" numbered="true" toc="default">
            <name>CertRep SUCCESS</name>
            <t>

When the pkiStatus attribute is set to SUCCESS, the messageData for this
message consists of a degenerate certificates-only CMS SignedData message
(<xref target="certs-only" format="default"/>).  The content of this degenerate
certificates-only SignedData message depends on what the original request was, as
outlined in <xref target="success"/>.

            </t>
            <table align="left" anchor="success">
	      <name>CertRep Response Types</name>
              <thead>
                <tr>
                  <th align="left">Request-type</th>
                  <th align="left">Reply-contents</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="left">PKCSReq</td>
                  <td align="left">The reply <bcp14>MUST</bcp14> contain at least the issued
		  certificate in the certificates field of the SignedData.
		  The reply <bcp14>MAY</bcp14> contain additional certificates, but the issued
		  certificate <bcp14>MUST</bcp14> be the leaf certificate.</td>
                </tr>
                <tr>
                  <td align="left">RenewalReq</td>
                  <td align="left">Same as PKCSReq</td>
                </tr>
                <tr>
                  <td align="left">CertPoll</td>
                  <td align="left">Same as PKCSReq</td>
                </tr>
                <tr>
                  <td align="left">GetCert</td>
                  <td align="left">The reply <bcp14>MUST</bcp14> contain at least the requested
				 certificate in the certificates field of the SignedData.
				 The reply <bcp14>MAY</bcp14> contain additional certificates, but the
				 requested certificate <bcp14>MUST</bcp14> be the leaf certificate.</td>
                </tr>
                <tr>
                  <td align="left">GetCRL</td>
                  <td align="left">The reply <bcp14>MUST</bcp14> contain the
		  CRL in the crls field of the SignedData.</td>
                </tr>
              </tbody>
            </table>
          </section>
          <section anchor="CertRep-failure" numbered="true" toc="default">
            <name>CertRep FAILURE</name>
            <t>

When the pkiStatus attribute is set to FAILURE, the reply <bcp14>MUST</bcp14> also contain a
failInfo (<xref target="failInfo" format="default"/>) attribute set to the appropriate error
condition describing the failure.  The reply <bcp14>MAY</bcp14> also contain a failInfoText
attribute providing extended details on why the operation failed, typically to
expand on the catchall failInfo = badRequest status.  The pkcsPKIEnvelope
(<xref target="pkcsPKIEnvelope" format="default"/>) <bcp14>MUST</bcp14> be omitted.

            </t>
          </section>
          <section anchor="CertRep-pending" numbered="true" toc="default">
            <name>CertRep PENDING</name>
            <t>

When the pkiStatus attribute is set to PENDING, the pkcsPKIEnvelope (<xref target="pkcsPKIEnvelope" format="default"/>) <bcp14>MUST</bcp14> be omitted.

            </t>
          </section>
        </section>
        <section anchor="CertPoll" numbered="true" toc="default">
          <name>CertPoll (GetCertInitial)</name>
          <t>
This message is used for certificate polling.  For unknown reasons, it was
referred to as "GetCertInitial" in earlier draft versions of this specification.
The messageData for this type consists of an IssuerAndSubject:
          </t>

<sourcecode>
issuerAndSubject ::= SEQUENCE {
    issuer     Name,
    subject    Name
    }
</sourcecode>

          <t>
The issuer is set to the subjectName of the CA (in other words, the intended
issuerName of the certificate that's being requested).  The subject is set to
the subjectName used when requesting the certificate.
          </t>

          <t>
Note that both of these fields are redundant; the CA is identified by the
recipientInfo in the pkcsPKIEnvelope (or in most cases, simply by the server
that the message is being sent to), and the client/transaction being polled is
identified by the transactionID.  Both of these fields can be processed by the
CA without going through the cryptographically expensive process of unwrapping
and processing the issuerAndSubject.  For this reason, implementations <bcp14>SHOULD</bcp14>
assume that the polling operation will be controlled by the recipientInfo and
transactionID rather than the contents of the messageData.  In addition, the
message must contain the authenticatedAttributes specified in <xref
target="signed-attrs" format="default"/>.

          </t>
        </section>
        <section anchor="GetCertCRL" numbered="true" toc="default">
          <name>GetCert and GetCRL</name>
          <t>

The messageData for these types consist of an IssuerAndSerialNumber, as defined
in CMS, that uniquely identifies the certificate being requested, either the
certificate itself for GetCert or its revocation status via a CRL for GetCRL.
In addition, the message must contain the authenticatedAttributes specified
in <xref target="signed-attrs" format="default"/>.

          </t>
          <t>

These message types, while included here for completeness, apply unnecessary
cryptography and messaging overhead to the simple task of transferring a
certificate or CRL (see <xref target="security-unnecessary" format="default"/>).
Implementations <bcp14>SHOULD</bcp14> prefer
<xref target="RFC4387" format="default">HTTP certificate-store access</xref> or LDAP
over the use of these messages.

          </t>
        </section>
      </section>
      <section anchor="certs-only" numbered="true" toc="default">
        <name>Degenerate certificates-only CMS SignedData</name>

        <t>
CMS includes a degenerate case of the SignedData content type in which there
are no signers.  The use of such a degenerate case is to disseminate
certificates and CRLs.  For SCEP, the content field of the ContentInfo value of
a degenerate certificates-only SignedData <bcp14>MUST</bcp14> be omitted.  When carrying
certificates, the certificates are included in the certificates field of the
SignedData.  When carrying a CRL, the CRL is included in the crls field of
the SignedData.
        </t>
      </section>
      <section anchor="CA-caps" numbered="true" toc="default">
        <name>CA Capabilities</name>
        <t>

In order to provide support for future enhancements to the protocol, CAs <bcp14>MUST</bcp14>
implement the GetCACaps message to allow clients to query which functionality
is available from the CA.

        </t>
        <section anchor="CA-caps-HTTP" numbered="true" toc="default">
          <name>GetCACaps HTTP Message Format</name>
          <t>This message requests capabilities from a CA, with the
	  format as described in <xref target="HTTP-GET-POST" format="default"/>:</t>

<sourcecode type="">
"GET" SP SCEPPATH "?operation=GetCACaps" SP HTTP-version CRLF
</sourcecode>

        </section>

        <section anchor="CA-caps-resp" numbered="true" toc="default">
          <name>CA Capabilities Response Format</name>
          <t>The response for a GetCACaps message is a list of CA
					  capabilities, in plain text and in any order, separated
					  by &lt;CR&gt;&lt;LF&gt; or &lt;LF&gt; characters.  This
					  specification defines the following keywords (quotation
					  marks are not sent):</t>
          <table align="left" anchor="keywords">
	    <name>GetCACaps Response Keywords</name>
            <thead>
              <tr>
                <th align="left">Keyword</th>
                <th align="left">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">AES</td>
                <td align="left">CA supports the AES128-CBC encryption
			   algorithm.</td>
              </tr>
              <tr>
                <td align="left">DES3</td>
                <td align="left">CA supports the triple DES-CBC encryption
			   algorithm.</td>
              </tr>
              <tr>
                <td align="left">GetNextCACert</td>
                <td align="left">CA supports the GetNextCACert
				message.</td>
              </tr>
              <tr>
                <td align="left">POSTPKIOperation</td>
                <td align="left">CA supports PKIOPeration messages sent
			   via HTTP POST.</td>
              </tr>
              <tr>
                <td align="left">Renewal</td>
                <td align="left">CA supports the Renewal CA operation.</td>
              </tr>
              <tr>
                <td align="left">SHA-1</td>
                <td align="left">CA supports the SHA-1 hashing algorithm.</td>
              </tr>
              <tr>
                <td align="left">SHA-256</td>
                <td align="left">CA supports the SHA-256 hashing algorithm.</td>
              </tr>
              <tr>
                <td align="left">SHA-512</td>
                <td align="left">CA supports the SHA-512 hashing algorithm.</td>
              </tr>
              <tr>
                <td align="left">SCEPStandard</td>
                <td align="left">CA supports all mandatory-to-implement
			sections of the SCEP standard.  This keyword implies "AES",
			"POSTPKIOperation", and "SHA-256", as well as the provisions of
			<xref target="MTI" format="default"/>.</td>
              </tr>
            </tbody>
          </table>
          <t>

<xref target="keywords" /> lists all of the keywords that are defined in this
specification.  A CA <bcp14>MAY</bcp14> provide additional keywords advertising further
capabilities and functionality.  A client <bcp14>MUST</bcp14> be able to accept and ignore
any unknown keywords that might be sent by a CA.
          </t>
          <t>
The CA <bcp14>MUST</bcp14> use the text case specified here, but clients
<bcp14>SHOULD</bcp14> ignore the text case when processing this message. 
Clients <bcp14>MUST</bcp14> accept the standard
HTTP-style text delimited by &lt;CR&gt;&lt;LF&gt; as well as the
text delimited by &lt;LF&gt; specified in an earlier draft version of this
specification.
          </t>
          <t>
The client <bcp14>SHOULD</bcp14> use SHA-256 in preference to SHA-1 hashing and AES128-CBC in
preference to triple DES-CBC if they are supported by the CA.  Although the
CMS format allows any form of  AES and SHA-2 to be specified, in the interests
of interoperability the de facto universal standards of AES128-CBC and SHA-256
<bcp14>SHOULD</bcp14> be used.
          </t>
          <t>
Announcing some of these capabilities individually is redundant, since they're
required as mandatory-to-implement functionality (see <xref target="MTI" format="default"/>)
whose presence as a whole is signalled by the "SCEPStandard" capability. However,
it may be useful to announce them in order to deal with older implementations
that would otherwise default to obsolete, insecure algorithms and mechanisms.

          </t>
          <t>

If the CA supports none of the above capabilities, it <bcp14>SHOULD</bcp14> return an empty
message.  A CA <bcp14>MAY</bcp14> simply return an HTTP error.  A client that receives an
empty message or an HTTP error <bcp14>SHOULD</bcp14> interpret the response as if none of the
capabilities listed are supported by the CA.

          </t>
          <t>

Note that at least one widely deployed server implementation supports several
of the above operations but doesn't support the GetCACaps message to indicate
that it supports them, and it will close the connection if sent a GetCACaps
message.  This means that the equivalent of GetCACaps must be performed
through server fingerprinting, which can be done using the ID string
"Microsoft-IIS".  Newer versions of the same server, if sent a SCEP request
using AES and SHA-2, will respond with an invalid response that can't be
decrypted, requiring the use of 3DES and SHA-1 in order to obtain a response
that can be processed, even if AES and/or SHA-2 are allegedly supported.  In
addition, the server will generate CA certificates that only have one, but not
both, of the keyEncipherment and digitalSignature keyUsage flags set,
requiring that the client ignore the keyUsage flags in order to use the
certificates for SCEP.

          </t>
          <t>

The Content-type of the reply <bcp14>SHOULD</bcp14> be "text/plain".  Clients
<bcp14>SHOULD</bcp14> ignore
the Content-type, as older implementations of SCEP may send various
Content-types.
          </t>

          <t>Example:</t>
<sourcecode>
GET /cgi-bin/pkiclient.exe?operation=GetCACaps HTTP/1.1
</sourcecode>

          <t>might return:</t>
<sourcecode>
AES
GetNextCACert
POSTPKIOperation
SCEPStandard
SHA-256
</sourcecode>
          <t>

This means that the CA supports modern crypto algorithms, and the GetNextCACert
message allows PKIOperation messages (PKCSReq/RenewalReq, GetCert, CertPoll,
...) to be sent using HTTP POST and is compliant with the final version of
the SCEP standard.

          </t>
        </section>
      </section>
    </section>
    <section anchor="SCEP-trans" numbered="true" toc="default">
      <name>SCEP Transactions</name>
      <t>

This section describes the SCEP Transactions and their
<xref target="RFC7230" format="default">HTTP</xref> transport mechanism.

      </t>
      <t>

Note that SCEP doesn't follow best current practices on usage of HTTP.  In
particular, it recommends ignoring some media types and hard-codes specific URI
paths.  Guidance on the appropriate application of HTTP in these circumstances
may be found in <xref target="I-D.ietf-httpbis-bcp56bis" format="default"/>.

      </t>
      <section anchor="HTTP-GET-POST" numbered="true" toc="default">
        <name>HTTP POST and GET Message Formats</name>
        <t>

SCEP uses the HTTP POST and GET methods <xref target="RFC7230" format="default"/> to
exchange information with the CA.  The following defines the ABNF syntax of
HTTP POST and GET methods sent from a client to a CA:

        </t>
<sourcecode type="abnf">
POSTREQUEST = "POST" SP SCEPPATH "?operation=" OPERATION
              SP HTTP-version CRLF

GETREQUEST = "GET" SP SCEPPATH "?operation=" OPERATION
             "&amp;message=" MESSAGE SP HTTP-version CRLF
</sourcecode>

        <t>
where:

        </t>
        <ul spacing="compact">
          <li>SCEPPATH is the HTTP URL path for accessing the CA. Clients
		  <bcp14>SHOULD</bcp14> set SCEPPATH to the fixed string "/cgi-bin/pkiclient.exe"
		  unless directed to do otherwise by the CA.</li>
          <li>OPERATION depends on the SCEP transaction and is defined in the
		  following sections.</li>
          <li>HTTP-version is the HTTP version string, which is "HTTP/1.1" for
		  <xref target="RFC7230" format="default"/>.</li>
          <li>SP and CRLF are space and carriage return/linefeed, as defined in
		  <xref target="RFC5234" format="default"/>.</li>
        </ul>
        <t>

The CA will typically ignore SCEPPATH, since it's unlikely to be issuing
certificates via a web server.  Clients <bcp14>SHOULD</bcp14> set SCEPPATH to the fixed
string "/cgi-bin/pkiclient.exe" unless directed to do otherwise by the CA.
The CA <bcp14>SHOULD</bcp14> ignore the SCEPPATH unless its precise format is critical to the
CA's operation.

        </t>
        <t>
Early SCEP drafts performed all communications via GET messages, including
non-idempotent ones that should have been sent via POST messages; see
<xref target="I-D.ietf-httpbis-bcp56bis" format="default"/> for details.  This has caused problems because of
the way that the (supposedly) idempotent GET interacts with caches and
proxies, and because the extremely large GET requests created by encoding CMS
messages may be truncated in transit.  These issues are typically not visible
when testing on a LAN, but crop up during deployment over WANs.  If the remote
CA supports POST, the CMS-encoded SCEP messages <bcp14>MUST</bcp14> be sent via HTTP POST
instead of HTTP GET.  This applies to any SCEP message except GetCACert,
GetNextCACert, and GetCACaps and avoids the need for base64 and URL encoding
that's required for GET messaging.  The client can verify that the CA supports
SCEP messages via POST by looking for the "SCEPStandard" or "POSTPKIOperation"
capability (see <xref target="CA-caps-resp" format="default"/>).

        </t>
        <t>
If a client or CA uses HTTP GET and encounters HTTP-related problems such as
messages being truncated, seeing errors such as HTTP 414 ("Request-URI too
long"), or simply having the message not sent/received at all when standard
requests to the server (for example, via a web browser) work, then this is a
symptom of the problematic use of HTTP GET.  The solution to this problem is
to update the implementation to use HTTP POST instead.  In addition, when using
GET, it's recommended to test the implementation from as many different network
locations as possible to determine whether the use of GET will cause problems
with communications.

        </t>
        <t>

When using GET messages to communicate binary data, base64 encoding as
specified in <xref target="RFC4648" sectionFormat="of" section="4"/>
<bcp14>MUST</bcp14> be used.  The base64-encoded data is distinct from
"base64url" and may contain URI reserved
characters; thus, it <bcp14>MUST</bcp14> be escaped as specified in <xref
target="RFC3986" format="default"/> in addition to being base64 encoded.
Finally, the encoded data is inserted into
the MESSAGE portion of the HTTP GET request.

        </t>
      </section>
      <section anchor="GetCACert" numbered="true" toc="default">
        <name>Get CA Certificate</name>
        <t>

To get the CA certificate(s), the client sends a GetCACert message to the CA.
The OPERATION <bcp14>MUST</bcp14> be set to "GetCACert".  There is no request data associated
with this message.

        </t>
        <section anchor="GetCACert-resp" numbered="true" toc="default">
          <name>Get CA Certificate Response Message Format</name>
          <t>

The response for GetCACert is different between the case where the CA directly
communicates with the client during the enrolment and the case where an
intermediate CA exists and the client communicates with this CA during the
enrolment.

          </t>
          <section anchor="GetCACert-resp-format" numbered="true" toc="default">
            <name>CA Certificate Response Message Format</name>
            <t>

If the CA does not have any intermediate CA certificates, the response
consists of a single X.509 CA certificate.  The response will have a
Content-Type of "application/x-x509-ca-cert".

            </t>
<sourcecode>
"Content-Type: application/x-x509-ca-cert"

&lt;binary X.509&gt;
</sourcecode>
          </section>
          <section anchor="GetCACertChain-resp-format" numbered="true" toc="default">
            <name>CA Certificate Chain Response Message Format</name>
            <t>
If the CA has intermediate CA certificates, the response consists of a
degenerate certificates-only CMS SignedData message (<xref target="certs-only" format="default"/>) containing the certificates, with the intermediate CA
certificate(s) as the leaf certificate(s).  The response will have a
Content-Type of "application/x-x509-ca-ra-cert".  Note that this designation
is used for historical reasons due to its use in older versions of this
specification -- no special meaning should be attached to the label.
            </t>

<sourcecode>
"Content-Type: application/x-x509-ca-ra-cert"

&lt;binary CMS&gt;
</sourcecode>
          </section>
        </section>
      </section>
      <section anchor="cert-enrolment" numbered="true" toc="default">
        <name>Certificate Enrolment/Renewal</name>
        <t>
A PKCSReq/RenewalReq (<xref target="PKCSReq" format="default"/>) message is used to perform a
certificate enrolment or renewal transaction.  The OPERATION <bcp14>MUST</bcp14> be set to
"PKIOperation".  Note that when used with HTTP POST, the only OPERATION
possible is "PKIOperation", so many CAs don't check this value or even notice
its absence.  When implemented using HTTP POST, the message is sent with a
Content-Type of "application/x-pki-message" and might look as follows:
        </t>

<sourcecode>
POST /cgi-bin/pkiclient.exe?operation=PKIOperation HTTP/1.1
Content-Length: &lt;length of data&gt;
Content-Type: application/x-pki-message

&lt;binary CMS data&gt;
</sourcecode>
        <t>
	  When implemented using HTTP GET, this might look as follows:
        </t>

<sourcecode>
GET /cgi-bin/pkiclient.exe?operation=PKIOperation&amp; \
message=MIAGCSqGSIb3DQEHA6CAMIACAQAxgDCBzAIBADB2MG \
IxETAPBgNVBAcTCE......AAAAAA== HTTP/1.1
</sourcecode>
  
      <section anchor="cert-enrolment-resp" numbered="true" toc="default">
          <name>Certificate Enrolment/Renewal Response Message</name>
          <t>

If the request is granted, a CertRep SUCCESS message
(<xref target="CertRep-success" format="default"/>) is returned.  If the request is rejected, a
CertRep FAILURE message (<xref target="CertRep-failure" format="default"/>) is returned.  If
the CA is configured to manually authenticate the client, a CertRep PENDING
message (<xref target="CertRep-pending" format="default"/>) <bcp14>MAY</bcp14> be returned.  The CA <bcp14>MAY</bcp14> return
a PENDING for other reasons.

          </t>
          <t>
The response will have a Content-Type of "application/x-pki-message".
          </t>

<sourcecode>
"Content-Type: application/x-pki-message"

&lt;binary CertRep message&gt;
</sourcecode>
        </section>
      </section>
      <section anchor="poll-resp" numbered="true" toc="default">
        <name>Poll for Client Initial Certificate</name>
        <t>

When the client receives a CertRep message with pkiStatus set to PENDING, it
will enter the polling state by periodically sending CertPoll messages to the
CA until either the request is granted and the certificate is sent back or the
request is rejected or some preconfigured time limit for polling or maximum
number of polls is exceeded.  The OPERATION <bcp14>MUST</bcp14> be set to "PKIOperation".

        </t>
        <t>

CertPoll messages exchanged during the polling period <bcp14>MUST</bcp14> carry the same
transactionID attribute as the previous PKCSReq/RenewalReq.  A CA receiving a
CertPoll for which it does not have a matching PKCSReq/RenewalReq <bcp14>MUST</bcp14> reject
this request.

        </t>
        <t>

Since at this time the certificate has not been issued, the client can only
use its own subject name (which was contained in the original PKCS# 10 sent
via PKCSReq/RenewalReq) to identify the polled certificate request (but see
the note on identification during polling in <xref target="CertPoll"
format="default"/>).  In
theory, there can be multiple outstanding requests from one client (for
example, if different keys and different key usages were used to request
multiple certificates), so the transactionID must also be included to
disambiguate between multiple requests.  In practice, however, the client <bcp14>SHOULD
NOT</bcp14> have multiple requests outstanding at any one time, since this tends to
confuse some CAs.

        </t>
        <section anchor="poll-resp-format" numbered="true" toc="default">
          <name>Polling Response Message Format</name>
          <t>

The response messages for CertPoll are the same as in <xref target="cert-enrolment-resp" format="default"/>.

          </t>
        </section>
      </section>
      <section anchor="cert-access" numbered="true" toc="default">
        <name>Certificate Access</name>
        <t>

A client can query an issued certificate from the SCEP CA, as long as the
client knows the issuer name and the issuer-assigned certificate serial
number.

        </t>
        <t>

This transaction consists of one GetCert (<xref target="GetCertCRL" format="default"/>) message
sent to the CA by a client and one CertRep (<xref target="CertRep" format="default"/>) message
sent back from the CA.  The OPERATION <bcp14>MUST</bcp14> be set to "PKIOperation".

        </t>
        <section anchor="cert-access-resp" numbered="true" toc="default">
          <name>Certificate Access Response Message Format</name>
          <t>

In this case, the CertRep from the CA is same as in <xref target="cert-enrolment-resp" format="default"/>, except that the CA will either grant the
request (SUCCESS) or reject it (FAILURE).

          </t>
        </section>
      </section>
      <section anchor="CRL-access" numbered="true" toc="default">
        <name>CRL Access</name>
        <t>

Clients can request a CRL from the SCEP CA, as described in <xref
target="overview-CRL-access" format="default"/>.  The OPERATION
<bcp14>MUST</bcp14> be set to "PKIOperation".

        </t>
        <section anchor="CRL-access-resp" numbered="true" toc="default">
          <name>CRL Access Response Message Format</name>
          <t>

The CRL is sent back to the client in a CertRep (<xref target="CertRep" format="default"/>)
message.  The information portion of this message is a degenerate
certificates-only SignedData (<xref target="certs-only"
format="default"/>) that contains only
the most recent CRL in the crls field of the SignedData.

          </t>
        </section>
      </section>
      <section anchor="get-next-CA" numbered="true" toc="default">
        <name>Get Next Certificate Authority Certificate</name>
        <t>

When a CA certificate is about to expire, clients need to retrieve the CA's
next CA certificate (i.e., the rollover certificate). This is done via the
GetNextCACert message.  The OPERATION <bcp14>MUST</bcp14> be set to "GetNextCACert".  There
is no request data associated with this message.

        </t>
        <section anchor="get-next-CA-format" numbered="true" toc="default">
          <name>Get Next CA Response Message Format</name>
          <t>

The response consists of a SignedData CMS message, signed by the current CA
signing key.  Clients <bcp14>MUST</bcp14> validate the signature on the message before
trusting any of its contents.  The response will have a Content-Type of
"application/x-x509-next-ca-cert".
          </t>

<sourcecode>
"Content-Type: application/x-x509-next-ca-cert"

&lt;binary CMS&gt;
</sourcecode>
          <t>

The content of the SignedData message is a degenerate certificates-only
SignedData message (<xref target="certs-only" format="default"/>) containing the new CA
certificate(s) to be used when the current CA certificate expires.

          </t>
        </section>
      </section>
    </section>

    <section anchor="state-trans" numbered="true" toc="default">
      <name>SCEP Transaction Examples</name>
      <t>

The following section gives several examples of client-to-CA transactions.
Client actions are indicated in the left column, CA actions are indicated in
the right column, and the transactionID is given in parentheses. For ease of
reading, small integer values have been used; in practice, full transaction IDs
would be used.  The first transaction, for example, would read like this:

      </t>
      <blockquote>
Client Sends PKCSReq message with transactionID 1 to the CA.  The CA signs
the certificate and constructs a CertRep Message containing the signed
certificate with a transaction ID 1.  The client receives the message and
installs the certificate locally.
      </blockquote>
      <section numbered="true" toc="default">
        <name>Successful Transactions</name>
<figure>
<name>Successful Enrolment Case: Automatic Processing</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
PKCSReq (1)             ----------> CA issues certificate
                        <---------- CertRep (1) SUCCESS
Client installs certificate
		  ]]></artwork>
</figure>

<figure>
        <name>Successful Enrolment Case: Manual Authentication Required</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
PKCSReq (2)             ----------> Cert request goes into queue
                        <---------- CertRep (2) PENDING
CertPoll (2)            ----------> Still pending
                        <---------- CertRep (2) PENDING
CertPoll (2)            ----------> CA issues certificate
                        <---------- CertRep (2) SUCCESS
Client installs certificate
		  ]]></artwork>
</figure>

<figure>
<name>CA Certificate Rollover Case</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
GetNextCACert         ---------->
                      <---------- New CA certificate

PKCSReq*              ----------> CA issues certificate with
                                  new key
                      <---------- CertRep SUCCESS
Client stores certificate
for installation when
existing certificate expires.
		  ]]></artwork>
</figure>

        <t>* Enveloped for the new CA certificate.  The CA will use
					   the envelope to determine which key to use to issue the
					   client certificate.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Transactions with Errors</name>
        <t>

In the case of polled transactions that aren't completed automatically, there
are two potential options for dealing with a transaction that's interrupted
due to network or software/hardware issues.  The first is for the client to
preserve its transaction state and resume the CertPoll polling when normal
service is restored. The second is for the client to begin a new transaction
by sending a new PKCSReq/RenewalReq, rather than continuing the previous
CertPoll.  Both options have their own advantages and disadvantages.

        </t>
        <t>

The CertPoll continuation requires that the client maintain its transaction
state for the time when it resumes polling.  This is relatively simple if the
problem is a brief network outage, but less simple when the problem is a
client crash and restart.  In addition, the CA may treat a lost network
connection as the end of a transaction, so that a new connection followed by a
CertPoll will be treated as an error.

        </t>
        <t>

The PKCSReq/RenewalReq continuation doesn't require any state to be maintained,
since it's a new transaction. However, it may cause problems on the CA side if
the certificate was successfully issued but the client never received it,
since the resumed transaction attempt will appear to be a request for a
duplicate certificate (see <xref target="security-no-conf" format="default"/> for more on why
this is a problem).  In this case, the CA may refuse the transaction or
require manual intervention to remove/revoke the previous certificate before
the client can request another one.

        </t>
        <t>

Since the new-transaction resume is more robust in the presence of errors and
doesn't require special-case handling by either the client or CA, clients
<bcp14>SHOULD</bcp14> use the new-transaction option in preference to the resumed-CertPoll
option to recover from errors.

        </t>
        <t>Resync Case 1: Client resyncs via new PKCSReq
					(recommended):</t>
<figure>
<name>Resync Case 1</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
PKCSReq (3)           ----------> Cert request goes into queue
                      <---------- CertRep (3) PENDING
CertPoll (3)          ----------> Still pending
                        X-------- CertRep(3) PENDING
(Network outage)
(Client reconnects)
PKCSReq (4)           ---------->
                      <---------- CertRep (4) PENDING
etc...
		  ]]></artwork>
</figure>

        <t>Resync Case 2: Client resyncs via resumed CertPoll after a
					network outage (not recommended; use PKCSReq to
					resync):</t>
<figure>
<name>Resync Case 2</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
PKCSReq (5)           ----------> Cert request goes into queue
                      <---------- CertRep (5) PENDING
CertPoll (5)          ----------> Still pending
                        X-------- CertRep(5) PENDING
(Network outage)
(Client reconnects)
CertPoll (5)          ----------> CA issues certificate
                      <---------- CertRep (5) SUCCESS
Client installs certificate
		  ]]></artwork>
</figure>

        <t>Resync Case 3: Special-case variation of Case 2 where the
					CertRep SUCCESS rather than the CertRep PENDING is
					lost (recommended):</t>
<figure>
<name>Resync Case 3</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
PKCSReq (6)           ----------> Cert request goes into queue
                      <---------- CertRep (6) PENDING
CertPoll (6)          ----------> Still pending
                      <---------- CertRep (6) PENDING
CertPoll (6)          ----------> CA issues certificate
                        X-------- CertRep(6) SUCCESS
(Network outage)
(Client reconnects)
PKCSReq (7)           ----------> There is already a valid
                                  certificate with this
				  Distinguished Name (DN).
                      <---------- CertRep (7) FAILURE
                                  Admin revokes certificate
PKCSReq (8)           ----------> CA issues new certificate
                      <---------- CertRep (8) SUCCESS
Client installs certificate
		  ]]></artwork>
</figure>

        <t>Resync Case 4: Special-case variation of Case 1 where the
					CertRep SUCCESS rather than the CertRep PENDING is lost
					(not recommended; use PKCSReq to resync):</t>
<figure>
<name>Resync Case 4</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
PKCSReq (9)           ----------> Cert request goes into queue
                      <---------- CertRep (9) PENDING
CertPoll (9)          ----------> Still pending
                      <---------- CertRep (9) PENDING
CertPoll (9)          ----------> CA issues certificate
                        X-------- CertRep(9) SIGNED CERT
(Network outage)
(Client reconnects)
CertPoll (9)          ----------> Certificate already issued
                      <---------- CertRep (9) SUCCESS
Client installs certificate
		  ]]></artwork>
</figure>
        <t>

As these examples indicate, resumption from an error via a resumed CertPoll is
tricky due to the state that needs to be held by both the client and/or the
CA.  A PKCSReq/RenewalReq resume is the easiest to implement, since it's
stateless and is identical for both polled and nonpolled transactions, whereas
a CertPoll resume treats the two differently. (A nonpolled transaction is
resumed with a PKCSReq/RenewalReq; a polled transaction is resumed with a
CertPoll.)  For this reason, error recovery <bcp14>SHOULD</bcp14> be handled via a new PKCSReq
rather than a resumed CertPoll.


        </t>
      </section>
    </section>

    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>
An object identifier for an arc to assign SCEP Attribute Identifiers has been
assigned in the "SMI Security for PKIX" registry (1.3.6.1.5.5.7).  This object
identifer, Simple Certificate Enrollment Protocol Attributes, is denoted as
id-scep:
      </t>

<sourcecode>
id-scep OBJECT IDENTIFIER ::= { id-pkix 24 }
</sourcecode>
  
      <t>
IANA created the "SMI Security for SCEP Attribute Identifiers" registry
(1.3.6.1.5.5.7.24) with the following entries with references to
this document:
      </t>

<sourcecode>
id-scep-failInfoText OBJECT IDENTIFIER ::= { id-scep 1 }
</sourcecode>
  
    <t>
Entries in the registry are assigned according to the "Specification Required"
policy defined in <xref target="RFC8126" format="default"/>.
      </t>
      <t>
<xref target="messageType" format="default"/> describes an "SCEP Message Type" registry, and
<xref target="CA-caps" format="default"/> describes an "SCEP CA Capabilities"
registry; these registries are maintained by IANA and define a number of such
code-point identifiers. Entries in the registry are assigned according
to the "Specification Required" policy defined in <xref target="RFC8126" format="default"/>.

      </t>
      <t>
The "SCEP Message Types" registry has "Value", "Name", "Description", and
"Reference" columns.  The "Value" entry is a small positive integer; value
"0" is reserved.
      </t>
      <t>
The "SCEP CA Capabilities" registry has "Keyword", "Description", and
"Reference" columns.  Although implementations <bcp14>SHOULD</bcp14> use the "SCEP CA Capabilities"
registry, SCEP is often employed in situations where this isn't possible.  In
this case, private-use CA capabilities may be specified using a unique prefix
such as an organisation identifier or domain name under the control of the
entity that defines the capability.  For example, the prefix would be
"Example.com-", and the complete capability would be
"Example.com-CapabilityName".
      </t>
      <t>
IANA has registered four media types as defined in this document: 
      </t>

<ul>
<li>application/x-x509-ca-cert</li>
<li>application/x-x509-ca-ra-cert</li>
<li>application/x-x509-next-ca-cert</li>
<li>application/x-pki-message</li>
</ul>
      <t>
Note that these are grandfathered media types registered as per <xref
target="RFC6838" sectionFormat="of" section="A"/>.  Templates
for registrations are specified below.
      </t>

      <section numbered="true" toc="default">
        <name>Registration of the application/x-x509-ca-cert Media Type</name>
<dl>
<dt>Type name:</dt>
<dd>application</dd>
<dt>Subtype name:</dt>
<dd>x-x509-ca-cert</dd>
<dt>Required parameters:</dt>
<dd>none</dd>
<dt>Optional parameters:</dt>
<dd>none</dd>
<dt>Encoding considerations:</dt>
<dd>binary</dd>
<dt>Security considerations:</dt>
<dd>This media type contains a certificate; see the
Security Considerations section of <xref target="RFC5280"
format="default"/>. There is no executable content.</dd>
<dt>Interoperability considerations:</dt>
<dd>This is a grandfathered registration of an alias to application/pkix-cert
(basically a single DER-encoded Certification Authority certificate), which is
only used in SCEP.</dd>
<dt>Published specification:</dt>
<dd>RFC 8894</dd>
<dt>Applications that use this media type:</dt>
<dd>SCEP uses this media type when returning a CA certificate.</dd>
<dt>Fragment identifier considerations:</dt>
<dd>N/A</dd>
<dt>Additional information:</dt>
<dd><t><br/></t>
<dl>
<dt>Deprecated alias names for this type:</dt>
<dd>N/A</dd>
<dt>Magic number(s):</dt>
<dd>none</dd>
<dt>File extension(s):</dt>
<dd>N/A</dd>
<dt>Macintosh file type code(s):</dt>
<dd>N/A</dd>
</dl>
</dd>
<dt>Person and email address to contact for further information:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Intended usage:</dt>
<dd>LIMITED USE</dd>
<dt>Restrictions on usage:</dt>
<dd>SCEP protocol</dd>
<dt>Author:</dt>
<dd>See the Authors' Addresses section of RFC 8894</dd>
<dt>Change controller:</dt>
<dd>IETF</dd>
<dt>Provisional registration?</dt>
<dd>No</dd>
</dl>
      </section>
      <section numbered="true" toc="default">
        <name>Registration of the application/x-x509-ca-ra-cert Media Type</name>

<dl>
<dt>Type name:</dt>
<dd>application</dd>
<dt>Subtype name:</dt>
<dd>x-x509-ca-ra-cert</dd>
<dt>Required parameters:</dt>
<dd>none</dd>
<dt>Optional parameters:</dt>
<dd>none</dd>
<dt>Encoding considerations:</dt>
<dd>binary</dd>
<dt>Security considerations:</dt>
<dd>This media type consists of a degenerate
certificates-only CMS SignedData message (<xref target="certs-only"
format="default"/>) containing the certificates, with the intermediate CA
certificate(s) as the leaf certificate(s). There is no executable
content.</dd>
<dt>Interoperability considerations:</dt>
<dd>This is a grandfathered registration that is only used in SCEP.</dd>
<dt>Published specification:</dt>
<dd>RFC 8894</dd>
<dt>Applications that use this media type:</dt>
<dd>SCEP uses this media type when returning CA Certificate Chain
Response.</dd>
<dt>Fragment identifier considerations:</dt>
<dd>N/A</dd>
<dt>Additional information:</dt>
<dd><t><br/></t>
<dl>
<dt>Deprecated alias names for this type:</dt>
<dd>N/A</dd>
<dt>Magic number(s):</dt>
<dd>none</dd>
<dt>File extension(s):</dt>
<dd>N/A</dd>
<dt>Macintosh file type code(s):</dt>
<dd>N/A</dd>
</dl>
</dd>
<dt>Person and email address to contact for further information:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Intended usage:</dt>
<dd>LIMITED USE</dd>
<dt>Restrictions on usage:</dt>
<dd>SCEP protocol</dd>
<dt>Author:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Change controller:</dt>
<dd>IETF</dd>
<dt>Provisional registration?</dt>
<dd>no</dd>
</dl>
      </section>

      <section numbered="true" toc="default">
        <name>Registration of the application/x-x509-next-ca-cert Media Type</name>
<dl>
<dt>Type name:</dt>
<dd>application</dd>
<dt>Subtype name:</dt>
<dd>x-x509-next-ca-cert</dd>
<dt>Required parameters:</dt>
<dd>none</dd>
<dt>Optional parameters:</dt>
<dd>none</dd>
<dt>Encoding considerations:</dt>
<dd>binary</dd>
<dt>Security considerations:</dt>
<dd>This media type consists of a SignedData CMS message, signed by the
current CA signing key. There is no executable content.</dd>
<dt>Interoperability considerations:</dt>
<dd>This is a grandfathered registration that is only used in SCEP.</dd>
<dt>Published specification:</dt>
<dd>RFC 8894</dd>
<dt>Applications that use this media type:</dt>
<dd>SCEP uses this media type when returning a Get Next CA response.</dd>
<dt>Fragment identifier considerations:</dt>
<dd>N/A</dd>
<dt>Additional information:</dt>
<dd><t><br/></t>
<dl>
<dt>Deprecated alias names for this type:</dt>
<dd>N/A</dd>
<dt>Magic number(s):</dt>
<dd>none</dd>
<dt>File extension(s):</dt>
<dd>N/A</dd>
<dt>Macintosh file type code(s):</dt>
<dd>N/A</dd>
</dl>
</dd>
<dt>Person and email address to contact for further information:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Intended usage:</dt>
<dd>LIMITED USE </dd>
<dt>Restrictions on usage:</dt>
<dd>SCEP protocol</dd>
<dt>Author:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Change controller:</dt>
<dd>IETF</dd>
<dt>Provisional registration?</dt>
<dd>no</dd>
</dl>
      </section>

      <section numbered="true" toc="default">
        <name>Registration of the application/x-pki-message Media Type</name>
<dl>
<dt>Type name:</dt>
<dd>application</dd>
<dt>Subtype name:</dt>
<dd>x-pki-message</dd>
<dt>Required parameters:</dt>
<dd>none</dd>
<dt>Optional parameters:</dt>
<dd>none</dd>
<dt>Encoding considerations:</dt>
<dd>binary</dd>
<dt>Security considerations:</dt>
<dd>This media type consists of a degenerate certificates-only CMS SignedData
message. There is no executable content.</dd>
<dt>Interoperability considerations:</dt>
<dd>This is a grandfathered registration that is only used in SCEP.</dd>
<dt>Published specification:</dt>
<dd>RFC 8894</dd>
<dt>Applications that use this media type:</dt>
<dd>SCEP uses this media type when returning a Certificate Enrolment/Renewal
Response.</dd>
<dt>Fragment identifier considerations:</dt>
<dd>N/A</dd>
<dt>Additional information:</dt>
<dd><t><br/></t>
<dl>
<dt>Deprecated alias names for this type:</dt>
<dd>N/A</dd>
<dt>Magic number(s):</dt>
<dd>none</dd>
<dt>File extension(s):</dt>
<dd>N/A</dd>
<dt>Macintosh file type code(s):</dt>
<dd>N/A</dd>
</dl>
</dd>
<dt>Person and email address to contact for further information:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Intended usage:</dt>
<dd>LIMITED USE</dd>
<dt>Restrictions on usage:</dt>
<dd>SCEP protocol</dd>
<dt>Author:</dt>
<dd>See the Authors' Addresses section of RFC 8894.</dd>
<dt>Change controller:</dt>
<dd>IETF</dd>
<dt>Provisional registration?</dt>
<dd>no</dd>
</dl>
      </section>
    </section>

    <section anchor="security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>
The security goal of SCEP is that no adversary can subvert the public
key/identity binding from that intended.  An adversary is any entity other
than the client and the CA participating in the protocol.
      </t>
      <t>
This goal is met through the use of CMS and PKCS #10 encryption and digital
signatures using authenticated public keys.  The CA's public key is
authenticated via out-of-band means such as the checking of the CA fingerprint,
and the SCEP client's public key is authenticated through manual or preshared
secret authentication.
      </t>
      <section numbered="true" toc="default">
        <name>General Security</name>
        <t>
Common key-management considerations such as keeping private keys truly
private and using adequate lengths for symmetric and asymmetric keys must be
followed in order to maintain the security of this protocol.  This is
especially true for CA keys which, when compromised, compromise the security
of all relying parties.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Use of the CA Private Key</name>
        <t>
A CA private key is generally meant for, and usually flagged as, being
usable for certificate (and CRL) signing exclusively rather than data signing
or encryption.  The SCEP protocol, however, uses the CA private key to both sign
and optionally encrypt CMS transport messages.  This is generally considered
undesirable, as it widens the possibility of an implementation weakness and
provides an additional location where the private key must be used (and hence
is slightly more vulnerable to exposure) and where a side-channel attack might
be applied.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>ChallengePassword Shared Secret Value</name>
        <t>
The security measures that should be applied to the challengePassword shared
secret depend on the manner in which SCEP is employed.  In the simplest case,
with SCEP used to provision devices with certificates in the manufacturing
facility, the physical security of the facility may be enough to protect the
certificate issue process with no additional measures explicitly required.  In
general, though, the security of the issue process depends on the security
employed around the use of the challengePassword shared secret.  While it's
not possible to enumerate every situation in which SCEP may be utilised, the
following security measures should be considered.
        </t>

        <ul spacing="compact">
          <li>
The challengePassword, despite its name, shouldn't be a conventional password
but a high-entropy shared-secret authentication string.  Using the base64
encoding of a keying value generated or exchanged as part of standard device
authentication protocols like the Extensible Authentication Protocol (EAP) or
DNP3 Secure Authentication (DNP3-SA) makes for a good
challengePassword.  The use of high-entropy shared secrets is particularly
important when the PasswordRecipientInfo option is used to encrypt SCEP
messages; see <xref target="message-processing" format="default"/>.
          </li>

          <li>
If feasible, the challengePassword should be a one-time value used to
authenticate the issue of a single certificate (subsequent certificate
requests will be authenticated by being signed with the initial certificate).
If the challengePassword is single use, then the arrival of subsequent requests
using the same challengePassword can then be used to indicate a security
breach.
          </li>

          <li>
The lifetime of a challengePassword can be limited, so that it can be used
during initial device provisioning but will have expired at a later date if an
attacker manages to compromise the challengePassword value -- for example, by
compromising the device that it's stored in.
          </li>

          <li>
The CA should take appropriate measures to protect the
challengePassword. Examples of possible measures include: physical security
measures; storing it as a salted iterated hash or equivalent memory-hard
function; storing it as a keyed MAC value if it's not being used for
encryption; and storing it in encrypted form if it is being used for encryption.
          </li>
        </ul>
      </section>

      <section anchor="security-no-conf" numbered="true" toc="default">
        <name>Lack of Certificate Issue Confirmation</name>
        <t>
SCEP provides no confirmation that the issued certificate was successfully
received and processed by the client.  This means that if the CertRep message
is lost or can't be processed by the client, then the CA will consider the
certificate successfully issued while the client won't.  If this situation is
of concern, then the correct issuance of the certificate will need to be
verified by out-of-band means, for example, through the client sending a
message signed by the newly issued certificate to the CA.  This also provides
the proof of possession that's not present in the case of a renewal operation;
see <xref target="security-no-pop" format="default"/>.
        </t>
      </section>
      <section anchor="security-getcacaps" numbered="true" toc="default">
        <name>GetCACaps Issues</name>
        <t>
The GetCACaps response is not authenticated by the CA.  This allows an
attacker to perform downgrade attacks on the cryptographic capabilities of the
client/CA exchange.  In particular, if the server were to support MD5 and
single DES, then an in-path attacker could trivially roll back the encryption
to use these insecure algorithms.  By taking advantage of the presence of
large amounts of static known plaintext in the SCEP messages, as of 2017, a DES
rainbow table attack can recover most encryption keys in under a minute, and
MD5 chosen-prefix collisions can be calculated for a few tens of cents of
computing time using tools like HashClash.  It is for this reason that this
specification makes single DES and MD5 a <bcp14>MUST NOT</bcp14> feature.  Note that all
known servers support at least triple DES and SHA-1 (regardless of whether
"DES3" and "SHA-1" are indicated in GetCACaps), so there should never be a
reason to fall all the way back to single DES and MD5.</t>
      <t>
One simple countermeasure to a GetCACaps downgrade attack is for clients that
are operating in an environment where on-path attacks are possible and that
expect the "SCEPStandard" capability to be indicated by the CA but don't see
it in the GetCACaps response to treat its absence as a security issue, and
either discontinue the exchange or continue as if "SCEPStandard" had been
returned.  This requires a certain trade-off between compatibility with old
servers and security against active attacks.
        </t>
      </section>
      <section anchor="security-no-pop" numbered="true" toc="default">
        <name>Lack of PoP in Renewal Requests</name>
        <t>
Renewal operations (but not standard certificate-issue operations) are
processed via a previously issued certificate and its associated private key,
not the key in the PKCS #10 request.  This means that a client no longer
demonstrates proof of possession (PoP) of the private key corresponding to the
public key in the PKCS #10 request.  It is therefore possible for a client to
recertify an existing key used by a third party, so that two or more
certificates exist for the same key.  By switching out the certificate in a
signature, an attacker can appear to have a piece of data signed by their
certificate rather than the original signer's certificate.  This, and other,
attacks are described in <xref target="RFC2634" format="default">S/MIME ESS</xref>.
        </t>
        <t>
Avoiding these types of attacks requires situation-specific measures.  For
example, CMS/SMIME implementations may use the ESSCertID attribute from <xref
target="RFC2634" format="default">S/MIME ESS</xref> or its successor, <xref
target="RFC5035" format="default">S/MIME
ESSv2</xref>, to unambiguously identify the signing certificate.  However, since
other mechanisms and protocols that the certificates will be used with
typically don't defend against this problem, it's unclear whether this is an
actual issue with SCEP.
        </t>
      </section>
      <section anchor="traffic-monitoring" numbered="true" toc="default">
        <name>Traffic Monitoring</name>
        <t>
SCEP messages are signed with certificates that may contain identifying
information.  If these are sent over the public Internet and real identity
information (rather than placeholder values or arbitrary device IDs) is
included in the signing certificate data, an attacker may be able to monitor
the identities of the entities submitting the certificate requests.  If this
is an issue, then <xref target="RFC7258" format="default"/> should be consulted for guidance.
        </t>
      </section>
      <section anchor="security-unnecessary" numbered="true" toc="default">
        <name>Unnecessary Cryptography</name>
        <t>
Some of the SCEP exchanges use unnecessary signing and encryption operations.
In particular, the GetCert and GetCRL exchanges are encrypted and signed in
both directions.  The information requested is public, and thus encrypting the
requests is of questionable value.  In addition, CRLs and certificates sent in
responses are already signed by the CA and can be verified by the recipient
without requiring additional signing and encryption.  More lightweight means
of retrieving certificates and CRLs such as <xref target="RFC4387" format="default">HTTP
certificate-store access</xref> and LDAP are recommended for this reason.
        </t>
      </section>
      <section anchor="security-sha1" numbered="true" toc="default">
        <name>Use of SHA-1</name>
        <t>
The majority of the large number of devices that use SCEP today default to
SHA-1, with many supporting only that hash algorithm with no ability to
upgrade to a newer one.  SHA-1 is no longer regarded as secure in all
situations, but as used in SCEP, it's still safe.  There are three reasons for
this.  The first is that attacking SCEP would require creating a fully general
SHA-1 collision in close to real time alongside breaking AES (more
specifically, it would require creating a fully general SHA-1 collision for
the PKCS #10 request, breaking the AES encryption around the PKCS #10 request,
and then creating a second SHA-1 collision for the signature on the encrypted
data), which won't be feasible for a long time.
        </t>
        <t>
The second reason is that the signature over the message -- in other words, the
SHA-1 hash that isn't protected by encryption -- doesn't serve any critical
cryptographic purpose: The PKCS #10 data itself is authenticated through its
own signature, protected by encryption, and the overall request is authorised
by the (encrypted) shared secret.  The sole exception to this will be the
small number of implementations that support the Renewal operation, which may
be authorised purely through a signature, but presumably any implementation
recent enough to support Renewal also supports SHA-2.  Any legacy
implementation that supports the historic core SCEP protocol would not be
affected.
        </t>
        <t>
The third reason is that SCEP uses the same key for encryption and signing, so
that even if an attacker were able to capture an outgoing renewal request that
didn't include a shared secret (in other words, one that was only authorised
through a signature), break the AES encryption, forge the SHA-1 hash in real
time, and forward the forged request to the CA, they couldn't decrypt the
returned certificate, which is protected with the same key that was used to
generate the signature.  While <xref target="security-unnecessary" format="default"/> points
out that SCEP uses unnecessary cryptography in places, the additional level of
security provided by the extra crypto makes it immune to any issues with
SHA-1.
        </t>
        <t>
This doesn't mean that SCEP implementations should continue to use SHA-1 in
perpetuity, merely that there's no need for a panicked switch to SHA-2.
        </t>
      </section>

      <section title="Use of HTTP">
              <t>
SCEP is an encrypted, authenticated certificate enrollment protocol that uses
HTTP as a simple transport mechanism. Since SCEP messages are already
cryptographically secured, it does not require transport layer security. Where
HTTPS is elected, a performance hit may result from the TLS overhead,
operational problems may result due to the more complex configuration, and
potential security vulnerability may result due to the addition of an entire
TLS protocol stack alongside the basic SCEP protocol. 
	      </t>
	      <t> 
In particular, experience has shown that the issue of configuring
certificates, CAs, and trust for both TLS and SCEP often leads to
interoperability problems because different certificates and trust models are
used in each.  Use of HTTPS to authenticate the server does not enable
omission of the ChallengePassword or similar authenticator in the SCEP message
on the assumption that using HTTPS instead of HTTP will somehow make this
insecure usage secure again. HTTPS is not soy sauce for security and is
unnecessary for SCEP, which uses cryptographically secured messages and does
not require transport layer security. 
	  </t>
    </section>
  </section>

      </middle>

  <back>
<displayreference target="I-D.ietf-httpbis-bcp56bis" to="HTTP" />

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6838.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7258.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>

        <reference anchor="AES">
          <front>
            <title>The Advanced Encryption Standard (AES)</title>
            <seriesInfo name="FIPS" value="197"/>
            <author fullname="U.S. National Institute of Standards and Technology">
              <organization>NIST</organization>
            </author>
            <date year="2001" month="November"/>
          </front>
<seriesInfo name="DOI" value="10.6028/NIST.FIPS.197" />
        </reference>

        <reference anchor="SHA2">
          <front>
            <title>Secure Hash Standard (SHS)</title>
            <seriesInfo name="FIPS" value="180-3"/>
            <author fullname="U.S. National Institute of Standards and Technology">
              <organization>NIST</organization>
            </author>
            <date year="2008" month="October"/>
          </front>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5652.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2985.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2986.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
      </references>
      <references>
        <name>Informative References</name>

<xi:include href="https://www.rfc-editor.org/refs/bibxml3/reference.I-D.ietf-httpbis-bcp56bis.xml"/>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4387.xml"/>

        <reference anchor="JSCEP" target="https://github.com/jscep/jscep">
          <front>
            <title>A Java implementation of the Simple Certificate Enrolment Protocol</title>
	    <author />
            <date month="January" year="2020"/>
          </front>
	  <seriesInfo name="commit" value="7410332" />
        </reference>

        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8551.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2634.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5035.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
      </references>
    </references>

    <section anchor="background" numbered="true" toc="default">
      <name>Background Notes</name>
      <t>

This specification has spent over twenty years in the draft stage.  Its
original goal, provisioning IPsec routers with certificates, has long since
changed to general device/embedded system/IoT use.  To fit this role, extra
features were bolted on in a haphazard manner through the addition of a
growing list of appendices and by inserting additional, often conflicting,
paragraphs in various locations in the body text.  Since existing features
were never updated as newer ones were added, the specification accumulated
large amounts of historical baggage over time.  If OpenPGP was described as "a
museum of 1990s crypto", then the SCEP document was its graveyard.

      </t>
      <t>

About five years ago, the specification, which even at that point had seen only
sporadic reposts of the existing document, was more or less abandoned by its
original sponsors.  Due to its widespread use in large segments of the
industry, the specification was rebooted in 2015, cleaning up fifteen years'
worth of accumulated cruft, fixing errors, clarifying ambiguities, and
bringing the algorithms and standards used into the current century (prior to
the update, the de facto lowest-common-denominator algorithms used for
interoperability were the insecure forty-year-old single DES and broken MD5
hash algorithms).

      </t>
      <t>

Note that although the text of the current specification has changed
significantly due to the consolidation of features and appendices into the
main document, the protocol that it describes is identical on the wire to the
original (with the unavoidable exception of the switch from single DES and MD5
to AES and SHA-2).  The only two changes introduced, the "SCEPStandard"
indicator in GetCACaps and the failInfoText attribute, are both optional
values and would be ignored by older implementations that don't support them,
or can be omitted from messages if they are found to cause problems.

      </t>
      <t>

Other changes include:

      </t>
      <ul>
        <li>Resolved contradictions in the text -- for example, a requirement
	given as a <bcp14>MUST</bcp14> in one paragraph and a
	<bcp14>SHOULD</bcp14> in the next, a <bcp14>MUST NOT</bcp14>
	in one paragraph and a <bcp14>MAY</bcp14> a few paragraphs later, a
	<bcp14>SHOULD NOT</bcp14> contradicted later by a <bcp14>MAY</bcp14>, and so on.</li>
        <li>Merged several later fragmentary addenda placed in appendices (for
	example, the handling of certificate renewal) with the body of the
	text.</li>
        <li>Merged the "SCEP Transactions" and "SCEP Transport" sections, since the
		latter mostly duplicated (with occasional inconsistencies) the
		former.</li>
        <li>Updated the algorithms to ones dating from at least this
		century.</li>
        <li>Did the same for normative references to other standards.</li>
        <li>Updated the text to use consistent terminology for the client and
		CA rather than a mixture of client, requester, requesting system, end
		entity, server, certificate authority, certification authority, and
		CA.</li>
        <li>Corrected incorrect references to other standards, e.g.,
		IssuerAndSerial -&gt; IssuerAndSerialNumber.</li>
        <li>Corrected errors such as a statement that when both signature and
		encryption certificates existed, the signature certificate was used
		for encryption.</li>
        <li>Condensed redundant discussions of the same topic spread across
		multiple sections into a single location.  For example, the description
		of intermediate CA handling previously existed in three different
		locations, with slightly different requirements in each one.</li>
        <li>Added a description of how pkiMessages were processed, which was
		never made explicit in the original specification.  This led to
		creative interpretations that had security problems but were employed
		anyway due to the lack of specific guidance on what to do.</li>
        <li>Relaxed some requirements that didn't serve any obvious purpose and
		that major implementations didn't seem to be enforcing.  For example,
		the requirement that the self-signed certificate used with a request
		<bcp14>MUST</bcp14> contain a subject name that matched the one in the PKCS #10
		request was relaxed to a <bcp14>SHOULD</bcp14>, because a number of implementations
		either ignored the issue entirely or at worst performed some minor
		action like creating a log entry, after which they continued
		anyway.</li>
        <li>Removed discussion of the transactionID from the security
		considerations, since the instructions there were directly
		contradicted by the discussion of the use of the transactionID in
		<xref target="state-trans" format="default"/>.</li>
        <li>Added a requirement that the signed message include the signing
		certificate(s) in the signedData certificates field.  This was
		implicit in the original specification (without it, the message
		couldn't be verified by the CA) and was handled by the fact that most
		PKCS #7/CMS libraries do this by default, but was never explicitly
		mentioned.</li>
        <li>Clarified sections that were unclear or even made no sense -- for
		example, the requirement for a "hash on the public key" [sic] encoded
		as a PrintableString.</li>
        <li>Renamed "RA certificates" to "intermediate CA certificates".  The
		original document at some point added mention of RA certificates
		without specifying how the client was to determine that an RA was in
		use, how the RA operations were identified in the protocol, or how it
		was used.  It's unclear whether what was meant was a true RA or merely
		an intermediate CA, as opposed to the default practice of having
		certificates issued directly from a single root CA certificate.  This
		update uses the term "intermediate CA certificates", since this seems
		to have been the original intent of the text.</li>
        <li>Redid the PKIMessage diagram to match what was specified in CMS;
		the original diagram omitted a number of fields and nested data
		structures, which meant that the diagram didn't match either the text
		or the CMS specification.</li>
        <li>Removed the requirement for a CertPoll to contain a recipientNonce,
		since CertPoll is a client message and will never be sent in response
		to a message containing a senderNonce.  See also the note in
		<xref target="CertRep" format="default"/>.</li>
        <li>Clarified certificate renewal.  This represents a capability that
		was bolted onto the original protocol with (at best) vaguely defined
		semantics, including a requirement by the CA to guess whether a
		particular request was a renewal or not.  In response to developer
		feedback that they either avoided renewal entirely because of this
		uncertainty or hard-coded in particular behaviour on a per-CA basis,
		this specification explicitly identifies renewal requests as such and
		provides proper semantics for them.</li>
        <li>Corrected the requirement that "undefined message types are treated
		as an error", since this negates the effect of GetCACaps, which is used
		to define new message types.  In particular, operations such as
		GetCACaps "Renewal" would be impossible if enforced as written,
		because the Renewal operation was an undefined message type at the
		time.</li>
        <li>In line with the above, added IANA registries for several entries
		that had previously been defined in an ad hoc manner in different
		locations in the text.</li>
        <li>Added the "SCEPStandard" keyword to GetCACaps to indicate that the
		CA complies with the final version of the SCEP standard, since the
		definition of what constitutes SCEP standards compliance has changed
		significantly over the years.</li>
        <li>Added the optional failInfoText attribute to deal with the fact
		that failInfo was incapable of adequately communicating to clients why
		a certificate request operation had been rejected.</li>
        <li>Removed the discussion in the security considerations of revocation
		issues, since SCEP doesn't support revocation as part of the
		protocol.</li>
        <li>Clarified the use of nonces, which if applied as originally
		specified would have made the use of polling in the presence of a lost
		message impossible.</li>
        <li>Removed the discussion of generating a given transactionID by
		hashing the public key, since this implied that there was some special
		significance in the value generated this way.  Since it was neither a
		<bcp14>MUST</bcp14> nor a <bcp14>MAY</bcp14>, it was unsound
		to imply that servers could rely on the
		value being generated a certain way.  In addition, it wouldn't work if
		multiple transactions as discussed in <xref target="poll-resp"
		format="default"/> were
		initiated, since the deterministic generation via hashing would lead
		to duplicate transactionIDs.</li>
        <li>Added examples of SCEP messages to give implementers something to
		aim for.</li>
      </ul>
    </section>

    <section anchor="ack" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>
The editor would like to thank all of the previous editors, authors, and
contributors for their work maintaining the
document over the years: <contact fullname="Cheryl Madson"/>, <contact
fullname="Xiaoyi Liu"/>, <contact fullname="David McGrew"/>, <contact
fullname="David Cooper"/>, <contact fullname="Andy Nourse"/>, <contact fullname="Max
Pritikin"/>, <contact fullname="Jan Vilhuber"/>, and others.  The IETF reviewers provided
much useful feedback that
helped improve the document, and in particular spotted a number of things that
were present in SCEP through established practice rather than by being
explicitly described in the text.  Numerous other people have contributed
during the long life cycle of the document, and all deserve thanks.  In addition,
several PKCS #7 / CMS libraries contributed to interoperability by doing the
right thing despite what earlier SCEP documents required.
      </t>
      <t>
The authors of earlier draft versions of this document would like to thank
<contact fullname="Peter William"/> of ValiCert, Inc. (formerly of VeriSign,
  Inc.), <contact fullname="Alex Deacon"/> of
VeriSign, Inc., and <contact fullname="Christopher Welles"/> of IRE, Inc. for their contributions to
early versions of this protocol and this document.
      </t>
    </section>

  </back>
</rfc>
