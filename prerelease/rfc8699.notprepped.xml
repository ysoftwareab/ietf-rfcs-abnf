<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" number="8699" category="exp"
     consensus="true" docName="draft-ietf-rmcat-coupled-cc-09"
     ipr="trust200902" obsoletes="" updates="" submissionType="IETF"
     xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true"
     version="3">


 
  <front>
    <title>Coupled Congestion Control for RTP Media</title>
 <seriesInfo name="RFC" value="8699"/>   
    <author fullname="Safiqul Islam" initials="S." surname="Islam">
      <organization>University of Oslo</organization>
      <address>
        <postal>
          <street>PO Box 1080 Blindern</street>
          <code>N-0316</code>
          <city>Oslo</city>
          <region/>
          <country>Norway</country>
        </postal>
        <phone>+47 22 84 08 37</phone>
        <email>safiquli@ifi.uio.no</email>
      </address>
    </author>
    <author fullname="Michael Welzl" initials="M." surname="Welzl">
      <organization>University of Oslo</organization>
      <address>
        <postal>
          <street>PO Box 1080 Blindern</street>
          <code>N-0316</code>
          <city>Oslo</city>
          <region/>
          <country>Norway</country>
        </postal>
        <phone>+47 22 85 24 20</phone>
        <email>michawe@ifi.uio.no</email>
      </address>
    </author>
    <author fullname="Stein Gjessing" initials="S." surname="Gjessing">
      <organization>University of Oslo</organization>
      <address>
        <postal>
          <street>PO Box 1080 Blindern</street>
          <code>N-0316</code>
          <city>Oslo</city>
          <region/>
          <country>Norway</country>
        </postal>
        <phone>+47 22 85 24 44</phone>
        <email>steing@ifi.uio.no</email>
      </address>
    </author>
    <date month="January" year="2020"/>
    <area>Transport</area>
    <workgroup>RTP Media Congestion Avoidance Techniques (rmcat)</workgroup>
    <keyword>tcp</keyword>

    <abstract>
      <t>When multiple congestion-controlled Real-time Transport Protocol
      (RTP) sessions traverse the same network bottleneck, combining their
      controls can improve the total on-the-wire behavior in terms of delay,
      loss, and fairness. This document describes such a method for flows that
      have the same sender, in a way that is as flexible and simple as
      possible while minimizing the number of changes needed to existing RTP
      applications. This document also specifies how to apply the method for the
      Network-Assisted Dynamic Adaptation (NADA) congestion control algorithm
      and provides suggestions on how to apply it to other congestion control
      algorithms.</t>
    </abstract>
  </front>
  <middle>

    <section anchor="sec-intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>When there is enough data to send, a congestion controller attempts
      to increase its sending rate until the path's capacity has been reached.
      Some controllers detect path capacity by increasing the sending rate
      further, until packets are 
      ECN-marked <xref target="RFC8087" format="default"/> or dropped, and
      then decreasing the sending rate until that stops happening. This
      process inevitably creates undesirable queuing delay when multiple
      congestion-controlled connections traverse the same network bottleneck,
      and each connection overshoots the path capacity as it determines its
      sending rate. </t>

      <t>The Congestion Manager (CM) <xref target="RFC3124" format="default"/>
      couples flows by providing a single congestion controller. It is hard to
      implement because it requires an additional congestion controller and
      removes all per-connection congestion control functionality, which is
      quite a significant change to existing RTP-based applications. This
      document presents a method to combine the behavior of congestion control
      mechanisms that is easier to implement than the Congestion Manager <xref
      target="RFC3124" format="default"/> and also requires fewer significant
      changes to existing RTP-based applications. It attempts to roughly
      approximate the CM behavior by sharing information between existing
      congestion controllers. It is able to honor user-specified priorities,
      which is required by WebRTC <xref target="I-D.ietf-rtcweb-overview"
      format="default"/> <xref target="RFC7478" format="default"/>.</t>
      <t>The described mechanisms are believed safe to use, but they are
      experimental and are presented for wider review and operational
      evaluation.</t>
    </section>
    <section anchor="sec-def" numbered="true" toc="default">
      <name>Definitions</name>



      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
      "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
      NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
      "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
      "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
      to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
      <xref target="RFC8174"/> when, and only when, they appear in all
      capitals, as shown here.</t>

      <dl newline="true" spacing="normal" indent="6">
        <dt>Available Bandwidth:</dt>
        <dd>
	    The available bandwidth is the nominal link capacity minus the
	    amount of traffic that traversed the link during a certain time
	    interval, divided by that time interval.</dd>
        <dt>Bottleneck:</dt>
        <dd>
	    The first link with the smallest available bandwidth along the path between a sender and receiver.</dd>
        <dt>Flow:</dt>
        <dd>
	    A flow is the entity that congestion control is operating on. It
	    could, for example, be a transport-layer connection or an RTP
	    stream <xref target="RFC7656" format="default"/>, regardless of
	    whether or not this RTP stream is multiplexed onto an RTP session
	    with other RTP streams.</dd>
        <dt>Flow Group Identifier (FGI):</dt>
        <dd>
	    A unique identifier for each subset of flows that is limited by a common bottleneck.</dd>
        <dt>Flow State Exchange (FSE):</dt>
        <dd>
	    The entity that maintains information that is exchanged between flows.</dd>
        <dt>Flow Group (FG):</dt>
        <dd>
	    A group of flows having the same FGI.</dd>
        <dt>Shared Bottleneck Detection (SBD):</dt>
        <dd>
	    The entity that determines which flows traverse the same
	bottleneck in the network or the process of doing so.</dd>
      </dl>
    </section>
    <section anchor="sec-limits" numbered="true" toc="default">
      <name>Limitations</name>
      <dl newline="true" spacing="normal" indent="6">
        <dt>Sender-side only:</dt>
        <dd>
      Shared bottlenecks can exist when multiple flows originate from the same
      sender or when flows from different senders reach the same receiver (see
      <xref target="RFC8382" sectionFormat="of" section="3" />). Coupled
      congestion control, as described here, only supports the former case, not
      the latter, as it operates inside a single host on the sender side.
  </dd>
        <dt>Shared bottlenecks do not change quickly:</dt>
        <dd>
     As per the definition above, a bottleneck depends on cross traffic, and
     since such traffic can heavily fluctuate, bottlenecks can change at a
     high frequency (e.g., there can be oscillation between two or more
     links). This means that, when flows are partially routed along different
     paths, they may quickly change between sharing and not sharing a
     bottleneck. For simplicity, here it is assumed that a shared bottleneck
     is valid for a time interval that is significantly longer than the
     interval at which congestion controllers operate. Note that, for the only
     SBD mechanism defined in this document (multiplexing on the same
     five-tuple), the notion of a shared bottleneck stays correct even in the
     presence of fast traffic fluctuations; since all flows that are assumed
     to share a bottleneck are routed in the same way, if the bottleneck
     changes, it will still be shared.</dd>
      </dl>
    </section>
    <section anchor="sec-arch" numbered="true" toc="default">
      <name>Architectural Overview</name>
      <t><xref target="fig_1"/> shows the elements of the architecture for coupled
      congestion control: the Flow State Exchange (FSE), Shared Bottleneck
      Detection (SBD), and Flows. The FSE is a storage element that can be
      implemented in two ways: active and passive. In the active version, it
      initiates communication with flows and SBD. However, in the passive
      version, it does not actively initiate communication with flows and SBD;
      its only active role is internal state maintenance (e.g., an
      implementation could use soft state to remove a flow's data after long
      periods of inactivity). Every time a flow's congestion control mechanism
      would normally update its sending rate, the flow instead updates
      information in the FSE and performs a query on the FSE, leading to a
      sending rate that can be different from what the congestion controller
      originally determined. Using information about/from the currently active
      flows, SBD updates the FSE with the correct Flow Group Identifiers
      (FGIs).
      </t>
      <t> This document describes both active and passive versions. While the
      passive algorithm works better for congestion controls with
      RTT-independent convergence, it can still produce oscillations on short
      time scales.  The passive algorithm, described in <xref
      target="example-alg-pas" format="default"/>, is therefore considered
      highly experimental and not safe to deploy outside of testbed
      environments. <xref target="fig_2"/> shows the interaction between flows
      and the FSE using the variable names defined in <xref
      target="fse-variables" format="default"/>.</t>
<figure anchor="fig_1" title="Coupled congestion control architecture" >      <artwork align="center" name="" type="" alt=""><![CDATA[-------  <---  Flow 1
| FSE |  <---  Flow 2 ..
-------  <---  .. Flow N
   ^
   |             |
-------          |
| SBD |  <-------|
-------		]]></artwork></figure>


<figure anchor="fig_2" title="Flow-FSE interactions">      <artwork align="center" name="" type="" alt=""><![CDATA[Flow#1(cc)                     FSE                    Flow#2(cc)
----------                     ---                    ----------
#1 JOIN     ----register--> REGISTER

                            REGISTER    <--register-- JOIN #1

#2 CC_R(1)  ----UPDATE----> UPDATE (in)

#3 NEW RATE <---FSE_R(1)-- UPDATE (out) --FSE_R(2)-> #3 NEW RATE
          ]]></artwork></figure>

      <t>Since everything shown in <xref target="fig_1"/> is assumed to operate on a single
      host (the sender) only, this document only describes aspects that have
      an influence on the resulting on-the-wire behavior. It does not, for
      instance, define how many bits must be used to represent FGIs or in
      which way the entities communicate.</t>
      <t>Implementations can take various forms; for instance, all the
      elements in the figure could be implemented within a single application,
      thereby operating on flows generated by that application only. Another
      alternative could be to implement both the FSE and SBD together in a
      separate process that different applications communicate with via some
      form of Inter-Process Communication (IPC). Such an implementation would
      extend the scope to flows generated by multiple applications. The FSE
      and SBD could also be included in the Operating System kernel. However,
      only one type of coupling algorithm should be used for all
      flows. Combinations of multiple algorithms at different aggregation
      levels (e.g., the Operating System coupling application aggregates with
      one algorithm, and applications coupling their flows with another) have
      not been tested and are therefore not recommended. </t>
    </section>
    <section anchor="roles" numbered="true" toc="default">
      <name>Roles</name>
      <t>This section gives an overview of the roles of the elements of
      coupled congestion control and provides an example of how coupled
      congestion control can operate.</t>
      <section numbered="true" toc="default">
        <name>SBD</name>
        <t>SBD uses knowledge about the flows to determine which flows belong
        in the same Flow Group (FG) and assigns FGIs accordingly.  This
        knowledge can be derived in three basic ways:

        </t>
        <ol spacing="normal" type="1">
          <li>From multiplexing: It can be based on the simple assumption that
          packets sharing the same five-tuple (IP source and destination
          address, protocol, and transport-layer port number pair) and having
          the same values for the Differentiated Services Code Point (DSCP)
          and the ECN field in the IP header are typically treated in the same
          way along the path.  This method is the only one specified in this
          document; SBD <bcp14>MAY</bcp14> consider all flows that use the
          same five-tuple, DSCP, and ECN field value to belong to the same
          FG. This classification applies to certain tunnels or RTP flows
          that are multiplexed over one transport (cf. <xref
          target="TRANSPORT-MULTIPLEX" format="default"/>). Such multiplexing
          is also a recommended usage of RTP in WebRTC <xref
          target="I-D.ietf-rtcweb-rtp-usage" format="default"/>.</li>
          <li>Via configuration: e.g., by assuming that a common wireless uplink is also a shared bottleneck.</li>
          <li>From measurements: e.g., by considering correlations among
          measured delay and loss as an indication of a shared
          bottleneck.</li>
        </ol>

        <t>The methods above have some essential trade-offs. For example,
        multiplexing is a completely reliable measure, but it is limited
        in scope to two endpoints (i.e., it cannot be applied to couple
        congestion controllers of one sender talking to multiple receivers). A
        measurement-based SBD mechanism is described in <xref target="RFC8382"
        format="default"/>. Measurements can never be 100% reliable, in
        particular because they are based on the past, but applying coupled
        congestion control involves making an assumption about the future; it is
        therefore recommended to implement cautionary measures, e.g., by
        disabling coupled congestion control if enabling it causes a
        significant increase in delay and/or packet loss.  Measurements also
        take time, which entails a certain delay for turning on coupling
        (refer to <xref target="RFC8382" format="default"/> for details).

When this is possible, it can be more efficient to statically configure shared
bottlenecks (e.g., via a system configuration or user input) based on
assumptions about the network environment.</t>
      </section>
      <section anchor="fse-variables" numbered="true" toc="default">
        <name>FSE</name>
        <t>The FSE contains a list of all flows that have registered with
        it. For each flow, the FSE stores the following:
        </t>
        <ul spacing="normal">
          <li>a unique flow number f to identify the flow.</li>
          <li>the FGI of the FG that it belongs to (based on the definitions
          in this document, a flow has only one bottleneck and can therefore
          be in only one FG).</li>

          <li>a priority P(f), which is a number greater than zero.</li>
          <li>The rate used by the flow in bits per second, FSE_R(f). </li>
          <li>The desired rate DR(f) of flow f. This can be smaller than
          FSE_R(f) if the application feeding into the flow has less data to
          send than FSE_R(f) would allow or if a maximum value is imposed on
          the rate.  In the absence of such limits, DR(f) must be set to the
          sending rate provided by the congestion control module of flow
          f.</li>
        </ul>
        <t>
    Note that the absolute range of priorities does not matter; the algorithm
    works with a flow's priority portion of the sum of all priority
    values. For example, if there are two flows, flow 1 with priority 1 and
    flow 2 with priority 2, the sum of the priorities is 3. Then, flow 1 will
    be assigned 1/3 of the aggregate sending rate, and flow 2 will be assigned
    2/3 of the aggregate sending rate. Priorities can be mapped to the
    "very-low", "low", "medium", or "high" priority levels described in <xref
    target="I-D.ietf-rtcweb-transports" format="default"/> by simply using the
    values 1, 2, 4, and 8, respectively.
        </t>
        <t>In the FSE, each FG contains one static variable, S_CR, which is the
        sum of the calculated rates of all flows in the same FG. This value is
        used to calculate the sending rate. </t>
        <t>The information listed here is enough to implement the sample flow
        algorithm given below. FSE implementations could easily be extended to
        store, e.g., a flow's current sending rate for statistics gathering or
        future potential optimizations.</t>
      </section>


      <section anchor="flows" numbered="true" toc="default">
        <name>Flows</name>
        <t>Flows register themselves with SBD and FSE when they start,
        deregister from the FSE when they stop, and carry out an UPDATE
        function call every time their congestion controller calculates a new
        sending rate. Via UPDATE, they provide the newly calculated rate and,
        optionally (if the algorithm supports it), the desired rate. The
        desired rate is less than the calculated rate in case of
        application-limited flows; otherwise, it is the same as the calculated
        rate.</t>
        <t>Below, two example algorithms are described. While other algorithms
        could be used instead, the same algorithm must be applied to all
        flows. Names of variables used in the algorithms are explained below.
</t>

        <dl newline="false" indent="10" spacing="normal">
          <dt>CC_R(f)</dt><dd>The rate received from the congestion controller of
          flow f when it calls UPDATE.</dd>
          <dt>FSE_R(f)</dt><dd>The rate calculated by the FSE for flow f.</dd>
          <dt>DR(f)</dt><dd>The desired rate of flow f.</dd>
          <dt>S_CR</dt><dd>The sum of the calculated rates of all flows in the same
          FG; this value is used to calculate the sending rate.</dd>
          <dt>FG</dt><dd>A group of flows having the same FGI and hence, sharing the same bottleneck.</dd>
          <dt>P(f)</dt><dd>The priority of flow f, which is received from the flow's congestion controller; the FSE uses this variable for calculating FSE_R(f).</dd>
          <dt>S_P</dt><dd>The sum of all the priorities.</dd>
          <dt>TLO</dt><dd>The total leftover rate; the sum of rates that could not be assigned to
    flows that were limited by their desired rate.</dd>
          <dt>AR</dt><dd>The aggregate rate that is assigned to flows that are not limited by their desired rate.</dd>
        </dl>
        <section anchor="example-alg-act" numbered="true" toc="default">
          <name>Example Algorithm 1 - Active FSE</name>

          <t>This algorithm was designed to be the simplest possible method to
          assign rates according to the priorities of flows. Simulation
          results in <xref target="FSE" format="default"/> indicate that it
          does not, however, significantly reduce queuing delay and packet
          loss.</t>

          <ol spacing="normal" type="(%d)">
            <li>When a flow f starts, it registers itself with SBD and the
            FSE. FSE_R(f) is initialized with the congestion controller's
            initial rate. SBD will assign the correct FGI. When a flow is
            assigned an FGI, it adds its FSE_R(f) to S_CR.</li>
            <li>When a flow f stops or pauses, its entry is removed from the list.</li>
            <li>
              <t>Every time the congestion controller of the flow f determines
              a new sending rate CC_R(f), the flow calls UPDATE, which carries
              out the tasks listed below to derive the new sending rates for
              all the flows in the FG. A flow's UPDATE function uses three
              local (i.e., per-flow) temporary variables: S_P, TLO, and AR.
              </t>

              <ol spacing="normal" type="(%c)">
                <li>
                  <t> It updates S_CR.
                  </t>
                  <sourcecode type="pseudocode"><![CDATA[
            S_CR = S_CR + CC_R(f) - FSE_R(f)            ]]></sourcecode>
                </li>
                <li>
                  <t> It calculates the sum of all the priorities, S_P, and initializes FSE_R.
                  </t>
                  <sourcecode type="pseudocode"><![CDATA[
            S_P = 0
            for all flows i in FG do
                S_P = S_P + P(i)
                FSE_R(i) = 0
            end for            ]]></sourcecode>
                </li>
                <li>
                  <t> It distributes S_CR among all flows, ensuring that each flow's desired rate
        is not exceeded.
                  </t>
                  <sourcecode type="pseudocode"><![CDATA[
            TLO = S_CR
            while(TLO-AR>0 and S_P>0)
                AR = 0
                for all flows i in FG do
                    if FSE_R[i] < DR[i] then
                        if TLO * P[i] / S_P >= DR[i] then
                            TLO = TLO - DR[i]
                            FSE_R[i] = DR[i]
                            S_P = S_P - P[i]
                        else
                            FSE_R[i] = TLO * P[i] / S_P
                            AR = AR + TLO * P[i] / S_P
                        end if
                    end if
                end for
            end while            ]]></sourcecode>
                </li>
                <li>
                  <t> It distributes FSE_R to all the flows.
                  </t>
                  <sourcecode type="pseudocode"><![CDATA[
            for all flows i in FG do
                send FSE_R(i) to the flow i
            end for            ]]></sourcecode>
                </li>
              </ol>
            </li>
          </ol>
        </section>
        <section anchor="example-alg-act-cons" numbered="true" toc="default">
          <name>Example Algorithm 2 - Conservative Active FSE</name>
          <t>This algorithm changes algorithm 1 to conservatively emulate the
          behavior of a single flow by proportionally reducing the aggregate
          rate on congestion. Simulation results in <xref target="FSE"
          format="default"/> indicate that it can significantly reduce queuing
          delay and packet loss. 
          </t>

          <t>Step (a) of the UPDATE function is changed as described
          below. This also introduces a local variable DELTA, which is used to
          calculate the difference between CC_R(f) and the previously stored
          FSE_R(f). To prevent flows from either ignoring congestion or
          overreacting, a timer keeps them from changing their rates
          immediately after the common rate reduction that follows a
          congestion event. This timer is set to two RTTs of the flow that
          experienced congestion because it is assumed that a congestion event
          can persist for up to one RTT of that flow, with another RTT added
          to compensate for fluctuations in the measured RTT value.
          </t>
          <ol type="(%c)" spacing="normal">
            <li>
              <t> It updates S_CR based on DELTA.
              </t>
              <sourcecode type="pseudocode"><![CDATA[
            if Timer has expired or was not set then
              DELTA = CC_R(f) - FSE_R(f)
              if DELTA < 0 then  // Reduce S_CR proportionally 
                S_CR = S_CR * CC_R(f) / FSE_R(f)
                Set Timer for 2 RTTs
              else    
                S_CR = S_CR + DELTA
              end if
             end if             ]]></sourcecode>
      </li>
          </ol>
        </section>
      </section>
    </section>
    <section anchor="Application" numbered="true" toc="default">
      <name>Application</name>
      <t>This section specifies how the FSE can be applied to specific
      congestion control mechanisms and makes general recommendations that
      facilitate applying the FSE to future congestion controls.</t>

      <section anchor="app-NADA" numbered="true" toc="default">
        <name>NADA</name>
        <t>Network-Assisted Dynamic Adaptation (NADA) <xref
        target="RFC8698" format="default"/> is a congestion
        control scheme for WebRTC. It calculates a reference rate r_ref upon
        receiving an acknowledgment and then, based on the reference rate,
        calculates a video target rate r_vin and a sending rate for the flows,
        r_send.</t>

 <t>When applying the FSE to NADA, the UPDATE function call described in <xref
 target="flows" format="default"/> gives the FSE NADA's reference rate
 r_ref. The recommended algorithm for NADA is the Active FSE in <xref
 target="example-alg-act" format="default"/>. In step 3 (d), when the FSE_R(i) is "sent" to
 the flow i, r_ref (r_vin and r_send) of flow i is updated with the value of FSE_R(i).</t>

      </section>
      <section anchor="app-general" numbered="true" toc="default">
        <name>General Recommendations</name>
        <t>This section provides general advice for applying the FSE to congestion control mechanisms.</t>
        <dl newline="true" spacing="normal" indent="6">
          <dt>Receiver-side calculations:</dt>
          <dd>
        When receiver-side calculations make assumptions about the rate of the
        sender, the calculations need to be synchronized, or the receiver needs
        to be updated accordingly. This applies to TCP Friendly Rate Control
        (TFRC) <xref target="RFC5348" format="default"/>, for example, where
        simulations showed somewhat less favorable results when using the FSE
        without a receiver-side change <xref target="FSE"
        format="default"/>.</dd>
          <dt>Stateful algorithms:</dt>

          <dd>
        When a congestion control algorithm is stateful (e.g., during the TCP slow
        start, congestion avoidance, or fast recovery phase), these states should
        be carefully considered such that the overall state of the aggregate
        flow is correct. This may require sharing more information in the
        UPDATE call.
        </dd>
          <dt>Rate jumps:</dt>
          <dd>
        The FSE-based coupling algorithms can let a flow quickly increase its
        rate to its fair share, e.g., when a new flow joins or after a
        quiescent period. In case of window-based congestion controls, this
        may produce a burst that should be mitigated in some way. An example
        of how this could be done without using a timer is presented in <xref
        target="ANRW2016" format="default"/>, using TCP as an example.
    </dd>
        </dl>
      </section>
    </section>
    <section anchor="expected-feedback" numbered="true" toc="default">
      <name>Expected Feedback from Experiments</name>
      <t>The algorithm described in this memo has so far been evaluated using
      simulations covering all the tests for more than one flow from <xref
      target="I-D.ietf-rmcat-eval-test" format="default"/> (see <xref
      target="IETF-93" format="default"/> and <xref target="IETF-94"
      format="default"/>). Experiments should confirm these results using at
      least the NADA congestion control algorithm with real-life code (e.g.,
      browsers communicating over an emulated network covering the conditions
      in <xref target="I-D.ietf-rmcat-eval-test" format="default"/>).  The
      tests with real-life code should be repeated afterwards in real network
      environments and monitored. Experiments should investigate cases where
      the media coder's output rate is below the rate that is calculated by
      the coupling algorithm (FSE_R(i) in algorithms 1 (<xref
      target="example-alg-act"/>) and 2 (<xref
      target="example-alg-act-cons"/>)). Implementers and testers are invited
      to document their findings in an Internet-Draft.</t>
    </section>

    <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>In scenarios where the architecture described in this document is
      applied across applications, various cheating possibilities arise, e.g.,
      supporting wrong values for the calculated rate, desired rate, or
      priority of a flow. In the worst case, such cheating could either
      prevent other flows from sending or make them send at a rate that is
      unreasonably large. The end result would be unfair behavior at the
      network bottleneck, akin to what could be achieved with any UDP-based
      application. Hence, since this is no worse than UDP in general, there
      seems to be no significant harm in using this in the absence of UDP rate
      limiters.</t>
      <t>In the case of a single-user system, it should also be in the
      interest of any application programmer to give the user the best
      possible experience by using reasonable flow priorities or even letting
      the user choose them. In a multi-user system, this interest may not be
      given, and one could imagine the worst case of an "arms race" situation
      where applications end up setting their priorities to the maximum
      value. If all applications do this, the end result is a fair allocation
      in which the priority mechanism is implicitly eliminated and no major
      harm is done.</t>
      <t> Implementers should also be aware of the Security Considerations
      sections of <xref target="RFC3124" format="default"/>, <xref
      target="RFC5348" format="default"/>, and <xref target="RFC7478"
      format="default"/>.</t>
    </section>
  </middle>


 
  <back>

<displayreference target="I-D.ietf-rmcat-eval-test" to="RMCAT-PROPOSALS"/>
<displayreference target="I-D.ietf-rmcat-gcc" to="GCC-RTCWEB"/>
<displayreference target="I-D.ietf-rtcweb-transports" to="WEBRTC-TRANS"/>
<displayreference target="I-D.ietf-rtcweb-rtp-usage" to="RTCWEB-RTP-USAGE"/>
<displayreference target="I-D.ietf-rtcweb-overview" to="RTCWEB-OVERVIEW"/>


    <references>
      <name>References</name>

   <references>
        <name>Normative References</name>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3124.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5348.xml"/>

               


<reference anchor="RFC8698" target="https://www.rfc-editor.org/info/rfc8698">
<front>
<title>Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion
Control Scheme for Real-Time Media</title>
<author initials='X' surname='Zhu' fullname='Xiaoqing Zhu'>
  <organization/>
</author>
<author initials='R' surname='Pan' fullname='Rong Pan'>
  <organization/>
</author>
<author initials='M' surname='Ramalho' fullname='Michael A. Ramalho'>
  <organization/>
</author>
<author initials='S' surname='Mena' fullname='Sergio Mena de la Cruz'>
  <organization/>
</author>
<date month='January' year='2020'/>
</front>
<seriesInfo name="RFC" value="8698"/>
<seriesInfo name="DOI" value="10.17487/RFC8698"/>
</reference>


      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7656.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8087.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8382.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7478.xml"/>


             <!-- I-D.ietf-rmcat-eval-test: I-D exists -->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rmcat-eval-test.xml"/>

             <!-- I-D.draft-ietf-rmcat-gcc-02: Expired -->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rmcat-gcc.xml"/>

             <!-- I-D.ietf-rtcweb-transports: I-D exists-->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-transports.xml"/>


<!-- I-D.ietf-rtcweb-overview: I-D exists -->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-overview.xml"/>

<!-- I-D.ietf-rtcweb-rtp-usage: I-D exists-->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-rtp-usage.xml"/>


       <!-- draft-westerlund-avtcore-transport-multiplexing-07: Expired -
            unable to use short way-->
<reference anchor='TRANSPORT-MULTIPLEX' target="">
<front>
<title>Multiple RTP Sessions on a Single Lower-Layer Transport</title>
<author initials='M.' surname='Westerlund' fullname='Magnus Westerlund'>
    <organization />
</author>
<author initials='C.' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>
<date month='October' year='2013' />
</front>
<seriesInfo name='Internet-Draft' value='draft-westerlund-avtcore-transport-multiplexing-07'/>
</reference>


        <reference anchor="FSE" target="http://safiquli.at.ifi.uio.no/paper/fse-tech-report.pdf">
          <front>
            <title>Coupled Congestion Control for RTP Media</title>          
            <author initials="S." surname="Islam" fullname="S. Islam"/>
            <author initials="M." surname="Welzl" fullname="M. Welzl"/>
            <author initials="S." surname="Gjessing" fullname="S Gjessing"/>
            <author initials="N." surname="Khademi" fullname="N Khademi"/>
            <date month="March" year="2014"/>
          </front>
<refcontent>ACM SIGCOMM Capacity Sharing Workshop (CSWS 2014) and ACM SIGCOMM
CCR 44(4) 2014
</refcontent>
        </reference>

        <reference anchor="FSE-NOMS">
          <front>
            <title>Managing real-time media flows through a flow state exchange</title>
            <seriesInfo name="DOI" value="10.1109/NOMS.2016.7502803"/>
            <author initials="S." surname="Islam" fullname="Safiqul Islam"/>
            <author initials="M." surname="Welzl" fullname="Michael Welzl"/>
            <author initials="D." surname="Hayes" fullname="David Hayes"/>
            <author initials="S." surname="Gjessing" fullname="Stein Gjessing"/>
          </front>
<refcontent>IEEE NOMS 2016
</refcontent>
        </reference>



        <reference anchor="IETF-93" target="https://www.ietf.org/proceedings/93/rmcat.html">
          <front>
            <title>Updates on 'Coupled
              Congestion Control for RTP Media'
	    </title>
            <author initials="S." surname="Islam" fullname="Safiqul Islam"/>
            <author initials="M." surname="Welzl" fullname="Michael Welzl"/>
            <author initials="S." surname="Gjessing" fullname="S Gjessing"/>
            <date month="July" year="2015"/>
          </front>
<seriesInfo name="IETF" value="93" />
<refcontent>RTP Media Congestion Avoidance Techniques (rmcat) Working Group</refcontent>
        </reference>

        <reference anchor="IETF-94" target="https://www.ietf.org/proceedings/94/rmcat.html">
          <front>
            <title>Updates on 'Coupled Congestion Control for RTP Media'</title>
            <author initials="S." surname="Islam" fullname="Safiqul Islam"/>
            <author initials="M." surname="Welzl" fullname="M. Welzl"/>
            <author initials="S." surname="Gjessing" fullname="S Gjessing"/>
            <date month="November" year="2015"/>
          </front>
<seriesInfo name="IETF" value="94" />
<refcontent>RTP Media Congestion Avoidance Techniques (rmcat) Working Group</refcontent>
        </reference>

        <reference anchor="ANRW2016">
          <front>
            <title>Start Me Up: Determining and Sharing TCP's Initial Congestion Window</title>
<seriesInfo name="Proceedings of the 2016 Applied Networking Research
		  Workshop" value="Pages 52-54"/>
<seriesInfo name="DOI" value="10.1145/2959424.2959440"/>
            <author initials="S." surname="Islam" fullname="Safiqul Islam"/>
            <author initials="M." surname="Welzl" fullname="Michael Welzl"/>
            <date month="July" year="2016"/>
          </front>
<refcontent>ACM, IRTF, ISOC Applied Networking Research Workshop 2016 (ANRW 2016)
</refcontent>
        </reference>

      </references>

    </references>

    <section anchor="app-GCC" numbered="true" toc="default">
      <name>Application to GCC</name>
      <t>Google Congestion Control (GCC) <xref target="I-D.ietf-rmcat-gcc"
      format="default"/> is another congestion control scheme for RTP flows
      that is under development. GCC is not yet finalized, but at the time of
      this writing, the rate control of GCC employs two parts: controlling the
      bandwidth estimate based on delay and controlling the bandwidth
      estimate based on loss. Both are designed to estimate the available
      bandwidth, A_hat. </t>
      <t>When applying the FSE to GCC, the UPDATE function call described in
      <xref target="flows" format="default"/> gives the FSE GCC's estimate of
      available bandwidth A_hat. The recommended algorithm for GCC is the
      Active FSE in <xref target="example-alg-act" format="default"/>. In
      step 3 (d) of this algorithm, when the FSE_R(i) is "sent" to the flow i,
      A_hat of flow i is updated with the value of FSE_R(i).</t>
    </section>
    <section anchor="scheduling" numbered="true" toc="default">
      <name>Scheduling</name>
      <t> When flows originate from the same host, it would be possible to use
      only one sender-side congestion controller that determines the
      overall allowed sending rate and then use a local scheduler to assign a
      proportion of this rate to each RTP session. This way, priorities could
      also be implemented as a function of the scheduler. The Congestion
      Manager (CM) <xref target="RFC3124" format="default"/> also uses such a
      scheduling function.</t>
    </section>

    <section anchor="example-alg-pas" numbered="true" toc="default">
      <name>Example Algorithm - Passive FSE</name>
      <t>Active algorithms calculate the rates for all the flows in the FG and
      actively distribute them. In a passive algorithm, UPDATE returns a rate
      that should be used instead of the rate that the congestion controller
      has determined. This can make a passive algorithm easier to implement;
      however, when round-trip times of flows are unequal, flows with shorter RTTs
      may (depending on the congestion control algorithm) update and react to
      the overall FSE state more often than flows with longer RTTs, which can
      produce unwanted side effects. This problem is more significant when the
      congestion control convergence depends on the RTT. While the passive
      algorithm works better for congestion controls with RTT-independent
      convergence, it can still produce oscillations on short time scales. The
      algorithm described below is therefore considered highly experimental
      and not safe to deploy outside of testbed environments. Results of a
      simplified passive FSE algorithm with both NADA and GCC can be found in
      <xref target="FSE-NOMS" format="default"/>.</t>
      <t>In the passive version of the FSE, TLO (Total Leftover Rate) is a
      static variable per FG that is initialized to 0. Additionally, S_CR is
      limited to increase or decrease as conservatively as a flow's congestion
      controller decides in order to prohibit sudden rate jumps.

      </t>
      <ol spacing="normal" type="(%d)">
        <li>When a flow f starts, it registers itself with SBD and the
        FSE. FSE_R(f) and DR(f) are initialized with the congestion
        controller's initial rate. SBD will assign the correct FGI. When a
        flow is assigned an FGI, it adds its FSE_R(f) to S_CR.</li>
        <li>When a flow f stops or pauses, it sets its DR(f) to 0 and sets P(f) to -1.</li>
        <li>
          <t>Every time the congestion controller of the flow f determines a
          new sending rate CC_R(f), assuming the flow's new desired rate
          new_DR(f) to be "infinity" in case of a bulk data transfer with an
          unknown maximum rate, the flow calls UPDATE, which carries out the
          tasks listed below to derive the flow's new sending rate, Rate(f). A
          flow's UPDATE function uses a few local (i.e., per-flow) temporary
          variables, which are all initialized to 0: DELTA, new_S_CR, and S_P.
          </t>

          <ol spacing="normal" type="(%c)">
            <li>
              <t>For all the flows in its FG (including itself), it calculates
              the sum of all the calculated rates, new_S_CR. Then, it
              calculates DELTA: the difference between FSE_R(f) and CC_R(f).
              </t>
              <sourcecode type="pseudocode"><![CDATA[
          for all flows i in FG do
              new_S_CR = new_S_CR + FSE_R(i)
          end for
          DELTA =  CC_R(f) - FSE_R(f)                  ]]></sourcecode>
            </li>
            <li>
              <t>It updates S_CR, FSE_R(f), and DR(f).
              </t>
              <sourcecode type="pseudocode"><![CDATA[
          FSE_R(f) = CC_R(f)
          if DELTA > 0 then  // the flow's rate has increased
              S_CR = S_CR + DELTA
          else if DELTA < 0 then
              S_CR = new_S_CR + DELTA
          end if 
          DR(f) = min(new_DR(f),FSE_R(f))                  ]]></sourcecode>
            </li>

            <li>
              <t>It calculates the leftover rate TLO, removes the terminated
              flows from the FSE, and calculates the sum of all the priorities,
              S_P.
              </t>
              <sourcecode type="pseudocode"><![CDATA[
            for all flows i in FG do
               if P(i)<0 then
                  delete flow
               else
                  S_P = S_P + P(i)
               end if
            end for
            if DR(f) < FSE_R(f) then
               TLO = TLO + (P(f)/S_P) * S_CR - DR(f))
            end if                  ]]></sourcecode>
            </li>
            <li>
              <t>It calculates the sending rate, Rate(f).
              </t>
              <sourcecode type="pseudocode"><![CDATA[
            Rate(f) = min(new_DR(f), (P(f)*S_CR)/S_P + TLO)
                          
            if Rate(f) != new_DR(f) and TLO > 0 then
                TLO = 0  // f has 'taken' TLO
            end if                  ]]></sourcecode>
            </li>
            <li>
              <t>It updates DR(f) and FSE_R(f) with Rate(f).
              </t>
              <sourcecode type="pseudocode"><![CDATA[
            if Rate(f) > DR(f) then
                DR(f) = Rate(f)
            end if
            FSE_R(f)  = Rate(f)                ]]></sourcecode>
            </li>
          </ol>
        </li>
      </ol>
      <t>The goals of the flow algorithm are to achieve prioritization,
      improve network utilization in the face of application-limited flows,
      and impose limits on the increase behavior such that the negative impact
      of multiple flows trying to increase their rate together is
      minimized. It does that by assigning a flow a sending rate that may not
      be what the flow's congestion controller expected. It therefore builds
      on the assumption that no significant inefficiencies arise from
      temporary application-limited behavior or from quickly jumping to a rate
      that is higher than the congestion controller intended. How problematic
      these issues really are depends on the controllers in use and requires
      careful per-controller experimentation. The coupled congestion control
      mechanism described here also does not require all controllers to be
      equal; effects of heterogeneous controllers, or homogeneous controllers
      being in different states, are also subject to experimentation.</t>

      <t>This algorithm gives the leftover rate of application-limited
      flows to the first flow that updates its sending rate, provided that
      this flow needs it all (otherwise, its own leftover rate can be taken by
      the next flow that updates its rate).  Other policies could be applied,
      e.g., to divide the leftover rate of a flow equally among all other flows
      in the FGI.</t>
      <section anchor="example-op" numbered="true" toc="default">
        <name>Example Operation (Passive)</name>
        <t>In order to illustrate the operation of the passive coupled
        congestion control algorithm, this section presents a toy example of
        two flows that use it. Let us assume that both flows traverse a common
        10 Mbit/s bottleneck and use a simplistic congestion controller that
        starts out with 1 Mbit/s, increases its rate by 1 Mbit/s in the
        absence of congestion, and decreases it by 2 Mbit/s in the presence of
        congestion. For simplicity, flows are assumed to always operate in a
        round-robin fashion. Rate numbers below without units are assumed to
        be in Mbit/s. For illustration purposes, the actual sending rate is
        also shown for every flow in FSE diagrams even though it is not really
        stored in the FSE.</t>
        <t>Flow #1 begins. It is a bulk data transfer and considers itself to
        have top priority.  This is the FSE after the flow algorithm's step
        1:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[----------------------------------------
| # | FGI |  P  | FSE_R  |  DR  | Rate |
|   |     |     |        |      |      |
| 1 |  1  |  1  |   1    |   1  |   1  |
----------------------------------------
S_CR = 1, TLO = 0                  ]]></artwork>
        <t>Its congestion controller gradually increases its rate. Eventually,
        at some point, the FSE should look like this:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[-----------------------------------------
| # | FGI |  P  |  FSE_R  |  DR  | Rate |
|   |     |     |         |      |      |
| 1 |  1  |  1  |   10    |  10  |  10  |
-----------------------------------------
S_CR = 10, TLO = 0    ]]></artwork>
        <t>Now, another flow joins. It is also a bulk data transfer and has a
        lower priority (0.5):</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[------------------------------------------
| # | FGI |   P   | FSE_R  |  DR  | Rate |
|   |     |       |        |      |      |
| 1 |  1  |   1   |   10   |  10  |  10  |
| 2 |  1  |  0.5  |    1   |   1  |   1  |
------------------------------------------
S_CR = 11, TLO = 0    ]]></artwork>
        <t>Now, assume that the first flow updates its rate to 8, because the
        total sending rate of 11 exceeds the total capacity.  Let us take a
        closer look at what happens in step 3 of the flow algorithm.</t>

<t>CC_R(1) = 8. new_DR(1) = infinity.</t>
<ol spacing="normal" type="(3%c)">
<li>new_S_CR = 11; DELTA = 8 - 10 = -2.</li>
<li>FSE_R(1) = 8. DELTA is negative, hence S_CR = 9; DR(1) = 8</li>
<li>S_P = 1.5.</li>
<li>new sending rate Rate(1) = min(infinity, 1/1.5 * 9 + 0) = 6.</li>
<li>FSE_R(1) = 6.</li>
</ol>

<t>The resulting FSE looks as follows:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[
-------------------------------------------
| # | FGI |   P   |  FSE_R  |  DR  | Rate |
|   |     |       |         |      |      |
| 1 |  1  |   1   |    6    |   8  |   6  |
| 2 |  1  |  0.5  |    1    |   1  |   1  |
-------------------------------------------
S_CR = 9, TLO = 0    ]]></artwork>


        <t>The effect is that flow #1 is sending with 6 Mbit/s instead of the
        8 Mbit/s that the congestion controller derived. Let us now assume
        that flow #2 updates its rate. Its congestion controller detects that
        the network is not fully saturated (the actual total sending rate is
        6+1=7) and increases its rate.</t>

<t>CC_R(2) = 2. new_DR(2) = infinity.</t>
<ol spacing="normal" type="(3%c)">
<li>new_S_CR = 7; DELTA = 2 - 1 = 1.</li>
<li>FSE_R(2) = 2. DELTA is positive, hence S_CR = 9 + 1 = 10; DR(2) = 2.</li>
<li>S_P = 1.5.</li>
<li>Rate(2) = min(infinity, 0.5/1.5 * 10 + 0) = 3.33.</li>
<li>DR(2) = FSE_R(2) = 3.33.</li>
</ol>

<t>The resulting FSE looks as follows:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[
-------------------------------------------
| # | FGI |   P   |  FSE_R  |  DR  | Rate |
|   |     |       |         |      |      |
| 1 |  1  |   1   |    6    |   8  |   6  |
| 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |
-------------------------------------------
S_CR = 10, TLO = 0    ]]></artwork>
        <t>The effect is that flow #2 is now sending with 3.33 Mbit/s, which
        is close to half of the rate of flow #1 and leads to a total
        utilization of 6(#1) + 3.33(#2) = 9.33 Mbit/s. Flow #2's congestion
        controller has increased its rate faster than the controller actually
        expected. Now, flow #1 updates its rate. Its congestion controller
        detects that the network is not fully saturated and increases its
        rate. Additionally, the application feeding into flow #1 limits the
        flow's sending rate to at most 2 Mbit/s.</t>



<t>CC_R(1) = 7. new_DR(1) = 2.</t>

<ol spacing="normal" type="(3%c)">
<li>new_S_CR = 9.33; DELTA = 1.</li>
<li>FSE_R(1) = 7, DELTA is positive, hence S_CR = 10 + 1 = 11; DR(1) = min(2, 7) = 2. </li>
<li>S_P = 1.5; DR(1) &lt; FSE_R(1), hence TLO = 1/1.5 * 11 - 2 = 5.33.</li>
<li>Rate(1) = min(2, 1/1.5 * 11 + 5.33) = 2.</li>
<li>FSE_R(1) = 2.</li>
</ol>

<t>The resulting FSE looks as follows:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[
-------------------------------------------
| # | FGI |   P   |  FSE_R  |  DR  | Rate |
|   |     |       |         |      |      |
| 1 |  1  |   1   |    2    |   2  |   2  |
| 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |
-------------------------------------------
S_CR = 11, TLO = 5.33                  ]]></artwork>

        <t>Now, the total rate of the two flows is 2 + 3.33 = 5.33 Mbit/s,
        i.e., the network is significantly underutilized due to the limitation
        of flow #1. Flow #2 updates its rate. Its congestion controller
        detects that the network is not fully saturated and increases its
        rate.</t>

<t>CC_R(2) = 4.33. new_DR(2) = infinity.</t>

<ol spacing="normal" type="(3%c)">
<li>new_S_CR = 5.33; DELTA = 1.</li>
<li>FSE_R(2) = 4.33. DELTA is positive, hence S_CR = 12; DR(2) = 4.33.</li>
<li>S_P = 1.5.</li>
<li>Rate(2) = min(infinity, 0.5/1.5 * 12 + 5.33 ) = 9.33.</li>
<li>FSE_R(2) = 9.33, DR(2) = 9.33.</li>
</ol>

<t>The resulting FSE looks as follows:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[
-------------------------------------------
| # | FGI |   P   |  FSE_R  |  DR  | Rate |
|   |     |       |         |      |      |
| 1 |  1  |   1   |    2    |   2  |   2  |
| 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |
-------------------------------------------
S_CR = 12, TLO = 0    ]]></artwork>
        <t>Now, the total rate of the two flows is 2 + 9.33 = 11.33
        Mbit/s. Finally, flow #1 terminates. It sets P(1) to -1 and DR(1) to
        0. Let us assume that it terminated late enough for flow #2 to still
        experience the network in a congested state, i.e., flow #2 decreases
        its rate in the next iteration.</t>

<t>CC_R(2) = 7.33. new_DR(2) = infinity.</t>

<ol spacing="normal" type="(3%c)">
<li>new_S_CR = 11.33; DELTA = -2.</li>
<li>FSE_R(2) = 7.33. DELTA is negative, hence S_CR = 9.33; DR(2) = 7.33.</li>
<li>Flow 1 has P(1) = -1, hence it is deleted from the FSE. S_P = 0.5.</li>
<li>Rate(2) = min(infinity, 0.5/0.5*9.33 + 0) = 9.33.</li>
<li>FSE_R(2) = DR(2) = 9.33.</li>
</ol>

<t>The resulting FSE looks as follows:</t>
        <artwork align="left" name="" type="" alt=""><![CDATA[
-------------------------------------------
| # | FGI |   P   |  FSE_R  |  DR  | Rate |
|   |     |       |         |      |      |
| 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |
-------------------------------------------
S_CR = 9.33, TLO = 0        ]]></artwork>
      </section>
    </section>   
    <section anchor="Acknowledgements" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>This document benefited from discussions with and feedback from
      <contact fullname="Andreas Petlund"/>,
      <contact fullname="Anna Brunstrom"/>,
      <contact fullname="Colin Perkins"/>,
      <contact fullname="David Hayes"/>,
      <contact fullname="David Ros"/>
      (who also gave the FSE its name), 
      <contact fullname="Ingemar Johansson"/>,
      <contact fullname="Karen Nielsen"/>,
      <contact fullname="Kristian Hiorth"/>,
      <contact fullname="Martin Stiemerling"/>,
      <contact fullname="Mirja Kühlewind"/>,
      <contact fullname="Spencer Dawkins"/>,
      <contact fullname="Varun Singh"/>,
      <contact fullname="Xiaoqing Zhu"/>, and
      <contact fullname="Zaheduzzaman Sarker"/>. The authors would
      like to especially thank <contact fullname="Xiaoqing Zhu"/> and <contact fullname="Stefan Holmer"/> for helping with
      NADA and GCC, and <contact fullname="Anna Brunstrom"/> as well as <contact fullname="Julius Flohr"/> for helping us
      correct the active algorithm for the case of application-limited
      flows.</t>
      <t>This work was partially funded by the European Community under its
      Seventh Framework Program through the Reducing Internet Transport
      Latency (RITE) project (ICT-317700).</t>
    </section>


  </back>
</rfc>
