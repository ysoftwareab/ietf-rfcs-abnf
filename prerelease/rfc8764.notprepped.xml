<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" number="8764"
     docName="draft-sekar-dns-llq-06" category="info"
     submissionType="independent" ipr="trust200902" obsoletes="" updates=""
     xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true"
     version="3"> 
 
  <front>
    <title abbrev="Apple's DNS LLQ">Apple's DNS Long-Lived Queries
    Protocol</title>
    <seriesInfo name="RFC" value="8764"/>
    <author initials="S." surname="Cheshire" fullname="Stuart Cheshire">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino</city>
          <region>CA</region>
          <code>95014</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 (408) 996-1010</phone>
        <email>cheshire@apple.com</email>
      </address>
    </author>
    <author initials="M." surname="Krochmal" fullname="Marc Krochmal">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino</city>
          <region>CA</region>
          <code>95014</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 (408) 996-1010</phone>
        <email>marc@apple.com</email>
      </address>
    </author>
    <date year="2020" month="June"/>

<keyword>Async</keyword>
<keyword>Asynchronous</keyword>
<keyword>Change Notification</keyword>
<keyword>Push Notification</keyword>

     <abstract>
       <t>
	  Apple's DNS Long-Lived Queries (LLQ) is a mechanism
	   for extending the DNS protocol to support change notification,
	    thus allowing clients to learn about changes to DNS data
	     without polling the server.  From 2005 onwards, LLQ was
	      implemented in Apple products including Mac OS X, Bonjour for
	       Windows, and AirPort wireless base stations.  In 2020, the LLQ
	        protocol was superseded by the IETF Standards Track RFC 8765,
		"DNS
		 Push Notifications", which builds on experience gained with
		  the LLQ protocol to create a superior replacement.
       </t>
       <t>
    The existing LLQ protocol deployed and used from 2005 to 2020 is
    documented here to give
    background regarding the operational experience that informed
    the development of DNS Push Notifications, and to help facilitate
    a smooth transition from LLQ to DNS Push Notifications.
       </t>
     </abstract>
  </front>
   <middle>
     <section anchor="introduction" numbered="true" toc="default">
       <name>Introduction</name>
       <t>
    In dynamic environments, DNS-based Service Discovery <xref target="RFC6763"
    format="default"/> benefits
    significantly from clients being able to learn about changes to
    DNS information via a mechanism that is both more timely and more
    efficient than simple polling. Such a mechanism enables "live
    browses" that (a) learn when a new instance of a service appears, (b)
    learn when
    an existing service instance disappears from the network, and (c) allows
    clients
    to monitor status changes to a service instance (e.g., printer ink
    levels).
    Multicast DNS <xref target="RFC6762" format="default"/> supports this
    natively. When a device on the network publishes or deletes Multicast DNS
    records, these changes are multicast to other hosts on the network.
    Those hosts deliver the change notifications to interested clients
    (applications
    running on that host). Hosts also send occasional queries to the
    network, in case gratuitous announcements are not received due to
    packet loss, and to detect records lost due to their publishers
    crashing or having become disconnected from the network.
       </t>
       <t>
   This document defines an Apple extension to unicast DNS that enables a
   client to
   issue long-lived queries that allow a unicast DNS server to notify clients
   about changes to DNS data. This is a more scalable and practical
   solution than can be achieved by polling of the name server, because
   a low polling rate could leave the client with stale information,
   while a high polling rate would have an adverse impact on the network
   and server.
       </t>
       <t>
   The mechanism defined in this document is now being replaced by DNS Push
   Notifications <xref target="RFC8765" format="default"></xref> as explained
   in <xref target="trans" format="default"/>.
       </t>
       <t>
       </t>
       <section anchor="trans" numbered="true" toc="default">
	  <name>Transition to DNS Push Notifications</name>
	   <t>
    The LLQ protocol enjoyed over a decade of useful operation,
    enabling timely live updates for the service discovery user interface in
    Apple's Back to My Mac <xref target="RFC6281" format="default"></xref>
    service.
	   </t>
	    <t>
    However, some problems were discovered, as described in <xref
    target="problems" format="default"/>.
    This operational
    experience with LLQ informed the design of its IETF Standards
    Track successor, DNS Push Notifications <xref target="RFC8765"
    format="default"></xref>.
    Since no further work is being done on the LLQ protocol, this LLQ
    specification will not be updated to remedy these problems.
	    </t>
	     <t>
    All existing LLQ implementations are <bcp14>RECOMMENDED</bcp14> to migrate
    to using DNS Push Notifications instead.
	     </t>
	      <t>
    Existing LLQ servers are <bcp14>RECOMMENDED</bcp14> to implement and
    support
    DNS Push Notifications so that clients can begin migrating to the
    newer protocol.
	      </t>
	       <t>
    Existing LLQ clients are <bcp14>RECOMMENDED</bcp14> to query for the
    <tt>_dns&nbhy;push&nbhy;tls._tcp.&lt;zone&gt;</tt> SRV record first, and
    then only if DNS Push Notifications fail, fall back to query for
    <tt>_dns&nbhy;llq._udp.&lt;zone&gt;</tt> instead.  Use of the
    <tt>_dns&nbhy;llq._udp.&lt;zone&gt;</tt> SRV record is described in <xref
    target="address-port"/>.
	       </t>
	        <t>
    This will cause clients to prefer the newer protocol when possible.  It is
    <bcp14>RECOMMENDED</bcp14> that clients always attempt DNS Push
    Notifications first for every new request, and only if that fails, then
    fall back to using LLQ.  Clients <bcp14>SHOULD NOT</bcp14> record that a
    given server only speaks LLQ and subsequently default to LLQ for that
    server, since server software gets updated and even a server that speaks
    only LLQ today may be updated to support DNS Push Notifications tomorrow.
		</t>
		 <t>
    New client and server implementations are <bcp14>RECOMMENDED</bcp14> to
    support only
    DNS Push Notifications.
		 </t>

       </section>
     </section>
     <section numbered="true" toc="default">
       <name>Conventions and Terminology Used in This Document</name>

        <t>
     The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
     "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
     NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
     "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
     "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
     to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
     <xref target="RFC8174"/> when, and only when, they appear in all
     capitals, as shown here.
	</t>

     </section>
     <section numbered="true" toc="default">
       <name>Mechanisms</name>
       <t>
    DNS Long-Lived Queries (LLQ) are implemented using the standard
    DNS message format <xref target="RFC1035" format="default"/> in
    conjunction with an EDNS(0) OPT
    pseudo&nbhy;RR <xref target="RFC6891" format="default"/> with a new
    OPTION&nbhy;CODE
    and OPTION&nbhy;DATA format specified here.  Encoding the LLQ request in
    an OPT pseudo&nbhy;RR
    allows for implementation of LLQ with minimal modification to a name
    server's front end.  If a DNS query containing an LLQ option is sent to a
    server that does not implement LLQ, a server that complies with the
    EDNS(0) specification <xref target="RFC6891" format="default"></xref> will
    silently ignore the unrecognized option and answer the request as a normal
    DNS query without establishing any long-lived state and without
    returning an LLQ option in its response.  If a DNS query containing an LLQ
    option is sent to a server that does not implement EDNS(0) at all, the
    server may silently ignore the EDNS(0) OPT pseudo&nbhy;RR or it may
    return a nonzero RCODE.  However, in practice, this issue is mostly
    theoretical, since having a zone's _dns&nbhy;llq._udp.&lt;zone&gt; SRV
    record target a host that does not implement LLQ is a configuration error.
       </t>
       <t>
    Note that this protocol is designed for data set sizes of a few dozen
    resource records at most and change rates no more than once every 10
    seconds on average. Data sets that frequently
    exceed a single IP packet, or that experience a rapid change rate, may
    have
    undesirable performance implications.
       </t>

       <section numbered="true" toc="default">
	  <name>Assigned Numbers</name>
	   <t>
	      This section describes constants used in this document.
	   </t>

<ul empty="true">

   <li>
     <t>EDNS(0) OPTION&nbhy;CODE (recorded with IANA):</t>

     <ul empty="true">
      <li>
         <dl indent="18">
         <dt>LLQ
         </dt>
         <dd>1
         </dd>
	 </dl>
      </li>
     </ul>
   </li>

   <li>
LLQ&nbhy;PORT 5352 (recorded with IANA)
   </li>

   <li><t>LLQ Opcodes (specific to this LLQ EDNS(0) Option):</t>

   <ul empty="true">  
      <li>
         <dl indent="18" spacing="compact">
         <dt>LLQ&nbhy;SETUP
         </dt>
         <dd>1
         </dd>

         <dt>LLQ&nbhy;REFRESH
         </dt>
         <dd>2
         </dd>

         <dt>LLQ&nbhy;EVENT
         </dt>
         <dd>3
         </dd>
	 </dl>
      </li>
   </ul>
   </li>

   <li>
<t>LLQ Error Codes (specific to this LLQ EDNS(0) Option):</t>

      <ul empty="true">
         <li>
<dl indent="18" spacing="compact">
<dt>
NO-ERROR
</dt>
<dd>0
</dd>

<dt>
SERV-FULL
</dt>
<dd>1
</dd>

<dt>
STATIC
</dt>
<dd>2
</dd>

<dt>
FORMAT-ERR
</dt>
<dd>3
</dd>

<dt>
NO-SUCH-LLQ
</dt>
<dd>4
</dd>

<dt>
BAD-VERS
</dt>
<dd>5
</dd>

<dt>
UNKNOWN-ERR
</dt>
<dd>6
</dd>
</dl>
         </li>
      </ul>
   </li>
</ul>

       </section>
       
<section numbered="true" toc="default">
   <name>Opt-RR Format</name>
    <t>
    As required by the EDNS(0) specification <xref target="RFC6891"
    format="default"></xref>,
    all OPT pseudo&nbhy;RRs used in LLQs are formatted as follows:
    </t>

<table anchor="OPT-RRs"> 
  <name>OPT-RRs Used in LLQs</name> 
  <thead>
    <tr>
      <th>Field Name</th>   
      <th>Field Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>       
    <tr>
      <td>NAME</td>
      <td>domain name</td>
      <td>MUST be 0 (root domain)</td>
    </tr>
    <tr>
      <td>TYPE</td>
      <td>u_int16_t</td>
      <td>OPT (41)</td>
    </tr>
    <tr>
      <td>CLASS</td>
      <td>u_int16_t</td>
      <td>0*</td>
    </tr>
    <tr>
      <td>TTL</td>
      <td>u_int32_t</td>
      <td>0</td>
    </tr>
    <tr>
      <td>RDLEN</td>
      <td>u_int16_t</td>
      <td>length of all RDATA</td>
    </tr>
    <tr>
      <td>RDATA</td>
      <td>octet stream</td>
      <td>(see below)</td>
    </tr>
  </tbody>
</table>

 <t>
    * The CLASS field indicates, as per the EDNS(0) specification <xref
    target="RFC6891" format="default"></xref>, the sender's UDP payload
    size. However, clients and servers are not required to determine their
    reassembly buffer size, path MTU, etc., to support LLQ. Thus, the sender
    of
    an LLQ Request or Response <bcp14>MAY</bcp14> set the CLASS field to 0.
    The recipient <bcp14>MUST</bcp14> ignore the class field if it is set to
    0.
 </t>
  <t>
    The RDATA of an EDNS(0) OPT pseudo&nbhy;RR consists of zero or more
    options
    of the form { OPTION&nbhy;CODE, OPTION&nbhy;LENGTH, OPTION&nbhy;DATA }
    packed together,
    with the RDLEN field set accordingly to indicate the total size.
    An LLQ OPTION is illustrated below.
    An EDNS(0) OPT pseudo&nbhy;RR may contain zero or more LLQ OPTIONS in
    addition
    to zero or more other EDNS(0) options.
  </t>





<table anchor="LLQ-OPT-FORMAT"> 
  <name>LLQ OPTION</name> 
  <thead>
    <tr>
      <th>Field Name</th>   
      <th>Field Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>       
    <tr>
      <td>OPTION-CODE</td>
      <td>u_int16_t</td>
      <td>LLQ (1)</td>
    </tr>
    <tr>
      <td>OPTION-LENGTH</td>
      <td>u_int16_t</td>
      <td>Length of following fields (18)</td>
    </tr>
    <tr>
      <td>LLQ-VERSION</td>
      <td>u_int16_t</td>
      <td>Version of LLQ protocol implemented</td>
    </tr>
    <tr>
      <td>LLQ-OPCODE</td>
      <td>u_int16_t</td>
      <td>Identifies LLQ operation</td>
    </tr>
    <tr>
      <td>LLQ-ERROR</td>
      <td>u_int16_t</td>
      <td>Identifies LLQ errors</td>
    </tr>
    <tr>
      <td>LLQ-ID</td>
      <td>u_int64_t</td>
      <td>Identifier for an LLQ</td>
    </tr>
    <tr>
      <td>LLQ-LEASE</td>
      <td>u_int32_t</td>
      <td>Requested or granted life of LLQ, in seconds</td>
    </tr>

  </tbody>
</table>

        <t>
   The size and meaning of the OPTION&nbhy;CODE and OPTION&nbhy;LENGTH fields
   are as described in the EDNS(0) specification <xref target="RFC6891"
   format="default"></xref>.  The remainder of the fields comprise the
   OPTION&nbhy;DATA of the EDNS(0) LLQ OPTION.  Since for LLQ the
   OPTION&nbhy;DATA is a
   fixed size, in EDNS(0) LLQ OPTIONS the OPTION&nbhy;LENGTH field always has
   the value 18.
        </t>
        <t>
   In keeping with Internet convention, all multi-byte numeric quantities
   (u_int16_t, u_int32_t, and u_int64_t)
   are represented in big endian byte order (most significant byte first).
        </t>
</section>
</section>
    <section numbered="true" toc="default" anchor="address-port">
      <name>LLQ Address and Port Identification</name>
      <t>
   The client
   requires a mechanism to determine to which server it should send LLQ
   operations.
      </t>
      <t>
   Additionally, some firewalls block direct communication with a name server
   on port 53 to avoid spoof responses. However, this direct communication is
   necessary for LLQs. Thus, servers <bcp14>MAY</bcp14> listen for LLQs on a
   different port (typically 5352). Clients, therefore, also need a
   mechanism to determine to which port to send LLQ operations.
      </t>

      <t>
   The client determines the server responsible for a given LLQ much as a
   client determines to which server to send a DNS dynamic update. The client
   begins by sending a standard DNS query for the name of the LLQ, with type
   SOA.  If the record exists, then the server <bcp14>MUST</bcp14> answer with
   that SOA record in the Answer section.  If a record of type SOA with the
   LLQ name does not exist, then the server <bcp14>SHOULD</bcp14> include an
   SOA record for that name's zone in the Authority section.  For example, a
   query for "_ftp._tcp.example.com" with type SOA, when there is no SOA
   record with that name, might return an SOA record named "example.com" in
   the Authority section.  If the named SOA record does not exist and the
   server fails to include the enclosing SOA record in the Authority section,
   the client strips the leading label from the name and tries again,
   repeating until an answer is received.
      </t>
      <t>
   This iterative zone apex discovery algorithm is described in more detail in
   the DNS Push Notifications specification <xref target="RFC8765"
   format="default"></xref>.
      </t>
      <t>
   Upon learning the zone apex (SOA), the client then constructs and sends an
   SRV query for the name, "_dns&nbhy;llq._udp.&lt;zone&gt;",
   e.g.,&nbsp;"_dns&nbhy;llq._udp.example.com".
      </t>
      <t>
   An authoritative server for a zone implementing LLQ <bcp14>MUST</bcp14>
   answer with an SRV record <xref target="RFC2782" format="default"/>
   for this name. The SRV RDATA is as follows:
      </t>



<table anchor="SRV-RDATA">
  <name>SRV RDATA</name>
  <tbody>
    <tr>
      <td>PRIORITY</td>
      <td>typically 0</td>

    </tr>
    <tr>
      <td>WEIGHT</td>
      <td>typically 0</td>

    </tr>
    <tr>
      <td>PORT</td>
      <td>typically 53 or 5352</td>

    </tr>
    <tr>
      <td>TARGET</td>
      <td>name of server providing LLQs for the requested zone</td>

    </tr>
  </tbody>
</table>



      <t>
   The server <bcp14>SHOULD</bcp14> include the address record(s) for the
   target host in the Additional
   section of the response.
      </t>
      <t>
   If the server does not include the target host's address record(s) in the
   Additional
   section, the client <bcp14>SHOULD</bcp14> query explicitly for the address
   record(s)
   with the name of the SRV target.
      </t>
      <t>
   The client <bcp14>MUST</bcp14> send all LLQ requests, refreshes, and
   acknowledgments to the name server specified in the SRV target, at the
   address contained in the address record for that target. Note that the
   queries described in this section (including those for SOA and SRV records)
   <bcp14>MAY</bcp14> be sent to an intermediate DNS recursive resolver --
   they
   need not be sent directly to the name server.
      </t>
      <t>
   If, on issuing the SRV query, the client receives a negative
   response indicating that the SRV record does not exist, the client
   <bcp14>SHOULD</bcp14> conclude that the zone does not support LLQ.
   The client then <bcp14>SHOULD NOT</bcp14> send an LLQ request for
   the desired name, instead utilizing the behavior for LLQ-unaware
   servers described in <xref target="llq-setup"/>, "<xref target="llq-setup"
   format="title"/>".
      </t>

      <t>
   Servers should send all messages to the source address and port of
   the LLQ setup message received from the client.
      </t>
    </section>
    <section numbered="true" toc="default" anchor="llq-setup">
      <name>LLQ Setup</name>
      <t>
   An LLQ is initiated by a client and is completed via a four-way
   handshake. This handshake provides resilience to packet loss,
   demonstrates client reachability, and reduces denial-of-service
   attack opportunities (see <xref target="security-considerations"/>, "<xref
   target="security-considerations" format="title"/>").
      </t>
      <section numbered="true" toc="default"
	       anchor="setup-message-retransmission">
        <name>Setup Message Retransmission</name>
        <t>
   LLQ Setup Requests and Responses sent by the client <bcp14>SHOULD</bcp14>
   be
   retransmitted if no acknowledgments are received. The client
   <bcp14>SHOULD</bcp14>
   retry up to two more times (for a total of 3 attempts) before
   considering the server down or unreachable. The client <bcp14>MUST</bcp14>
   wait at
   least 2 seconds before the first retransmission and 4 seconds between
   the first and second retransmissions. The client <bcp14>SHOULD</bcp14>
   listen for a
   response for at least 8 seconds after the 3rd attempt before
   considering the server down or unreachable. Upon determining a
   server to be down, a client <bcp14>MAY</bcp14> periodically attempt to
   re-initiate
   an LLQ setup at a rate of not more than once per hour.
        </t>
        <t>
   Servers <bcp14>MUST NOT</bcp14> retransmit acknowledgments that do not
   generate
   responses from the client. Retransmission in setup is client driven,
   freeing servers from maintaining timers for incomplete LLQ setups. If
   servers receive duplicate messages from clients (perhaps due to the
   loss of the server's responses mid-flight), the server <bcp14>MUST</bcp14>
   resend
   its reply (possibly modifying the LLQ&nbhy;LEASE as described in <xref
   target="ack-answers"/>, "<xref
   target="ack-answers" format="title"/>").
        </t>
        <t>
   Servers <bcp14>MUST NOT</bcp14> garbage collect LLQs that fail to complete
   the four-way handshake until the initially granted LLQ&nbhy;LEASE has
   elapsed.
        </t>
      </section>

      <section numbered="true" toc="default" anchor="four-way-handshake">
        <name>LLQ Setup Four-Way Handshake</name>
<t>The four phases of the handshake include:
</t>

<ul empty="true">
<li>
<dl indent="24">
<dt>1)  Setup Request
</dt>
<dd>client to server, identifies LLQ(s) requested
</dd>
<dt>2)  Setup Challenge
</dt>
<dd>server to client, provides
unique identifiers for successful requested LLQs, and
error(s) for unsuccessful requested LLQs.
</dd>
<dt>3)  Challenge Response
</dt>
<dd>client to server, echoes identifier(s), demonstrating client's
reachability and willingness to participate
</dd>
<dt>4)  ACK + Answers
</dt>
<dd>server to client, confirms setup and provides initial answers
</dd>
</dl>
</li>
</ul>

        <section numbered="true" toc="default" anchor="setup-request">
          <name>Setup Request</name>
          <t>
   A request for an LLQ is formatted like a standard DNS query but with
   an OPT pseudo&nbhy;RR containing LLQ metadata in its Additional
   section. LLQ
   Setup Requests are identified by the LLQ&nbhy;SETUP opcode and a
   zero&nbhy;valued LLQ&nbhy;ID.
          </t>
          <t>
   The request <bcp14>MAY</bcp14> contain multiple questions to set up
   multiple LLQs.
   A Setup Request consisting of multiple questions <bcp14>MUST</bcp14>
   contain multiple LLQ
   OPTIONS, one per question, with the LLQ OPTIONS in the
   same order as the questions they correspond to (i.e., the first
   LLQ OPTION corresponds to the first question, the second
   LLQ OPTION corresponds to the second question, etc.). If
   requesting multiple LLQs, clients <bcp14>SHOULD</bcp14> request the same
   LLQ&nbhy;LEASE
   for each LLQ. Requests over UDP <bcp14>MUST NOT</bcp14> contain multiple
   questions
   if doing so would cause the message to exceed a single IP packet.
          </t>
          <t>
   A client <bcp14>MUST NOT</bcp14> request multiple identical LLQs (i.e.,
   containing
   the same qname/type/class) from the same source IP address and port.
   This requirement is to avoid unnecessary load on servers.

   In the case of multiple independent client implementations that
   may run on the same device without knowledge of each other,
   it is allowable if they by chance send LLQ requests for the same
   qname/type/class. These independent implementations on the same
   client will be using different source ports. Likewise,
   to the server,
   multiple independent clients behind the same NAT gateway
   will appear as if they were
   multiple independent clients using different ports on the same host,
   and this is also allowable.


          </t>
          <t>
   The query <bcp14>MUST NOT</bcp14> be for record type ANY (255), class ANY
   (255), or
   class NONE (0).
          </t>

<table anchor="OPT-RR-LLQ"> 
  <name>Setup Request LLQ OPTION Format</name> 
  <thead>
    <tr>
      <th>Field Name</th>   
      <th>Field Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>       
    <tr>
      <td>OPTION-CODE</td>
      <td>u_int16_t</td>
      <td>LLQ (1)</td>
    </tr>
    <tr>
      <td>OPTION-LENGTH</td>
      <td>u_int16_t</td>
      <td>Length of following fields (18)</td>
    </tr>
    <tr>
      <td>LLQ-VERSION</td>
      <td>u_int16_t</td>
      <td>Version of LLQ protocol implemented by requester (1)</td>
    </tr>
    <tr>
      <td>LLQ-OPCODE</td>
      <td>u_int16_t</td>
      <td>LLQ-SETUP (1)</td>
    </tr>
    <tr>
      <td>LLQ-ERROR</td>
      <td>u_int16_t</td>
      <td>NO-ERROR (0)</td>
    </tr>
    <tr>
      <td>LLQ-ID</td>
      <td>u_int64_t</td>
      <td>0</td>
    </tr>
    <tr>
      <td>LLQ-LEASE</td>
      <td>u_int32_t</td>
      <td>Desired life of LLQ request</td>
    </tr>
  </tbody>
</table>
<t>The Setup Request LLQ OPTION <bcp14>MUST</bcp14> be repeated once for each
additional query in the
Question section.
</t>

        </section>
        <section numbered="true" toc="default" anchor="setup-challenge">
          <name>Setup Challenge</name>
          <t>
   Upon receiving an LLQ Setup Request, a server implementing LLQs will
   send a Setup Challenge to the requester (client). An LLQ Setup
   Challenge is a DNS response, with the DNS message ID matching that of
   the Setup Request, and with all questions contained in the Setup Request
   present
   in the Question section of the response. Additionally, the
   challenge contains a single OPT pseudo&nbhy;RR with an LLQ OPTION for
   each LLQ request, indicating the success or failure of each request.
   The LLQ OPTIONS <bcp14>MUST</bcp14> be in the same order as the questions
   they
   correspond to. Note that in a Setup Request containing multiple
   questions, some LLQs may succeed while others may fail.
          </t>

<table anchor="CHALLENGE-OPT-RR-DATA">
  <name>Setup Challenge LLQ OPTION Format</name> 
  <thead>
    <tr>
      <th>Field Name</th>   
      <th>Field Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>       
    <tr>
      <td>OPTION-CODE</td>
      <td>u_int16_t</td>
      <td>LLQ (1)</td>
    </tr>
    <tr>
      <td>OPTION-LENGTH</td>
      <td>u_int16_t</td>
      <td>Length of following fields (18)</td>
    </tr>
    <tr>
      <td>LLQ-VERSION</td>
      <td>u_int16_t</td>
      <td>Version of LLQ protocol implemented in server (1)</td>
    </tr>
    <tr>
      <td>LLQ-OPCODE</td>
      <td>u_int16_t</td>
      <td>LLQ-SETUP (1)</td>
    </tr>
    <tr>
      <td>LLQ-ERROR</td>
      <td>u_int16_t</td>
      <td>[As Appropriate]</td>
    </tr>
    <tr>
      <td>LLQ-ID</td>
      <td>u_int64_t</td>
      <td>[As Appropriate]</td>
    </tr>
    <tr>
      <td>LLQ-LEASE</td>
      <td>u_int32_t</td>
      <td>[As Appropriate]</td>
    </tr>
  </tbody>
</table>

          <t>
   The Setup Challenge LLQ OPTION <bcp14>MUST</bcp14> be repeated once for
   each query in the Questions
   section of the Setup Challenge.
   Further details for LLQ&nbhy;ERROR, LLQ&nbhy;ID and LLQ&nbhy;LEASE are
   given below.
          </t>

          <t>
   LLQ&nbhy;ERROR:
          </t>


<ul empty="true">
<li>
 <dl indent="18">
         <dt>NO-ERROR:
         </dt>
         <dd>The LLQ Setup Request was successful.
         </dd>
<dt>FORMAT-ERR:
</dt>
<dd>The LLQ was improperly formatted.  Note that if the rest of the DNS
message is properly formatted, the DNS header error code <bcp14>MUST
NOT</bcp14> include a format error code, since to do so would cause ambiguity
between the case where a client sends a valid LLQ Setup Request to a server
that does not understand LLQ and the case where a client sends a malformed
LLQ Setup Request to a server that does understand LLQ.
</dd>

<dt>SERV-FULL:
</dt>
<dd>The server cannot grant the LLQ request because it is overloaded or the
request exceeds the server's rate limit (see <xref
target="security-considerations"/>, <xref target="security-considerations"
format="title"/>).  Upon
returning this error, the server <bcp14>MUST</bcp14> include in the LLQ-LEASE
field a time interval, in seconds, after which the client may retry the LLQ
Setup.
</dd>

<dt>STATIC:
</dt>
<dd>The data for this name and type is not expected to change frequently, and
the server, therefore, does not support the requested LLQ.  The client
<bcp14>MUST</bcp14> honor the resource record TTLs returned and
<bcp14>MUST NOT</bcp14> poll sooner than indicated by those TTLs,
nor should it retry the LLQ Setup for this name and type.
</dd>

<dt>BAD-VERS:
</dt>
<dd>The protocol version specified in the client's Setup Request is not
supported by
the server.
</dd>

<dt>UNKNOWN-ERR:
</dt>
<dd>The LLQ was not granted for some other reason not covered by the preceding
error code values.
</dd>

 </dl>

</li>
</ul>

<dl indent="18">
<dt>LLQ&nbhy;ID:
</dt>
<dd>On success, a random number generated by the server that is unique on the
server for the
requested name/type/class. The LLQ&nbhy;ID <bcp14>SHOULD</bcp14> be an
unpredictable random number. A possible method of allocating LLQ&nbhy;IDs with
minimal bookkeeping would be to store the time, in seconds since the Epoch, in
the high 32 bits of the field, and a cryptographically generated 32-bit random
integer in the low 32 bits.
</dd>

<dt>
</dt>
<dd>
On error, the LLQ&nbhy;ID is set to 0. 
</dd>

<dt>LLQ&nbhy;LEASE:
</dt>

<dd>On success, the actual life of the LLQ, in seconds.  Value may be greater
than, less than, or equal to the value requested by the client, as per the
server administrator's policy. The server <bcp14>MAY</bcp14> discard the LLQ
after this LLQ&nbhy;LEASE expires unless the LLQ has been renewed by the
client (see <xref target="LLQ-LLE"/>, "<xref target="LLQ-LLE"
format="title"/>").  The server <bcp14>MUST NOT</bcp14> generate events (see
<xref target="event-responses"/>, "<xref target="event-responses"
format="title"/>") for expired LLQs.
</dd>

<dt></dt>
<dd>
 On SERV&nbhy;FULL error, LLQ&nbhy;LEASE <bcp14>MUST</bcp14> be set to a time
 interval, in seconds, after which the client may retry the LLQ Setup.
</dd>
<dt>
</dt>
<dd>
On other errors, the LLQ&nbhy;LEASE <bcp14>MUST</bcp14> be set to 0.
</dd>

</dl>

</section>
        <section numbered="true" toc="default" anchor="challenge-response">
          <name>Challenge Response</name>
          <t>

   Upon issuing a Setup Request, a client listens for a Setup Challenge
   (<xref target="setup-challenge"/>) retransmitting the Setup Request as
   necessary
   (<xref target="setup-message-retransmission"/>). After
   receiving a successful Setup Challenge, the client <bcp14>SHOULD</bcp14>
   send a Challenge
   Response to the server. This Challenge Response is a DNS request
   with questions as in the Setup Request and Setup Challenge, and a single
   OPT pseudo&nbhy;RR in
   the Additional section, with the LLQ OPTIONS corresponding to the
   LLQ OPTIONS contained in the Setup Challenge (i.e., echoing, for
   each LLQ OPTION, the random LLQ&nbhy;ID and the granted LLQ&nbhy;LEASE). If
   the Challenge Response contains multiple questions, the first
   question <bcp14>MUST</bcp14> correspond to the first LLQ OPTION, etc.
          </t>
          <t>
   If the Setup Request for a particular LLQ fails with a STATIC error, the
   client <bcp14>MUST NOT</bcp14>
   poll the server for that LLQ. The client <bcp14>SHOULD</bcp14> honor the
   resource record TTLs
   contained in the response.
          </t>
          <t>
   If a Setup Request fails with a SERV&nbhy;FULL error, the client
   <bcp14>MAY</bcp14>
   retry the LLQ Setup Request (<xref target="setup-request"/>) after the time
   indicated in the
   LLQ&nbhy;LEASE field.
          </t>


          <t>
   If the Setup Request fails with an error other than STATIC or
   SERV&nbhy;FULL, or the server is determined not to support LLQ
   (i.e., the client receives a DNS response with a nonzero RCODE,
   or a DNS response containing no LLQ option), the
   client <bcp14>MAY</bcp14> poll the server periodically with standard DNS
   queries,
   inferring Add and Remove Events (see <xref target="event-responses"/>,
   "Event Responses")
   by comparing answers to these queries. The client
   <bcp14>SHOULD NOT</bcp14> poll more than once every 15 minutes for a given
   query.
   The client <bcp14>MUST NOT</bcp14> poll if it receives a STATIC error code
   in the
   acknowledgment.
          </t>
        </section>
        <section numbered="true" toc="default" anchor="ack-answers">
          <name>ACK + Answers</name>
          <t>

   Upon receiving a correct Challenge Response, a server <bcp14>MUST</bcp14>
   return an
   acknowledgment, completing the LLQ setup, and provide all current
   answers to the question(s).
          </t>
          <t>
   To acknowledge a successful Challenge Response, i.e., a Challenge
   Response in which the LLQ&nbhy;ID and LLQ&nbhy;LEASE echoed by the client
   match the values issued by the server, the server <bcp14>MUST</bcp14> send
   a DNS
   response containing all available answers to the question(s)
   contained in the original Setup Request, along with all additional
   resource records appropriate for those answers in the Additional
   section. The Additional section also contains LLQ OPTIONS formatted as
   follows:
          </t>

<table anchor="SUCCESSFUL-ACK-ANSWERS-OPT-RR-RDATA">
  <name>Successful ACK + Answers LLQ OPTION Format</name> 
  <thead>
    <tr>
      <th>Field Name</th>   
      <th>Field Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>       
    <tr>
      <td>OPTION-CODE</td>
      <td>u_int16_t</td>
      <td>LLQ (1)</td>
    </tr>
    <tr>
      <td>OPTION-LENGTH</td>
      <td>u_int16_t</td>
      <td>Length of following fields (18)</td>
    </tr>
    <tr>
      <td>LLQ-VERSION</td>
      <td>u_int16_t</td>
      <td>Version of LLQ protocol implemented in server (1)</td>
    </tr>
    <tr>
      <td>LLQ-OPCODE</td>
      <td>u_int16_t</td>
      <td>LLQ-SETUP (1)</td>
    </tr>
    <tr>
      <td>LLQ-ERROR</td>
      <td>u_int16_t</td>
      <td>NO-ERROR (0)</td>
    </tr>
    <tr>
      <td>LLQ-ID</td>
      <td>u_int64_t</td>
      <td>Originally granted ID, echoed in client's Response</td>
    </tr>
    <tr>
      <td>LLQ-LEASE</td>
      <td>u_int32_t</td>
      <td>Remaining life of LLQ, in seconds</td>
    </tr>
  </tbody>
</table>

          <t>
   If there is a significant delay in receiving a Challenge Response, or
   multiple Challenge Responses are issued (possibly because they were lost
   en route to the client, causing the client to resend the Challenge
   Response), the server <bcp14>MAY</bcp14> decrement the LLQ&nbhy;LEASE by
   the time
   elapsed since the Setup Challenge was initially issued.
          </t>
          <t>
   If the setup is completed over UDP and all initially available
   answers to the question(s), additional records, and the OPT pseudo&nbhy;RR
   do not
   fit in a single IP packet, some or all additional records (excluding the
   OPT pseudo&nbhy;RR) <bcp14>MUST</bcp14> be omitted. If, after omission of
   all additional
   records, the answers still do not fit in a single message, answers
   <bcp14>MUST</bcp14> be removed until the message fits in a single IP
   packet. These
   answers not delivered in the ACK + Answers <bcp14>MUST</bcp14> be delivered
   without undue delay to the client via Add Events (<xref
   target="event-responses"/>, "<xref
   target="event-responses" format="title"/>").
          </t>
        </section>
      </section>
      <section numbered="true" toc="default" anchor="resource-record-ttls">
        <name>Resource Record TTLs</name>
        <t>
   The TTLs of resource records contained in answers to successful LLQs
   <bcp14>SHOULD</bcp14> be ignored by the client. The client
   <bcp14>MAY</bcp14> cache LLQ answers until the client receives a gratuitous
   announcement (see <xref target="event-responses"/>, "<xref
   target="event-responses" format="title"/>")
   indicating that the answer to the LLQ has changed.  The client
   <bcp14>SHOULD NOT</bcp14> cache answers after the LLQs LLQ&nbhy;LEASE
   expires without being refreshed (see <xref target="LLQ-LLE"/>, "LLQ
   Lease-Life Expiration").  If an LLQ request fails, the client <bcp14>SHOULD
   NOT</bcp14> cache answers for a period longer than the client's polling
   interval.
        </t>
        <t>
   Note that resource records intended specifically to be transmitted
   via LLQs (e.g., DNS-based Service Discovery resource records) may have
   unusually short TTLs. This is because it is assumed that the records
   may change frequently, and that a client's cache coherence will be
   maintained via the LLQ and gratuitous responses. Short TTLs prevent
   stale information from residing in intermediate DNS recursive resolvers
   that are
   not LLQ aware.
        </t>
        <t>
   TTLs of resource records included in the Additional section of an
   LLQ response (which do not directly answer the LLQ) <bcp14>SHOULD</bcp14>
   be honored
   by the client.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default" anchor="event-responses">
      <name>Event Responses</name>
      <t>
   When a change ("event") occurs to a name server's zone, the server
   <bcp14>MUST</bcp14> check if the new or deleted resource records answer any
   LLQs.
   If so, the changes <bcp14>MUST</bcp14> be communicated to the LLQ
   requesters in
   the form of a gratuitous DNS response sent to the client, with the
   relevant question(s) in the Question section, and the corresponding answers
   in the Answer section. The response also includes
   an OPT pseudo&nbhy;RR in the Additional section. This OPT pseudo&nbhy;RR
   contains, in its
   RDATA, an LLQ OPTION for each LLQ being answered in the message. Each LLQ
   OPTION
   must include the LLQ&nbhy;ID. This reduces the potential for spoof events
   being sent to a client.
      </t>

<table anchor="EVENT-RESPONSE-OPT-RR-RDATA">
  <name>Event Response LLQ OPTION Format</name> 
  <thead>
    <tr>
      <th>Field Name</th>   
      <th>Field Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>OPTION-CODE</td>
      <td>u_int16_t</td>
      <td>LLQ (1)</td>
    </tr>
    <tr>
      <td>OPTION-LENGTH</td>
      <td>u_int16_t</td>
      <td>Length of following fields (18)</td>
    </tr>
    <tr>
      <td>LLQ-VERSION</td>
      <td>u_int16_t</td>
      <td>Version of LLQ protocol implemented in server (1)</td>
    </tr>
    <tr>
      <td>LLQ-OPCODE</td>
      <td>u_int16_t</td>
      <td>LLQ-EVENT (3)</td>
    </tr>
    <tr>
      <td>LLQ-ERROR</td>
      <td>u_int16_t</td>
      <td>NO-ERROR (0)</td>
    </tr>
    <tr>
      <td>LLQ-ID</td>
      <td>u_int64_t</td>
      <td>[As Appropriate]</td>
    </tr>
    <tr>
      <td>LLQ-LEASE</td>
      <td>u_int32_t</td>
      <td>0</td>
    </tr>

  </tbody>
</table>

      <t>
   Gratuitous responses for a single LLQ <bcp14>MAY</bcp14> be batched such
   that
   multiple changes are communicated in a single message.
   Responses <bcp14>MUST NOT</bcp14> be batched if this would cause a message
   that
   would otherwise fit in a single IP packet to be truncated. While
   responses <bcp14>MAY</bcp14> be deferred to provide opportunities for
   batching,
   responses <bcp14>SHOULD NOT</bcp14> be delayed, for purposes of batching,
   for more
   than 30 seconds, as this would cause an unacceptable latency for the
   client.
      </t>
      <t>
   After sending a gratuitous response, the server <bcp14>MUST</bcp14> listen
   for an
   acknowledgment from the client. If the client does not respond, the
   server <bcp14>MUST</bcp14> resend the response. The server
   <bcp14>MUST</bcp14> resend two times
   (for a total of 3 transmissions), after which the server
   <bcp14>MUST</bcp14>
   consider the client to be unreachable and delete its LLQ. The server
   <bcp14>MUST</bcp14> listen for 2 seconds before resending the response, 4
   more
   seconds before resending again, and must wait an additional 8
   seconds after the 3rd transmission before terminating the LLQ.
      </t>
      <t>
   The DNS message header of the response <bcp14>SHOULD</bcp14> include an
   unpredictable
   random number in the DNS message ID field, which is to be echoed in
   the client's acknowledgment.
      </t>
      <section numbered="true" toc="default">
        <name>Add Events</name>
        <t>
   Add Events occur when a new resource record appears, usually as the
   result of a dynamic update <xref target="RFC2136" format="default"/>, that
   answers an LLQ. This
   record must be sent in the Answer section of the event to the client.
   Records that normally accompany this record in responses <bcp14>MAY</bcp14>
   be
   included in the Additional section as per truncation restrictions
   described above.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Remove Events</name>
        <t>
   Remove Events occur when a resource record previously sent to a
   client, either in an initial response or in an Add Event, becomes
   invalid (normally as a result of being removed via a dynamic update).
   The deleted resource record is sent in the Answer section of the
   event to the client. The resource record TTL is set to -1,
   indicating that the record has been removed.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Gratuitous Response Acknowledgments</name>
        <t>
   Upon receiving a gratuitous response ("event"), the client
   <bcp14>MUST</bcp14> send
   an acknowledgment to the server. This acknowledgment is a DNS
   response echoing the OPT pseudo&nbhy;RR contained in the event, with the
   message
   ID of the gratuitous response echoed in the message header. The
   acknowledgment <bcp14>MUST</bcp14> be sent to the source IP address and
   port from
   which the event originated.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default" anchor="LLQ-LLE">
      <name>LLQ Lease-Life Expiration</name>

      <section numbered="true" toc="default">
        <name>Refresh Request</name>
        <t>
   If the client desires to maintain the LLQ beyond the duration specified in
   the LLQ&nbhy;LEASE field of the ACK + Answers (<xref
   target="ack-answers"/>), the client <bcp14>MUST</bcp14> send a
   Refresh Request. A Refresh Request is identical to an LLQ Challenge
   Response (<xref target="challenge-response"/>) but with the LLQ&nbhy;OPCODE
   set to
   LLQ&nbhy;REFRESH. Unlike a Challenge Response, a Refresh Request returns no
   answers.
        </t>

        <t>
   The client <bcp14>SHOULD</bcp14> refresh an LLQ when 80% of its
   LLQ&nbhy;LEASE has
   elapsed.
        </t>
        <t>
   As a means of reducing network traffic, when constructing refresh
   messages the client <bcp14>SHOULD</bcp14> include all LLQs established with
   a given
   server, even those not yet close to expiration. However, at least
   one LLQ <bcp14>MUST</bcp14> have elapsed at least 80% of its original
   LLQ&nbhy;LEASE.
   The client <bcp14>MUST NOT</bcp14> include additional LLQs if doing so
   would cause
   the message to no longer fit in a single IP packet. In this case, the
   LLQs furthest from expiration should be omitted such that the message
   fits in a single IP packet.  (These LLQs <bcp14>SHOULD</bcp14> be refreshed
   in a
   separate message when 80% of one or more of their lease lives have
   elapsed.)  When refreshing multiple LLQs simultaneously, the message
   contains multiple questions and a single OPT pseudo&nbhy;RR with multiple
   LLQ
   OPTIONS, one per question, with the LLQ OPTIONS in
   the same order as the questions they correspond to.
        </t>
        <t>
   The client <bcp14>SHOULD</bcp14> specify the original LLQ&nbhy;LEASE
   granted in the LLQ
   response as the desired LLQ&nbhy;LEASE in the Refresh Request. If
   refreshing multiple LLQs simultaneously, the client <bcp14>SHOULD</bcp14>
   request
   the same LLQ&nbhy;LEASE for all LLQs being refreshed (with the exception
   of termination requests; see below).
        </t>
        <t>
   To terminate an LLQ prior
   to its scheduled expiration (for instance, when the client terminates
   a DNS-based Service Discovery browse operation or when a client is about to go
   to sleep or shut down), the client specifies an LLQ&nbhy;LEASE value of 0.
        </t>
        <t>
   The client <bcp14>MUST</bcp14> listen for an acknowledgment from the
   server. The
   client <bcp14>MAY</bcp14> retry up to two more times (for a total of 3
   attempts)
   before considering the server down or unreachable. The client <bcp14>MUST
   NOT</bcp14> retry a first time before 90% of the LLQ&nbhy;LEASE has expired
   and
   <bcp14>MUST NOT</bcp14> retry again before 95% of the LLQ&nbhy;LEASE has
   expired. If
   the server is determined to be down, the client <bcp14>MAY</bcp14>
   periodically
   attempt to re-establish the LLQ via an LLQ Setup Request message.
   The client <bcp14>MUST NOT</bcp14> attempt the LLQ Setup Request more than
   once per
   hour.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>LLQ Refresh Acknowledgment</name>

        <t>
   Upon receiving an LLQ Refresh message, a server <bcp14>MUST</bcp14> send an
   acknowledgment of the Refresh. This acknowledgment is formatted like
   the "ACK + Answers" message described in <xref target="ack-answers"/>, but
   with the following variations:
        </t>
<ul> 
<li>    
   <t>
   It contains no answers.
        </t>
</li>
<li>     
   <t>
   The LLQ&nbhy;OPCODE is set to LLQ&nbhy;REFRESH.
        </t>
</li>
<li>     
   <t>
   NO&nbhy;SUCH&nbhy;LLQ <bcp14>MUST</bcp14> be returned as an error code if
   the client attempts
   to refresh an expired or non-existent LLQ (as determined by the
   LLQ&nbhy;ID in the request).
        </t>
</li>
<li>
        <t>
   The LLQ&nbhy;ID in the acknowledgment is set to the LLQ&nbhy;ID in the
   request.
        </t>
</li>
</ul>

  </section>
    </section>
    <section numbered="true" toc="default" anchor="security-considerations">
      <name>Security Considerations</name>
      <t>
   In datagram-based protocols
   (i.e., protocols running over UDP, or directly over IP, or similar), servers
   may be susceptible to denial-of-service (DoS) attacks, and clients
   may be subjected to packet storms. Carefully designed mechanisms are needed
   to limit potential for these attacks.
      </t>
      <t>
   Note: This section contains no new protocol elements -- it serves
   only to explain the rationale behind protocol elements described
   above as they relate to security.
      </t>
      <section numbered="true" toc="default" anchor="server-dos">
        <name>Server DoS</name>
        <t>
   LLQs require that servers be stateful, maintaining entries for each LLQ
   over a potentially long period of time. If unbounded in quantity, these
   entries may overload the server. By returning SERV&nbhy;FULL in Setup
   Challenges, the server may limit the maximum number of LLQs it
   maintains. Additionally, the server may return SERV&nbhy;FULL to limit the
   number of LLQs requested for a single name and type, or by a single
   client. This throttling may be in the form of a hard limit, or, preferably,
   by token-bucket rate limiting. Such rate limiting should occur rarely in
   normal use and is intended to prevent DoS attacks -- thus, it is not built
   into the protocol explicitly but is instead implemented at the discretion
   of an administrator via the SERV&nbhy;FULL error and the LLQ&nbhy;LEASE
   field to indicate a retry time to the client.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Client Packet Storms</name>
        <t>
   In addition to protecting the server from DoS attacks, the LLQ protocol
   limits the ability of a malicious host to cause the server to flood a
   client with packets. This is achieved via the four-way handshake
   upon setup, demonstrating reachability and willingness of the client
   to participate, and by requiring that gratuitous responses be ACK'd
   by the client.
        </t>
        <t>
   Additionally, rate limiting by LLQ client address, as described in
   <xref target="server-dos"/>, serves to limit the number of packets that can
   be delivered to
   an unsuspecting client.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Spoofing</name>
        <t>
   A large random ID greatly reduces the risk of an off-path attacker
   sending spoof packets to the client (containing spoof events)
   or to the server (containing phony requests or refreshes).
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>
  The EDNS(0) OPTION CODE 1 has already been assigned for this DNS extension.
  IANA has updated the record in the "DNS EDNS0 Option Codes (OPT)" registry
  from "On-hold" to "Optional" and has set the reference to this document.
      </t>

      <t>
  TCP and UDP ports 5352 have already been assigned for LLQ.  IANA has
  added a reference to this document.
      </t>
    </section>

  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6891.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>




<reference anchor='RFC8765' target="https://www.rfc-editor.org/info/rfc8765">
        <front>
        <title>DNS Push Notifications
	</title>
        <author initials='T' surname='Pusateri' fullname='Tom Pusateri'>
                <organization />
        </author>
        <author initials='S' surname='Cheshire' fullname='Stuart Cheshire'>
                <organization />
        </author>
        <date month='June' year='2020' />
        </front>
        <seriesInfo name='RFC' value='8765' />
        <seriesInfo name="DOI" value="10.17487/RFC8765"/>
</reference>


      </references>
      <references>
        <name>Informative References</name>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2136.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4787.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4953.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5382.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6281.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6886.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6887.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7857.xml"/>
        <xi:include
	    href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8490.xml"/>

        <reference anchor="SYN"
		   target="https://www.cisco.com/web/about/ac123/ac147/archived_issues/ipj_9-4/ipj_9-4.pdf">
          <front>
            <title>Defenses Against TCP SYN Flooding Attacks</title>
            <seriesInfo name="Volume" value="9"/>
            <seriesInfo name="Number" value="4"/>
            <seriesInfo name="The Internet Protocol Journal," value="Cisco
								     Systems"/>
            <author initials="W." surname="Eddy" fullname="Wesley Eddy">
              <organization>Verizon Federal Network Systems</organization>
              <address>
                <email>weddy@grc.nasa.gov</email>
              </address>
            </author>
            <date year="2006" month="December"/>
            <keyword>TCP</keyword>
          </front>

        </reference>



      </references>
    </references>
    <section anchor="problems" numbered="true" toc="default">
      <name>Problems with the LLQ Protocol</name>
      <t>
	In the course of using LLQ since 2005, some problems were discovered.
	Since no further work is being done on the LLQ protocol,
	this LLQ specification will not be updated to remedy these problems.
      </t>
      <t>
	LLQ's IETF Standards Track successor, "DNS Push Notifications"
	<xref target="RFC8765" format="default"></xref>, does not
	suffer from these problems, so all existing LLQ
	implementations are <bcp14>RECOMMENDED</bcp14> to migrate to
	using DNS Push Notifications, and all new implementations are
	<bcp14>RECOMMENDED</bcp14> to implement DNS Push Notifications
	instead of LLQ.
      </t>
      <t>
	Known problems with LLQ are documented here as a cautionary tale
	about the challenges of building an application protocol directly
	using datagrams (like IP or UDP) without the benefit of a
	mature and thoroughly reviewed
	intervening transport layer (such as TCP or QUIC).
      </t>
      <t>
	An LLQ "Setup Challenge" message from server to client is identical to
	an LLQ "ACK + Answers" message from server to client
	when there are no current answers for the query.
	If there is packet loss, retransmission, and duplication in the
	network,
	then a duplicated "Setup Challenge" message arriving late at the
	client
	would look like an "ACK + Answers" message with no answers,
	causing the client to clear its cache of any
	records matching the query.
      </t>
      <t>
	<xref target="setup-message-retransmission"/> of this LLQ
	specification states, "Servers <bcp14>MUST
	NOT</bcp14> garbage collect LLQs that fail to complete the
	four-way handshake until the initially granted LLQ-LEASE has
	elapsed." This is probably a mistake since it exposes LLQ
	servers to an easy resource-exhaustion denial-of-service
	attack.
	LLQ's replacement,
	DNS Push Notifications <xref target="RFC8765"
	format="default"></xref>,
	is built using DNS Stateful
	Operations <xref target="RFC8490" format="default"/>, which
	uses TLS over TCP; a benefit of building on TCP is that there
	are already established industry best practices to guard
	against SYN flooding and similar attacks <xref target="SYN"
	format="default"/> <xref target="RFC4953" format="default"/>.
      </t>
      <t>
	The attempts here to pack multiple questions into a single UDP/IP
	packet for efficiency are awkward and lead to error-prone programming
	to deal with cases where some requests in a packet succeed and other
	requests in the same packet fail.  Fully specifying the correct
	handling in all possible cases would be a lot of work to document, a
	lot of work to implement, and even more work to thoroughly test.  DNS
	Push Notifications <xref target="RFC8765" format="default"></xref>
	avoids this problem by using an underlying stream protocol (TLS/TCP)
	to deal with packing small multiple messages into larger IP packets
	for efficiency.
      </t>
      <t>
	In some cases, initial LLQ answers are delivered in the "ACK +
	Answers" message, and in other cases, such as when all the initial
	answers will not fit in a single IP packet, some of the initial
	answers are delivered in a subsequent "Add Event" message.
	Having two different ways to accomplish the same thing increases
	the possibility for programming errors.
	DNS Push Notifications <xref target="RFC8765" format="default"></xref>
	corrects this error by having only one single consistent way to
	deliver results.
      </t>
      <t>
	LLQ is built using UDP, and because UDP has no
	standardized way of indicating the start and end of a session,
	firewalls and NAT gateways tend to be fairly aggressive about
	recycling UDP mappings that they believe to be disused <xref
	target="RFC4787" format="default"/> <xref target="RFC5382"
	format="default"/> <xref target="RFC7857" format="default"/>.
	Using a high keepalive traffic rate to maintain firewall or
	NAT mapping state could remedy this but would largely defeat
	the purpose of using LLQ in the first place, which is to
	provide efficient change notification without wasteful
	polling.  Because of this, existing LLQ clients use the NAT
	Port Mapping Protocol (NAT-PMP) <xref target="RFC6886"
	format="default"></xref> and/or Port Control Protocol (PCP)
	<xref target="RFC6887" format="default"></xref> to establish
	longer port mapping lifetimes.  This solves the problem but
	adds extra complexity and doesn't work with firewalls and NAT
	gateways that don't support NAT-PMP or PCP.  By using TCP
	instead of UDP, the DNS Push Notifications protocol benefits
	from better longevity of sessions through firewalls and NAT
	gateways that don't support NAT-PMP or PCP.
      </t>
    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>
   The concepts described in this document were originally explored,
   developed,
   and implemented with help from <contact fullname="Chris Sharp"/> and
   <contact fullname="Roger Pantos"/>.
      </t>
      <t><contact fullname="Kiren Sekar"/> made significant contributions to
      the first draft of this document and he wrote much of the code for the
      implementation of LLQ that shipped in Mac OS X 10.4 Tiger in April
      2005.</t>
<t>Thanks to Independent Stream Editor <contact fullname="Adrian Farrel"/> for his support and
assistance in the publication of this RFC.
</t>

    </section>
  </back>
</rfc>
