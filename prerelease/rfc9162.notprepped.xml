<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-trans-rfc6962-bis-42" number="9162" obsoletes="6962" updates="" submissionType="IETF" category="exp" consensus="true" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 3.9.1 -->
  <front>
    <title>Certificate Transparency Version 2.0</title>
    <seriesInfo name="RFC" value="9162"/>
    <author initials="B." surname="Laurie" fullname="Ben Laurie">
      <organization abbrev="Google">Google UK Ltd.</organization>
      <address>
        <email>benl@google.com</email>
      </address>
    </author>
    <author initials="E." surname="Messeri" fullname="Eran Messeri">
      <organization abbrev="Google">Google UK Ltd.</organization>
      <address>
        <email>eranm@google.com</email>
      </address>
    </author>
    <author initials="R." surname="Stradling" fullname="Rob Stradling">
      <organization abbrev="Sectigo">Sectigo Ltd.</organization>
      <address>
        <email>rob@sectigo.com</email>
      </address>
    </author>
    <date year="2021" month="December"/>
    <area>Security</area>
    <workgroup>TRANS (Public Notary Transparency)</workgroup>
    <keyword>certificates</keyword>
    <keyword>pkix</keyword>
    <keyword>tls</keyword>
    <keyword>website</keyword>
    <keyword>webpki</keyword>
    <keyword>browsers</keyword>
    <abstract>
      <t>This document describes version 2.0 of the Certificate Transparency (CT)
protocol for publicly logging the existence of Transport Layer Security (TLS)
server certificates as they are issued or observed, in a manner that allows
anyone to audit certification authority (CA) activity and notice the issuance of
suspect certificates as well as to audit the certificate logs themselves. The
intent is that eventually clients would refuse to honor certificates that do not
appear in a log, effectively forcing CAs to add all issued certificates to the
logs.</t>
      <t>This document obsoletes RFC 6962.  It also specifies a new TLS extension that is
used to send various CT log artifacts.</t>
      <t>Logs are network services that implement the protocol operations for submissions
and queries that are defined in this document.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Certificate Transparency aims to mitigate the problem of misissued certificates
by providing append-only logs of issued certificates. The logs do not themselves
prevent misissuance, but they ensure that interested parties (particularly those
named in certificates) can detect such misissuance. Note that this is a general
mechanism that could be used for transparently logging any form of binary data,
subject to some kind of inclusion criteria. In this document, we only describe
its use for public TLS server certificates (i.e., where the inclusion criteria
is a valid certificate issued by a public certification authority (CA)).
A typical definition of "public" can be found in <xref target="CABBR" format="default"/>.</t>
      <t>Each log contains certificate chains, which can be submitted by anyone. It is
expected that public CAs will contribute all their newly issued certificates to
one or more logs; however, certificate holders can also contribute their own
certificate chains, as can third parties. In order to avoid logs being rendered
useless by the submission of large numbers of spurious certificates, it is
required that each chain ends with a trust anchor that is accepted by the log.
A log may also limit the length of the chain it is willing to accept;
such chains must also end with an acceptable trust anchor.
When a chain is accepted by a log, a signed timestamp is returned, which can
later be used to provide evidence to TLS clients that the chain has been
submitted. TLS clients can thus require that all certificates they accept as
valid are accompanied by signed timestamps.</t>
      <t>Those who are concerned about misissuance can monitor the logs, asking them
regularly for all new entries, and can thus check whether domains for which they
are responsible have had certificates issued that they did not expect. What
they do with this information, particularly when they find that a misissuance
has happened, is beyond the scope of this document. However, broadly speaking,
they can invoke existing business mechanisms for dealing with misissued
certificates, such as working with the CA to get the certificate revoked or
with maintainers of trust anchor lists to get the CA removed. Of course, anyone
who wants can monitor the logs and, if they believe a certificate is incorrectly
issued, take action as they see fit.</t>
      <t>Similarly, those who have seen signed timestamps from a particular log can later
demand a proof of inclusion from that log. If the log is unable to provide this
(or, indeed, if the corresponding certificate is absent from monitors' copies of
that log), that is evidence of the incorrect operation of the log. The checking
operation is asynchronous to allow clients to proceed without delay, despite
possible issues, such as network connectivity and the vagaries of firewalls.</t>
      <t>The append-only property of each log is achieved using Merkle Trees, which can
be used to efficiently prove that any particular instance of the log is a
superset of any particular previous instance and to efficiently detect various
misbehaviors of the log (e.g., issuing a signed timestamp for a certificate that
is not subsequently logged).</t>
      <t>The log auditing mechanisms described in this document can
be circumvented by a misbehaving log that shows different, inconsistent
views of itself to different clients. Therefore, it is necessary to treat each log 
as a trusted third party. While mechanisms are being developed to address these
shortcomings and thereby avoid the need to blindly trust logs,
such mechanisms are outside the scope of this document.</t>
      <section anchor="requirements-language" numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section anchor="data_structures" numbered="true" toc="default">
        <name>Data Structures</name>
        <t>Data structures are defined and encoded according to the conventions laid out
	in <xref target="RFC8446" sectionFormat="of" section="3"/>.</t>
        <t>This document uses object identifiers (OIDs) to identify Log IDs (see
	<xref target="log_id" format="default"/>), the precertificate Cryptographic Message
	Syntax (CMS) <tt>eContentType</tt> (see <xref target="precertificates"
	format="default"/>), X.509v3 extensions in certificates (see <xref
	target="cert_transinfo_extension" format="default"/>), and
	Online Certificate Status Protocol (OCSP) responses (see <xref
	target="ocsp_transinfo_extension" format="default"/>). The OIDs are defined in an
	arc that was selected due to its short encoding.</t>
      </section>
      <section anchor="major-differences-from-ct-10" numbered="true" toc="default">
        <name>Major Differences from CT 1.0</name>
        <t>This document revises and obsoletes the CT 1.0 protocol <xref target="RFC6962"
	format="default"/>, drawing on
	insights gained from CT 1.0 deployments and on feedback from the community. The
	major changes are:</t>
        <ul spacing="normal">
          <li>Hash and signature algorithm agility: Permitted algorithms are now specified
	  in IANA registries.</li>
          <li>Precertificate format: Precertificates are now CMS objects rather than X.509
	  certificates, which avoids violating the certificate serial number uniqueness
	  requirement in <xref target="RFC5280" sectionFormat="of" section="4.1.2.2"/>.</li>
          <li>Removal of precertificate signing certificates and the precertificate poison
	  extension: The change of precertificate format means that these are no longer
	  needed.</li>
          <li>Logs IDs: Each log is now identified by an OID rather than by the hash of its
	  public key. OID allocations are available from an IANA registry.</li>
          <li><tt>TransItem</tt> structure: This new data structure is used to encapsulate
	  most types of CT data. A <tt>TransItemList</tt>, consisting of one or more
	  <tt>TransItem</tt> structures, can be used anywhere that
	  <tt>SignedCertificateTimestampList</tt> was
	  used in <xref target="RFC6962" format="default"/>.</li>
          <li>Merkle Tree leaves: The <tt>MerkleTreeLeaf</tt> structure has been replaced by
	  the <tt>TransItem</tt> structure, which eases extensibility and simplifies the leaf
	  structure by removing one layer of abstraction.</li>
          <li>Unified leaf format: The structure for both certificate and precertificate
	  entries now includes only the TBSCertificate (whereas certificate entries in
	  <xref target="RFC6962" format="default"/> included the entire certificate).</li>
          <li>Log artifact extensions: These are now typed and managed by an IANA registry,
	  and they can now appear not only in Signed Certificate Timestamps (SCTs) but also
	  in Signed Tree Heads (STHs).</li>
          <li>API outputs: Complete <tt>TransItem</tt> structures are returned rather than
	  the constituent parts of each structure.</li>
          <li><tt>get-all-by-hash</tt>: This is a new client API for obtaining an inclusion proof and
	  the corresponding consistency proof at the same time.</li>
          <li><tt>submit-entry</tt>: This is a new client API, replacing <tt>add-chain</tt> and
	  <tt>add-pre-chain</tt>.</li>
          <li>Presenting SCTs with proofs: TLS servers may present SCTs together with the
	  corresponding inclusion proofs, using any of the mechanisms that <xref
	  target="RFC6962" format="default"/>
	  defined for presenting SCTs only. (Presenting SCTs only is still supported).</li>
          <li>CT TLS extension: The <tt>signed_certificate_timestamp</tt> TLS extension has
	  been replaced by the <tt>transparency_info</tt> TLS extension.</li>
          <li>Verification algorithms: Detailed algorithms for verifying inclusion
	  proofs, for verifying consistency between two STHs, and for verifying a root
	  hash given a complete list of the relevant leaf input entries have been added.</li>
          <li>Extensive clarifications and editorial work.</li>
        </ul>
      </section>
    </section>
    <section anchor="cryptographic-components" numbered="true" toc="default">
      <name>Cryptographic Components</name>
      <section anchor="mht" numbered="true" toc="default">
        <name>Merkle Trees</name>
        <t>A full description of the Merkle Tree is beyond the scope of this
	document. Briefly, it is a binary tree where each non-leaf node is a
	hash of its children. For CT, the number of children is at most two.
	Additional information can be found in the Introduction and Reference
	sections of <xref target="RFC8391" format="default"/>.</t>
        <section anchor="mht_definition" numbered="true" toc="default">
          <name>Definition of the Merkle Tree</name>
          <t>The log uses a binary Merkle Tree for efficient auditing. The hash
	  algorithm used is one of the log's parameters (see <xref target="log_parameters"
	  format="default"/>). This document establishes a registry of acceptable hash
	  algorithms (see <xref target="hash_algorithms" format="default"/>). Throughout this
	  document, the hash algorithm in use is referred to as HASH and the size of its
	  output in bytes is referred to as HASH_SIZE. The input
	  to the Merkle Tree Hash is a list of data entries; these entries will be
	  hashed to form the leaves of the Merkle Tree. The output is a single
	  HASH_SIZE Merkle Tree Hash. Given an ordered list of n inputs, D_n =
	  {d[0], d[1], ..., d[n-1]}, the Merkle Tree Hash (MTH) is thus defined as
	  follows:</t>
          <t>The hash of an empty list is the hash of an empty string:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
MTH({}) = HASH().
]]></artwork>
          <t>The hash of a list with one entry (also known as a leaf hash) is:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
MTH({d[0]}) = HASH(0x00 || d[0]).
]]></artwork>
          <t>For n &gt; 1, let k be the largest power of two smaller than n
	  (i.e., k &lt; n &lt;= 2k).
	  The Merkle Tree Hash of an n-element list D_n is then defined recursively as:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
MTH(D_n) = HASH(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
]]></artwork>
          <t>where:</t>
          <ul spacing="normal">
            <li>|| denotes concatenation</li>
            <li>: denotes concatenation of lists</li>
            <li>D[k1:k2] = D'_(k2-k1) denotes the list {d'[0] = d[k1], d'[1] = d[k1+1],
	    ..., d'[k2-k1-1] = d[k2-1]} of length (k2 - k1).</li>
          </ul>
          <t>Note that the hash calculations for leaves and nodes differ; this domain
separation is required to give second preimage resistance.</t>
          <t>Note that we do not require the length of the input list to be a power of two.
The resulting Merkle Tree may thus not be balanced; however, its shape is
uniquely determined by the number of leaves. (Note: This Merkle Tree is
essentially the same as the history tree proposed by <xref target="CrosbyWallach" format="default"/>, except our
definition handles non-full trees differently.)</t>
        </section>
        <section anchor="verify_hash" numbered="true" toc="default">
          <name>Verifying a Tree Head Given Entries</name>
          <t>When a client has a complete list of <tt>entries</tt> from <tt>0</tt> up to
<tt>tree_size - 1</tt> and wishes to verify this list against a tree head <tt>root_hash</tt>
returned by the log for the same <tt>tree_size</tt>, the following algorithm may be
used:</t>
          <ol spacing="normal" type="1">
	    <li>Set <tt>stack</tt> to an empty stack.</li>
            <li>
              <t>For each <tt>i</tt> from <tt>0</tt> up to <tt>tree_size - 1</tt>:</t>
              <ol spacing="normal" type="a">
		<li>Push <tt>HASH(0x00 || entries[i])</tt> to <tt>stack</tt>.</li>
                <li>Set <tt>merge_count</tt> to the lowest value (<tt>0</tt> included)
		such that <tt>LSB(i &gt;&gt; merge_count)</tt> is not set, where
		<tt>LSB</tt> means the least significant
		bit. In other words, set <tt>merge_count</tt> to the number
		of consecutive <tt>1</tt>s found starting at the least significant bit of
		<tt>i</tt>.</li>
                <li>
                  <t>Repeat <tt>merge_count</tt> times:</t>
                  <ol spacing="normal" type="i">
		    <li>Pop <tt>right</tt> from <tt>stack</tt>.</li>
                    <li>Pop <tt>left</tt> from <tt>stack</tt>.</li>
                    <li>Push <tt>HASH(0x01 || left || right)</tt> to <tt>stack</tt>.</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>If there is more than one element in the <tt>stack</tt>, repeat the same merge
procedure (the sub-items of Step 2(c) above) until only a single element
remains.</li>
            <li>The remaining element in <tt>stack</tt> is the Merkle Tree Hash for the given
<tt>tree_size</tt> and should be compared by equality against the supplied
<tt>root_hash</tt>.</li>
          </ol>
        </section>
        <section anchor="merkle_inclusion_proof" numbered="true" toc="default">
          <name>Merkle Inclusion Proofs</name>
          <t>A Merkle inclusion proof for a leaf in a Merkle Tree is the shortest list
of additional nodes in the Merkle Tree required to compute the Merkle Tree Hash
for that tree. Each node in the tree is either a leaf node or is computed from
the two nodes immediately below it (i.e., towards the leaves). At each step up
the tree (towards the root), a node from the inclusion proof is combined with
the node computed so far. In other words, the inclusion proof consists of the
list of missing nodes required to compute the nodes leading from a leaf to the
root of the tree. If the root computed from the inclusion proof matches the true
root, then the inclusion proof proves that the leaf exists in the tree.</t>
          <section anchor="generating-an-inclusion-proof" numbered="true" toc="default">
            <name>Generating an Inclusion Proof</name>
            <t>Given an ordered list of n inputs to the tree, D_n = {d[0], d[1], ...,
d[n-1]}, the Merkle inclusion proof PATH(m, D_n) for the (m+1)th input d[m],
0 &lt;= m &lt; n, is defined as follows:</t>
            <t>The proof for the single leaf in a tree with a one-element input list D[1] =
{d[0]} is empty:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
PATH(0, {d[0]}) = {}
]]></artwork>
            <t>For n &gt; 1, let k be the largest power of two smaller than n. The proof for the
(m+1)th element d[m] in a list of n &gt; m elements is then defined recursively as:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
PATH(m, D_n) = PATH(m, D[0:k]) : MTH(D[k:n]) for m < k; and

PATH(m, D_n) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m >= k,
]]></artwork>
            <t>The : operator and D[k1:k2] are defined the same as in <xref target="mht_definition" format="default"/>.</t>
          </section>
          <section anchor="verify_inclusion" numbered="true" toc="default">
            <name>Verifying an Inclusion Proof</name>
            <t>When a client has received an inclusion proof (e.g., in a <tt>TransItem</tt> of type
<tt>inclusion_proof_v2</tt>) and wishes to verify inclusion of an input <tt>hash</tt> for a
given <tt>tree_size</tt> and <tt>root_hash</tt>, the following algorithm may be used to prove
the <tt>hash</tt> was included in the <tt>root_hash</tt>:</t>
            <ol spacing="normal" type="1">
	      <li>Compare <tt>leaf_index</tt> from the <tt>inclusion_proof_v2</tt> structure
	      against <tt>tree_size</tt>. If <tt>leaf_index</tt> is greater than or
	      equal to <tt>tree_size</tt>, then fail the proof verification.</li>
              <li>Set <tt>fn</tt> to <tt>leaf_index</tt> and <tt>sn</tt> to <tt>tree_size -
	      1</tt>.</li>
              <li>Set <tt>r</tt> to <tt>hash</tt>.</li>
              <li>
                <t>For each value <tt>p</tt> in the <tt>inclusion_path</tt> array:</t>
                <ol spacing="normal" type="a">
                  <li>If <tt>sn</tt> is 0, then stop the iteration and fail the proof verification.</li>
                  <li>
                    <t>If <tt>LSB(fn)</tt> is set, or if <tt>fn</tt> is equal to <tt>sn</tt>, then:</t>
                    <ol spacing="normal" type="i">
                      <li>Set <tt>r</tt> to <tt>HASH(0x01 || p || r)</tt>.</li>
                      <li>If <tt>LSB(fn)</tt> is not set, then right-shift both <tt>fn</tt> and
                        <tt>sn</tt> equally until either <tt>LSB(fn)</tt> is set or <tt>fn</tt> is <tt>0</tt>.</li>
                    </ol>
                    <t>Otherwise:</t>
                    <ol spacing="normal" type="i">
                      <li>Set <tt>r</tt> to <tt>HASH(0x01 || r || p)</tt>.</li>
                    </ol>
                  </li>
                  <li>Finally, right-shift both <tt>fn</tt> and <tt>sn</tt> one time.</li>
                </ol>
              </li>
              <li>Compare <tt>sn</tt> to 0. Compare <tt>r</tt> against the
	      <tt>root_hash</tt>. If <tt>sn</tt> is equal to
	      0 and <tt>r</tt> and the <tt>root_hash</tt> are equal, then the log has proven
	      the inclusion of <tt>hash</tt>. Otherwise, fail the proof verification.</li>
            </ol>
          </section>
        </section>
        <section anchor="consistency" numbered="true" toc="default">
          <name>Merkle Consistency Proofs</name>
          <t>Merkle consistency proofs prove the append-only property of the tree. A Merkle
consistency proof for a Merkle Tree Hash MTH(D_n) and a previously advertised
hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the
Merkle Tree required to verify that the first m inputs D[0:m] are equal in both
trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e.,
commitments to inputs) sufficient to verify MTH(D_n), such that (a subset of)
the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that
outputs the (unique) minimal consistency proof.</t>
          <section anchor="generating-a-consistency-proof" numbered="true" toc="default">
            <name>Generating a Consistency Proof</name>
            <t>Given an ordered list of n inputs to the tree, D_n = {d[0], d[1], ...,
d[n-1]}, the Merkle consistency proof PROOF(m, D_n) for a previous Merkle Tree
Hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as:</t>
            <artwork name="" type="" align="left" alt=""><![CDATA[
PROOF(m, D_n) = SUBPROOF(m, D_n, true)
]]></artwork>
            <t>In SUBPROOF, the boolean value represents whether the subtree created from
	    D[0:m] is a complete subtree of the Merkle Tree created from D_n and,
	    consequently, whether the subtree Merkle Tree Hash MTH(D[0:m]) is known. The
	    initial call to SUBPROOF sets this to be true, and SUBPROOF is then defined as
	    follows:</t>
	    <t>The subproof for m = n is empty if m is the value for which PROOF was
	    originally requested (meaning that the subtree created from D[0:m] is a complete
	    subtree of the Merkle Tree created from the original D_n for which PROOF was
	    requested and the subtree Merkle Tree Hash MTH(D[0:m]) is known):</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
SUBPROOF(m, D_m, true) = {}
]]></artwork>
            <t>Otherwise, the subproof for m = n is the Merkle Tree Hash committing inputs
	    D[0:m]:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
SUBPROOF(m, D_m, false) = {MTH(D_m)}
]]></artwork>
            <t>For m &lt; n, let k be the largest power of two smaller than n. The subproof is
	    then defined recursively, using the appropriate step below:</t>
            <t>If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree.
	    We prove that the left subtree entries D[0:k] are consistent and add a
	    commitment to D[k:n]:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
SUBPROOF(m, D_n, b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])
]]></artwork>
             <t>If m &gt; k, the left subtree entries D[0:k] are identical in both trees. We
	     prove that the right subtree entries D[k:n] are consistent and add a commitment
	     to D[0:k]:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
SUBPROOF(m, D_n, b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])
]]></artwork>
            <t>The number of nodes in the resulting proof is bounded above by ceil(log2(n)) +
1.</t>
            <t>The : operator and D[k1:k2] are defined the same as in <xref target="mht_definition" format="default"/>.</t>
          </section>
          <section anchor="verify_consistency" numbered="true" toc="default">
            <name>Verifying Consistency between Two Tree Heads</name>
            <t>When a client has a tree head <tt>first_hash</tt> for tree size
	    <tt>first</tt>, has a tree head
	    <tt>second_hash</tt> for tree size <tt>second</tt> where <tt>0 &lt; first &lt;
	    second</tt>, and has received a consistency proof between the two (e.g., in a
	    <tt>TransItem</tt> of type
	    <tt>consistency_proof_v2</tt>), the following algorithm may be used to verify the
	    consistency proof:</t>
            <ol spacing="normal" type="1">
	      <li>If <tt>consistency_path</tt> is an empty array, stop and fail the proof
	      verification.</li>
              <li>If <tt>first</tt> is an exact power of 2, then prepend <tt>first_hash</tt>
	      to the <tt>consistency_path</tt> array.</li>
              <li>Set <tt>fn</tt> to <tt>first - 1</tt> and <tt>sn</tt> to <tt>second -
	      1</tt>.</li>
              <li>If <tt>LSB(fn)</tt> is set, then right-shift both <tt>fn</tt> and
	      <tt>sn</tt> equally until <tt>LSB(fn)</tt> is not set.</li>
              <li>Set both <tt>fr</tt> and <tt>sr</tt> to the first value in the
	      <tt>consistency_path</tt> array.</li>
              <li>
                <t>For each subsequent value <tt>c</tt> in the <tt>consistency_path</tt> array:</t>
                <ol spacing="normal" type="a">
                  <li>If <tt>sn</tt> is 0, then stop the iteration and fail the proof verification.</li>
                  <li>
                    <t>If <tt>LSB(fn)</tt> is set, or if <tt>fn</tt> is equal to <tt>sn</tt>, then:</t>
                    <ol spacing="normal" type="i">
                      <li>Set <tt>fr</tt> to <tt>HASH(0x01 || c || fr)</tt>.</li>
                      <li>Set <tt>sr</tt> to <tt>HASH(0x01 || c || sr)</tt>.</li>
                      <li>If <tt>LSB(fn)</tt> is not set, then right-shift both <tt>fn</tt> and <tt>sn</tt>
                        equally until either <tt>LSB(fn)</tt> is set or <tt>fn</tt> is <tt>0</tt>.</li>
                    </ol>
                    <t>Otherwise:</t>
                    <ol spacing="normal" type="i">
                      <li>Set <tt>sr</tt> to <tt>HASH(0x01 || sr || c)</tt>.</li>
                    </ol>
                  </li>
                  <li>Finally, right-shift both <tt>fn</tt> and <tt>sn</tt> one time.</li>
                </ol>
              </li>
              <li>After completing iterating through the <tt>consistency_path</tt> array as
	      described above, verify that the <tt>fr</tt> calculated is equal to the
	      <tt>first_hash</tt> supplied, that the <tt>sr</tt> calculated is equal to the
	      <tt>second_hash</tt> supplied, and that <tt>sn</tt> is 0.</li>
            </ol>
          </section>
        </section>
        <section anchor="example" numbered="true" toc="default">
          <name>Example</name>
          <t>The following is a binary Merkle Tree with 7 leaves:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \
   /     \        /     \
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6
 | |     | |    | |
d0 d1   d2 d3  d4 d5
]]></artwork>
          <t>The inclusion proof for <tt>d0</tt> is [<tt>b</tt>, <tt>h</tt>, <tt>l</tt>].</t>
          <t>The inclusion proof for <tt>d3</tt> is [<tt>c</tt>, <tt>g</tt>, <tt>l</tt>].</t>
          <t>The inclusion proof for <tt>d4</tt> is [<tt>f</tt>, <tt>j</tt>, <tt>k</tt>].</t>
          <t>The inclusion proof for <tt>d6</tt> is [<tt>i</tt>, <tt>k</tt>].</t>
          <t>The same tree, built incrementally in four steps:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    hash0          hash1=k
    / \              /  \
   /   \            /    \
  /     \          /      \
  g      c         g       h
 / \     |        / \     / \
 a b     d2       a b     c d
 | |              | |     | |
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6
| |     | |             | |     | |    | |
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5
]]></artwork>
          <t>The consistency proof between <tt>hash0</tt> and <tt>hash</tt> is PROOF(3, D[7]) = [<tt>c</tt>, <tt>d</tt>, <tt>g</tt>, <tt>l</tt>].
Non-leaf nodes <tt>c</tt>, <tt>g</tt> are used to verify <tt>hash0</tt>, and non-leaf nodes <tt>d</tt>, <tt>l</tt> are additionally used to show <tt>hash</tt> is
consistent with <tt>hash0</tt>.</t>
          <t>The consistency proof between <tt>hash1</tt> and <tt>hash</tt> is PROOF(4, D[7]) = [<tt>l</tt>]. <tt>hash</tt> can
be verified using <tt>hash1</tt>=<tt>k</tt> and <tt>l</tt>.</t>
          <t>The consistency proof between <tt>hash2</tt> and <tt>hash</tt> is PROOF(6, D[7]) = [<tt>i</tt>, <tt>j</tt>, <tt>k</tt>].
Non-leaf nodes <tt>k</tt>, <tt>i</tt> are used to verify <tt>hash2</tt>, and non-leaf node <tt>j</tt> is additionally used to show <tt>hash</tt> is
consistent with <tt>hash2</tt>.</t>
        </section>
      </section>
      <section anchor="signatures" numbered="true" toc="default">
        <name>Signatures</name>
        <t>When signing data structures, a log <bcp14>MUST</bcp14> use one of
the signature algorithms from the IANA "Signature Algorithms" registry,
described in <xref target="signature_algorithms" format="default"/>.</t>
      </section>
    </section>
    <section anchor="submitters" numbered="true" toc="default">
      <name>Submitters</name>
      <t>Submitters submit certificates or preannouncements of certificates prior to
issuance (precertificates) to logs for public auditing, as described below. In
order to enable attribution of each logged certificate or precertificate to its
issuer, each submission <bcp14>MUST</bcp14> be accompanied by all additional certificates
required to verify the chain up to an accepted trust anchor (<xref target="get-anchors" format="default"/>).
The trust anchor (a root or intermediate CA certificate) <bcp14>MAY</bcp14> be omitted from the
submission.</t>
      <t>If a log accepts a submission, it will return a Signed Certificate Timestamp
(SCT) (see <xref target="sct" format="default"/>). The submitter <bcp14>SHOULD</bcp14> validate the returned SCT, as described
in <xref target="tls_clients" format="default"/>, if they understand its format and they intend to use it
directly in a TLS handshake or to construct a certificate. If the submitter does
not need the SCT (for example, the certificate is being submitted simply to make
it available in the log), it <bcp14>MAY</bcp14> validate the SCT.</t>
      <section anchor="certificates" numbered="true" toc="default">
        <name>Certificates</name>
        <t>Any entity can submit a certificate (<xref target="submit-entry" format="default"/>) to a log. Since it is
anticipated that TLS clients will reject certificates that are not logged, it is
expected that certificate issuers and subjects will be strongly motivated to
submit them.</t>
      </section>
      <section anchor="precertificates" numbered="true" toc="default">
        <name>Precertificates</name>
        <t>CAs may preannounce a certificate prior to issuance by submitting a
precertificate (<xref target="submit-entry" format="default"/>) that the log can use to create an entry that
will be valid against the issued certificate. The CA <bcp14>MAY</bcp14> incorporate the
returned SCT in the issued certificate. One example of where the returned SCT is
not incorporated in the issued certificate is when a CA sends the precertificate
to multiple logs but only incorporates the SCTs that are returned first.</t>
        <t>A precertificate is a CMS <xref target="RFC5652" format="default"/> <tt>signed-data</tt> object that conforms to the
following profile:</t>
        <ul spacing="normal">
          <li>It <bcp14>MUST</bcp14> be DER encoded, as described in <xref target="X690"
	  format="default"/>.</li>
          <li><tt>SignedData.version</tt> <bcp14>MUST</bcp14> be v3(3).</li>
          <li><tt>SignedData.digestAlgorithms</tt> <bcp14>MUST</bcp14> be the same as the
	  <tt>SignerInfo.digestAlgorithm</tt> OID value (see below).</li>
          <li>
	    <t><tt>SignedData.encapContentInfo</tt>:</t>
            <ul spacing="normal">
              <li><tt>eContentType</tt> <bcp14>MUST</bcp14> be the OID 1.3.101.78.</li>
              <li><tt>eContent</tt> <bcp14>MUST</bcp14> contain a TBSCertificate <xref
	      target="RFC5280" format="default"/> that will be identical to
	      the TBSCertificate in the issued certificate, except that the Transparency
	      Information (<xref target="x509v3_transinfo_extension" format="default"/>)
	      extension <bcp14>MUST</bcp14> be omitted.</li>
            </ul>
          </li>
          <li><tt>SignedData.certificates</tt> <bcp14>MUST</bcp14> be omitted.</li>
          <li><tt>SignedData.crls</tt> <bcp14>MUST</bcp14> be omitted.</li>
          <li><t><tt>SignedData.signerInfos</tt> <bcp14>MUST</bcp14> contain one
	  <tt>SignerInfo</tt>:</t>
            <ul spacing="normal">
              <li><tt>version</tt> <bcp14>MUST</bcp14> be v3(3).</li>
              <li><tt>sid</tt> <bcp14>MUST</bcp14> use the <tt>subjectKeyIdentifier</tt>
	      option.</li>
              <li><tt>digestAlgorithm</tt> <bcp14>MUST</bcp14> be one of the hash algorithm
	      OIDs listed in the IANA "Hash Algorithms" registry, described in
	      <xref target="hash_algorithms" format="default"/>.</li>
              <li>
		<t><tt>signedAttrs</tt> <bcp14>MUST</bcp14> be present and
		<bcp14>MUST</bcp14> contain two attributes:</t>
                <ul spacing="normal">
                  <li>a content-type attribute whose value is the same as
		  <tt>SignedData.encapContentInfo.eContentType</tt> and</li>
                  <li>a message-digest attribute whose value is the message digest of
		  <tt>SignedData.encapContentInfo.eContent</tt>.</li>
                </ul>
              </li>
              <li><tt>signatureAlgorithm</tt> <bcp14>MUST</bcp14> be the same OID as
	      <tt>TBSCertificate.signature</tt>.</li>
              <li><tt>signature</tt> <bcp14>MUST</bcp14> be from the same (root or
	      intermediate) CA that intends to
	      issue the corresponding certificate (see <xref target="binding_intent_to_issue"
	      format="default"/>).</li>
              <li><tt>unsignedAttrs</tt> <bcp14>MUST</bcp14> be omitted.</li>
            </ul>
          </li>
        </ul>
        <t><tt>SignerInfo.signedAttrs</tt> is included in the message digest calculation process
(see <xref target="RFC5652" sectionFormat="of" section="5.4"/>), which ensures that the <tt>SignerInfo.signature</tt>
value will not be a valid X.509v3 signature that could be used in conjunction
with the TBSCertificate (from <tt>SignedData.encapContentInfo.eContent</tt>) to
construct a valid certificate.</t>
        <section anchor="binding_intent_to_issue" numbered="true" toc="default">
          <name>Binding Intent to Issue</name>
          <t>Under normal circumstances, there will be a short delay between precertificate
submission and issuance of the corresponding certificate. Longer delays are to
be expected occasionally (e.g., due to log server downtime); in some cases,
the CA might not actually issue the corresponding certificate. Nevertheless, a
precertificate's <tt>signature</tt> indicates the CA's binding intent to issue the
corresponding certificate, which means that:</t>
          <ul spacing="normal">
            <li>Misissuance of a precertificate is considered equivalent to misissuance of
	    the corresponding certificate. The CA should expect to be held accountable,
	    even if the corresponding certificate has not actually been issued.</li>
            <li>Upon observing a precertificate, a client can reasonably presume that the
	    corresponding certificate has been issued. A client may wish to obtain status
	    information (e.g., by using the Online Certificate Status Protocol <xref
	    target="RFC6960" format="default"/>
	    or by checking a Certificate Revocation List <xref target="RFC5280"
	    format="default"/>) about a certificate
	    that is presumed to exist, especially if there is evidence or suspicion that
	    the corresponding precertificate was misissued.</li>
            <li>TLS clients may have policies that require CAs to be able to revoke and to
	    provide certificate status services for each certificate that is presumed to
	    exist based on the existence of a corresponding precertificate.</li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="log-format-and-operation" numbered="true" toc="default">
      <name>Log Format and Operation</name>
      <t>A log is a single, append-only Merkle Tree of submitted certificate and
precertificate entries.</t>
      <t>When it receives and accepts a valid submission, the log <bcp14>MUST</bcp14> return an SCT that
corresponds to the submitted certificate or precertificate. If the log has
previously seen this valid submission, it <bcp14>SHOULD</bcp14> return the same SCT as it
returned before, as discussed in <xref target="misbehaving_logs" format="default"/>.
If different SCTs are produced for the same
submission, multiple log entries will have to be created, one for each SCT (as
the timestamp is a part of the leaf structure). Note that if a certificate was
previously logged as a precertificate, then the precertificate's SCT of type
<tt>precert_sct_v2</tt> would not be appropriate; instead, a fresh SCT of type
<tt>x509_sct_v2</tt> should be generated.</t>
      <t>An SCT is the log's promise to append to its Merkle Tree an entry for the
      accepted submission. Upon producing an SCT, the log <bcp14>MUST</bcp14> fulfill this
      promise by performing the following actions within a fixed amount of time known as the
      Maximum Merge Delay (MMD), which is one of the log's parameters (see
      <xref target="log_parameters" format="default"/>):</t>
      <ul spacing="normal">
        <li>Allocate a tree index to the entry representing the accepted submission.</li>
        <li>Calculate the root of the tree.</li>
        <li>Sign the root of the tree (see <xref target="sth" format="default"/>).</li>
      </ul>
      <t>The log may append multiple entries before signing the root of the tree.</t>
      <t>Log operators <bcp14>SHOULD NOT</bcp14> impose any conditions on retrieving or sharing data
from the log.</t>
      <section anchor="log_parameters" numbered="true" toc="default">
        <name>Log Parameters</name>
        <t>A log is defined by a collection of immutable parameters, which are used by
clients to communicate with the log and to verify log artifacts. Except for the
Final STH, each of these parameters <bcp14>MUST</bcp14> be established
before the log operator begins to operate the log.</t>
        <dl newline="false" spacing="normal">
          <dt>Base URL:</dt>
          <dd>The prefix used to construct URLs <xref target="RFC3986" format="default"/>
	  for client messages (see <xref target="client_messages" format="default"/>). The
	  base URL <bcp14>MUST</bcp14> be an "https" URL, <bcp14>MAY</bcp14> contain a port,
	  and <bcp14>MAY</bcp14> contain a path with any number of path segments but
	  <bcp14>MUST NOT</bcp14> contain a query string, fragment, or trailing "/".
	  Example: https://ct.example.org/blue.</dd>
          <dt>Hash Algorithm:</dt>
          <dd>The hash algorithm used for the Merkle Tree (see <xref target="hash_algorithms"
	  format="default"/>).</dd>
          <dt>Signature Algorithm:</dt>
          <dd>The signature algorithm used (see <xref target="signatures"
	  format="default"/>).</dd>
          <dt>Public Key:</dt>
          <dd>The public key used to verify signatures generated by the log. A log
	  <bcp14>MUST NOT</bcp14> use the same keypair as any other log.</dd>
          <dt>Log ID:</dt>
          <dd>The OID that uniquely identifies the log.</dd>
          <dt>Maximum Merge Delay:</dt>
          <dd>The MMD the log has committed to. This document deliberately does not specify
	  any limits on the value to allow for experimentation.</dd>
          <dt>Version:</dt>
          <dd>The version of the protocol supported by the log (currently 1 or 2).</dd>
          <dt>Maximum Chain Length:</dt>
          <dd>The longest certificate chain submission the log is willing to accept, if the
	  log imposes any limit.</dd>
          <dt>STH Frequency Count:</dt>
          <dd>The maximum number of STHs the log may produce in any period equal to the
	  <tt>Maximum Merge Delay</tt> (see <xref target="sth" format="default"/>).</dd>
          <dt>Final STH:</dt>
          <dd>If a log has been closed down (i.e., no longer accepts new entries), existing
	  entries may still be valid. In this case, the client should know the final
	  valid STH in the log to ensure no new entries can be added without detection.
	  This value <bcp14>MUST</bcp14> be provided in the form of a <tt>TransItem</tt> of
	  type <tt>signed_tree_head_v2</tt>.
	  If a log is still accepting entries, this value should not be provided.</dd>
        </dl>
        <t><xref target="JSON.Metadata" format="default"/> is an example of a metadata format
	that includes the above	elements.</t>
      </section>
      <section anchor="evaluating-submissions" numbered="true" toc="default">
        <name>Evaluating Submissions</name>
        <t>A log determines whether to accept or reject a submission by evaluating it
against the minimum acceptance criteria (see <xref target="minimum_criteria" format="default"/>) and against
the log's discretionary acceptance criteria (see <xref target="discretionary_criteria" format="default"/>).</t>
        <t>If the acceptance criteria are met, the log <bcp14>SHOULD</bcp14> accept the submission. (A log
may decide, for example, to temporarily reject acceptable submissions to protect
itself against denial-of-service attacks.)</t>
        <t>The log <bcp14>SHALL</bcp14> allow retrieval of its list of accepted trust anchors (see
<xref target="get-anchors" format="default"/>), each of which is a root or intermediate CA certificate. This
list might usefully be the union of root certificates trusted by major browser
vendors.</t>
        <section anchor="minimum_criteria" numbered="true" toc="default">
          <name>Minimum Acceptance Criteria</name>
          <t>To ensure that logged certificates and precertificates are attributable to an
accepted trust anchor, to set clear expectations for what monitors would
find in the log, and to avoid being overloaded by invalid submissions, the log
<bcp14>MUST</bcp14> reject a submission if any of the following conditions are not met:</t>
          <ul spacing="normal">
            <li>The <tt>submission</tt>, <tt>type</tt>, and <tt>chain</tt> inputs
	    <bcp14>MUST</bcp14> be set as described in
	    <xref target="submit-entry" format="default"/>. The log <bcp14>MUST NOT</bcp14>
	    accommodate misordered CA certificates or
	    use any other source of intermediate CA certificates to attempt certification
	    path construction.</li>
            <li>
	      <t>Each of the zero or more intermediate CA certificates in the chain
	      <bcp14>MUST</bcp14> have one or both of the following features:</t>
              <ul spacing="normal">
                <li>The Basic Constraints extension with the cA boolean asserted.</li>
                <li>The Key Usage extension with the keyCertSign bit asserted.</li>
              </ul>
            </li>
            <li>Each certificate in the chain <bcp14>MUST</bcp14> fall within the limits
	    imposed by the zero
	    or more Basic Constraints pathLenConstraint values found higher up the chain.</li>
            <li>Precertificate submissions <bcp14>MUST</bcp14> conform to all of the
	    requirements in
	    <xref target="precertificates" format="default"/>.</li>
          </ul>
        </section>
        <section anchor="discretionary_criteria" numbered="true" toc="default">
          <name>Discretionary Acceptance Criteria</name>
          <t>If the minimum acceptance criteria are met but the submission is not fully
	  valid according to <xref target="RFC5280" format="default"/> verification rules
	  (e.g., the certificate or
	  precertificate has expired, is not yet valid, has been revoked, exhibits ASN.1
	  DER encoding errors but the log can still parse it, etc.), then the acceptability
	  of the submission is left to the log's discretion. It is useful for logs to
	  accept such submissions in order to accommodate quirks of CA certificate-issuing
	  software and to facilitate monitoring of CA compliance with applicable policies
	  and technical standards. However, it is impractical for this document to
	  enumerate, and for logs to consider, all of the ways that a submission might
	  fail to comply with <xref target="RFC5280" format="default"/>.</t>
          <t>Logs <bcp14>SHOULD</bcp14> limit the length of chain they will accept. The
	  maximum chain length is one of the log's parameters (see <xref
	  target="log_parameters" format="default"/>).</t>
        </section>
      </section>
      <section anchor="log_entries" numbered="true" toc="default">
        <name>Log Entries</name>
        <t>If a submission is accepted and an SCT is issued, the accepting log <bcp14>MUST</bcp14> store the
entire chain used for verification. This chain <bcp14>MUST</bcp14> include the certificate or
precertificate itself, the zero or more intermediate CA certificates provided by
the submitter, and the trust anchor used to verify the chain (even if it was
omitted from the submission). The log <bcp14>MUST</bcp14> provide this chain for auditing upon
request (see <xref target="get-entries" format="default"/>) so that the CA cannot avoid blame by
logging a partial or empty chain.
Each log entry is a <tt>TransItem</tt> structure of type <tt>x509_entry_v2</tt> or
<tt>precert_entry_v2</tt>. However, a log may store its entries in any format. If a
log does not store this <tt>TransItem</tt> in full, it must store the <tt>timestamp</tt>
and <tt>sct_extensions</tt> of the corresponding <tt>TimestampedCertificateEntryDataV2</tt>
structure. The <tt>TransItem</tt> can be reconstructed from these fields and the entire
chain that the log used to verify the submission.</t>
      </section>
      <section anchor="log_id" numbered="true" toc="default">
        <name>Log ID</name>
        <t>Each log is identified by an OID, which is one of the log's parameters (see
<xref target="log_parameters" format="default"/>) and which <bcp14>MUST NOT</bcp14> be used to identify any other log. A
log's operator <bcp14>MUST</bcp14> either allocate the OID themselves or request an OID from
the Log ID registry (see <xref target="log_id_registry" format="default"/>).
One way to get an OID arc, from which OIDs can be allocated, is to request
a Private Enterprise Number from IANA by completing the
<eref target="https://pen.iana.org/pen/PenApplication.page">registration form</eref>.
The only advantage of the registry is that the DER encoding can be small.
(Recall that OID allocations do not require a central registration, although
logs will most likely want to make themselves known to potential clients
through out-of-band means.)
Various data structures include
the DER encoding of this OID, excluding the ASN.1 tag and length bytes, in an
opaque vector:</t>
<sourcecode type="tls-presentation"><![CDATA[
    opaque LogID<2..127>;
]]></sourcecode>
        <t>Note that the ASN.1 length and the opaque vector length are identical in size (1
byte) and value, so the full DER encoding (including the tag and length)
of the OID can be reproduced simply by
prepending an OBJECT IDENTIFIER tag (0x06) to the opaque vector length and
contents.</t>
        <t>The OID used to identify a log is limited such that the DER encoding of its
value, excluding the tag and length, <bcp14>MUST</bcp14> be no longer than 127 octets.</t>
      </section>
      <section anchor="transitem-structure" numbered="true" toc="default">
        <name>TransItem Structure</name>
        <t>Various data structures are encapsulated in the <tt>TransItem</tt> structure to ensure
that the type and version of each one is identified in a common fashion:</t>
<sourcecode type="tls-presentation"><![CDATA[
    enum {
        x509_entry_v2(0x0100), precert_entry_v2(0x0101),
        x509_sct_v2(0x0102), precert_sct_v2(0x0103),
        signed_tree_head_v2(0x0104), consistency_proof_v2(0x0105),
        inclusion_proof_v2(0x0106),

        /* Reserved Code Points */
        reserved_rfc6962(0x0000..0x00FF),
        reserved_experimentaluse(0xE000..0xEFFF),
        reserved_privateuse(0xF000..0xFFFF),
        (0xFFFF)
    } VersionedTransType;

    struct {
        VersionedTransType versioned_type;
        select (versioned_type) {
            case x509_entry_v2: TimestampedCertificateEntryDataV2;
            case precert_entry_v2: TimestampedCertificateEntryDataV2;
            case x509_sct_v2: SignedCertificateTimestampDataV2;
            case precert_sct_v2: SignedCertificateTimestampDataV2;
            case signed_tree_head_v2: SignedTreeHeadDataV2;
            case consistency_proof_v2: ConsistencyProofDataV2;
            case inclusion_proof_v2: InclusionProofDataV2;
        } data;
    } TransItem;
]]></sourcecode>
        <t><tt>versioned_type</tt> is a value from the IANA registry in <xref target="versioned_trans_types" format="default"/>
that identifies the type of the encapsulated data structure and the earliest
version of this protocol to which it conforms. This document is v2.</t>
        <t><tt>data</tt> is the encapsulated data structure. The various structures named with the
<tt>DataV2</tt> suffix are defined in later sections of this document.</t>
        <t>Note that <tt>VersionedTransType</tt> combines the v1 type enumerations
<tt>Version</tt>, <tt>LogEntryType</tt>, <tt>SignatureType</tt>, and <tt>MerkleLeafType</tt> <xref target="RFC6962" format="default"/>. Note also that
v1 did not define <tt>TransItem</tt>, but this document provides guidelines (see
<xref target="v1_coexistence" format="default"/>) on how v2 implementations can coexist with v1
implementations.</t>
        <t>Future versions of this protocol may reuse <tt>VersionedTransType</tt> values defined
in this document as long as the corresponding data structures are not modified
and may add new <tt>VersionedTransType</tt> values for new or modified data structures.</t>
      </section>
      <section anchor="log-artifact-extensions" numbered="true" toc="default">
        <name>Log Artifact Extensions</name>
<sourcecode type="tls-presentation"><![CDATA[
    enum {
        reserved(65535)
    } ExtensionType;

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;
]]></sourcecode>
        <t>The <tt>Extension</tt> structure provides a generic extensibility for log artifacts,
including SCTs (<xref target="sct" format="default"/>) and STHs
(<xref target="sth" format="default"/>). The interpretation of the <tt>extension_data</tt> field is determined solely
by the value of the <tt>extension_type</tt> field.</t>
        <t>This document does not define any extensions, but it does establish a registry
for future <tt>ExtensionType</tt> values (see <xref target="log_artifact_extension_registry" format="default"/>).
Each document that registers a new <tt>ExtensionType</tt> must specify the context in
which it may be used (e.g., SCT, STH, or both) and describe how to interpret the
corresponding <tt>extension_data</tt>.</t>
      </section>
      <section anchor="tree_leaves" numbered="true" toc="default">
        <name>Merkle Tree Leaves</name>
        <t>The leaves of a log's Merkle Tree correspond to the log's entries (see
<xref target="log_entries" format="default"/>). Each leaf is the leaf hash (<xref target="mht" format="default"/>) of a <tt>TransItem</tt>
structure of type <tt>x509_entry_v2</tt> or <tt>precert_entry_v2</tt>, which encapsulates a
<tt>TimestampedCertificateEntryDataV2</tt> structure. Note that leaf hashes are
calculated as <tt>HASH(0x00 || TransItem)</tt>, where the hash algorithm is one of the
log's parameters.</t>
<sourcecode type="tls-presentation"><![CDATA[
    opaque TBSCertificate<1..2^24-1>;

    struct {
        uint64 timestamp;
        opaque issuer_key_hash<32..2^8-1>;
        TBSCertificate tbs_certificate;
        Extension sct_extensions<0..2^16-1>;
    } TimestampedCertificateEntryDataV2;
]]></sourcecode>
        <t><tt>timestamp</tt> is the date and time at which the certificate or precertificate
	was accepted by the log, in the form of a 64-bit unsigned number of milliseconds
	elapsed since the Unix Epoch (1 January 1970 00:00:00 UTC -- see <xref
	target="UNIXTIME" format="default"/>),
	ignoring leap seconds, in network byte order. Note that the leaves of a log's
	Merkle Tree are not required to be in strict chronological order.</t>
        <t><tt>issuer_key_hash</tt> is the HASH of the public key of the CA that issued the
certificate or precertificate, calculated over the DER encoding of the key
represented as SubjectPublicKeyInfo <xref target="RFC5280" format="default"/>. This is needed to bind the CA to
the certificate or precertificate, making it impossible for the corresponding
SCT to be valid for any other certificate or precertificate whose TBSCertificate
matches <tt>tbs_certificate</tt>. The length of the <tt>issuer_key_hash</tt> <bcp14>MUST</bcp14> match
HASH_SIZE.</t>
        <t><tt>tbs_certificate</tt> is the DER-encoded TBSCertificate from the submission.
	(Note that a precertificate's TBSCertificate can be reconstructed from the
	corresponding certificate, as described in <xref
	target="reconstructing_tbscertificate" format="default"/>).</t>
        <t><tt>sct_extensions</tt> is byte-for-byte identical to the SCT extensions of the
	corresponding SCT.</t>
        <t>The type of the <tt>TransItem</tt> corresponds to the value of the <tt>type</tt> parameter
supplied in the <xref target="submit-entry" format="default"/> call.</t>
      </section>
      <section anchor="sct" numbered="true" toc="default">
        <name>Signed Certificate Timestamp (SCT)</name>
        <t>An SCT is a <tt>TransItem</tt> structure of type <tt>x509_sct_v2</tt> or <tt>precert_sct_v2</tt>,
which encapsulates a <tt>SignedCertificateTimestampDataV2</tt> structure:</t>
<sourcecode type="tls-presentation"><![CDATA[
    struct {
        LogID log_id;
        uint64 timestamp;
        Extension sct_extensions<0..2^16-1>;
        opaque signature<1..2^16-1>;
    } SignedCertificateTimestampDataV2;
]]></sourcecode>
        <t><tt>log_id</tt> is this log's unique ID, encoded in an opaque vector, as described
	in <xref target="log_id" format="default"/>.</t>
        <t><tt>timestamp</tt> is equal to the timestamp from the corresponding
	<tt>TimestampedCertificateEntryDataV2</tt> structure.</t>
        <t><tt>sct_extensions</tt> is a vector of 0 or more SCT extensions. This vector
	<bcp14>MUST NOT</bcp14> include more than one extension with the same
	<tt>extension_type</tt>. The
	extensions in the vector <bcp14>MUST</bcp14> be ordered by the value of the
	<tt>extension_type</tt> field, smallest value first.
	All SCT extensions are similar to noncritical X.509v3 extensions (i.e.,
	the <tt>mustUnderstand</tt> field is not set), and a recipient <bcp14>SHOULD</bcp14>
	ignore any extension it does not understand.
	Furthermore, an implementation <bcp14>MAY</bcp14> choose to ignore any extension(s)
	that it does understand.</t>
        <t><tt>signature</tt> is computed over a <tt>TransItem</tt> structure of type
	<tt>x509_entry_v2</tt> or <tt>precert_entry_v2</tt> (see <xref target="tree_leaves"
	format="default"/>) using the signature algorithm
	declared in the log's parameters (see <xref target="log_parameters"
	format="default"/>).</t>
      </section>
      <section anchor="tree_head" numbered="true" toc="default">
        <name>Merkle Tree Head</name>
        <t>The log stores information about its Merkle Tree in a <tt>TreeHeadDataV2</tt>:</t>
<sourcecode type="tls-presentation"><![CDATA[
    opaque NodeHash<32..2^8-1>;

    struct {
        uint64 timestamp;
        uint64 tree_size;
        NodeHash root_hash;
        Extension sth_extensions<0..2^16-1>;
    } TreeHeadDataV2;
]]></sourcecode>
        <t>The length of NodeHash <bcp14>MUST</bcp14> match HASH_SIZE of the log.</t>
        <t><tt>timestamp</tt> is the current date and time, using the format defined in
<xref target="tree_leaves" format="default"/>.</t>
        <t><tt>tree_size</tt> is the number of entries currently in the log's Merkle Tree.</t>
        <t><tt>root_hash</tt> is the root of the Merkle Tree.</t>
        <t><tt>sth_extensions</tt> is a vector of 0 or more STH extensions. This vector <bcp14>MUST NOT</bcp14>
include more than one extension with the same <tt>extension_type</tt>. The
extensions in the vector <bcp14>MUST</bcp14> be ordered by the value of the
<tt>extension_type</tt> field, smallest value first. If an implementation sees an
extension that it does not understand, it <bcp14>SHOULD</bcp14> ignore that extension.
Furthermore, an implementation <bcp14>MAY</bcp14> choose to ignore any extension(s) that it
does understand.</t>
      </section>
      <section anchor="sth" numbered="true" toc="default">
        <name>Signed Tree Head (STH)</name>
        <t>Periodically, each log <bcp14>SHOULD</bcp14> sign its current tree head
	information (see <xref target="tree_head" format="default"/>) to produce an STH. When
	a client requests a log's latest STH (see
	<xref target="get-sth" format="default"/>), the log <bcp14>MUST</bcp14> return an STH
	that is no older than the log's MMD.
	However, since STHs could be used to mark individual clients (by producing a new
	STH for each query), a log <bcp14>MUST NOT</bcp14> produce STHs more frequently than
	its parameters declare (see <xref target="log_parameters" format="default"/>). In
	general, there is no need to
	produce a new STH unless there are new entries in the log; however, in the event
	that a log does not accept any submissions during an MMD period, the log
	<bcp14>MUST</bcp14> sign the same Merkle Tree Hash with a fresh timestamp.</t>
        <t>An STH is a <tt>TransItem</tt> structure of type <tt>signed_tree_head_v2</tt>,
	which encapsulates a <tt>SignedTreeHeadDataV2</tt> structure:</t>
<sourcecode type="tls-presentation"><![CDATA[
    struct {
        LogID log_id;
        TreeHeadDataV2 tree_head;
        opaque signature<1..2^16-1>;
    } SignedTreeHeadDataV2;
]]></sourcecode>
        <t><tt>log_id</tt> is this log's unique ID encoded in an opaque vector, as described
	in <xref target="log_id" format="default"/>.</t>
        <t>The <tt>timestamp</tt> in <tt>tree_head</tt> <bcp14>MUST</bcp14> be at least as
	recent as the most recent SCT
	timestamp in the tree. Each subsequent timestamp <bcp14>MUST</bcp14> be more recent
	than the timestamp of the previous update.</t>
        <t><tt>tree_head</tt> contains the latest tree head information (see <xref target="tree_head" format="default"/>).</t>
        <t><tt>signature</tt> is computed over the <tt>tree_head</tt> field using the signature algorithm
declared in the log's parameters (see <xref target="log_parameters" format="default"/>).</t>
      </section>
      <section anchor="merkle-consistency-proofs" numbered="true" toc="default">
        <name>Merkle Consistency Proofs</name>
        <t>To prepare a Merkle consistency proof for distribution to clients, the log
produces a <tt>TransItem</tt> structure of type <tt>consistency_proof_v2</tt>, which
encapsulates a <tt>ConsistencyProofDataV2</tt> structure:</t>
<sourcecode type="tls-presentation"><![CDATA[
    struct {
        LogID log_id;
        uint64 tree_size_1;
        uint64 tree_size_2;
        NodeHash consistency_path<0..2^16-1>;
    } ConsistencyProofDataV2;
]]></sourcecode>
        <t><tt>log_id</tt> is this log's unique ID encoded in an opaque vector, as described
	in <xref target="log_id" format="default"/>.</t>
        <t><tt>tree_size_1</tt> is the size of the older tree.</t>
        <t><tt>tree_size_2</tt> is the size of the newer tree.</t>
        <t><tt>consistency_path</tt> is a vector of Merkle Tree nodes proving the consistency
	of two STHs, as described in <xref target="consistency" format="default"/>.</t>
      </section>
      <section anchor="merkle-inclusion-proofs" numbered="true" toc="default">
        <name>Merkle Inclusion Proofs</name>
        <t>To prepare a Merkle inclusion proof for distribution to clients, the log
produces a <tt>TransItem</tt> structure of type <tt>inclusion_proof_v2</tt>, which
encapsulates an <tt>InclusionProofDataV2</tt> structure:</t>
<sourcecode type="tls-presentation"><![CDATA[
    struct {
        LogID log_id;
        uint64 tree_size;
        uint64 leaf_index;
        NodeHash inclusion_path<0..2^16-1>;
    } InclusionProofDataV2;
]]></sourcecode>
        <t><tt>log_id</tt> is this log's unique ID encoded in an opaque vector, as described
	in <xref target="log_id" format="default"/>.</t>
        <t><tt>tree_size</tt> is the size of the tree on which this inclusion proof is
	based.</t>
        <t><tt>leaf_index</tt> is the 0-based index of the log entry corresponding to this
inclusion proof.</t>
        <t><tt>inclusion_path</tt> is a vector of Merkle Tree nodes proving the inclusion of the
chosen certificate or precertificate, as described in <xref target="merkle_inclusion_proof" format="default"/>.</t>
      </section>
      <section anchor="log_shutdown" numbered="true" toc="default">
        <name>Shutting Down a Log</name>
        <t>Log operators may decide to shut down a log for various reasons, such as
deprecation of the signature algorithm. If there are entries in the log for
certificates that have not yet expired, simply making TLS clients stop
recognizing that log will have the effect of invalidating SCTs from that log.
In order to avoid that, the following actions <bcp14>SHOULD</bcp14> be taken:</t>
        <ul spacing="normal">
          <li>Make it known to clients and monitors that the log will be frozen.
	  This is not part of the API, so it will have to be done via a relevant
	  out-of-band mechanism.</li>
          <li>Stop accepting new submissions (the error code "shutdown" should be returned
	  for such requests).</li>
          <li>Once MMD from the last accepted submission has passed and all pending
	  submissions are incorporated, issue a final STH and publish it as one of the
	  log's parameters. Having an STH with a timestamp that is after the MMD has
	  passed from the last SCT issuance allows clients to audit this log regularly
	  without special handling for the final STH. At this point, the log's private
	  key is no longer needed and can be destroyed.</li>
          <li>Keep the log running until the certificates in all of its entries have expired
	  or exist in other logs (this can be determined by scanning other logs or
	  connecting to domains mentioned in the certificates and inspecting the SCTs
	  served).</li>
        </ul>
      </section>
    </section>
    <section anchor="client_messages" numbered="true" toc="default">
      <name>Log Client Messages</name>
      <t>Messages are sent as HTTPS GET or POST requests. Parameters for POSTs and all
responses are encoded as JavaScript Object Notation (JSON) objects <xref target="RFC8259" format="default"/>.
Parameters for GETs are encoded as order-independent key/value URL parameters,
using the "application/x-www-form-urlencoded" format described in the "HTML 4.01
Specification" <xref target="HTML401" format="default"/>. Binary data is base64 encoded according to
<xref target="RFC4648" sectionFormat="of" section="4"/>, as specified
in the individual messages.</t>
      <t>Clients are configured with a log's base URL, which is one of the log's
parameters. Clients construct URLs for requests by appending suffixes to this
base URL. This structure places some degree of restriction on how log operators
can deploy these services, as noted in <xref target="RFC8820" format="default"/>. However, operational
experience with version 1 of this protocol has not indicated that these
restrictions are a problem in practice.</t>
      <t>Note that JSON objects and URL parameters may contain fields not specified here
to allow for experimentation. Any fields that are not understood <bcp14>SHOULD</bcp14>
be ignored.</t>
      <t>In practice, log servers may include multiple front-end machines. Since it is
impractical to keep these machines in perfect sync, errors that are 
caused by skew between the machines may occur. Where such errors are possible, the
front end will return additional information (as specified below), making it
possible for clients to make progress, if progress is possible. Front ends <bcp14>MUST</bcp14>
only serve data that is free of gaps (that is, for example, no front end will
respond with an STH unless it is also able to prove consistency from all log
entries logged within that STH).</t>
      <t>For example, when a consistency proof between two STHs is requested, the
front end reached may not yet be aware of one or both STHs. In the case where it
is unaware of both, it will return the latest STH it is aware of. Where it is
aware of the first but not the second, it will return the latest STH it is aware
of and a consistency proof from the first STH to the returned STH. The case
where it knows the second but not the first should not arise (see the "no gaps"
requirement above).</t>
      <t>If the log is unable to process a client's request, it <bcp14>MUST</bcp14> return an HTTP
response code of 4xx/5xx (see <xref target="RFC7231" format="default"/>), and, in place of the responses
outlined in the subsections below, the body <bcp14>SHOULD</bcp14> be a JSON problem details
object (see <xref target="RFC7807" sectionFormat="of" section="3"/>) containing:</t>
      <dl newline="false" spacing="normal">
        <dt>type:</dt>
        <dd>A URN reference identifying the problem. To facilitate automated response
	to errors, this document defines a set of standard tokens for use in the
	<tt>type</tt> field within the URN namespace of: "urn:ietf:params:trans:error:".</dd>
        <dt>detail:</dt>
        <dd>A human-readable string describing the error that prevented the log from
	processing the request, ideally with sufficient detail to enable the error to
	be rectified.</dd>
      </dl>
      <t>For example, in response to a request of
<tt>&lt;Base URL&gt;/ct/v2/get-entries?start=100&amp;end=99</tt>, the log would return a
<tt>400 Bad Request</tt> response code with a body similar to the following:</t>
<sourcecode type="json"><![CDATA[
    {
        "type": "urn:ietf:params:trans:error:endBeforeStart",
        "detail": "'start' cannot be greater than 'end'"
    }
]]></sourcecode>
      <t>Most error types are specific to the type of request and are defined in the
respective subsections below. The one exception is the "malformed" error type,
which indicates that the log server could not parse the client's request because
it did not comply with this document:</t>
      <table align="center">
        <thead>
          <tr>
            <th align="left">type</th>
            <th align="left">detail</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">malformed</td>
            <td align="left">The request could not be parsed.</td>
          </tr>
        </tbody>
      </table>
      <t>Clients <bcp14>SHOULD</bcp14> treat <tt>500 Internal Server Error</tt> and <tt>503
      Service Unavailable</tt>
      responses as transient failures and <bcp14>MAY</bcp14> retry the same request without
      modification at a later date. Note that in the case of a 503 response, the log 
      <bcp14>MAY</bcp14> include a <tt>Retry-After</tt> header field per <xref target="RFC7231" format="default"/> in
      order to request a minimum time for the client to wait before retrying the request.
      In the absence of this header field, this document does not specify a minimum.</t>
      <t>Clients <bcp14>SHOULD</bcp14> treat any 4xx error as a problem with the request and
      not attempt to resubmit without some modification to the request. The full
      status code <bcp14>MAY</bcp14> provide additional details.</t>
      <t>This document deliberately does not provide more specific guidance
      on the use of HTTP status codes.</t>
      <section anchor="submit-entry" numbered="true" toc="default">
        <name>Submit Entry to Log</name>
        <t>POST &lt;Base URL&gt;/ct/v2/submit-entry</t>
        <dl newline="true" spacing="normal">
          <dt>Inputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>submission:</dt>
              <dd>The base64-encoded certificate or precertificate.</dd>
              <dt>type:</dt>
              <dd>The <tt>VersionedTransType</tt> integer value that indicates the type of the
	      <tt>submission</tt>: 1 for <tt>x509_entry_v2</tt> or 2 for
	      <tt>precert_entry_v2</tt>.</dd>
              <dt>chain:</dt>
              <dd>An array of zero or more JSON strings,
	      each of which is a base64-encoded CA certificate. The first element
	      is the certifier of the <tt>submission</tt>, the second certifies the first,
	      etc. The last element of <tt>chain</tt> (or, if <tt>chain</tt> is an empty
	      array, the <tt>submission</tt>) is certified by an accepted trust anchor.</dd>
            </dl>
          </dd>
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>sct:</dt>
              <dd><t>A base64-encoded <tt>TransItem</tt> of type <tt>x509_sct_v2</tt> or
	      <tt>precert_sct_v2</tt>, signed by this log, that corresponds to the
	      <tt>submission</tt>.</t></dd>
	    </dl>
              <t>If the submitted entry is immediately appended to (or already exists in) this
	      log's tree, then the log <bcp14>SHOULD</bcp14> also output:</t>
	      <dl newline="false" spacing="normal" indent="3">
              <dt>sth:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>signed_tree_head_v2</tt>
	      signed by this log.</dd>
              <dt>inclusion:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>inclusion_proof_v2</tt>
	      whose <tt>inclusion_path</tt> array of Merkle Tree nodes proves the inclusion
	      of the <tt>submission</tt> in the returned <tt>sth</tt>.</dd>
            </dl>
          </dd>
        </dl>
        <t>Error codes:</t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">type</th>
              <th align="left">detail</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">badSubmission</td>
              <td align="left">
                <tt>submission</tt> is neither a valid certificate nor a valid precertificate.</td>
            </tr>
            <tr>
              <td align="left">badType</td>
              <td align="left">
                <tt>type</tt> is neither 1 nor 2.</td>
            </tr>
            <tr>
              <td align="left">badChain</td>
              <td align="left">The first element of <tt>chain</tt> is not the certifier of the <tt>submission</tt>, or the second element does not certify the first, etc.</td>
            </tr>
            <tr>
              <td align="left">badCertificate</td>
              <td align="left">One or more certificates in <tt>chain</tt> are not valid (e.g., not properly encoded).</td>
            </tr>
            <tr>
              <td align="left">unknownAnchor</td>
              <td align="left">The last element of <tt>chain</tt> (or, if <tt>chain</tt> is an empty array, the <tt>submission</tt>) is not, nor is it certified by, an accepted trust anchor.</td>
            </tr>
            <tr>
              <td align="left">shutdown</td>
              <td align="left">The log is no longer accepting submissions.</td>
            </tr>
          </tbody>
        </table>
        <t>If the version of <tt>sct</tt> is not v2, then a v2 client may be unable to verify the
signature. It <bcp14>MUST NOT</bcp14> construe this as an error. This is to avoid forcing an
upgrade of compliant v2 clients that do not use the returned SCTs.</t>
        <t>If a log detects bad encoding in a chain that otherwise verifies correctly, then
the log <bcp14>MUST</bcp14> either log the certificate or return the "badCertificate" error.
If the certificate is logged, an SCT <bcp14>MUST</bcp14> be issued. Logging the certificate is
useful, because monitors (<xref target="monitor" format="default"/>) can then detect these encoding errors,
which may be accepted by some TLS clients.</t>
        <t>If <tt>submission</tt> is an accepted trust anchor whose certifier is neither an
accepted trust anchor nor the first element of <tt>chain</tt>, then the log <bcp14>MUST</bcp14> return
the "unknownAnchor" error. A log is not able to generate an SCT for a
submission if it
does not have access to the issuer's public key.</t>
        <t>If the returned <tt>sct</tt> is intended to be provided to TLS clients, then <tt>sth</tt> and
<tt>inclusion</tt> (if returned) <bcp14>SHOULD</bcp14> also be provided to TLS clients. For
example, if
<tt>type</tt> was 2 (indicating <tt>precert_sct_v2</tt>), then all three <tt>TransItem</tt>s could be
embedded in the certificate.</t>
      </section>
      <section anchor="get-sth" numbered="true" toc="default">
        <name>Retrieve Latest STH</name>
        <t>GET &lt;Base URL&gt;/ct/v2/get-sth</t>
        <t>No inputs.</t>
        <dl newline="true" spacing="normal">
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>sth:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>signed_tree_head_v2</tt>
	      signed by this log that is no older than the log's MMD.</dd>
            </dl>
          </dd>
        </dl>
      </section>
      <section anchor="get-sth-consistency" numbered="true" toc="default">
        <name>Retrieve Merkle Consistency Proof between Two STHs</name>
        <t>GET &lt;Base URL&gt;/ct/v2/get-sth-consistency</t>
        <dl newline="true" spacing="normal">
          <dt>Inputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>first:</dt>
	      <dd>The <tt>tree_size</tt> of the older tree, in decimal.</dd>
              <dt>second:</dt>
	      <dd>The <tt>tree_size</tt> of the newer tree, in decimal (optional).</dd>
            </dl>
          <t>Both tree sizes must be from existing v2 STHs. However, because of skew, the
	  receiving front end may not know one or both of the existing STHs. If both are
	  known, then only the <tt>consistency</tt> output is returned. If the first is known
	  but the second is not (or has been omitted), then the latest known STH is
	  returned, along with a consistency proof between the first STH and the latest.
	  If neither are known, then the latest known STH is returned without a
	  consistency proof.</t>
        </dd>
	</dl>
        <dl newline="true" spacing="normal">
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>consistency:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>consistency_proof_v2</tt>
	      whose <tt>tree_size_1</tt> <bcp14>MUST</bcp14> match the <tt>first</tt> input.
	      If the <tt>sth</tt> output is omitted,
	      then <tt>tree_size_2</tt> <bcp14>MUST</bcp14> match the <tt>second</tt> input.
	      If <tt>first</tt> and <tt>second</tt> are equal and correspond to a known STH,
	      the returned consistency proof <bcp14>MUST</bcp14> be empty (a
	      <tt>consistency_path</tt> array with zero elements).</dd>
              <dt>sth:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>signed_tree_head_v2</tt>,
	      signed by this log.</dd>
            </dl>
          <t>Note that no signature is required for the <tt>consistency</tt> output, as it is
	  used to verify the consistency between two signed STHs.</t>
	  </dd>
	</dl>
        <t>Error codes:</t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">type</th>
              <th align="left">detail</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">firstUnknown</td>
              <td align="left"><tt>first</tt> is before the latest known STH but is not from
	      an existing STH.</td>
            </tr>
            <tr>
              <td align="left">secondUnknown</td>
              <td align="left"><tt>second</tt> is before the latest known STH but is not from
	      an existing STH.</td>
            </tr>
            <tr>
              <td align="left">secondBeforeFirst</td>
              <td align="left"><tt>second</tt> is smaller than <tt>first</tt>.</td>
            </tr>
          </tbody>
        </table>
        <t>See <xref target="verify_consistency" format="default"/> for an outline of how to use the <tt>consistency</tt>
output.</t>
      </section>
      <section anchor="get-proof-by-hash" numbered="true" toc="default">
        <name>Retrieve Merkle Inclusion Proof from Log by Leaf Hash</name>
        <t>GET &lt;Base URL&gt;/ct/v2/get-proof-by-hash</t>
        <dl newline="true" spacing="normal">
          <dt>Inputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>hash:</dt>
              <dd>A base64-encoded v2 leaf hash.</dd>
              <dt>tree_size:</dt>
	      <dd>The <tt>tree_size</tt> of the tree on which to base the proof, in decimal.</dd>
            </dl>
          <t>The <tt>hash</tt> must be calculated as defined in <xref target="tree_leaves"
	  format="default"/>. A v2 STH must
	  exist for the <tt>tree_size</tt>.  Because of skew, the front end may not know
	  the requested tree head. In that case, it will return the latest STH it knows, along
	  with an inclusion proof to that STH. If the front end knows the requested tree head,
	  then only <tt>inclusion</tt> is returned.</t>
        </dd>
	</dl>
        <dl newline="true" spacing="normal">
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>inclusion:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>inclusion_proof_v2</tt>
	      whose <tt>inclusion_path</tt> array of Merkle Tree nodes proves the inclusion
	      of the certificate (as specified by the <tt>hash</tt> parameter) in the
	      selected STH.</dd>
              <dt>sth:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>signed_tree_head_v2</tt>,
	      signed by this log.</dd>
            </dl>
            <t>Note that no signature is required for the <tt>inclusion</tt> output, as it is
	    used to verify inclusion in the selected STH, which is signed.</t>
	  </dd>
	</dl>
        <t>Error codes:</t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">type</th>
              <th align="left">detail</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">hashUnknown</td>
              <td align="left">
                <tt>hash</tt> is not the hash of a known leaf (may be caused by skew or by a known certificate not yet merged).</td>
            </tr>
            <tr>
              <td align="left">treeSizeUnknown</td>
              <td align="left">
                <tt>hash</tt> is before the latest known STH but is not from an existing STH.</td>
            </tr>
          </tbody>
        </table>
        <t>See <xref target="verify_inclusion" format="default"/> for an outline of how to use the <tt>inclusion</tt> output.</t>
      </section>
      <section anchor="get-all-by-hash" numbered="true" toc="default">
        <name>Retrieve Merkle Inclusion Proof, STH, and Consistency Proof by Leaf Hash</name>
        <t>GET &lt;Base URL&gt;/ct/v2/get-all-by-hash</t>
        <dl newline="true" spacing="normal">
          <dt>Inputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>hash:</dt>
              <dd>A base64-encoded v2 leaf hash.</dd>
              <dt>tree_size:</dt>
	      <dd>The <tt>tree_size</tt> of the tree on which to base the proofs, in decimal.</dd>
            </dl>
            <t>The <tt>hash</tt> must be calculated as defined in <xref target="tree_leaves"
	  format="default"/>. A v2 STH must exist for the <tt>tree_size</tt>.</t>
	  </dd>
        </dl>
        <t>Because of skew, the front end may not know the requested tree head or the
	requested hash, which leads to a number of cases:</t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">Case</th>
              <th align="left">Response</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">latest STH &lt; requested tree head</td>
              <td align="left">Return latest STH.</td>
            </tr>
            <tr>
              <td align="left">latest STH &gt; requested tree head</td>
              <td align="left">Return latest STH and a consistency proof between it and the requested tree head (see <xref target="get-sth-consistency" format="default"/>).</td>
            </tr>
            <tr>
              <td align="left">index of requested hash &lt; latest STH</td>
              <td align="left">Return <tt>inclusion</tt>.</td>
            </tr>
          </tbody>
        </table>
        <t>Note that more than one case can be true; in which case, the returned data is
their union. It is also possible for none to be true; in which case, the
front end <bcp14>MUST</bcp14> return an empty response.</t>
        <dl newline="true" spacing="normal">
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>inclusion:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>inclusion_proof_v2</tt>
	      whose <tt>inclusion_path</tt> array of Merkle Tree nodes proves the inclusion
	      of the certificate (as specified by the <tt>hash</tt> parameter) in the
	      selected STH.</dd>
              <dt>sth:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>signed_tree_head_v2</tt>,
	      signed by this log.</dd>
              <dt>consistency:</dt>
              <dd>A base64-encoded <tt>TransItem</tt> of type <tt>consistency_proof_v2</tt>
	      that proves the consistency of the requested tree head and the returned
	      STH.</dd>
            </dl>
            <t>Note that no signature is required for the <tt>inclusion</tt> or
	    <tt>consistency</tt> outputs, as they are used to verify inclusion in and
	    consistency of signed STHs.</t>
          </dd>
        </dl>
        <t>Errors are the same as in <xref target="get-proof-by-hash" format="default"/>.</t>
        <t>See <xref target="verify_inclusion" format="default"/> for an outline of how to use the <tt>inclusion</tt> output,
and see <xref target="verify_consistency" format="default"/> for an outline of how to use the <tt>consistency</tt>
output.</t>
      </section>
      <section anchor="get-entries" numbered="true" toc="default">
        <name>Retrieve Entries and STH from Log</name>
        <t>GET &lt;Base URL&gt;/ct/v2/get-entries</t>
        <dl newline="true" spacing="normal">
          <dt>Inputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>start:</dt>
              <dd>0-based index of first entry to retrieve, in decimal.</dd>
              <dt>end:</dt>
              <dd>0-based index of last entry to retrieve, in decimal.</dd>
            </dl>
          </dd>
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>entries:</dt>
              <dd>
                <t>An array of objects, each consisting of:</t>
                <dl newline="false" spacing="normal">
                  <dt>log_entry:</dt>
                  <dd>The base64-encoded <tt>TransItem</tt> structure of type
		  <tt>x509_entry_v2</tt> or
		  <tt>precert_entry_v2</tt> (see <xref target="log_entries"
		  format="default"/>).</dd>
                  <dt>submitted_entry:</dt>
                  <dd>JSON object equivalent to inputs that were submitted to
		  <tt>submit-entry</tt>, with the addition of the trust anchor to the
		  <tt>chain</tt> field if the submission did not include it.</dd>
                  <dt>sct:</dt>
                  <dd>The base64-encoded <tt>TransItem</tt> of type <tt>x509_sct_v2</tt> or
		  <tt>precert_sct_v2</tt>, corresponding to this log entry.</dd>
		  <dt>sth:</dt>
		  <dd>A base64-encoded <tt>TransItem</tt> of type
		  <tt>signed_tree_head_v2</tt>, signed by this log.</dd>
                </dl>
              </dd>
            </dl>
          </dd>
        </dl>
        <t>Note that this message is not signed -- the <tt>entries</tt> data can be verified by
constructing the Merkle Tree Hash corresponding to a retrieved STH. All leaves
<bcp14>MUST</bcp14> be v2. However, a compliant v2 client <bcp14>MUST NOT</bcp14> construe an unrecognized
<tt>TransItem</tt> type as an error. This means it may be unable to parse some entries,
but note that each client can inspect the entries it does recognize as well as
verify the integrity of the data by treating unrecognized leaves as opaque input
to the tree.</t>
        <t>The <tt>start</tt> and <tt>end</tt> parameters <bcp14>SHOULD</bcp14> be within the range 0 &lt;= x &lt; <tt>tree_size</tt>,
as returned by <tt>get-sth</tt> in <xref target="get-sth" format="default"/>.</t>
        <t>The <tt>start</tt> parameter <bcp14>MUST</bcp14> be less than or equal to the <tt>end</tt> parameter.</t>
        <t>Each <tt>submitted_entry</tt> output parameter <bcp14>MUST</bcp14> include the trust anchor that the
log used to verify the <tt>submission</tt>, even if that trust anchor was not provided
to <tt>submit-entry</tt> (see <xref target="submit-entry" format="default"/>). If the <tt>submission</tt> does not certify
itself, then the first element of <tt>chain</tt> <bcp14>MUST</bcp14> be present and <bcp14>MUST</bcp14> certify the
<tt>submission</tt>.</t>
        <t>Log servers <bcp14>MUST</bcp14> honor requests where 0 &lt;= <tt>start</tt> &lt; <tt>tree_size</tt> and <tt>end</tt> &gt;=
<tt>tree_size</tt> by returning a partial response covering only the valid entries in
the specified range. <tt>end</tt> &gt;= <tt>tree_size</tt> could be caused by skew. Note that the
following restriction may also apply:</t>
        <t>Logs <bcp14>MAY</bcp14> restrict the number of entries that can be retrieved per <tt>get-entries</tt>
request. If a client requests more than the permitted number of entries, the log
<bcp14>SHALL</bcp14> return the maximum number of entries permissible. These entries <bcp14>SHALL</bcp14> be
sequential beginning with the entry specified by <tt>start</tt>.
Note that a limit on the number of entries is not immutable, and therefore
the restriction may be changed or lifted at any time and is not listed
with the other Log Parameters in <xref target="log_parameters" format="default"/>.</t>
        <t>Because of skew, it is possible the log server will not have any entries between
<tt>start</tt> and <tt>end</tt>. In this case, it <bcp14>MUST</bcp14> return an empty <tt>entries</tt> array.</t>
        <t>In any case, the log server <bcp14>MUST</bcp14> return the latest STH it knows about.</t>
        <t>See <xref target="verify_hash" format="default"/> for an outline of how to use a complete list of <tt>log_entry</tt>
entries to verify the <tt>root_hash</tt>.</t>
        <t>Error codes:</t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">type</th>
              <th align="left">detail</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">startUnknown</td>
              <td align="left">
                <tt>start</tt> is greater than the number of entries in the Merkle Tree.</td>
            </tr>
            <tr>
              <td align="left">endBeforeStart</td>
              <td align="left">
                <tt>start</tt> cannot be greater than <tt>end</tt>.</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="get-anchors" numbered="true" toc="default">
        <name>Retrieve Accepted Trust Anchors</name>
        <t>GET &lt;Base URL&gt;/ct/v2/get-anchors</t>
        <t>No inputs.</t>
        <dl newline="true" spacing="normal">
          <dt>Outputs:</dt>
          <dd>
            <dl newline="false" spacing="normal">
              <dt>certificates:</dt>
              <dd>An array of JSON strings, each of which
	      is a base64-encoded CA certificate that is acceptable to the log.</dd>
              <dt>max_chain_length:</dt>
              <dd>If the server has chosen to limit the length of chains it accepts, this is
	      the maximum number of certificates in the chain, in decimal. If there is no
	      limit, this is omitted.</dd>
            </dl>
	    <t>This data is not signed, and the protocol depends on the security guarantees
	    of TLS to ensure correctness.</t>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="tls_servers" numbered="true" toc="default">
      <name>TLS Servers</name>
      <t>CT-using TLS servers <bcp14>MUST</bcp14> use at least one of the mechanisms described below
to present one or more SCTs from one or more logs to each TLS client during full
TLS handshakes, when requested by the client, where each SCT corresponds to the server certificate.
(Of course, a server can only send a TLS extension if the client has
specified it first.)
Servers
<bcp14>SHOULD</bcp14> also present corresponding inclusion proofs and STHs.</t>
      <t>A server can provide SCTs using
a TLS 1.3 extension (<xref target="RFC8446" sectionFormat="of" section="4.2"/>) with type <tt>transparency_info</tt>
(see <xref target="tls_transinfo_extension" format="default"/>). This mechanism allows TLS servers to
participate in CT without the cooperation of CAs, unlike the other two
mechanisms. It also allows SCTs and inclusion proofs to be updated on the fly.</t>
      <t>The server may also use an Online Certificate Status Protocol (OCSP)
<xref target="RFC6960" format="default"/> response extension (see <xref target="ocsp_transinfo_extension" format="default"/>),
providing the OCSP response as part of the TLS handshake. Providing
a response during a TLS handshake is popularly known as "OCSP stapling".
For TLS
1.3, the information is encoded as an extension in the <tt>status_request</tt>
extension data; see <xref target="RFC8446" sectionFormat="of" section="4.4.2.1"/>. For TLS 1.2 <xref target="RFC5246" format="default"/>, the information
is encoded in the <tt>CertificateStatus</tt> message; see <xref target="RFC6066" sectionFormat="of" section="8"/>.  Using stapling also
allows SCTs and inclusion proofs to be updated on the fly.</t>
      <t>CT information can also be encoded as an extension in the X.509v3 certificate
(see <xref target="cert_transinfo_extension" format="default"/>). This
mechanism allows the use of unmodified TLS servers, but the SCTs and inclusion
proofs cannot be updated on the fly. Since the logs from which the SCTs and
inclusion proofs originated won't necessarily be accepted by TLS clients for
the full lifetime of the certificate, there is a risk that TLS clients may
subsequently consider the certificate to be noncompliant. In such an event, one of
the other two mechanisms will need to be used to deliver CT information, or, if this is
not possible, the certificate will need to be reissued.</t>
      <section anchor="tls-client-authentication" numbered="true" toc="default">
        <name>TLS Client Authentication</name>
        <t>This specification includes no description of how a TLS server can
use CT for TLS client certificates.
While this may be useful, it is not documented here for the following
reasons:</t>
        <ul spacing="normal">
          <li>The greater security exposure is for clients to end up interacting with an
	  illegitimate server.</li>
          <li>In general, TLS client certificates are not expected to be submitted to
	  CT logs, particularly those intended for general public use.</li>
        </ul>
        <t>A future version could include such information.</t>
      </section>
      <section anchor="multiple-scts" numbered="true" toc="default">
        <name>Multiple SCTs</name>
        <t>CT-using TLS servers <bcp14>SHOULD</bcp14> send SCTs from multiple logs because:</t>
        <ul spacing="normal">
          <li>The set of logs trusted by TLS clients is neither unified nor static; each
          client vendor may maintain an independent list of trusted logs, and, over time, new logs
          may become trusted and current logs may become distrusted.
	  Note that client discovery, trust, and distrust of logs are expected to
	  be handled out of band and are out of scope of this document.</li>
          <li>If a CA and a log collude, it is possible to temporarily hide misissuance from
	  clients. When a TLS client requires SCTs from multiple logs to be provided, it
	  is more difficult to mount this attack.</li>
          <li>If a log misbehaves or suffers a key compromise, a consequence may be that
	  clients cease to trust it. Since the time an SCT may be in use can be
	  considerable (several years is common in current practice when embedded in a
	  certificate), including SCTs from multiple logs reduces the probability of the
	  certificate being rejected by TLS clients.</li>
          <li>TLS clients may have policies related to the above risks requiring TLS servers
	  to present multiple SCTs. For example, at the time of writing, Chromium
	  <xref target="Chromium.Log.Policy" format="default"/> requires multiple SCTs to be
	  presented with Extended Validation (EV)
	  certificates in order for the EV indicator to be shown.</li>
        </ul>
        <t>To select the logs from which to obtain SCTs, a TLS server can, for example,
examine the set of logs popular TLS clients accept and recognize.</t>
      </section>
      <section anchor="transitemlist-structure" numbered="true" toc="default">
        <name>TransItemList Structure</name>
        <t>Multiple SCTs, inclusion proofs, and indeed <tt>TransItem</tt> structures of any
	type are combined into a list as follows:</t>
<sourcecode type="tls-presentation"><![CDATA[
      opaque SerializedTransItem<1..2^16-1>;

      struct {
          SerializedTransItem trans_item_list<1..2^16-1>;
      } TransItemList;
]]></sourcecode>
        <t>Here, <tt>SerializedTransItem</tt> is an opaque byte string that contains the
	serialized <tt>TransItem</tt> structure. This encoding ensures that TLS clients can
	decode each <tt>TransItem</tt> individually (so, for example, if there is a version
	upgrade, out-of-date clients can still parse old <tt>TransItem</tt> structures while
	skipping over new <tt>TransItem</tt> structures whose versions they don't
	understand).</t>
      </section>
      <section anchor="presenting_transitems" numbered="true" toc="default">
        <name>Presenting SCTs, Inclusions Proofs, and STHs</name>
        <t>In each <tt>TransItemList</tt> that is sent during a TLS handshake, the TLS
server <bcp14>MUST</bcp14> include a <tt>TransItem</tt> structure of type <tt>x509_sct_v2</tt> or
<tt>precert_sct_v2</tt>.</t>
        <t>Presenting inclusion proofs and STHs in the TLS handshake helps to protect the
client's privacy (see <xref target="fetching_inclusion_proofs" format="default"/>) and reduces load on log
servers. Therefore, if the TLS server can obtain them, it <bcp14>SHOULD</bcp14> also include
<tt>TransItem</tt>s of type <tt>inclusion_proof_v2</tt> and <tt>signed_tree_head_v2</tt> in the
<tt>TransItemList</tt>.</t>
      </section>
      <section anchor="tls_transinfo_extension" numbered="true" toc="default">
        <name>transparency_info TLS Extension</name>
        <t>Provided that a TLS client includes the <tt>transparency_info</tt> extension type in
the ClientHello and the TLS server supports the <tt>transparency_info</tt> extension:</t>
        <ul spacing="normal">
          <li>The TLS server <bcp14>MUST</bcp14> verify that the received
	  <tt>extension_data</tt> is empty.</li>
          <li>The TLS server <bcp14>MUST</bcp14> construct a <tt>TransItemList</tt> of
	  relevant <tt>TransItem</tt>s (see
	  <xref target="presenting_transitems" format="default"/>), which
	  <bcp14>SHOULD</bcp14> omit any <tt>TransItem</tt>s that are
	  already embedded in the server certificate or the stapled OCSP response (see
	  <xref target="x509v3_transinfo_extension" format="default"/>). If the constructed
	  <tt>TransItemList</tt> is not
	  empty, then the TLS server <bcp14>MUST</bcp14> include the
	  <tt>transparency_info</tt> extension with
	  the <tt>extension_data</tt> set to this <tt>TransItemList</tt>. If the list is
	  empty, then the server <bcp14>SHOULD</bcp14> omit the <tt>extension_data</tt>
	  element but <bcp14>MAY</bcp14> send it with an empty array.</li>
        </ul>
        <t>TLS servers <bcp14>MUST</bcp14> only include this extension in the following messages:</t>
        <ul spacing="normal">
          <li>the ServerHello message (for TLS 1.2 or earlier)</li>
          <li>the Certificate or CertificateRequest message (for TLS 1.3)</li>
        </ul>
        <t>TLS servers <bcp14>MUST NOT</bcp14> process or include this extension when a TLS session is
resumed, since session resumption uses the original session information.</t>
      </section>
    </section>
    <section anchor="certification-authorities" numbered="true" toc="default">
      <name>Certification Authorities</name>
      <section anchor="x509v3_transinfo_extension" numbered="true" toc="default">
        <name>Transparency Information X.509v3 Extension</name>
        <t>The Transparency Information X.509v3 extension, which has OID 1.3.101.75 and
	<bcp14>SHOULD</bcp14> be noncritical, contains one or more <tt>TransItem</tt>
	structures in a <tt>TransItemList</tt>. This extension <bcp14>MAY</bcp14> be
	included in OCSP responses (see
	<xref target="ocsp_transinfo_extension" format="default"/>) and certificates (see
	<xref target="cert_transinfo_extension" format="default"/>). Since <xref
	target="RFC5280" format="default"/> requires the <tt>extnValue</tt> field (an
	OCTET STRING) of each X.509v3 extension to include the DER encoding of an ASN.1
	value, a <tt>TransItemList</tt> <bcp14>MUST NOT</bcp14> be included directly.
	Instead, it <bcp14>MUST</bcp14> be
	wrapped inside an additional OCTET STRING, which is then put into the
	<tt>extnValue</tt> field:</t>
<sourcecode type="asn.1"><![CDATA[
    TransparencyInformationSyntax ::= OCTET STRING
]]></sourcecode>
        <t><tt>TransparencyInformationSyntax</tt> contains a <tt>TransItemList</tt>.</t>
        <section anchor="ocsp_transinfo_extension" numbered="true" toc="default">
          <name>OCSP Response Extension</name>
          <t>A certification authority <bcp14>MAY</bcp14> include a Transparency Information
	  X.509v3 extension in the <tt>singleExtensions</tt> of a <tt>SingleResponse</tt> in
	  an OCSP response. All included SCTs and inclusion proofs <bcp14>MUST</bcp14> be for
	  the certificate identified by the <tt>certID</tt> of that <tt>SingleResponse</tt>
	  or for a precertificate that corresponds to that certificate.</t>
        </section>
        <section anchor="cert_transinfo_extension" numbered="true" toc="default">
          <name>Certificate Extension</name>
          <t>A certification authority <bcp14>MAY</bcp14> include a Transparency Information X.509v3
extension in a certificate. All included SCTs and inclusion proofs <bcp14>MUST</bcp14> be for a
precertificate that corresponds to this certificate.</t>
        </section>
      </section>
      <section anchor="tls-feature-x509v3-extension" numbered="true" toc="default">
        <name>TLS Feature X.509v3 Extension</name>
        <t>A certification authority <bcp14>SHOULD NOT</bcp14> issue any certificate that identifies the
<tt>transparency_info</tt> TLS extension in a TLS feature extension <xref target="RFC7633" format="default"/>, because
TLS servers are not required to support the <tt>transparency_info</tt> TLS extension in
order to participate in CT (see <xref target="tls_servers" format="default"/>).</t>
      </section>
    </section>
    <section anchor="clients" numbered="true" toc="default">
      <name>Clients</name>
      <t>There are various different functions clients of logs might perform. We describe
      here some typical clients and how they should function. Any inconsistency may be
      used as evidence that a log has not behaved correctly, and the signatures on the
      data structures prevent the log from denying that misbehavior.</t>
      <t>All clients need various parameters in order to communicate with logs and verify
      their responses. These parameters are described in <xref target="log_parameters"
      format="default"/>, but note
      that this document does not describe how the parameters are obtained, which is
      implementation dependent (for example, see <xref target="Chromium.Policy"
      format="default"/>).</t>
      <section anchor="tls_clients" numbered="true" toc="default">
        <name>TLS Client</name>
        <section anchor="receiving_transitems" numbered="true" toc="default">
          <name>Receiving SCTs and Inclusion Proofs</name>
          <t>TLS clients receive SCTs and inclusion proofs alongside or in certificates.
	  CT-using TLS clients <bcp14>MUST</bcp14> implement all of the three mechanisms by
	  which TLS servers may present SCTs (see <xref target="tls_servers"
	  format="default"/>).</t>
          <t>TLS clients that support the <tt>transparency_info</tt> TLS extension
	  (see <xref target="tls_transinfo_extension" format="default"/>)
	  <bcp14>SHOULD</bcp14> include it in ClientHello messages,
	  with empty <tt>extension_data</tt>. If a TLS server includes the
	  <tt>transparency_info</tt> TLS extension when resuming a TLS session, the TLS
	  client <bcp14>MUST</bcp14> abort the handshake.</t>
        </section>
        <section anchor="reconstructing_tbscertificate" numbered="true" toc="default">
          <name>Reconstructing the TBSCertificate</name>
          <t>Validation of an SCT for a certificate (where the <tt>type</tt> of the <tt>TransItem</tt> is
<tt>x509_sct_v2</tt>) uses the unmodified TBSCertificate component of the certificate.</t>
          <t>Before an SCT for a precertificate (where the <tt>type</tt> of the <tt>TransItem</tt> is
<tt>precert_sct_v2</tt>) can be validated, the TBSCertificate component of the
precertificate needs to be reconstructed from the TBSCertificate component of
the certificate as follows:</t>
          <ul spacing="normal">
            <li>Remove the Transparency Information extension
	    (see <xref target="x509v3_transinfo_extension" format="default"/>).</li>
            <li>Remove embedded v1 SCTs, identified by OID 1.3.6.1.4.1.11129.2.4.2 (see
	    <xref target="RFC6962" sectionFormat="of" section="3.3"/>). This allows embedded
	    v1 and v2 SCTs to co-exist in
	    a certificate (see <xref target="v1_coexistence" format="default"/>).</li>
          </ul>
        </section>
        <section anchor="validating-scts" numbered="true" toc="default">
          <name>Validating SCTs</name>
          <t>In order to make use of a received SCT, the TLS client <bcp14>MUST</bcp14> first validate it as
follows:</t>
          <ul spacing="normal">
            <li>
              <t>Compute the signature input by constructing a <tt>TransItem</tt> of type
	      <tt>x509_entry_v2</tt> or <tt>precert_entry_v2</tt>, depending on the SCT's
	      <tt>TransItem</tt>
	      type. The <tt>TimestampedCertificateEntryDataV2</tt> structure is constructed
	      in the following manner:
              </t>
              <ul spacing="normal">
                <li><tt>timestamp</tt> is copied from the SCT.</li>
                <li><tt>tbs_certificate</tt> is the reconstructed TBSCertificate portion of
		the server certificate, as described in <xref
		target="reconstructing_tbscertificate" format="default"/>.</li>
                <li><tt>issuer_key_hash</tt> is computed as described in <xref
		target="tree_leaves" format="default"/>.</li>
                <li><tt>sct_extensions</tt> is copied from the SCT.</li>
              </ul>
            </li>
            <li>Verify the SCT's <tt>signature</tt> against the computed signature input using the
public key of the corresponding log, which is identified by the <tt>log_id</tt>. The
required signature algorithm is one of the log's parameters.</li>
          </ul>
          <t>If the TLS client does not have the corresponding log's parameters, it cannot
attempt to validate the SCT. When evaluating compliance (see
<xref target="evaluating_compliance" format="default"/>), the TLS client will consider only those SCTs that it
was able to validate.</t>
          <t>Note that SCT validation is not a substitute for the normal validation of the
server certificate and its chain.</t>
        </section>
        <section anchor="fetching_inclusion_proofs" numbered="true" toc="default">
          <name>Fetching Inclusion Proofs</name>
          <t>When a TLS client has validated a received SCT but does not yet possess
a corresponding inclusion proof, the TLS client <bcp14>MAY</bcp14> request the inclusion
proof directly from a log using <tt>get-proof-by-hash</tt> (<xref target="get-proof-by-hash" format="default"/>) or
<tt>get-all-by-hash</tt> (<xref target="get-all-by-hash" format="default"/>).</t>
          <t>Note that fetching inclusion proofs directly from a log will disclose to the
log which TLS server the client has been communicating with. This may be
regarded as a significant privacy concern, and so it is preferable for the TLS
server to send the inclusion proofs (see <xref target="presenting_transitems" format="default"/>).</t>
        </section>
        <section anchor="validating_inclusion_proofs" numbered="true" toc="default">
          <name>Validating Inclusion Proofs</name>
          <t>When a TLS client has received, or fetched, an inclusion proof (and an STH),
it <bcp14>SHOULD</bcp14> proceed to verify the inclusion proof to the provided STH.
The TLS client <bcp14>SHOULD</bcp14> also verify consistency between the provided STH
and an STH it knows about.</t>
          <t>If the TLS client holds an STH that predates the SCT, it <bcp14>MAY</bcp14>, in the process of
auditing, request a new STH from the log (<xref target="get-sth" format="default"/>) and then verify it by
requesting a consistency proof (<xref target="get-sth-consistency" format="default"/>). Note that if the TLS
client uses <tt>get-all-by-hash</tt>, then it will already have the new STH.</t>
        </section>
        <section anchor="evaluating_compliance" numbered="true" toc="default">
          <name>Evaluating Compliance</name>
          <t>It is up to a client's local policy to specify the quantity and form of
evidence (SCTs, inclusion proofs, or a combination) needed to achieve
compliance and how to handle noncompliance.</t>
          <t>A TLS client can only evaluate compliance if it has given the TLS server the
opportunity to send SCTs and inclusion proofs by any of the three mechanisms
that are mandatory to implement for CT-using TLS clients (see
<xref target="receiving_transitems" format="default"/>). Therefore, a TLS client <bcp14>MUST NOT</bcp14> evaluate compliance
if it did not include both the <tt>transparency_info</tt> and <tt>status_request</tt> TLS
extensions in the ClientHello.</t>
        </section>
      </section>
      <section anchor="monitor" numbered="true" toc="default">
        <name>Monitor</name>
        <t>Monitors watch logs to check for correct behavior, for certificates of
interest, or for both. For example, a monitor may be configured to report on all
certificates that apply to a specific domain name when fetching new entries for
consistency validation.</t>
        <t>A monitor <bcp14>MUST</bcp14> at least inspect every new entry in every log it watches, and it
<bcp14>MAY</bcp14> also choose to keep copies of entire logs.</t>
        <t>To inspect all of the existing entries, the monitor <bcp14>SHOULD</bcp14> follow these steps
once for each log:</t>
        <ol spacing="normal" type="1">
	  <li>Fetch the current STH (<xref target="get-sth" format="default"/>).</li>
          <li>Verify the STH signature.</li>
          <li>Fetch all the entries in the tree corresponding to the STH (<xref
	  target="get-entries" format="default"/>).</li>
          <li>If applicable, check each entry to see if it's a certificate of interest.</li>
          <li>Confirm that the tree made from the fetched entries produces the same hash as
	  that in the STH.</li>
        </ol>
        <t>To inspect new entries, the monitor <bcp14>SHOULD</bcp14> follow these steps
	repeatedly for each log:</t>
        <ol spacing="normal" type="1">
	  <li>Fetch the current STH (<xref target="get-sth" format="default"/>). Repeat until
	  the STH changes. To allow for experimentation, this document does not specify the polling frequency.</li>
          <li>Verify the STH signature.</li>
          <li>Fetch all the new entries in the tree corresponding to the STH
	  (<xref target="get-entries" format="default"/>). If they remain unavailable for an
	  extended period, then this should be viewed as misbehavior on the part of the
	  log.</li>
          <li>If applicable, check each entry to see if it's a certificate of interest.</li>
          <li>
            <t>Either:</t>
            <ol spacing="normal" type="a">
	      <li>Verify that the updated list of all entries generates a tree with the
	      same hash as the new STH.</li>
            </ol>
            <t>Or, if it is not keeping all log entries:</t>
            <ol spacing="normal" type="a">
	      <li>Fetch a consistency proof for the new STH with the previous STH
	      (<xref target="get-sth-consistency" format="default"/>).</li>
              <li>Verify the consistency proof.</li>
              <li>Verify that the new entries generate the corresponding elements in the
	      consistency proof.</li>
            </ol>
          </li>
          <li>Repeat from Step 1.</li>
        </ol>
      </section>
      <section anchor="auditing" numbered="true" toc="default">
        <name>Auditing</name>
        <t>Auditing ensures that the current published state of a log is reachable from
previously published states that are known to be good and that the promises
made by the log, in the form of SCTs, have been kept. Audits are performed by
monitors or TLS clients.</t>
        <t>In particular, there are four properties of log behavior that should be checked:</t>
        <ul spacing="normal">
          <li>the Maximum Merge Delay (MMD)</li>
          <li>the STH Frequency Count</li>
          <li>the append-only property</li>
          <li>the consistency of the log view presented to all query sources</li>
        </ul>
        <t>A benign, conformant log publishes a series of STHs over time, each derived from
the previous STH and the submitted entries incorporated into the log since
publication of the previous STH. This can be proven through auditing of STHs.
SCTs returned to TLS clients can be audited by verifying against the
accompanying certificate and using Merkle inclusion proofs against the log's
Merkle Tree.</t>
        <t>The action taken by the auditor, if an audit fails, is not specified, but note
that in general, if an audit fails, the auditor is in possession of signed proof of
the log's misbehavior.</t>
        <t>A monitor (<xref target="monitor" format="default"/>) can audit by verifying the consistency of STHs it
receives, ensuring that each entry can be fetched and that the STH is indeed the
result of making a tree from all fetched entries.</t>
        <t>A TLS client (<xref target="tls_clients" format="default"/>) can audit by verifying an SCT against any STH
dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle
inclusion proof (<xref target="get-proof-by-hash" format="default"/>). It can also verify that the SCT
corresponds to the server certificate it arrived with (i.e., the log entry is
that certificate or is a precertificate corresponding to that certificate).</t>
        <t>Checking of the consistency of the log view presented to all entities is more
difficult to perform because it requires a way to share log responses among a
set of CT-using entities and is discussed in <xref target="misbehaving_logs" format="default"/>.</t>
      </section>
    </section>
    <section anchor="algorithm-agility" numbered="true" toc="default">
      <name>Algorithm Agility</name>
      <t>It is not possible for a log to change either of its algorithms part way through
its lifetime:</t>
      <dl newline="false" spacing="normal">
        <dt>Signature algorithm:</dt>
        <dd>SCT signatures must remain valid so signature algorithms can only be added,
	not removed.</dd>
        <dt>Hash algorithm:</dt>
        <dd>A log would have to support the old and new hash algorithms to allow
	backwards compatibility with clients that are not aware of a hash algorithm
	change.</dd>
      </dl>
      <t>Allowing multiple signature or hash algorithms for a log would require that all
data structures support it and would significantly complicate client
implementation, which is why it is not supported by this document.</t>
      <t>If it should become necessary to deprecate an algorithm used by a live log, then
the log <bcp14>MUST</bcp14> be frozen, as specified in <xref target="log_shutdown" format="default"/>, and a new log <bcp14>SHOULD</bcp14> be
started. Certificates in the frozen log that have not yet expired and require
new SCTs <bcp14>SHOULD</bcp14> be submitted to the new log and the SCTs from that log used
instead.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>The assignment policy criteria mentioned in this section refer to the policies
outlined in <xref target="RFC8126" format="default"/>.</t>
      <section anchor="additions-to-existing-registries" numbered="true" toc="default">
        <name>Additions to Existing Registries</name>
        <t>This subsection defines additions to existing registries.</t>
        <section anchor="new-entry-to-the-tls-extensiontype-registry" numbered="true" toc="default">
          <name>New Entry to the TLS ExtensionType Registry</name>
          <t>IANA has added the following entry
to the "TLS ExtensionType Values" registry defined in <xref target="RFC8446" format="default"/>,
with an assigned Value:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Value</th>
                <th align="left">Extension Name</th>
                <th align="left">TLS 1.3</th>
                <th align="left">DTLS-Only</th>
                <th align="left">Recommended</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">52</td>
                <td align="left">transparency_info</td>
                <td align="left">CH, CR, CT</td>
                <td align="left">N</td>
                <td align="left">Y</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section anchor="urn-sub-namespace-for-trans-urnietfparamstrans" numbered="true" toc="default">
          <name>URN Sub-namespace for TRANS (urn:ietf:params:trans)</name>
          <t>IANA has added a new entry in the
	  "IETF URN Sub-namespace for Registered Protocol Parameter Identifiers"
	  registry, following the template in <xref target="RFC3553" format="default"/>:</t>
	  <dl newline="false" spacing="compact">
            <dt>Registry name:</dt> 
	    <dd>trans</dd>
            <dt>Specification:</dt> 
	    <dd>RFC 9162</dd>
            <dt>Repository:</dt>
	    <dd><eref brackets="angle"
	    target="https://www.iana.org/assignments/trans"/></dd>
            <dt>Index value:</dt>
	    <dd>No transformation needed.</dd>
	  </dl>
        </section>
      </section>
      <section anchor="new-ct-related-registries" numbered="true" toc="default">
        <name>New CT-Related Registries</name>
        <t>IANA has added a new protocol registry, "Public Notary
Transparency", to the list that appears at
<eref brackets="angle" target="https://www.iana.org/assignments/"/></t>
        <t>The rest of this section defines the subregistries that have been created within the new "Public Notary Transparency" registry.</t>
        <section anchor="hash_algorithms" numbered="true" toc="default">
          <name>Hash Algorithms</name>
          <t>IANA has established a registry of hash algorithm values, named
"Hash Algorithms", with the following registration procedures:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Range</th>
                <th align="left">Registration Procedures</th>
              </tr>
            </thead>
            <tbody>
                <tr>
                  <td>0x00-0xDF</td>
                  <td>Specification Required</td>
                </tr>
                <tr>
                  <td>0xE0-0xEF</td>
                  <td>Experimental Use</td>
                </tr>
                <tr>
                  <td>0xF0-0xFF</td>
                  <td>Private Use</td>
                </tr>
            </tbody>
          </table>
          <t>The "Hash Algorithms" registry initially consists of:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Value</th>
                <th align="left">Hash Algorithm</th>
                <th align="left">OID</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">0x00</td>
                <td align="left">SHA-256</td>
                <td align="left">2.16.840.1.101.3.4.2.1</td>
                <td align="left">
                  <xref target="RFC6234" format="default"/></td>
              </tr>
              <tr>
                <td align="left">0x01 - 0xDF</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0xE0 - 0xEF</td>
                <td align="left">Reserved for Experimental Use</td>
                <td align="left">&nbsp;</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0xF0 - 0xFF</td>
                <td align="left">Reserved for Private Use</td>
                <td align="left">&nbsp;</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
          <t>The designated expert(s) should ensure that the proposed algorithm has a public
specification and is suitable for use as a cryptographic hash algorithm with no
known preimage or collision attacks. These attacks can damage the integrity of
the log.</t>
        </section>
        <section anchor="signature_algorithms" numbered="true" toc="default">
          <name>Signature Algorithms</name>
          <t>IANA has established a registry of signature algorithm values, named
"Signature Algorithms".</t>
          <t>The following notes have been added to the registry:</t>
            <blockquote>
              <dl newline="true">
                <dt><strong>Note:</strong></dt>
                <dd>This is a subset of the "TLS SignatureScheme" registry, limited to those
	    algorithms that are appropriate for CT. A major advantage of this is
	    leveraging the expertise of the TLS Working Group and its designated
	    expert(s).</dd>
              </dl>
            </blockquote>
            <blockquote>
              <dl newline="true">
                <dt><strong>Note:</strong></dt> 
                <dd>The value <tt>0x0403</tt> appears twice. While this may be confusing,
	    it is okay because the verification
	    process is the same for both algorithms, and the choice of which to use
	    when generating a signature is purely internal to the log server.</dd>
              </dl>
            </blockquote>
          <t>The "Signature Algorithms" registry has the following registration procedures:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Range</th>
                <th align="left">Registration Procedures</th>
              </tr>
            </thead>
            <tbody>
                <tr>
                  <td>0x0000-0x0807</td>
                  <td>Specification Required</td>
                </tr>
                <tr>
                  <td>0x0808-0xFDFF</td>
                  <td>Expert Review</td>
                </tr>
                <tr>
                  <td>0xFE00-0xFEFF</td>
                  <td>Experimental Use</td>
                </tr>
                <tr>
                  <td>0xFF00-0xFFFF</td>
                  <td>Private Use</td>
                </tr>
            </tbody>
          </table>

          <t>The "Signature Algorithms" registry initially consists of:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">SignatureScheme Value</th>
                <th align="left">Signature Algorithm</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">0x0000 - 0x0402</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
              </tr>
              <tr>
                <td align="left">ecdsa_secp256r1_sha256 (0x0403)</td>
                <td align="left">ECDSA (NIST P-256) with SHA-256</td>
                <td align="left">
                  <xref target="FIPS186-4" format="default"/></td>
              </tr>
              <tr>
                <td align="left">ecdsa_secp256r1_sha256 (0x0403)</td>
                <td align="left">Deterministic ECDSA (NIST P-256) with HMAC-SHA256</td>
                <td align="left">
                  <xref target="RFC6979" format="default"/></td>
              </tr>
              <tr>
                <td align="left">0x0404 - 0x0806</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
              </tr>
              <tr>
                <td align="left">ed25519 (0x0807)</td>
                <td align="left">Ed25519 (PureEdDSA with the edwards25519 curve)</td>
                <td align="left">
                  <xref target="RFC8032" format="default"/></td>
              </tr>
              <tr>
                <td align="left">0x0808 - 0xFDFF</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
              </tr>
              <tr>
                <td align="left">0xFE00 - 0xFEFF</td>
                <td align="left">Reserved for Experimental Use</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0xFF00 - 0xFFFF</td>
                <td align="left">Reserved for Private Use</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
          <t>The designated expert(s) should ensure that the proposed algorithm has a public
specification, has a value assigned to it in the "TLS SignatureScheme" registry
(which was established by <xref target="RFC8446" format="default"/>), and is suitable for use as a
cryptographic signature algorithm.</t>
        </section>
        <section anchor="versioned_trans_types" numbered="true" toc="default">
          <name>VersionedTransTypes</name>
          <t>IANA has established a registry of <tt>VersionedTransType</tt> values, named
"VersionedTransTypes".</t>
          <t>The following note has been added:</t>
          <blockquote>
          <dl newline="true">
            <dt><strong>Note:</strong></dt>
            <dd>The range 0x0000..0x00FF is reserved so that v1 SCTs are distinguishable from
	    v2 SCTs and other <tt>TransItem</tt> structures.</dd>
          </dl>
          </blockquote>
          <t>The registration procedures for the "VersionedTransTypes" registry are the following:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Range</th>
                <th align="left">Registration Procedures</th>
              </tr>
            </thead>
            <tbody>
                <tr>
                  <td>0x0100-0xDFFF</td>
                  <td>Specification Required</td>
                </tr>
                <tr>
                  <td>0xE000-0xEFFF</td>
                  <td>Experimental Use</td>
                </tr>
                <tr>
                  <td>0xF000-0xFFFF</td>
                  <td>Private Use</td>
                </tr>
            </tbody>
          </table>
          <t>The "VersionedTransTypes" registry initially consists of:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Value</th>
                <th align="left">Type and Version</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">0x0000 - 0x00FF</td>
                <td align="left">Reserved</td>
                <td align="left">
                  <xref target="RFC6962" format="default"/></td>
              </tr>
              <tr>
                <td align="left">0x0100</td>
                <td align="left">x509_entry_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0101</td>
                <td align="left">precert_entry_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0102</td>
                <td align="left">x509_sct_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0103</td>
                <td align="left">precert_sct_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0104</td>
                <td align="left">signed_tree_head_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0105</td>
                <td align="left">consistency_proof_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0106</td>
                <td align="left">inclusion_proof_v2</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0x0107 - 0xDFFF</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
              </tr>
              <tr>
                <td align="left">0xE000 - 0xEFFF</td>
                <td align="left">Reserved for Experimental Use</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0xF000 - 0xFFFF</td>
                <td align="left">Reserved for Private Use</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
          <t>The designated expert(s) should review the public specification to ensure that it is
detailed enough to ensure implementation interoperability.</t>
        </section>
        <section anchor="log_artifact_extension_registry" numbered="true" toc="default">
          <name>Log Artifact Extensions</name>
          <t>IANA has established a registry of <tt>ExtensionType</tt> values, named "Log
Artifact Extensions".</t>
          <t>The registration procedures for the "Log Artifact Extensions" registry are the following:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Range</th>
                <th align="left">Registration Procedures</th>
              </tr>
            </thead>
            <tbody>
                <tr>
                  <td>0x0000-0xDFFF</td>
                  <td>Specification Required</td>
                </tr>
                <tr>
                  <td>0xE000-0xEFFF</td>
                  <td>Experimental Use</td>
                </tr>
                <tr>
                  <td>0xF000-0xFFFF</td>
                  <td>Private Use</td>
                </tr>
            </tbody>
          </table>
          <t>The "Log Artifact Extensions" registry initially consists of:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">ExtensionType</th>
                <th align="left">Status</th>
                <th align="left">Use</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">0x0000 - 0xDFFF</td>
                <td align="left">Unassigned</td>
                <td align="left">n/a</td>
                <td align="left">&nbsp;</td>
              </tr>
              <tr>
                <td align="left">0xE000 - 0xEFFF</td>
                <td align="left">Reserved for Experimental Use</td>
                <td align="left">n/a</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">0xF000 - 0xFFFF</td>
                <td align="left">Reserved for Private Use</td>
                <td align="left">n/a</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
          <t>The "Use" column should contain one or both of the following values:</t>
          <ul spacing="normal">
            <li>"SCT", for extensions specified for use in Signed Certificate Timestamps.</li>
            <li>"STH", for extensions specified for use in Signed Tree Heads.</li>
          </ul>
          <t>The designated expert(s) should review the public specification to ensure that it is
detailed enough to ensure implementation interoperability. They should
also verify that the extension is appropriate to the contexts in which it is
specified to be used (SCT, STH, or both).</t>
        </section>
        <section anchor="log_id_registry" numbered="true" toc="default">
          <name>Log IDs</name>
          <t>IANA has established a registry of Log IDs, named "Log IDs".</t>
          <t>The registry's registration procedure is First Come First Served.</t>
          <t>The "Log IDs" registry initially consists of:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Log ID</th>
                <th align="left">Log Base URL</th>
                <th align="left">Log Operator</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">1.3.101.8192 - 1.3.101.16383</td>
                <td align="left">Unassigned</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
              </tr>
              <tr>
                <td align="left">1.3.101.80.0 - 1.3.101.80.*</td>
                <td align="left">Unassigned</td>
                <td align="left">Unassigned</td>
                <td align="left">&nbsp;</td>
              </tr>
            </tbody>
          </table>
          <t>The following notes have been added to the registry:</t>
          <blockquote>
          <dl newline="true">
            <dt><strong>Note:</strong></dt>
            <dd>All OIDs in the range from 1.3.101.8192 to 1.3.101.16383 have been set aside
for Log IDs.
This is a limited resource of 8,192 OIDs, each of which has an encoded length of
4 octets.</dd>
          </dl>
          </blockquote>
          <blockquote>
          <dl newline="true">
            <dt><strong>Note:</strong></dt>
            <dd>The 1.3.101.80 arc has also been set aside for Log IDs.
This is an unlimited resource, but only
the 128 OIDs from 1.3.101.80.0 to 1.3.101.80.127 have an encoded length of only
4 octets.</dd>
          </dl>
          </blockquote>
          <t>Each application for the allocation of a Log ID <bcp14>MUST</bcp14> be accompanied by:</t>
          <ul spacing="normal">
            <li>the Log's Base URL (see <xref target="log_parameters"
	    format="default"/>) and</li>
            <li>the Log Operator's contact details.</li>
          </ul>
          <t>IANA is asked to reject any request to update a Log ID or Log Base URL in this
registry because these fields are immutable (see <xref target="log_parameters" format="default"/>).</t>
          <t>IANA is asked to accept requests from log operators to update their contact
details in this registry.</t>
          <t>Since log operators can choose to not use this registry (see <xref target="log_id" format="default"/>), it is
not expected to be a global directory of all logs.</t>
        </section>
        <section anchor="error-types-registry" numbered="true" toc="default">
          <name>Error Types</name>
          <t>IANA has created a new registry for errors,
the "Error Types" registry.</t>
          <t>The registration procedure for this registry is Specification Required.</t>
          <t>This registry has the following three fields:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Field Name</th>
                <th align="left">Type</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">Identifier</td>
                <td align="left">string</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">Meaning</td>
                <td align="left">string</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">Reference</td>
                <td align="left">string</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
          <t>The initial values of the "Error Types" registry, which are taken from the text in <xref target="client_messages" format="default"/>, are as follows:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Identifier</th>
                <th align="left">Meaning</th>
                <th align="left">Reference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">malformed</td>
                <td align="left">The request could not be parsed.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">badSubmission</td>
                <td align="left"><tt>submission</tt> is neither a valid certificate nor a
		valid precertificate.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">badType</td>
                <td align="left"><tt>type</tt> is neither 1 nor 2.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">badChain</td>
                <td align="left">The first element of <tt>chain</tt> is not the certifier of
		the <tt>submission</tt>, or the second element does not certify the first,
		etc.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">badCertificate</td>
                <td align="left">One or more certificates in <tt>chain</tt> are not valid
		(e.g., not properly encoded).</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">unknownAnchor</td>
                <td align="left">The last element of <tt>chain</tt> (or, if <tt>chain</tt> is
		an empty array, the <tt>submission</tt>) is not, nor is it certified
		by, an accepted trust anchor.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">shutdown</td>
                <td align="left">The log is no longer accepting submissions.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">firstUnknown</td>
                <td align="left"><tt>first</tt> is before the latest known STH but is not
		from an existing STH.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">secondUnknown</td>
                <td align="left"><tt>second</tt> is before the latest known STH but is not
		from an existing STH.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">secondBeforeFirst</td>
                <td align="left"><tt>second</tt> is smaller than <tt>first</tt>.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">hashUnknown</td>
                <td align="left"><tt>hash</tt> is not the hash of a known leaf (may be caused
		by skew or by a known certificate not yet merged).</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">treeSizeUnknown</td>
                <td align="left"><tt>hash</tt> is before the latest known STH but is not from
		an existing STH.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">startUnknown</td>
                <td align="left"><tt>start</tt> is greater than the number of entries in the
		Merkle Tree.</td>
                <td align="left">RFC 9162</td>
              </tr>
              <tr>
                <td align="left">endBeforeStart</td>
                <td align="left"><tt>start</tt> cannot be greater than <tt>end</tt>.</td>
                <td align="left">RFC 9162</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="oid-assignment" numbered="true" toc="default">
        <name>OID Assignment</name>
        <t>IANA has assigned an object identifier from the "SMI
Security for PKIX Module Identifier" registry to identify the
ASN.1 module in <xref target="asn1_module" format="default"/> of this document.</t>
        <table align="center">
          <thead>
            <tr>
              <th align="left">Decimal</th>
              <th align="left">Description</th>
              <th align="left">References</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">102</td>
              <td align="left">id-mod-public-notary-v2</td>
              <td align="left">RFC 9162</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>With CAs, logs, and servers performing the actions described here, TLS clients
can use logs and signed timestamps to reduce the likelihood that they will
accept misissued certificates. If a server presents a valid signed timestamp for
a certificate, then the client knows that a log has committed to publishing the
certificate. From this, the client knows that monitors acting for the subject of
the certificate have had some time to notice the misissuance and take some
action, such as asking a CA to revoke a misissued certificate. A signed
timestamp does not guarantee this, though, since appropriate monitors might not
have checked the logs or the CA might have refused to revoke the certificate.</t>
      <t>In addition, if TLS clients will not accept unlogged certificates, then site
owners will have a greater incentive to submit certificates to logs, possibly
with the assistance of their CA, increasing the overall transparency of the
system.</t>
      <section anchor="misissued-certificates" numbered="true" toc="default">
        <name>Misissued Certificates</name>
        <t>Misissued certificates that have not been publicly logged, and thus do not have
a valid SCT, are not considered compliant. Misissued certificates that do have
an SCT from a log will appear in that public log within the Maximum Merge Delay,
assuming the log is operating correctly. Since a log is allowed to serve an STH
of any age up to the MMD, the maximum period of time during which a misissued
certificate can be used without being available for audit is twice the MMD.</t>
      </section>
      <section anchor="detection-of-misissue" numbered="true" toc="default">
        <name>Detection of Misissue</name>
        <t>The logs do not themselves detect misissued certificates; they rely instead on
interested parties, such as domain owners, to monitor them and take corrective
action when a misissue is detected.</t>
      </section>
      <section anchor="misbehaving_logs" numbered="true" toc="default">
        <name>Misbehaving Logs</name>
        <t>A log can misbehave in several ways. Examples include the following: failing to incorporate a
certificate with an SCT in the Merkle Tree within the MMD; presenting different,
conflicting views of the Merkle Tree at different times and/or to different
parties; issuing STHs too frequently; mutating the signature of a logged
certificate; and failing to present a chain containing the certifier of a logged
certificate.</t>
        <t>Violation of the MMD contract is detected by log clients requesting a Merkle
inclusion proof (<xref target="get-proof-by-hash" format="default"/>) for each observed SCT. These checks can
be asynchronous and need only be done once per certificate. However, note that
there may be privacy concerns (see <xref target="fetching_inclusion_proofs" format="default"/>).</t>
        <t>Violation of the append-only property or the STH issuance rate limit can be
	detected by multiple clients comparing their instances of the STHs.
	This technique, known as "gossip", is an active area of research and not
	defined here.
	Proof of misbehavior in such cases would be either a series of STHs that were
	issued too closely together, proving violation of the STH issuance rate limit,
	or an STH with a root hash that does not match the one calculated from a copy of
	the log, proving violation of the append-only property.</t>
        <t>Clients that report back SCTs can be tracked or traced if a log
produces multiple STHs or SCTs with the same timestamp and data but different
signatures. Logs <bcp14>SHOULD</bcp14> mitigate this risk by either:</t>
        <ul spacing="normal">
          <li>using deterministic signature schemes or</li>
          <li>producing no more than one SCT for each distinct submission and no more than one
	  STH for each distinct <tt>tree_size</tt>. Each of these SCTs and STHs can be stored by
	  the log and served to other clients that submit the same certificate or request
	  the same STH.</li>
        </ul>
      </section>
      <section anchor="requiring_multiple_scts" numbered="true" toc="default">
        <name>Multiple SCTs</name>
        <t>By requiring TLS servers to offer multiple SCTs, each from a different log, TLS
clients reduce the effectiveness of an attack where a CA and a log collude
(see <xref target="multiple-scts" format="default"/>).</t>
      </section>
      <section anchor="leakage-of-dns-information" numbered="true" toc="default">
        <name>Leakage of DNS Information</name>
        <t>Malicious monitors can use logs to learn about the existence of domain names
that might not otherwise be easy to discover. Some subdomain labels may reveal
information about the service and software for which the subdomain is used,
which in turn might facilitate targeted attacks.</t>
      </section>
    </section>

  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5652.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6066.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6960.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6979.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7633.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7807.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8391.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>

        <reference anchor="HTML401" target="https://www.w3.org/TR/2018/SPSD-html401-20180327">
          <front>
            <title>HTML 4.01 Specification</title>
            <author initials="D." surname="Raggett" fullname="David Raggett">
              <organization/>
            </author>
            <author initials="A." surname="Le Hors" fullname="Arnaud Le Hors">
              <organization/>
            </author>
            <author initials="I." surname="Jacobs" fullname="Ian Jacobs">
              <organization/>
            </author>
            <date year="2018" month="March"/>
          </front>
          <seriesInfo name="W3C Recommendation" value="SPSD-html401-20180327"/>
        </reference>

        <reference anchor="FIPS186-4" target="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">
          <front>
            <title>Digital Signature Standard (DSS)</title>
            <author>
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <date year="2013" month="July"/>
          </front>
	  <seriesInfo name="FIPS PUB" value="186-4"/>
        </reference>

        <reference anchor="UNIXTIME" target="http://pubs.opengroup.org/onlinepubs/9699919799.2016edition/basedefs/V1_chap04.html#tag_04_16">
          <front>
            <title>The Open Group Base Specifications Issue 7</title>
            <author>
              <organization>IEEE</organization>
            </author>
	    <date year="2016"/>
          </front>
	  <seriesInfo name="IEEE Std" value="1003.1-2008"/>
	  <refcontent>Section 4.16 Seconds Since the Epoch</refcontent>
        </reference>

        <reference anchor="X690">
          <front>
            <title>Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date year="2021" month="February"/>
          </front>
	  <seriesInfo name="ITU-T Recommendation" value="X.690"/>
          <seriesInfo name="ISO/IEC" value="8825-1"/>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3553.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6962.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8820.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5912.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6268.xml"/>

        <reference anchor="CrosbyWallach" target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf">
          <front>
            <title>Efficient Data Structures for Tamper-Evident Logging</title>
            <author initials="S." surname="Crosby" fullname="Scott A. Crosby">
              <organization/>
            </author>
            <author initials="D." surname="Wallach" fullname="Dan S. Wallach">
              <organization/>
            </author>
            <date year="2009" month="August"/>
          </front>
          <refcontent>Proceedings of the 18th USENIX Security Symposium, Montreal</refcontent>
        </reference>

        <reference anchor="Chromium.Policy" target="https://googlechrome.github.io/CertificateTransparency/ct_policy.html">
          <front>
            <title>Chromium Certificate Transparency Policy</title>
            <author>
              <organization>The Chromium Projects</organization>
            </author>
          </front>
        </reference>

        <reference anchor="JSON.Metadata" target="https://www.gstatic.com/ct/log_list/log_list_schema.json">
          <front>
            <title>Chromium Log Metadata JSON Schema</title>
            <author>
              <organization>The Chromium Projects</organization>
            </author>
          </front>
        </reference>

        <reference anchor="Chromium.Log.Policy" target="https://googlechrome.github.io/CertificateTransparency/log_policy.html">
          <front>
            <title>Chromium Certificate Transparency Log Policy</title>
            <author>
              <organization>The Chromium Projects</organization>
            </author>
          </front>
        </reference>

        <reference anchor="CABBR" target="https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.7.3.pdf">
          <front>
            <title>Baseline Requirements for the Issuance and Management of Publicly-Trusted Certificates</title>
            <author>
              <organization>CA/Browser Forum</organization>
            </author>
            <date month="October" year="2020"/>
          </front>
	  <seriesInfo name="Version" value="1.7.3"/>
        </reference>

        <reference anchor="X.680">
          <front>
            <title>Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date year="2021" month="February"/>
          </front>
          <seriesInfo name="ITU-T Recommendation" value="X.680"/>
        </reference>

      </references>
    </references>

    <section anchor="v1_coexistence" numbered="true" toc="default">
      <name>Supporting v1 and v2 Simultaneously (Informative)</name>
      <t>Certificate Transparency logs have to be either v1 (conforming to <xref target="RFC6962" format="default"/>) or
v2 (conforming to this document), as the data structures are incompatible, and so
a v2 log could not issue a valid v1 SCT.</t>
      <t>CT clients, however, can support v1 and v2 SCTs for the same certificate
simultaneously, as v1 SCTs are delivered in different TLS, X.509, and OCSP
extensions than v2 SCTs.</t>
      <t>v1 and v2 SCTs for X.509 certificates can be validated independently. For
precertificates, v2 SCTs should be embedded in the TBSCertificate before
submission of the TBSCertificate (inside a v1 precertificate, as described in
<xref target="RFC6962" sectionFormat="of" section="3.1"/>) to a v1 log so that TLS clients conforming to
<xref target="RFC6962" format="default"/> but not this document are oblivious to the embedded v2 SCTs. An issuer
can follow these steps to produce an X.509 certificate with embedded v1 and v2
SCTs:</t>
      <ul spacing="normal">
        <li>Create a CMS precertificate, as described in <xref target="precertificates"
	format="default"/>, and submit it to v2 logs.</li>
        <li>Embed the obtained v2 SCTs in the TBSCertificate, as described in
	<xref target="cert_transinfo_extension" format="default"/>.</li>
        <li>Use that TBSCertificate to create a v1 precertificate, as described in
	<xref target="RFC6962" sectionFormat="of" section="3.1"/>, and submit it to v1
	logs.</li>
        <li>Embed the v1 SCTs in the TBSCertificate, as described in
	<xref target="RFC6962" sectionFormat="of" section="3.3"/>.</li>
        <li>Sign that TBSCertificate (which now contains v1 and v2 SCTs) to issue the
	final X.509 certificate.</li>
      </ul>
    </section>
    <section anchor="asn1_module" numbered="true" toc="default">
      <name>An ASN.1 Module (Informative)</name>
      <t>The following ASN.1 <xref target="X.680" format="default"/> module may be useful to implementors. This module references <xref target="RFC5912" format="default"/> and <xref target="RFC6268" format="default"/>.</t>
<sourcecode type="asn.1"><![CDATA[
CertificateTransparencyV2Module-2021
 -- { id-mod-public-notary-v2 from above, in
        iso(1) identified-organization(3) ...
    form }
DEFINITIONS IMPLICIT TAGS ::= BEGIN

-- EXPORTS ALL --

IMPORTS
  EXTENSION
  FROM PKIX-CommonTypes-2009 -- RFC 5912
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkixCommon-02(57) }

  CONTENT-TYPE
  FROM CryptographicMessageSyntax-2010  -- RFC 6268
    { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
      pkcs-9(9) smime(16) modules(0) id-mod-cms-2009(58) }

  TBSCertificate
  FROM PKIX1Explicit-2009 -- RFC 5912
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-explicit-02(51) }
;

--
-- Section 3.2.  Precertificates
--

ct-tbsCertificate CONTENT-TYPE ::= {
  TYPE TBSCertificate
  IDENTIFIED BY id-ct-tbsCertificate }

id-ct-tbsCertificate OBJECT IDENTIFIER ::= { 1 3 101 78 }

--
-- Section 7.1.  Transparency Information X.509v3 Extension
--

ext-transparencyInfo EXTENSION ::= {
   SYNTAX TransparencyInformationSyntax
   IDENTIFIED BY id-ce-transparencyInfo
   CRITICALITY { FALSE } }

id-ce-transparencyInfo OBJECT IDENTIFIER ::= { 1 3 101 75 }

TransparencyInformationSyntax ::= OCTET STRING

--
-- Section 7.1.1.  OCSP Response Extension
--

ext-ocsp-transparencyInfo EXTENSION ::= {
   SYNTAX TransparencyInformationSyntax
   IDENTIFIED BY id-pkix-ocsp-transparencyInfo
   CRITICALITY { FALSE } }

id-pkix-ocsp-transparencyInfo OBJECT IDENTIFIER ::=
   id-ce-transparencyInfo

--
-- Section 8.1.2.  Reconstructing the TBSCertificate
--

ext-embeddedSCT-CTv1 EXTENSION ::= {
   SYNTAX SignedCertificateTimestampList
   IDENTIFIED BY id-ce-embeddedSCT-CTv1
   CRITICALITY { FALSE } }

id-ce-embeddedSCT-CTv1 OBJECT IDENTIFIER ::= {
   1 3 6 1 4 1 11129 2 4 2 }

SignedCertificateTimestampList ::= OCTET STRING

END

]]></sourcecode>
    </section>
    <section anchor="acknowledgements" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>The authors would like to thank <contact fullname="Erwann Abelea"/>, <contact
      fullname="Robin Alden"/>, <contact fullname="Andrew Ayer"/>, <contact fullname="Richard
      Barnes"/>, <contact fullname="Al Cutter"/>, <contact fullname="David Drysdale"/>,
      <contact fullname="Francis Dupont"/>, <contact fullname="Adam Eijdenberg"/>, <contact
      fullname="Stephen Farrell"/>, <contact fullname="Daniel Kahn Gillmor"/>, <contact
      fullname="Paul Hadfield"/>, <contact fullname="Brad Hill"/>, <contact fullname="Jeff
      Hodges"/>, <contact fullname="Paul
      Hoffman"/>, <contact fullname="Jeffrey Hutzelman"/>, <contact fullname="Kat Joyce"/>,
      <contact fullname="Emilia Kasper"/>, <contact fullname="Stephen Kent"/>, <contact
      fullname="Adam Langley"/>, <contact fullname="SM"/>, <contact fullname="Alexey
      Melnikov"/>, <contact fullname="Linus
      Nordberg"/>, <contact fullname="Chris Palmer"/>, <contact fullname="Trevor Perrin"/>,
      <contact fullname="Pierre Phaneuf"/>, <contact fullname="Eric Rescorla"/>, <contact
      fullname="Rich Salz"/>, <contact fullname="Melinda Shore"/>, <contact fullname="Ryan
      Sleevi"/>, <contact fullname="Martin Smith"/>, <contact fullname="Carl Wallace"/>,
      and <contact fullname="Paul Wouters"/> for their valuable contributions.</t>
      <t>A big thank you to Symantec for kindly donating the OIDs from the 1.3.101 arc
      that are used in this document.</t>
    </section>
  </back>
</rfc>
